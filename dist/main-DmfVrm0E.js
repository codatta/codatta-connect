var yR = Object.defineProperty;
var wR = (t, e, r) => e in t ? yR(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var Rs = (t, e, r) => wR(t, typeof e != "symbol" ? e + "" : e, r);
import * as Gt from "react";
import pv, { createContext as hc, useContext as Fn, useState as Er, useEffect as si, forwardRef as gv, createElement as jd, useId as mv, useCallback as vv, Component as xR, useLayoutEffect as _R, useRef as bi, useInsertionEffect as m5, useMemo as Oi, Fragment as v5, Children as ER, isValidElement as SR } from "react";
var gn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ts(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function bv(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(t, n);
    Object.defineProperty(r, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[n];
      }
    });
  }), r;
}
var Ym = { exports: {} }, df = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l2;
function AR() {
  if (l2) return df;
  l2 = 1;
  var t = pv, e = Symbol.for("react.element"), r = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(a, u, h) {
    var d, p = {}, x = null, A = null;
    h !== void 0 && (x = "" + h), u.key !== void 0 && (x = "" + u.key), u.ref !== void 0 && (A = u.ref);
    for (d in u) n.call(u, d) && !s.hasOwnProperty(d) && (p[d] = u[d]);
    if (a && a.defaultProps) for (d in u = a.defaultProps, u) p[d] === void 0 && (p[d] = u[d]);
    return { $$typeof: e, type: a, key: x, ref: A, props: p, _owner: i.current };
  }
  return df.Fragment = r, df.jsx = o, df.jsxs = o, df;
}
var pf = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h2;
function PR() {
  return h2 || (h2 = 1, process.env.NODE_ENV !== "production" && function() {
    var t = pv, e = Symbol.for("react.element"), r = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), a = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), x = Symbol.for("react.lazy"), A = Symbol.for("react.offscreen"), I = Symbol.iterator, N = "@@iterator";
    function L(U) {
      if (U === null || typeof U != "object")
        return null;
      var se = I && U[I] || U[N];
      return typeof se == "function" ? se : null;
    }
    var F = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function $(U) {
      {
        for (var se = arguments.length, he = new Array(se > 1 ? se - 1 : 0), xe = 1; xe < se; xe++)
          he[xe - 1] = arguments[xe];
        W("error", U, he);
      }
    }
    function W(U, se, he) {
      {
        var xe = F.ReactDebugCurrentFrame, Te = xe.getStackAddendum();
        Te !== "" && (se += "%s", he = he.concat([Te]));
        var Re = he.map(function(nt) {
          return String(nt);
        });
        Re.unshift("Warning: " + se), Function.prototype.apply.call(console[U], console, Re);
      }
    }
    var z = !1, V = !1, te = !1, R = !1, K = !1, pe;
    pe = Symbol.for("react.module.reference");
    function _e(U) {
      return !!(typeof U == "string" || typeof U == "function" || U === n || U === s || K || U === i || U === h || U === d || R || U === A || z || V || te || typeof U == "object" && U !== null && (U.$$typeof === x || U.$$typeof === p || U.$$typeof === o || U.$$typeof === a || U.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      U.$$typeof === pe || U.getModuleId !== void 0));
    }
    function Y(U, se, he) {
      var xe = U.displayName;
      if (xe)
        return xe;
      var Te = se.displayName || se.name || "";
      return Te !== "" ? he + "(" + Te + ")" : he;
    }
    function S(U) {
      return U.displayName || "Context";
    }
    function m(U) {
      if (U == null)
        return null;
      if (typeof U.tag == "number" && $("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof U == "function")
        return U.displayName || U.name || null;
      if (typeof U == "string")
        return U;
      switch (U) {
        case n:
          return "Fragment";
        case r:
          return "Portal";
        case s:
          return "Profiler";
        case i:
          return "StrictMode";
        case h:
          return "Suspense";
        case d:
          return "SuspenseList";
      }
      if (typeof U == "object")
        switch (U.$$typeof) {
          case a:
            var se = U;
            return S(se) + ".Consumer";
          case o:
            var he = U;
            return S(he._context) + ".Provider";
          case u:
            return Y(U, U.render, "ForwardRef");
          case p:
            var xe = U.displayName || null;
            return xe !== null ? xe : m(U.type) || "Memo";
          case x: {
            var Te = U, Re = Te._payload, nt = Te._init;
            try {
              return m(nt(Re));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var f = Object.assign, g = 0, b, w, _, E, v, M, P;
    function B() {
    }
    B.__reactDisabledLog = !0;
    function ue() {
      {
        if (g === 0) {
          b = console.log, w = console.info, _ = console.warn, E = console.error, v = console.group, M = console.groupCollapsed, P = console.groupEnd;
          var U = {
            configurable: !0,
            enumerable: !0,
            value: B,
            writable: !0
          };
          Object.defineProperties(console, {
            info: U,
            log: U,
            warn: U,
            error: U,
            group: U,
            groupCollapsed: U,
            groupEnd: U
          });
        }
        g++;
      }
    }
    function D() {
      {
        if (g--, g === 0) {
          var U = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: f({}, U, {
              value: b
            }),
            info: f({}, U, {
              value: w
            }),
            warn: f({}, U, {
              value: _
            }),
            error: f({}, U, {
              value: E
            }),
            group: f({}, U, {
              value: v
            }),
            groupCollapsed: f({}, U, {
              value: M
            }),
            groupEnd: f({}, U, {
              value: P
            })
          });
        }
        g < 0 && $("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var oe = F.ReactCurrentDispatcher, Z;
    function J(U, se, he) {
      {
        if (Z === void 0)
          try {
            throw Error();
          } catch (Te) {
            var xe = Te.stack.trim().match(/\n( *(at )?)/);
            Z = xe && xe[1] || "";
          }
        return `
` + Z + U;
      }
    }
    var Q = !1, T;
    {
      var X = typeof WeakMap == "function" ? WeakMap : Map;
      T = new X();
    }
    function re(U, se) {
      if (!U || Q)
        return "";
      {
        var he = T.get(U);
        if (he !== void 0)
          return he;
      }
      var xe;
      Q = !0;
      var Te = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Re;
      Re = oe.current, oe.current = null, ue();
      try {
        if (se) {
          var nt = function() {
            throw Error();
          };
          if (Object.defineProperty(nt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(nt, []);
            } catch (_t) {
              xe = _t;
            }
            Reflect.construct(U, [], nt);
          } else {
            try {
              nt.call();
            } catch (_t) {
              xe = _t;
            }
            U.call(nt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (_t) {
            xe = _t;
          }
          U();
        }
      } catch (_t) {
        if (_t && xe && typeof _t.stack == "string") {
          for (var Ue = _t.stack.split(`
`), pt = xe.stack.split(`
`), it = Ue.length - 1, et = pt.length - 1; it >= 1 && et >= 0 && Ue[it] !== pt[et]; )
            et--;
          for (; it >= 1 && et >= 0; it--, et--)
            if (Ue[it] !== pt[et]) {
              if (it !== 1 || et !== 1)
                do
                  if (it--, et--, et < 0 || Ue[it] !== pt[et]) {
                    var St = `
` + Ue[it].replace(" at new ", " at ");
                    return U.displayName && St.includes("<anonymous>") && (St = St.replace("<anonymous>", U.displayName)), typeof U == "function" && T.set(U, St), St;
                  }
                while (it >= 1 && et >= 0);
              break;
            }
        }
      } finally {
        Q = !1, oe.current = Re, D(), Error.prepareStackTrace = Te;
      }
      var Tt = U ? U.displayName || U.name : "", At = Tt ? J(Tt) : "";
      return typeof U == "function" && T.set(U, At), At;
    }
    function de(U, se, he) {
      return re(U, !1);
    }
    function ie(U) {
      var se = U.prototype;
      return !!(se && se.isReactComponent);
    }
    function ce(U, se, he) {
      if (U == null)
        return "";
      if (typeof U == "function")
        return re(U, ie(U));
      if (typeof U == "string")
        return J(U);
      switch (U) {
        case h:
          return J("Suspense");
        case d:
          return J("SuspenseList");
      }
      if (typeof U == "object")
        switch (U.$$typeof) {
          case u:
            return de(U.render);
          case p:
            return ce(U.type, se, he);
          case x: {
            var xe = U, Te = xe._payload, Re = xe._init;
            try {
              return ce(Re(Te), se, he);
            } catch {
            }
          }
        }
      return "";
    }
    var me = Object.prototype.hasOwnProperty, Pe = {}, De = F.ReactDebugCurrentFrame;
    function Ce(U) {
      if (U) {
        var se = U._owner, he = ce(U.type, U._source, se ? se.type : null);
        De.setExtraStackFrame(he);
      } else
        De.setExtraStackFrame(null);
    }
    function $e(U, se, he, xe, Te) {
      {
        var Re = Function.call.bind(me);
        for (var nt in U)
          if (Re(U, nt)) {
            var Ue = void 0;
            try {
              if (typeof U[nt] != "function") {
                var pt = Error((xe || "React class") + ": " + he + " type `" + nt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof U[nt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw pt.name = "Invariant Violation", pt;
              }
              Ue = U[nt](se, nt, xe, he, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (it) {
              Ue = it;
            }
            Ue && !(Ue instanceof Error) && (Ce(Te), $("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", xe || "React class", he, nt, typeof Ue), Ce(null)), Ue instanceof Error && !(Ue.message in Pe) && (Pe[Ue.message] = !0, Ce(Te), $("Failed %s type: %s", he, Ue.message), Ce(null));
          }
      }
    }
    var Me = Array.isArray;
    function Ne(U) {
      return Me(U);
    }
    function Ke(U) {
      {
        var se = typeof Symbol == "function" && Symbol.toStringTag, he = se && U[Symbol.toStringTag] || U.constructor.name || "Object";
        return he;
      }
    }
    function Le(U) {
      try {
        return qe(U), !1;
      } catch {
        return !0;
      }
    }
    function qe(U) {
      return "" + U;
    }
    function ze(U) {
      if (Le(U))
        return $("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ke(U)), qe(U);
    }
    var Ee = F.ReactCurrentOwner, Ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, at, ke, Qe;
    Qe = {};
    function tt(U) {
      if (me.call(U, "ref")) {
        var se = Object.getOwnPropertyDescriptor(U, "ref").get;
        if (se && se.isReactWarning)
          return !1;
      }
      return U.ref !== void 0;
    }
    function Ye(U) {
      if (me.call(U, "key")) {
        var se = Object.getOwnPropertyDescriptor(U, "key").get;
        if (se && se.isReactWarning)
          return !1;
      }
      return U.key !== void 0;
    }
    function dt(U, se) {
      if (typeof U.ref == "string" && Ee.current && se && Ee.current.stateNode !== se) {
        var he = m(Ee.current.type);
        Qe[he] || ($('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', m(Ee.current.type), U.ref), Qe[he] = !0);
      }
    }
    function lt(U, se) {
      {
        var he = function() {
          at || (at = !0, $("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", se));
        };
        he.isReactWarning = !0, Object.defineProperty(U, "key", {
          get: he,
          configurable: !0
        });
      }
    }
    function ct(U, se) {
      {
        var he = function() {
          ke || (ke = !0, $("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", se));
        };
        he.isReactWarning = !0, Object.defineProperty(U, "ref", {
          get: he,
          configurable: !0
        });
      }
    }
    var qt = function(U, se, he, xe, Te, Re, nt) {
      var Ue = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: U,
        key: se,
        ref: he,
        props: nt,
        // Record the component responsible for creating this element.
        _owner: Re
      };
      return Ue._store = {}, Object.defineProperty(Ue._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ue, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: xe
      }), Object.defineProperty(Ue, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Te
      }), Object.freeze && (Object.freeze(Ue.props), Object.freeze(Ue)), Ue;
    };
    function Yt(U, se, he, xe, Te) {
      {
        var Re, nt = {}, Ue = null, pt = null;
        he !== void 0 && (ze(he), Ue = "" + he), Ye(se) && (ze(se.key), Ue = "" + se.key), tt(se) && (pt = se.ref, dt(se, Te));
        for (Re in se)
          me.call(se, Re) && !Ze.hasOwnProperty(Re) && (nt[Re] = se[Re]);
        if (U && U.defaultProps) {
          var it = U.defaultProps;
          for (Re in it)
            nt[Re] === void 0 && (nt[Re] = it[Re]);
        }
        if (Ue || pt) {
          var et = typeof U == "function" ? U.displayName || U.name || "Unknown" : U;
          Ue && lt(nt, et), pt && ct(nt, et);
        }
        return qt(U, Ue, pt, Te, xe, Ee.current, nt);
      }
    }
    var Et = F.ReactCurrentOwner, Qt = F.ReactDebugCurrentFrame;
    function Jt(U) {
      if (U) {
        var se = U._owner, he = ce(U.type, U._source, se ? se.type : null);
        Qt.setExtraStackFrame(he);
      } else
        Qt.setExtraStackFrame(null);
    }
    var Dt;
    Dt = !1;
    function kt(U) {
      return typeof U == "object" && U !== null && U.$$typeof === e;
    }
    function Ct() {
      {
        if (Et.current) {
          var U = m(Et.current.type);
          if (U)
            return `

Check the render method of \`` + U + "`.";
        }
        return "";
      }
    }
    function gt(U) {
      return "";
    }
    var Rt = {};
    function Nt(U) {
      {
        var se = Ct();
        if (!se) {
          var he = typeof U == "string" ? U : U.displayName || U.name;
          he && (se = `

Check the top-level render call using <` + he + ">.");
        }
        return se;
      }
    }
    function vt(U, se) {
      {
        if (!U._store || U._store.validated || U.key != null)
          return;
        U._store.validated = !0;
        var he = Nt(se);
        if (Rt[he])
          return;
        Rt[he] = !0;
        var xe = "";
        U && U._owner && U._owner !== Et.current && (xe = " It was passed a child from " + m(U._owner.type) + "."), Jt(U), $('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', he, xe), Jt(null);
      }
    }
    function $t(U, se) {
      {
        if (typeof U != "object")
          return;
        if (Ne(U))
          for (var he = 0; he < U.length; he++) {
            var xe = U[he];
            kt(xe) && vt(xe, se);
          }
        else if (kt(U))
          U._store && (U._store.validated = !0);
        else if (U) {
          var Te = L(U);
          if (typeof Te == "function" && Te !== U.entries)
            for (var Re = Te.call(U), nt; !(nt = Re.next()).done; )
              kt(nt.value) && vt(nt.value, se);
        }
      }
    }
    function Ft(U) {
      {
        var se = U.type;
        if (se == null || typeof se == "string")
          return;
        var he;
        if (typeof se == "function")
          he = se.propTypes;
        else if (typeof se == "object" && (se.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        se.$$typeof === p))
          he = se.propTypes;
        else
          return;
        if (he) {
          var xe = m(se);
          $e(he, U.props, "prop", xe, U);
        } else if (se.PropTypes !== void 0 && !Dt) {
          Dt = !0;
          var Te = m(se);
          $("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Te || "Unknown");
        }
        typeof se.getDefaultProps == "function" && !se.getDefaultProps.isReactClassApproved && $("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function rt(U) {
      {
        for (var se = Object.keys(U.props), he = 0; he < se.length; he++) {
          var xe = se[he];
          if (xe !== "children" && xe !== "key") {
            Jt(U), $("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", xe), Jt(null);
            break;
          }
        }
        U.ref !== null && (Jt(U), $("Invalid attribute `ref` supplied to `React.Fragment`."), Jt(null));
      }
    }
    var Bt = {};
    function k(U, se, he, xe, Te, Re) {
      {
        var nt = _e(U);
        if (!nt) {
          var Ue = "";
          (U === void 0 || typeof U == "object" && U !== null && Object.keys(U).length === 0) && (Ue += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var pt = gt();
          pt ? Ue += pt : Ue += Ct();
          var it;
          U === null ? it = "null" : Ne(U) ? it = "array" : U !== void 0 && U.$$typeof === e ? (it = "<" + (m(U.type) || "Unknown") + " />", Ue = " Did you accidentally export a JSX literal instead of a component?") : it = typeof U, $("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", it, Ue);
        }
        var et = Yt(U, se, he, Te, Re);
        if (et == null)
          return et;
        if (nt) {
          var St = se.children;
          if (St !== void 0)
            if (xe)
              if (Ne(St)) {
                for (var Tt = 0; Tt < St.length; Tt++)
                  $t(St[Tt], U);
                Object.freeze && Object.freeze(St);
              } else
                $("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              $t(St, U);
        }
        if (me.call(se, "key")) {
          var At = m(U), _t = Object.keys(se).filter(function(st) {
            return st !== "key";
          }), ht = _t.length > 0 ? "{key: someKey, " + _t.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Bt[At + ht]) {
            var xt = _t.length > 0 ? "{" + _t.join(": ..., ") + ": ...}" : "{}";
            $(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ht, At, xt, At), Bt[At + ht] = !0;
          }
        }
        return U === n ? rt(et) : Ft(et), et;
      }
    }
    function j(U, se, he) {
      return k(U, se, he, !0);
    }
    function H(U, se, he) {
      return k(U, se, he, !1);
    }
    var C = H, G = j;
    pf.Fragment = n, pf.jsx = C, pf.jsxs = G;
  }()), pf;
}
process.env.NODE_ENV === "production" ? Ym.exports = AR() : Ym.exports = PR();
var ve = Ym.exports;
const Fc = "https://s.xny.ai/xny-connect/wallet-icons.svg", MR = [
  {
    featured: !0,
    name: "MetaMask",
    rdns: "io.metamask",
    image: `${Fc}#metamask`,
    getWallet: {
      chrome_store_id: "nkbihfbeogaeaoehlefnkodbefgpgknn",
      brave_store_id: "nkbihfbeogaeaoehlefnkodbefgpgknn",
      edge_addon_id: "ejbalbakoplchlghecdalmeeeajnimhm",
      firefox_addon_id: "ether-metamask",
      play_store_id: "io.metamask",
      app_store_id: "id1438144202"
    },
    deep_link: "metamask://wc",
    universal_link: "https://metamask.app.link/wc"
  },
  {
    featured: !0,
    name: "OKX Wallet",
    rdns: "com.okex.wallet",
    image: `${Fc}#okx`,
    getWallet: {
      chrome_store_id: "mcohilncbfahbmgdjkbpemcciiolgcge",
      brave_store_id: "mcohilncbfahbmgdjkbpemcciiolgcge",
      edge_addon_id: "pbpjkcldjiffchgbbndmhojiacbgflha",
      play_store_id: "com.okinc.okex.gp",
      app_store_id: "id1327268470"
    },
    deep_link: "okex://main/wc",
    universal_link: "okex://main/wc"
  },
  {
    featured: !0,
    name: "WalletConnect",
    image: `${Fc}#walletconnect`
  },
  {
    featured: !1,
    name: "Coinbase Wallet",
    image: `${Fc}#coinbase`
  },
  {
    featured: !0,
    name: "GateWallet",
    rdns: "io.gate.wallet",
    image: `${Fc}#6e528abf-7a7d-47bd-d84d-481f169b1200`,
    getWallet: {
      chrome_store_id: "cpmkedoipcpimgecpmgpldfpohjplkpp",
      brave_store_id: "cpmkedoipcpimgecpmgpldfpohjplkpp",
      play_store_id: "com.gateio.gateio",
      app_store_id: "id1294998195",
      mac_app_store_id: "id1609559473"
    },
    deep_link: "https://www.gate.io/mobileapp",
    universal_link: "https://www.gate.io/mobileapp",
    desktop_link: "gtweb3wallet://wc"
  },
  {
    featured: !1,
    name: "Onekey",
    rdns: "so.onekey.app.wallet",
    image: `${Fc}#onekey`,
    getWallet: {
      chrome_store_id: "kfndfpljldjblhckmbbhbhbchjhhgghd",
      brave_store_id: "kfndfpljldjblhckmbbhbhbchjhhgghd",
      play_store_id: "com.onekey.wallet",
      app_store_id: "id1609559473"
    },
    deep_link: "onekey-wallet://",
    universal_link: "onekey://wc",
    desktop_link: "onekey-wallet://",
    webapp_link: "https://app.onekey.so/wc/connect"
  }
];
function IR(t, e) {
  const r = t.exec(e);
  return r == null ? void 0 : r.groups;
}
const d2 = /^tuple(?<array>(\[(\d*)\])*)$/;
function Jm(t) {
  let e = t.type;
  if (d2.test(t.type) && "components" in t) {
    e = "(";
    const r = t.components.length;
    for (let i = 0; i < r; i++) {
      const s = t.components[i];
      e += Jm(s), i < r - 1 && (e += ", ");
    }
    const n = IR(d2, t.type);
    return e += `)${(n == null ? void 0 : n.array) ?? ""}`, Jm({
      ...t,
      type: e
    });
  }
  return "indexed" in t && t.indexed && (e = `${e} indexed`), t.name ? `${e} ${t.name}` : e;
}
function gf(t) {
  let e = "";
  const r = t.length;
  for (let n = 0; n < r; n++) {
    const i = t[n];
    e += Jm(i), n !== r - 1 && (e += ", ");
  }
  return e;
}
function CR(t) {
  return t.type === "function" ? `function ${t.name}(${gf(t.inputs)})${t.stateMutability && t.stateMutability !== "nonpayable" ? ` ${t.stateMutability}` : ""}${t.outputs.length ? ` returns (${gf(t.outputs)})` : ""}` : t.type === "event" ? `event ${t.name}(${gf(t.inputs)})` : t.type === "error" ? `error ${t.name}(${gf(t.inputs)})` : t.type === "constructor" ? `constructor(${gf(t.inputs)})${t.stateMutability === "payable" ? " payable" : ""}` : t.type === "fallback" ? "fallback()" : "receive() external payable";
}
function vi(t, e, r) {
  const n = t[e.name];
  if (typeof n == "function")
    return n;
  const i = t[r];
  return typeof i == "function" ? i : (s) => e(t, s);
}
function gu(t, { includeName: e = !1 } = {}) {
  if (t.type !== "function" && t.type !== "event" && t.type !== "error")
    throw new jR(t.type);
  return `${t.name}(${yv(t.inputs, { includeName: e })})`;
}
function yv(t, { includeName: e = !1 } = {}) {
  return t ? t.map((r) => TR(r, { includeName: e })).join(e ? ", " : ",") : "";
}
function TR(t, { includeName: e }) {
  return t.type.startsWith("tuple") ? `(${yv(t.components, { includeName: e })})${t.type.slice(5)}` : t.type + (e && t.name ? ` ${t.name}` : "");
}
function pa(t, { strict: e = !0 } = {}) {
  return !t || typeof t != "string" ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(t) : t.startsWith("0x");
}
function An(t) {
  return pa(t, { strict: !1 }) ? Math.ceil((t.length - 2) / 2) : t.length;
}
const b5 = "2.21.45";
let mf = {
  getDocsUrl: ({ docsBaseUrl: t, docsPath: e = "", docsSlug: r }) => e ? `${t ?? "https://viem.sh"}${e}${r ? `#${r}` : ""}` : void 0,
  version: `viem@${b5}`
};
class yt extends Error {
  constructor(e, r = {}) {
    var a;
    const n = (() => {
      var u;
      return r.cause instanceof yt ? r.cause.details : (u = r.cause) != null && u.message ? r.cause.message : r.details;
    })(), i = r.cause instanceof yt && r.cause.docsPath || r.docsPath, s = (a = mf.getDocsUrl) == null ? void 0 : a.call(mf, { ...r, docsPath: i }), o = [
      e || "An error occurred.",
      "",
      ...r.metaMessages ? [...r.metaMessages, ""] : [],
      ...s ? [`Docs: ${s}`] : [],
      ...n ? [`Details: ${n}`] : [],
      ...mf.version ? [`Version: ${mf.version}`] : []
    ].join(`
`);
    super(o, r.cause ? { cause: r.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = n, this.docsPath = i, this.metaMessages = r.metaMessages, this.name = r.name ?? this.name, this.shortMessage = e, this.version = b5;
  }
  walk(e) {
    return y5(this, e);
  }
}
function y5(t, e) {
  return e != null && e(t) ? t : t && typeof t == "object" && "cause" in t && t.cause !== void 0 ? y5(t.cause, e) : e ? null : t;
}
class RR extends yt {
  constructor({ docsPath: e }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join(`
`), {
      docsPath: e,
      name: "AbiConstructorNotFoundError"
    });
  }
}
class p2 extends yt {
  constructor({ docsPath: e }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join(`
`), {
      docsPath: e,
      name: "AbiConstructorParamsNotFoundError"
    });
  }
}
class DR extends yt {
  constructor({ data: e, params: r, size: n }) {
    super([`Data size of ${n} bytes is too small for given parameters.`].join(`
`), {
      metaMessages: [
        `Params: (${yv(r, { includeName: !0 })})`,
        `Data:   ${e} (${n} bytes)`
      ],
      name: "AbiDecodingDataSizeTooSmallError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = e, this.params = r, this.size = n;
  }
}
class wv extends yt {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.', {
      name: "AbiDecodingZeroDataError"
    });
  }
}
class OR extends yt {
  constructor({ expectedLength: e, givenLength: r, type: n }) {
    super([
      `ABI encoding array length mismatch for type ${n}.`,
      `Expected length: ${e}`,
      `Given length: ${r}`
    ].join(`
`), { name: "AbiEncodingArrayLengthMismatchError" });
  }
}
class NR extends yt {
  constructor({ expectedSize: e, value: r }) {
    super(`Size of bytes "${r}" (bytes${An(r)}) does not match expected size (bytes${e}).`, { name: "AbiEncodingBytesSizeMismatchError" });
  }
}
class LR extends yt {
  constructor({ expectedLength: e, givenLength: r }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${e}`,
      `Given length (values): ${r}`
    ].join(`
`), { name: "AbiEncodingLengthMismatchError" });
  }
}
class w5 extends yt {
  constructor(e, { docsPath: r }) {
    super([
      `Encoded error signature "${e}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${e}.`
    ].join(`
`), {
      docsPath: r,
      name: "AbiErrorSignatureNotFoundError"
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.signature = e;
  }
}
class g2 extends yt {
  constructor(e, { docsPath: r } = {}) {
    super([
      `Function ${e ? `"${e}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: r,
      name: "AbiFunctionNotFoundError"
    });
  }
}
class kR extends yt {
  constructor(e, r) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${e.type}\` in \`${gu(e.abiItem)}\`, and`,
        `\`${r.type}\` in \`${gu(r.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ],
      name: "AbiItemAmbiguityError"
    });
  }
}
class $R extends yt {
  constructor({ expectedSize: e, givenSize: r }) {
    super(`Expected bytes${e}, got bytes${r}.`, {
      name: "BytesSizeMismatchError"
    });
  }
}
class BR extends yt {
  constructor(e, { docsPath: r }) {
    super([
      `Type "${e}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: r, name: "InvalidAbiEncodingType" });
  }
}
class FR extends yt {
  constructor(e, { docsPath: r }) {
    super([
      `Type "${e}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: r, name: "InvalidAbiDecodingType" });
  }
}
class UR extends yt {
  constructor(e) {
    super([`Value "${e}" is not a valid array.`].join(`
`), {
      name: "InvalidArrayError"
    });
  }
}
class jR extends yt {
  constructor(e) {
    super([
      `"${e}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join(`
`), { name: "InvalidDefinitionTypeError" });
  }
}
class x5 extends yt {
  constructor({ offset: e, position: r, size: n }) {
    super(`Slice ${r === "start" ? "starting" : "ending"} at offset "${e}" is out-of-bounds (size: ${n}).`, { name: "SliceOffsetOutOfBoundsError" });
  }
}
class _5 extends yt {
  constructor({ size: e, targetSize: r, type: n }) {
    super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${e}) exceeds padding size (${r}).`, { name: "SizeExceedsPaddingSizeError" });
  }
}
class m2 extends yt {
  constructor({ size: e, targetSize: r, type: n }) {
    super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} is expected to be ${r} ${n} long, but is ${e} ${n} long.`, { name: "InvalidBytesLengthError" });
  }
}
function Iu(t, { dir: e, size: r = 32 } = {}) {
  return typeof t == "string" ? da(t, { dir: e, size: r }) : qR(t, { dir: e, size: r });
}
function da(t, { dir: e, size: r = 32 } = {}) {
  if (r === null)
    return t;
  const n = t.replace("0x", "");
  if (n.length > r * 2)
    throw new _5({
      size: Math.ceil(n.length / 2),
      targetSize: r,
      type: "hex"
    });
  return `0x${n[e === "right" ? "padEnd" : "padStart"](r * 2, "0")}`;
}
function qR(t, { dir: e, size: r = 32 } = {}) {
  if (r === null)
    return t;
  if (t.length > r)
    throw new _5({
      size: t.length,
      targetSize: r,
      type: "bytes"
    });
  const n = new Uint8Array(r);
  for (let i = 0; i < r; i++) {
    const s = e === "right";
    n[s ? i : r - i - 1] = t[s ? i : t.length - i - 1];
  }
  return n;
}
class zR extends yt {
  constructor({ max: e, min: r, signed: n, size: i, value: s }) {
    super(`Number "${s}" is not in safe ${i ? `${i * 8}-bit ${n ? "signed" : "unsigned"} ` : ""}integer range ${e ? `(${r} to ${e})` : `(above ${r})`}`, { name: "IntegerOutOfRangeError" });
  }
}
class HR extends yt {
  constructor(e) {
    super(`Bytes value "${e}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
      name: "InvalidBytesBooleanError"
    });
  }
}
class WR extends yt {
  constructor({ givenSize: e, maxSize: r }) {
    super(`Size cannot exceed ${r} bytes. Given size: ${e} bytes.`, { name: "SizeOverflowError" });
  }
}
function xv(t, { dir: e = "left" } = {}) {
  let r = typeof t == "string" ? t.replace("0x", "") : t, n = 0;
  for (let i = 0; i < r.length - 1 && r[e === "left" ? i : r.length - i - 1].toString() === "0"; i++)
    n++;
  return r = e === "left" ? r.slice(n) : r.slice(0, r.length - n), typeof t == "string" ? (r.length === 1 && e === "right" && (r = `${r}0`), `0x${r.length % 2 === 1 ? `0${r}` : r}`) : r;
}
function Qs(t, { size: e }) {
  if (An(t) > e)
    throw new WR({
      givenSize: An(t),
      maxSize: e
    });
}
function Zf(t, e = {}) {
  const { signed: r } = e;
  e.size && Qs(t, { size: e.size });
  const n = BigInt(t);
  if (!r)
    return n;
  const i = (t.length - 2) / 2, s = (1n << BigInt(i) * 8n - 1n) - 1n;
  return n <= s ? n : n - BigInt(`0x${"f".padStart(i * 2, "f")}`) - 1n;
}
function mu(t, e = {}) {
  return Number(Zf(t, e));
}
const KR = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function qd(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint" ? Mr(t, e) : typeof t == "string" ? I0(t, e) : typeof t == "boolean" ? E5(t, e) : wi(t, e);
}
function E5(t, e = {}) {
  const r = `0x${Number(t)}`;
  return typeof e.size == "number" ? (Qs(r, { size: e.size }), Iu(r, { size: e.size })) : r;
}
function wi(t, e = {}) {
  let r = "";
  for (let i = 0; i < t.length; i++)
    r += KR[t[i]];
  const n = `0x${r}`;
  return typeof e.size == "number" ? (Qs(n, { size: e.size }), Iu(n, { dir: "right", size: e.size })) : n;
}
function Mr(t, e = {}) {
  const { signed: r, size: n } = e, i = BigInt(t);
  let s;
  n ? r ? s = (1n << BigInt(n) * 8n - 1n) - 1n : s = 2n ** (BigInt(n) * 8n) - 1n : typeof t == "number" && (s = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof s == "bigint" && r ? -s - 1n : 0;
  if (s && i > s || i < o) {
    const u = typeof t == "bigint" ? "n" : "";
    throw new zR({
      max: s ? `${s}${u}` : void 0,
      min: `${o}${u}`,
      signed: r,
      size: n,
      value: `${t}${u}`
    });
  }
  const a = `0x${(r && i < 0 ? (1n << BigInt(n * 8)) + BigInt(i) : i).toString(16)}`;
  return n ? Iu(a, { size: n }) : a;
}
const VR = /* @__PURE__ */ new TextEncoder();
function I0(t, e = {}) {
  const r = VR.encode(t);
  return wi(r, e);
}
const GR = /* @__PURE__ */ new TextEncoder();
function _v(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint" ? JR(t, e) : typeof t == "boolean" ? YR(t, e) : pa(t) ? Do(t, e) : S5(t, e);
}
function YR(t, e = {}) {
  const r = new Uint8Array(1);
  return r[0] = Number(t), typeof e.size == "number" ? (Qs(r, { size: e.size }), Iu(r, { size: e.size })) : r;
}
const ho = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function v2(t) {
  if (t >= ho.zero && t <= ho.nine)
    return t - ho.zero;
  if (t >= ho.A && t <= ho.F)
    return t - (ho.A - 10);
  if (t >= ho.a && t <= ho.f)
    return t - (ho.a - 10);
}
function Do(t, e = {}) {
  let r = t;
  e.size && (Qs(r, { size: e.size }), r = Iu(r, { dir: "right", size: e.size }));
  let n = r.slice(2);
  n.length % 2 && (n = `0${n}`);
  const i = n.length / 2, s = new Uint8Array(i);
  for (let o = 0, a = 0; o < i; o++) {
    const u = v2(n.charCodeAt(a++)), h = v2(n.charCodeAt(a++));
    if (u === void 0 || h === void 0)
      throw new yt(`Invalid byte sequence ("${n[a - 2]}${n[a - 1]}" in "${n}").`);
    s[o] = u * 16 + h;
  }
  return s;
}
function JR(t, e) {
  const r = Mr(t, e);
  return Do(r);
}
function S5(t, e = {}) {
  const r = GR.encode(t);
  return typeof e.size == "number" ? (Qs(r, { size: e.size }), Iu(r, { dir: "right", size: e.size })) : r;
}
function zd(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error(`positive integer expected, not ${t}`);
}
function XR(t) {
  return t instanceof Uint8Array || t != null && typeof t == "object" && t.constructor.name === "Uint8Array";
}
function Nl(t, ...e) {
  if (!XR(t))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error(`Uint8Array expected of length ${e}, not of length=${t.length}`);
}
function sse(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  zd(t.outputLen), zd(t.blockLen);
}
function Hd(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function A5(t, e) {
  Nl(t);
  const r = e.outputLen;
  if (t.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const td = /* @__PURE__ */ BigInt(2 ** 32 - 1), b2 = /* @__PURE__ */ BigInt(32);
function ZR(t, e = !1) {
  return e ? { h: Number(t & td), l: Number(t >> b2 & td) } : { h: Number(t >> b2 & td) | 0, l: Number(t & td) | 0 };
}
function QR(t, e = !1) {
  let r = new Uint32Array(t.length), n = new Uint32Array(t.length);
  for (let i = 0; i < t.length; i++) {
    const { h: s, l: o } = ZR(t[i], e);
    [r[i], n[i]] = [s, o];
  }
  return [r, n];
}
const eD = (t, e, r) => t << r | e >>> 32 - r, tD = (t, e, r) => e << r | t >>> 32 - r, rD = (t, e, r) => e << r - 32 | t >>> 64 - r, nD = (t, e, r) => t << r - 32 | e >>> 64 - r, Uc = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const iD = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)), Bg = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), Ds = (t, e) => t << 32 - e | t >>> e, y2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, sD = (t) => t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
function w2(t) {
  for (let e = 0; e < t.length; e++)
    t[e] = sD(t[e]);
}
const oD = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function aD(t) {
  Nl(t);
  let e = "";
  for (let r = 0; r < t.length; r++)
    e += oD[t[r]];
  return e;
}
function cD(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new Uint8Array(new TextEncoder().encode(t));
}
function C0(t) {
  return typeof t == "string" && (t = cD(t)), Nl(t), t;
}
function ose(...t) {
  let e = 0;
  for (let n = 0; n < t.length; n++) {
    const i = t[n];
    Nl(i), e += i.length;
  }
  const r = new Uint8Array(e);
  for (let n = 0, i = 0; n < t.length; n++) {
    const s = t[n];
    r.set(s, i), i += s.length;
  }
  return r;
}
class P5 {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function M5(t) {
  const e = (n) => t().update(C0(n)).digest(), r = t();
  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e;
}
function uD(t) {
  const e = (n, i) => t(i).update(C0(n)).digest(), r = t({});
  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = (n) => t(n), e;
}
function ase(t = 32) {
  if (Uc && typeof Uc.getRandomValues == "function")
    return Uc.getRandomValues(new Uint8Array(t));
  if (Uc && typeof Uc.randomBytes == "function")
    return Uc.randomBytes(t);
  throw new Error("crypto.getRandomValues must be defined");
}
const I5 = [], C5 = [], T5 = [], fD = /* @__PURE__ */ BigInt(0), vf = /* @__PURE__ */ BigInt(1), lD = /* @__PURE__ */ BigInt(2), hD = /* @__PURE__ */ BigInt(7), dD = /* @__PURE__ */ BigInt(256), pD = /* @__PURE__ */ BigInt(113);
for (let t = 0, e = vf, r = 1, n = 0; t < 24; t++) {
  [r, n] = [n, (2 * r + 3 * n) % 5], I5.push(2 * (5 * n + r)), C5.push((t + 1) * (t + 2) / 2 % 64);
  let i = fD;
  for (let s = 0; s < 7; s++)
    e = (e << vf ^ (e >> hD) * pD) % dD, e & lD && (i ^= vf << (vf << /* @__PURE__ */ BigInt(s)) - vf);
  T5.push(i);
}
const [gD, mD] = /* @__PURE__ */ QR(T5, !0), x2 = (t, e, r) => r > 32 ? rD(t, e, r) : eD(t, e, r), _2 = (t, e, r) => r > 32 ? nD(t, e, r) : tD(t, e, r);
function R5(t, e = 24) {
  const r = new Uint32Array(10);
  for (let n = 24 - e; n < 24; n++) {
    for (let o = 0; o < 10; o++)
      r[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10, u = (o + 2) % 10, h = r[u], d = r[u + 1], p = x2(h, d, 1) ^ r[a], x = _2(h, d, 1) ^ r[a + 1];
      for (let A = 0; A < 50; A += 10)
        t[o + A] ^= p, t[o + A + 1] ^= x;
    }
    let i = t[2], s = t[3];
    for (let o = 0; o < 24; o++) {
      const a = C5[o], u = x2(i, s, a), h = _2(i, s, a), d = I5[o];
      i = t[d], s = t[d + 1], t[d] = u, t[d + 1] = h;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++)
        r[a] = t[o + a];
      for (let a = 0; a < 10; a++)
        t[o + a] ^= ~r[(a + 2) % 10] & r[(a + 4) % 10];
    }
    t[0] ^= gD[n], t[1] ^= mD[n];
  }
  r.fill(0);
}
class Ll extends P5 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, r, n, i = !1, s = 24) {
    if (super(), this.blockLen = e, this.suffix = r, this.outputLen = n, this.enableXOF = i, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, zd(n), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = iD(this.state);
  }
  keccak() {
    y2 || w2(this.state32), R5(this.state32, this.rounds), y2 || w2(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Hd(this);
    const { blockLen: r, state: n } = this;
    e = C0(e);
    const i = e.length;
    for (let s = 0; s < i; ) {
      const o = Math.min(r - this.pos, i - s);
      for (let a = 0; a < o; a++)
        n[this.pos++] ^= e[s++];
      this.pos === r && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: r, pos: n, blockLen: i } = this;
    e[n] ^= r, r & 128 && n === i - 1 && this.keccak(), e[i - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Hd(this, !1), Nl(e), this.finish();
    const r = this.state, { blockLen: n } = this;
    for (let i = 0, s = e.length; i < s; ) {
      this.posOut >= n && this.keccak();
      const o = Math.min(n - this.posOut, s - i);
      e.set(r.subarray(this.posOut, this.posOut + o), i), this.posOut += o, i += o;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return zd(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (A5(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: r, suffix: n, outputLen: i, rounds: s, enableXOF: o } = this;
    return e || (e = new Ll(r, n, i, o, s)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = s, e.suffix = n, e.outputLen = i, e.enableXOF = o, e.destroyed = this.destroyed, e;
  }
}
const _a = (t, e, r) => M5(() => new Ll(e, t, r)), vD = /* @__PURE__ */ _a(6, 144, 224 / 8), bD = /* @__PURE__ */ _a(6, 136, 256 / 8), yD = /* @__PURE__ */ _a(6, 104, 384 / 8), wD = /* @__PURE__ */ _a(6, 72, 512 / 8), xD = /* @__PURE__ */ _a(1, 144, 224 / 8), D5 = /* @__PURE__ */ _a(1, 136, 256 / 8), _D = /* @__PURE__ */ _a(1, 104, 384 / 8), ED = /* @__PURE__ */ _a(1, 72, 512 / 8), O5 = (t, e, r) => uD((n = {}) => new Ll(e, t, n.dkLen === void 0 ? r : n.dkLen, !0)), SD = /* @__PURE__ */ O5(31, 168, 128 / 8), AD = /* @__PURE__ */ O5(31, 136, 256 / 8), PD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Keccak: Ll,
  keccakP: R5,
  keccak_224: xD,
  keccak_256: D5,
  keccak_384: _D,
  keccak_512: ED,
  sha3_224: vD,
  sha3_256: bD,
  sha3_384: yD,
  sha3_512: wD,
  shake128: SD,
  shake256: AD
}, Symbol.toStringTag, { value: "Module" }));
function kl(t, e) {
  const r = e || "hex", n = D5(pa(t, { strict: !1 }) ? _v(t) : t);
  return r === "bytes" ? n : qd(n);
}
const MD = (t) => kl(_v(t));
function ID(t) {
  return MD(t);
}
function CD(t) {
  let e = !0, r = "", n = 0, i = "", s = !1;
  for (let o = 0; o < t.length; o++) {
    const a = t[o];
    if (["(", ")", ","].includes(a) && (e = !0), a === "(" && n++, a === ")" && n--, !!e) {
      if (n === 0) {
        if (a === " " && ["event", "function", ""].includes(i))
          i = "";
        else if (i += a, a === ")") {
          s = !0;
          break;
        }
        continue;
      }
      if (a === " ") {
        t[o - 1] !== "," && r !== "," && r !== ",(" && (r = "", e = !1);
        continue;
      }
      i += a, r += a;
    }
  }
  if (!s)
    throw new yt("Unable to normalize signature.");
  return i;
}
const TD = (t) => {
  const e = typeof t == "string" ? t : CR(t);
  return CD(e);
};
function N5(t) {
  return ID(TD(t));
}
const RD = N5;
class vu extends yt {
  constructor({ address: e }) {
    super(`Address "${e}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
}
class T0 extends Map {
  constructor(e) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = e;
  }
  get(e) {
    const r = super.get(e);
    return super.has(e) && r !== void 0 && (this.delete(e), super.set(e, r)), r;
  }
  set(e, r) {
    if (super.set(e, r), this.maxSize && this.size > this.maxSize) {
      const n = this.keys().next().value;
      n && this.delete(n);
    }
    return this;
  }
}
const Fg = /* @__PURE__ */ new T0(8192);
function $l(t, e) {
  if (Fg.has(`${t}.${e}`))
    return Fg.get(`${t}.${e}`);
  const r = t.substring(2).toLowerCase(), n = kl(S5(r), "bytes"), i = r.split("");
  for (let o = 0; o < 40; o += 2)
    n[o >> 1] >> 4 >= 8 && i[o] && (i[o] = i[o].toUpperCase()), (n[o >> 1] & 15) >= 8 && i[o + 1] && (i[o + 1] = i[o + 1].toUpperCase());
  const s = `0x${i.join("")}`;
  return Fg.set(`${t}.${e}`, s), s;
}
function L5(t, e) {
  if (!Oo(t, { strict: !1 }))
    throw new vu({ address: t });
  return $l(t, e);
}
const DD = /^0x[a-fA-F0-9]{40}$/, Ug = /* @__PURE__ */ new T0(8192);
function Oo(t, e) {
  const { strict: r = !0 } = e ?? {}, n = `${t}.${r}`;
  if (Ug.has(n))
    return Ug.get(n);
  const i = DD.test(t) ? t.toLowerCase() === t ? !0 : r ? $l(t) === t : !0 : !1;
  return Ug.set(n, i), i;
}
function bu(t) {
  return typeof t[0] == "string" ? R0(t) : OD(t);
}
function OD(t) {
  let e = 0;
  for (const i of t)
    e += i.length;
  const r = new Uint8Array(e);
  let n = 0;
  for (const i of t)
    r.set(i, n), n += i.length;
  return r;
}
function R0(t) {
  return `0x${t.reduce((e, r) => e + r.replace("0x", ""), "")}`;
}
function Wd(t, e, r, { strict: n } = {}) {
  return pa(t, { strict: !1 }) ? ND(t, e, r, {
    strict: n
  }) : B5(t, e, r, {
    strict: n
  });
}
function k5(t, e) {
  if (typeof e == "number" && e > 0 && e > An(t) - 1)
    throw new x5({
      offset: e,
      position: "start",
      size: An(t)
    });
}
function $5(t, e, r) {
  if (typeof e == "number" && typeof r == "number" && An(t) !== r - e)
    throw new x5({
      offset: r,
      position: "end",
      size: An(t)
    });
}
function B5(t, e, r, { strict: n } = {}) {
  k5(t, e);
  const i = t.slice(e, r);
  return n && $5(i, e, r), i;
}
function ND(t, e, r, { strict: n } = {}) {
  k5(t, e);
  const i = `0x${t.replace("0x", "").slice((e ?? 0) * 2, (r ?? t.length) * 2)}`;
  return n && $5(i, e, r), i;
}
function F5(t, e) {
  if (t.length !== e.length)
    throw new LR({
      expectedLength: t.length,
      givenLength: e.length
    });
  const r = LD({
    params: t,
    values: e
  }), n = Sv(r);
  return n.length === 0 ? "0x" : n;
}
function LD({ params: t, values: e }) {
  const r = [];
  for (let n = 0; n < t.length; n++)
    r.push(Ev({ param: t[n], value: e[n] }));
  return r;
}
function Ev({ param: t, value: e }) {
  const r = Av(t.type);
  if (r) {
    const [n, i] = r;
    return $D(e, { length: n, param: { ...t, type: i } });
  }
  if (t.type === "tuple")
    return qD(e, {
      param: t
    });
  if (t.type === "address")
    return kD(e);
  if (t.type === "bool")
    return FD(e);
  if (t.type.startsWith("uint") || t.type.startsWith("int")) {
    const n = t.type.startsWith("int");
    return UD(e, { signed: n });
  }
  if (t.type.startsWith("bytes"))
    return BD(e, { param: t });
  if (t.type === "string")
    return jD(e);
  throw new BR(t.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function Sv(t) {
  let e = 0;
  for (let s = 0; s < t.length; s++) {
    const { dynamic: o, encoded: a } = t[s];
    o ? e += 32 : e += An(a);
  }
  const r = [], n = [];
  let i = 0;
  for (let s = 0; s < t.length; s++) {
    const { dynamic: o, encoded: a } = t[s];
    o ? (r.push(Mr(e + i, { size: 32 })), n.push(a), i += An(a)) : r.push(a);
  }
  return bu([...r, ...n]);
}
function kD(t) {
  if (!Oo(t))
    throw new vu({ address: t });
  return { dynamic: !1, encoded: da(t.toLowerCase()) };
}
function $D(t, { length: e, param: r }) {
  const n = e === null;
  if (!Array.isArray(t))
    throw new UR(t);
  if (!n && t.length !== e)
    throw new OR({
      expectedLength: e,
      givenLength: t.length,
      type: `${r.type}[${e}]`
    });
  let i = !1;
  const s = [];
  for (let o = 0; o < t.length; o++) {
    const a = Ev({ param: r, value: t[o] });
    a.dynamic && (i = !0), s.push(a);
  }
  if (n || i) {
    const o = Sv(s);
    if (n) {
      const a = Mr(s.length, { size: 32 });
      return {
        dynamic: !0,
        encoded: s.length > 0 ? bu([a, o]) : a
      };
    }
    if (i)
      return { dynamic: !0, encoded: o };
  }
  return {
    dynamic: !1,
    encoded: bu(s.map(({ encoded: o }) => o))
  };
}
function BD(t, { param: e }) {
  const [, r] = e.type.split("bytes"), n = An(t);
  if (!r) {
    let i = t;
    return n % 32 !== 0 && (i = da(i, {
      dir: "right",
      size: Math.ceil((t.length - 2) / 2 / 32) * 32
    })), {
      dynamic: !0,
      encoded: bu([da(Mr(n, { size: 32 })), i])
    };
  }
  if (n !== Number.parseInt(r))
    throw new NR({
      expectedSize: Number.parseInt(r),
      value: t
    });
  return { dynamic: !1, encoded: da(t, { dir: "right" }) };
}
function FD(t) {
  if (typeof t != "boolean")
    throw new yt(`Invalid boolean value: "${t}" (type: ${typeof t}). Expected: \`true\` or \`false\`.`);
  return { dynamic: !1, encoded: da(E5(t)) };
}
function UD(t, { signed: e }) {
  return {
    dynamic: !1,
    encoded: Mr(t, {
      size: 32,
      signed: e
    })
  };
}
function jD(t) {
  const e = I0(t), r = Math.ceil(An(e) / 32), n = [];
  for (let i = 0; i < r; i++)
    n.push(da(Wd(e, i * 32, (i + 1) * 32), {
      dir: "right"
    }));
  return {
    dynamic: !0,
    encoded: bu([
      da(Mr(An(e), { size: 32 })),
      ...n
    ])
  };
}
function qD(t, { param: e }) {
  let r = !1;
  const n = [];
  for (let i = 0; i < e.components.length; i++) {
    const s = e.components[i], o = Array.isArray(t) ? i : s.name, a = Ev({
      param: s,
      value: t[o]
    });
    n.push(a), a.dynamic && (r = !0);
  }
  return {
    dynamic: r,
    encoded: r ? Sv(n) : bu(n.map(({ encoded: i }) => i))
  };
}
function Av(t) {
  const e = t.match(/^(.*)\[(\d+)?\]$/);
  return e ? (
    // Return `null` if the array is dynamic.
    [e[2] ? Number(e[2]) : null, e[1]]
  ) : void 0;
}
const Pv = (t) => Wd(N5(t), 0, 4);
function U5(t) {
  const { abi: e, args: r = [], name: n } = t, i = pa(n, { strict: !1 }), s = e.filter((a) => i ? a.type === "function" ? Pv(a) === n : a.type === "event" ? RD(a) === n : !1 : "name" in a && a.name === n);
  if (s.length === 0)
    return;
  if (s.length === 1)
    return s[0];
  let o;
  for (const a of s) {
    if (!("inputs" in a))
      continue;
    if (!r || r.length === 0) {
      if (!a.inputs || a.inputs.length === 0)
        return a;
      continue;
    }
    if (!a.inputs || a.inputs.length === 0 || a.inputs.length !== r.length)
      continue;
    if (r.every((h, d) => {
      const p = "inputs" in a && a.inputs[d];
      return p ? Xm(h, p) : !1;
    })) {
      if (o && "inputs" in o && o.inputs) {
        const h = j5(a.inputs, o.inputs, r);
        if (h)
          throw new kR({
            abiItem: a,
            type: h[0]
          }, {
            abiItem: o,
            type: h[1]
          });
      }
      o = a;
    }
  }
  return o || s[0];
}
function Xm(t, e) {
  const r = typeof t, n = e.type;
  switch (n) {
    case "address":
      return Oo(t, { strict: !1 });
    case "bool":
      return r === "boolean";
    case "function":
      return r === "string";
    case "string":
      return r === "string";
    default:
      return n === "tuple" && "components" in e ? Object.values(e.components).every((i, s) => Xm(Object.values(t)[s], i)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(n) ? r === "number" || r === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(n) ? r === "string" || t instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(n) ? Array.isArray(t) && t.every((i) => Xm(i, {
        ...e,
        // Pop off `[]` or `[M]` from end of type
        type: n.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1;
  }
}
function j5(t, e, r) {
  for (const n in t) {
    const i = t[n], s = e[n];
    if (i.type === "tuple" && s.type === "tuple" && "components" in i && "components" in s)
      return j5(i.components, s.components, r[n]);
    const o = [i.type, s.type];
    if (o.includes("address") && o.includes("bytes20") ? !0 : o.includes("address") && o.includes("string") ? Oo(r[n], { strict: !1 }) : o.includes("address") && o.includes("bytes") ? Oo(r[n], { strict: !1 }) : !1)
      return o;
  }
}
function Fo(t) {
  return typeof t == "string" ? { address: t, type: "json-rpc" } : t;
}
const E2 = "/docs/contract/encodeFunctionData";
function zD(t) {
  const { abi: e, args: r, functionName: n } = t;
  let i = e[0];
  if (n) {
    const s = U5({
      abi: e,
      args: r,
      name: n
    });
    if (!s)
      throw new g2(n, { docsPath: E2 });
    i = s;
  }
  if (i.type !== "function")
    throw new g2(void 0, { docsPath: E2 });
  return {
    abi: [i],
    functionName: Pv(gu(i))
  };
}
function HD(t) {
  const { args: e } = t, { abi: r, functionName: n } = (() => {
    var a;
    return t.abi.length === 1 && ((a = t.functionName) != null && a.startsWith("0x")) ? t : zD(t);
  })(), i = r[0], s = n, o = "inputs" in i && i.inputs ? F5(i.inputs, e ?? []) : void 0;
  return R0([s, o ?? "0x"]);
}
const WD = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
}, KD = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
}, VD = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
class S2 extends yt {
  constructor({ offset: e }) {
    super(`Offset \`${e}\` cannot be negative.`, {
      name: "NegativeOffsetError"
    });
  }
}
class GD extends yt {
  constructor({ length: e, position: r }) {
    super(`Position \`${r}\` is out of bounds (\`0 < position < ${e}\`).`, { name: "PositionOutOfBoundsError" });
  }
}
class YD extends yt {
  constructor({ count: e, limit: r }) {
    super(`Recursive read limit of \`${r}\` exceeded (recursive read count: \`${e}\`).`, { name: "RecursiveReadLimitExceededError" });
  }
}
const JD = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new YD({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(t) {
    if (t < 0 || t > this.bytes.length - 1)
      throw new GD({
        length: this.bytes.length,
        position: t
      });
  },
  decrementPosition(t) {
    if (t < 0)
      throw new S2({ offset: t });
    const e = this.position - t;
    this.assertPosition(e), this.position = e;
  },
  getReadCount(t) {
    return this.positionReadCount.get(t || this.position) || 0;
  },
  incrementPosition(t) {
    if (t < 0)
      throw new S2({ offset: t });
    const e = this.position + t;
    this.assertPosition(e), this.position = e;
  },
  inspectByte(t) {
    const e = t ?? this.position;
    return this.assertPosition(e), this.bytes[e];
  },
  inspectBytes(t, e) {
    const r = e ?? this.position;
    return this.assertPosition(r + t - 1), this.bytes.subarray(r, r + t);
  },
  inspectUint8(t) {
    const e = t ?? this.position;
    return this.assertPosition(e), this.bytes[e];
  },
  inspectUint16(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 1), this.dataView.getUint16(e);
  },
  inspectUint24(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 2), (this.dataView.getUint16(e) << 8) + this.dataView.getUint8(e + 2);
  },
  inspectUint32(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 3), this.dataView.getUint32(e);
  },
  pushByte(t) {
    this.assertPosition(this.position), this.bytes[this.position] = t, this.position++;
  },
  pushBytes(t) {
    this.assertPosition(this.position + t.length - 1), this.bytes.set(t, this.position), this.position += t.length;
  },
  pushUint8(t) {
    this.assertPosition(this.position), this.bytes[this.position] = t, this.position++;
  },
  pushUint16(t) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, t), this.position += 2;
  },
  pushUint24(t) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, t >> 8), this.dataView.setUint8(this.position + 2, t & 255), this.position += 3;
  },
  pushUint32(t) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, t), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectByte();
    return this.position++, t;
  },
  readBytes(t, e) {
    this.assertReadLimit(), this._touch();
    const r = this.inspectBytes(t);
    return this.position += e ?? t, r;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint8();
    return this.position += 1, t;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint16();
    return this.position += 2, t;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint24();
    return this.position += 3, t;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint32();
    return this.position += 4, t;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(t) {
    const e = this.position;
    return this.assertPosition(t), this.position = t, () => this.position = e;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const t = this.getReadCount();
    this.positionReadCount.set(this.position, t + 1), t > 0 && this.recursiveReadCount++;
  }
};
function Mv(t, { recursiveReadLimit: e = 8192 } = {}) {
  const r = Object.create(JD);
  return r.bytes = t, r.dataView = new DataView(t.buffer, t.byteOffset, t.byteLength), r.positionReadCount = /* @__PURE__ */ new Map(), r.recursiveReadLimit = e, r;
}
function XD(t, e = {}) {
  typeof e.size < "u" && Qs(t, { size: e.size });
  const r = wi(t, e);
  return Zf(r, e);
}
function ZD(t, e = {}) {
  let r = t;
  if (typeof e.size < "u" && (Qs(r, { size: e.size }), r = xv(r)), r.length > 1 || r[0] > 1)
    throw new HR(r);
  return !!r[0];
}
function Po(t, e = {}) {
  typeof e.size < "u" && Qs(t, { size: e.size });
  const r = wi(t, e);
  return mu(r, e);
}
function QD(t, e = {}) {
  let r = t;
  return typeof e.size < "u" && (Qs(r, { size: e.size }), r = xv(r, { dir: "right" })), new TextDecoder().decode(r);
}
function eO(t, e) {
  const r = typeof e == "string" ? Do(e) : e, n = Mv(r);
  if (An(r) === 0 && t.length > 0)
    throw new wv();
  if (An(e) && An(e) < 32)
    throw new DR({
      data: typeof e == "string" ? e : wi(e),
      params: t,
      size: An(e)
    });
  let i = 0;
  const s = [];
  for (let o = 0; o < t.length; ++o) {
    const a = t[o];
    n.setPosition(i);
    const [u, h] = su(n, a, {
      staticPosition: 0
    });
    i += h, s.push(u);
  }
  return s;
}
function su(t, e, { staticPosition: r }) {
  const n = Av(e.type);
  if (n) {
    const [i, s] = n;
    return rO(t, { ...e, type: s }, { length: i, staticPosition: r });
  }
  if (e.type === "tuple")
    return oO(t, e, { staticPosition: r });
  if (e.type === "address")
    return tO(t);
  if (e.type === "bool")
    return nO(t);
  if (e.type.startsWith("bytes"))
    return iO(t, e, { staticPosition: r });
  if (e.type.startsWith("uint") || e.type.startsWith("int"))
    return sO(t, e);
  if (e.type === "string")
    return aO(t, { staticPosition: r });
  throw new FR(e.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
const A2 = 32, Zm = 32;
function tO(t) {
  const e = t.readBytes(32);
  return [$l(wi(B5(e, -20))), 32];
}
function rO(t, e, { length: r, staticPosition: n }) {
  if (!r) {
    const o = Po(t.readBytes(Zm)), a = n + o, u = a + A2;
    t.setPosition(a);
    const h = Po(t.readBytes(A2)), d = Qf(e);
    let p = 0;
    const x = [];
    for (let A = 0; A < h; ++A) {
      t.setPosition(u + (d ? A * 32 : p));
      const [I, N] = su(t, e, {
        staticPosition: u
      });
      p += N, x.push(I);
    }
    return t.setPosition(n + 32), [x, 32];
  }
  if (Qf(e)) {
    const o = Po(t.readBytes(Zm)), a = n + o, u = [];
    for (let h = 0; h < r; ++h) {
      t.setPosition(a + h * 32);
      const [d] = su(t, e, {
        staticPosition: a
      });
      u.push(d);
    }
    return t.setPosition(n + 32), [u, 32];
  }
  let i = 0;
  const s = [];
  for (let o = 0; o < r; ++o) {
    const [a, u] = su(t, e, {
      staticPosition: n + i
    });
    i += u, s.push(a);
  }
  return [s, i];
}
function nO(t) {
  return [ZD(t.readBytes(32), { size: 32 }), 32];
}
function iO(t, e, { staticPosition: r }) {
  const [n, i] = e.type.split("bytes");
  if (!i) {
    const o = Po(t.readBytes(32));
    t.setPosition(r + o);
    const a = Po(t.readBytes(32));
    if (a === 0)
      return t.setPosition(r + 32), ["0x", 32];
    const u = t.readBytes(a);
    return t.setPosition(r + 32), [wi(u), 32];
  }
  return [wi(t.readBytes(Number.parseInt(i), 32)), 32];
}
function sO(t, e) {
  const r = e.type.startsWith("int"), n = Number.parseInt(e.type.split("int")[1] || "256"), i = t.readBytes(32);
  return [
    n > 48 ? XD(i, { signed: r }) : Po(i, { signed: r }),
    32
  ];
}
function oO(t, e, { staticPosition: r }) {
  const n = e.components.length === 0 || e.components.some(({ name: o }) => !o), i = n ? [] : {};
  let s = 0;
  if (Qf(e)) {
    const o = Po(t.readBytes(Zm)), a = r + o;
    for (let u = 0; u < e.components.length; ++u) {
      const h = e.components[u];
      t.setPosition(a + s);
      const [d, p] = su(t, h, {
        staticPosition: a
      });
      s += p, i[n ? u : h == null ? void 0 : h.name] = d;
    }
    return t.setPosition(r + 32), [i, 32];
  }
  for (let o = 0; o < e.components.length; ++o) {
    const a = e.components[o], [u, h] = su(t, a, {
      staticPosition: r
    });
    i[n ? o : a == null ? void 0 : a.name] = u, s += h;
  }
  return [i, s];
}
function aO(t, { staticPosition: e }) {
  const r = Po(t.readBytes(32)), n = e + r;
  t.setPosition(n);
  const i = Po(t.readBytes(32));
  if (i === 0)
    return t.setPosition(e + 32), ["", 32];
  const s = t.readBytes(i, 32), o = QD(xv(s));
  return t.setPosition(e + 32), [o, 32];
}
function Qf(t) {
  var n;
  const { type: e } = t;
  if (e === "string" || e === "bytes" || e.endsWith("[]"))
    return !0;
  if (e === "tuple")
    return (n = t.components) == null ? void 0 : n.some(Qf);
  const r = Av(t.type);
  return !!(r && Qf({ ...t, type: r[1] }));
}
function cO(t) {
  const { abi: e, data: r } = t, n = Wd(r, 0, 4);
  if (n === "0x")
    throw new wv();
  const s = [...e || [], KD, VD].find((o) => o.type === "error" && n === Pv(gu(o)));
  if (!s)
    throw new w5(n, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem: s,
    args: "inputs" in s && s.inputs && s.inputs.length > 0 ? eO(s.inputs, Wd(r, 4)) : void 0,
    errorName: s.name
  };
}
const Cu = (t, e, r) => JSON.stringify(t, (n, i) => typeof i == "bigint" ? i.toString() : i, r);
function q5({ abiItem: t, args: e, includeFunctionName: r = !0, includeName: n = !1 }) {
  if ("name" in t && "inputs" in t && t.inputs)
    return `${r ? t.name : ""}(${t.inputs.map((i, s) => `${n && i.name ? `${i.name}: ` : ""}${typeof e[s] == "object" ? Cu(e[s]) : e[s]}`).join(", ")})`;
}
const uO = {
  gwei: 9,
  wei: 18
}, fO = {
  ether: -9,
  wei: 9
};
function z5(t, e) {
  let r = t.toString();
  const n = r.startsWith("-");
  n && (r = r.slice(1)), r = r.padStart(e, "0");
  let [i, s] = [
    r.slice(0, r.length - e),
    r.slice(r.length - e)
  ];
  return s = s.replace(/(0+)$/, ""), `${n ? "-" : ""}${i || "0"}${s ? `.${s}` : ""}`;
}
function H5(t, e = "wei") {
  return z5(t, uO[e]);
}
function _s(t, e = "wei") {
  return z5(t, fO[e]);
}
class lO extends yt {
  constructor({ address: e }) {
    super(`State for account "${e}" is set multiple times.`, {
      name: "AccountStateConflictError"
    });
  }
}
class hO extends yt {
  constructor() {
    super("state and stateDiff are set on the same account.", {
      name: "StateAssignmentConflictError"
    });
  }
}
function D0(t) {
  const e = Object.entries(t).map(([n, i]) => i === void 0 || i === !1 ? null : [n, i]).filter(Boolean), r = e.reduce((n, [i]) => Math.max(n, i.length), 0);
  return e.map(([n, i]) => `  ${`${n}:`.padEnd(r + 1)}  ${i}`).join(`
`);
}
class dO extends yt {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join(`
`), { name: "FeeConflictError" });
  }
}
class pO extends yt {
  constructor({ transaction: e }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        D0(e),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- an EIP-7702 Transaction with `authorizationList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ],
      name: "InvalidSerializableTransactionError"
    });
  }
}
class gO extends yt {
  constructor(e, { account: r, docsPath: n, chain: i, data: s, gas: o, gasPrice: a, maxFeePerGas: u, maxPriorityFeePerGas: h, nonce: d, to: p, value: x }) {
    var I;
    const A = D0({
      chain: i && `${i == null ? void 0 : i.name} (id: ${i == null ? void 0 : i.id})`,
      from: r == null ? void 0 : r.address,
      to: p,
      value: typeof x < "u" && `${H5(x)} ${((I = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : I.symbol) || "ETH"}`,
      data: s,
      gas: o,
      gasPrice: typeof a < "u" && `${_s(a)} gwei`,
      maxFeePerGas: typeof u < "u" && `${_s(u)} gwei`,
      maxPriorityFeePerGas: typeof h < "u" && `${_s(h)} gwei`,
      nonce: d
    });
    super(e.shortMessage, {
      cause: e,
      docsPath: n,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        "Request Arguments:",
        A
      ].filter(Boolean),
      name: "TransactionExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = e;
  }
}
const mO = (t) => t, W5 = (t) => t;
class vO extends yt {
  constructor(e, { abi: r, args: n, contractAddress: i, docsPath: s, functionName: o, sender: a }) {
    const u = U5({ abi: r, args: n, name: o }), h = u ? q5({
      abiItem: u,
      args: n,
      includeFunctionName: !1,
      includeName: !1
    }) : void 0, d = u ? gu(u, { includeName: !0 }) : void 0, p = D0({
      address: i && mO(i),
      function: d,
      args: h && h !== "()" && `${[...Array((o == null ? void 0 : o.length) ?? 0).keys()].map(() => " ").join("")}${h}`,
      sender: a
    });
    super(e.shortMessage || `An unknown error occurred while executing the contract function "${o}".`, {
      cause: e,
      docsPath: s,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        p && "Contract Call:",
        p
      ].filter(Boolean),
      name: "ContractFunctionExecutionError"
    }), Object.defineProperty(this, "abi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "args", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "contractAddress", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "formattedArgs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "functionName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sender", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abi = r, this.args = n, this.cause = e, this.contractAddress = i, this.functionName = o, this.sender = a;
  }
}
class bO extends yt {
  constructor({ abi: e, data: r, functionName: n, message: i }) {
    let s, o, a, u;
    if (r && r !== "0x")
      try {
        o = cO({ abi: e, data: r });
        const { abiItem: d, errorName: p, args: x } = o;
        if (p === "Error")
          u = x[0];
        else if (p === "Panic") {
          const [A] = x;
          u = WD[A];
        } else {
          const A = d ? gu(d, { includeName: !0 }) : void 0, I = d && x ? q5({
            abiItem: d,
            args: x,
            includeFunctionName: !1,
            includeName: !1
          }) : void 0;
          a = [
            A ? `Error: ${A}` : "",
            I && I !== "()" ? `       ${[...Array((p == null ? void 0 : p.length) ?? 0).keys()].map(() => " ").join("")}${I}` : ""
          ];
        }
      } catch (d) {
        s = d;
      }
    else i && (u = i);
    let h;
    s instanceof w5 && (h = s.signature, a = [
      `Unable to decode signature "${h}" as it was not found on the provided ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${h}.`
    ]), super(u && u !== "execution reverted" || h ? [
      `The contract function "${n}" reverted with the following ${h ? "signature" : "reason"}:`,
      u || h
    ].join(`
`) : `The contract function "${n}" reverted.`, {
      cause: s,
      metaMessages: a,
      name: "ContractFunctionRevertedError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reason", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = o, this.reason = u, this.signature = h;
  }
}
class yO extends yt {
  constructor({ functionName: e }) {
    super(`The contract function "${e}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${e}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ],
      name: "ContractFunctionZeroDataError"
    });
  }
}
class wO extends yt {
  constructor({ data: e, message: r }) {
    super(r || "", { name: "RawContractError" }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = e;
  }
}
class K5 extends yt {
  constructor({ body: e, cause: r, details: n, headers: i, status: s, url: o }) {
    super("HTTP request failed.", {
      cause: r,
      details: n,
      metaMessages: [
        s && `Status: ${s}`,
        `URL: ${W5(o)}`,
        e && `Request body: ${Cu(e)}`
      ].filter(Boolean),
      name: "HttpRequestError"
    }), Object.defineProperty(this, "body", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "url", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.body = e, this.headers = i, this.status = s, this.url = o;
  }
}
class xO extends yt {
  constructor({ body: e, error: r, url: n }) {
    super("RPC Request failed.", {
      cause: r,
      details: r.message,
      metaMessages: [`URL: ${W5(n)}`, `Request body: ${Cu(e)}`],
      name: "RpcRequestError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.code = r.code;
  }
}
const _O = -1;
class Ei extends yt {
  constructor(e, { code: r, docsPath: n, metaMessages: i, name: s, shortMessage: o }) {
    super(o, {
      cause: e,
      docsPath: n,
      metaMessages: i || (e == null ? void 0 : e.metaMessages),
      name: s || "RpcError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = s || e.name, this.code = e instanceof xO ? e.code : r ?? _O;
  }
}
class Tu extends Ei {
  constructor(e, r) {
    super(e, r), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = r.data;
  }
}
class el extends Ei {
  constructor(e) {
    super(e, {
      code: el.code,
      name: "ParseRpcError",
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    });
  }
}
Object.defineProperty(el, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32700
});
class tl extends Ei {
  constructor(e) {
    super(e, {
      code: tl.code,
      name: "InvalidRequestRpcError",
      shortMessage: "JSON is not a valid request object."
    });
  }
}
Object.defineProperty(tl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32600
});
class rl extends Ei {
  constructor(e, { method: r } = {}) {
    super(e, {
      code: rl.code,
      name: "MethodNotFoundRpcError",
      shortMessage: `The method${r ? ` "${r}"` : ""} does not exist / is not available.`
    });
  }
}
Object.defineProperty(rl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32601
});
class nl extends Ei {
  constructor(e) {
    super(e, {
      code: nl.code,
      name: "InvalidParamsRpcError",
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    });
  }
}
Object.defineProperty(nl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602
});
class sc extends Ei {
  constructor(e) {
    super(e, {
      code: sc.code,
      name: "InternalRpcError",
      shortMessage: "An internal error was received."
    });
  }
}
Object.defineProperty(sc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603
});
class il extends Ei {
  constructor(e) {
    super(e, {
      code: il.code,
      name: "InvalidInputRpcError",
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    });
  }
}
Object.defineProperty(il, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32e3
});
class sl extends Ei {
  constructor(e) {
    super(e, {
      code: sl.code,
      name: "ResourceNotFoundRpcError",
      shortMessage: "Requested resource not found."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty(sl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32001
});
class ol extends Ei {
  constructor(e) {
    super(e, {
      code: ol.code,
      name: "ResourceUnavailableRpcError",
      shortMessage: "Requested resource not available."
    });
  }
}
Object.defineProperty(ol, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32002
});
class al extends Ei {
  constructor(e) {
    super(e, {
      code: al.code,
      name: "TransactionRejectedRpcError",
      shortMessage: "Transaction creation failed."
    });
  }
}
Object.defineProperty(al, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32003
});
class cl extends Ei {
  constructor(e, { method: r } = {}) {
    super(e, {
      code: cl.code,
      name: "MethodNotSupportedRpcError",
      shortMessage: `Method${r ? ` "${r}"` : ""} is not implemented.`
    });
  }
}
Object.defineProperty(cl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32004
});
class yu extends Ei {
  constructor(e) {
    super(e, {
      code: yu.code,
      name: "LimitExceededRpcError",
      shortMessage: "Request exceeds defined limit."
    });
  }
}
Object.defineProperty(yu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32005
});
class ul extends Ei {
  constructor(e) {
    super(e, {
      code: ul.code,
      name: "JsonRpcVersionUnsupportedError",
      shortMessage: "Version of JSON-RPC protocol is not supported."
    });
  }
}
Object.defineProperty(ul, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32006
});
class ou extends Tu {
  constructor(e) {
    super(e, {
      code: ou.code,
      name: "UserRejectedRequestError",
      shortMessage: "User rejected the request."
    });
  }
}
Object.defineProperty(ou, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4001
});
class fl extends Tu {
  constructor(e) {
    super(e, {
      code: fl.code,
      name: "UnauthorizedProviderError",
      shortMessage: "The requested method and/or account has not been authorized by the user."
    });
  }
}
Object.defineProperty(fl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4100
});
class ll extends Tu {
  constructor(e, { method: r } = {}) {
    super(e, {
      code: ll.code,
      name: "UnsupportedProviderMethodError",
      shortMessage: `The Provider does not support the requested method${r ? ` " ${r}"` : ""}.`
    });
  }
}
Object.defineProperty(ll, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4200
});
class hl extends Tu {
  constructor(e) {
    super(e, {
      code: hl.code,
      name: "ProviderDisconnectedError",
      shortMessage: "The Provider is disconnected from all chains."
    });
  }
}
Object.defineProperty(hl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4900
});
class dl extends Tu {
  constructor(e) {
    super(e, {
      code: dl.code,
      name: "ChainDisconnectedError",
      shortMessage: "The Provider is not connected to the requested chain."
    });
  }
}
Object.defineProperty(dl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4901
});
class pl extends Tu {
  constructor(e) {
    super(e, {
      code: pl.code,
      name: "SwitchChainError",
      shortMessage: "An error occurred when attempting to switch chain."
    });
  }
}
Object.defineProperty(pl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4902
});
class EO extends Ei {
  constructor(e) {
    super(e, {
      name: "UnknownRpcError",
      shortMessage: "An unknown RPC error occurred."
    });
  }
}
const SO = 3;
function AO(t, { abi: e, address: r, args: n, docsPath: i, functionName: s, sender: o }) {
  const { code: a, data: u, message: h, shortMessage: d } = t instanceof wO ? t : t instanceof yt ? t.walk((x) => "data" in x) || t.walk() : {}, p = t instanceof wv ? new yO({ functionName: s }) : [SO, sc.code].includes(a) && (u || h || d) ? new bO({
    abi: e,
    data: typeof u == "object" ? u.data : u,
    functionName: s,
    message: d ?? h
  }) : t;
  return new vO(p, {
    abi: e,
    args: n,
    contractAddress: r,
    docsPath: i,
    functionName: s,
    sender: o
  });
}
function PO(t) {
  const e = kl(`0x${t.substring(4)}`).substring(26);
  return $l(`0x${e}`);
}
async function MO({ hash: t, signature: e }) {
  const r = pa(t) ? t : qd(t), { secp256k1: n } = await import("./secp256k1-DGg-fnqm.js");
  return `0x${(() => {
    if (typeof e == "object" && "r" in e && "s" in e) {
      const { r: h, s: d, v: p, yParity: x } = e, A = Number(x ?? p), I = P2(A);
      return new n.Signature(Zf(h), Zf(d)).addRecoveryBit(I);
    }
    const o = pa(e) ? e : qd(e), a = mu(`0x${o.slice(130)}`), u = P2(a);
    return n.Signature.fromCompact(o.substring(2, 130)).addRecoveryBit(u);
  })().recoverPublicKey(r.substring(2)).toHex(!1)}`;
}
function P2(t) {
  if (t === 0 || t === 1)
    return t;
  if (t === 27)
    return 0;
  if (t === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}
async function IO({ hash: t, signature: e }) {
  return PO(await MO({ hash: t, signature: e }));
}
function CO(t, e = "hex") {
  const r = V5(t), n = Mv(new Uint8Array(r.length));
  return r.encode(n), e === "hex" ? wi(n.bytes) : n.bytes;
}
function V5(t) {
  return Array.isArray(t) ? TO(t.map((e) => V5(e))) : RO(t);
}
function TO(t) {
  const e = t.reduce((i, s) => i + s.length, 0), r = G5(e);
  return {
    length: e <= 55 ? 1 + e : 1 + r + e,
    encode(i) {
      e <= 55 ? i.pushByte(192 + e) : (i.pushByte(247 + r), r === 1 ? i.pushUint8(e) : r === 2 ? i.pushUint16(e) : r === 3 ? i.pushUint24(e) : i.pushUint32(e));
      for (const { encode: s } of t)
        s(i);
    }
  };
}
function RO(t) {
  const e = typeof t == "string" ? Do(t) : t, r = G5(e.length);
  return {
    length: e.length === 1 && e[0] < 128 ? 1 : e.length <= 55 ? 1 + e.length : 1 + r + e.length,
    encode(i) {
      e.length === 1 && e[0] < 128 ? i.pushBytes(e) : e.length <= 55 ? (i.pushByte(128 + e.length), i.pushBytes(e)) : (i.pushByte(183 + r), r === 1 ? i.pushUint8(e.length) : r === 2 ? i.pushUint16(e.length) : r === 3 ? i.pushUint24(e.length) : i.pushUint32(e.length), i.pushBytes(e));
    }
  };
}
function G5(t) {
  if (t < 2 ** 8)
    return 1;
  if (t < 2 ** 16)
    return 2;
  if (t < 2 ** 24)
    return 3;
  if (t < 2 ** 32)
    return 4;
  throw new yt("Length is too large.");
}
function DO(t) {
  const { chainId: e, contractAddress: r, nonce: n, to: i } = t, s = kl(R0([
    "0x05",
    CO([
      e ? Mr(e) : "0x",
      r,
      n ? Mr(n) : "0x"
    ])
  ]));
  return i === "bytes" ? Do(s) : s;
}
async function Y5(t) {
  const { authorization: e, signature: r } = t;
  return IO({
    hash: DO(e),
    signature: r ?? e
  });
}
class OO extends yt {
  constructor(e, { account: r, docsPath: n, chain: i, data: s, gas: o, gasPrice: a, maxFeePerGas: u, maxPriorityFeePerGas: h, nonce: d, to: p, value: x }) {
    var I;
    const A = D0({
      from: r == null ? void 0 : r.address,
      to: p,
      value: typeof x < "u" && `${H5(x)} ${((I = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : I.symbol) || "ETH"}`,
      data: s,
      gas: o,
      gasPrice: typeof a < "u" && `${_s(a)} gwei`,
      maxFeePerGas: typeof u < "u" && `${_s(u)} gwei`,
      maxPriorityFeePerGas: typeof h < "u" && `${_s(h)} gwei`,
      nonce: d
    });
    super(e.shortMessage, {
      cause: e,
      docsPath: n,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        A
      ].filter(Boolean),
      name: "EstimateGasExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = e;
  }
}
class Jc extends yt {
  constructor({ cause: e, message: r } = {}) {
    var i;
    const n = (i = r == null ? void 0 : r.replace("execution reverted: ", "")) == null ? void 0 : i.replace("execution reverted", "");
    super(`Execution reverted ${n ? `with reason: ${n}` : "for an unknown reason"}.`, {
      cause: e,
      name: "ExecutionRevertedError"
    });
  }
}
Object.defineProperty(Jc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3
});
Object.defineProperty(Jc, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class Kd extends yt {
  constructor({ cause: e, maxFeePerGas: r } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${r ? ` = ${_s(r)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: e,
      name: "FeeCapTooHighError"
    });
  }
}
Object.defineProperty(Kd, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class Qm extends yt {
  constructor({ cause: e, maxFeePerGas: r } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${r ? ` = ${_s(r)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause: e,
      name: "FeeCapTooLowError"
    });
  }
}
Object.defineProperty(Qm, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class e1 extends yt {
  constructor({ cause: e, nonce: r } = {}) {
    super(`Nonce provided for the transaction ${r ? `(${r}) ` : ""}is higher than the next one expected.`, { cause: e, name: "NonceTooHighError" });
  }
}
Object.defineProperty(e1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/
});
class t1 extends yt {
  constructor({ cause: e, nonce: r } = {}) {
    super([
      `Nonce provided for the transaction ${r ? `(${r}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join(`
`), { cause: e, name: "NonceTooLowError" });
  }
}
Object.defineProperty(t1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/
});
class r1 extends yt {
  constructor({ cause: e, nonce: r } = {}) {
    super(`Nonce provided for the transaction ${r ? `(${r}) ` : ""}exceeds the maximum allowed nonce.`, { cause: e, name: "NonceMaxValueError" });
  }
}
Object.defineProperty(r1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/
});
class n1 extends yt {
  constructor({ cause: e } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join(`
`), {
      cause: e,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ],
      name: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(n1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds|exceeds transaction sender account balance/
});
class i1 extends yt {
  constructor({ cause: e, gas: r } = {}) {
    super(`The amount of gas ${r ? `(${r}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause: e,
      name: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(i1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/
});
class s1 extends yt {
  constructor({ cause: e, gas: r } = {}) {
    super(`The amount of gas ${r ? `(${r}) ` : ""}provided for the transaction is too low.`, {
      cause: e,
      name: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(s1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/
});
class o1 extends yt {
  constructor({ cause: e }) {
    super("The transaction type is not supported for this chain.", {
      cause: e,
      name: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(o1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/
});
class Vd extends yt {
  constructor({ cause: e, maxPriorityFeePerGas: r, maxFeePerGas: n } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${r ? ` = ${_s(r)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${n ? ` = ${_s(n)} gwei` : ""}).`
    ].join(`
`), {
      cause: e,
      name: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(Vd, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class Iv extends yt {
  constructor({ cause: e }) {
    super(`An error occurred while executing: ${e == null ? void 0 : e.shortMessage}`, {
      cause: e,
      name: "UnknownNodeError"
    });
  }
}
function J5(t, e) {
  const r = (t.details || "").toLowerCase(), n = t instanceof yt ? t.walk((i) => (i == null ? void 0 : i.code) === Jc.code) : t;
  return n instanceof yt ? new Jc({
    cause: t,
    message: n.details
  }) : Jc.nodeMessage.test(r) ? new Jc({
    cause: t,
    message: t.details
  }) : Kd.nodeMessage.test(r) ? new Kd({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas
  }) : Qm.nodeMessage.test(r) ? new Qm({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas
  }) : e1.nodeMessage.test(r) ? new e1({ cause: t, nonce: e == null ? void 0 : e.nonce }) : t1.nodeMessage.test(r) ? new t1({ cause: t, nonce: e == null ? void 0 : e.nonce }) : r1.nodeMessage.test(r) ? new r1({ cause: t, nonce: e == null ? void 0 : e.nonce }) : n1.nodeMessage.test(r) ? new n1({ cause: t }) : i1.nodeMessage.test(r) ? new i1({ cause: t, gas: e == null ? void 0 : e.gas }) : s1.nodeMessage.test(r) ? new s1({ cause: t, gas: e == null ? void 0 : e.gas }) : o1.nodeMessage.test(r) ? new o1({ cause: t }) : Vd.nodeMessage.test(r) ? new Vd({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas,
    maxPriorityFeePerGas: e == null ? void 0 : e.maxPriorityFeePerGas
  }) : new Iv({
    cause: t
  });
}
function NO(t, { docsPath: e, ...r }) {
  const n = (() => {
    const i = J5(t, r);
    return i instanceof Iv ? t : i;
  })();
  return new OO(n, {
    docsPath: e,
    ...r
  });
}
function X5(t, { format: e }) {
  if (!e)
    return {};
  const r = {};
  function n(s) {
    const o = Object.keys(s);
    for (const a of o)
      a in t && (r[a] = t[a]), s[a] && typeof s[a] == "object" && !Array.isArray(s[a]) && n(s[a]);
  }
  const i = e(t || {});
  return n(i), r;
}
const LO = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
function Cv(t) {
  const e = {};
  return typeof t.authorizationList < "u" && (e.authorizationList = kO(t.authorizationList)), typeof t.accessList < "u" && (e.accessList = t.accessList), typeof t.blobVersionedHashes < "u" && (e.blobVersionedHashes = t.blobVersionedHashes), typeof t.blobs < "u" && (typeof t.blobs[0] != "string" ? e.blobs = t.blobs.map((r) => wi(r)) : e.blobs = t.blobs), typeof t.data < "u" && (e.data = t.data), typeof t.from < "u" && (e.from = t.from), typeof t.gas < "u" && (e.gas = Mr(t.gas)), typeof t.gasPrice < "u" && (e.gasPrice = Mr(t.gasPrice)), typeof t.maxFeePerBlobGas < "u" && (e.maxFeePerBlobGas = Mr(t.maxFeePerBlobGas)), typeof t.maxFeePerGas < "u" && (e.maxFeePerGas = Mr(t.maxFeePerGas)), typeof t.maxPriorityFeePerGas < "u" && (e.maxPriorityFeePerGas = Mr(t.maxPriorityFeePerGas)), typeof t.nonce < "u" && (e.nonce = Mr(t.nonce)), typeof t.to < "u" && (e.to = t.to), typeof t.type < "u" && (e.type = LO[t.type]), typeof t.value < "u" && (e.value = Mr(t.value)), e;
}
function kO(t) {
  return t.map((e) => ({
    address: e.contractAddress,
    r: e.r,
    s: e.s,
    chainId: Mr(e.chainId),
    nonce: Mr(e.nonce),
    ...typeof e.yParity < "u" ? { yParity: Mr(e.yParity) } : {},
    ...typeof e.v < "u" && typeof e.yParity > "u" ? { v: Mr(e.v) } : {}
  }));
}
function M2(t) {
  if (!(!t || t.length === 0))
    return t.reduce((e, { slot: r, value: n }) => {
      if (r.length !== 66)
        throw new m2({
          size: r.length,
          targetSize: 66,
          type: "hex"
        });
      if (n.length !== 66)
        throw new m2({
          size: n.length,
          targetSize: 66,
          type: "hex"
        });
      return e[r] = n, e;
    }, {});
}
function $O(t) {
  const { balance: e, nonce: r, state: n, stateDiff: i, code: s } = t, o = {};
  if (s !== void 0 && (o.code = s), e !== void 0 && (o.balance = Mr(e)), r !== void 0 && (o.nonce = Mr(r)), n !== void 0 && (o.state = M2(n)), i !== void 0) {
    if (o.state)
      throw new hO();
    o.stateDiff = M2(i);
  }
  return o;
}
function BO(t) {
  if (!t)
    return;
  const e = {};
  for (const { address: r, ...n } of t) {
    if (!Oo(r, { strict: !1 }))
      throw new vu({ address: r });
    if (e[r])
      throw new lO({ address: r });
    e[r] = $O(n);
  }
  return e;
}
const FO = 2n ** 256n - 1n;
function O0(t) {
  const { account: e, gasPrice: r, maxFeePerGas: n, maxPriorityFeePerGas: i, to: s } = t, o = e ? Fo(e) : void 0;
  if (o && !Oo(o.address))
    throw new vu({ address: o.address });
  if (s && !Oo(s))
    throw new vu({ address: s });
  if (typeof r < "u" && (typeof n < "u" || typeof i < "u"))
    throw new dO();
  if (n && n > FO)
    throw new Kd({ maxFeePerGas: n });
  if (i && n && i > n)
    throw new Vd({ maxFeePerGas: n, maxPriorityFeePerGas: i });
}
class UO extends yt {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError"
    });
  }
}
class Tv extends yt {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError"
    });
  }
}
class jO extends yt {
  constructor({ maxPriorityFeePerGas: e }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${_s(e)} gwei).`, { name: "MaxFeePerGasTooLowError" });
  }
}
class qO extends yt {
  constructor({ blockHash: e, blockNumber: r }) {
    let n = "Block";
    e && (n = `Block at hash "${e}"`), r && (n = `Block at number "${r}"`), super(`${n} could not be found.`, { name: "BlockNotFoundError" });
  }
}
const zO = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function HO(t) {
  const e = {
    ...t,
    blockHash: t.blockHash ? t.blockHash : null,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    chainId: t.chainId ? mu(t.chainId) : void 0,
    gas: t.gas ? BigInt(t.gas) : void 0,
    gasPrice: t.gasPrice ? BigInt(t.gasPrice) : void 0,
    maxFeePerBlobGas: t.maxFeePerBlobGas ? BigInt(t.maxFeePerBlobGas) : void 0,
    maxFeePerGas: t.maxFeePerGas ? BigInt(t.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: t.maxPriorityFeePerGas ? BigInt(t.maxPriorityFeePerGas) : void 0,
    nonce: t.nonce ? mu(t.nonce) : void 0,
    to: t.to ? t.to : null,
    transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
    type: t.type ? zO[t.type] : void 0,
    typeHex: t.type ? t.type : void 0,
    value: t.value ? BigInt(t.value) : void 0,
    v: t.v ? BigInt(t.v) : void 0
  };
  return t.authorizationList && (e.authorizationList = WO(t.authorizationList)), e.yParity = (() => {
    if (t.yParity)
      return Number(t.yParity);
    if (typeof e.v == "bigint") {
      if (e.v === 0n || e.v === 27n)
        return 0;
      if (e.v === 1n || e.v === 28n)
        return 1;
      if (e.v >= 35n)
        return e.v % 2n === 0n ? 1 : 0;
    }
  })(), e.type === "legacy" && (delete e.accessList, delete e.maxFeePerBlobGas, delete e.maxFeePerGas, delete e.maxPriorityFeePerGas, delete e.yParity), e.type === "eip2930" && (delete e.maxFeePerBlobGas, delete e.maxFeePerGas, delete e.maxPriorityFeePerGas), e.type === "eip1559" && delete e.maxFeePerBlobGas, e;
}
function WO(t) {
  return t.map((e) => ({
    contractAddress: e.address,
    chainId: Number(e.chainId),
    nonce: Number(e.nonce),
    r: e.r,
    s: e.s,
    yParity: Number(e.yParity)
  }));
}
function KO(t) {
  const e = (t.transactions ?? []).map((r) => typeof r == "string" ? r : HO(r));
  return {
    ...t,
    baseFeePerGas: t.baseFeePerGas ? BigInt(t.baseFeePerGas) : null,
    blobGasUsed: t.blobGasUsed ? BigInt(t.blobGasUsed) : void 0,
    difficulty: t.difficulty ? BigInt(t.difficulty) : void 0,
    excessBlobGas: t.excessBlobGas ? BigInt(t.excessBlobGas) : void 0,
    gasLimit: t.gasLimit ? BigInt(t.gasLimit) : void 0,
    gasUsed: t.gasUsed ? BigInt(t.gasUsed) : void 0,
    hash: t.hash ? t.hash : null,
    logsBloom: t.logsBloom ? t.logsBloom : null,
    nonce: t.nonce ? t.nonce : null,
    number: t.number ? BigInt(t.number) : null,
    size: t.size ? BigInt(t.size) : void 0,
    timestamp: t.timestamp ? BigInt(t.timestamp) : void 0,
    transactions: e,
    totalDifficulty: t.totalDifficulty ? BigInt(t.totalDifficulty) : null
  };
}
async function Gd(t, { blockHash: e, blockNumber: r, blockTag: n, includeTransactions: i } = {}) {
  var d, p, x;
  const s = n ?? "latest", o = i ?? !1, a = r !== void 0 ? Mr(r) : void 0;
  let u = null;
  if (e ? u = await t.request({
    method: "eth_getBlockByHash",
    params: [e, o]
  }, { dedupe: !0 }) : u = await t.request({
    method: "eth_getBlockByNumber",
    params: [a || s, o]
  }, { dedupe: !!a }), !u)
    throw new qO({ blockHash: e, blockNumber: r });
  return (((x = (p = (d = t.chain) == null ? void 0 : d.formatters) == null ? void 0 : p.block) == null ? void 0 : x.format) || KO)(u);
}
async function Z5(t) {
  const e = await t.request({
    method: "eth_gasPrice"
  });
  return BigInt(e);
}
async function VO(t, e) {
  var s, o;
  const { block: r, chain: n = t.chain, request: i } = e || {};
  try {
    const a = ((s = n == null ? void 0 : n.fees) == null ? void 0 : s.maxPriorityFeePerGas) ?? ((o = n == null ? void 0 : n.fees) == null ? void 0 : o.defaultPriorityFee);
    if (typeof a == "function") {
      const h = r || await vi(t, Gd, "getBlock")({}), d = await a({
        block: h,
        client: t,
        request: i
      });
      if (d === null)
        throw new Error();
      return d;
    }
    if (typeof a < "u")
      return a;
    const u = await t.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return Zf(u);
  } catch {
    const [a, u] = await Promise.all([
      r ? Promise.resolve(r) : vi(t, Gd, "getBlock")({}),
      vi(t, Z5, "getGasPrice")({})
    ]);
    if (typeof a.baseFeePerGas != "bigint")
      throw new Tv();
    const h = u - a.baseFeePerGas;
    return h < 0n ? 0n : h;
  }
}
async function I2(t, e) {
  var x, A;
  const { block: r, chain: n = t.chain, request: i, type: s = "eip1559" } = e || {}, o = await (async () => {
    var I, N;
    return typeof ((I = n == null ? void 0 : n.fees) == null ? void 0 : I.baseFeeMultiplier) == "function" ? n.fees.baseFeeMultiplier({
      block: r,
      client: t,
      request: i
    }) : ((N = n == null ? void 0 : n.fees) == null ? void 0 : N.baseFeeMultiplier) ?? 1.2;
  })();
  if (o < 1)
    throw new UO();
  const u = 10 ** (((x = o.toString().split(".")[1]) == null ? void 0 : x.length) ?? 0), h = (I) => I * BigInt(Math.ceil(o * u)) / BigInt(u), d = r || await vi(t, Gd, "getBlock")({});
  if (typeof ((A = n == null ? void 0 : n.fees) == null ? void 0 : A.estimateFeesPerGas) == "function") {
    const I = await n.fees.estimateFeesPerGas({
      block: r,
      client: t,
      multiply: h,
      request: i,
      type: s
    });
    if (I !== null)
      return I;
  }
  if (s === "eip1559") {
    if (typeof d.baseFeePerGas != "bigint")
      throw new Tv();
    const I = typeof (i == null ? void 0 : i.maxPriorityFeePerGas) == "bigint" ? i.maxPriorityFeePerGas : await VO(t, {
      block: d,
      chain: n,
      request: i
    }), N = h(d.baseFeePerGas);
    return {
      maxFeePerGas: (i == null ? void 0 : i.maxFeePerGas) ?? N + I,
      maxPriorityFeePerGas: I
    };
  }
  return {
    gasPrice: (i == null ? void 0 : i.gasPrice) ?? h(await vi(t, Z5, "getGasPrice")({}))
  };
}
async function GO(t, { address: e, blockTag: r = "latest", blockNumber: n }) {
  const i = await t.request({
    method: "eth_getTransactionCount",
    params: [e, n ? Mr(n) : r]
  }, { dedupe: !!n });
  return mu(i);
}
function Q5(t) {
  const { kzg: e } = t, r = t.to ?? (typeof t.blobs[0] == "string" ? "hex" : "bytes"), n = typeof t.blobs[0] == "string" ? t.blobs.map((s) => Do(s)) : t.blobs, i = [];
  for (const s of n)
    i.push(Uint8Array.from(e.blobToKzgCommitment(s)));
  return r === "bytes" ? i : i.map((s) => wi(s));
}
function e4(t) {
  const { kzg: e } = t, r = t.to ?? (typeof t.blobs[0] == "string" ? "hex" : "bytes"), n = typeof t.blobs[0] == "string" ? t.blobs.map((o) => Do(o)) : t.blobs, i = typeof t.commitments[0] == "string" ? t.commitments.map((o) => Do(o)) : t.commitments, s = [];
  for (let o = 0; o < n.length; o++) {
    const a = n[o], u = i[o];
    s.push(Uint8Array.from(e.computeBlobKzgProof(a, u)));
  }
  return r === "bytes" ? s : s.map((o) => wi(o));
}
function YO(t, e, r, n) {
  if (typeof t.setBigUint64 == "function")
    return t.setBigUint64(e, r, n);
  const i = BigInt(32), s = BigInt(4294967295), o = Number(r >> i & s), a = Number(r & s), u = n ? 4 : 0, h = n ? 0 : 4;
  t.setUint32(e + u, o, n), t.setUint32(e + h, a, n);
}
const JO = (t, e, r) => t & e ^ ~t & r, XO = (t, e, r) => t & e ^ t & r ^ e & r;
class ZO extends P5 {
  constructor(e, r, n, i) {
    super(), this.blockLen = e, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = Bg(this.buffer);
  }
  update(e) {
    Hd(this);
    const { view: r, buffer: n, blockLen: i } = this;
    e = C0(e);
    const s = e.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const u = Bg(e);
        for (; i <= s - o; o += i)
          this.process(u, o);
        continue;
      }
      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Hd(this), A5(e, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    r[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(n, 0), o = 0);
    for (let p = o; p < i; p++)
      r[p] = 0;
    YO(n, i - 8, BigInt(this.length * 8), s), this.process(n, 0);
    const a = Bg(e), u = this.outputLen;
    if (u % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const h = u / 4, d = this.get();
    if (h > d.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let p = 0; p < h; p++)
      a.setUint32(4 * p, d[p], s);
  }
  digest() {
    const { buffer: e, outputLen: r } = this;
    this.digestInto(e);
    const n = e.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: s, destroyed: o, pos: a } = this;
    return e.length = i, e.pos = a, e.finished = s, e.destroyed = o, i % r && e.buffer.set(n), e;
  }
}
const QO = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Jo = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Xo = /* @__PURE__ */ new Uint32Array(64);
let eN = class extends ZO {
  constructor() {
    super(64, 32, 8, !1), this.A = Jo[0] | 0, this.B = Jo[1] | 0, this.C = Jo[2] | 0, this.D = Jo[3] | 0, this.E = Jo[4] | 0, this.F = Jo[5] | 0, this.G = Jo[6] | 0, this.H = Jo[7] | 0;
  }
  get() {
    const { A: e, B: r, C: n, D: i, E: s, F: o, G: a, H: u } = this;
    return [e, r, n, i, s, o, a, u];
  }
  // prettier-ignore
  set(e, r, n, i, s, o, a, u) {
    this.A = e | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = u | 0;
  }
  process(e, r) {
    for (let p = 0; p < 16; p++, r += 4)
      Xo[p] = e.getUint32(r, !1);
    for (let p = 16; p < 64; p++) {
      const x = Xo[p - 15], A = Xo[p - 2], I = Ds(x, 7) ^ Ds(x, 18) ^ x >>> 3, N = Ds(A, 17) ^ Ds(A, 19) ^ A >>> 10;
      Xo[p] = N + Xo[p - 7] + I + Xo[p - 16] | 0;
    }
    let { A: n, B: i, C: s, D: o, E: a, F: u, G: h, H: d } = this;
    for (let p = 0; p < 64; p++) {
      const x = Ds(a, 6) ^ Ds(a, 11) ^ Ds(a, 25), A = d + x + JO(a, u, h) + QO[p] + Xo[p] | 0, N = (Ds(n, 2) ^ Ds(n, 13) ^ Ds(n, 22)) + XO(n, i, s) | 0;
      d = h, h = u, u = a, a = o + A | 0, o = s, s = i, i = n, n = A + N | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, h = h + this.G | 0, d = d + this.H | 0, this.set(n, i, s, o, a, u, h, d);
  }
  roundClean() {
    Xo.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const t4 = /* @__PURE__ */ M5(() => new eN());
function tN(t, e) {
  return t4(pa(t, { strict: !1 }) ? _v(t) : t);
}
function rN(t) {
  const { commitment: e, version: r = 1 } = t, n = t.to ?? (typeof e == "string" ? "hex" : "bytes"), i = tN(e);
  return i.set([r], 0), n === "bytes" ? i : wi(i);
}
function nN(t) {
  const { commitments: e, version: r } = t, n = t.to ?? (typeof e[0] == "string" ? "hex" : "bytes"), i = [];
  for (const s of e)
    i.push(rN({
      commitment: s,
      to: n,
      version: r
    }));
  return i;
}
const C2 = 6, r4 = 32, Rv = 4096, n4 = r4 * Rv, T2 = n4 * C2 - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * Rv * C2;
class iN extends yt {
  constructor({ maxSize: e, size: r }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${e} bytes`, `Given: ${r} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
}
class sN extends yt {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}
function oN(t) {
  const e = t.to ?? (typeof t.data == "string" ? "hex" : "bytes"), r = typeof t.data == "string" ? Do(t.data) : t.data, n = An(r);
  if (!n)
    throw new sN();
  if (n > T2)
    throw new iN({
      maxSize: T2,
      size: n
    });
  const i = [];
  let s = !0, o = 0;
  for (; s; ) {
    const a = Mv(new Uint8Array(n4));
    let u = 0;
    for (; u < Rv; ) {
      const h = r.slice(o, o + (r4 - 1));
      if (a.pushByte(0), a.pushBytes(h), h.length < 31) {
        a.pushByte(128), s = !1;
        break;
      }
      u++, o += 31;
    }
    i.push(a);
  }
  return e === "bytes" ? i.map((a) => a.bytes) : i.map((a) => wi(a.bytes));
}
function aN(t) {
  const { data: e, kzg: r, to: n } = t, i = t.blobs ?? oN({ data: e, to: n }), s = t.commitments ?? Q5({ blobs: i, kzg: r, to: n }), o = t.proofs ?? e4({ blobs: i, commitments: s, kzg: r, to: n }), a = [];
  for (let u = 0; u < i.length; u++)
    a.push({
      blob: i[u],
      commitment: s[u],
      proof: o[u]
    });
  return a;
}
function cN(t) {
  if (t.type)
    return t.type;
  if (typeof t.authorizationList < "u")
    return "eip7702";
  if (typeof t.blobs < "u" || typeof t.blobVersionedHashes < "u" || typeof t.maxFeePerBlobGas < "u" || typeof t.sidecars < "u")
    return "eip4844";
  if (typeof t.maxFeePerGas < "u" || typeof t.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof t.gasPrice < "u")
    return typeof t.accessList < "u" ? "eip2930" : "legacy";
  throw new pO({ transaction: t });
}
async function N0(t) {
  const e = await t.request({
    method: "eth_chainId"
  }, { dedupe: !0 });
  return mu(e);
}
const i4 = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];
async function Dv(t, e) {
  const { account: r = t.account, blobs: n, chain: i, gas: s, kzg: o, nonce: a, nonceManager: u, parameters: h = i4, type: d } = e, p = r && Fo(r), x = { ...e, ...p ? { from: p == null ? void 0 : p.address } : {} };
  let A;
  async function I() {
    return A || (A = await vi(t, Gd, "getBlock")({ blockTag: "latest" }), A);
  }
  let N;
  async function L() {
    return N || (i ? i.id : typeof e.chainId < "u" ? e.chainId : (N = await vi(t, N0, "getChainId")({}), N));
  }
  if ((h.includes("blobVersionedHashes") || h.includes("sidecars")) && n && o) {
    const F = Q5({ blobs: n, kzg: o });
    if (h.includes("blobVersionedHashes")) {
      const $ = nN({
        commitments: F,
        to: "hex"
      });
      x.blobVersionedHashes = $;
    }
    if (h.includes("sidecars")) {
      const $ = e4({ blobs: n, commitments: F, kzg: o }), W = aN({
        blobs: n,
        commitments: F,
        proofs: $,
        to: "hex"
      });
      x.sidecars = W;
    }
  }
  if (h.includes("chainId") && (x.chainId = await L()), h.includes("nonce") && typeof a > "u" && p)
    if (u) {
      const F = await L();
      x.nonce = await u.consume({
        address: p.address,
        chainId: F,
        client: t
      });
    } else
      x.nonce = await vi(t, GO, "getTransactionCount")({
        address: p.address,
        blockTag: "pending"
      });
  if ((h.includes("fees") || h.includes("type")) && typeof d > "u")
    try {
      x.type = cN(x);
    } catch {
      const F = await I();
      x.type = typeof (F == null ? void 0 : F.baseFeePerGas) == "bigint" ? "eip1559" : "legacy";
    }
  if (h.includes("fees"))
    if (x.type !== "legacy" && x.type !== "eip2930") {
      if (typeof x.maxFeePerGas > "u" || typeof x.maxPriorityFeePerGas > "u") {
        const F = await I(), { maxFeePerGas: $, maxPriorityFeePerGas: W } = await I2(t, {
          block: F,
          chain: i,
          request: x
        });
        if (typeof e.maxPriorityFeePerGas > "u" && e.maxFeePerGas && e.maxFeePerGas < W)
          throw new jO({
            maxPriorityFeePerGas: W
          });
        x.maxPriorityFeePerGas = W, x.maxFeePerGas = $;
      }
    } else {
      if (typeof e.maxFeePerGas < "u" || typeof e.maxPriorityFeePerGas < "u")
        throw new Tv();
      const F = await I(), { gasPrice: $ } = await I2(t, {
        block: F,
        chain: i,
        request: x,
        type: "legacy"
      });
      x.gasPrice = $;
    }
  return h.includes("gas") && typeof s > "u" && (x.gas = await vi(t, fN, "estimateGas")({
    ...x,
    account: p && { address: p.address, type: "json-rpc" }
  })), O0(x), delete x.parameters, x;
}
async function uN(t, { address: e, blockNumber: r, blockTag: n = "latest" }) {
  const i = r ? Mr(r) : void 0, s = await t.request({
    method: "eth_getBalance",
    params: [e, i || n]
  });
  return BigInt(s);
}
async function fN(t, e) {
  var i, s, o;
  const { account: r = t.account } = e, n = r ? Fo(r) : void 0;
  try {
    let f = function(b) {
      const { block: w, request: _, rpcStateOverride: E } = b;
      return t.request({
        method: "eth_estimateGas",
        params: E ? [_, w ?? "latest", E] : w ? [_, w] : [_]
      });
    };
    const { accessList: a, authorizationList: u, blobs: h, blobVersionedHashes: d, blockNumber: p, blockTag: x, data: A, gas: I, gasPrice: N, maxFeePerBlobGas: L, maxFeePerGas: F, maxPriorityFeePerGas: $, nonce: W, value: z, stateOverride: V, ...te } = await Dv(t, {
      ...e,
      parameters: (
        // Some RPC Providers do not compute versioned hashes from blobs. We will need
        // to compute them.
        (n == null ? void 0 : n.type) === "local" ? void 0 : ["blobVersionedHashes"]
      )
    }), K = (p ? Mr(p) : void 0) || x, pe = BO(V), _e = await (async () => {
      if (te.to)
        return te.to;
      if (u && u.length > 0)
        return await Y5({
          authorization: u[0]
        }).catch(() => {
          throw new yt("`to` is required. Could not infer from `authorizationList`");
        });
    })();
    O0(e);
    const Y = (o = (s = (i = t.chain) == null ? void 0 : i.formatters) == null ? void 0 : s.transactionRequest) == null ? void 0 : o.format, m = (Y || Cv)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...X5(te, { format: Y }),
      from: n == null ? void 0 : n.address,
      accessList: a,
      authorizationList: u,
      blobs: h,
      blobVersionedHashes: d,
      data: A,
      gas: I,
      gasPrice: N,
      maxFeePerBlobGas: L,
      maxFeePerGas: F,
      maxPriorityFeePerGas: $,
      nonce: W,
      to: _e,
      value: z
    });
    let g = BigInt(await f({ block: K, request: m, rpcStateOverride: pe }));
    if (u) {
      const b = await uN(t, { address: m.from }), w = await Promise.all(u.map(async (_) => {
        const { contractAddress: E } = _, v = await f({
          block: K,
          request: {
            authorizationList: void 0,
            data: A,
            from: n == null ? void 0 : n.address,
            to: E,
            value: Mr(b)
          },
          rpcStateOverride: pe
        }).catch(() => 100000n);
        return 2n * BigInt(v);
      }));
      g += w.reduce((_, E) => _ + E, 0n);
    }
    return g;
  } catch (a) {
    throw NO(a, {
      ...e,
      account: n,
      chain: t.chain
    });
  }
}
class lN extends yt {
  constructor({ chain: e, currentChainId: r }) {
    super(`The current chain of the wallet (id: ${r}) does not match the target chain for the transaction (id: ${e.id} – ${e.name}).`, {
      metaMessages: [
        `Current Chain ID:  ${r}`,
        `Expected Chain ID: ${e.id} – ${e.name}`
      ],
      name: "ChainMismatchError"
    });
  }
}
class hN extends yt {
  constructor() {
    super([
      "No chain was provided to the request.",
      "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
    ].join(`
`), {
      name: "ChainNotFoundError"
    });
  }
}
const jg = "/docs/contract/encodeDeployData";
function dN(t) {
  const { abi: e, args: r, bytecode: n } = t;
  if (!r || r.length === 0)
    return n;
  const i = e.find((o) => "type" in o && o.type === "constructor");
  if (!i)
    throw new RR({ docsPath: jg });
  if (!("inputs" in i))
    throw new p2({ docsPath: jg });
  if (!i.inputs || i.inputs.length === 0)
    throw new p2({ docsPath: jg });
  const s = F5(i.inputs, r);
  return R0([n, s]);
}
async function pN(t) {
  return new Promise((e) => setTimeout(e, t));
}
class Bl extends yt {
  constructor({ docsPath: e } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join(`
`), {
      docsPath: e,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
}
class qg extends yt {
  constructor({ docsPath: e, metaMessages: r, type: n }) {
    super(`Account type "${n}" is not supported.`, {
      docsPath: e,
      metaMessages: r,
      name: "AccountTypeNotSupportedError"
    });
  }
}
function s4({ chain: t, currentChainId: e }) {
  if (!t)
    throw new hN();
  if (e !== t.id)
    throw new lN({ chain: t, currentChainId: e });
}
function gN(t, { docsPath: e, ...r }) {
  const n = (() => {
    const i = J5(t, r);
    return i instanceof Iv ? t : i;
  })();
  return new gO(n, {
    docsPath: e,
    ...r
  });
}
async function o4(t, { serializedTransaction: e }) {
  return t.request({
    method: "eth_sendRawTransaction",
    params: [e]
  }, { retryCount: 0 });
}
const zg = new T0(128);
async function Ov(t, e) {
  var F, $, W, z;
  const { account: r = t.account, chain: n = t.chain, accessList: i, authorizationList: s, blobs: o, data: a, gas: u, gasPrice: h, maxFeePerBlobGas: d, maxFeePerGas: p, maxPriorityFeePerGas: x, nonce: A, value: I, ...N } = e;
  if (typeof r > "u")
    throw new Bl({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const L = r ? Fo(r) : null;
  try {
    O0(e);
    const V = await (async () => {
      if (e.to)
        return e.to;
      if (s && s.length > 0)
        return await Y5({
          authorization: s[0]
        }).catch(() => {
          throw new yt("`to` is required. Could not infer from `authorizationList`.");
        });
    })();
    if ((L == null ? void 0 : L.type) === "json-rpc" || L === null) {
      let te;
      n !== null && (te = await vi(t, N0, "getChainId")({}), s4({
        currentChainId: te,
        chain: n
      }));
      const R = (W = ($ = (F = t.chain) == null ? void 0 : F.formatters) == null ? void 0 : $.transactionRequest) == null ? void 0 : W.format, pe = (R || Cv)({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...X5(N, { format: R }),
        accessList: i,
        authorizationList: s,
        blobs: o,
        chainId: te,
        data: a,
        from: L == null ? void 0 : L.address,
        gas: u,
        gasPrice: h,
        maxFeePerBlobGas: d,
        maxFeePerGas: p,
        maxPriorityFeePerGas: x,
        nonce: A,
        to: V,
        value: I
      }), _e = zg.get(t.uid), Y = _e ? "wallet_sendTransaction" : "eth_sendTransaction";
      try {
        return await t.request({
          method: Y,
          params: [pe]
        }, { retryCount: 0 });
      } catch (S) {
        if (_e === !1)
          throw S;
        const m = S;
        if (m.name === "InvalidInputRpcError" || m.name === "InvalidParamsRpcError" || m.name === "MethodNotFoundRpcError" || m.name === "MethodNotSupportedRpcError")
          return await t.request({
            method: "wallet_sendTransaction",
            params: [pe]
          }, { retryCount: 0 }).then((f) => (zg.set(t.uid, !0), f)).catch((f) => {
            const g = f;
            throw g.name === "MethodNotFoundRpcError" || g.name === "MethodNotSupportedRpcError" ? (zg.set(t.uid, !1), m) : g;
          });
        throw m;
      }
    }
    if ((L == null ? void 0 : L.type) === "local") {
      const te = await vi(t, Dv, "prepareTransactionRequest")({
        account: L,
        accessList: i,
        authorizationList: s,
        blobs: o,
        chain: n,
        data: a,
        gas: u,
        gasPrice: h,
        maxFeePerBlobGas: d,
        maxFeePerGas: p,
        maxPriorityFeePerGas: x,
        nonce: A,
        nonceManager: L.nonceManager,
        parameters: [...i4, "sidecars"],
        value: I,
        ...N,
        to: V
      }), R = (z = n == null ? void 0 : n.serializers) == null ? void 0 : z.transaction, K = await L.signTransaction(te, {
        serializer: R
      });
      return await vi(t, o4, "sendRawTransaction")({
        serializedTransaction: K
      });
    }
    throw (L == null ? void 0 : L.type) === "smart" ? new qg({
      metaMessages: [
        "Consider using the `sendUserOperation` Action instead."
      ],
      docsPath: "/docs/actions/bundler/sendUserOperation",
      type: "smart"
    }) : new qg({
      docsPath: "/docs/actions/wallet/sendTransaction",
      type: L == null ? void 0 : L.type
    });
  } catch (V) {
    throw V instanceof qg ? V : gN(V, {
      ...e,
      account: L,
      chain: e.chain || void 0
    });
  }
}
async function mN(t, e) {
  const { abi: r, account: n = t.account, address: i, args: s, dataSuffix: o, functionName: a, ...u } = e;
  if (typeof n > "u")
    throw new Bl({
      docsPath: "/docs/contract/writeContract"
    });
  const h = n ? Fo(n) : null, d = HD({
    abi: r,
    args: s,
    functionName: a
  });
  try {
    return await vi(t, Ov, "sendTransaction")({
      data: `${d}${o ? o.replace("0x", "") : ""}`,
      to: i,
      account: h,
      ...u
    });
  } catch (p) {
    throw AO(p, {
      abi: r,
      address: i,
      args: s,
      docsPath: "/docs/contract/writeContract",
      functionName: a,
      sender: h == null ? void 0 : h.address
    });
  }
}
async function vN(t, { chain: e }) {
  const { id: r, name: n, nativeCurrency: i, rpcUrls: s, blockExplorers: o } = e;
  await t.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: Mr(r),
        chainName: n,
        nativeCurrency: i,
        rpcUrls: s.default.http,
        blockExplorerUrls: o ? Object.values(o).map(({ url: a }) => a) : void 0
      }
    ]
  }, { dedupe: !0, retryCount: 0 });
}
const a1 = 256;
let rd = a1, nd;
function a4(t = 11) {
  if (!nd || rd + t > a1 * 2) {
    nd = "", rd = 0;
    for (let e = 0; e < a1; e++)
      nd += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return nd.substring(rd, rd++ + t);
}
function bN(t) {
  const { batch: e, cacheTime: r = t.pollingInterval ?? 4e3, ccipRead: n, key: i = "base", name: s = "Base Client", pollingInterval: o = 4e3, type: a = "base" } = t, u = t.chain, h = t.account ? Fo(t.account) : void 0, { config: d, request: p, value: x } = t.transport({
    chain: u,
    pollingInterval: o
  }), A = { ...d, ...x }, I = {
    account: h,
    batch: e,
    cacheTime: r,
    ccipRead: n,
    chain: u,
    key: i,
    name: s,
    pollingInterval: o,
    request: p,
    transport: A,
    type: a,
    uid: a4()
  };
  function N(L) {
    return (F) => {
      const $ = F(L);
      for (const z in I)
        delete $[z];
      const W = { ...L, ...$ };
      return Object.assign(W, { extend: N(W) });
    };
  }
  return Object.assign(I, { extend: N(I) });
}
const id = /* @__PURE__ */ new T0(8192);
function yN(t, { enabled: e = !0, id: r }) {
  if (!e || !r)
    return t();
  if (id.get(r))
    return id.get(r);
  const n = t().finally(() => id.delete(r));
  return id.set(r, n), n;
}
function wN(t, { delay: e = 100, retryCount: r = 2, shouldRetry: n = () => !0 } = {}) {
  return new Promise((i, s) => {
    const o = async ({ count: a = 0 } = {}) => {
      const u = async ({ error: h }) => {
        const d = typeof e == "function" ? e({ count: a, error: h }) : e;
        d && await pN(d), o({ count: a + 1 });
      };
      try {
        const h = await t();
        i(h);
      } catch (h) {
        if (a < r && await n({ count: a, error: h }))
          return u({ error: h });
        s(h);
      }
    };
    o();
  });
}
function xN(t, e = {}) {
  return async (r, n = {}) => {
    const { dedupe: i = !1, retryDelay: s = 150, retryCount: o = 3, uid: a } = {
      ...e,
      ...n
    }, u = i ? kl(I0(`${a}.${Cu(r)}`)) : void 0;
    return yN(() => wN(async () => {
      try {
        return await t(r);
      } catch (h) {
        const d = h;
        switch (d.code) {
          case el.code:
            throw new el(d);
          case tl.code:
            throw new tl(d);
          case rl.code:
            throw new rl(d, { method: r.method });
          case nl.code:
            throw new nl(d);
          case sc.code:
            throw new sc(d);
          case il.code:
            throw new il(d);
          case sl.code:
            throw new sl(d);
          case ol.code:
            throw new ol(d);
          case al.code:
            throw new al(d);
          case cl.code:
            throw new cl(d, {
              method: r.method
            });
          case yu.code:
            throw new yu(d);
          case ul.code:
            throw new ul(d);
          case ou.code:
            throw new ou(d);
          case fl.code:
            throw new fl(d);
          case ll.code:
            throw new ll(d);
          case hl.code:
            throw new hl(d);
          case dl.code:
            throw new dl(d);
          case pl.code:
            throw new pl(d);
          case 5e3:
            throw new ou(d);
          default:
            throw h instanceof yt ? h : new EO(d);
        }
      }
    }, {
      delay: ({ count: h, error: d }) => {
        var p;
        if (d && d instanceof K5) {
          const x = (p = d == null ? void 0 : d.headers) == null ? void 0 : p.get("Retry-After");
          if (x != null && x.match(/\d/))
            return Number.parseInt(x) * 1e3;
        }
        return ~~(1 << h) * s;
      },
      retryCount: o,
      shouldRetry: ({ error: h }) => _N(h)
    }), { enabled: i, id: u });
  };
}
function _N(t) {
  return "code" in t && typeof t.code == "number" ? t.code === -1 || t.code === yu.code || t.code === sc.code : t instanceof K5 && t.status ? t.status === 403 || t.status === 408 || t.status === 413 || t.status === 429 || t.status === 500 || t.status === 502 || t.status === 503 || t.status === 504 : !0;
}
function EN({ key: t, name: e, request: r, retryCount: n = 3, retryDelay: i = 150, timeout: s, type: o }, a) {
  const u = a4();
  return {
    config: {
      key: t,
      name: e,
      request: r,
      retryCount: n,
      retryDelay: i,
      timeout: s,
      type: o
    },
    request: xN(r, { retryCount: n, retryDelay: i, uid: u }),
    value: a
  };
}
function SN(t, e = {}) {
  const { key: r = "custom", name: n = "Custom Provider", retryDelay: i } = e;
  return ({ retryCount: s }) => EN({
    key: r,
    name: n,
    request: t.request.bind(t),
    retryCount: e.retryCount ?? s,
    retryDelay: i,
    type: "custom"
  });
}
const AN = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, PN = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
class MN extends yt {
  constructor({ domain: e }) {
    super(`Invalid domain "${Cu(e)}".`, {
      metaMessages: ["Must be a valid EIP-712 domain."]
    });
  }
}
class IN extends yt {
  constructor({ primaryType: e, types: r }) {
    super(`Invalid primary type \`${e}\` must be one of \`${JSON.stringify(Object.keys(r))}\`.`, {
      docsPath: "/api/glossary/Errors#typeddatainvalidprimarytypeerror",
      metaMessages: ["Check that the primary type is a key in `types`."]
    });
  }
}
class CN extends yt {
  constructor({ type: e }) {
    super(`Struct type "${e}" is invalid.`, {
      metaMessages: ["Struct type must not be a Solidity type."],
      name: "InvalidStructTypeError"
    });
  }
}
function TN(t) {
  const { domain: e, message: r, primaryType: n, types: i } = t, s = (u, h) => {
    const d = { ...h };
    for (const p of u) {
      const { name: x, type: A } = p;
      A === "address" && (d[x] = d[x].toLowerCase());
    }
    return d;
  }, o = i.EIP712Domain ? e ? s(i.EIP712Domain, e) : {} : {}, a = (() => {
    if (n !== "EIP712Domain")
      return s(i[n], r);
  })();
  return Cu({ domain: o, message: a, primaryType: n, types: i });
}
function RN(t) {
  const { domain: e, message: r, primaryType: n, types: i } = t, s = (o, a) => {
    for (const u of o) {
      const { name: h, type: d } = u, p = a[h], x = d.match(PN);
      if (x && (typeof p == "number" || typeof p == "bigint")) {
        const [N, L, F] = x;
        Mr(p, {
          signed: L === "int",
          size: Number.parseInt(F) / 8
        });
      }
      if (d === "address" && typeof p == "string" && !Oo(p))
        throw new vu({ address: p });
      const A = d.match(AN);
      if (A) {
        const [N, L] = A;
        if (L && An(p) !== Number.parseInt(L))
          throw new $R({
            expectedSize: Number.parseInt(L),
            givenSize: An(p)
          });
      }
      const I = i[d];
      I && (ON(d), s(I, p));
    }
  };
  if (i.EIP712Domain && e) {
    if (typeof e != "object")
      throw new MN({ domain: e });
    s(i.EIP712Domain, e);
  }
  if (n !== "EIP712Domain")
    if (i[n])
      s(i[n], r);
    else
      throw new IN({ primaryType: n, types: i });
}
function DN({ domain: t }) {
  return [
    typeof (t == null ? void 0 : t.name) == "string" && { name: "name", type: "string" },
    (t == null ? void 0 : t.version) && { name: "version", type: "string" },
    typeof (t == null ? void 0 : t.chainId) == "number" && {
      name: "chainId",
      type: "uint256"
    },
    (t == null ? void 0 : t.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (t == null ? void 0 : t.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
function ON(t) {
  if (t === "address" || t === "bool" || t === "string" || t.startsWith("bytes") || t.startsWith("uint") || t.startsWith("int"))
    throw new CN({ type: t });
}
function NN(t, e) {
  const { abi: r, args: n, bytecode: i, ...s } = e, o = dN({ abi: r, args: n, bytecode: i });
  return Ov(t, {
    ...s,
    data: o
  });
}
async function LN(t) {
  var r;
  return ((r = t.account) == null ? void 0 : r.type) === "local" ? [t.account.address] : (await t.request({ method: "eth_accounts" }, { dedupe: !0 })).map((n) => $l(n));
}
async function kN(t) {
  return await t.request({ method: "wallet_getPermissions" }, { dedupe: !0 });
}
async function $N(t) {
  return (await t.request({ method: "eth_requestAccounts" }, { dedupe: !0, retryCount: 0 })).map((r) => L5(r));
}
async function BN(t, e) {
  return t.request({
    method: "wallet_requestPermissions",
    params: [e]
  }, { retryCount: 0 });
}
async function FN(t, { account: e = t.account, message: r }) {
  if (!e)
    throw new Bl({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const n = Fo(e);
  if (n.signMessage)
    return n.signMessage({ message: r });
  const i = typeof r == "string" ? I0(r) : r.raw instanceof Uint8Array ? qd(r.raw) : r.raw;
  return t.request({
    method: "personal_sign",
    params: [i, n.address]
  }, { retryCount: 0 });
}
async function UN(t, e) {
  var h, d, p, x;
  const { account: r = t.account, chain: n = t.chain, ...i } = e;
  if (!r)
    throw new Bl({
      docsPath: "/docs/actions/wallet/signTransaction"
    });
  const s = Fo(r);
  O0({
    account: s,
    ...e
  });
  const o = await vi(t, N0, "getChainId")({});
  n !== null && s4({
    currentChainId: o,
    chain: n
  });
  const a = (n == null ? void 0 : n.formatters) || ((h = t.chain) == null ? void 0 : h.formatters), u = ((d = a == null ? void 0 : a.transactionRequest) == null ? void 0 : d.format) || Cv;
  return s.signTransaction ? s.signTransaction({
    ...i,
    chainId: o
  }, { serializer: (x = (p = t.chain) == null ? void 0 : p.serializers) == null ? void 0 : x.transaction }) : await t.request({
    method: "eth_signTransaction",
    params: [
      {
        ...u(i),
        chainId: Mr(o),
        from: s.address
      }
    ]
  }, { retryCount: 0 });
}
async function jN(t, e) {
  const { account: r = t.account, domain: n, message: i, primaryType: s } = e;
  if (!r)
    throw new Bl({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const o = Fo(r), a = {
    EIP712Domain: DN({ domain: n }),
    ...e.types
  };
  if (RN({ domain: n, message: i, primaryType: s, types: a }), o.signTypedData)
    return o.signTypedData({ domain: n, message: i, primaryType: s, types: a });
  const u = TN({ domain: n, message: i, primaryType: s, types: a });
  return t.request({
    method: "eth_signTypedData_v4",
    params: [o.address, u]
  }, { retryCount: 0 });
}
async function qN(t, { id: e }) {
  await t.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: Mr(e)
      }
    ]
  }, { retryCount: 0 });
}
async function zN(t, e) {
  return await t.request({
    method: "wallet_watchAsset",
    params: e
  }, { retryCount: 0 });
}
function HN(t) {
  return {
    addChain: (e) => vN(t, e),
    deployContract: (e) => NN(t, e),
    getAddresses: () => LN(t),
    getChainId: () => N0(t),
    getPermissions: () => kN(t),
    prepareTransactionRequest: (e) => Dv(t, e),
    requestAddresses: () => $N(t),
    requestPermissions: (e) => BN(t, e),
    sendRawTransaction: (e) => o4(t, e),
    sendTransaction: (e) => Ov(t, e),
    signMessage: (e) => FN(t, e),
    signTransaction: (e) => UN(t, e),
    signTypedData: (e) => jN(t, e),
    switchChain: (e) => qN(t, e),
    watchAsset: (e) => zN(t, e),
    writeContract: (e) => mN(t, e)
  };
}
function WN(t) {
  const { key: e = "wallet", name: r = "Wallet Client", transport: n } = t;
  return bN({
    ...t,
    key: e,
    name: r,
    transport: n,
    type: "walletClient"
  }).extend(HN);
}
class gl {
  constructor(e) {
    Rs(this, "_key");
    Rs(this, "_config", null);
    Rs(this, "_provider", null);
    Rs(this, "_connected", !1);
    Rs(this, "_address", null);
    Rs(this, "_fatured", !1);
    Rs(this, "_installed", !1);
    Rs(this, "lastUsed", !1);
    var r;
    if ("name" in e && "image" in e)
      this._key = e.name, this._config = e, this._fatured = e.featured;
    else if ("session" in e) {
      if (!e.session) throw new Error("session is null");
      this._key = (r = e.session) == null ? void 0 : r.peer.metadata.name, this._provider = e, this._config = {
        name: e.session.peer.metadata.name,
        image: e.session.peer.metadata.icons[0],
        featured: !1
      };
    } else if ("info" in e)
      console.log(e.info, "installed"), this._key = e.info.name, this._provider = e.provider, this._installed = !0, this._config = {
        name: e.info.name,
        image: e.info.icon,
        featured: !1
      }, this.testConnect();
    else
      throw new Error("unknown params");
  }
  get connected() {
    return this._connected;
  }
  get featured() {
    return this._fatured;
  }
  get key() {
    return this._key;
  }
  get installed() {
    return this._installed;
  }
  get client() {
    return this._provider ? WN({ transport: SN(this._provider) }) : null;
  }
  get config() {
    return this._config;
  }
  static fromWalletConfig(e) {
    return new gl(e);
  }
  EIP6963Detected(e) {
    this._provider = e.provider, this._installed = !0, this._provider.on("disconnect", this.disconnect), this._provider.on("accountsChanged", (r) => {
      this._address = r[0], this._connected = !0;
    }), this.testConnect();
  }
  setUniversalProvider(e) {
    this._provider = e, this.testConnect();
  }
  async testConnect() {
    var r;
    const e = await ((r = this.client) == null ? void 0 : r.getAddresses());
    e && e.length > 0 ? (this._address = e[0], this._connected = !0) : (this._address = null, this._connected = !1);
  }
  async connect() {
    var r;
    const e = await ((r = this.client) == null ? void 0 : r.request({ method: "eth_requestAccounts", params: void 0 }));
    if (!e) throw new Error("connect failed");
    return e;
  }
  async getAddress() {
    var r;
    const e = await ((r = this.client) == null ? void 0 : r.getAddresses());
    if (!e || !e.length) throw new Error("get address failed");
    return e[0];
  }
  async getChain() {
    var r;
    const e = await ((r = this.client) == null ? void 0 : r.getChainId());
    if (console.log("wallet client", this.client), !e) throw new Error("get chain failed");
    return e;
  }
  async signMessage(e) {
    var n;
    return !this._address || !this._connected ? void 0 : await ((n = this.client) == null ? void 0 : n.signMessage({ message: e, account: this._address }));
  }
  async disconnect() {
    this._provider && "session" in this._provider && await this._provider.disconnect(), this._connected = !1, this._address = null;
  }
}
var Nv = { exports: {} }, au = typeof Reflect == "object" ? Reflect : null, R2 = au && typeof au.apply == "function" ? au.apply : function(e, r, n) {
  return Function.prototype.apply.call(e, r, n);
}, wd;
au && typeof au.ownKeys == "function" ? wd = au.ownKeys : Object.getOwnPropertySymbols ? wd = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : wd = function(e) {
  return Object.getOwnPropertyNames(e);
};
function KN(t) {
  console && console.warn && console.warn(t);
}
var c4 = Number.isNaN || function(e) {
  return e !== e;
};
function kr() {
  kr.init.call(this);
}
Nv.exports = kr;
Nv.exports.once = JN;
kr.EventEmitter = kr;
kr.prototype._events = void 0;
kr.prototype._eventsCount = 0;
kr.prototype._maxListeners = void 0;
var D2 = 10;
function L0(t) {
  if (typeof t != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
}
Object.defineProperty(kr, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return D2;
  },
  set: function(t) {
    if (typeof t != "number" || t < 0 || c4(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    D2 = t;
  }
});
kr.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
kr.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || c4(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function u4(t) {
  return t._maxListeners === void 0 ? kr.defaultMaxListeners : t._maxListeners;
}
kr.prototype.getMaxListeners = function() {
  return u4(this);
};
kr.prototype.emit = function(e) {
  for (var r = [], n = 1; n < arguments.length; n++) r.push(arguments[n]);
  var i = e === "error", s = this._events;
  if (s !== void 0)
    i = i && s.error === void 0;
  else if (!i)
    return !1;
  if (i) {
    var o;
    if (r.length > 0 && (o = r[0]), o instanceof Error)
      throw o;
    var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
    throw a.context = o, a;
  }
  var u = s[e];
  if (u === void 0)
    return !1;
  if (typeof u == "function")
    R2(u, this, r);
  else
    for (var h = u.length, d = p4(u, h), n = 0; n < h; ++n)
      R2(d[n], this, r);
  return !0;
};
function f4(t, e, r, n) {
  var i, s, o;
  if (L0(r), s = t._events, s === void 0 ? (s = t._events = /* @__PURE__ */ Object.create(null), t._eventsCount = 0) : (s.newListener !== void 0 && (t.emit(
    "newListener",
    e,
    r.listener ? r.listener : r
  ), s = t._events), o = s[e]), o === void 0)
    o = s[e] = r, ++t._eventsCount;
  else if (typeof o == "function" ? o = s[e] = n ? [r, o] : [o, r] : n ? o.unshift(r) : o.push(r), i = u4(t), i > 0 && o.length > i && !o.warned) {
    o.warned = !0;
    var a = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a.name = "MaxListenersExceededWarning", a.emitter = t, a.type = e, a.count = o.length, KN(a);
  }
  return t;
}
kr.prototype.addListener = function(e, r) {
  return f4(this, e, r, !1);
};
kr.prototype.on = kr.prototype.addListener;
kr.prototype.prependListener = function(e, r) {
  return f4(this, e, r, !0);
};
function VN() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function l4(t, e, r) {
  var n = { fired: !1, wrapFn: void 0, target: t, type: e, listener: r }, i = VN.bind(n);
  return i.listener = r, n.wrapFn = i, i;
}
kr.prototype.once = function(e, r) {
  return L0(r), this.on(e, l4(this, e, r)), this;
};
kr.prototype.prependOnceListener = function(e, r) {
  return L0(r), this.prependListener(e, l4(this, e, r)), this;
};
kr.prototype.removeListener = function(e, r) {
  var n, i, s, o, a;
  if (L0(r), i = this._events, i === void 0)
    return this;
  if (n = i[e], n === void 0)
    return this;
  if (n === r || n.listener === r)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || r));
  else if (typeof n != "function") {
    for (s = -1, o = n.length - 1; o >= 0; o--)
      if (n[o] === r || n[o].listener === r) {
        a = n[o].listener, s = o;
        break;
      }
    if (s < 0)
      return this;
    s === 0 ? n.shift() : GN(n, s), n.length === 1 && (i[e] = n[0]), i.removeListener !== void 0 && this.emit("removeListener", e, a || r);
  }
  return this;
};
kr.prototype.off = kr.prototype.removeListener;
kr.prototype.removeAllListeners = function(e) {
  var r, n, i;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[e]), this;
  if (arguments.length === 0) {
    var s = Object.keys(n), o;
    for (i = 0; i < s.length; ++i)
      o = s[i], o !== "removeListener" && this.removeAllListeners(o);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r = n[e], typeof r == "function")
    this.removeListener(e, r);
  else if (r !== void 0)
    for (i = r.length - 1; i >= 0; i--)
      this.removeListener(e, r[i]);
  return this;
};
function h4(t, e, r) {
  var n = t._events;
  if (n === void 0)
    return [];
  var i = n[e];
  return i === void 0 ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? YN(i) : p4(i, i.length);
}
kr.prototype.listeners = function(e) {
  return h4(this, e, !0);
};
kr.prototype.rawListeners = function(e) {
  return h4(this, e, !1);
};
kr.listenerCount = function(t, e) {
  return typeof t.listenerCount == "function" ? t.listenerCount(e) : d4.call(t, e);
};
kr.prototype.listenerCount = d4;
function d4(t) {
  var e = this._events;
  if (e !== void 0) {
    var r = e[t];
    if (typeof r == "function")
      return 1;
    if (r !== void 0)
      return r.length;
  }
  return 0;
}
kr.prototype.eventNames = function() {
  return this._eventsCount > 0 ? wd(this._events) : [];
};
function p4(t, e) {
  for (var r = new Array(e), n = 0; n < e; ++n)
    r[n] = t[n];
  return r;
}
function GN(t, e) {
  for (; e + 1 < t.length; e++)
    t[e] = t[e + 1];
  t.pop();
}
function YN(t) {
  for (var e = new Array(t.length), r = 0; r < e.length; ++r)
    e[r] = t[r].listener || t[r];
  return e;
}
function JN(t, e) {
  return new Promise(function(r, n) {
    function i(o) {
      t.removeListener(e, s), n(o);
    }
    function s() {
      typeof t.removeListener == "function" && t.removeListener("error", i), r([].slice.call(arguments));
    }
    g4(t, e, s, { once: !0 }), e !== "error" && XN(t, i, { once: !0 });
  });
}
function XN(t, e, r) {
  typeof t.on == "function" && g4(t, "error", e, r);
}
function g4(t, e, r, n) {
  if (typeof t.on == "function")
    n.once ? t.once(e, r) : t.on(e, r);
  else if (typeof t.addEventListener == "function")
    t.addEventListener(e, function i(s) {
      n.once && t.removeEventListener(e, i), r(s);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
}
var rs = Nv.exports;
const Lv = /* @__PURE__ */ ts(rs);
var mt = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var c1 = function(t, e) {
  return c1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var i in n) n.hasOwnProperty(i) && (r[i] = n[i]);
  }, c1(t, e);
};
function ZN(t, e) {
  c1(t, e);
  function r() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
}
var u1 = function() {
  return u1 = Object.assign || function(e) {
    for (var r, n = 1, i = arguments.length; n < i; n++) {
      r = arguments[n];
      for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (e[s] = r[s]);
    }
    return e;
  }, u1.apply(this, arguments);
};
function QN(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
  return r;
}
function eL(t, e, r, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, r) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, r, n);
  else for (var a = t.length - 1; a >= 0; a--) (o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, r, s) : o(e, r)) || s);
  return i > 3 && s && Object.defineProperty(e, r, s), s;
}
function tL(t, e) {
  return function(r, n) {
    e(r, n, t);
  };
}
function rL(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(t, e);
}
function nL(t, e, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function a(d) {
      try {
        h(n.next(d));
      } catch (p) {
        o(p);
      }
    }
    function u(d) {
      try {
        h(n.throw(d));
      } catch (p) {
        o(p);
      }
    }
    function h(d) {
      d.done ? s(d.value) : i(d.value).then(a, u);
    }
    h((n = n.apply(t, e || [])).next());
  });
}
function iL(t, e) {
  var r = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(h) {
    return function(d) {
      return u([h, d]);
    };
  }
  function u(h) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; r; ) try {
      if (n = 1, i && (s = h[0] & 2 ? i.return : h[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, h[1])).done) return s;
      switch (i = 0, s && (h = [h[0] & 2, s.value]), h[0]) {
        case 0:
        case 1:
          s = h;
          break;
        case 4:
          return r.label++, { value: h[1], done: !1 };
        case 5:
          r.label++, i = h[1], h = [0];
          continue;
        case 7:
          h = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (h[0] === 6 || h[0] === 2)) {
            r = 0;
            continue;
          }
          if (h[0] === 3 && (!s || h[1] > s[0] && h[1] < s[3])) {
            r.label = h[1];
            break;
          }
          if (h[0] === 6 && r.label < s[1]) {
            r.label = s[1], s = h;
            break;
          }
          if (s && r.label < s[2]) {
            r.label = s[2], r.ops.push(h);
            break;
          }
          s[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      h = e.call(t, r);
    } catch (d) {
      h = [6, d], i = 0;
    } finally {
      n = s = 0;
    }
    if (h[0] & 5) throw h[1];
    return { value: h[0] ? h[1] : void 0, done: !0 };
  }
}
function sL(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}
function oL(t, e) {
  for (var r in t) r !== "default" && !e.hasOwnProperty(r) && (e[r] = t[r]);
}
function f1(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], n = 0;
  if (r) return r.call(t);
  if (t && typeof t.length == "number") return {
    next: function() {
      return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function m4(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r) return t;
  var n = r.call(t), i, s = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) s.push(i.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (o) throw o.error;
    }
  }
  return s;
}
function aL() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(m4(arguments[e]));
  return t;
}
function cL() {
  for (var t = 0, e = 0, r = arguments.length; e < r; e++) t += arguments[e].length;
  for (var n = Array(t), i = 0, e = 0; e < r; e++)
    for (var s = arguments[e], o = 0, a = s.length; o < a; o++, i++)
      n[i] = s[o];
  return n;
}
function ml(t) {
  return this instanceof ml ? (this.v = t, this) : new ml(t);
}
function uL(t, e, r) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = r.apply(t, e || []), i, s = [];
  return i = {}, o("next"), o("throw"), o("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function o(x) {
    n[x] && (i[x] = function(A) {
      return new Promise(function(I, N) {
        s.push([x, A, I, N]) > 1 || a(x, A);
      });
    });
  }
  function a(x, A) {
    try {
      u(n[x](A));
    } catch (I) {
      p(s[0][3], I);
    }
  }
  function u(x) {
    x.value instanceof ml ? Promise.resolve(x.value.v).then(h, d) : p(s[0][2], x);
  }
  function h(x) {
    a("next", x);
  }
  function d(x) {
    a("throw", x);
  }
  function p(x, A) {
    x(A), s.shift(), s.length && a(s[0][0], s[0][1]);
  }
}
function fL(t) {
  var e, r;
  return e = {}, n("next"), n("throw", function(i) {
    throw i;
  }), n("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function n(i, s) {
    e[i] = t[i] ? function(o) {
      return (r = !r) ? { value: ml(t[i](o)), done: i === "return" } : s ? s(o) : o;
    } : s;
  }
}
function lL(t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], r;
  return e ? e.call(t) : (t = typeof f1 == "function" ? f1(t) : t[Symbol.iterator](), r = {}, n("next"), n("throw"), n("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function n(s) {
    r[s] = t[s] && function(o) {
      return new Promise(function(a, u) {
        o = t[s](o), i(a, u, o.done, o.value);
      });
    };
  }
  function i(s, o, a, u) {
    Promise.resolve(u).then(function(h) {
      s({ value: h, done: a });
    }, o);
  }
}
function hL(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : t.raw = e, t;
}
function dL(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
  return e.default = t, e;
}
function pL(t) {
  return t && t.__esModule ? t : { default: t };
}
function gL(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function mL(t, e, r) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, r), r;
}
const vL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return u1;
  },
  __asyncDelegator: fL,
  __asyncGenerator: uL,
  __asyncValues: lL,
  __await: ml,
  __awaiter: nL,
  __classPrivateFieldGet: gL,
  __classPrivateFieldSet: mL,
  __createBinding: sL,
  __decorate: eL,
  __exportStar: oL,
  __extends: ZN,
  __generator: iL,
  __importDefault: pL,
  __importStar: dL,
  __makeTemplateObject: hL,
  __metadata: rL,
  __param: tL,
  __read: m4,
  __rest: QN,
  __spread: aL,
  __spreadArrays: cL,
  __values: f1
}, Symbol.toStringTag, { value: "Module" })), Fl = /* @__PURE__ */ bv(vL);
var Hg = {}, bf = {}, O2;
function bL() {
  if (O2) return bf;
  O2 = 1, Object.defineProperty(bf, "__esModule", { value: !0 }), bf.delay = void 0;
  function t(e) {
    return new Promise((r) => {
      setTimeout(() => {
        r(!0);
      }, e);
    });
  }
  return bf.delay = t, bf;
}
var Ba = {}, Wg = {}, Fa = {}, N2;
function yL() {
  return N2 || (N2 = 1, Object.defineProperty(Fa, "__esModule", { value: !0 }), Fa.ONE_THOUSAND = Fa.ONE_HUNDRED = void 0, Fa.ONE_HUNDRED = 100, Fa.ONE_THOUSAND = 1e3), Fa;
}
var Kg = {}, L2;
function wL() {
  return L2 || (L2 = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ONE_YEAR = t.FOUR_WEEKS = t.THREE_WEEKS = t.TWO_WEEKS = t.ONE_WEEK = t.THIRTY_DAYS = t.SEVEN_DAYS = t.FIVE_DAYS = t.THREE_DAYS = t.ONE_DAY = t.TWENTY_FOUR_HOURS = t.TWELVE_HOURS = t.SIX_HOURS = t.THREE_HOURS = t.ONE_HOUR = t.SIXTY_MINUTES = t.THIRTY_MINUTES = t.TEN_MINUTES = t.FIVE_MINUTES = t.ONE_MINUTE = t.SIXTY_SECONDS = t.THIRTY_SECONDS = t.TEN_SECONDS = t.FIVE_SECONDS = t.ONE_SECOND = void 0, t.ONE_SECOND = 1, t.FIVE_SECONDS = 5, t.TEN_SECONDS = 10, t.THIRTY_SECONDS = 30, t.SIXTY_SECONDS = 60, t.ONE_MINUTE = t.SIXTY_SECONDS, t.FIVE_MINUTES = t.ONE_MINUTE * 5, t.TEN_MINUTES = t.ONE_MINUTE * 10, t.THIRTY_MINUTES = t.ONE_MINUTE * 30, t.SIXTY_MINUTES = t.ONE_MINUTE * 60, t.ONE_HOUR = t.SIXTY_MINUTES, t.THREE_HOURS = t.ONE_HOUR * 3, t.SIX_HOURS = t.ONE_HOUR * 6, t.TWELVE_HOURS = t.ONE_HOUR * 12, t.TWENTY_FOUR_HOURS = t.ONE_HOUR * 24, t.ONE_DAY = t.TWENTY_FOUR_HOURS, t.THREE_DAYS = t.ONE_DAY * 3, t.FIVE_DAYS = t.ONE_DAY * 5, t.SEVEN_DAYS = t.ONE_DAY * 7, t.THIRTY_DAYS = t.ONE_DAY * 30, t.ONE_WEEK = t.SEVEN_DAYS, t.TWO_WEEKS = t.ONE_WEEK * 2, t.THREE_WEEKS = t.ONE_WEEK * 3, t.FOUR_WEEKS = t.ONE_WEEK * 4, t.ONE_YEAR = t.ONE_DAY * 365;
  }(Kg)), Kg;
}
var k2;
function v4() {
  return k2 || (k2 = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const e = Fl;
    e.__exportStar(yL(), t), e.__exportStar(wL(), t);
  }(Wg)), Wg;
}
var $2;
function xL() {
  if ($2) return Ba;
  $2 = 1, Object.defineProperty(Ba, "__esModule", { value: !0 }), Ba.fromMiliseconds = Ba.toMiliseconds = void 0;
  const t = v4();
  function e(n) {
    return n * t.ONE_THOUSAND;
  }
  Ba.toMiliseconds = e;
  function r(n) {
    return Math.floor(n / t.ONE_THOUSAND);
  }
  return Ba.fromMiliseconds = r, Ba;
}
var B2;
function _L() {
  return B2 || (B2 = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const e = Fl;
    e.__exportStar(bL(), t), e.__exportStar(xL(), t);
  }(Hg)), Hg;
}
var jc = {}, F2;
function EL() {
  if (F2) return jc;
  F2 = 1, Object.defineProperty(jc, "__esModule", { value: !0 }), jc.Watch = void 0;
  class t {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(r) {
      if (this.timestamps.has(r))
        throw new Error(`Watch already started for label: ${r}`);
      this.timestamps.set(r, { started: Date.now() });
    }
    stop(r) {
      const n = this.get(r);
      if (typeof n.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${r}`);
      const i = Date.now() - n.started;
      this.timestamps.set(r, { started: n.started, elapsed: i });
    }
    get(r) {
      const n = this.timestamps.get(r);
      if (typeof n > "u")
        throw new Error(`No timestamp found for label: ${r}`);
      return n;
    }
    elapsed(r) {
      const n = this.get(r);
      return n.elapsed || Date.now() - n.started;
    }
  }
  return jc.Watch = t, jc.default = t, jc;
}
var Vg = {}, yf = {}, U2;
function SL() {
  if (U2) return yf;
  U2 = 1, Object.defineProperty(yf, "__esModule", { value: !0 }), yf.IWatch = void 0;
  class t {
  }
  return yf.IWatch = t, yf;
}
var j2;
function AL() {
  return j2 || (j2 = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), Fl.__exportStar(SL(), t);
  }(Vg)), Vg;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = Fl;
  e.__exportStar(_L(), t), e.__exportStar(EL(), t), e.__exportStar(AL(), t), e.__exportStar(v4(), t);
})(mt);
class dc {
}
let PL = class extends dc {
  constructor(e) {
    super();
  }
};
const q2 = mt.FIVE_SECONDS, Ru = { pulse: "heartbeat_pulse" };
let ML = class b4 extends PL {
  constructor(e) {
    super(e), this.events = new rs.EventEmitter(), this.interval = q2, this.interval = (e == null ? void 0 : e.interval) || q2;
  }
  static async init(e) {
    const r = new b4(e);
    return await r.init(), r;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), mt.toMiliseconds(this.interval));
  }
  pulse() {
    this.events.emit(Ru.pulse);
  }
};
const IL = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, CL = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, TL = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function RL(t, e) {
  if (t === "__proto__" || t === "constructor" && e && typeof e == "object" && "prototype" in e) {
    DL(t);
    return;
  }
  return e;
}
function DL(t) {
  console.warn(`[destr] Dropping "${t}" key to prevent prototype pollution.`);
}
function sd(t, e = {}) {
  if (typeof t != "string")
    return t;
  const r = t.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    t[0] === '"' && t.endsWith('"') && !t.includes("\\")
  )
    return r.slice(1, -1);
  if (r.length <= 9) {
    const n = r.toLowerCase();
    if (n === "true")
      return !0;
    if (n === "false")
      return !1;
    if (n === "undefined")
      return;
    if (n === "null")
      return null;
    if (n === "nan")
      return Number.NaN;
    if (n === "infinity")
      return Number.POSITIVE_INFINITY;
    if (n === "-infinity")
      return Number.NEGATIVE_INFINITY;
  }
  if (!TL.test(t)) {
    if (e.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return t;
  }
  try {
    if (IL.test(t) || CL.test(t)) {
      if (e.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(t, RL);
    }
    return JSON.parse(t);
  } catch (n) {
    if (e.strict)
      throw n;
    return t;
  }
}
function OL(t) {
  return !t || typeof t.then != "function" ? Promise.resolve(t) : t;
}
function Cn(t, ...e) {
  try {
    return OL(t(...e));
  } catch (r) {
    return Promise.reject(r);
  }
}
function NL(t) {
  const e = typeof t;
  return t === null || e !== "object" && e !== "function";
}
function LL(t) {
  const e = Object.getPrototypeOf(t);
  return !e || e.isPrototypeOf(Object);
}
function xd(t) {
  if (NL(t))
    return String(t);
  if (LL(t) || Array.isArray(t))
    return JSON.stringify(t);
  if (typeof t.toJSON == "function")
    return xd(t.toJSON());
  throw new Error("[unstorage] Cannot stringify value!");
}
function y4() {
  if (typeof Buffer > "u")
    throw new TypeError("[unstorage] Buffer is not supported!");
}
const l1 = "base64:";
function kL(t) {
  if (typeof t == "string")
    return t;
  y4();
  const e = Buffer.from(t).toString("base64");
  return l1 + e;
}
function $L(t) {
  return typeof t != "string" || !t.startsWith(l1) ? t : (y4(), Buffer.from(t.slice(l1.length), "base64"));
}
function di(t) {
  return t ? t.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : "";
}
function BL(...t) {
  return di(t.join(":"));
}
function od(t) {
  return t = di(t), t ? t + ":" : "";
}
const FL = "memory", UL = () => {
  const t = /* @__PURE__ */ new Map();
  return {
    name: FL,
    getInstance: () => t,
    hasItem(e) {
      return t.has(e);
    },
    getItem(e) {
      return t.get(e) ?? null;
    },
    getItemRaw(e) {
      return t.get(e) ?? null;
    },
    setItem(e, r) {
      t.set(e, r);
    },
    setItemRaw(e, r) {
      t.set(e, r);
    },
    removeItem(e) {
      t.delete(e);
    },
    getKeys() {
      return [...t.keys()];
    },
    clear() {
      t.clear();
    },
    dispose() {
      t.clear();
    }
  };
};
function jL(t = {}) {
  const e = {
    mounts: { "": t.driver || UL() },
    mountpoints: [""],
    watching: !1,
    watchListeners: [],
    unwatch: {}
  }, r = (h) => {
    for (const d of e.mountpoints)
      if (h.startsWith(d))
        return {
          base: d,
          relativeKey: h.slice(d.length),
          driver: e.mounts[d]
        };
    return {
      base: "",
      relativeKey: h,
      driver: e.mounts[""]
    };
  }, n = (h, d) => e.mountpoints.filter(
    (p) => p.startsWith(h) || d && h.startsWith(p)
  ).map((p) => ({
    relativeBase: h.length > p.length ? h.slice(p.length) : void 0,
    mountpoint: p,
    driver: e.mounts[p]
  })), i = (h, d) => {
    if (e.watching) {
      d = di(d);
      for (const p of e.watchListeners)
        p(h, d);
    }
  }, s = async () => {
    if (!e.watching) {
      e.watching = !0;
      for (const h in e.mounts)
        e.unwatch[h] = await z2(
          e.mounts[h],
          i,
          h
        );
    }
  }, o = async () => {
    if (e.watching) {
      for (const h in e.unwatch)
        await e.unwatch[h]();
      e.unwatch = {}, e.watching = !1;
    }
  }, a = (h, d, p) => {
    const x = /* @__PURE__ */ new Map(), A = (I) => {
      let N = x.get(I.base);
      return N || (N = {
        driver: I.driver,
        base: I.base,
        items: []
      }, x.set(I.base, N)), N;
    };
    for (const I of h) {
      const N = typeof I == "string", L = di(N ? I : I.key), F = N ? void 0 : I.value, $ = N || !I.options ? d : { ...d, ...I.options }, W = r(L);
      A(W).items.push({
        key: L,
        value: F,
        relativeKey: W.relativeKey,
        options: $
      });
    }
    return Promise.all([...x.values()].map((I) => p(I))).then(
      (I) => I.flat()
    );
  }, u = {
    // Item
    hasItem(h, d = {}) {
      h = di(h);
      const { relativeKey: p, driver: x } = r(h);
      return Cn(x.hasItem, p, d);
    },
    getItem(h, d = {}) {
      h = di(h);
      const { relativeKey: p, driver: x } = r(h);
      return Cn(x.getItem, p, d).then(
        (A) => sd(A)
      );
    },
    getItems(h, d) {
      return a(h, d, (p) => p.driver.getItems ? Cn(
        p.driver.getItems,
        p.items.map((x) => ({
          key: x.relativeKey,
          options: x.options
        })),
        d
      ).then(
        (x) => x.map((A) => ({
          key: BL(p.base, A.key),
          value: sd(A.value)
        }))
      ) : Promise.all(
        p.items.map((x) => Cn(
          p.driver.getItem,
          x.relativeKey,
          x.options
        ).then((A) => ({
          key: x.key,
          value: sd(A)
        })))
      ));
    },
    getItemRaw(h, d = {}) {
      h = di(h);
      const { relativeKey: p, driver: x } = r(h);
      return x.getItemRaw ? Cn(x.getItemRaw, p, d) : Cn(x.getItem, p, d).then(
        (A) => $L(A)
      );
    },
    async setItem(h, d, p = {}) {
      if (d === void 0)
        return u.removeItem(h);
      h = di(h);
      const { relativeKey: x, driver: A } = r(h);
      A.setItem && (await Cn(A.setItem, x, xd(d), p), A.watch || i("update", h));
    },
    async setItems(h, d) {
      await a(h, d, async (p) => {
        if (p.driver.setItems)
          return Cn(
            p.driver.setItems,
            p.items.map((x) => ({
              key: x.relativeKey,
              value: xd(x.value),
              options: x.options
            })),
            d
          );
        p.driver.setItem && await Promise.all(
          p.items.map((x) => Cn(
            p.driver.setItem,
            x.relativeKey,
            xd(x.value),
            x.options
          ))
        );
      });
    },
    async setItemRaw(h, d, p = {}) {
      if (d === void 0)
        return u.removeItem(h, p);
      h = di(h);
      const { relativeKey: x, driver: A } = r(h);
      if (A.setItemRaw)
        await Cn(A.setItemRaw, x, d, p);
      else if (A.setItem)
        await Cn(A.setItem, x, kL(d), p);
      else
        return;
      A.watch || i("update", h);
    },
    async removeItem(h, d = {}) {
      typeof d == "boolean" && (d = { removeMeta: d }), h = di(h);
      const { relativeKey: p, driver: x } = r(h);
      x.removeItem && (await Cn(x.removeItem, p, d), (d.removeMeta || d.removeMata) && await Cn(x.removeItem, p + "$", d), x.watch || i("remove", h));
    },
    // Meta
    async getMeta(h, d = {}) {
      typeof d == "boolean" && (d = { nativeOnly: d }), h = di(h);
      const { relativeKey: p, driver: x } = r(h), A = /* @__PURE__ */ Object.create(null);
      if (x.getMeta && Object.assign(A, await Cn(x.getMeta, p, d)), !d.nativeOnly) {
        const I = await Cn(
          x.getItem,
          p + "$",
          d
        ).then((N) => sd(N));
        I && typeof I == "object" && (typeof I.atime == "string" && (I.atime = new Date(I.atime)), typeof I.mtime == "string" && (I.mtime = new Date(I.mtime)), Object.assign(A, I));
      }
      return A;
    },
    setMeta(h, d, p = {}) {
      return this.setItem(h + "$", d, p);
    },
    removeMeta(h, d = {}) {
      return this.removeItem(h + "$", d);
    },
    // Keys
    async getKeys(h, d = {}) {
      h = od(h);
      const p = n(h, !0);
      let x = [];
      const A = [];
      for (const I of p) {
        const N = await Cn(
          I.driver.getKeys,
          I.relativeBase,
          d
        );
        for (const L of N) {
          const F = I.mountpoint + di(L);
          x.some(($) => F.startsWith($)) || A.push(F);
        }
        x = [
          I.mountpoint,
          ...x.filter((L) => !L.startsWith(I.mountpoint))
        ];
      }
      return h ? A.filter(
        (I) => I.startsWith(h) && I[I.length - 1] !== "$"
      ) : A.filter((I) => I[I.length - 1] !== "$");
    },
    // Utils
    async clear(h, d = {}) {
      h = od(h), await Promise.all(
        n(h, !1).map(async (p) => {
          if (p.driver.clear)
            return Cn(p.driver.clear, p.relativeBase, d);
          if (p.driver.removeItem) {
            const x = await p.driver.getKeys(p.relativeBase || "", d);
            return Promise.all(
              x.map((A) => p.driver.removeItem(A, d))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(e.mounts).map((h) => H2(h))
      );
    },
    async watch(h) {
      return await s(), e.watchListeners.push(h), async () => {
        e.watchListeners = e.watchListeners.filter(
          (d) => d !== h
        ), e.watchListeners.length === 0 && await o();
      };
    },
    async unwatch() {
      e.watchListeners = [], await o();
    },
    // Mount
    mount(h, d) {
      if (h = od(h), h && e.mounts[h])
        throw new Error(`already mounted at ${h}`);
      return h && (e.mountpoints.push(h), e.mountpoints.sort((p, x) => x.length - p.length)), e.mounts[h] = d, e.watching && Promise.resolve(z2(d, i, h)).then((p) => {
        e.unwatch[h] = p;
      }).catch(console.error), u;
    },
    async unmount(h, d = !0) {
      h = od(h), !(!h || !e.mounts[h]) && (e.watching && h in e.unwatch && (e.unwatch[h](), delete e.unwatch[h]), d && await H2(e.mounts[h]), e.mountpoints = e.mountpoints.filter((p) => p !== h), delete e.mounts[h]);
    },
    getMount(h = "") {
      h = di(h) + ":";
      const d = r(h);
      return {
        driver: d.driver,
        base: d.base
      };
    },
    getMounts(h = "", d = {}) {
      return h = di(h), n(h, d.parents).map((x) => ({
        driver: x.driver,
        base: x.mountpoint
      }));
    },
    // Aliases
    keys: (h, d = {}) => u.getKeys(h, d),
    get: (h, d = {}) => u.getItem(h, d),
    set: (h, d, p = {}) => u.setItem(h, d, p),
    has: (h, d = {}) => u.hasItem(h, d),
    del: (h, d = {}) => u.removeItem(h, d),
    remove: (h, d = {}) => u.removeItem(h, d)
  };
  return u;
}
function z2(t, e, r) {
  return t.watch ? t.watch((n, i) => e(n, r + i)) : () => {
  };
}
async function H2(t) {
  typeof t.dispose == "function" && await Cn(t.dispose);
}
function pc(t) {
  return new Promise((e, r) => {
    t.oncomplete = t.onsuccess = () => e(t.result), t.onabort = t.onerror = () => r(t.error);
  });
}
function w4(t, e) {
  const r = indexedDB.open(t);
  r.onupgradeneeded = () => r.result.createObjectStore(e);
  const n = pc(r);
  return (i, s) => n.then((o) => s(o.transaction(e, i).objectStore(e)));
}
let Gg;
function Ul() {
  return Gg || (Gg = w4("keyval-store", "keyval")), Gg;
}
function W2(t, e = Ul()) {
  return e("readonly", (r) => pc(r.get(t)));
}
function qL(t, e, r = Ul()) {
  return r("readwrite", (n) => (n.put(e, t), pc(n.transaction)));
}
function zL(t, e = Ul()) {
  return e("readwrite", (r) => (r.delete(t), pc(r.transaction)));
}
function HL(t = Ul()) {
  return t("readwrite", (e) => (e.clear(), pc(e.transaction)));
}
function WL(t, e) {
  return t.openCursor().onsuccess = function() {
    this.result && (e(this.result), this.result.continue());
  }, pc(t.transaction);
}
function KL(t = Ul()) {
  return t("readonly", (e) => {
    if (e.getAllKeys)
      return pc(e.getAllKeys());
    const r = [];
    return WL(e, (n) => r.push(n.key)).then(() => r);
  });
}
const VL = (t) => JSON.stringify(t, (e, r) => typeof r == "bigint" ? r.toString() + "n" : r), GL = (t) => {
  const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, r = t.replace(e, '$1"$2n"$3');
  return JSON.parse(r, (n, i) => typeof i == "string" && i.match(/^\d+n$/) ? BigInt(i.substring(0, i.length - 1)) : i);
};
function oc(t) {
  if (typeof t != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof t}`);
  try {
    return GL(t);
  } catch {
    return t;
  }
}
function No(t) {
  return typeof t == "string" ? t : VL(t) || "";
}
const YL = "idb-keyval";
var JL = (t = {}) => {
  const e = t.base && t.base.length > 0 ? `${t.base}:` : "", r = (i) => e + i;
  let n;
  return t.dbName && t.storeName && (n = w4(t.dbName, t.storeName)), { name: YL, options: t, async hasItem(i) {
    return !(typeof await W2(r(i), n) > "u");
  }, async getItem(i) {
    return await W2(r(i), n) ?? null;
  }, setItem(i, s) {
    return qL(r(i), s, n);
  }, removeItem(i) {
    return zL(r(i), n);
  }, getKeys() {
    return KL(n);
  }, clear() {
    return HL(n);
  } };
};
const XL = "WALLET_CONNECT_V2_INDEXED_DB", ZL = "keyvaluestorage";
let QL = class {
  constructor() {
    this.indexedDb = jL({ driver: JL({ dbName: XL, storeName: ZL }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((e) => [e.key, e.value]);
  }
  async getItem(e) {
    const r = await this.indexedDb.getItem(e);
    if (r !== null) return r;
  }
  async setItem(e, r) {
    await this.indexedDb.setItem(e, No(r));
  }
  async removeItem(e) {
    await this.indexedDb.removeItem(e);
  }
};
var Yg = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, _d = { exports: {} };
(function() {
  let t;
  function e() {
  }
  t = e, t.prototype.getItem = function(r) {
    return this.hasOwnProperty(r) ? String(this[r]) : null;
  }, t.prototype.setItem = function(r, n) {
    this[r] = String(n);
  }, t.prototype.removeItem = function(r) {
    delete this[r];
  }, t.prototype.clear = function() {
    const r = this;
    Object.keys(r).forEach(function(n) {
      r[n] = void 0, delete r[n];
    });
  }, t.prototype.key = function(r) {
    return r = r || 0, Object.keys(this)[r];
  }, t.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof Yg < "u" && Yg.localStorage ? _d.exports = Yg.localStorage : typeof window < "u" && window.localStorage ? _d.exports = window.localStorage : _d.exports = new e();
})();
function ek(t) {
  var e;
  return [t[0], oc((e = t[1]) != null ? e : "")];
}
let tk = class {
  constructor() {
    this.localStorage = _d.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(ek);
  }
  async getItem(e) {
    const r = this.localStorage.getItem(e);
    if (r !== null) return oc(r);
  }
  async setItem(e, r) {
    this.localStorage.setItem(e, No(r));
  }
  async removeItem(e) {
    this.localStorage.removeItem(e);
  }
};
const rk = "wc_storage_version", K2 = 1, nk = async (t, e, r) => {
  const n = rk, i = await e.getItem(n);
  if (i && i >= K2) {
    r(e);
    return;
  }
  const s = await t.getKeys();
  if (!s.length) {
    r(e);
    return;
  }
  const o = [];
  for (; s.length; ) {
    const a = s.shift();
    if (!a) continue;
    const u = a.toLowerCase();
    if (u.includes("wc@") || u.includes("walletconnect") || u.includes("wc_") || u.includes("wallet_connect")) {
      const h = await t.getItem(a);
      await e.setItem(a, h), o.push(a);
    }
  }
  await e.setItem(n, K2), r(e), ik(t, o);
}, ik = async (t, e) => {
  e.length && e.forEach(async (r) => {
    await t.removeItem(r);
  });
};
let sk = class {
  constructor() {
    this.initialized = !1, this.setInitialized = (r) => {
      this.storage = r, this.initialized = !0;
    };
    const e = new tk();
    this.storage = e;
    try {
      const r = new QL();
      nk(e, r, this.setInitialized);
    } catch {
      this.initialized = !0;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(e) {
    return await this.initialize(), this.storage.getItem(e);
  }
  async setItem(e, r) {
    return await this.initialize(), this.storage.setItem(e, r);
  }
  async removeItem(e) {
    return await this.initialize(), this.storage.removeItem(e);
  }
  async initialize() {
    this.initialized || await new Promise((e) => {
      const r = setInterval(() => {
        this.initialized && (clearInterval(r), e());
      }, 20);
    });
  }
};
function ok(t) {
  try {
    return JSON.stringify(t);
  } catch {
    return '"[Circular]"';
  }
}
var ak = ck;
function ck(t, e, r) {
  var n = r && r.stringify || ok, i = 1;
  if (typeof t == "object" && t !== null) {
    var s = e.length + i;
    if (s === 1) return t;
    var o = new Array(s);
    o[0] = n(t);
    for (var a = 1; a < s; a++)
      o[a] = n(e[a]);
    return o.join(" ");
  }
  if (typeof t != "string")
    return t;
  var u = e.length;
  if (u === 0) return t;
  for (var h = "", d = 1 - i, p = -1, x = t && t.length || 0, A = 0; A < x; ) {
    if (t.charCodeAt(A) === 37 && A + 1 < x) {
      switch (p = p > -1 ? p : 0, t.charCodeAt(A + 1)) {
        case 100:
        case 102:
          if (d >= u || e[d] == null) break;
          p < A && (h += t.slice(p, A)), h += Number(e[d]), p = A + 2, A++;
          break;
        case 105:
          if (d >= u || e[d] == null) break;
          p < A && (h += t.slice(p, A)), h += Math.floor(Number(e[d])), p = A + 2, A++;
          break;
        case 79:
        case 111:
        case 106:
          if (d >= u || e[d] === void 0) break;
          p < A && (h += t.slice(p, A));
          var I = typeof e[d];
          if (I === "string") {
            h += "'" + e[d] + "'", p = A + 2, A++;
            break;
          }
          if (I === "function") {
            h += e[d].name || "<anonymous>", p = A + 2, A++;
            break;
          }
          h += n(e[d]), p = A + 2, A++;
          break;
        case 115:
          if (d >= u)
            break;
          p < A && (h += t.slice(p, A)), h += String(e[d]), p = A + 2, A++;
          break;
        case 37:
          p < A && (h += t.slice(p, A)), h += "%", p = A + 2, A++, d--;
          break;
      }
      ++d;
    }
    ++A;
  }
  return p === -1 ? t : (p < x && (h += t.slice(p)), h);
}
const V2 = ak;
var Gc = Lo;
const vl = bk().console || {}, uk = {
  mapHttpRequest: ad,
  mapHttpResponse: ad,
  wrapRequestSerializer: Jg,
  wrapResponseSerializer: Jg,
  wrapErrorSerializer: Jg,
  req: ad,
  res: ad,
  err: pk
};
function fk(t, e) {
  return Array.isArray(t) ? t.filter(function(n) {
    return n !== "!stdSerializers.err";
  }) : t === !0 ? Object.keys(e) : !1;
}
function Lo(t) {
  t = t || {}, t.browser = t.browser || {};
  const e = t.browser.transmit;
  if (e && typeof e.send != "function")
    throw Error("pino: transmit option must have a send function");
  const r = t.browser.write || vl;
  t.browser.write && (t.browser.asObject = !0);
  const n = t.serializers || {}, i = fk(t.browser.serialize, n);
  let s = t.browser.serialize;
  Array.isArray(t.browser.serialize) && t.browser.serialize.indexOf("!stdSerializers.err") > -1 && (s = !1);
  const o = ["error", "fatal", "warn", "info", "debug", "trace"];
  typeof r == "function" && (r.error = r.fatal = r.warn = r.info = r.debug = r.trace = r), t.enabled === !1 && (t.level = "silent");
  const a = t.level || "info", u = Object.create(r);
  u.log || (u.log = bl), Object.defineProperty(u, "levelVal", {
    get: d
  }), Object.defineProperty(u, "level", {
    get: p,
    set: x
  });
  const h = {
    transmit: e,
    serialize: i,
    asObject: t.browser.asObject,
    levels: o,
    timestamp: gk(t)
  };
  u.levels = Lo.levels, u.level = a, u.setMaxListeners = u.getMaxListeners = u.emit = u.addListener = u.on = u.prependListener = u.once = u.prependOnceListener = u.removeListener = u.removeAllListeners = u.listeners = u.listenerCount = u.eventNames = u.write = u.flush = bl, u.serializers = n, u._serialize = i, u._stdErrSerialize = s, u.child = A, e && (u._logEvent = h1());
  function d() {
    return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
  }
  function p() {
    return this._level;
  }
  function x(I) {
    if (I !== "silent" && !this.levels.values[I])
      throw Error("unknown level " + I);
    this._level = I, qc(h, u, "error", "log"), qc(h, u, "fatal", "error"), qc(h, u, "warn", "error"), qc(h, u, "info", "log"), qc(h, u, "debug", "log"), qc(h, u, "trace", "log");
  }
  function A(I, N) {
    if (!I)
      throw new Error("missing bindings for child Pino");
    N = N || {}, i && I.serializers && (N.serializers = I.serializers);
    const L = N.serializers;
    if (i && L) {
      var F = Object.assign({}, n, L), $ = t.browser.serialize === !0 ? Object.keys(F) : i;
      delete I.serializers, k0([I], $, F, this._stdErrSerialize);
    }
    function W(z) {
      this._childLevel = (z._childLevel | 0) + 1, this.error = zc(z, I, "error"), this.fatal = zc(z, I, "fatal"), this.warn = zc(z, I, "warn"), this.info = zc(z, I, "info"), this.debug = zc(z, I, "debug"), this.trace = zc(z, I, "trace"), F && (this.serializers = F, this._serialize = $), e && (this._logEvent = h1(
        [].concat(z._logEvent.bindings, I)
      ));
    }
    return W.prototype = this, new W(this);
  }
  return u;
}
Lo.levels = {
  values: {
    fatal: 60,
    error: 50,
    warn: 40,
    info: 30,
    debug: 20,
    trace: 10
  },
  labels: {
    10: "trace",
    20: "debug",
    30: "info",
    40: "warn",
    50: "error",
    60: "fatal"
  }
};
Lo.stdSerializers = uk;
Lo.stdTimeFunctions = Object.assign({}, { nullTime: x4, epochTime: _4, unixTime: mk, isoTime: vk });
function qc(t, e, r, n) {
  const i = Object.getPrototypeOf(e);
  e[r] = e.levelVal > e.levels.values[r] ? bl : i[r] ? i[r] : vl[r] || vl[n] || bl, lk(t, e, r);
}
function lk(t, e, r) {
  !t.transmit && e[r] === bl || (e[r] = /* @__PURE__ */ function(n) {
    return function() {
      const s = t.timestamp(), o = new Array(arguments.length), a = Object.getPrototypeOf && Object.getPrototypeOf(this) === vl ? vl : this;
      for (var u = 0; u < o.length; u++) o[u] = arguments[u];
      if (t.serialize && !t.asObject && k0(o, this._serialize, this.serializers, this._stdErrSerialize), t.asObject ? n.call(a, hk(this, r, o, s)) : n.apply(a, o), t.transmit) {
        const h = t.transmit.level || e.level, d = Lo.levels.values[h], p = Lo.levels.values[r];
        if (p < d) return;
        dk(this, {
          ts: s,
          methodLevel: r,
          methodValue: p,
          send: t.transmit.send,
          val: e.levelVal
        }, o);
      }
    };
  }(e[r]));
}
function hk(t, e, r, n) {
  t._serialize && k0(r, t._serialize, t.serializers, t._stdErrSerialize);
  const i = r.slice();
  let s = i[0];
  const o = {};
  n && (o.time = n), o.level = Lo.levels.values[e];
  let a = (t._childLevel | 0) + 1;
  if (a < 1 && (a = 1), s !== null && typeof s == "object") {
    for (; a-- && typeof i[0] == "object"; )
      Object.assign(o, i.shift());
    s = i.length ? V2(i.shift(), i) : void 0;
  } else typeof s == "string" && (s = V2(i.shift(), i));
  return s !== void 0 && (o.msg = s), o;
}
function k0(t, e, r, n) {
  for (const i in t)
    if (n && t[i] instanceof Error)
      t[i] = Lo.stdSerializers.err(t[i]);
    else if (typeof t[i] == "object" && !Array.isArray(t[i]))
      for (const s in t[i])
        e && e.indexOf(s) > -1 && s in r && (t[i][s] = r[s](t[i][s]));
}
function zc(t, e, r) {
  return function() {
    const n = new Array(1 + arguments.length);
    n[0] = e;
    for (var i = 1; i < n.length; i++)
      n[i] = arguments[i - 1];
    return t[r].apply(this, n);
  };
}
function dk(t, e, r) {
  const n = e.send, i = e.ts, s = e.methodLevel, o = e.methodValue, a = e.val, u = t._logEvent.bindings;
  k0(
    r,
    t._serialize || Object.keys(t.serializers),
    t.serializers,
    t._stdErrSerialize === void 0 ? !0 : t._stdErrSerialize
  ), t._logEvent.ts = i, t._logEvent.messages = r.filter(function(h) {
    return u.indexOf(h) === -1;
  }), t._logEvent.level.label = s, t._logEvent.level.value = o, n(s, t._logEvent, a), t._logEvent = h1(u);
}
function h1(t) {
  return {
    ts: 0,
    messages: [],
    bindings: t || [],
    level: { label: "", value: 0 }
  };
}
function pk(t) {
  const e = {
    type: t.constructor.name,
    msg: t.message,
    stack: t.stack
  };
  for (const r in t)
    e[r] === void 0 && (e[r] = t[r]);
  return e;
}
function gk(t) {
  return typeof t.timestamp == "function" ? t.timestamp : t.timestamp === !1 ? x4 : _4;
}
function ad() {
  return {};
}
function Jg(t) {
  return t;
}
function bl() {
}
function x4() {
  return !1;
}
function _4() {
  return Date.now();
}
function mk() {
  return Math.round(Date.now() / 1e3);
}
function vk() {
  return new Date(Date.now()).toISOString();
}
function bk() {
  function t(e) {
    return typeof e < "u" && e;
  }
  try {
    return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
      get: function() {
        return delete Object.prototype.globalThis, this.globalThis = this;
      },
      configurable: !0
    }), globalThis;
  } catch {
    return t(self) || t(window) || t(this) || {};
  }
}
const jl = /* @__PURE__ */ ts(Gc), yk = { level: "info" }, ql = "custom_context", kv = 1e3 * 1024;
let wk = class {
  constructor(e) {
    this.nodeValue = e, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
}, G2 = class {
  constructor(e) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e, this.sizeInBytes = 0;
  }
  append(e) {
    const r = new wk(e);
    if (r.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${r.size}`);
    for (; this.size + r.size > this.maxSizeInBytes; ) this.shift();
    this.head ? (this.tail && (this.tail.next = r), this.tail = r) : (this.head = r, this.tail = r), this.lengthInNodes++, this.sizeInBytes += r.size;
  }
  shift() {
    if (!this.head) return;
    const e = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e.size;
  }
  toArray() {
    const e = [];
    let r = this.head;
    for (; r !== null; ) e.push(r.value), r = r.next;
    return e;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e = this.head;
    return { next: () => {
      if (!e) return { done: !0, value: null };
      const r = e.value;
      return e = e.next, { done: !1, value: r };
    } };
  }
}, E4 = class {
  constructor(e, r = kv) {
    this.level = e ?? "error", this.levelValue = Gc.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = r, this.logs = new G2(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(e, r) {
    r === Gc.levels.values.error ? console.error(e) : r === Gc.levels.values.warn ? console.warn(e) : r === Gc.levels.values.debug ? console.debug(e) : r === Gc.levels.values.trace ? console.trace(e) : console.log(e);
  }
  appendToLogs(e) {
    this.logs.append(No({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: e }));
    const r = typeof e == "string" ? JSON.parse(e).level : e.level;
    r >= this.levelValue && this.forwardToConsole(e, r);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new G2(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(e) {
    const r = this.getLogArray();
    return r.push(No({ extraMetadata: e })), new Blob(r, { type: "application/json" });
  }
}, xk = class {
  constructor(e, r = kv) {
    this.baseChunkLogger = new E4(e, r);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
  downloadLogsBlobInBrowser(e) {
    const r = URL.createObjectURL(this.logsToBlob(e)), n = document.createElement("a");
    n.href = r, n.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(n), n.click(), document.body.removeChild(n), URL.revokeObjectURL(r);
  }
}, _k = class {
  constructor(e, r = kv) {
    this.baseChunkLogger = new E4(e, r);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
};
var Ek = Object.defineProperty, Sk = Object.defineProperties, Ak = Object.getOwnPropertyDescriptors, Y2 = Object.getOwnPropertySymbols, Pk = Object.prototype.hasOwnProperty, Mk = Object.prototype.propertyIsEnumerable, J2 = (t, e, r) => e in t ? Ek(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Yd = (t, e) => {
  for (var r in e || (e = {})) Pk.call(e, r) && J2(t, r, e[r]);
  if (Y2) for (var r of Y2(e)) Mk.call(e, r) && J2(t, r, e[r]);
  return t;
}, Jd = (t, e) => Sk(t, Ak(e));
function $0(t) {
  return Jd(Yd({}, t), { level: (t == null ? void 0 : t.level) || yk.level });
}
function Ik(t, e = ql) {
  return t[e] || "";
}
function Ck(t, e, r = ql) {
  return t[r] = e, t;
}
function Si(t, e = ql) {
  let r = "";
  return typeof t.bindings > "u" ? r = Ik(t, e) : r = t.bindings().context || "", r;
}
function Tk(t, e, r = ql) {
  const n = Si(t, r);
  return n.trim() ? `${n}/${e}` : e;
}
function ai(t, e, r = ql) {
  const n = Tk(t, e, r), i = t.child({ context: n });
  return Ck(i, n, r);
}
function Rk(t) {
  var e, r;
  const n = new xk((e = t.opts) == null ? void 0 : e.level, t.maxSizeInBytes);
  return { logger: jl(Jd(Yd({}, t.opts), { level: "trace", browser: Jd(Yd({}, (r = t.opts) == null ? void 0 : r.browser), { write: (i) => n.write(i) }) })), chunkLoggerController: n };
}
function Dk(t) {
  var e;
  const r = new _k((e = t.opts) == null ? void 0 : e.level, t.maxSizeInBytes);
  return { logger: jl(Jd(Yd({}, t.opts), { level: "trace" }), r), chunkLoggerController: r };
}
function Ok(t) {
  return typeof t.loggerOverride < "u" && typeof t.loggerOverride != "string" ? { logger: t.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? Rk(t) : Dk(t);
}
let Nk = class extends dc {
  constructor(e) {
    super(), this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, Lk = class extends dc {
  constructor(e, r) {
    super(), this.core = e, this.logger = r, this.records = /* @__PURE__ */ new Map();
  }
}, kk = class {
  constructor(e, r) {
    this.logger = e, this.core = r;
  }
}, $k = class extends dc {
  constructor(e, r) {
    super(), this.relayer = e, this.logger = r;
  }
}, Bk = class extends dc {
  constructor(e) {
    super();
  }
}, Fk = class {
  constructor(e, r, n, i) {
    this.core = e, this.logger = r, this.name = n;
  }
}, Uk = class extends dc {
  constructor(e, r) {
    super(), this.relayer = e, this.logger = r;
  }
}, jk = class extends dc {
  constructor(e, r) {
    super(), this.core = e, this.logger = r;
  }
}, qk = class {
  constructor(e, r, n) {
    this.core = e, this.logger = r, this.store = n;
  }
}, zk = class {
  constructor(e, r) {
    this.projectId = e, this.logger = r;
  }
}, Hk = class {
  constructor(e, r, n) {
    this.core = e, this.logger = r, this.telemetryEnabled = n;
  }
}, Wk = class {
  constructor(e) {
    this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, Kk = class {
  constructor(e) {
    this.client = e;
  }
};
var $v = {}, Ea = {}, B0 = {}, F0 = {};
Object.defineProperty(F0, "__esModule", { value: !0 });
F0.BrowserRandomSource = void 0;
const X2 = 65536;
class Vk {
  constructor() {
    this.isAvailable = !1, this.isInstantiated = !1;
    const e = typeof self < "u" ? self.crypto || self.msCrypto : null;
    e && e.getRandomValues !== void 0 && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Browser random byte generator is not available.");
    const r = new Uint8Array(e);
    for (let n = 0; n < r.length; n += X2)
      this._crypto.getRandomValues(r.subarray(n, n + Math.min(r.length - n, X2)));
    return r;
  }
}
F0.BrowserRandomSource = Vk;
function S4(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var U0 = {}, ki = {};
Object.defineProperty(ki, "__esModule", { value: !0 });
function Gk(t) {
  for (var e = 0; e < t.length; e++)
    t[e] = 0;
  return t;
}
ki.wipe = Gk;
const Yk = {}, Jk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Yk
}, Symbol.toStringTag, { value: "Module" })), zl = /* @__PURE__ */ bv(Jk);
Object.defineProperty(U0, "__esModule", { value: !0 });
U0.NodeRandomSource = void 0;
const Xk = ki;
class Zk {
  constructor() {
    if (this.isAvailable = !1, this.isInstantiated = !1, typeof S4 < "u") {
      const e = zl;
      e && e.randomBytes && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
    }
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Node.js random byte generator is not available.");
    let r = this._crypto.randomBytes(e);
    if (r.length !== e)
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    const n = new Uint8Array(e);
    for (let i = 0; i < n.length; i++)
      n[i] = r[i];
    return (0, Xk.wipe)(r), n;
  }
}
U0.NodeRandomSource = Zk;
Object.defineProperty(B0, "__esModule", { value: !0 });
B0.SystemRandomSource = void 0;
const Qk = F0, e$ = U0;
class t$ {
  constructor() {
    if (this.isAvailable = !1, this.name = "", this._source = new Qk.BrowserRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Browser";
      return;
    }
    if (this._source = new e$.NodeRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Node";
      return;
    }
  }
  randomBytes(e) {
    if (!this.isAvailable)
      throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(e);
  }
}
B0.SystemRandomSource = t$;
var or = {}, A4 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(a, u) {
    var h = a >>> 16 & 65535, d = a & 65535, p = u >>> 16 & 65535, x = u & 65535;
    return d * x + (h * x + d * p << 16 >>> 0) | 0;
  }
  t.mul = Math.imul || e;
  function r(a, u) {
    return a + u | 0;
  }
  t.add = r;
  function n(a, u) {
    return a - u | 0;
  }
  t.sub = n;
  function i(a, u) {
    return a << u | a >>> 32 - u;
  }
  t.rotl = i;
  function s(a, u) {
    return a << 32 - u | a >>> u;
  }
  t.rotr = s;
  function o(a) {
    return typeof a == "number" && isFinite(a) && Math.floor(a) === a;
  }
  t.isInteger = Number.isInteger || o, t.MAX_SAFE_INTEGER = 9007199254740991, t.isSafeInteger = function(a) {
    return t.isInteger(a) && a >= -t.MAX_SAFE_INTEGER && a <= t.MAX_SAFE_INTEGER;
  };
})(A4);
Object.defineProperty(or, "__esModule", { value: !0 });
var P4 = A4;
function r$(t, e) {
  return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) << 16 >> 16;
}
or.readInt16BE = r$;
function n$(t, e) {
  return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) >>> 0;
}
or.readUint16BE = n$;
function i$(t, e) {
  return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) << 16 >> 16;
}
or.readInt16LE = i$;
function s$(t, e) {
  return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) >>> 0;
}
or.readUint16LE = s$;
function M4(t, e, r) {
  return e === void 0 && (e = new Uint8Array(2)), r === void 0 && (r = 0), e[r + 0] = t >>> 8, e[r + 1] = t >>> 0, e;
}
or.writeUint16BE = M4;
or.writeInt16BE = M4;
function I4(t, e, r) {
  return e === void 0 && (e = new Uint8Array(2)), r === void 0 && (r = 0), e[r + 0] = t >>> 0, e[r + 1] = t >>> 8, e;
}
or.writeUint16LE = I4;
or.writeInt16LE = I4;
function d1(t, e) {
  return e === void 0 && (e = 0), t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3];
}
or.readInt32BE = d1;
function p1(t, e) {
  return e === void 0 && (e = 0), (t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]) >>> 0;
}
or.readUint32BE = p1;
function g1(t, e) {
  return e === void 0 && (e = 0), t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e];
}
or.readInt32LE = g1;
function m1(t, e) {
  return e === void 0 && (e = 0), (t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e]) >>> 0;
}
or.readUint32LE = m1;
function Xd(t, e, r) {
  return e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0), e[r + 0] = t >>> 24, e[r + 1] = t >>> 16, e[r + 2] = t >>> 8, e[r + 3] = t >>> 0, e;
}
or.writeUint32BE = Xd;
or.writeInt32BE = Xd;
function Zd(t, e, r) {
  return e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0), e[r + 0] = t >>> 0, e[r + 1] = t >>> 8, e[r + 2] = t >>> 16, e[r + 3] = t >>> 24, e;
}
or.writeUint32LE = Zd;
or.writeInt32LE = Zd;
function o$(t, e) {
  e === void 0 && (e = 0);
  var r = d1(t, e), n = d1(t, e + 4);
  return r * 4294967296 + n - (n >> 31) * 4294967296;
}
or.readInt64BE = o$;
function a$(t, e) {
  e === void 0 && (e = 0);
  var r = p1(t, e), n = p1(t, e + 4);
  return r * 4294967296 + n;
}
or.readUint64BE = a$;
function c$(t, e) {
  e === void 0 && (e = 0);
  var r = g1(t, e), n = g1(t, e + 4);
  return n * 4294967296 + r - (r >> 31) * 4294967296;
}
or.readInt64LE = c$;
function u$(t, e) {
  e === void 0 && (e = 0);
  var r = m1(t, e), n = m1(t, e + 4);
  return n * 4294967296 + r;
}
or.readUint64LE = u$;
function C4(t, e, r) {
  return e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0), Xd(t / 4294967296 >>> 0, e, r), Xd(t >>> 0, e, r + 4), e;
}
or.writeUint64BE = C4;
or.writeInt64BE = C4;
function T4(t, e, r) {
  return e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0), Zd(t >>> 0, e, r), Zd(t / 4294967296 >>> 0, e, r + 4), e;
}
or.writeUint64LE = T4;
or.writeInt64LE = T4;
function f$(t, e, r) {
  if (r === void 0 && (r = 0), t % 8 !== 0)
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (t / 8 > e.length - r)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var n = 0, i = 1, s = t / 8 + r - 1; s >= r; s--)
    n += e[s] * i, i *= 256;
  return n;
}
or.readUintBE = f$;
function l$(t, e, r) {
  if (r === void 0 && (r = 0), t % 8 !== 0)
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (t / 8 > e.length - r)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var n = 0, i = 1, s = r; s < r + t / 8; s++)
    n += e[s] * i, i *= 256;
  return n;
}
or.readUintLE = l$;
function h$(t, e, r, n) {
  if (r === void 0 && (r = new Uint8Array(t / 8)), n === void 0 && (n = 0), t % 8 !== 0)
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!P4.isSafeInteger(e))
    throw new Error("writeUintBE value must be an integer");
  for (var i = 1, s = t / 8 + n - 1; s >= n; s--)
    r[s] = e / i & 255, i *= 256;
  return r;
}
or.writeUintBE = h$;
function d$(t, e, r, n) {
  if (r === void 0 && (r = new Uint8Array(t / 8)), n === void 0 && (n = 0), t % 8 !== 0)
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!P4.isSafeInteger(e))
    throw new Error("writeUintLE value must be an integer");
  for (var i = 1, s = n; s < n + t / 8; s++)
    r[s] = e / i & 255, i *= 256;
  return r;
}
or.writeUintLE = d$;
function p$(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat32(e);
}
or.readFloat32BE = p$;
function g$(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat32(e, !0);
}
or.readFloat32LE = g$;
function m$(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat64(e);
}
or.readFloat64BE = m$;
function v$(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat64(e, !0);
}
or.readFloat64LE = v$;
function b$(t, e, r) {
  e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat32(r, t), e;
}
or.writeFloat32BE = b$;
function y$(t, e, r) {
  e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat32(r, t, !0), e;
}
or.writeFloat32LE = y$;
function w$(t, e, r) {
  e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat64(r, t), e;
}
or.writeFloat64BE = w$;
function x$(t, e, r) {
  e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat64(r, t, !0), e;
}
or.writeFloat64LE = x$;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.randomStringForEntropy = t.randomString = t.randomUint32 = t.randomBytes = t.defaultRandomSource = void 0;
  const e = B0, r = or, n = ki;
  t.defaultRandomSource = new e.SystemRandomSource();
  function i(h, d = t.defaultRandomSource) {
    return d.randomBytes(h);
  }
  t.randomBytes = i;
  function s(h = t.defaultRandomSource) {
    const d = i(4, h), p = (0, r.readUint32LE)(d);
    return (0, n.wipe)(d), p;
  }
  t.randomUint32 = s;
  const o = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function a(h, d = o, p = t.defaultRandomSource) {
    if (d.length < 2)
      throw new Error("randomString charset is too short");
    if (d.length > 256)
      throw new Error("randomString charset is too long");
    let x = "";
    const A = d.length, I = 256 - 256 % A;
    for (; h > 0; ) {
      const N = i(Math.ceil(h * 256 / I), p);
      for (let L = 0; L < N.length && h > 0; L++) {
        const F = N[L];
        F < I && (x += d.charAt(F % A), h--);
      }
      (0, n.wipe)(N);
    }
    return x;
  }
  t.randomString = a;
  function u(h, d = o, p = t.defaultRandomSource) {
    const x = Math.ceil(h / (Math.log(d.length) / Math.LN2));
    return a(x, d, p);
  }
  t.randomStringForEntropy = u;
})(Ea);
var R4 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = or, r = ki;
  t.DIGEST_LENGTH = 64, t.BLOCK_SIZE = 128;
  var n = (
    /** @class */
    function() {
      function a() {
        this.digestLength = t.DIGEST_LENGTH, this.blockSize = t.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return a.prototype._initState = function() {
        this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209;
      }, a.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, a.prototype.clean = function() {
        r.wipe(this._buffer), r.wipe(this._tempHi), r.wipe(this._tempLo), this.reset();
      }, a.prototype.update = function(u, h) {
        if (h === void 0 && (h = u.length), this._finished)
          throw new Error("SHA512: can't update because hash was finished.");
        var d = 0;
        if (this._bytesHashed += h, this._bufferLength > 0) {
          for (; this._bufferLength < t.BLOCK_SIZE && h > 0; )
            this._buffer[this._bufferLength++] = u[d++], h--;
          this._bufferLength === this.blockSize && (s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (h >= this.blockSize && (d = s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, u, d, h), h %= this.blockSize); h > 0; )
          this._buffer[this._bufferLength++] = u[d++], h--;
        return this;
      }, a.prototype.finish = function(u) {
        if (!this._finished) {
          var h = this._bytesHashed, d = this._bufferLength, p = h / 536870912 | 0, x = h << 3, A = h % 128 < 112 ? 128 : 256;
          this._buffer[d] = 128;
          for (var I = d + 1; I < A - 8; I++)
            this._buffer[I] = 0;
          e.writeUint32BE(p, this._buffer, A - 8), e.writeUint32BE(x, this._buffer, A - 4), s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, A), this._finished = !0;
        }
        for (var I = 0; I < this.digestLength / 8; I++)
          e.writeUint32BE(this._stateHi[I], u, I * 8), e.writeUint32BE(this._stateLo[I], u, I * 8 + 4);
        return this;
      }, a.prototype.digest = function() {
        var u = new Uint8Array(this.digestLength);
        return this.finish(u), u;
      }, a.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, a.prototype.restoreState = function(u) {
        return this._stateHi.set(u.stateHi), this._stateLo.set(u.stateLo), this._bufferLength = u.bufferLength, u.buffer && this._buffer.set(u.buffer), this._bytesHashed = u.bytesHashed, this._finished = !1, this;
      }, a.prototype.cleanSavedState = function(u) {
        r.wipe(u.stateHi), r.wipe(u.stateLo), u.buffer && r.wipe(u.buffer), u.bufferLength = 0, u.bytesHashed = 0;
      }, a;
    }()
  );
  t.SHA512 = n;
  var i = new Int32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  function s(a, u, h, d, p, x, A) {
    for (var I = h[0], N = h[1], L = h[2], F = h[3], $ = h[4], W = h[5], z = h[6], V = h[7], te = d[0], R = d[1], K = d[2], pe = d[3], _e = d[4], Y = d[5], S = d[6], m = d[7], f, g, b, w, _, E, v, M; A >= 128; ) {
      for (var P = 0; P < 16; P++) {
        var B = 8 * P + x;
        a[P] = e.readUint32BE(p, B), u[P] = e.readUint32BE(p, B + 4);
      }
      for (var P = 0; P < 80; P++) {
        var ue = I, D = N, oe = L, Z = F, J = $, Q = W, T = z, X = V, re = te, de = R, ie = K, ce = pe, me = _e, Pe = Y, De = S, Ce = m;
        if (f = V, g = m, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = ($ >>> 14 | _e << 18) ^ ($ >>> 18 | _e << 14) ^ (_e >>> 9 | $ << 23), g = (_e >>> 14 | $ << 18) ^ (_e >>> 18 | $ << 14) ^ ($ >>> 9 | _e << 23), _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, f = $ & W ^ ~$ & z, g = _e & Y ^ ~_e & S, _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, f = i[P * 2], g = i[P * 2 + 1], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, f = a[P % 16], g = u[P % 16], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, b = v & 65535 | M << 16, w = _ & 65535 | E << 16, f = b, g = w, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = (I >>> 28 | te << 4) ^ (te >>> 2 | I << 30) ^ (te >>> 7 | I << 25), g = (te >>> 28 | I << 4) ^ (I >>> 2 | te << 30) ^ (I >>> 7 | te << 25), _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, f = I & N ^ I & L ^ N & L, g = te & R ^ te & K ^ R & K, _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, X = v & 65535 | M << 16, Ce = _ & 65535 | E << 16, f = Z, g = ce, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = b, g = w, _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, Z = v & 65535 | M << 16, ce = _ & 65535 | E << 16, N = ue, L = D, F = oe, $ = Z, W = J, z = Q, V = T, I = X, R = re, K = de, pe = ie, _e = ce, Y = me, S = Pe, m = De, te = Ce, P % 16 === 15)
          for (var B = 0; B < 16; B++)
            f = a[B], g = u[B], _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = a[(B + 9) % 16], g = u[(B + 9) % 16], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, b = a[(B + 1) % 16], w = u[(B + 1) % 16], f = (b >>> 1 | w << 31) ^ (b >>> 8 | w << 24) ^ b >>> 7, g = (w >>> 1 | b << 31) ^ (w >>> 8 | b << 24) ^ (w >>> 7 | b << 25), _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, b = a[(B + 14) % 16], w = u[(B + 14) % 16], f = (b >>> 19 | w << 13) ^ (w >>> 29 | b << 3) ^ b >>> 6, g = (w >>> 19 | b << 13) ^ (b >>> 29 | w << 3) ^ (w >>> 6 | b << 26), _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, a[B] = v & 65535 | M << 16, u[B] = _ & 65535 | E << 16;
      }
      f = I, g = te, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = h[0], g = d[0], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, h[0] = I = v & 65535 | M << 16, d[0] = te = _ & 65535 | E << 16, f = N, g = R, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = h[1], g = d[1], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, h[1] = N = v & 65535 | M << 16, d[1] = R = _ & 65535 | E << 16, f = L, g = K, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = h[2], g = d[2], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, h[2] = L = v & 65535 | M << 16, d[2] = K = _ & 65535 | E << 16, f = F, g = pe, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = h[3], g = d[3], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, h[3] = F = v & 65535 | M << 16, d[3] = pe = _ & 65535 | E << 16, f = $, g = _e, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = h[4], g = d[4], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, h[4] = $ = v & 65535 | M << 16, d[4] = _e = _ & 65535 | E << 16, f = W, g = Y, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = h[5], g = d[5], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, h[5] = W = v & 65535 | M << 16, d[5] = Y = _ & 65535 | E << 16, f = z, g = S, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = h[6], g = d[6], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, h[6] = z = v & 65535 | M << 16, d[6] = S = _ & 65535 | E << 16, f = V, g = m, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = h[7], g = d[7], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, h[7] = V = v & 65535 | M << 16, d[7] = m = _ & 65535 | E << 16, x += 128, A -= 128;
    }
    return x;
  }
  function o(a) {
    var u = new n();
    u.update(a);
    var h = u.digest();
    return u.clean(), h;
  }
  t.hash = o;
})(R4);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.convertSecretKeyToX25519 = t.convertPublicKeyToX25519 = t.verify = t.sign = t.extractPublicKeyFromSecretKey = t.generateKeyPair = t.generateKeyPairFromSeed = t.SEED_LENGTH = t.SECRET_KEY_LENGTH = t.PUBLIC_KEY_LENGTH = t.SIGNATURE_LENGTH = void 0;
  const e = Ea, r = R4, n = ki;
  t.SIGNATURE_LENGTH = 64, t.PUBLIC_KEY_LENGTH = 32, t.SECRET_KEY_LENGTH = 64, t.SEED_LENGTH = 32;
  function i(Z) {
    const J = new Float64Array(16);
    if (Z)
      for (let Q = 0; Q < Z.length; Q++)
        J[Q] = Z[Q];
    return J;
  }
  const s = new Uint8Array(32);
  s[0] = 9;
  const o = i(), a = i([1]), u = i([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]), h = i([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]), d = i([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]), p = i([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]), x = i([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function A(Z, J) {
    for (let Q = 0; Q < 16; Q++)
      Z[Q] = J[Q] | 0;
  }
  function I(Z) {
    let J = 1;
    for (let Q = 0; Q < 16; Q++) {
      let T = Z[Q] + J + 65535;
      J = Math.floor(T / 65536), Z[Q] = T - J * 65536;
    }
    Z[0] += J - 1 + 37 * (J - 1);
  }
  function N(Z, J, Q) {
    const T = ~(Q - 1);
    for (let X = 0; X < 16; X++) {
      const re = T & (Z[X] ^ J[X]);
      Z[X] ^= re, J[X] ^= re;
    }
  }
  function L(Z, J) {
    const Q = i(), T = i();
    for (let X = 0; X < 16; X++)
      T[X] = J[X];
    I(T), I(T), I(T);
    for (let X = 0; X < 2; X++) {
      Q[0] = T[0] - 65517;
      for (let de = 1; de < 15; de++)
        Q[de] = T[de] - 65535 - (Q[de - 1] >> 16 & 1), Q[de - 1] &= 65535;
      Q[15] = T[15] - 32767 - (Q[14] >> 16 & 1);
      const re = Q[15] >> 16 & 1;
      Q[14] &= 65535, N(T, Q, 1 - re);
    }
    for (let X = 0; X < 16; X++)
      Z[2 * X] = T[X] & 255, Z[2 * X + 1] = T[X] >> 8;
  }
  function F(Z, J) {
    let Q = 0;
    for (let T = 0; T < 32; T++)
      Q |= Z[T] ^ J[T];
    return (1 & Q - 1 >>> 8) - 1;
  }
  function $(Z, J) {
    const Q = new Uint8Array(32), T = new Uint8Array(32);
    return L(Q, Z), L(T, J), F(Q, T);
  }
  function W(Z) {
    const J = new Uint8Array(32);
    return L(J, Z), J[0] & 1;
  }
  function z(Z, J) {
    for (let Q = 0; Q < 16; Q++)
      Z[Q] = J[2 * Q] + (J[2 * Q + 1] << 8);
    Z[15] &= 32767;
  }
  function V(Z, J, Q) {
    for (let T = 0; T < 16; T++)
      Z[T] = J[T] + Q[T];
  }
  function te(Z, J, Q) {
    for (let T = 0; T < 16; T++)
      Z[T] = J[T] - Q[T];
  }
  function R(Z, J, Q) {
    let T, X, re = 0, de = 0, ie = 0, ce = 0, me = 0, Pe = 0, De = 0, Ce = 0, $e = 0, Me = 0, Ne = 0, Ke = 0, Le = 0, qe = 0, ze = 0, Ee = 0, Ze = 0, at = 0, ke = 0, Qe = 0, tt = 0, Ye = 0, dt = 0, lt = 0, ct = 0, qt = 0, Yt = 0, Et = 0, Qt = 0, Jt = 0, Dt = 0, kt = Q[0], Ct = Q[1], gt = Q[2], Rt = Q[3], Nt = Q[4], vt = Q[5], $t = Q[6], Ft = Q[7], rt = Q[8], Bt = Q[9], k = Q[10], j = Q[11], H = Q[12], C = Q[13], G = Q[14], U = Q[15];
    T = J[0], re += T * kt, de += T * Ct, ie += T * gt, ce += T * Rt, me += T * Nt, Pe += T * vt, De += T * $t, Ce += T * Ft, $e += T * rt, Me += T * Bt, Ne += T * k, Ke += T * j, Le += T * H, qe += T * C, ze += T * G, Ee += T * U, T = J[1], de += T * kt, ie += T * Ct, ce += T * gt, me += T * Rt, Pe += T * Nt, De += T * vt, Ce += T * $t, $e += T * Ft, Me += T * rt, Ne += T * Bt, Ke += T * k, Le += T * j, qe += T * H, ze += T * C, Ee += T * G, Ze += T * U, T = J[2], ie += T * kt, ce += T * Ct, me += T * gt, Pe += T * Rt, De += T * Nt, Ce += T * vt, $e += T * $t, Me += T * Ft, Ne += T * rt, Ke += T * Bt, Le += T * k, qe += T * j, ze += T * H, Ee += T * C, Ze += T * G, at += T * U, T = J[3], ce += T * kt, me += T * Ct, Pe += T * gt, De += T * Rt, Ce += T * Nt, $e += T * vt, Me += T * $t, Ne += T * Ft, Ke += T * rt, Le += T * Bt, qe += T * k, ze += T * j, Ee += T * H, Ze += T * C, at += T * G, ke += T * U, T = J[4], me += T * kt, Pe += T * Ct, De += T * gt, Ce += T * Rt, $e += T * Nt, Me += T * vt, Ne += T * $t, Ke += T * Ft, Le += T * rt, qe += T * Bt, ze += T * k, Ee += T * j, Ze += T * H, at += T * C, ke += T * G, Qe += T * U, T = J[5], Pe += T * kt, De += T * Ct, Ce += T * gt, $e += T * Rt, Me += T * Nt, Ne += T * vt, Ke += T * $t, Le += T * Ft, qe += T * rt, ze += T * Bt, Ee += T * k, Ze += T * j, at += T * H, ke += T * C, Qe += T * G, tt += T * U, T = J[6], De += T * kt, Ce += T * Ct, $e += T * gt, Me += T * Rt, Ne += T * Nt, Ke += T * vt, Le += T * $t, qe += T * Ft, ze += T * rt, Ee += T * Bt, Ze += T * k, at += T * j, ke += T * H, Qe += T * C, tt += T * G, Ye += T * U, T = J[7], Ce += T * kt, $e += T * Ct, Me += T * gt, Ne += T * Rt, Ke += T * Nt, Le += T * vt, qe += T * $t, ze += T * Ft, Ee += T * rt, Ze += T * Bt, at += T * k, ke += T * j, Qe += T * H, tt += T * C, Ye += T * G, dt += T * U, T = J[8], $e += T * kt, Me += T * Ct, Ne += T * gt, Ke += T * Rt, Le += T * Nt, qe += T * vt, ze += T * $t, Ee += T * Ft, Ze += T * rt, at += T * Bt, ke += T * k, Qe += T * j, tt += T * H, Ye += T * C, dt += T * G, lt += T * U, T = J[9], Me += T * kt, Ne += T * Ct, Ke += T * gt, Le += T * Rt, qe += T * Nt, ze += T * vt, Ee += T * $t, Ze += T * Ft, at += T * rt, ke += T * Bt, Qe += T * k, tt += T * j, Ye += T * H, dt += T * C, lt += T * G, ct += T * U, T = J[10], Ne += T * kt, Ke += T * Ct, Le += T * gt, qe += T * Rt, ze += T * Nt, Ee += T * vt, Ze += T * $t, at += T * Ft, ke += T * rt, Qe += T * Bt, tt += T * k, Ye += T * j, dt += T * H, lt += T * C, ct += T * G, qt += T * U, T = J[11], Ke += T * kt, Le += T * Ct, qe += T * gt, ze += T * Rt, Ee += T * Nt, Ze += T * vt, at += T * $t, ke += T * Ft, Qe += T * rt, tt += T * Bt, Ye += T * k, dt += T * j, lt += T * H, ct += T * C, qt += T * G, Yt += T * U, T = J[12], Le += T * kt, qe += T * Ct, ze += T * gt, Ee += T * Rt, Ze += T * Nt, at += T * vt, ke += T * $t, Qe += T * Ft, tt += T * rt, Ye += T * Bt, dt += T * k, lt += T * j, ct += T * H, qt += T * C, Yt += T * G, Et += T * U, T = J[13], qe += T * kt, ze += T * Ct, Ee += T * gt, Ze += T * Rt, at += T * Nt, ke += T * vt, Qe += T * $t, tt += T * Ft, Ye += T * rt, dt += T * Bt, lt += T * k, ct += T * j, qt += T * H, Yt += T * C, Et += T * G, Qt += T * U, T = J[14], ze += T * kt, Ee += T * Ct, Ze += T * gt, at += T * Rt, ke += T * Nt, Qe += T * vt, tt += T * $t, Ye += T * Ft, dt += T * rt, lt += T * Bt, ct += T * k, qt += T * j, Yt += T * H, Et += T * C, Qt += T * G, Jt += T * U, T = J[15], Ee += T * kt, Ze += T * Ct, at += T * gt, ke += T * Rt, Qe += T * Nt, tt += T * vt, Ye += T * $t, dt += T * Ft, lt += T * rt, ct += T * Bt, qt += T * k, Yt += T * j, Et += T * H, Qt += T * C, Jt += T * G, Dt += T * U, re += 38 * Ze, de += 38 * at, ie += 38 * ke, ce += 38 * Qe, me += 38 * tt, Pe += 38 * Ye, De += 38 * dt, Ce += 38 * lt, $e += 38 * ct, Me += 38 * qt, Ne += 38 * Yt, Ke += 38 * Et, Le += 38 * Qt, qe += 38 * Jt, ze += 38 * Dt, X = 1, T = re + X + 65535, X = Math.floor(T / 65536), re = T - X * 65536, T = de + X + 65535, X = Math.floor(T / 65536), de = T - X * 65536, T = ie + X + 65535, X = Math.floor(T / 65536), ie = T - X * 65536, T = ce + X + 65535, X = Math.floor(T / 65536), ce = T - X * 65536, T = me + X + 65535, X = Math.floor(T / 65536), me = T - X * 65536, T = Pe + X + 65535, X = Math.floor(T / 65536), Pe = T - X * 65536, T = De + X + 65535, X = Math.floor(T / 65536), De = T - X * 65536, T = Ce + X + 65535, X = Math.floor(T / 65536), Ce = T - X * 65536, T = $e + X + 65535, X = Math.floor(T / 65536), $e = T - X * 65536, T = Me + X + 65535, X = Math.floor(T / 65536), Me = T - X * 65536, T = Ne + X + 65535, X = Math.floor(T / 65536), Ne = T - X * 65536, T = Ke + X + 65535, X = Math.floor(T / 65536), Ke = T - X * 65536, T = Le + X + 65535, X = Math.floor(T / 65536), Le = T - X * 65536, T = qe + X + 65535, X = Math.floor(T / 65536), qe = T - X * 65536, T = ze + X + 65535, X = Math.floor(T / 65536), ze = T - X * 65536, T = Ee + X + 65535, X = Math.floor(T / 65536), Ee = T - X * 65536, re += X - 1 + 37 * (X - 1), X = 1, T = re + X + 65535, X = Math.floor(T / 65536), re = T - X * 65536, T = de + X + 65535, X = Math.floor(T / 65536), de = T - X * 65536, T = ie + X + 65535, X = Math.floor(T / 65536), ie = T - X * 65536, T = ce + X + 65535, X = Math.floor(T / 65536), ce = T - X * 65536, T = me + X + 65535, X = Math.floor(T / 65536), me = T - X * 65536, T = Pe + X + 65535, X = Math.floor(T / 65536), Pe = T - X * 65536, T = De + X + 65535, X = Math.floor(T / 65536), De = T - X * 65536, T = Ce + X + 65535, X = Math.floor(T / 65536), Ce = T - X * 65536, T = $e + X + 65535, X = Math.floor(T / 65536), $e = T - X * 65536, T = Me + X + 65535, X = Math.floor(T / 65536), Me = T - X * 65536, T = Ne + X + 65535, X = Math.floor(T / 65536), Ne = T - X * 65536, T = Ke + X + 65535, X = Math.floor(T / 65536), Ke = T - X * 65536, T = Le + X + 65535, X = Math.floor(T / 65536), Le = T - X * 65536, T = qe + X + 65535, X = Math.floor(T / 65536), qe = T - X * 65536, T = ze + X + 65535, X = Math.floor(T / 65536), ze = T - X * 65536, T = Ee + X + 65535, X = Math.floor(T / 65536), Ee = T - X * 65536, re += X - 1 + 37 * (X - 1), Z[0] = re, Z[1] = de, Z[2] = ie, Z[3] = ce, Z[4] = me, Z[5] = Pe, Z[6] = De, Z[7] = Ce, Z[8] = $e, Z[9] = Me, Z[10] = Ne, Z[11] = Ke, Z[12] = Le, Z[13] = qe, Z[14] = ze, Z[15] = Ee;
  }
  function K(Z, J) {
    R(Z, J, J);
  }
  function pe(Z, J) {
    const Q = i();
    let T;
    for (T = 0; T < 16; T++)
      Q[T] = J[T];
    for (T = 253; T >= 0; T--)
      K(Q, Q), T !== 2 && T !== 4 && R(Q, Q, J);
    for (T = 0; T < 16; T++)
      Z[T] = Q[T];
  }
  function _e(Z, J) {
    const Q = i();
    let T;
    for (T = 0; T < 16; T++)
      Q[T] = J[T];
    for (T = 250; T >= 0; T--)
      K(Q, Q), T !== 1 && R(Q, Q, J);
    for (T = 0; T < 16; T++)
      Z[T] = Q[T];
  }
  function Y(Z, J) {
    const Q = i(), T = i(), X = i(), re = i(), de = i(), ie = i(), ce = i(), me = i(), Pe = i();
    te(Q, Z[1], Z[0]), te(Pe, J[1], J[0]), R(Q, Q, Pe), V(T, Z[0], Z[1]), V(Pe, J[0], J[1]), R(T, T, Pe), R(X, Z[3], J[3]), R(X, X, h), R(re, Z[2], J[2]), V(re, re, re), te(de, T, Q), te(ie, re, X), V(ce, re, X), V(me, T, Q), R(Z[0], de, ie), R(Z[1], me, ce), R(Z[2], ce, ie), R(Z[3], de, me);
  }
  function S(Z, J, Q) {
    for (let T = 0; T < 4; T++)
      N(Z[T], J[T], Q);
  }
  function m(Z, J) {
    const Q = i(), T = i(), X = i();
    pe(X, J[2]), R(Q, J[0], X), R(T, J[1], X), L(Z, T), Z[31] ^= W(Q) << 7;
  }
  function f(Z, J, Q) {
    A(Z[0], o), A(Z[1], a), A(Z[2], a), A(Z[3], o);
    for (let T = 255; T >= 0; --T) {
      const X = Q[T / 8 | 0] >> (T & 7) & 1;
      S(Z, J, X), Y(J, Z), Y(Z, Z), S(Z, J, X);
    }
  }
  function g(Z, J) {
    const Q = [i(), i(), i(), i()];
    A(Q[0], d), A(Q[1], p), A(Q[2], a), R(Q[3], d, p), f(Z, Q, J);
  }
  function b(Z) {
    if (Z.length !== t.SEED_LENGTH)
      throw new Error(`ed25519: seed must be ${t.SEED_LENGTH} bytes`);
    const J = (0, r.hash)(Z);
    J[0] &= 248, J[31] &= 127, J[31] |= 64;
    const Q = new Uint8Array(32), T = [i(), i(), i(), i()];
    g(T, J), m(Q, T);
    const X = new Uint8Array(64);
    return X.set(Z), X.set(Q, 32), {
      publicKey: Q,
      secretKey: X
    };
  }
  t.generateKeyPairFromSeed = b;
  function w(Z) {
    const J = (0, e.randomBytes)(32, Z), Q = b(J);
    return (0, n.wipe)(J), Q;
  }
  t.generateKeyPair = w;
  function _(Z) {
    if (Z.length !== t.SECRET_KEY_LENGTH)
      throw new Error(`ed25519: secret key must be ${t.SECRET_KEY_LENGTH} bytes`);
    return new Uint8Array(Z.subarray(32));
  }
  t.extractPublicKeyFromSecretKey = _;
  const E = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function v(Z, J) {
    let Q, T, X, re;
    for (T = 63; T >= 32; --T) {
      for (Q = 0, X = T - 32, re = T - 12; X < re; ++X)
        J[X] += Q - 16 * J[T] * E[X - (T - 32)], Q = Math.floor((J[X] + 128) / 256), J[X] -= Q * 256;
      J[X] += Q, J[T] = 0;
    }
    for (Q = 0, X = 0; X < 32; X++)
      J[X] += Q - (J[31] >> 4) * E[X], Q = J[X] >> 8, J[X] &= 255;
    for (X = 0; X < 32; X++)
      J[X] -= Q * E[X];
    for (T = 0; T < 32; T++)
      J[T + 1] += J[T] >> 8, Z[T] = J[T] & 255;
  }
  function M(Z) {
    const J = new Float64Array(64);
    for (let Q = 0; Q < 64; Q++)
      J[Q] = Z[Q];
    for (let Q = 0; Q < 64; Q++)
      Z[Q] = 0;
    v(Z, J);
  }
  function P(Z, J) {
    const Q = new Float64Array(64), T = [i(), i(), i(), i()], X = (0, r.hash)(Z.subarray(0, 32));
    X[0] &= 248, X[31] &= 127, X[31] |= 64;
    const re = new Uint8Array(64);
    re.set(X.subarray(32), 32);
    const de = new r.SHA512();
    de.update(re.subarray(32)), de.update(J);
    const ie = de.digest();
    de.clean(), M(ie), g(T, ie), m(re, T), de.reset(), de.update(re.subarray(0, 32)), de.update(Z.subarray(32)), de.update(J);
    const ce = de.digest();
    M(ce);
    for (let me = 0; me < 32; me++)
      Q[me] = ie[me];
    for (let me = 0; me < 32; me++)
      for (let Pe = 0; Pe < 32; Pe++)
        Q[me + Pe] += ce[me] * X[Pe];
    return v(re.subarray(32), Q), re;
  }
  t.sign = P;
  function B(Z, J) {
    const Q = i(), T = i(), X = i(), re = i(), de = i(), ie = i(), ce = i();
    return A(Z[2], a), z(Z[1], J), K(X, Z[1]), R(re, X, u), te(X, X, Z[2]), V(re, Z[2], re), K(de, re), K(ie, de), R(ce, ie, de), R(Q, ce, X), R(Q, Q, re), _e(Q, Q), R(Q, Q, X), R(Q, Q, re), R(Q, Q, re), R(Z[0], Q, re), K(T, Z[0]), R(T, T, re), $(T, X) && R(Z[0], Z[0], x), K(T, Z[0]), R(T, T, re), $(T, X) ? -1 : (W(Z[0]) === J[31] >> 7 && te(Z[0], o, Z[0]), R(Z[3], Z[0], Z[1]), 0);
  }
  function ue(Z, J, Q) {
    const T = new Uint8Array(32), X = [i(), i(), i(), i()], re = [i(), i(), i(), i()];
    if (Q.length !== t.SIGNATURE_LENGTH)
      throw new Error(`ed25519: signature must be ${t.SIGNATURE_LENGTH} bytes`);
    if (B(re, Z))
      return !1;
    const de = new r.SHA512();
    de.update(Q.subarray(0, 32)), de.update(Z), de.update(J);
    const ie = de.digest();
    return M(ie), f(X, re, ie), g(re, Q.subarray(32)), Y(X, re), m(T, X), !F(Q, T);
  }
  t.verify = ue;
  function D(Z) {
    let J = [i(), i(), i(), i()];
    if (B(J, Z))
      throw new Error("Ed25519: invalid public key");
    let Q = i(), T = i(), X = J[1];
    V(Q, a, X), te(T, a, X), pe(T, T), R(Q, Q, T);
    let re = new Uint8Array(32);
    return L(re, Q), re;
  }
  t.convertPublicKeyToX25519 = D;
  function oe(Z) {
    const J = (0, r.hash)(Z.subarray(0, 32));
    J[0] &= 248, J[31] &= 127, J[31] |= 64;
    const Q = new Uint8Array(J.subarray(0, 32));
    return (0, n.wipe)(J), Q;
  }
  t.convertSecretKeyToX25519 = oe;
})($v);
const _$ = "EdDSA", E$ = "JWT", Qd = ".", j0 = "base64url", D4 = "utf8", O4 = "utf8", S$ = ":", A$ = "did", P$ = "key", Z2 = "base58btc", M$ = "z", I$ = "K36", C$ = 32;
function N4(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(t) : new Uint8Array(t);
}
function Ed(t, e) {
  e || (e = t.reduce((i, s) => i + s.length, 0));
  const r = N4(e);
  let n = 0;
  for (const i of t)
    r.set(i, n), n += i.length;
  return r;
}
function T$(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++)
    r[n] = 255;
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i), o = s.charCodeAt(0);
    if (r[o] !== 255)
      throw new TypeError(s + " is ambiguous");
    r[o] = i;
  }
  var a = t.length, u = t.charAt(0), h = Math.log(a) / Math.log(256), d = Math.log(256) / Math.log(a);
  function p(I) {
    if (I instanceof Uint8Array || (ArrayBuffer.isView(I) ? I = new Uint8Array(I.buffer, I.byteOffset, I.byteLength) : Array.isArray(I) && (I = Uint8Array.from(I))), !(I instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (I.length === 0)
      return "";
    for (var N = 0, L = 0, F = 0, $ = I.length; F !== $ && I[F] === 0; )
      F++, N++;
    for (var W = ($ - F) * d + 1 >>> 0, z = new Uint8Array(W); F !== $; ) {
      for (var V = I[F], te = 0, R = W - 1; (V !== 0 || te < L) && R !== -1; R--, te++)
        V += 256 * z[R] >>> 0, z[R] = V % a >>> 0, V = V / a >>> 0;
      if (V !== 0)
        throw new Error("Non-zero carry");
      L = te, F++;
    }
    for (var K = W - L; K !== W && z[K] === 0; )
      K++;
    for (var pe = u.repeat(N); K < W; ++K)
      pe += t.charAt(z[K]);
    return pe;
  }
  function x(I) {
    if (typeof I != "string")
      throw new TypeError("Expected String");
    if (I.length === 0)
      return new Uint8Array();
    var N = 0;
    if (I[N] !== " ") {
      for (var L = 0, F = 0; I[N] === u; )
        L++, N++;
      for (var $ = (I.length - N) * h + 1 >>> 0, W = new Uint8Array($); I[N]; ) {
        var z = r[I.charCodeAt(N)];
        if (z === 255)
          return;
        for (var V = 0, te = $ - 1; (z !== 0 || V < F) && te !== -1; te--, V++)
          z += a * W[te] >>> 0, W[te] = z % 256 >>> 0, z = z / 256 >>> 0;
        if (z !== 0)
          throw new Error("Non-zero carry");
        F = V, N++;
      }
      if (I[N] !== " ") {
        for (var R = $ - F; R !== $ && W[R] === 0; )
          R++;
        for (var K = new Uint8Array(L + ($ - R)), pe = L; R !== $; )
          K[pe++] = W[R++];
        return K;
      }
    }
  }
  function A(I) {
    var N = x(I);
    if (N)
      return N;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: p,
    decodeUnsafe: x,
    decode: A
  };
}
var R$ = T$, D$ = R$;
const O$ = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, N$ = (t) => new TextEncoder().encode(t), L$ = (t) => new TextDecoder().decode(t);
class k$ {
  constructor(e, r, n) {
    this.name = e, this.prefix = r, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class $$ {
  constructor(e, r, n) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return L4(this, e);
  }
}
class B$ {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return L4(this, e);
  }
  decode(e) {
    const r = e[0], n = this.decoders[r];
    if (n)
      return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const L4 = (t, e) => new B$({
  ...t.decoders || { [t.prefix]: t },
  ...e.decoders || { [e.prefix]: e }
});
class F$ {
  constructor(e, r, n, i) {
    this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = i, this.encoder = new k$(e, r, n), this.decoder = new $$(e, r, i);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const q0 = ({ name: t, prefix: e, encode: r, decode: n }) => new F$(t, e, r, n), Hl = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: n, decode: i } = D$(r, e);
  return q0({
    prefix: t,
    name: e,
    encode: n,
    decode: (s) => O$(i(s))
  });
}, U$ = (t, e, r, n) => {
  const i = {};
  for (let d = 0; d < e.length; ++d)
    i[e[d]] = d;
  let s = t.length;
  for (; t[s - 1] === "="; )
    --s;
  const o = new Uint8Array(s * r / 8 | 0);
  let a = 0, u = 0, h = 0;
  for (let d = 0; d < s; ++d) {
    const p = i[t[d]];
    if (p === void 0)
      throw new SyntaxError(`Non-${n} character`);
    u = u << r | p, a += r, a >= 8 && (a -= 8, o[h++] = 255 & u >> a);
  }
  if (a >= r || 255 & u << 8 - a)
    throw new SyntaxError("Unexpected end of data");
  return o;
}, j$ = (t, e, r) => {
  const n = e[e.length - 1] === "=", i = (1 << r) - 1;
  let s = "", o = 0, a = 0;
  for (let u = 0; u < t.length; ++u)
    for (a = a << 8 | t[u], o += 8; o > r; )
      o -= r, s += e[i & a >> o];
  if (o && (s += e[i & a << r - o]), n)
    for (; s.length * r & 7; )
      s += "=";
  return s;
}, jn = ({ name: t, prefix: e, bitsPerChar: r, alphabet: n }) => q0({
  prefix: e,
  name: t,
  encode(i) {
    return j$(i, n, r);
  },
  decode(i) {
    return U$(i, n, r, t);
  }
}), q$ = q0({
  prefix: "\0",
  name: "identity",
  encode: (t) => L$(t),
  decode: (t) => N$(t)
}), z$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: q$
}, Symbol.toStringTag, { value: "Module" })), H$ = jn({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), W$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: H$
}, Symbol.toStringTag, { value: "Module" })), K$ = jn({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), V$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: K$
}, Symbol.toStringTag, { value: "Module" })), G$ = Hl({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), Y$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: G$
}, Symbol.toStringTag, { value: "Module" })), J$ = jn({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), X$ = jn({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), Z$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: J$,
  base16upper: X$
}, Symbol.toStringTag, { value: "Module" })), Q$ = jn({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), eB = jn({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), tB = jn({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), rB = jn({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), nB = jn({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), iB = jn({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), sB = jn({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), oB = jn({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), aB = jn({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), cB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: Q$,
  base32hex: nB,
  base32hexpad: sB,
  base32hexpadupper: oB,
  base32hexupper: iB,
  base32pad: tB,
  base32padupper: rB,
  base32upper: eB,
  base32z: aB
}, Symbol.toStringTag, { value: "Module" })), uB = Hl({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), fB = Hl({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), lB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: uB,
  base36upper: fB
}, Symbol.toStringTag, { value: "Module" })), hB = Hl({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), dB = Hl({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), pB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: hB,
  base58flickr: dB
}, Symbol.toStringTag, { value: "Module" })), gB = jn({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), mB = jn({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), vB = jn({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), bB = jn({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), yB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: gB,
  base64pad: mB,
  base64url: vB,
  base64urlpad: bB
}, Symbol.toStringTag, { value: "Module" })), k4 = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), wB = k4.reduce((t, e, r) => (t[r] = e, t), []), xB = k4.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function _B(t) {
  return t.reduce((e, r) => (e += wB[r], e), "");
}
function EB(t) {
  const e = [];
  for (const r of t) {
    const n = xB[r.codePointAt(0)];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const SB = q0({
  prefix: "🚀",
  name: "base256emoji",
  encode: _B,
  decode: EB
}), AB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: SB
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const Q2 = {
  ...z$,
  ...W$,
  ...V$,
  ...Y$,
  ...Z$,
  ...cB,
  ...lB,
  ...pB,
  ...yB,
  ...AB
};
function $4(t, e, r, n) {
  return {
    name: t,
    prefix: e,
    encoder: {
      name: t,
      prefix: e,
      encode: r
    },
    decoder: { decode: n }
  };
}
const ex = $4("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), Xg = $4("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = N4(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = t.charCodeAt(r);
  return e;
}), B4 = {
  utf8: ex,
  "utf-8": ex,
  hex: Q2.base16,
  latin1: Xg,
  ascii: Xg,
  binary: Xg,
  ...Q2
};
function Rn(t, e = "utf8") {
  const r = B4[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8") : r.encoder.encode(t).substring(1);
}
function Tn(t, e = "utf8") {
  const r = B4[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t, "utf8") : r.decoder.decode(`${r.prefix}${t}`);
}
function tx(t) {
  return oc(Rn(Tn(t, j0), D4));
}
function e0(t) {
  return Rn(Tn(No(t), D4), j0);
}
function F4(t) {
  const e = Tn(I$, Z2), r = M$ + Rn(Ed([e, t]), Z2);
  return [A$, P$, r].join(S$);
}
function PB(t) {
  return Rn(t, j0);
}
function MB(t) {
  return Tn(t, j0);
}
function IB(t) {
  return Tn([e0(t.header), e0(t.payload)].join(Qd), O4);
}
function CB(t) {
  return [
    e0(t.header),
    e0(t.payload),
    PB(t.signature)
  ].join(Qd);
}
function v1(t) {
  const e = t.split(Qd), r = tx(e[0]), n = tx(e[1]), i = MB(e[2]), s = Tn(e.slice(0, 2).join(Qd), O4);
  return { header: r, payload: n, signature: i, data: s };
}
function rx(t = Ea.randomBytes(C$)) {
  return $v.generateKeyPairFromSeed(t);
}
async function TB(t, e, r, n, i = mt.fromMiliseconds(Date.now())) {
  const s = { alg: _$, typ: E$ }, o = F4(n.publicKey), a = i + r, u = { iss: o, sub: t, aud: e, iat: i, exp: a }, h = IB({ header: s, payload: u }), d = $v.sign(n.secretKey, h);
  return CB({ header: s, payload: u, signature: d });
}
var nx = function(t, e, r) {
  if (r || arguments.length === 2) for (var n = 0, i = e.length, s; n < i; n++)
    (s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
  return t.concat(s || Array.prototype.slice.call(e));
}, RB = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e, r, n) {
      this.name = e, this.version = r, this.os = n, this.type = "browser";
    }
    return t;
  }()
), DB = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e) {
      this.version = e, this.type = "node", this.name = "node", this.os = process.platform;
    }
    return t;
  }()
), OB = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e, r, n, i) {
      this.name = e, this.version = r, this.os = n, this.bot = i, this.type = "bot-device";
    }
    return t;
  }()
), NB = (
  /** @class */
  /* @__PURE__ */ function() {
    function t() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return t;
  }()
), LB = (
  /** @class */
  /* @__PURE__ */ function() {
    function t() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return t;
  }()
), kB = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, $B = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, ix = 3, BB = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", kB]
], sx = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function FB(t) {
  return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new LB() : typeof navigator < "u" ? jB(navigator.userAgent) : zB();
}
function UB(t) {
  return t !== "" && BB.reduce(function(e, r) {
    var n = r[0], i = r[1];
    if (e)
      return e;
    var s = i.exec(t);
    return !!s && [n, s];
  }, !1);
}
function jB(t) {
  var e = UB(t);
  if (!e)
    return null;
  var r = e[0], n = e[1];
  if (r === "searchbot")
    return new NB();
  var i = n[1] && n[1].split(".").join("_").split("_").slice(0, 3);
  i ? i.length < ix && (i = nx(nx([], i, !0), HB(ix - i.length), !0)) : i = [];
  var s = i.join("."), o = qB(t), a = $B.exec(t);
  return a && a[1] ? new OB(r, s, o, a[1]) : new RB(r, s, o);
}
function qB(t) {
  for (var e = 0, r = sx.length; e < r; e++) {
    var n = sx[e], i = n[0], s = n[1], o = s.exec(t);
    if (o)
      return i;
  }
  return null;
}
function zB() {
  var t = typeof process < "u" && process.version;
  return t ? new DB(process.version.slice(1)) : null;
}
function HB(t) {
  for (var e = [], r = 0; r < t; r++)
    e.push("0");
  return e;
}
var Hr = {};
Object.defineProperty(Hr, "__esModule", { value: !0 });
Hr.getLocalStorage = Hr.getLocalStorageOrThrow = Hr.getCrypto = Hr.getCryptoOrThrow = U4 = Hr.getLocation = Hr.getLocationOrThrow = Bv = Hr.getNavigator = Hr.getNavigatorOrThrow = Wl = Hr.getDocument = Hr.getDocumentOrThrow = Hr.getFromWindowOrThrow = Hr.getFromWindow = void 0;
function gc(t) {
  let e;
  return typeof window < "u" && typeof window[t] < "u" && (e = window[t]), e;
}
Hr.getFromWindow = gc;
function Du(t) {
  const e = gc(t);
  if (!e)
    throw new Error(`${t} is not defined in Window`);
  return e;
}
Hr.getFromWindowOrThrow = Du;
function WB() {
  return Du("document");
}
Hr.getDocumentOrThrow = WB;
function KB() {
  return gc("document");
}
var Wl = Hr.getDocument = KB;
function VB() {
  return Du("navigator");
}
Hr.getNavigatorOrThrow = VB;
function GB() {
  return gc("navigator");
}
var Bv = Hr.getNavigator = GB;
function YB() {
  return Du("location");
}
Hr.getLocationOrThrow = YB;
function JB() {
  return gc("location");
}
var U4 = Hr.getLocation = JB;
function XB() {
  return Du("crypto");
}
Hr.getCryptoOrThrow = XB;
function ZB() {
  return gc("crypto");
}
Hr.getCrypto = ZB;
function QB() {
  return Du("localStorage");
}
Hr.getLocalStorageOrThrow = QB;
function eF() {
  return gc("localStorage");
}
Hr.getLocalStorage = eF;
var Fv = {};
Object.defineProperty(Fv, "__esModule", { value: !0 });
var j4 = Fv.getWindowMetadata = void 0;
const ox = Hr;
function tF() {
  let t, e;
  try {
    t = ox.getDocumentOrThrow(), e = ox.getLocationOrThrow();
  } catch {
    return null;
  }
  function r() {
    const p = t.getElementsByTagName("link"), x = [];
    for (let A = 0; A < p.length; A++) {
      const I = p[A], N = I.getAttribute("rel");
      if (N && N.toLowerCase().indexOf("icon") > -1) {
        const L = I.getAttribute("href");
        if (L)
          if (L.toLowerCase().indexOf("https:") === -1 && L.toLowerCase().indexOf("http:") === -1 && L.indexOf("//") !== 0) {
            let F = e.protocol + "//" + e.host;
            if (L.indexOf("/") === 0)
              F += L;
            else {
              const $ = e.pathname.split("/");
              $.pop();
              const W = $.join("/");
              F += W + "/" + L;
            }
            x.push(F);
          } else if (L.indexOf("//") === 0) {
            const F = e.protocol + L;
            x.push(F);
          } else
            x.push(L);
      }
    }
    return x;
  }
  function n(...p) {
    const x = t.getElementsByTagName("meta");
    for (let A = 0; A < x.length; A++) {
      const I = x[A], N = ["itemprop", "property", "name"].map((L) => I.getAttribute(L)).filter((L) => L ? p.includes(L) : !1);
      if (N.length && N) {
        const L = I.getAttribute("content");
        if (L)
          return L;
      }
    }
    return "";
  }
  function i() {
    let p = n("name", "og:site_name", "og:title", "twitter:title");
    return p || (p = t.title), p;
  }
  function s() {
    return n("description", "og:description", "twitter:description", "keywords");
  }
  const o = i(), a = s(), u = e.origin, h = r();
  return {
    description: a,
    url: u,
    icons: h,
    name: o
  };
}
j4 = Fv.getWindowMetadata = tF;
var yl = {}, rF = (t) => encodeURIComponent(t).replace(/[!'()*]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`), q4 = "%[a-f0-9]{2}", ax = new RegExp("(" + q4 + ")|([^%]+?)", "gi"), cx = new RegExp("(" + q4 + ")+", "gi");
function b1(t, e) {
  try {
    return [decodeURIComponent(t.join(""))];
  } catch {
  }
  if (t.length === 1)
    return t;
  e = e || 1;
  var r = t.slice(0, e), n = t.slice(e);
  return Array.prototype.concat.call([], b1(r), b1(n));
}
function nF(t) {
  try {
    return decodeURIComponent(t);
  } catch {
    for (var e = t.match(ax) || [], r = 1; r < e.length; r++)
      t = b1(e, r).join(""), e = t.match(ax) || [];
    return t;
  }
}
function iF(t) {
  for (var e = {
    "%FE%FF": "��",
    "%FF%FE": "��"
  }, r = cx.exec(t); r; ) {
    try {
      e[r[0]] = decodeURIComponent(r[0]);
    } catch {
      var n = nF(r[0]);
      n !== r[0] && (e[r[0]] = n);
    }
    r = cx.exec(t);
  }
  e["%C2"] = "�";
  for (var i = Object.keys(e), s = 0; s < i.length; s++) {
    var o = i[s];
    t = t.replace(new RegExp(o, "g"), e[o]);
  }
  return t;
}
var sF = function(t) {
  if (typeof t != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof t + "`");
  try {
    return t = t.replace(/\+/g, " "), decodeURIComponent(t);
  } catch {
    return iF(t);
  }
}, oF = (t, e) => {
  if (!(typeof t == "string" && typeof e == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (e === "")
    return [t];
  const r = t.indexOf(e);
  return r === -1 ? [t] : [
    t.slice(0, r),
    t.slice(r + e.length)
  ];
}, aF = function(t, e) {
  for (var r = {}, n = Object.keys(t), i = Array.isArray(e), s = 0; s < n.length; s++) {
    var o = n[s], a = t[o];
    (i ? e.indexOf(o) !== -1 : e(o, a, t)) && (r[o] = a);
  }
  return r;
};
(function(t) {
  const e = rF, r = sF, n = oF, i = aF, s = ($) => $ == null, o = Symbol("encodeFragmentIdentifier");
  function a($) {
    switch ($.arrayFormat) {
      case "index":
        return (W) => (z, V) => {
          const te = z.length;
          return V === void 0 || $.skipNull && V === null || $.skipEmptyString && V === "" ? z : V === null ? [...z, [d(W, $), "[", te, "]"].join("")] : [
            ...z,
            [d(W, $), "[", d(te, $), "]=", d(V, $)].join("")
          ];
        };
      case "bracket":
        return (W) => (z, V) => V === void 0 || $.skipNull && V === null || $.skipEmptyString && V === "" ? z : V === null ? [...z, [d(W, $), "[]"].join("")] : [...z, [d(W, $), "[]=", d(V, $)].join("")];
      case "colon-list-separator":
        return (W) => (z, V) => V === void 0 || $.skipNull && V === null || $.skipEmptyString && V === "" ? z : V === null ? [...z, [d(W, $), ":list="].join("")] : [...z, [d(W, $), ":list=", d(V, $)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const W = $.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (z) => (V, te) => te === void 0 || $.skipNull && te === null || $.skipEmptyString && te === "" ? V : (te = te === null ? "" : te, V.length === 0 ? [[d(z, $), W, d(te, $)].join("")] : [[V, d(te, $)].join($.arrayFormatSeparator)]);
      }
      default:
        return (W) => (z, V) => V === void 0 || $.skipNull && V === null || $.skipEmptyString && V === "" ? z : V === null ? [...z, d(W, $)] : [...z, [d(W, $), "=", d(V, $)].join("")];
    }
  }
  function u($) {
    let W;
    switch ($.arrayFormat) {
      case "index":
        return (z, V, te) => {
          if (W = /\[(\d*)\]$/.exec(z), z = z.replace(/\[\d*\]$/, ""), !W) {
            te[z] = V;
            return;
          }
          te[z] === void 0 && (te[z] = {}), te[z][W[1]] = V;
        };
      case "bracket":
        return (z, V, te) => {
          if (W = /(\[\])$/.exec(z), z = z.replace(/\[\]$/, ""), !W) {
            te[z] = V;
            return;
          }
          if (te[z] === void 0) {
            te[z] = [V];
            return;
          }
          te[z] = [].concat(te[z], V);
        };
      case "colon-list-separator":
        return (z, V, te) => {
          if (W = /(:list)$/.exec(z), z = z.replace(/:list$/, ""), !W) {
            te[z] = V;
            return;
          }
          if (te[z] === void 0) {
            te[z] = [V];
            return;
          }
          te[z] = [].concat(te[z], V);
        };
      case "comma":
      case "separator":
        return (z, V, te) => {
          const R = typeof V == "string" && V.includes($.arrayFormatSeparator), K = typeof V == "string" && !R && p(V, $).includes($.arrayFormatSeparator);
          V = K ? p(V, $) : V;
          const pe = R || K ? V.split($.arrayFormatSeparator).map((_e) => p(_e, $)) : V === null ? V : p(V, $);
          te[z] = pe;
        };
      case "bracket-separator":
        return (z, V, te) => {
          const R = /(\[\])$/.test(z);
          if (z = z.replace(/\[\]$/, ""), !R) {
            te[z] = V && p(V, $);
            return;
          }
          const K = V === null ? [] : V.split($.arrayFormatSeparator).map((pe) => p(pe, $));
          if (te[z] === void 0) {
            te[z] = K;
            return;
          }
          te[z] = [].concat(te[z], K);
        };
      default:
        return (z, V, te) => {
          if (te[z] === void 0) {
            te[z] = V;
            return;
          }
          te[z] = [].concat(te[z], V);
        };
    }
  }
  function h($) {
    if (typeof $ != "string" || $.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function d($, W) {
    return W.encode ? W.strict ? e($) : encodeURIComponent($) : $;
  }
  function p($, W) {
    return W.decode ? r($) : $;
  }
  function x($) {
    return Array.isArray($) ? $.sort() : typeof $ == "object" ? x(Object.keys($)).sort((W, z) => Number(W) - Number(z)).map((W) => $[W]) : $;
  }
  function A($) {
    const W = $.indexOf("#");
    return W !== -1 && ($ = $.slice(0, W)), $;
  }
  function I($) {
    let W = "";
    const z = $.indexOf("#");
    return z !== -1 && (W = $.slice(z)), W;
  }
  function N($) {
    $ = A($);
    const W = $.indexOf("?");
    return W === -1 ? "" : $.slice(W + 1);
  }
  function L($, W) {
    return W.parseNumbers && !Number.isNaN(Number($)) && typeof $ == "string" && $.trim() !== "" ? $ = Number($) : W.parseBooleans && $ !== null && ($.toLowerCase() === "true" || $.toLowerCase() === "false") && ($ = $.toLowerCase() === "true"), $;
  }
  function F($, W) {
    W = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, W), h(W.arrayFormatSeparator);
    const z = u(W), V = /* @__PURE__ */ Object.create(null);
    if (typeof $ != "string" || ($ = $.trim().replace(/^[?#&]/, ""), !$))
      return V;
    for (const te of $.split("&")) {
      if (te === "")
        continue;
      let [R, K] = n(W.decode ? te.replace(/\+/g, " ") : te, "=");
      K = K === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(W.arrayFormat) ? K : p(K, W), z(p(R, W), K, V);
    }
    for (const te of Object.keys(V)) {
      const R = V[te];
      if (typeof R == "object" && R !== null)
        for (const K of Object.keys(R))
          R[K] = L(R[K], W);
      else
        V[te] = L(R, W);
    }
    return W.sort === !1 ? V : (W.sort === !0 ? Object.keys(V).sort() : Object.keys(V).sort(W.sort)).reduce((te, R) => {
      const K = V[R];
      return K && typeof K == "object" && !Array.isArray(K) ? te[R] = x(K) : te[R] = K, te;
    }, /* @__PURE__ */ Object.create(null));
  }
  t.extract = N, t.parse = F, t.stringify = ($, W) => {
    if (!$)
      return "";
    W = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, W), h(W.arrayFormatSeparator);
    const z = (K) => W.skipNull && s($[K]) || W.skipEmptyString && $[K] === "", V = a(W), te = {};
    for (const K of Object.keys($))
      z(K) || (te[K] = $[K]);
    const R = Object.keys(te);
    return W.sort !== !1 && R.sort(W.sort), R.map((K) => {
      const pe = $[K];
      return pe === void 0 ? "" : pe === null ? d(K, W) : Array.isArray(pe) ? pe.length === 0 && W.arrayFormat === "bracket-separator" ? d(K, W) + "[]" : pe.reduce(V(K), []).join("&") : d(K, W) + "=" + d(pe, W);
    }).filter((K) => K.length > 0).join("&");
  }, t.parseUrl = ($, W) => {
    W = Object.assign({
      decode: !0
    }, W);
    const [z, V] = n($, "#");
    return Object.assign(
      {
        url: z.split("?")[0] || "",
        query: F(N($), W)
      },
      W && W.parseFragmentIdentifier && V ? { fragmentIdentifier: p(V, W) } : {}
    );
  }, t.stringifyUrl = ($, W) => {
    W = Object.assign({
      encode: !0,
      strict: !0,
      [o]: !0
    }, W);
    const z = A($.url).split("?")[0] || "", V = t.extract($.url), te = t.parse(V, { sort: !1 }), R = Object.assign(te, $.query);
    let K = t.stringify(R, W);
    K && (K = `?${K}`);
    let pe = I($.url);
    return $.fragmentIdentifier && (pe = `#${W[o] ? d($.fragmentIdentifier, W) : $.fragmentIdentifier}`), `${z}${K}${pe}`;
  }, t.pick = ($, W, z) => {
    z = Object.assign({
      parseFragmentIdentifier: !0,
      [o]: !1
    }, z);
    const { url: V, query: te, fragmentIdentifier: R } = t.parseUrl($, z);
    return t.stringifyUrl({
      url: V,
      query: i(te, W),
      fragmentIdentifier: R
    }, z);
  }, t.exclude = ($, W, z) => {
    const V = Array.isArray(W) ? (te) => !W.includes(te) : (te, R) => !W(te, R);
    return t.pick($, V, z);
  };
})(yl);
var z4 = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(t) {
  (function() {
    var e = "input is invalid type", r = "finalize already called", n = typeof window == "object", i = n ? window : {};
    i.JS_SHA3_NO_WINDOW && (n = !1);
    var s = !n && typeof self == "object", o = !i.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    o ? i = gn : s && (i = self);
    var a = !i.JS_SHA3_NO_COMMON_JS && !0 && t.exports, u = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", h = "0123456789abcdef".split(""), d = [31, 7936, 2031616, 520093696], p = [4, 1024, 262144, 67108864], x = [1, 256, 65536, 16777216], A = [6, 1536, 393216, 100663296], I = [0, 8, 16, 24], N = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ], L = [224, 256, 384, 512], F = [128, 256], $ = ["hex", "buffer", "arrayBuffer", "array", "digest"], W = {
      128: 168,
      256: 136
    };
    (i.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(D) {
      return Object.prototype.toString.call(D) === "[object Array]";
    }), u && (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(D) {
      return typeof D == "object" && D.buffer && D.buffer.constructor === ArrayBuffer;
    });
    for (var z = function(D, oe, Z) {
      return function(J) {
        return new P(D, oe, D).update(J)[Z]();
      };
    }, V = function(D, oe, Z) {
      return function(J, Q) {
        return new P(D, oe, Q).update(J)[Z]();
      };
    }, te = function(D, oe, Z) {
      return function(J, Q, T, X) {
        return f["cshake" + D].update(J, Q, T, X)[Z]();
      };
    }, R = function(D, oe, Z) {
      return function(J, Q, T, X) {
        return f["kmac" + D].update(J, Q, T, X)[Z]();
      };
    }, K = function(D, oe, Z, J) {
      for (var Q = 0; Q < $.length; ++Q) {
        var T = $[Q];
        D[T] = oe(Z, J, T);
      }
      return D;
    }, pe = function(D, oe) {
      var Z = z(D, oe, "hex");
      return Z.create = function() {
        return new P(D, oe, D);
      }, Z.update = function(J) {
        return Z.create().update(J);
      }, K(Z, z, D, oe);
    }, _e = function(D, oe) {
      var Z = V(D, oe, "hex");
      return Z.create = function(J) {
        return new P(D, oe, J);
      }, Z.update = function(J, Q) {
        return Z.create(Q).update(J);
      }, K(Z, V, D, oe);
    }, Y = function(D, oe) {
      var Z = W[D], J = te(D, oe, "hex");
      return J.create = function(Q, T, X) {
        return !T && !X ? f["shake" + D].create(Q) : new P(D, oe, Q).bytepad([T, X], Z);
      }, J.update = function(Q, T, X, re) {
        return J.create(T, X, re).update(Q);
      }, K(J, te, D, oe);
    }, S = function(D, oe) {
      var Z = W[D], J = R(D, oe, "hex");
      return J.create = function(Q, T, X) {
        return new B(D, oe, T).bytepad(["KMAC", X], Z).bytepad([Q], Z);
      }, J.update = function(Q, T, X, re) {
        return J.create(Q, X, re).update(T);
      }, K(J, R, D, oe);
    }, m = [
      { name: "keccak", padding: x, bits: L, createMethod: pe },
      { name: "sha3", padding: A, bits: L, createMethod: pe },
      { name: "shake", padding: d, bits: F, createMethod: _e },
      { name: "cshake", padding: p, bits: F, createMethod: Y },
      { name: "kmac", padding: p, bits: F, createMethod: S }
    ], f = {}, g = [], b = 0; b < m.length; ++b)
      for (var w = m[b], _ = w.bits, E = 0; E < _.length; ++E) {
        var v = w.name + "_" + _[E];
        if (g.push(v), f[v] = w.createMethod(_[E], w.padding), w.name !== "sha3") {
          var M = w.name + _[E];
          g.push(M), f[M] = f[v];
        }
      }
    function P(D, oe, Z) {
      this.blocks = [], this.s = [], this.padding = oe, this.outputBits = Z, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (D << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = Z >> 5, this.extraBytes = (Z & 31) >> 3;
      for (var J = 0; J < 50; ++J)
        this.s[J] = 0;
    }
    P.prototype.update = function(D) {
      if (this.finalized)
        throw new Error(r);
      var oe, Z = typeof D;
      if (Z !== "string") {
        if (Z === "object") {
          if (D === null)
            throw new Error(e);
          if (u && D.constructor === ArrayBuffer)
            D = new Uint8Array(D);
          else if (!Array.isArray(D) && (!u || !ArrayBuffer.isView(D)))
            throw new Error(e);
        } else
          throw new Error(e);
        oe = !0;
      }
      for (var J = this.blocks, Q = this.byteCount, T = D.length, X = this.blockCount, re = 0, de = this.s, ie, ce; re < T; ) {
        if (this.reset)
          for (this.reset = !1, J[0] = this.block, ie = 1; ie < X + 1; ++ie)
            J[ie] = 0;
        if (oe)
          for (ie = this.start; re < T && ie < Q; ++re)
            J[ie >> 2] |= D[re] << I[ie++ & 3];
        else
          for (ie = this.start; re < T && ie < Q; ++re)
            ce = D.charCodeAt(re), ce < 128 ? J[ie >> 2] |= ce << I[ie++ & 3] : ce < 2048 ? (J[ie >> 2] |= (192 | ce >> 6) << I[ie++ & 3], J[ie >> 2] |= (128 | ce & 63) << I[ie++ & 3]) : ce < 55296 || ce >= 57344 ? (J[ie >> 2] |= (224 | ce >> 12) << I[ie++ & 3], J[ie >> 2] |= (128 | ce >> 6 & 63) << I[ie++ & 3], J[ie >> 2] |= (128 | ce & 63) << I[ie++ & 3]) : (ce = 65536 + ((ce & 1023) << 10 | D.charCodeAt(++re) & 1023), J[ie >> 2] |= (240 | ce >> 18) << I[ie++ & 3], J[ie >> 2] |= (128 | ce >> 12 & 63) << I[ie++ & 3], J[ie >> 2] |= (128 | ce >> 6 & 63) << I[ie++ & 3], J[ie >> 2] |= (128 | ce & 63) << I[ie++ & 3]);
        if (this.lastByteIndex = ie, ie >= Q) {
          for (this.start = ie - Q, this.block = J[X], ie = 0; ie < X; ++ie)
            de[ie] ^= J[ie];
          ue(de), this.reset = !0;
        } else
          this.start = ie;
      }
      return this;
    }, P.prototype.encode = function(D, oe) {
      var Z = D & 255, J = 1, Q = [Z];
      for (D = D >> 8, Z = D & 255; Z > 0; )
        Q.unshift(Z), D = D >> 8, Z = D & 255, ++J;
      return oe ? Q.push(J) : Q.unshift(J), this.update(Q), Q.length;
    }, P.prototype.encodeString = function(D) {
      var oe, Z = typeof D;
      if (Z !== "string") {
        if (Z === "object") {
          if (D === null)
            throw new Error(e);
          if (u && D.constructor === ArrayBuffer)
            D = new Uint8Array(D);
          else if (!Array.isArray(D) && (!u || !ArrayBuffer.isView(D)))
            throw new Error(e);
        } else
          throw new Error(e);
        oe = !0;
      }
      var J = 0, Q = D.length;
      if (oe)
        J = Q;
      else
        for (var T = 0; T < D.length; ++T) {
          var X = D.charCodeAt(T);
          X < 128 ? J += 1 : X < 2048 ? J += 2 : X < 55296 || X >= 57344 ? J += 3 : (X = 65536 + ((X & 1023) << 10 | D.charCodeAt(++T) & 1023), J += 4);
        }
      return J += this.encode(J * 8), this.update(D), J;
    }, P.prototype.bytepad = function(D, oe) {
      for (var Z = this.encode(oe), J = 0; J < D.length; ++J)
        Z += this.encodeString(D[J]);
      var Q = oe - Z % oe, T = [];
      return T.length = Q, this.update(T), this;
    }, P.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var D = this.blocks, oe = this.lastByteIndex, Z = this.blockCount, J = this.s;
        if (D[oe >> 2] |= this.padding[oe & 3], this.lastByteIndex === this.byteCount)
          for (D[0] = D[Z], oe = 1; oe < Z + 1; ++oe)
            D[oe] = 0;
        for (D[Z - 1] |= 2147483648, oe = 0; oe < Z; ++oe)
          J[oe] ^= D[oe];
        ue(J);
      }
    }, P.prototype.toString = P.prototype.hex = function() {
      this.finalize();
      for (var D = this.blockCount, oe = this.s, Z = this.outputBlocks, J = this.extraBytes, Q = 0, T = 0, X = "", re; T < Z; ) {
        for (Q = 0; Q < D && T < Z; ++Q, ++T)
          re = oe[Q], X += h[re >> 4 & 15] + h[re & 15] + h[re >> 12 & 15] + h[re >> 8 & 15] + h[re >> 20 & 15] + h[re >> 16 & 15] + h[re >> 28 & 15] + h[re >> 24 & 15];
        T % D === 0 && (ue(oe), Q = 0);
      }
      return J && (re = oe[Q], X += h[re >> 4 & 15] + h[re & 15], J > 1 && (X += h[re >> 12 & 15] + h[re >> 8 & 15]), J > 2 && (X += h[re >> 20 & 15] + h[re >> 16 & 15])), X;
    }, P.prototype.arrayBuffer = function() {
      this.finalize();
      var D = this.blockCount, oe = this.s, Z = this.outputBlocks, J = this.extraBytes, Q = 0, T = 0, X = this.outputBits >> 3, re;
      J ? re = new ArrayBuffer(Z + 1 << 2) : re = new ArrayBuffer(X);
      for (var de = new Uint32Array(re); T < Z; ) {
        for (Q = 0; Q < D && T < Z; ++Q, ++T)
          de[T] = oe[Q];
        T % D === 0 && ue(oe);
      }
      return J && (de[Q] = oe[Q], re = re.slice(0, X)), re;
    }, P.prototype.buffer = P.prototype.arrayBuffer, P.prototype.digest = P.prototype.array = function() {
      this.finalize();
      for (var D = this.blockCount, oe = this.s, Z = this.outputBlocks, J = this.extraBytes, Q = 0, T = 0, X = [], re, de; T < Z; ) {
        for (Q = 0; Q < D && T < Z; ++Q, ++T)
          re = T << 2, de = oe[Q], X[re] = de & 255, X[re + 1] = de >> 8 & 255, X[re + 2] = de >> 16 & 255, X[re + 3] = de >> 24 & 255;
        T % D === 0 && ue(oe);
      }
      return J && (re = T << 2, de = oe[Q], X[re] = de & 255, J > 1 && (X[re + 1] = de >> 8 & 255), J > 2 && (X[re + 2] = de >> 16 & 255)), X;
    };
    function B(D, oe, Z) {
      P.call(this, D, oe, Z);
    }
    B.prototype = new P(), B.prototype.finalize = function() {
      return this.encode(this.outputBits, !0), P.prototype.finalize.call(this);
    };
    var ue = function(D) {
      var oe, Z, J, Q, T, X, re, de, ie, ce, me, Pe, De, Ce, $e, Me, Ne, Ke, Le, qe, ze, Ee, Ze, at, ke, Qe, tt, Ye, dt, lt, ct, qt, Yt, Et, Qt, Jt, Dt, kt, Ct, gt, Rt, Nt, vt, $t, Ft, rt, Bt, k, j, H, C, G, U, se, he, xe, Te, Re, nt, Ue, pt, it, et;
      for (J = 0; J < 48; J += 2)
        Q = D[0] ^ D[10] ^ D[20] ^ D[30] ^ D[40], T = D[1] ^ D[11] ^ D[21] ^ D[31] ^ D[41], X = D[2] ^ D[12] ^ D[22] ^ D[32] ^ D[42], re = D[3] ^ D[13] ^ D[23] ^ D[33] ^ D[43], de = D[4] ^ D[14] ^ D[24] ^ D[34] ^ D[44], ie = D[5] ^ D[15] ^ D[25] ^ D[35] ^ D[45], ce = D[6] ^ D[16] ^ D[26] ^ D[36] ^ D[46], me = D[7] ^ D[17] ^ D[27] ^ D[37] ^ D[47], Pe = D[8] ^ D[18] ^ D[28] ^ D[38] ^ D[48], De = D[9] ^ D[19] ^ D[29] ^ D[39] ^ D[49], oe = Pe ^ (X << 1 | re >>> 31), Z = De ^ (re << 1 | X >>> 31), D[0] ^= oe, D[1] ^= Z, D[10] ^= oe, D[11] ^= Z, D[20] ^= oe, D[21] ^= Z, D[30] ^= oe, D[31] ^= Z, D[40] ^= oe, D[41] ^= Z, oe = Q ^ (de << 1 | ie >>> 31), Z = T ^ (ie << 1 | de >>> 31), D[2] ^= oe, D[3] ^= Z, D[12] ^= oe, D[13] ^= Z, D[22] ^= oe, D[23] ^= Z, D[32] ^= oe, D[33] ^= Z, D[42] ^= oe, D[43] ^= Z, oe = X ^ (ce << 1 | me >>> 31), Z = re ^ (me << 1 | ce >>> 31), D[4] ^= oe, D[5] ^= Z, D[14] ^= oe, D[15] ^= Z, D[24] ^= oe, D[25] ^= Z, D[34] ^= oe, D[35] ^= Z, D[44] ^= oe, D[45] ^= Z, oe = de ^ (Pe << 1 | De >>> 31), Z = ie ^ (De << 1 | Pe >>> 31), D[6] ^= oe, D[7] ^= Z, D[16] ^= oe, D[17] ^= Z, D[26] ^= oe, D[27] ^= Z, D[36] ^= oe, D[37] ^= Z, D[46] ^= oe, D[47] ^= Z, oe = ce ^ (Q << 1 | T >>> 31), Z = me ^ (T << 1 | Q >>> 31), D[8] ^= oe, D[9] ^= Z, D[18] ^= oe, D[19] ^= Z, D[28] ^= oe, D[29] ^= Z, D[38] ^= oe, D[39] ^= Z, D[48] ^= oe, D[49] ^= Z, Ce = D[0], $e = D[1], rt = D[11] << 4 | D[10] >>> 28, Bt = D[10] << 4 | D[11] >>> 28, Ye = D[20] << 3 | D[21] >>> 29, dt = D[21] << 3 | D[20] >>> 29, Ue = D[31] << 9 | D[30] >>> 23, pt = D[30] << 9 | D[31] >>> 23, Nt = D[40] << 18 | D[41] >>> 14, vt = D[41] << 18 | D[40] >>> 14, Et = D[2] << 1 | D[3] >>> 31, Qt = D[3] << 1 | D[2] >>> 31, Me = D[13] << 12 | D[12] >>> 20, Ne = D[12] << 12 | D[13] >>> 20, k = D[22] << 10 | D[23] >>> 22, j = D[23] << 10 | D[22] >>> 22, lt = D[33] << 13 | D[32] >>> 19, ct = D[32] << 13 | D[33] >>> 19, it = D[42] << 2 | D[43] >>> 30, et = D[43] << 2 | D[42] >>> 30, se = D[5] << 30 | D[4] >>> 2, he = D[4] << 30 | D[5] >>> 2, Jt = D[14] << 6 | D[15] >>> 26, Dt = D[15] << 6 | D[14] >>> 26, Ke = D[25] << 11 | D[24] >>> 21, Le = D[24] << 11 | D[25] >>> 21, H = D[34] << 15 | D[35] >>> 17, C = D[35] << 15 | D[34] >>> 17, qt = D[45] << 29 | D[44] >>> 3, Yt = D[44] << 29 | D[45] >>> 3, at = D[6] << 28 | D[7] >>> 4, ke = D[7] << 28 | D[6] >>> 4, xe = D[17] << 23 | D[16] >>> 9, Te = D[16] << 23 | D[17] >>> 9, kt = D[26] << 25 | D[27] >>> 7, Ct = D[27] << 25 | D[26] >>> 7, qe = D[36] << 21 | D[37] >>> 11, ze = D[37] << 21 | D[36] >>> 11, G = D[47] << 24 | D[46] >>> 8, U = D[46] << 24 | D[47] >>> 8, $t = D[8] << 27 | D[9] >>> 5, Ft = D[9] << 27 | D[8] >>> 5, Qe = D[18] << 20 | D[19] >>> 12, tt = D[19] << 20 | D[18] >>> 12, Re = D[29] << 7 | D[28] >>> 25, nt = D[28] << 7 | D[29] >>> 25, gt = D[38] << 8 | D[39] >>> 24, Rt = D[39] << 8 | D[38] >>> 24, Ee = D[48] << 14 | D[49] >>> 18, Ze = D[49] << 14 | D[48] >>> 18, D[0] = Ce ^ ~Me & Ke, D[1] = $e ^ ~Ne & Le, D[10] = at ^ ~Qe & Ye, D[11] = ke ^ ~tt & dt, D[20] = Et ^ ~Jt & kt, D[21] = Qt ^ ~Dt & Ct, D[30] = $t ^ ~rt & k, D[31] = Ft ^ ~Bt & j, D[40] = se ^ ~xe & Re, D[41] = he ^ ~Te & nt, D[2] = Me ^ ~Ke & qe, D[3] = Ne ^ ~Le & ze, D[12] = Qe ^ ~Ye & lt, D[13] = tt ^ ~dt & ct, D[22] = Jt ^ ~kt & gt, D[23] = Dt ^ ~Ct & Rt, D[32] = rt ^ ~k & H, D[33] = Bt ^ ~j & C, D[42] = xe ^ ~Re & Ue, D[43] = Te ^ ~nt & pt, D[4] = Ke ^ ~qe & Ee, D[5] = Le ^ ~ze & Ze, D[14] = Ye ^ ~lt & qt, D[15] = dt ^ ~ct & Yt, D[24] = kt ^ ~gt & Nt, D[25] = Ct ^ ~Rt & vt, D[34] = k ^ ~H & G, D[35] = j ^ ~C & U, D[44] = Re ^ ~Ue & it, D[45] = nt ^ ~pt & et, D[6] = qe ^ ~Ee & Ce, D[7] = ze ^ ~Ze & $e, D[16] = lt ^ ~qt & at, D[17] = ct ^ ~Yt & ke, D[26] = gt ^ ~Nt & Et, D[27] = Rt ^ ~vt & Qt, D[36] = H ^ ~G & $t, D[37] = C ^ ~U & Ft, D[46] = Ue ^ ~it & se, D[47] = pt ^ ~et & he, D[8] = Ee ^ ~Ce & Me, D[9] = Ze ^ ~$e & Ne, D[18] = qt ^ ~at & Qe, D[19] = Yt ^ ~ke & tt, D[28] = Nt ^ ~Et & Jt, D[29] = vt ^ ~Qt & Dt, D[38] = G ^ ~$t & rt, D[39] = U ^ ~Ft & Bt, D[48] = it ^ ~se & xe, D[49] = et ^ ~he & Te, D[0] ^= N[J], D[1] ^= N[J + 1];
    };
    if (a)
      t.exports = f;
    else
      for (b = 0; b < g.length; ++b)
        i[g[b]] = f[g[b]];
  })();
})(z4);
var cF = z4.exports;
const uF = /* @__PURE__ */ ts(cF), fF = "logger/5.7.0";
let ux = !1, fx = !1;
const Sd = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let lx = Sd.default, Zg = null;
function lF() {
  try {
    const t = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((e) => {
      try {
        if ("test".normalize(e) !== "test")
          throw new Error("bad normalize");
      } catch {
        t.push(e);
      }
    }), t.length)
      throw new Error("missing " + t.join(", "));
    if ("é".normalize("NFD") !== "é")
      throw new Error("broken implementation");
  } catch (t) {
    return t.message;
  }
  return null;
}
const hx = lF();
var y1;
(function(t) {
  t.DEBUG = "DEBUG", t.INFO = "INFO", t.WARNING = "WARNING", t.ERROR = "ERROR", t.OFF = "OFF";
})(y1 || (y1 = {}));
var ys;
(function(t) {
  t.UNKNOWN_ERROR = "UNKNOWN_ERROR", t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", t.NETWORK_ERROR = "NETWORK_ERROR", t.SERVER_ERROR = "SERVER_ERROR", t.TIMEOUT = "TIMEOUT", t.BUFFER_OVERRUN = "BUFFER_OVERRUN", t.NUMERIC_FAULT = "NUMERIC_FAULT", t.MISSING_NEW = "MISSING_NEW", t.INVALID_ARGUMENT = "INVALID_ARGUMENT", t.MISSING_ARGUMENT = "MISSING_ARGUMENT", t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", t.CALL_EXCEPTION = "CALL_EXCEPTION", t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", t.NONCE_EXPIRED = "NONCE_EXPIRED", t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", t.ACTION_REJECTED = "ACTION_REJECTED";
})(ys || (ys = {}));
const dx = "0123456789abcdef";
class Yr {
  constructor(e) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: e,
      writable: !1
    });
  }
  _log(e, r) {
    const n = e.toLowerCase();
    Sd[n] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(lx > Sd[n]) && console.log.apply(console, r);
  }
  debug(...e) {
    this._log(Yr.levels.DEBUG, e);
  }
  info(...e) {
    this._log(Yr.levels.INFO, e);
  }
  warn(...e) {
    this._log(Yr.levels.WARNING, e);
  }
  makeError(e, r, n) {
    if (fx)
      return this.makeError("censored error", r, {});
    r || (r = Yr.errors.UNKNOWN_ERROR), n || (n = {});
    const i = [];
    Object.keys(n).forEach((u) => {
      const h = n[u];
      try {
        if (h instanceof Uint8Array) {
          let d = "";
          for (let p = 0; p < h.length; p++)
            d += dx[h[p] >> 4], d += dx[h[p] & 15];
          i.push(u + "=Uint8Array(0x" + d + ")");
        } else
          i.push(u + "=" + JSON.stringify(h));
      } catch {
        i.push(u + "=" + JSON.stringify(n[u].toString()));
      }
    }), i.push(`code=${r}`), i.push(`version=${this.version}`);
    const s = e;
    let o = "";
    switch (r) {
      case ys.NUMERIC_FAULT: {
        o = "NUMERIC_FAULT";
        const u = e;
        switch (u) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            o += "-" + u;
            break;
          case "negative-power":
          case "negative-width":
            o += "-unsupported";
            break;
          case "unbound-bitwise-result":
            o += "-unbound-result";
            break;
        }
        break;
      }
      case ys.CALL_EXCEPTION:
      case ys.INSUFFICIENT_FUNDS:
      case ys.MISSING_NEW:
      case ys.NONCE_EXPIRED:
      case ys.REPLACEMENT_UNDERPRICED:
      case ys.TRANSACTION_REPLACED:
      case ys.UNPREDICTABLE_GAS_LIMIT:
        o = r;
        break;
    }
    o && (e += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), i.length && (e += " (" + i.join(", ") + ")");
    const a = new Error(e);
    return a.reason = s, a.code = r, Object.keys(n).forEach(function(u) {
      a[u] = n[u];
    }), a;
  }
  throwError(e, r, n) {
    throw this.makeError(e, r, n);
  }
  throwArgumentError(e, r, n) {
    return this.throwError(e, Yr.errors.INVALID_ARGUMENT, {
      argument: r,
      value: n
    });
  }
  assert(e, r, n, i) {
    e || this.throwError(r, n, i);
  }
  assertArgument(e, r, n, i) {
    e || this.throwArgumentError(r, n, i);
  }
  checkNormalize(e) {
    hx && this.throwError("platform missing String.prototype.normalize", Yr.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: hx
    });
  }
  checkSafeUint53(e, r) {
    typeof e == "number" && (r == null && (r = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(r, Yr.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: e
    }), e % 1 && this.throwError(r, Yr.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: e
    }));
  }
  checkArgumentCount(e, r, n) {
    n ? n = ": " + n : n = "", e < r && this.throwError("missing argument" + n, Yr.errors.MISSING_ARGUMENT, {
      count: e,
      expectedCount: r
    }), e > r && this.throwError("too many arguments" + n, Yr.errors.UNEXPECTED_ARGUMENT, {
      count: e,
      expectedCount: r
    });
  }
  checkNew(e, r) {
    (e === Object || e == null) && this.throwError("missing new", Yr.errors.MISSING_NEW, { name: r.name });
  }
  checkAbstract(e, r) {
    e === r ? this.throwError("cannot instantiate abstract class " + JSON.stringify(r.name) + " directly; use a sub-class", Yr.errors.UNSUPPORTED_OPERATION, { name: e.name, operation: "new" }) : (e === Object || e == null) && this.throwError("missing new", Yr.errors.MISSING_NEW, { name: r.name });
  }
  static globalLogger() {
    return Zg || (Zg = new Yr(fF)), Zg;
  }
  static setCensorship(e, r) {
    if (!e && r && this.globalLogger().throwError("cannot permanently disable censorship", Yr.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), ux) {
      if (!e)
        return;
      this.globalLogger().throwError("error censorship permanent", Yr.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    fx = !!e, ux = !!r;
  }
  static setLogLevel(e) {
    const r = Sd[e.toLowerCase()];
    if (r == null) {
      Yr.globalLogger().warn("invalid log level - " + e);
      return;
    }
    lx = r;
  }
  static from(e) {
    return new Yr(e);
  }
}
Yr.errors = ys;
Yr.levels = y1;
const hF = "bytes/5.7.0", hn = new Yr(hF);
function H4(t) {
  return !!t.toHexString;
}
function cu(t) {
  return t.slice || (t.slice = function() {
    const e = Array.prototype.slice.call(arguments);
    return cu(new Uint8Array(Array.prototype.slice.apply(t, e)));
  }), t;
}
function dF(t) {
  return js(t) && !(t.length % 2) || Uv(t);
}
function px(t) {
  return typeof t == "number" && t == t && t % 1 === 0;
}
function Uv(t) {
  if (t == null)
    return !1;
  if (t.constructor === Uint8Array)
    return !0;
  if (typeof t == "string" || !px(t.length) || t.length < 0)
    return !1;
  for (let e = 0; e < t.length; e++) {
    const r = t[e];
    if (!px(r) || r < 0 || r >= 256)
      return !1;
  }
  return !0;
}
function wn(t, e) {
  if (e || (e = {}), typeof t == "number") {
    hn.checkSafeUint53(t, "invalid arrayify value");
    const r = [];
    for (; t; )
      r.unshift(t & 255), t = parseInt(String(t / 256));
    return r.length === 0 && r.push(0), cu(new Uint8Array(r));
  }
  if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), H4(t) && (t = t.toHexString()), js(t)) {
    let r = t.substring(2);
    r.length % 2 && (e.hexPad === "left" ? r = "0" + r : e.hexPad === "right" ? r += "0" : hn.throwArgumentError("hex data is odd-length", "value", t));
    const n = [];
    for (let i = 0; i < r.length; i += 2)
      n.push(parseInt(r.substring(i, i + 2), 16));
    return cu(new Uint8Array(n));
  }
  return Uv(t) ? cu(new Uint8Array(t)) : hn.throwArgumentError("invalid arrayify value", "value", t);
}
function pF(t) {
  const e = t.map((i) => wn(i)), r = e.reduce((i, s) => i + s.length, 0), n = new Uint8Array(r);
  return e.reduce((i, s) => (n.set(s, i), i + s.length), 0), cu(n);
}
function gF(t, e) {
  t = wn(t), t.length > e && hn.throwArgumentError("value out of range", "value", arguments[0]);
  const r = new Uint8Array(e);
  return r.set(t, e - t.length), cu(r);
}
function js(t, e) {
  return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e);
}
const Qg = "0123456789abcdef";
function Ti(t, e) {
  if (e || (e = {}), typeof t == "number") {
    hn.checkSafeUint53(t, "invalid hexlify value");
    let r = "";
    for (; t; )
      r = Qg[t & 15] + r, t = Math.floor(t / 16);
    return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00";
  }
  if (typeof t == "bigint")
    return t = t.toString(16), t.length % 2 ? "0x0" + t : "0x" + t;
  if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), H4(t))
    return t.toHexString();
  if (js(t))
    return t.length % 2 && (e.hexPad === "left" ? t = "0x0" + t.substring(2) : e.hexPad === "right" ? t += "0" : hn.throwArgumentError("hex data is odd-length", "value", t)), t.toLowerCase();
  if (Uv(t)) {
    let r = "0x";
    for (let n = 0; n < t.length; n++) {
      let i = t[n];
      r += Qg[(i & 240) >> 4] + Qg[i & 15];
    }
    return r;
  }
  return hn.throwArgumentError("invalid hexlify value", "value", t);
}
function mF(t) {
  if (typeof t != "string")
    t = Ti(t);
  else if (!js(t) || t.length % 2)
    return null;
  return (t.length - 2) / 2;
}
function gx(t, e, r) {
  return typeof t != "string" ? t = Ti(t) : (!js(t) || t.length % 2) && hn.throwArgumentError("invalid hexData", "value", t), e = 2 + 2 * e, "0x" + t.substring(e);
}
function uu(t, e) {
  for (typeof t != "string" ? t = Ti(t) : js(t) || hn.throwArgumentError("invalid hex string", "value", t), t.length > 2 * e + 2 && hn.throwArgumentError("value out of range", "value", arguments[1]); t.length < 2 * e + 2; )
    t = "0x0" + t.substring(2);
  return t;
}
function W4(t) {
  const e = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (dF(t)) {
    let r = wn(t);
    r.length === 64 ? (e.v = 27 + (r[32] >> 7), r[32] &= 127, e.r = Ti(r.slice(0, 32)), e.s = Ti(r.slice(32, 64))) : r.length === 65 ? (e.r = Ti(r.slice(0, 32)), e.s = Ti(r.slice(32, 64)), e.v = r[64]) : hn.throwArgumentError("invalid signature string", "signature", t), e.v < 27 && (e.v === 0 || e.v === 1 ? e.v += 27 : hn.throwArgumentError("signature invalid v byte", "signature", t)), e.recoveryParam = 1 - e.v % 2, e.recoveryParam && (r[32] |= 128), e._vs = Ti(r.slice(32, 64));
  } else {
    if (e.r = t.r, e.s = t.s, e.v = t.v, e.recoveryParam = t.recoveryParam, e._vs = t._vs, e._vs != null) {
      const i = gF(wn(e._vs), 32);
      e._vs = Ti(i);
      const s = i[0] >= 128 ? 1 : 0;
      e.recoveryParam == null ? e.recoveryParam = s : e.recoveryParam !== s && hn.throwArgumentError("signature recoveryParam mismatch _vs", "signature", t), i[0] &= 127;
      const o = Ti(i);
      e.s == null ? e.s = o : e.s !== o && hn.throwArgumentError("signature v mismatch _vs", "signature", t);
    }
    if (e.recoveryParam == null)
      e.v == null ? hn.throwArgumentError("signature missing v and recoveryParam", "signature", t) : e.v === 0 || e.v === 1 ? e.recoveryParam = e.v : e.recoveryParam = 1 - e.v % 2;
    else if (e.v == null)
      e.v = 27 + e.recoveryParam;
    else {
      const i = e.v === 0 || e.v === 1 ? e.v : 1 - e.v % 2;
      e.recoveryParam !== i && hn.throwArgumentError("signature recoveryParam mismatch v", "signature", t);
    }
    e.r == null || !js(e.r) ? hn.throwArgumentError("signature missing or invalid r", "signature", t) : e.r = uu(e.r, 32), e.s == null || !js(e.s) ? hn.throwArgumentError("signature missing or invalid s", "signature", t) : e.s = uu(e.s, 32);
    const r = wn(e.s);
    r[0] >= 128 && hn.throwArgumentError("signature s out of range", "signature", t), e.recoveryParam && (r[0] |= 128);
    const n = Ti(r);
    e._vs && (js(e._vs) || hn.throwArgumentError("signature invalid _vs", "signature", t), e._vs = uu(e._vs, 32)), e._vs == null ? e._vs = n : e._vs !== n && hn.throwArgumentError("signature _vs mismatch v and s", "signature", t);
  }
  return e.yParityAndS = e._vs, e.compact = e.r + e.yParityAndS.substring(2), e;
}
function jv(t) {
  return "0x" + uF.keccak_256(wn(t));
}
var qv = { exports: {} };
qv.exports;
(function(t) {
  (function(e, r) {
    function n(m, f) {
      if (!m) throw new Error(f || "Assertion failed");
    }
    function i(m, f) {
      m.super_ = f;
      var g = function() {
      };
      g.prototype = f.prototype, m.prototype = new g(), m.prototype.constructor = m;
    }
    function s(m, f, g) {
      if (s.isBN(m))
        return m;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, m !== null && ((f === "le" || f === "be") && (g = f, f = 10), this._init(m || 0, f || 10, g || "be"));
    }
    typeof e == "object" ? e.exports = s : r.BN = s, s.BN = s, s.wordSize = 26;
    var o;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = zl.Buffer;
    } catch {
    }
    s.isBN = function(f) {
      return f instanceof s ? !0 : f !== null && typeof f == "object" && f.constructor.wordSize === s.wordSize && Array.isArray(f.words);
    }, s.max = function(f, g) {
      return f.cmp(g) > 0 ? f : g;
    }, s.min = function(f, g) {
      return f.cmp(g) < 0 ? f : g;
    }, s.prototype._init = function(f, g, b) {
      if (typeof f == "number")
        return this._initNumber(f, g, b);
      if (typeof f == "object")
        return this._initArray(f, g, b);
      g === "hex" && (g = 16), n(g === (g | 0) && g >= 2 && g <= 36), f = f.toString().replace(/\s+/g, "");
      var w = 0;
      f[0] === "-" && (w++, this.negative = 1), w < f.length && (g === 16 ? this._parseHex(f, w, b) : (this._parseBase(f, g, w), b === "le" && this._initArray(this.toArray(), g, b)));
    }, s.prototype._initNumber = function(f, g, b) {
      f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [f & 67108863], this.length = 1) : f < 4503599627370496 ? (this.words = [
        f & 67108863,
        f / 67108864 & 67108863
      ], this.length = 2) : (n(f < 9007199254740992), this.words = [
        f & 67108863,
        f / 67108864 & 67108863,
        1
      ], this.length = 3), b === "le" && this._initArray(this.toArray(), g, b);
    }, s.prototype._initArray = function(f, g, b) {
      if (n(typeof f.length == "number"), f.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
      for (var w = 0; w < this.length; w++)
        this.words[w] = 0;
      var _, E, v = 0;
      if (b === "be")
        for (w = f.length - 1, _ = 0; w >= 0; w -= 3)
          E = f[w] | f[w - 1] << 8 | f[w - 2] << 16, this.words[_] |= E << v & 67108863, this.words[_ + 1] = E >>> 26 - v & 67108863, v += 24, v >= 26 && (v -= 26, _++);
      else if (b === "le")
        for (w = 0, _ = 0; w < f.length; w += 3)
          E = f[w] | f[w + 1] << 8 | f[w + 2] << 16, this.words[_] |= E << v & 67108863, this.words[_ + 1] = E >>> 26 - v & 67108863, v += 24, v >= 26 && (v -= 26, _++);
      return this._strip();
    };
    function a(m, f) {
      var g = m.charCodeAt(f);
      if (g >= 48 && g <= 57)
        return g - 48;
      if (g >= 65 && g <= 70)
        return g - 55;
      if (g >= 97 && g <= 102)
        return g - 87;
      n(!1, "Invalid character in " + m);
    }
    function u(m, f, g) {
      var b = a(m, g);
      return g - 1 >= f && (b |= a(m, g - 1) << 4), b;
    }
    s.prototype._parseHex = function(f, g, b) {
      this.length = Math.ceil((f.length - g) / 6), this.words = new Array(this.length);
      for (var w = 0; w < this.length; w++)
        this.words[w] = 0;
      var _ = 0, E = 0, v;
      if (b === "be")
        for (w = f.length - 1; w >= g; w -= 2)
          v = u(f, g, w) << _, this.words[E] |= v & 67108863, _ >= 18 ? (_ -= 18, E += 1, this.words[E] |= v >>> 26) : _ += 8;
      else {
        var M = f.length - g;
        for (w = M % 2 === 0 ? g + 1 : g; w < f.length; w += 2)
          v = u(f, g, w) << _, this.words[E] |= v & 67108863, _ >= 18 ? (_ -= 18, E += 1, this.words[E] |= v >>> 26) : _ += 8;
      }
      this._strip();
    };
    function h(m, f, g, b) {
      for (var w = 0, _ = 0, E = Math.min(m.length, g), v = f; v < E; v++) {
        var M = m.charCodeAt(v) - 48;
        w *= b, M >= 49 ? _ = M - 49 + 10 : M >= 17 ? _ = M - 17 + 10 : _ = M, n(M >= 0 && _ < b, "Invalid character"), w += _;
      }
      return w;
    }
    s.prototype._parseBase = function(f, g, b) {
      this.words = [0], this.length = 1;
      for (var w = 0, _ = 1; _ <= 67108863; _ *= g)
        w++;
      w--, _ = _ / g | 0;
      for (var E = f.length - b, v = E % w, M = Math.min(E, E - v) + b, P = 0, B = b; B < M; B += w)
        P = h(f, B, B + w, g), this.imuln(_), this.words[0] + P < 67108864 ? this.words[0] += P : this._iaddn(P);
      if (v !== 0) {
        var ue = 1;
        for (P = h(f, B, f.length, g), B = 0; B < v; B++)
          ue *= g;
        this.imuln(ue), this.words[0] + P < 67108864 ? this.words[0] += P : this._iaddn(P);
      }
      this._strip();
    }, s.prototype.copy = function(f) {
      f.words = new Array(this.length);
      for (var g = 0; g < this.length; g++)
        f.words[g] = this.words[g];
      f.length = this.length, f.negative = this.negative, f.red = this.red;
    };
    function d(m, f) {
      m.words = f.words, m.length = f.length, m.negative = f.negative, m.red = f.red;
    }
    if (s.prototype._move = function(f) {
      d(f, this);
    }, s.prototype.clone = function() {
      var f = new s(null);
      return this.copy(f), f;
    }, s.prototype._expand = function(f) {
      for (; this.length < f; )
        this.words[this.length++] = 0;
      return this;
    }, s.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, s.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        s.prototype[Symbol.for("nodejs.util.inspect.custom")] = p;
      } catch {
        s.prototype.inspect = p;
      }
    else
      s.prototype.inspect = p;
    function p() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var x = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], A = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], I = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    s.prototype.toString = function(f, g) {
      f = f || 10, g = g | 0 || 1;
      var b;
      if (f === 16 || f === "hex") {
        b = "";
        for (var w = 0, _ = 0, E = 0; E < this.length; E++) {
          var v = this.words[E], M = ((v << w | _) & 16777215).toString(16);
          _ = v >>> 24 - w & 16777215, w += 2, w >= 26 && (w -= 26, E--), _ !== 0 || E !== this.length - 1 ? b = x[6 - M.length] + M + b : b = M + b;
        }
        for (_ !== 0 && (b = _.toString(16) + b); b.length % g !== 0; )
          b = "0" + b;
        return this.negative !== 0 && (b = "-" + b), b;
      }
      if (f === (f | 0) && f >= 2 && f <= 36) {
        var P = A[f], B = I[f];
        b = "";
        var ue = this.clone();
        for (ue.negative = 0; !ue.isZero(); ) {
          var D = ue.modrn(B).toString(f);
          ue = ue.idivn(B), ue.isZero() ? b = D + b : b = x[P - D.length] + D + b;
        }
        for (this.isZero() && (b = "0" + b); b.length % g !== 0; )
          b = "0" + b;
        return this.negative !== 0 && (b = "-" + b), b;
      }
      n(!1, "Base should be between 2 and 36");
    }, s.prototype.toNumber = function() {
      var f = this.words[0];
      return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f : f;
    }, s.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, o && (s.prototype.toBuffer = function(f, g) {
      return this.toArrayLike(o, f, g);
    }), s.prototype.toArray = function(f, g) {
      return this.toArrayLike(Array, f, g);
    };
    var N = function(f, g) {
      return f.allocUnsafe ? f.allocUnsafe(g) : new f(g);
    };
    s.prototype.toArrayLike = function(f, g, b) {
      this._strip();
      var w = this.byteLength(), _ = b || Math.max(1, w);
      n(w <= _, "byte array longer than desired length"), n(_ > 0, "Requested array length <= 0");
      var E = N(f, _), v = g === "le" ? "LE" : "BE";
      return this["_toArrayLike" + v](E, w), E;
    }, s.prototype._toArrayLikeLE = function(f, g) {
      for (var b = 0, w = 0, _ = 0, E = 0; _ < this.length; _++) {
        var v = this.words[_] << E | w;
        f[b++] = v & 255, b < f.length && (f[b++] = v >> 8 & 255), b < f.length && (f[b++] = v >> 16 & 255), E === 6 ? (b < f.length && (f[b++] = v >> 24 & 255), w = 0, E = 0) : (w = v >>> 24, E += 2);
      }
      if (b < f.length)
        for (f[b++] = w; b < f.length; )
          f[b++] = 0;
    }, s.prototype._toArrayLikeBE = function(f, g) {
      for (var b = f.length - 1, w = 0, _ = 0, E = 0; _ < this.length; _++) {
        var v = this.words[_] << E | w;
        f[b--] = v & 255, b >= 0 && (f[b--] = v >> 8 & 255), b >= 0 && (f[b--] = v >> 16 & 255), E === 6 ? (b >= 0 && (f[b--] = v >> 24 & 255), w = 0, E = 0) : (w = v >>> 24, E += 2);
      }
      if (b >= 0)
        for (f[b--] = w; b >= 0; )
          f[b--] = 0;
    }, Math.clz32 ? s.prototype._countBits = function(f) {
      return 32 - Math.clz32(f);
    } : s.prototype._countBits = function(f) {
      var g = f, b = 0;
      return g >= 4096 && (b += 13, g >>>= 13), g >= 64 && (b += 7, g >>>= 7), g >= 8 && (b += 4, g >>>= 4), g >= 2 && (b += 2, g >>>= 2), b + g;
    }, s.prototype._zeroBits = function(f) {
      if (f === 0) return 26;
      var g = f, b = 0;
      return g & 8191 || (b += 13, g >>>= 13), g & 127 || (b += 7, g >>>= 7), g & 15 || (b += 4, g >>>= 4), g & 3 || (b += 2, g >>>= 2), g & 1 || b++, b;
    }, s.prototype.bitLength = function() {
      var f = this.words[this.length - 1], g = this._countBits(f);
      return (this.length - 1) * 26 + g;
    };
    function L(m) {
      for (var f = new Array(m.bitLength()), g = 0; g < f.length; g++) {
        var b = g / 26 | 0, w = g % 26;
        f[g] = m.words[b] >>> w & 1;
      }
      return f;
    }
    s.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var f = 0, g = 0; g < this.length; g++) {
        var b = this._zeroBits(this.words[g]);
        if (f += b, b !== 26) break;
      }
      return f;
    }, s.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, s.prototype.toTwos = function(f) {
      return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone();
    }, s.prototype.fromTwos = function(f) {
      return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone();
    }, s.prototype.isNeg = function() {
      return this.negative !== 0;
    }, s.prototype.neg = function() {
      return this.clone().ineg();
    }, s.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, s.prototype.iuor = function(f) {
      for (; this.length < f.length; )
        this.words[this.length++] = 0;
      for (var g = 0; g < f.length; g++)
        this.words[g] = this.words[g] | f.words[g];
      return this._strip();
    }, s.prototype.ior = function(f) {
      return n((this.negative | f.negative) === 0), this.iuor(f);
    }, s.prototype.or = function(f) {
      return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this);
    }, s.prototype.uor = function(f) {
      return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this);
    }, s.prototype.iuand = function(f) {
      var g;
      this.length > f.length ? g = f : g = this;
      for (var b = 0; b < g.length; b++)
        this.words[b] = this.words[b] & f.words[b];
      return this.length = g.length, this._strip();
    }, s.prototype.iand = function(f) {
      return n((this.negative | f.negative) === 0), this.iuand(f);
    }, s.prototype.and = function(f) {
      return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this);
    }, s.prototype.uand = function(f) {
      return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this);
    }, s.prototype.iuxor = function(f) {
      var g, b;
      this.length > f.length ? (g = this, b = f) : (g = f, b = this);
      for (var w = 0; w < b.length; w++)
        this.words[w] = g.words[w] ^ b.words[w];
      if (this !== g)
        for (; w < g.length; w++)
          this.words[w] = g.words[w];
      return this.length = g.length, this._strip();
    }, s.prototype.ixor = function(f) {
      return n((this.negative | f.negative) === 0), this.iuxor(f);
    }, s.prototype.xor = function(f) {
      return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this);
    }, s.prototype.uxor = function(f) {
      return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this);
    }, s.prototype.inotn = function(f) {
      n(typeof f == "number" && f >= 0);
      var g = Math.ceil(f / 26) | 0, b = f % 26;
      this._expand(g), b > 0 && g--;
      for (var w = 0; w < g; w++)
        this.words[w] = ~this.words[w] & 67108863;
      return b > 0 && (this.words[w] = ~this.words[w] & 67108863 >> 26 - b), this._strip();
    }, s.prototype.notn = function(f) {
      return this.clone().inotn(f);
    }, s.prototype.setn = function(f, g) {
      n(typeof f == "number" && f >= 0);
      var b = f / 26 | 0, w = f % 26;
      return this._expand(b + 1), g ? this.words[b] = this.words[b] | 1 << w : this.words[b] = this.words[b] & ~(1 << w), this._strip();
    }, s.prototype.iadd = function(f) {
      var g;
      if (this.negative !== 0 && f.negative === 0)
        return this.negative = 0, g = this.isub(f), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && f.negative !== 0)
        return f.negative = 0, g = this.isub(f), f.negative = 1, g._normSign();
      var b, w;
      this.length > f.length ? (b = this, w = f) : (b = f, w = this);
      for (var _ = 0, E = 0; E < w.length; E++)
        g = (b.words[E] | 0) + (w.words[E] | 0) + _, this.words[E] = g & 67108863, _ = g >>> 26;
      for (; _ !== 0 && E < b.length; E++)
        g = (b.words[E] | 0) + _, this.words[E] = g & 67108863, _ = g >>> 26;
      if (this.length = b.length, _ !== 0)
        this.words[this.length] = _, this.length++;
      else if (b !== this)
        for (; E < b.length; E++)
          this.words[E] = b.words[E];
      return this;
    }, s.prototype.add = function(f) {
      var g;
      return f.negative !== 0 && this.negative === 0 ? (f.negative = 0, g = this.sub(f), f.negative ^= 1, g) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0, g = f.sub(this), this.negative = 1, g) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this);
    }, s.prototype.isub = function(f) {
      if (f.negative !== 0) {
        f.negative = 0;
        var g = this.iadd(f);
        return f.negative = 1, g._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
      var b = this.cmp(f);
      if (b === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var w, _;
      b > 0 ? (w = this, _ = f) : (w = f, _ = this);
      for (var E = 0, v = 0; v < _.length; v++)
        g = (w.words[v] | 0) - (_.words[v] | 0) + E, E = g >> 26, this.words[v] = g & 67108863;
      for (; E !== 0 && v < w.length; v++)
        g = (w.words[v] | 0) + E, E = g >> 26, this.words[v] = g & 67108863;
      if (E === 0 && v < w.length && w !== this)
        for (; v < w.length; v++)
          this.words[v] = w.words[v];
      return this.length = Math.max(this.length, v), w !== this && (this.negative = 1), this._strip();
    }, s.prototype.sub = function(f) {
      return this.clone().isub(f);
    };
    function F(m, f, g) {
      g.negative = f.negative ^ m.negative;
      var b = m.length + f.length | 0;
      g.length = b, b = b - 1 | 0;
      var w = m.words[0] | 0, _ = f.words[0] | 0, E = w * _, v = E & 67108863, M = E / 67108864 | 0;
      g.words[0] = v;
      for (var P = 1; P < b; P++) {
        for (var B = M >>> 26, ue = M & 67108863, D = Math.min(P, f.length - 1), oe = Math.max(0, P - m.length + 1); oe <= D; oe++) {
          var Z = P - oe | 0;
          w = m.words[Z] | 0, _ = f.words[oe] | 0, E = w * _ + ue, B += E / 67108864 | 0, ue = E & 67108863;
        }
        g.words[P] = ue | 0, M = B | 0;
      }
      return M !== 0 ? g.words[P] = M | 0 : g.length--, g._strip();
    }
    var $ = function(f, g, b) {
      var w = f.words, _ = g.words, E = b.words, v = 0, M, P, B, ue = w[0] | 0, D = ue & 8191, oe = ue >>> 13, Z = w[1] | 0, J = Z & 8191, Q = Z >>> 13, T = w[2] | 0, X = T & 8191, re = T >>> 13, de = w[3] | 0, ie = de & 8191, ce = de >>> 13, me = w[4] | 0, Pe = me & 8191, De = me >>> 13, Ce = w[5] | 0, $e = Ce & 8191, Me = Ce >>> 13, Ne = w[6] | 0, Ke = Ne & 8191, Le = Ne >>> 13, qe = w[7] | 0, ze = qe & 8191, Ee = qe >>> 13, Ze = w[8] | 0, at = Ze & 8191, ke = Ze >>> 13, Qe = w[9] | 0, tt = Qe & 8191, Ye = Qe >>> 13, dt = _[0] | 0, lt = dt & 8191, ct = dt >>> 13, qt = _[1] | 0, Yt = qt & 8191, Et = qt >>> 13, Qt = _[2] | 0, Jt = Qt & 8191, Dt = Qt >>> 13, kt = _[3] | 0, Ct = kt & 8191, gt = kt >>> 13, Rt = _[4] | 0, Nt = Rt & 8191, vt = Rt >>> 13, $t = _[5] | 0, Ft = $t & 8191, rt = $t >>> 13, Bt = _[6] | 0, k = Bt & 8191, j = Bt >>> 13, H = _[7] | 0, C = H & 8191, G = H >>> 13, U = _[8] | 0, se = U & 8191, he = U >>> 13, xe = _[9] | 0, Te = xe & 8191, Re = xe >>> 13;
      b.negative = f.negative ^ g.negative, b.length = 19, M = Math.imul(D, lt), P = Math.imul(D, ct), P = P + Math.imul(oe, lt) | 0, B = Math.imul(oe, ct);
      var nt = (v + M | 0) + ((P & 8191) << 13) | 0;
      v = (B + (P >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, M = Math.imul(J, lt), P = Math.imul(J, ct), P = P + Math.imul(Q, lt) | 0, B = Math.imul(Q, ct), M = M + Math.imul(D, Yt) | 0, P = P + Math.imul(D, Et) | 0, P = P + Math.imul(oe, Yt) | 0, B = B + Math.imul(oe, Et) | 0;
      var Ue = (v + M | 0) + ((P & 8191) << 13) | 0;
      v = (B + (P >>> 13) | 0) + (Ue >>> 26) | 0, Ue &= 67108863, M = Math.imul(X, lt), P = Math.imul(X, ct), P = P + Math.imul(re, lt) | 0, B = Math.imul(re, ct), M = M + Math.imul(J, Yt) | 0, P = P + Math.imul(J, Et) | 0, P = P + Math.imul(Q, Yt) | 0, B = B + Math.imul(Q, Et) | 0, M = M + Math.imul(D, Jt) | 0, P = P + Math.imul(D, Dt) | 0, P = P + Math.imul(oe, Jt) | 0, B = B + Math.imul(oe, Dt) | 0;
      var pt = (v + M | 0) + ((P & 8191) << 13) | 0;
      v = (B + (P >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, M = Math.imul(ie, lt), P = Math.imul(ie, ct), P = P + Math.imul(ce, lt) | 0, B = Math.imul(ce, ct), M = M + Math.imul(X, Yt) | 0, P = P + Math.imul(X, Et) | 0, P = P + Math.imul(re, Yt) | 0, B = B + Math.imul(re, Et) | 0, M = M + Math.imul(J, Jt) | 0, P = P + Math.imul(J, Dt) | 0, P = P + Math.imul(Q, Jt) | 0, B = B + Math.imul(Q, Dt) | 0, M = M + Math.imul(D, Ct) | 0, P = P + Math.imul(D, gt) | 0, P = P + Math.imul(oe, Ct) | 0, B = B + Math.imul(oe, gt) | 0;
      var it = (v + M | 0) + ((P & 8191) << 13) | 0;
      v = (B + (P >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, M = Math.imul(Pe, lt), P = Math.imul(Pe, ct), P = P + Math.imul(De, lt) | 0, B = Math.imul(De, ct), M = M + Math.imul(ie, Yt) | 0, P = P + Math.imul(ie, Et) | 0, P = P + Math.imul(ce, Yt) | 0, B = B + Math.imul(ce, Et) | 0, M = M + Math.imul(X, Jt) | 0, P = P + Math.imul(X, Dt) | 0, P = P + Math.imul(re, Jt) | 0, B = B + Math.imul(re, Dt) | 0, M = M + Math.imul(J, Ct) | 0, P = P + Math.imul(J, gt) | 0, P = P + Math.imul(Q, Ct) | 0, B = B + Math.imul(Q, gt) | 0, M = M + Math.imul(D, Nt) | 0, P = P + Math.imul(D, vt) | 0, P = P + Math.imul(oe, Nt) | 0, B = B + Math.imul(oe, vt) | 0;
      var et = (v + M | 0) + ((P & 8191) << 13) | 0;
      v = (B + (P >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, M = Math.imul($e, lt), P = Math.imul($e, ct), P = P + Math.imul(Me, lt) | 0, B = Math.imul(Me, ct), M = M + Math.imul(Pe, Yt) | 0, P = P + Math.imul(Pe, Et) | 0, P = P + Math.imul(De, Yt) | 0, B = B + Math.imul(De, Et) | 0, M = M + Math.imul(ie, Jt) | 0, P = P + Math.imul(ie, Dt) | 0, P = P + Math.imul(ce, Jt) | 0, B = B + Math.imul(ce, Dt) | 0, M = M + Math.imul(X, Ct) | 0, P = P + Math.imul(X, gt) | 0, P = P + Math.imul(re, Ct) | 0, B = B + Math.imul(re, gt) | 0, M = M + Math.imul(J, Nt) | 0, P = P + Math.imul(J, vt) | 0, P = P + Math.imul(Q, Nt) | 0, B = B + Math.imul(Q, vt) | 0, M = M + Math.imul(D, Ft) | 0, P = P + Math.imul(D, rt) | 0, P = P + Math.imul(oe, Ft) | 0, B = B + Math.imul(oe, rt) | 0;
      var St = (v + M | 0) + ((P & 8191) << 13) | 0;
      v = (B + (P >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, M = Math.imul(Ke, lt), P = Math.imul(Ke, ct), P = P + Math.imul(Le, lt) | 0, B = Math.imul(Le, ct), M = M + Math.imul($e, Yt) | 0, P = P + Math.imul($e, Et) | 0, P = P + Math.imul(Me, Yt) | 0, B = B + Math.imul(Me, Et) | 0, M = M + Math.imul(Pe, Jt) | 0, P = P + Math.imul(Pe, Dt) | 0, P = P + Math.imul(De, Jt) | 0, B = B + Math.imul(De, Dt) | 0, M = M + Math.imul(ie, Ct) | 0, P = P + Math.imul(ie, gt) | 0, P = P + Math.imul(ce, Ct) | 0, B = B + Math.imul(ce, gt) | 0, M = M + Math.imul(X, Nt) | 0, P = P + Math.imul(X, vt) | 0, P = P + Math.imul(re, Nt) | 0, B = B + Math.imul(re, vt) | 0, M = M + Math.imul(J, Ft) | 0, P = P + Math.imul(J, rt) | 0, P = P + Math.imul(Q, Ft) | 0, B = B + Math.imul(Q, rt) | 0, M = M + Math.imul(D, k) | 0, P = P + Math.imul(D, j) | 0, P = P + Math.imul(oe, k) | 0, B = B + Math.imul(oe, j) | 0;
      var Tt = (v + M | 0) + ((P & 8191) << 13) | 0;
      v = (B + (P >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, M = Math.imul(ze, lt), P = Math.imul(ze, ct), P = P + Math.imul(Ee, lt) | 0, B = Math.imul(Ee, ct), M = M + Math.imul(Ke, Yt) | 0, P = P + Math.imul(Ke, Et) | 0, P = P + Math.imul(Le, Yt) | 0, B = B + Math.imul(Le, Et) | 0, M = M + Math.imul($e, Jt) | 0, P = P + Math.imul($e, Dt) | 0, P = P + Math.imul(Me, Jt) | 0, B = B + Math.imul(Me, Dt) | 0, M = M + Math.imul(Pe, Ct) | 0, P = P + Math.imul(Pe, gt) | 0, P = P + Math.imul(De, Ct) | 0, B = B + Math.imul(De, gt) | 0, M = M + Math.imul(ie, Nt) | 0, P = P + Math.imul(ie, vt) | 0, P = P + Math.imul(ce, Nt) | 0, B = B + Math.imul(ce, vt) | 0, M = M + Math.imul(X, Ft) | 0, P = P + Math.imul(X, rt) | 0, P = P + Math.imul(re, Ft) | 0, B = B + Math.imul(re, rt) | 0, M = M + Math.imul(J, k) | 0, P = P + Math.imul(J, j) | 0, P = P + Math.imul(Q, k) | 0, B = B + Math.imul(Q, j) | 0, M = M + Math.imul(D, C) | 0, P = P + Math.imul(D, G) | 0, P = P + Math.imul(oe, C) | 0, B = B + Math.imul(oe, G) | 0;
      var At = (v + M | 0) + ((P & 8191) << 13) | 0;
      v = (B + (P >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, M = Math.imul(at, lt), P = Math.imul(at, ct), P = P + Math.imul(ke, lt) | 0, B = Math.imul(ke, ct), M = M + Math.imul(ze, Yt) | 0, P = P + Math.imul(ze, Et) | 0, P = P + Math.imul(Ee, Yt) | 0, B = B + Math.imul(Ee, Et) | 0, M = M + Math.imul(Ke, Jt) | 0, P = P + Math.imul(Ke, Dt) | 0, P = P + Math.imul(Le, Jt) | 0, B = B + Math.imul(Le, Dt) | 0, M = M + Math.imul($e, Ct) | 0, P = P + Math.imul($e, gt) | 0, P = P + Math.imul(Me, Ct) | 0, B = B + Math.imul(Me, gt) | 0, M = M + Math.imul(Pe, Nt) | 0, P = P + Math.imul(Pe, vt) | 0, P = P + Math.imul(De, Nt) | 0, B = B + Math.imul(De, vt) | 0, M = M + Math.imul(ie, Ft) | 0, P = P + Math.imul(ie, rt) | 0, P = P + Math.imul(ce, Ft) | 0, B = B + Math.imul(ce, rt) | 0, M = M + Math.imul(X, k) | 0, P = P + Math.imul(X, j) | 0, P = P + Math.imul(re, k) | 0, B = B + Math.imul(re, j) | 0, M = M + Math.imul(J, C) | 0, P = P + Math.imul(J, G) | 0, P = P + Math.imul(Q, C) | 0, B = B + Math.imul(Q, G) | 0, M = M + Math.imul(D, se) | 0, P = P + Math.imul(D, he) | 0, P = P + Math.imul(oe, se) | 0, B = B + Math.imul(oe, he) | 0;
      var _t = (v + M | 0) + ((P & 8191) << 13) | 0;
      v = (B + (P >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, M = Math.imul(tt, lt), P = Math.imul(tt, ct), P = P + Math.imul(Ye, lt) | 0, B = Math.imul(Ye, ct), M = M + Math.imul(at, Yt) | 0, P = P + Math.imul(at, Et) | 0, P = P + Math.imul(ke, Yt) | 0, B = B + Math.imul(ke, Et) | 0, M = M + Math.imul(ze, Jt) | 0, P = P + Math.imul(ze, Dt) | 0, P = P + Math.imul(Ee, Jt) | 0, B = B + Math.imul(Ee, Dt) | 0, M = M + Math.imul(Ke, Ct) | 0, P = P + Math.imul(Ke, gt) | 0, P = P + Math.imul(Le, Ct) | 0, B = B + Math.imul(Le, gt) | 0, M = M + Math.imul($e, Nt) | 0, P = P + Math.imul($e, vt) | 0, P = P + Math.imul(Me, Nt) | 0, B = B + Math.imul(Me, vt) | 0, M = M + Math.imul(Pe, Ft) | 0, P = P + Math.imul(Pe, rt) | 0, P = P + Math.imul(De, Ft) | 0, B = B + Math.imul(De, rt) | 0, M = M + Math.imul(ie, k) | 0, P = P + Math.imul(ie, j) | 0, P = P + Math.imul(ce, k) | 0, B = B + Math.imul(ce, j) | 0, M = M + Math.imul(X, C) | 0, P = P + Math.imul(X, G) | 0, P = P + Math.imul(re, C) | 0, B = B + Math.imul(re, G) | 0, M = M + Math.imul(J, se) | 0, P = P + Math.imul(J, he) | 0, P = P + Math.imul(Q, se) | 0, B = B + Math.imul(Q, he) | 0, M = M + Math.imul(D, Te) | 0, P = P + Math.imul(D, Re) | 0, P = P + Math.imul(oe, Te) | 0, B = B + Math.imul(oe, Re) | 0;
      var ht = (v + M | 0) + ((P & 8191) << 13) | 0;
      v = (B + (P >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, M = Math.imul(tt, Yt), P = Math.imul(tt, Et), P = P + Math.imul(Ye, Yt) | 0, B = Math.imul(Ye, Et), M = M + Math.imul(at, Jt) | 0, P = P + Math.imul(at, Dt) | 0, P = P + Math.imul(ke, Jt) | 0, B = B + Math.imul(ke, Dt) | 0, M = M + Math.imul(ze, Ct) | 0, P = P + Math.imul(ze, gt) | 0, P = P + Math.imul(Ee, Ct) | 0, B = B + Math.imul(Ee, gt) | 0, M = M + Math.imul(Ke, Nt) | 0, P = P + Math.imul(Ke, vt) | 0, P = P + Math.imul(Le, Nt) | 0, B = B + Math.imul(Le, vt) | 0, M = M + Math.imul($e, Ft) | 0, P = P + Math.imul($e, rt) | 0, P = P + Math.imul(Me, Ft) | 0, B = B + Math.imul(Me, rt) | 0, M = M + Math.imul(Pe, k) | 0, P = P + Math.imul(Pe, j) | 0, P = P + Math.imul(De, k) | 0, B = B + Math.imul(De, j) | 0, M = M + Math.imul(ie, C) | 0, P = P + Math.imul(ie, G) | 0, P = P + Math.imul(ce, C) | 0, B = B + Math.imul(ce, G) | 0, M = M + Math.imul(X, se) | 0, P = P + Math.imul(X, he) | 0, P = P + Math.imul(re, se) | 0, B = B + Math.imul(re, he) | 0, M = M + Math.imul(J, Te) | 0, P = P + Math.imul(J, Re) | 0, P = P + Math.imul(Q, Te) | 0, B = B + Math.imul(Q, Re) | 0;
      var xt = (v + M | 0) + ((P & 8191) << 13) | 0;
      v = (B + (P >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, M = Math.imul(tt, Jt), P = Math.imul(tt, Dt), P = P + Math.imul(Ye, Jt) | 0, B = Math.imul(Ye, Dt), M = M + Math.imul(at, Ct) | 0, P = P + Math.imul(at, gt) | 0, P = P + Math.imul(ke, Ct) | 0, B = B + Math.imul(ke, gt) | 0, M = M + Math.imul(ze, Nt) | 0, P = P + Math.imul(ze, vt) | 0, P = P + Math.imul(Ee, Nt) | 0, B = B + Math.imul(Ee, vt) | 0, M = M + Math.imul(Ke, Ft) | 0, P = P + Math.imul(Ke, rt) | 0, P = P + Math.imul(Le, Ft) | 0, B = B + Math.imul(Le, rt) | 0, M = M + Math.imul($e, k) | 0, P = P + Math.imul($e, j) | 0, P = P + Math.imul(Me, k) | 0, B = B + Math.imul(Me, j) | 0, M = M + Math.imul(Pe, C) | 0, P = P + Math.imul(Pe, G) | 0, P = P + Math.imul(De, C) | 0, B = B + Math.imul(De, G) | 0, M = M + Math.imul(ie, se) | 0, P = P + Math.imul(ie, he) | 0, P = P + Math.imul(ce, se) | 0, B = B + Math.imul(ce, he) | 0, M = M + Math.imul(X, Te) | 0, P = P + Math.imul(X, Re) | 0, P = P + Math.imul(re, Te) | 0, B = B + Math.imul(re, Re) | 0;
      var st = (v + M | 0) + ((P & 8191) << 13) | 0;
      v = (B + (P >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, M = Math.imul(tt, Ct), P = Math.imul(tt, gt), P = P + Math.imul(Ye, Ct) | 0, B = Math.imul(Ye, gt), M = M + Math.imul(at, Nt) | 0, P = P + Math.imul(at, vt) | 0, P = P + Math.imul(ke, Nt) | 0, B = B + Math.imul(ke, vt) | 0, M = M + Math.imul(ze, Ft) | 0, P = P + Math.imul(ze, rt) | 0, P = P + Math.imul(Ee, Ft) | 0, B = B + Math.imul(Ee, rt) | 0, M = M + Math.imul(Ke, k) | 0, P = P + Math.imul(Ke, j) | 0, P = P + Math.imul(Le, k) | 0, B = B + Math.imul(Le, j) | 0, M = M + Math.imul($e, C) | 0, P = P + Math.imul($e, G) | 0, P = P + Math.imul(Me, C) | 0, B = B + Math.imul(Me, G) | 0, M = M + Math.imul(Pe, se) | 0, P = P + Math.imul(Pe, he) | 0, P = P + Math.imul(De, se) | 0, B = B + Math.imul(De, he) | 0, M = M + Math.imul(ie, Te) | 0, P = P + Math.imul(ie, Re) | 0, P = P + Math.imul(ce, Te) | 0, B = B + Math.imul(ce, Re) | 0;
      var bt = (v + M | 0) + ((P & 8191) << 13) | 0;
      v = (B + (P >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, M = Math.imul(tt, Nt), P = Math.imul(tt, vt), P = P + Math.imul(Ye, Nt) | 0, B = Math.imul(Ye, vt), M = M + Math.imul(at, Ft) | 0, P = P + Math.imul(at, rt) | 0, P = P + Math.imul(ke, Ft) | 0, B = B + Math.imul(ke, rt) | 0, M = M + Math.imul(ze, k) | 0, P = P + Math.imul(ze, j) | 0, P = P + Math.imul(Ee, k) | 0, B = B + Math.imul(Ee, j) | 0, M = M + Math.imul(Ke, C) | 0, P = P + Math.imul(Ke, G) | 0, P = P + Math.imul(Le, C) | 0, B = B + Math.imul(Le, G) | 0, M = M + Math.imul($e, se) | 0, P = P + Math.imul($e, he) | 0, P = P + Math.imul(Me, se) | 0, B = B + Math.imul(Me, he) | 0, M = M + Math.imul(Pe, Te) | 0, P = P + Math.imul(Pe, Re) | 0, P = P + Math.imul(De, Te) | 0, B = B + Math.imul(De, Re) | 0;
      var ut = (v + M | 0) + ((P & 8191) << 13) | 0;
      v = (B + (P >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, M = Math.imul(tt, Ft), P = Math.imul(tt, rt), P = P + Math.imul(Ye, Ft) | 0, B = Math.imul(Ye, rt), M = M + Math.imul(at, k) | 0, P = P + Math.imul(at, j) | 0, P = P + Math.imul(ke, k) | 0, B = B + Math.imul(ke, j) | 0, M = M + Math.imul(ze, C) | 0, P = P + Math.imul(ze, G) | 0, P = P + Math.imul(Ee, C) | 0, B = B + Math.imul(Ee, G) | 0, M = M + Math.imul(Ke, se) | 0, P = P + Math.imul(Ke, he) | 0, P = P + Math.imul(Le, se) | 0, B = B + Math.imul(Le, he) | 0, M = M + Math.imul($e, Te) | 0, P = P + Math.imul($e, Re) | 0, P = P + Math.imul(Me, Te) | 0, B = B + Math.imul(Me, Re) | 0;
      var ot = (v + M | 0) + ((P & 8191) << 13) | 0;
      v = (B + (P >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, M = Math.imul(tt, k), P = Math.imul(tt, j), P = P + Math.imul(Ye, k) | 0, B = Math.imul(Ye, j), M = M + Math.imul(at, C) | 0, P = P + Math.imul(at, G) | 0, P = P + Math.imul(ke, C) | 0, B = B + Math.imul(ke, G) | 0, M = M + Math.imul(ze, se) | 0, P = P + Math.imul(ze, he) | 0, P = P + Math.imul(Ee, se) | 0, B = B + Math.imul(Ee, he) | 0, M = M + Math.imul(Ke, Te) | 0, P = P + Math.imul(Ke, Re) | 0, P = P + Math.imul(Le, Te) | 0, B = B + Math.imul(Le, Re) | 0;
      var Se = (v + M | 0) + ((P & 8191) << 13) | 0;
      v = (B + (P >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, M = Math.imul(tt, C), P = Math.imul(tt, G), P = P + Math.imul(Ye, C) | 0, B = Math.imul(Ye, G), M = M + Math.imul(at, se) | 0, P = P + Math.imul(at, he) | 0, P = P + Math.imul(ke, se) | 0, B = B + Math.imul(ke, he) | 0, M = M + Math.imul(ze, Te) | 0, P = P + Math.imul(ze, Re) | 0, P = P + Math.imul(Ee, Te) | 0, B = B + Math.imul(Ee, Re) | 0;
      var Ae = (v + M | 0) + ((P & 8191) << 13) | 0;
      v = (B + (P >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, M = Math.imul(tt, se), P = Math.imul(tt, he), P = P + Math.imul(Ye, se) | 0, B = Math.imul(Ye, he), M = M + Math.imul(at, Te) | 0, P = P + Math.imul(at, Re) | 0, P = P + Math.imul(ke, Te) | 0, B = B + Math.imul(ke, Re) | 0;
      var Ve = (v + M | 0) + ((P & 8191) << 13) | 0;
      v = (B + (P >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, M = Math.imul(tt, Te), P = Math.imul(tt, Re), P = P + Math.imul(Ye, Te) | 0, B = Math.imul(Ye, Re);
      var Fe = (v + M | 0) + ((P & 8191) << 13) | 0;
      return v = (B + (P >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, E[0] = nt, E[1] = Ue, E[2] = pt, E[3] = it, E[4] = et, E[5] = St, E[6] = Tt, E[7] = At, E[8] = _t, E[9] = ht, E[10] = xt, E[11] = st, E[12] = bt, E[13] = ut, E[14] = ot, E[15] = Se, E[16] = Ae, E[17] = Ve, E[18] = Fe, v !== 0 && (E[19] = v, b.length++), b;
    };
    Math.imul || ($ = F);
    function W(m, f, g) {
      g.negative = f.negative ^ m.negative, g.length = m.length + f.length;
      for (var b = 0, w = 0, _ = 0; _ < g.length - 1; _++) {
        var E = w;
        w = 0;
        for (var v = b & 67108863, M = Math.min(_, f.length - 1), P = Math.max(0, _ - m.length + 1); P <= M; P++) {
          var B = _ - P, ue = m.words[B] | 0, D = f.words[P] | 0, oe = ue * D, Z = oe & 67108863;
          E = E + (oe / 67108864 | 0) | 0, Z = Z + v | 0, v = Z & 67108863, E = E + (Z >>> 26) | 0, w += E >>> 26, E &= 67108863;
        }
        g.words[_] = v, b = E, E = w;
      }
      return b !== 0 ? g.words[_] = b : g.length--, g._strip();
    }
    function z(m, f, g) {
      return W(m, f, g);
    }
    s.prototype.mulTo = function(f, g) {
      var b, w = this.length + f.length;
      return this.length === 10 && f.length === 10 ? b = $(this, f, g) : w < 63 ? b = F(this, f, g) : w < 1024 ? b = W(this, f, g) : b = z(this, f, g), b;
    }, s.prototype.mul = function(f) {
      var g = new s(null);
      return g.words = new Array(this.length + f.length), this.mulTo(f, g);
    }, s.prototype.mulf = function(f) {
      var g = new s(null);
      return g.words = new Array(this.length + f.length), z(this, f, g);
    }, s.prototype.imul = function(f) {
      return this.clone().mulTo(f, this);
    }, s.prototype.imuln = function(f) {
      var g = f < 0;
      g && (f = -f), n(typeof f == "number"), n(f < 67108864);
      for (var b = 0, w = 0; w < this.length; w++) {
        var _ = (this.words[w] | 0) * f, E = (_ & 67108863) + (b & 67108863);
        b >>= 26, b += _ / 67108864 | 0, b += E >>> 26, this.words[w] = E & 67108863;
      }
      return b !== 0 && (this.words[w] = b, this.length++), g ? this.ineg() : this;
    }, s.prototype.muln = function(f) {
      return this.clone().imuln(f);
    }, s.prototype.sqr = function() {
      return this.mul(this);
    }, s.prototype.isqr = function() {
      return this.imul(this.clone());
    }, s.prototype.pow = function(f) {
      var g = L(f);
      if (g.length === 0) return new s(1);
      for (var b = this, w = 0; w < g.length && g[w] === 0; w++, b = b.sqr())
        ;
      if (++w < g.length)
        for (var _ = b.sqr(); w < g.length; w++, _ = _.sqr())
          g[w] !== 0 && (b = b.mul(_));
      return b;
    }, s.prototype.iushln = function(f) {
      n(typeof f == "number" && f >= 0);
      var g = f % 26, b = (f - g) / 26, w = 67108863 >>> 26 - g << 26 - g, _;
      if (g !== 0) {
        var E = 0;
        for (_ = 0; _ < this.length; _++) {
          var v = this.words[_] & w, M = (this.words[_] | 0) - v << g;
          this.words[_] = M | E, E = v >>> 26 - g;
        }
        E && (this.words[_] = E, this.length++);
      }
      if (b !== 0) {
        for (_ = this.length - 1; _ >= 0; _--)
          this.words[_ + b] = this.words[_];
        for (_ = 0; _ < b; _++)
          this.words[_] = 0;
        this.length += b;
      }
      return this._strip();
    }, s.prototype.ishln = function(f) {
      return n(this.negative === 0), this.iushln(f);
    }, s.prototype.iushrn = function(f, g, b) {
      n(typeof f == "number" && f >= 0);
      var w;
      g ? w = (g - g % 26) / 26 : w = 0;
      var _ = f % 26, E = Math.min((f - _) / 26, this.length), v = 67108863 ^ 67108863 >>> _ << _, M = b;
      if (w -= E, w = Math.max(0, w), M) {
        for (var P = 0; P < E; P++)
          M.words[P] = this.words[P];
        M.length = E;
      }
      if (E !== 0) if (this.length > E)
        for (this.length -= E, P = 0; P < this.length; P++)
          this.words[P] = this.words[P + E];
      else
        this.words[0] = 0, this.length = 1;
      var B = 0;
      for (P = this.length - 1; P >= 0 && (B !== 0 || P >= w); P--) {
        var ue = this.words[P] | 0;
        this.words[P] = B << 26 - _ | ue >>> _, B = ue & v;
      }
      return M && B !== 0 && (M.words[M.length++] = B), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, s.prototype.ishrn = function(f, g, b) {
      return n(this.negative === 0), this.iushrn(f, g, b);
    }, s.prototype.shln = function(f) {
      return this.clone().ishln(f);
    }, s.prototype.ushln = function(f) {
      return this.clone().iushln(f);
    }, s.prototype.shrn = function(f) {
      return this.clone().ishrn(f);
    }, s.prototype.ushrn = function(f) {
      return this.clone().iushrn(f);
    }, s.prototype.testn = function(f) {
      n(typeof f == "number" && f >= 0);
      var g = f % 26, b = (f - g) / 26, w = 1 << g;
      if (this.length <= b) return !1;
      var _ = this.words[b];
      return !!(_ & w);
    }, s.prototype.imaskn = function(f) {
      n(typeof f == "number" && f >= 0);
      var g = f % 26, b = (f - g) / 26;
      if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= b)
        return this;
      if (g !== 0 && b++, this.length = Math.min(b, this.length), g !== 0) {
        var w = 67108863 ^ 67108863 >>> g << g;
        this.words[this.length - 1] &= w;
      }
      return this._strip();
    }, s.prototype.maskn = function(f) {
      return this.clone().imaskn(f);
    }, s.prototype.iaddn = function(f) {
      return n(typeof f == "number"), n(f < 67108864), f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f);
    }, s.prototype._iaddn = function(f) {
      this.words[0] += f;
      for (var g = 0; g < this.length && this.words[g] >= 67108864; g++)
        this.words[g] -= 67108864, g === this.length - 1 ? this.words[g + 1] = 1 : this.words[g + 1]++;
      return this.length = Math.max(this.length, g + 1), this;
    }, s.prototype.isubn = function(f) {
      if (n(typeof f == "number"), n(f < 67108864), f < 0) return this.iaddn(-f);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(f), this.negative = 1, this;
      if (this.words[0] -= f, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var g = 0; g < this.length && this.words[g] < 0; g++)
          this.words[g] += 67108864, this.words[g + 1] -= 1;
      return this._strip();
    }, s.prototype.addn = function(f) {
      return this.clone().iaddn(f);
    }, s.prototype.subn = function(f) {
      return this.clone().isubn(f);
    }, s.prototype.iabs = function() {
      return this.negative = 0, this;
    }, s.prototype.abs = function() {
      return this.clone().iabs();
    }, s.prototype._ishlnsubmul = function(f, g, b) {
      var w = f.length + b, _;
      this._expand(w);
      var E, v = 0;
      for (_ = 0; _ < f.length; _++) {
        E = (this.words[_ + b] | 0) + v;
        var M = (f.words[_] | 0) * g;
        E -= M & 67108863, v = (E >> 26) - (M / 67108864 | 0), this.words[_ + b] = E & 67108863;
      }
      for (; _ < this.length - b; _++)
        E = (this.words[_ + b] | 0) + v, v = E >> 26, this.words[_ + b] = E & 67108863;
      if (v === 0) return this._strip();
      for (n(v === -1), v = 0, _ = 0; _ < this.length; _++)
        E = -(this.words[_] | 0) + v, v = E >> 26, this.words[_] = E & 67108863;
      return this.negative = 1, this._strip();
    }, s.prototype._wordDiv = function(f, g) {
      var b = this.length - f.length, w = this.clone(), _ = f, E = _.words[_.length - 1] | 0, v = this._countBits(E);
      b = 26 - v, b !== 0 && (_ = _.ushln(b), w.iushln(b), E = _.words[_.length - 1] | 0);
      var M = w.length - _.length, P;
      if (g !== "mod") {
        P = new s(null), P.length = M + 1, P.words = new Array(P.length);
        for (var B = 0; B < P.length; B++)
          P.words[B] = 0;
      }
      var ue = w.clone()._ishlnsubmul(_, 1, M);
      ue.negative === 0 && (w = ue, P && (P.words[M] = 1));
      for (var D = M - 1; D >= 0; D--) {
        var oe = (w.words[_.length + D] | 0) * 67108864 + (w.words[_.length + D - 1] | 0);
        for (oe = Math.min(oe / E | 0, 67108863), w._ishlnsubmul(_, oe, D); w.negative !== 0; )
          oe--, w.negative = 0, w._ishlnsubmul(_, 1, D), w.isZero() || (w.negative ^= 1);
        P && (P.words[D] = oe);
      }
      return P && P._strip(), w._strip(), g !== "div" && b !== 0 && w.iushrn(b), {
        div: P || null,
        mod: w
      };
    }, s.prototype.divmod = function(f, g, b) {
      if (n(!f.isZero()), this.isZero())
        return {
          div: new s(0),
          mod: new s(0)
        };
      var w, _, E;
      return this.negative !== 0 && f.negative === 0 ? (E = this.neg().divmod(f, g), g !== "mod" && (w = E.div.neg()), g !== "div" && (_ = E.mod.neg(), b && _.negative !== 0 && _.iadd(f)), {
        div: w,
        mod: _
      }) : this.negative === 0 && f.negative !== 0 ? (E = this.divmod(f.neg(), g), g !== "mod" && (w = E.div.neg()), {
        div: w,
        mod: E.mod
      }) : this.negative & f.negative ? (E = this.neg().divmod(f.neg(), g), g !== "div" && (_ = E.mod.neg(), b && _.negative !== 0 && _.isub(f)), {
        div: E.div,
        mod: _
      }) : f.length > this.length || this.cmp(f) < 0 ? {
        div: new s(0),
        mod: this
      } : f.length === 1 ? g === "div" ? {
        div: this.divn(f.words[0]),
        mod: null
      } : g === "mod" ? {
        div: null,
        mod: new s(this.modrn(f.words[0]))
      } : {
        div: this.divn(f.words[0]),
        mod: new s(this.modrn(f.words[0]))
      } : this._wordDiv(f, g);
    }, s.prototype.div = function(f) {
      return this.divmod(f, "div", !1).div;
    }, s.prototype.mod = function(f) {
      return this.divmod(f, "mod", !1).mod;
    }, s.prototype.umod = function(f) {
      return this.divmod(f, "mod", !0).mod;
    }, s.prototype.divRound = function(f) {
      var g = this.divmod(f);
      if (g.mod.isZero()) return g.div;
      var b = g.div.negative !== 0 ? g.mod.isub(f) : g.mod, w = f.ushrn(1), _ = f.andln(1), E = b.cmp(w);
      return E < 0 || _ === 1 && E === 0 ? g.div : g.div.negative !== 0 ? g.div.isubn(1) : g.div.iaddn(1);
    }, s.prototype.modrn = function(f) {
      var g = f < 0;
      g && (f = -f), n(f <= 67108863);
      for (var b = (1 << 26) % f, w = 0, _ = this.length - 1; _ >= 0; _--)
        w = (b * w + (this.words[_] | 0)) % f;
      return g ? -w : w;
    }, s.prototype.modn = function(f) {
      return this.modrn(f);
    }, s.prototype.idivn = function(f) {
      var g = f < 0;
      g && (f = -f), n(f <= 67108863);
      for (var b = 0, w = this.length - 1; w >= 0; w--) {
        var _ = (this.words[w] | 0) + b * 67108864;
        this.words[w] = _ / f | 0, b = _ % f;
      }
      return this._strip(), g ? this.ineg() : this;
    }, s.prototype.divn = function(f) {
      return this.clone().idivn(f);
    }, s.prototype.egcd = function(f) {
      n(f.negative === 0), n(!f.isZero());
      var g = this, b = f.clone();
      g.negative !== 0 ? g = g.umod(f) : g = g.clone();
      for (var w = new s(1), _ = new s(0), E = new s(0), v = new s(1), M = 0; g.isEven() && b.isEven(); )
        g.iushrn(1), b.iushrn(1), ++M;
      for (var P = b.clone(), B = g.clone(); !g.isZero(); ) {
        for (var ue = 0, D = 1; !(g.words[0] & D) && ue < 26; ++ue, D <<= 1) ;
        if (ue > 0)
          for (g.iushrn(ue); ue-- > 0; )
            (w.isOdd() || _.isOdd()) && (w.iadd(P), _.isub(B)), w.iushrn(1), _.iushrn(1);
        for (var oe = 0, Z = 1; !(b.words[0] & Z) && oe < 26; ++oe, Z <<= 1) ;
        if (oe > 0)
          for (b.iushrn(oe); oe-- > 0; )
            (E.isOdd() || v.isOdd()) && (E.iadd(P), v.isub(B)), E.iushrn(1), v.iushrn(1);
        g.cmp(b) >= 0 ? (g.isub(b), w.isub(E), _.isub(v)) : (b.isub(g), E.isub(w), v.isub(_));
      }
      return {
        a: E,
        b: v,
        gcd: b.iushln(M)
      };
    }, s.prototype._invmp = function(f) {
      n(f.negative === 0), n(!f.isZero());
      var g = this, b = f.clone();
      g.negative !== 0 ? g = g.umod(f) : g = g.clone();
      for (var w = new s(1), _ = new s(0), E = b.clone(); g.cmpn(1) > 0 && b.cmpn(1) > 0; ) {
        for (var v = 0, M = 1; !(g.words[0] & M) && v < 26; ++v, M <<= 1) ;
        if (v > 0)
          for (g.iushrn(v); v-- > 0; )
            w.isOdd() && w.iadd(E), w.iushrn(1);
        for (var P = 0, B = 1; !(b.words[0] & B) && P < 26; ++P, B <<= 1) ;
        if (P > 0)
          for (b.iushrn(P); P-- > 0; )
            _.isOdd() && _.iadd(E), _.iushrn(1);
        g.cmp(b) >= 0 ? (g.isub(b), w.isub(_)) : (b.isub(g), _.isub(w));
      }
      var ue;
      return g.cmpn(1) === 0 ? ue = w : ue = _, ue.cmpn(0) < 0 && ue.iadd(f), ue;
    }, s.prototype.gcd = function(f) {
      if (this.isZero()) return f.abs();
      if (f.isZero()) return this.abs();
      var g = this.clone(), b = f.clone();
      g.negative = 0, b.negative = 0;
      for (var w = 0; g.isEven() && b.isEven(); w++)
        g.iushrn(1), b.iushrn(1);
      do {
        for (; g.isEven(); )
          g.iushrn(1);
        for (; b.isEven(); )
          b.iushrn(1);
        var _ = g.cmp(b);
        if (_ < 0) {
          var E = g;
          g = b, b = E;
        } else if (_ === 0 || b.cmpn(1) === 0)
          break;
        g.isub(b);
      } while (!0);
      return b.iushln(w);
    }, s.prototype.invm = function(f) {
      return this.egcd(f).a.umod(f);
    }, s.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, s.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, s.prototype.andln = function(f) {
      return this.words[0] & f;
    }, s.prototype.bincn = function(f) {
      n(typeof f == "number");
      var g = f % 26, b = (f - g) / 26, w = 1 << g;
      if (this.length <= b)
        return this._expand(b + 1), this.words[b] |= w, this;
      for (var _ = w, E = b; _ !== 0 && E < this.length; E++) {
        var v = this.words[E] | 0;
        v += _, _ = v >>> 26, v &= 67108863, this.words[E] = v;
      }
      return _ !== 0 && (this.words[E] = _, this.length++), this;
    }, s.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, s.prototype.cmpn = function(f) {
      var g = f < 0;
      if (this.negative !== 0 && !g) return -1;
      if (this.negative === 0 && g) return 1;
      this._strip();
      var b;
      if (this.length > 1)
        b = 1;
      else {
        g && (f = -f), n(f <= 67108863, "Number is too big");
        var w = this.words[0] | 0;
        b = w === f ? 0 : w < f ? -1 : 1;
      }
      return this.negative !== 0 ? -b | 0 : b;
    }, s.prototype.cmp = function(f) {
      if (this.negative !== 0 && f.negative === 0) return -1;
      if (this.negative === 0 && f.negative !== 0) return 1;
      var g = this.ucmp(f);
      return this.negative !== 0 ? -g | 0 : g;
    }, s.prototype.ucmp = function(f) {
      if (this.length > f.length) return 1;
      if (this.length < f.length) return -1;
      for (var g = 0, b = this.length - 1; b >= 0; b--) {
        var w = this.words[b] | 0, _ = f.words[b] | 0;
        if (w !== _) {
          w < _ ? g = -1 : w > _ && (g = 1);
          break;
        }
      }
      return g;
    }, s.prototype.gtn = function(f) {
      return this.cmpn(f) === 1;
    }, s.prototype.gt = function(f) {
      return this.cmp(f) === 1;
    }, s.prototype.gten = function(f) {
      return this.cmpn(f) >= 0;
    }, s.prototype.gte = function(f) {
      return this.cmp(f) >= 0;
    }, s.prototype.ltn = function(f) {
      return this.cmpn(f) === -1;
    }, s.prototype.lt = function(f) {
      return this.cmp(f) === -1;
    }, s.prototype.lten = function(f) {
      return this.cmpn(f) <= 0;
    }, s.prototype.lte = function(f) {
      return this.cmp(f) <= 0;
    }, s.prototype.eqn = function(f) {
      return this.cmpn(f) === 0;
    }, s.prototype.eq = function(f) {
      return this.cmp(f) === 0;
    }, s.red = function(f) {
      return new Y(f);
    }, s.prototype.toRed = function(f) {
      return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), f.convertTo(this)._forceRed(f);
    }, s.prototype.fromRed = function() {
      return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, s.prototype._forceRed = function(f) {
      return this.red = f, this;
    }, s.prototype.forceRed = function(f) {
      return n(!this.red, "Already a number in reduction context"), this._forceRed(f);
    }, s.prototype.redAdd = function(f) {
      return n(this.red, "redAdd works only with red numbers"), this.red.add(this, f);
    }, s.prototype.redIAdd = function(f) {
      return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f);
    }, s.prototype.redSub = function(f) {
      return n(this.red, "redSub works only with red numbers"), this.red.sub(this, f);
    }, s.prototype.redISub = function(f) {
      return n(this.red, "redISub works only with red numbers"), this.red.isub(this, f);
    }, s.prototype.redShl = function(f) {
      return n(this.red, "redShl works only with red numbers"), this.red.shl(this, f);
    }, s.prototype.redMul = function(f) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f);
    }, s.prototype.redIMul = function(f) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f);
    }, s.prototype.redSqr = function() {
      return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, s.prototype.redISqr = function() {
      return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, s.prototype.redSqrt = function() {
      return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, s.prototype.redInvm = function() {
      return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, s.prototype.redNeg = function() {
      return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, s.prototype.redPow = function(f) {
      return n(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f);
    };
    var V = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function te(m, f) {
      this.name = m, this.p = new s(f, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    te.prototype._tmp = function() {
      var f = new s(null);
      return f.words = new Array(Math.ceil(this.n / 13)), f;
    }, te.prototype.ireduce = function(f) {
      var g = f, b;
      do
        this.split(g, this.tmp), g = this.imulK(g), g = g.iadd(this.tmp), b = g.bitLength();
      while (b > this.n);
      var w = b < this.n ? -1 : g.ucmp(this.p);
      return w === 0 ? (g.words[0] = 0, g.length = 1) : w > 0 ? g.isub(this.p) : g.strip !== void 0 ? g.strip() : g._strip(), g;
    }, te.prototype.split = function(f, g) {
      f.iushrn(this.n, 0, g);
    }, te.prototype.imulK = function(f) {
      return f.imul(this.k);
    };
    function R() {
      te.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(R, te), R.prototype.split = function(f, g) {
      for (var b = 4194303, w = Math.min(f.length, 9), _ = 0; _ < w; _++)
        g.words[_] = f.words[_];
      if (g.length = w, f.length <= 9) {
        f.words[0] = 0, f.length = 1;
        return;
      }
      var E = f.words[9];
      for (g.words[g.length++] = E & b, _ = 10; _ < f.length; _++) {
        var v = f.words[_] | 0;
        f.words[_ - 10] = (v & b) << 4 | E >>> 22, E = v;
      }
      E >>>= 22, f.words[_ - 10] = E, E === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9;
    }, R.prototype.imulK = function(f) {
      f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
      for (var g = 0, b = 0; b < f.length; b++) {
        var w = f.words[b] | 0;
        g += w * 977, f.words[b] = g & 67108863, g = w * 64 + (g / 67108864 | 0);
      }
      return f.words[f.length - 1] === 0 && (f.length--, f.words[f.length - 1] === 0 && f.length--), f;
    };
    function K() {
      te.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(K, te);
    function pe() {
      te.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(pe, te);
    function _e() {
      te.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(_e, te), _e.prototype.imulK = function(f) {
      for (var g = 0, b = 0; b < f.length; b++) {
        var w = (f.words[b] | 0) * 19 + g, _ = w & 67108863;
        w >>>= 26, f.words[b] = _, g = w;
      }
      return g !== 0 && (f.words[f.length++] = g), f;
    }, s._prime = function(f) {
      if (V[f]) return V[f];
      var g;
      if (f === "k256")
        g = new R();
      else if (f === "p224")
        g = new K();
      else if (f === "p192")
        g = new pe();
      else if (f === "p25519")
        g = new _e();
      else
        throw new Error("Unknown prime " + f);
      return V[f] = g, g;
    };
    function Y(m) {
      if (typeof m == "string") {
        var f = s._prime(m);
        this.m = f.p, this.prime = f;
      } else
        n(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null;
    }
    Y.prototype._verify1 = function(f) {
      n(f.negative === 0, "red works only with positives"), n(f.red, "red works only with red numbers");
    }, Y.prototype._verify2 = function(f, g) {
      n((f.negative | g.negative) === 0, "red works only with positives"), n(
        f.red && f.red === g.red,
        "red works only with red numbers"
      );
    }, Y.prototype.imod = function(f) {
      return this.prime ? this.prime.ireduce(f)._forceRed(this) : (d(f, f.umod(this.m)._forceRed(this)), f);
    }, Y.prototype.neg = function(f) {
      return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this);
    }, Y.prototype.add = function(f, g) {
      this._verify2(f, g);
      var b = f.add(g);
      return b.cmp(this.m) >= 0 && b.isub(this.m), b._forceRed(this);
    }, Y.prototype.iadd = function(f, g) {
      this._verify2(f, g);
      var b = f.iadd(g);
      return b.cmp(this.m) >= 0 && b.isub(this.m), b;
    }, Y.prototype.sub = function(f, g) {
      this._verify2(f, g);
      var b = f.sub(g);
      return b.cmpn(0) < 0 && b.iadd(this.m), b._forceRed(this);
    }, Y.prototype.isub = function(f, g) {
      this._verify2(f, g);
      var b = f.isub(g);
      return b.cmpn(0) < 0 && b.iadd(this.m), b;
    }, Y.prototype.shl = function(f, g) {
      return this._verify1(f), this.imod(f.ushln(g));
    }, Y.prototype.imul = function(f, g) {
      return this._verify2(f, g), this.imod(f.imul(g));
    }, Y.prototype.mul = function(f, g) {
      return this._verify2(f, g), this.imod(f.mul(g));
    }, Y.prototype.isqr = function(f) {
      return this.imul(f, f.clone());
    }, Y.prototype.sqr = function(f) {
      return this.mul(f, f);
    }, Y.prototype.sqrt = function(f) {
      if (f.isZero()) return f.clone();
      var g = this.m.andln(3);
      if (n(g % 2 === 1), g === 3) {
        var b = this.m.add(new s(1)).iushrn(2);
        return this.pow(f, b);
      }
      for (var w = this.m.subn(1), _ = 0; !w.isZero() && w.andln(1) === 0; )
        _++, w.iushrn(1);
      n(!w.isZero());
      var E = new s(1).toRed(this), v = E.redNeg(), M = this.m.subn(1).iushrn(1), P = this.m.bitLength();
      for (P = new s(2 * P * P).toRed(this); this.pow(P, M).cmp(v) !== 0; )
        P.redIAdd(v);
      for (var B = this.pow(P, w), ue = this.pow(f, w.addn(1).iushrn(1)), D = this.pow(f, w), oe = _; D.cmp(E) !== 0; ) {
        for (var Z = D, J = 0; Z.cmp(E) !== 0; J++)
          Z = Z.redSqr();
        n(J < oe);
        var Q = this.pow(B, new s(1).iushln(oe - J - 1));
        ue = ue.redMul(Q), B = Q.redSqr(), D = D.redMul(B), oe = J;
      }
      return ue;
    }, Y.prototype.invm = function(f) {
      var g = f._invmp(this.m);
      return g.negative !== 0 ? (g.negative = 0, this.imod(g).redNeg()) : this.imod(g);
    }, Y.prototype.pow = function(f, g) {
      if (g.isZero()) return new s(1).toRed(this);
      if (g.cmpn(1) === 0) return f.clone();
      var b = 4, w = new Array(1 << b);
      w[0] = new s(1).toRed(this), w[1] = f;
      for (var _ = 2; _ < w.length; _++)
        w[_] = this.mul(w[_ - 1], f);
      var E = w[0], v = 0, M = 0, P = g.bitLength() % 26;
      for (P === 0 && (P = 26), _ = g.length - 1; _ >= 0; _--) {
        for (var B = g.words[_], ue = P - 1; ue >= 0; ue--) {
          var D = B >> ue & 1;
          if (E !== w[0] && (E = this.sqr(E)), D === 0 && v === 0) {
            M = 0;
            continue;
          }
          v <<= 1, v |= D, M++, !(M !== b && (_ !== 0 || ue !== 0)) && (E = this.mul(E, w[v]), M = 0, v = 0);
        }
        P = 26;
      }
      return E;
    }, Y.prototype.convertTo = function(f) {
      var g = f.umod(this.m);
      return g === f ? g.clone() : g;
    }, Y.prototype.convertFrom = function(f) {
      var g = f.clone();
      return g.red = null, g;
    }, s.mont = function(f) {
      return new S(f);
    };
    function S(m) {
      Y.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(S, Y), S.prototype.convertTo = function(f) {
      return this.imod(f.ushln(this.shift));
    }, S.prototype.convertFrom = function(f) {
      var g = this.imod(f.mul(this.rinv));
      return g.red = null, g;
    }, S.prototype.imul = function(f, g) {
      if (f.isZero() || g.isZero())
        return f.words[0] = 0, f.length = 1, f;
      var b = f.imul(g), w = b.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), _ = b.isub(w).iushrn(this.shift), E = _;
      return _.cmp(this.m) >= 0 ? E = _.isub(this.m) : _.cmpn(0) < 0 && (E = _.iadd(this.m)), E._forceRed(this);
    }, S.prototype.mul = function(f, g) {
      if (f.isZero() || g.isZero()) return new s(0)._forceRed(this);
      var b = f.mul(g), w = b.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), _ = b.isub(w).iushrn(this.shift), E = _;
      return _.cmp(this.m) >= 0 ? E = _.isub(this.m) : _.cmpn(0) < 0 && (E = _.iadd(this.m)), E._forceRed(this);
    }, S.prototype.invm = function(f) {
      var g = this.imod(f._invmp(this.m).mul(this.r2));
      return g._forceRed(this);
    };
  })(t, gn);
})(qv);
var vF = qv.exports;
const ir = /* @__PURE__ */ ts(vF);
var bF = ir.BN;
function yF(t) {
  return new bF(t, 36).toString(16);
}
const wF = "strings/5.7.0", xF = new Yr(wF);
var t0;
(function(t) {
  t.current = "", t.NFC = "NFC", t.NFD = "NFD", t.NFKC = "NFKC", t.NFKD = "NFKD";
})(t0 || (t0 = {}));
var mx;
(function(t) {
  t.UNEXPECTED_CONTINUE = "unexpected continuation byte", t.BAD_PREFIX = "bad codepoint prefix", t.OVERRUN = "string overrun", t.MISSING_CONTINUE = "missing continuation byte", t.OUT_OF_RANGE = "out of UTF-8 range", t.UTF16_SURROGATE = "UTF-16 surrogate", t.OVERLONG = "overlong representation";
})(mx || (mx = {}));
function em(t, e = t0.current) {
  e != t0.current && (xF.checkNormalize(), t = t.normalize(e));
  let r = [];
  for (let n = 0; n < t.length; n++) {
    const i = t.charCodeAt(n);
    if (i < 128)
      r.push(i);
    else if (i < 2048)
      r.push(i >> 6 | 192), r.push(i & 63 | 128);
    else if ((i & 64512) == 55296) {
      n++;
      const s = t.charCodeAt(n);
      if (n >= t.length || (s & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const o = 65536 + ((i & 1023) << 10) + (s & 1023);
      r.push(o >> 18 | 240), r.push(o >> 12 & 63 | 128), r.push(o >> 6 & 63 | 128), r.push(o & 63 | 128);
    } else
      r.push(i >> 12 | 224), r.push(i >> 6 & 63 | 128), r.push(i & 63 | 128);
  }
  return wn(r);
}
const _F = `Ethereum Signed Message:
`;
function K4(t) {
  return typeof t == "string" && (t = em(t)), jv(pF([
    em(_F),
    em(String(t.length)),
    t
  ]));
}
const EF = "address/5.7.0", Lf = new Yr(EF);
function vx(t) {
  js(t, 20) || Lf.throwArgumentError("invalid address", "address", t), t = t.toLowerCase();
  const e = t.substring(2).split(""), r = new Uint8Array(40);
  for (let i = 0; i < 40; i++)
    r[i] = e[i].charCodeAt(0);
  const n = wn(jv(r));
  for (let i = 0; i < 40; i += 2)
    n[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (n[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
  return "0x" + e.join("");
}
const SF = 9007199254740991;
function AF(t) {
  return Math.log10 ? Math.log10(t) : Math.log(t) / Math.LN10;
}
const zv = {};
for (let t = 0; t < 10; t++)
  zv[String(t)] = String(t);
for (let t = 0; t < 26; t++)
  zv[String.fromCharCode(65 + t)] = String(10 + t);
const bx = Math.floor(AF(SF));
function PF(t) {
  t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
  let e = t.split("").map((n) => zv[n]).join("");
  for (; e.length >= bx; ) {
    let n = e.substring(0, bx);
    e = parseInt(n, 10) % 97 + e.substring(n.length);
  }
  let r = String(98 - parseInt(e, 10) % 97);
  for (; r.length < 2; )
    r = "0" + r;
  return r;
}
function MF(t) {
  let e = null;
  if (typeof t != "string" && Lf.throwArgumentError("invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/))
    t.substring(0, 2) !== "0x" && (t = "0x" + t), e = vx(t), t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== t && Lf.throwArgumentError("bad address checksum", "address", t);
  else if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (t.substring(2, 4) !== PF(t) && Lf.throwArgumentError("bad icap checksum", "address", t), e = yF(t.substring(4)); e.length < 40; )
      e = "0" + e;
    e = vx("0x" + e);
  } else
    Lf.throwArgumentError("invalid address", "address", t);
  return e;
}
function wf(t, e, r) {
  Object.defineProperty(t, e, {
    enumerable: !0,
    value: r,
    writable: !1
  });
}
var Kl = {}, wr = {}, mc = V4;
function V4(t, e) {
  if (!t)
    throw new Error(e || "Assertion failed");
}
V4.equal = function(e, r, n) {
  if (e != r)
    throw new Error(n || "Assertion failed: " + e + " != " + r);
};
var w1 = { exports: {} };
typeof Object.create == "function" ? w1.exports = function(e, r) {
  r && (e.super_ = r, e.prototype = Object.create(r.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : w1.exports = function(e, r) {
  if (r) {
    e.super_ = r;
    var n = function() {
    };
    n.prototype = r.prototype, e.prototype = new n(), e.prototype.constructor = e;
  }
};
var z0 = w1.exports, IF = mc, CF = z0;
wr.inherits = CF;
function TF(t, e) {
  return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? !1 : (t.charCodeAt(e + 1) & 64512) === 56320;
}
function RF(t, e) {
  if (Array.isArray(t))
    return t.slice();
  if (!t)
    return [];
  var r = [];
  if (typeof t == "string")
    if (e) {
      if (e === "hex")
        for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), i = 0; i < t.length; i += 2)
          r.push(parseInt(t[i] + t[i + 1], 16));
    } else for (var n = 0, i = 0; i < t.length; i++) {
      var s = t.charCodeAt(i);
      s < 128 ? r[n++] = s : s < 2048 ? (r[n++] = s >> 6 | 192, r[n++] = s & 63 | 128) : TF(t, i) ? (s = 65536 + ((s & 1023) << 10) + (t.charCodeAt(++i) & 1023), r[n++] = s >> 18 | 240, r[n++] = s >> 12 & 63 | 128, r[n++] = s >> 6 & 63 | 128, r[n++] = s & 63 | 128) : (r[n++] = s >> 12 | 224, r[n++] = s >> 6 & 63 | 128, r[n++] = s & 63 | 128);
    }
  else
    for (i = 0; i < t.length; i++)
      r[i] = t[i] | 0;
  return r;
}
wr.toArray = RF;
function DF(t) {
  for (var e = "", r = 0; r < t.length; r++)
    e += Y4(t[r].toString(16));
  return e;
}
wr.toHex = DF;
function G4(t) {
  var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
  return e >>> 0;
}
wr.htonl = G4;
function OF(t, e) {
  for (var r = "", n = 0; n < t.length; n++) {
    var i = t[n];
    e === "little" && (i = G4(i)), r += J4(i.toString(16));
  }
  return r;
}
wr.toHex32 = OF;
function Y4(t) {
  return t.length === 1 ? "0" + t : t;
}
wr.zero2 = Y4;
function J4(t) {
  return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
}
wr.zero8 = J4;
function NF(t, e, r, n) {
  var i = r - e;
  IF(i % 4 === 0);
  for (var s = new Array(i / 4), o = 0, a = e; o < s.length; o++, a += 4) {
    var u;
    n === "big" ? u = t[a] << 24 | t[a + 1] << 16 | t[a + 2] << 8 | t[a + 3] : u = t[a + 3] << 24 | t[a + 2] << 16 | t[a + 1] << 8 | t[a], s[o] = u >>> 0;
  }
  return s;
}
wr.join32 = NF;
function LF(t, e) {
  for (var r = new Array(t.length * 4), n = 0, i = 0; n < t.length; n++, i += 4) {
    var s = t[n];
    e === "big" ? (r[i] = s >>> 24, r[i + 1] = s >>> 16 & 255, r[i + 2] = s >>> 8 & 255, r[i + 3] = s & 255) : (r[i + 3] = s >>> 24, r[i + 2] = s >>> 16 & 255, r[i + 1] = s >>> 8 & 255, r[i] = s & 255);
  }
  return r;
}
wr.split32 = LF;
function kF(t, e) {
  return t >>> e | t << 32 - e;
}
wr.rotr32 = kF;
function $F(t, e) {
  return t << e | t >>> 32 - e;
}
wr.rotl32 = $F;
function BF(t, e) {
  return t + e >>> 0;
}
wr.sum32 = BF;
function FF(t, e, r) {
  return t + e + r >>> 0;
}
wr.sum32_3 = FF;
function UF(t, e, r, n) {
  return t + e + r + n >>> 0;
}
wr.sum32_4 = UF;
function jF(t, e, r, n, i) {
  return t + e + r + n + i >>> 0;
}
wr.sum32_5 = jF;
function qF(t, e, r, n) {
  var i = t[e], s = t[e + 1], o = n + s >>> 0, a = (o < n ? 1 : 0) + r + i;
  t[e] = a >>> 0, t[e + 1] = o;
}
wr.sum64 = qF;
function zF(t, e, r, n) {
  var i = e + n >>> 0, s = (i < e ? 1 : 0) + t + r;
  return s >>> 0;
}
wr.sum64_hi = zF;
function HF(t, e, r, n) {
  var i = e + n;
  return i >>> 0;
}
wr.sum64_lo = HF;
function WF(t, e, r, n, i, s, o, a) {
  var u = 0, h = e;
  h = h + n >>> 0, u += h < e ? 1 : 0, h = h + s >>> 0, u += h < s ? 1 : 0, h = h + a >>> 0, u += h < a ? 1 : 0;
  var d = t + r + i + o + u;
  return d >>> 0;
}
wr.sum64_4_hi = WF;
function KF(t, e, r, n, i, s, o, a) {
  var u = e + n + s + a;
  return u >>> 0;
}
wr.sum64_4_lo = KF;
function VF(t, e, r, n, i, s, o, a, u, h) {
  var d = 0, p = e;
  p = p + n >>> 0, d += p < e ? 1 : 0, p = p + s >>> 0, d += p < s ? 1 : 0, p = p + a >>> 0, d += p < a ? 1 : 0, p = p + h >>> 0, d += p < h ? 1 : 0;
  var x = t + r + i + o + u + d;
  return x >>> 0;
}
wr.sum64_5_hi = VF;
function GF(t, e, r, n, i, s, o, a, u, h) {
  var d = e + n + s + a + h;
  return d >>> 0;
}
wr.sum64_5_lo = GF;
function YF(t, e, r) {
  var n = e << 32 - r | t >>> r;
  return n >>> 0;
}
wr.rotr64_hi = YF;
function JF(t, e, r) {
  var n = t << 32 - r | e >>> r;
  return n >>> 0;
}
wr.rotr64_lo = JF;
function XF(t, e, r) {
  return t >>> r;
}
wr.shr64_hi = XF;
function ZF(t, e, r) {
  var n = t << 32 - r | e >>> r;
  return n >>> 0;
}
wr.shr64_lo = ZF;
var Ou = {}, yx = wr, QF = mc;
function H0() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
Ou.BlockHash = H0;
H0.prototype.update = function(e, r) {
  if (e = yx.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
    e = this.pending;
    var n = e.length % this._delta8;
    this.pending = e.slice(e.length - n, e.length), this.pending.length === 0 && (this.pending = null), e = yx.join32(e, 0, e.length - n, this.endian);
    for (var i = 0; i < e.length; i += this._delta32)
      this._update(e, i, i + this._delta32);
  }
  return this;
};
H0.prototype.digest = function(e) {
  return this.update(this._pad()), QF(this.pending === null), this._digest(e);
};
H0.prototype._pad = function() {
  var e = this.pendingTotal, r = this._delta8, n = r - (e + this.padLength) % r, i = new Array(n + this.padLength);
  i[0] = 128;
  for (var s = 1; s < n; s++)
    i[s] = 0;
  if (e <<= 3, this.endian === "big") {
    for (var o = 8; o < this.padLength; o++)
      i[s++] = 0;
    i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = e >>> 24 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 8 & 255, i[s++] = e & 255;
  } else
    for (i[s++] = e & 255, i[s++] = e >>> 8 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 24 & 255, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, o = 8; o < this.padLength; o++)
      i[s++] = 0;
  return i;
};
var Nu = {}, eo = {}, eU = wr, qs = eU.rotr32;
function tU(t, e, r, n) {
  if (t === 0)
    return X4(e, r, n);
  if (t === 1 || t === 3)
    return Q4(e, r, n);
  if (t === 2)
    return Z4(e, r, n);
}
eo.ft_1 = tU;
function X4(t, e, r) {
  return t & e ^ ~t & r;
}
eo.ch32 = X4;
function Z4(t, e, r) {
  return t & e ^ t & r ^ e & r;
}
eo.maj32 = Z4;
function Q4(t, e, r) {
  return t ^ e ^ r;
}
eo.p32 = Q4;
function rU(t) {
  return qs(t, 2) ^ qs(t, 13) ^ qs(t, 22);
}
eo.s0_256 = rU;
function nU(t) {
  return qs(t, 6) ^ qs(t, 11) ^ qs(t, 25);
}
eo.s1_256 = nU;
function iU(t) {
  return qs(t, 7) ^ qs(t, 18) ^ t >>> 3;
}
eo.g0_256 = iU;
function sU(t) {
  return qs(t, 17) ^ qs(t, 19) ^ t >>> 10;
}
eo.g1_256 = sU;
var wu = wr, oU = Ou, aU = eo, tm = wu.rotl32, xf = wu.sum32, cU = wu.sum32_5, uU = aU.ft_1, e8 = oU.BlockHash, fU = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function Gs() {
  if (!(this instanceof Gs))
    return new Gs();
  e8.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
wu.inherits(Gs, e8);
var lU = Gs;
Gs.blockSize = 512;
Gs.outSize = 160;
Gs.hmacStrength = 80;
Gs.padLength = 64;
Gs.prototype._update = function(e, r) {
  for (var n = this.W, i = 0; i < 16; i++)
    n[i] = e[r + i];
  for (; i < n.length; i++)
    n[i] = tm(n[i - 3] ^ n[i - 8] ^ n[i - 14] ^ n[i - 16], 1);
  var s = this.h[0], o = this.h[1], a = this.h[2], u = this.h[3], h = this.h[4];
  for (i = 0; i < n.length; i++) {
    var d = ~~(i / 20), p = cU(tm(s, 5), uU(d, o, a, u), h, n[i], fU[d]);
    h = u, u = a, a = tm(o, 30), o = s, s = p;
  }
  this.h[0] = xf(this.h[0], s), this.h[1] = xf(this.h[1], o), this.h[2] = xf(this.h[2], a), this.h[3] = xf(this.h[3], u), this.h[4] = xf(this.h[4], h);
};
Gs.prototype._digest = function(e) {
  return e === "hex" ? wu.toHex32(this.h, "big") : wu.split32(this.h, "big");
};
var xu = wr, hU = Ou, Lu = eo, dU = mc, ps = xu.sum32, pU = xu.sum32_4, gU = xu.sum32_5, mU = Lu.ch32, vU = Lu.maj32, bU = Lu.s0_256, yU = Lu.s1_256, wU = Lu.g0_256, xU = Lu.g1_256, t8 = hU.BlockHash, _U = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function Ys() {
  if (!(this instanceof Ys))
    return new Ys();
  t8.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = _U, this.W = new Array(64);
}
xu.inherits(Ys, t8);
var r8 = Ys;
Ys.blockSize = 512;
Ys.outSize = 256;
Ys.hmacStrength = 192;
Ys.padLength = 64;
Ys.prototype._update = function(e, r) {
  for (var n = this.W, i = 0; i < 16; i++)
    n[i] = e[r + i];
  for (; i < n.length; i++)
    n[i] = pU(xU(n[i - 2]), n[i - 7], wU(n[i - 15]), n[i - 16]);
  var s = this.h[0], o = this.h[1], a = this.h[2], u = this.h[3], h = this.h[4], d = this.h[5], p = this.h[6], x = this.h[7];
  for (dU(this.k.length === n.length), i = 0; i < n.length; i++) {
    var A = gU(x, yU(h), mU(h, d, p), this.k[i], n[i]), I = ps(bU(s), vU(s, o, a));
    x = p, p = d, d = h, h = ps(u, A), u = a, a = o, o = s, s = ps(A, I);
  }
  this.h[0] = ps(this.h[0], s), this.h[1] = ps(this.h[1], o), this.h[2] = ps(this.h[2], a), this.h[3] = ps(this.h[3], u), this.h[4] = ps(this.h[4], h), this.h[5] = ps(this.h[5], d), this.h[6] = ps(this.h[6], p), this.h[7] = ps(this.h[7], x);
};
Ys.prototype._digest = function(e) {
  return e === "hex" ? xu.toHex32(this.h, "big") : xu.split32(this.h, "big");
};
var x1 = wr, n8 = r8;
function ko() {
  if (!(this instanceof ko))
    return new ko();
  n8.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
x1.inherits(ko, n8);
var EU = ko;
ko.blockSize = 512;
ko.outSize = 224;
ko.hmacStrength = 192;
ko.padLength = 64;
ko.prototype._digest = function(e) {
  return e === "hex" ? x1.toHex32(this.h.slice(0, 7), "big") : x1.split32(this.h.slice(0, 7), "big");
};
var xi = wr, SU = Ou, AU = mc, zs = xi.rotr64_hi, Hs = xi.rotr64_lo, i8 = xi.shr64_hi, s8 = xi.shr64_lo, Zo = xi.sum64, rm = xi.sum64_hi, nm = xi.sum64_lo, PU = xi.sum64_4_hi, MU = xi.sum64_4_lo, IU = xi.sum64_5_hi, CU = xi.sum64_5_lo, o8 = SU.BlockHash, TU = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function Es() {
  if (!(this instanceof Es))
    return new Es();
  o8.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = TU, this.W = new Array(160);
}
xi.inherits(Es, o8);
var a8 = Es;
Es.blockSize = 1024;
Es.outSize = 512;
Es.hmacStrength = 192;
Es.padLength = 128;
Es.prototype._prepareBlock = function(e, r) {
  for (var n = this.W, i = 0; i < 32; i++)
    n[i] = e[r + i];
  for (; i < n.length; i += 2) {
    var s = jU(n[i - 4], n[i - 3]), o = qU(n[i - 4], n[i - 3]), a = n[i - 14], u = n[i - 13], h = FU(n[i - 30], n[i - 29]), d = UU(n[i - 30], n[i - 29]), p = n[i - 32], x = n[i - 31];
    n[i] = PU(
      s,
      o,
      a,
      u,
      h,
      d,
      p,
      x
    ), n[i + 1] = MU(
      s,
      o,
      a,
      u,
      h,
      d,
      p,
      x
    );
  }
};
Es.prototype._update = function(e, r) {
  this._prepareBlock(e, r);
  var n = this.W, i = this.h[0], s = this.h[1], o = this.h[2], a = this.h[3], u = this.h[4], h = this.h[5], d = this.h[6], p = this.h[7], x = this.h[8], A = this.h[9], I = this.h[10], N = this.h[11], L = this.h[12], F = this.h[13], $ = this.h[14], W = this.h[15];
  AU(this.k.length === n.length);
  for (var z = 0; z < n.length; z += 2) {
    var V = $, te = W, R = $U(x, A), K = BU(x, A), pe = RU(x, A, I, N, L), _e = DU(x, A, I, N, L, F), Y = this.k[z], S = this.k[z + 1], m = n[z], f = n[z + 1], g = IU(
      V,
      te,
      R,
      K,
      pe,
      _e,
      Y,
      S,
      m,
      f
    ), b = CU(
      V,
      te,
      R,
      K,
      pe,
      _e,
      Y,
      S,
      m,
      f
    );
    V = LU(i, s), te = kU(i, s), R = OU(i, s, o, a, u), K = NU(i, s, o, a, u, h);
    var w = rm(V, te, R, K), _ = nm(V, te, R, K);
    $ = L, W = F, L = I, F = N, I = x, N = A, x = rm(d, p, g, b), A = nm(p, p, g, b), d = u, p = h, u = o, h = a, o = i, a = s, i = rm(g, b, w, _), s = nm(g, b, w, _);
  }
  Zo(this.h, 0, i, s), Zo(this.h, 2, o, a), Zo(this.h, 4, u, h), Zo(this.h, 6, d, p), Zo(this.h, 8, x, A), Zo(this.h, 10, I, N), Zo(this.h, 12, L, F), Zo(this.h, 14, $, W);
};
Es.prototype._digest = function(e) {
  return e === "hex" ? xi.toHex32(this.h, "big") : xi.split32(this.h, "big");
};
function RU(t, e, r, n, i) {
  var s = t & r ^ ~t & i;
  return s < 0 && (s += 4294967296), s;
}
function DU(t, e, r, n, i, s) {
  var o = e & n ^ ~e & s;
  return o < 0 && (o += 4294967296), o;
}
function OU(t, e, r, n, i) {
  var s = t & r ^ t & i ^ r & i;
  return s < 0 && (s += 4294967296), s;
}
function NU(t, e, r, n, i, s) {
  var o = e & n ^ e & s ^ n & s;
  return o < 0 && (o += 4294967296), o;
}
function LU(t, e) {
  var r = zs(t, e, 28), n = zs(e, t, 2), i = zs(e, t, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function kU(t, e) {
  var r = Hs(t, e, 28), n = Hs(e, t, 2), i = Hs(e, t, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function $U(t, e) {
  var r = zs(t, e, 14), n = zs(t, e, 18), i = zs(e, t, 9), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function BU(t, e) {
  var r = Hs(t, e, 14), n = Hs(t, e, 18), i = Hs(e, t, 9), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function FU(t, e) {
  var r = zs(t, e, 1), n = zs(t, e, 8), i = i8(t, e, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function UU(t, e) {
  var r = Hs(t, e, 1), n = Hs(t, e, 8), i = s8(t, e, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function jU(t, e) {
  var r = zs(t, e, 19), n = zs(e, t, 29), i = i8(t, e, 6), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function qU(t, e) {
  var r = Hs(t, e, 19), n = Hs(e, t, 29), i = s8(t, e, 6), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
var _1 = wr, c8 = a8;
function $o() {
  if (!(this instanceof $o))
    return new $o();
  c8.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
_1.inherits($o, c8);
var zU = $o;
$o.blockSize = 1024;
$o.outSize = 384;
$o.hmacStrength = 192;
$o.padLength = 128;
$o.prototype._digest = function(e) {
  return e === "hex" ? _1.toHex32(this.h.slice(0, 12), "big") : _1.split32(this.h.slice(0, 12), "big");
};
Nu.sha1 = lU;
Nu.sha224 = EU;
Nu.sha256 = r8;
Nu.sha384 = zU;
Nu.sha512 = a8;
var u8 = {}, ac = wr, HU = Ou, cd = ac.rotl32, wx = ac.sum32, _f = ac.sum32_3, xx = ac.sum32_4, f8 = HU.BlockHash;
function Js() {
  if (!(this instanceof Js))
    return new Js();
  f8.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
ac.inherits(Js, f8);
u8.ripemd160 = Js;
Js.blockSize = 512;
Js.outSize = 160;
Js.hmacStrength = 192;
Js.padLength = 64;
Js.prototype._update = function(e, r) {
  for (var n = this.h[0], i = this.h[1], s = this.h[2], o = this.h[3], a = this.h[4], u = n, h = i, d = s, p = o, x = a, A = 0; A < 80; A++) {
    var I = wx(
      cd(
        xx(n, _x(A, i, s, o), e[VU[A] + r], WU(A)),
        YU[A]
      ),
      a
    );
    n = a, a = o, o = cd(s, 10), s = i, i = I, I = wx(
      cd(
        xx(u, _x(79 - A, h, d, p), e[GU[A] + r], KU(A)),
        JU[A]
      ),
      x
    ), u = x, x = p, p = cd(d, 10), d = h, h = I;
  }
  I = _f(this.h[1], s, p), this.h[1] = _f(this.h[2], o, x), this.h[2] = _f(this.h[3], a, u), this.h[3] = _f(this.h[4], n, h), this.h[4] = _f(this.h[0], i, d), this.h[0] = I;
};
Js.prototype._digest = function(e) {
  return e === "hex" ? ac.toHex32(this.h, "little") : ac.split32(this.h, "little");
};
function _x(t, e, r, n) {
  return t <= 15 ? e ^ r ^ n : t <= 31 ? e & r | ~e & n : t <= 47 ? (e | ~r) ^ n : t <= 63 ? e & n | r & ~n : e ^ (r | ~n);
}
function WU(t) {
  return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
}
function KU(t) {
  return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
}
var VU = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], GU = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], YU = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], JU = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], XU = wr, ZU = mc;
function _u(t, e, r) {
  if (!(this instanceof _u))
    return new _u(t, e, r);
  this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(XU.toArray(e, r));
}
var QU = _u;
_u.prototype._init = function(e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), ZU(e.length <= this.blockSize);
  for (var r = e.length; r < this.blockSize; r++)
    e.push(0);
  for (r = 0; r < e.length; r++)
    e[r] ^= 54;
  for (this.inner = new this.Hash().update(e), r = 0; r < e.length; r++)
    e[r] ^= 106;
  this.outer = new this.Hash().update(e);
};
_u.prototype.update = function(e, r) {
  return this.inner.update(e, r), this;
};
_u.prototype.digest = function(e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function(t) {
  var e = t;
  e.utils = wr, e.common = Ou, e.sha = Nu, e.ripemd = u8, e.hmac = QU, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160;
})(Kl);
const vo = /* @__PURE__ */ ts(Kl);
function ku(t, e, r) {
  return r = {
    path: e,
    exports: {},
    require: function(n, i) {
      return ej(n, i ?? r.path);
    }
  }, t(r, r.exports), r.exports;
}
function ej() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var Hv = l8;
function l8(t, e) {
  if (!t)
    throw new Error(e || "Assertion failed");
}
l8.equal = function(e, r, n) {
  if (e != r)
    throw new Error(n || "Assertion failed: " + e + " != " + r);
};
var ws = ku(function(t, e) {
  var r = e;
  function n(o, a) {
    if (Array.isArray(o))
      return o.slice();
    if (!o)
      return [];
    var u = [];
    if (typeof o != "string") {
      for (var h = 0; h < o.length; h++)
        u[h] = o[h] | 0;
      return u;
    }
    if (a === "hex") {
      o = o.replace(/[^a-z0-9]+/ig, ""), o.length % 2 !== 0 && (o = "0" + o);
      for (var h = 0; h < o.length; h += 2)
        u.push(parseInt(o[h] + o[h + 1], 16));
    } else
      for (var h = 0; h < o.length; h++) {
        var d = o.charCodeAt(h), p = d >> 8, x = d & 255;
        p ? u.push(p, x) : u.push(x);
      }
    return u;
  }
  r.toArray = n;
  function i(o) {
    return o.length === 1 ? "0" + o : o;
  }
  r.zero2 = i;
  function s(o) {
    for (var a = "", u = 0; u < o.length; u++)
      a += i(o[u].toString(16));
    return a;
  }
  r.toHex = s, r.encode = function(a, u) {
    return u === "hex" ? s(a) : a;
  };
}), $i = ku(function(t, e) {
  var r = e;
  r.assert = Hv, r.toArray = ws.toArray, r.zero2 = ws.zero2, r.toHex = ws.toHex, r.encode = ws.encode;
  function n(u, h, d) {
    var p = new Array(Math.max(u.bitLength(), d) + 1);
    p.fill(0);
    for (var x = 1 << h + 1, A = u.clone(), I = 0; I < p.length; I++) {
      var N, L = A.andln(x - 1);
      A.isOdd() ? (L > (x >> 1) - 1 ? N = (x >> 1) - L : N = L, A.isubn(N)) : N = 0, p[I] = N, A.iushrn(1);
    }
    return p;
  }
  r.getNAF = n;
  function i(u, h) {
    var d = [
      [],
      []
    ];
    u = u.clone(), h = h.clone();
    for (var p = 0, x = 0, A; u.cmpn(-p) > 0 || h.cmpn(-x) > 0; ) {
      var I = u.andln(3) + p & 3, N = h.andln(3) + x & 3;
      I === 3 && (I = -1), N === 3 && (N = -1);
      var L;
      I & 1 ? (A = u.andln(7) + p & 7, (A === 3 || A === 5) && N === 2 ? L = -I : L = I) : L = 0, d[0].push(L);
      var F;
      N & 1 ? (A = h.andln(7) + x & 7, (A === 3 || A === 5) && I === 2 ? F = -N : F = N) : F = 0, d[1].push(F), 2 * p === L + 1 && (p = 1 - p), 2 * x === F + 1 && (x = 1 - x), u.iushrn(1), h.iushrn(1);
    }
    return d;
  }
  r.getJSF = i;
  function s(u, h, d) {
    var p = "_" + h;
    u.prototype[h] = function() {
      return this[p] !== void 0 ? this[p] : this[p] = d.call(this);
    };
  }
  r.cachedProperty = s;
  function o(u) {
    return typeof u == "string" ? r.toArray(u, "hex") : u;
  }
  r.parseBytes = o;
  function a(u) {
    return new ir(u, "hex", "le");
  }
  r.intFromLE = a;
}), r0 = $i.getNAF, tj = $i.getJSF, n0 = $i.assert;
function Sa(t, e) {
  this.type = t, this.p = new ir(e.p, 16), this.red = e.prime ? ir.red(e.prime) : ir.mont(this.p), this.zero = new ir(0).toRed(this.red), this.one = new ir(1).toRed(this.red), this.two = new ir(2).toRed(this.red), this.n = e.n && new ir(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var r = this.n && this.p.div(this.n);
  !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var vc = Sa;
Sa.prototype.point = function() {
  throw new Error("Not implemented");
};
Sa.prototype.validate = function() {
  throw new Error("Not implemented");
};
Sa.prototype._fixedNafMul = function(e, r) {
  n0(e.precomputed);
  var n = e._getDoubles(), i = r0(r, 1, this._bitLength), s = (1 << n.step + 1) - (n.step % 2 === 0 ? 2 : 1);
  s /= 3;
  var o = [], a, u;
  for (a = 0; a < i.length; a += n.step) {
    u = 0;
    for (var h = a + n.step - 1; h >= a; h--)
      u = (u << 1) + i[h];
    o.push(u);
  }
  for (var d = this.jpoint(null, null, null), p = this.jpoint(null, null, null), x = s; x > 0; x--) {
    for (a = 0; a < o.length; a++)
      u = o[a], u === x ? p = p.mixedAdd(n.points[a]) : u === -x && (p = p.mixedAdd(n.points[a].neg()));
    d = d.add(p);
  }
  return d.toP();
};
Sa.prototype._wnafMul = function(e, r) {
  var n = 4, i = e._getNAFPoints(n);
  n = i.wnd;
  for (var s = i.points, o = r0(r, n, this._bitLength), a = this.jpoint(null, null, null), u = o.length - 1; u >= 0; u--) {
    for (var h = 0; u >= 0 && o[u] === 0; u--)
      h++;
    if (u >= 0 && h++, a = a.dblp(h), u < 0)
      break;
    var d = o[u];
    n0(d !== 0), e.type === "affine" ? d > 0 ? a = a.mixedAdd(s[d - 1 >> 1]) : a = a.mixedAdd(s[-d - 1 >> 1].neg()) : d > 0 ? a = a.add(s[d - 1 >> 1]) : a = a.add(s[-d - 1 >> 1].neg());
  }
  return e.type === "affine" ? a.toP() : a;
};
Sa.prototype._wnafMulAdd = function(e, r, n, i, s) {
  var o = this._wnafT1, a = this._wnafT2, u = this._wnafT3, h = 0, d, p, x;
  for (d = 0; d < i; d++) {
    x = r[d];
    var A = x._getNAFPoints(e);
    o[d] = A.wnd, a[d] = A.points;
  }
  for (d = i - 1; d >= 1; d -= 2) {
    var I = d - 1, N = d;
    if (o[I] !== 1 || o[N] !== 1) {
      u[I] = r0(n[I], o[I], this._bitLength), u[N] = r0(n[N], o[N], this._bitLength), h = Math.max(u[I].length, h), h = Math.max(u[N].length, h);
      continue;
    }
    var L = [
      r[I],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      r[N]
      /* 7 */
    ];
    r[I].y.cmp(r[N].y) === 0 ? (L[1] = r[I].add(r[N]), L[2] = r[I].toJ().mixedAdd(r[N].neg())) : r[I].y.cmp(r[N].y.redNeg()) === 0 ? (L[1] = r[I].toJ().mixedAdd(r[N]), L[2] = r[I].add(r[N].neg())) : (L[1] = r[I].toJ().mixedAdd(r[N]), L[2] = r[I].toJ().mixedAdd(r[N].neg()));
    var F = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], $ = tj(n[I], n[N]);
    for (h = Math.max($[0].length, h), u[I] = new Array(h), u[N] = new Array(h), p = 0; p < h; p++) {
      var W = $[0][p] | 0, z = $[1][p] | 0;
      u[I][p] = F[(W + 1) * 3 + (z + 1)], u[N][p] = 0, a[I] = L;
    }
  }
  var V = this.jpoint(null, null, null), te = this._wnafT4;
  for (d = h; d >= 0; d--) {
    for (var R = 0; d >= 0; ) {
      var K = !0;
      for (p = 0; p < i; p++)
        te[p] = u[p][d] | 0, te[p] !== 0 && (K = !1);
      if (!K)
        break;
      R++, d--;
    }
    if (d >= 0 && R++, V = V.dblp(R), d < 0)
      break;
    for (p = 0; p < i; p++) {
      var pe = te[p];
      pe !== 0 && (pe > 0 ? x = a[p][pe - 1 >> 1] : pe < 0 && (x = a[p][-pe - 1 >> 1].neg()), x.type === "affine" ? V = V.mixedAdd(x) : V = V.add(x));
    }
  }
  for (d = 0; d < i; d++)
    a[d] = null;
  return s ? V : V.toP();
};
function ns(t, e) {
  this.curve = t, this.type = e, this.precomputed = null;
}
Sa.BasePoint = ns;
ns.prototype.eq = function() {
  throw new Error("Not implemented");
};
ns.prototype.validate = function() {
  return this.curve.validate(this);
};
Sa.prototype.decodePoint = function(e, r) {
  e = $i.toArray(e, r);
  var n = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * n) {
    e[0] === 6 ? n0(e[e.length - 1] % 2 === 0) : e[0] === 7 && n0(e[e.length - 1] % 2 === 1);
    var i = this.point(
      e.slice(1, 1 + n),
      e.slice(1 + n, 1 + 2 * n)
    );
    return i;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n)
    return this.pointFromX(e.slice(1, 1 + n), e[0] === 3);
  throw new Error("Unknown point format");
};
ns.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
ns.prototype._encode = function(e) {
  var r = this.curve.p.byteLength(), n = this.getX().toArray("be", r);
  return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", r));
};
ns.prototype.encode = function(e, r) {
  return $i.encode(this._encode(r), e);
};
ns.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var r = {
    doubles: null,
    naf: null,
    beta: null
  };
  return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
};
ns.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var r = this.precomputed.doubles;
  return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : !1;
};
ns.prototype._getDoubles = function(e, r) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var n = [this], i = this, s = 0; s < r; s += e) {
    for (var o = 0; o < e; o++)
      i = i.dbl();
    n.push(i);
  }
  return {
    step: e,
    points: n
  };
};
ns.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var r = [this], n = (1 << e) - 1, i = n === 1 ? null : this.dbl(), s = 1; s < n; s++)
    r[s] = r[s - 1].add(i);
  return {
    wnd: e,
    points: r
  };
};
ns.prototype._getBeta = function() {
  return null;
};
ns.prototype.dblp = function(e) {
  for (var r = this, n = 0; n < e; n++)
    r = r.dbl();
  return r;
};
var Wv = ku(function(t) {
  typeof Object.create == "function" ? t.exports = function(r, n) {
    n && (r.super_ = n, r.prototype = Object.create(n.prototype, {
      constructor: {
        value: r,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : t.exports = function(r, n) {
    if (n) {
      r.super_ = n;
      var i = function() {
      };
      i.prototype = n.prototype, r.prototype = new i(), r.prototype.constructor = r;
    }
  };
}), rj = $i.assert;
function is(t) {
  vc.call(this, "short", t), this.a = new ir(t.a, 16).toRed(this.red), this.b = new ir(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
Wv(is, vc);
var nj = is;
is.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var r, n;
    if (e.beta)
      r = new ir(e.beta, 16).toRed(this.red);
    else {
      var i = this._getEndoRoots(this.p);
      r = i[0].cmp(i[1]) < 0 ? i[0] : i[1], r = r.toRed(this.red);
    }
    if (e.lambda)
      n = new ir(e.lambda, 16);
    else {
      var s = this._getEndoRoots(this.n);
      this.g.mul(s[0]).x.cmp(this.g.x.redMul(r)) === 0 ? n = s[0] : (n = s[1], rj(this.g.mul(n).x.cmp(this.g.x.redMul(r)) === 0));
    }
    var o;
    return e.basis ? o = e.basis.map(function(a) {
      return {
        a: new ir(a.a, 16),
        b: new ir(a.b, 16)
      };
    }) : o = this._getEndoBasis(n), {
      beta: r,
      lambda: n,
      basis: o
    };
  }
};
is.prototype._getEndoRoots = function(e) {
  var r = e === this.p ? this.red : ir.mont(e), n = new ir(2).toRed(r).redInvm(), i = n.redNeg(), s = new ir(3).toRed(r).redNeg().redSqrt().redMul(n), o = i.redAdd(s).fromRed(), a = i.redSub(s).fromRed();
  return [o, a];
};
is.prototype._getEndoBasis = function(e) {
  for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), n = e, i = this.n.clone(), s = new ir(1), o = new ir(0), a = new ir(0), u = new ir(1), h, d, p, x, A, I, N, L = 0, F, $; n.cmpn(0) !== 0; ) {
    var W = i.div(n);
    F = i.sub(W.mul(n)), $ = a.sub(W.mul(s));
    var z = u.sub(W.mul(o));
    if (!p && F.cmp(r) < 0)
      h = N.neg(), d = s, p = F.neg(), x = $;
    else if (p && ++L === 2)
      break;
    N = F, i = n, n = F, a = s, s = $, u = o, o = z;
  }
  A = F.neg(), I = $;
  var V = p.sqr().add(x.sqr()), te = A.sqr().add(I.sqr());
  return te.cmp(V) >= 0 && (A = h, I = d), p.negative && (p = p.neg(), x = x.neg()), A.negative && (A = A.neg(), I = I.neg()), [
    { a: p, b: x },
    { a: A, b: I }
  ];
};
is.prototype._endoSplit = function(e) {
  var r = this.endo.basis, n = r[0], i = r[1], s = i.b.mul(e).divRound(this.n), o = n.b.neg().mul(e).divRound(this.n), a = s.mul(n.a), u = o.mul(i.a), h = s.mul(n.b), d = o.mul(i.b), p = e.sub(a).sub(u), x = h.add(d).neg();
  return { k1: p, k2: x };
};
is.prototype.pointFromX = function(e, r) {
  e = new ir(e, 16), e.red || (e = e.toRed(this.red));
  var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), i = n.redSqrt();
  if (i.redSqr().redSub(n).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var s = i.fromRed().isOdd();
  return (r && !s || !r && s) && (i = i.redNeg()), this.point(e, i);
};
is.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var r = e.x, n = e.y, i = this.a.redMul(r), s = r.redSqr().redMul(r).redIAdd(i).redIAdd(this.b);
  return n.redSqr().redISub(s).cmpn(0) === 0;
};
is.prototype._endoWnafMulAdd = function(e, r, n) {
  for (var i = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < e.length; o++) {
    var a = this._endoSplit(r[o]), u = e[o], h = u._getBeta();
    a.k1.negative && (a.k1.ineg(), u = u.neg(!0)), a.k2.negative && (a.k2.ineg(), h = h.neg(!0)), i[o * 2] = u, i[o * 2 + 1] = h, s[o * 2] = a.k1, s[o * 2 + 1] = a.k2;
  }
  for (var d = this._wnafMulAdd(1, i, s, o * 2, n), p = 0; p < o * 2; p++)
    i[p] = null, s[p] = null;
  return d;
};
function Nn(t, e, r, n) {
  vc.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new ir(e, 16), this.y = new ir(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
Wv(Nn, vc.BasePoint);
is.prototype.point = function(e, r, n) {
  return new Nn(this, e, r, n);
};
is.prototype.pointFromJSON = function(e, r) {
  return Nn.fromJSON(this, e, r);
};
Nn.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var n = this.curve, i = function(s) {
        return n.point(s.x.redMul(n.endo.beta), s.y);
      };
      e.beta = r, r.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(i)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(i)
        }
      };
    }
    return r;
  }
};
Nn.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Nn.fromJSON = function(e, r, n) {
  typeof r == "string" && (r = JSON.parse(r));
  var i = e.point(r[0], r[1], n);
  if (!r[2])
    return i;
  function s(a) {
    return e.point(a[0], a[1], n);
  }
  var o = r[2];
  return i.precomputed = {
    beta: null,
    doubles: o.doubles && {
      step: o.doubles.step,
      points: [i].concat(o.doubles.points.map(s))
    },
    naf: o.naf && {
      wnd: o.naf.wnd,
      points: [i].concat(o.naf.points.map(s))
    }
  }, i;
};
Nn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Nn.prototype.isInfinity = function() {
  return this.inf;
};
Nn.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var r = this.y.redSub(e.y);
  r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
  var n = r.redSqr().redISub(this.x).redISub(e.x), i = r.redMul(this.x.redSub(n)).redISub(this.y);
  return this.curve.point(n, i);
};
Nn.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var r = this.curve.a, n = this.x.redSqr(), i = e.redInvm(), s = n.redAdd(n).redIAdd(n).redIAdd(r).redMul(i), o = s.redSqr().redISub(this.x.redAdd(this.x)), a = s.redMul(this.x.redSub(o)).redISub(this.y);
  return this.curve.point(o, a);
};
Nn.prototype.getX = function() {
  return this.x.fromRed();
};
Nn.prototype.getY = function() {
  return this.y.fromRed();
};
Nn.prototype.mul = function(e) {
  return e = new ir(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
Nn.prototype.mulAdd = function(e, r, n) {
  var i = [this, r], s = [e, n];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2);
};
Nn.prototype.jmulAdd = function(e, r, n) {
  var i = [this, r], s = [e, n];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, !0) : this.curve._wnafMulAdd(1, i, s, 2, !0);
};
Nn.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
Nn.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var r = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var n = this.precomputed, i = function(s) {
      return s.neg();
    };
    r.precomputed = {
      naf: n.naf && {
        wnd: n.naf.wnd,
        points: n.naf.points.map(i)
      },
      doubles: n.doubles && {
        step: n.doubles.step,
        points: n.doubles.points.map(i)
      }
    };
  }
  return r;
};
Nn.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function qn(t, e, r, n) {
  vc.BasePoint.call(this, t, "jacobian"), e === null && r === null && n === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new ir(0)) : (this.x = new ir(e, 16), this.y = new ir(r, 16), this.z = new ir(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
Wv(qn, vc.BasePoint);
is.prototype.jpoint = function(e, r, n) {
  return new qn(this, e, r, n);
};
qn.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), r = e.redSqr(), n = this.x.redMul(r), i = this.y.redMul(r).redMul(e);
  return this.curve.point(n, i);
};
qn.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
qn.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var r = e.z.redSqr(), n = this.z.redSqr(), i = this.x.redMul(r), s = e.x.redMul(n), o = this.y.redMul(r.redMul(e.z)), a = e.y.redMul(n.redMul(this.z)), u = i.redSub(s), h = o.redSub(a);
  if (u.cmpn(0) === 0)
    return h.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var d = u.redSqr(), p = d.redMul(u), x = i.redMul(d), A = h.redSqr().redIAdd(p).redISub(x).redISub(x), I = h.redMul(x.redISub(A)).redISub(o.redMul(p)), N = this.z.redMul(e.z).redMul(u);
  return this.curve.jpoint(A, I, N);
};
qn.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var r = this.z.redSqr(), n = this.x, i = e.x.redMul(r), s = this.y, o = e.y.redMul(r).redMul(this.z), a = n.redSub(i), u = s.redSub(o);
  if (a.cmpn(0) === 0)
    return u.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var h = a.redSqr(), d = h.redMul(a), p = n.redMul(h), x = u.redSqr().redIAdd(d).redISub(p).redISub(p), A = u.redMul(p.redISub(x)).redISub(s.redMul(d)), I = this.z.redMul(a);
  return this.curve.jpoint(x, A, I);
};
qn.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var r;
  if (this.curve.zeroA || this.curve.threeA) {
    var n = this;
    for (r = 0; r < e; r++)
      n = n.dbl();
    return n;
  }
  var i = this.curve.a, s = this.curve.tinv, o = this.x, a = this.y, u = this.z, h = u.redSqr().redSqr(), d = a.redAdd(a);
  for (r = 0; r < e; r++) {
    var p = o.redSqr(), x = d.redSqr(), A = x.redSqr(), I = p.redAdd(p).redIAdd(p).redIAdd(i.redMul(h)), N = o.redMul(x), L = I.redSqr().redISub(N.redAdd(N)), F = N.redISub(L), $ = I.redMul(F);
    $ = $.redIAdd($).redISub(A);
    var W = d.redMul(u);
    r + 1 < e && (h = h.redMul(A)), o = L, u = W, d = $;
  }
  return this.curve.jpoint(o, d.redMul(s), u);
};
qn.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
qn.prototype._zeroDbl = function() {
  var e, r, n;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
    a = a.redIAdd(a);
    var u = i.redAdd(i).redIAdd(i), h = u.redSqr().redISub(a).redISub(a), d = o.redIAdd(o);
    d = d.redIAdd(d), d = d.redIAdd(d), e = h, r = u.redMul(a.redISub(h)).redISub(d), n = this.y.redAdd(this.y);
  } else {
    var p = this.x.redSqr(), x = this.y.redSqr(), A = x.redSqr(), I = this.x.redAdd(x).redSqr().redISub(p).redISub(A);
    I = I.redIAdd(I);
    var N = p.redAdd(p).redIAdd(p), L = N.redSqr(), F = A.redIAdd(A);
    F = F.redIAdd(F), F = F.redIAdd(F), e = L.redISub(I).redISub(I), r = N.redMul(I.redISub(e)).redISub(F), n = this.y.redMul(this.z), n = n.redIAdd(n);
  }
  return this.curve.jpoint(e, r, n);
};
qn.prototype._threeDbl = function() {
  var e, r, n;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
    a = a.redIAdd(a);
    var u = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a), h = u.redSqr().redISub(a).redISub(a);
    e = h;
    var d = o.redIAdd(o);
    d = d.redIAdd(d), d = d.redIAdd(d), r = u.redMul(a.redISub(h)).redISub(d), n = this.y.redAdd(this.y);
  } else {
    var p = this.z.redSqr(), x = this.y.redSqr(), A = this.x.redMul(x), I = this.x.redSub(p).redMul(this.x.redAdd(p));
    I = I.redAdd(I).redIAdd(I);
    var N = A.redIAdd(A);
    N = N.redIAdd(N);
    var L = N.redAdd(N);
    e = I.redSqr().redISub(L), n = this.y.redAdd(this.z).redSqr().redISub(x).redISub(p);
    var F = x.redSqr();
    F = F.redIAdd(F), F = F.redIAdd(F), F = F.redIAdd(F), r = I.redMul(N.redISub(e)).redISub(F);
  }
  return this.curve.jpoint(e, r, n);
};
qn.prototype._dbl = function() {
  var e = this.curve.a, r = this.x, n = this.y, i = this.z, s = i.redSqr().redSqr(), o = r.redSqr(), a = n.redSqr(), u = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(s)), h = r.redAdd(r);
  h = h.redIAdd(h);
  var d = h.redMul(a), p = u.redSqr().redISub(d.redAdd(d)), x = d.redISub(p), A = a.redSqr();
  A = A.redIAdd(A), A = A.redIAdd(A), A = A.redIAdd(A);
  var I = u.redMul(x).redISub(A), N = n.redAdd(n).redMul(i);
  return this.curve.jpoint(p, I, N);
};
qn.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr(), i = r.redSqr(), s = e.redAdd(e).redIAdd(e), o = s.redSqr(), a = this.x.redAdd(r).redSqr().redISub(e).redISub(i);
  a = a.redIAdd(a), a = a.redAdd(a).redIAdd(a), a = a.redISub(o);
  var u = a.redSqr(), h = i.redIAdd(i);
  h = h.redIAdd(h), h = h.redIAdd(h), h = h.redIAdd(h);
  var d = s.redIAdd(a).redSqr().redISub(o).redISub(u).redISub(h), p = r.redMul(d);
  p = p.redIAdd(p), p = p.redIAdd(p);
  var x = this.x.redMul(u).redISub(p);
  x = x.redIAdd(x), x = x.redIAdd(x);
  var A = this.y.redMul(d.redMul(h.redISub(d)).redISub(a.redMul(u)));
  A = A.redIAdd(A), A = A.redIAdd(A), A = A.redIAdd(A);
  var I = this.z.redAdd(a).redSqr().redISub(n).redISub(u);
  return this.curve.jpoint(x, A, I);
};
qn.prototype.mul = function(e, r) {
  return e = new ir(e, r), this.curve._wnafMul(this, e);
};
qn.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var r = this.z.redSqr(), n = e.z.redSqr();
  if (this.x.redMul(n).redISub(e.x.redMul(r)).cmpn(0) !== 0)
    return !1;
  var i = r.redMul(this.z), s = n.redMul(e.z);
  return this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0) === 0;
};
qn.prototype.eqXToP = function(e) {
  var r = this.z.redSqr(), n = e.toRed(this.curve.red).redMul(r);
  if (this.x.cmp(n) === 0)
    return !0;
  for (var i = e.clone(), s = this.curve.redN.redMul(r); ; ) {
    if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)
      return !1;
    if (n.redIAdd(s), this.x.cmp(n) === 0)
      return !0;
  }
};
qn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
qn.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var Ad = ku(function(t, e) {
  var r = e;
  r.base = vc, r.short = nj, r.mont = /*RicMoo:ethers:require(./mont)*/
  null, r.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
}), Pd = ku(function(t, e) {
  var r = e, n = $i.assert;
  function i(a) {
    a.type === "short" ? this.curve = new Ad.short(a) : a.type === "edwards" ? this.curve = new Ad.edwards(a) : this.curve = new Ad.mont(a), this.g = this.curve.g, this.n = this.curve.n, this.hash = a.hash, n(this.g.validate(), "Invalid curve"), n(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  r.PresetCurve = i;
  function s(a, u) {
    Object.defineProperty(r, a, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var h = new i(u);
        return Object.defineProperty(r, a, {
          configurable: !0,
          enumerable: !0,
          value: h
        }), h;
      }
    });
  }
  s("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: vo.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), s("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: vo.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), s("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: vo.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), s("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: vo.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), s("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: vo.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), s("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: vo.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), s("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: vo.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var o;
  try {
    o = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch {
    o = void 0;
  }
  s("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: vo.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      o
    ]
  });
});
function ga(t) {
  if (!(this instanceof ga))
    return new ga(t);
  this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var e = ws.toArray(t.entropy, t.entropyEnc || "hex"), r = ws.toArray(t.nonce, t.nonceEnc || "hex"), n = ws.toArray(t.pers, t.persEnc || "hex");
  Hv(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(e, r, n);
}
var h8 = ga;
ga.prototype._init = function(e, r, n) {
  var i = e.concat(r).concat(n);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var s = 0; s < this.V.length; s++)
    this.K[s] = 0, this.V[s] = 1;
  this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656;
};
ga.prototype._hmac = function() {
  return new vo.hmac(this.hash, this.K);
};
ga.prototype._update = function(e) {
  var r = this._hmac().update(this.V).update([0]);
  e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
ga.prototype.reseed = function(e, r, n, i) {
  typeof r != "string" && (i = n, n = r, r = null), e = ws.toArray(e, r), n = ws.toArray(n, i), Hv(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(n || [])), this._reseed = 1;
};
ga.prototype.generate = function(e, r, n, i) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof r != "string" && (i = n, n = r, r = null), n && (n = ws.toArray(n, i || "hex"), this._update(n));
  for (var s = []; s.length < e; )
    this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
  var o = s.slice(0, e);
  return this._update(n), this._reseed++, ws.encode(o, r);
};
var E1 = $i.assert;
function Xn(t, e) {
  this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var Kv = Xn;
Xn.fromPublic = function(e, r, n) {
  return r instanceof Xn ? r : new Xn(e, {
    pub: r,
    pubEnc: n
  });
};
Xn.fromPrivate = function(e, r, n) {
  return r instanceof Xn ? r : new Xn(e, {
    priv: r,
    privEnc: n
  });
};
Xn.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
Xn.prototype.getPublic = function(e, r) {
  return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
};
Xn.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
Xn.prototype._importPrivate = function(e, r) {
  this.priv = new ir(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
Xn.prototype._importPublic = function(e, r) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? E1(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && E1(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, r);
};
Xn.prototype.derive = function(e) {
  return e.validate() || E1(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
Xn.prototype.sign = function(e, r, n) {
  return this.ec.sign(e, this, r, n);
};
Xn.prototype.verify = function(e, r) {
  return this.ec.verify(e, r, this);
};
Xn.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var ij = $i.assert;
function W0(t, e) {
  if (t instanceof W0)
    return t;
  this._importDER(t, e) || (ij(t.r && t.s, "Signature without r or s"), this.r = new ir(t.r, 16), this.s = new ir(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
}
var K0 = W0;
function sj() {
  this.place = 0;
}
function im(t, e) {
  var r = t[e.place++];
  if (!(r & 128))
    return r;
  var n = r & 15;
  if (n === 0 || n > 4)
    return !1;
  for (var i = 0, s = 0, o = e.place; s < n; s++, o++)
    i <<= 8, i |= t[o], i >>>= 0;
  return i <= 127 ? !1 : (e.place = o, i);
}
function Ex(t) {
  for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r; )
    e++;
  return e === 0 ? t : t.slice(e);
}
W0.prototype._importDER = function(e, r) {
  e = $i.toArray(e, r);
  var n = new sj();
  if (e[n.place++] !== 48)
    return !1;
  var i = im(e, n);
  if (i === !1 || i + n.place !== e.length || e[n.place++] !== 2)
    return !1;
  var s = im(e, n);
  if (s === !1)
    return !1;
  var o = e.slice(n.place, s + n.place);
  if (n.place += s, e[n.place++] !== 2)
    return !1;
  var a = im(e, n);
  if (a === !1 || e.length !== a + n.place)
    return !1;
  var u = e.slice(n.place, a + n.place);
  if (o[0] === 0)
    if (o[1] & 128)
      o = o.slice(1);
    else
      return !1;
  if (u[0] === 0)
    if (u[1] & 128)
      u = u.slice(1);
    else
      return !1;
  return this.r = new ir(o), this.s = new ir(u), this.recoveryParam = null, !0;
};
function sm(t, e) {
  if (e < 128) {
    t.push(e);
    return;
  }
  var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
  for (t.push(r | 128); --r; )
    t.push(e >>> (r << 3) & 255);
  t.push(e);
}
W0.prototype.toDER = function(e) {
  var r = this.r.toArray(), n = this.s.toArray();
  for (r[0] & 128 && (r = [0].concat(r)), n[0] & 128 && (n = [0].concat(n)), r = Ex(r), n = Ex(n); !n[0] && !(n[1] & 128); )
    n = n.slice(1);
  var i = [2];
  sm(i, r.length), i = i.concat(r), i.push(2), sm(i, n.length);
  var s = i.concat(n), o = [48];
  return sm(o, s.length), o = o.concat(s), $i.encode(o, e);
};
var oj = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
), d8 = $i.assert;
function Qi(t) {
  if (!(this instanceof Qi))
    return new Qi(t);
  typeof t == "string" && (d8(
    Object.prototype.hasOwnProperty.call(Pd, t),
    "Unknown curve " + t
  ), t = Pd[t]), t instanceof Pd.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
}
var aj = Qi;
Qi.prototype.keyPair = function(e) {
  return new Kv(this, e);
};
Qi.prototype.keyFromPrivate = function(e, r) {
  return Kv.fromPrivate(this, e, r);
};
Qi.prototype.keyFromPublic = function(e, r) {
  return Kv.fromPublic(this, e, r);
};
Qi.prototype.genKeyPair = function(e) {
  e || (e = {});
  for (var r = new h8({
    hash: this.hash,
    pers: e.pers,
    persEnc: e.persEnc || "utf8",
    entropy: e.entropy || oj(this.hash.hmacStrength),
    entropyEnc: e.entropy && e.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), n = this.n.byteLength(), i = this.n.sub(new ir(2)); ; ) {
    var s = new ir(r.generate(n));
    if (!(s.cmp(i) > 0))
      return s.iaddn(1), this.keyFromPrivate(s);
  }
};
Qi.prototype._truncateToN = function(e, r) {
  var n = e.byteLength() * 8 - this.n.bitLength();
  return n > 0 && (e = e.ushrn(n)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
};
Qi.prototype.sign = function(e, r, n, i) {
  typeof n == "object" && (i = n, n = null), i || (i = {}), r = this.keyFromPrivate(r, n), e = this._truncateToN(new ir(e, 16));
  for (var s = this.n.byteLength(), o = r.getPrivate().toArray("be", s), a = e.toArray("be", s), u = new h8({
    hash: this.hash,
    entropy: o,
    nonce: a,
    pers: i.pers,
    persEnc: i.persEnc || "utf8"
  }), h = this.n.sub(new ir(1)), d = 0; ; d++) {
    var p = i.k ? i.k(d) : new ir(u.generate(this.n.byteLength()));
    if (p = this._truncateToN(p, !0), !(p.cmpn(1) <= 0 || p.cmp(h) >= 0)) {
      var x = this.g.mul(p);
      if (!x.isInfinity()) {
        var A = x.getX(), I = A.umod(this.n);
        if (I.cmpn(0) !== 0) {
          var N = p.invm(this.n).mul(I.mul(r.getPrivate()).iadd(e));
          if (N = N.umod(this.n), N.cmpn(0) !== 0) {
            var L = (x.getY().isOdd() ? 1 : 0) | (A.cmp(I) !== 0 ? 2 : 0);
            return i.canonical && N.cmp(this.nh) > 0 && (N = this.n.sub(N), L ^= 1), new K0({ r: I, s: N, recoveryParam: L });
          }
        }
      }
    }
  }
};
Qi.prototype.verify = function(e, r, n, i) {
  e = this._truncateToN(new ir(e, 16)), n = this.keyFromPublic(n, i), r = new K0(r, "hex");
  var s = r.r, o = r.s;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0 || o.cmpn(1) < 0 || o.cmp(this.n) >= 0)
    return !1;
  var a = o.invm(this.n), u = a.mul(e).umod(this.n), h = a.mul(s).umod(this.n), d;
  return this.curve._maxwellTrick ? (d = this.g.jmulAdd(u, n.getPublic(), h), d.isInfinity() ? !1 : d.eqXToP(s)) : (d = this.g.mulAdd(u, n.getPublic(), h), d.isInfinity() ? !1 : d.getX().umod(this.n).cmp(s) === 0);
};
Qi.prototype.recoverPubKey = function(t, e, r, n) {
  d8((3 & r) === r, "The recovery param is more than two bits"), e = new K0(e, n);
  var i = this.n, s = new ir(t), o = e.r, a = e.s, u = r & 1, h = r >> 1;
  if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && h)
    throw new Error("Unable to find sencond key candinate");
  h ? o = this.curve.pointFromX(o.add(this.curve.n), u) : o = this.curve.pointFromX(o, u);
  var d = e.r.invm(i), p = i.sub(s).mul(d).umod(i), x = a.mul(d).umod(i);
  return this.g.mulAdd(p, o, x);
};
Qi.prototype.getKeyRecoveryParam = function(t, e, r, n) {
  if (e = new K0(e, n), e.recoveryParam !== null)
    return e.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var s;
    try {
      s = this.recoverPubKey(t, e, i);
    } catch {
      continue;
    }
    if (s.eq(r))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var cj = ku(function(t, e) {
  var r = e;
  r.version = "6.5.4", r.utils = $i, r.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }, r.curve = Ad, r.curves = Pd, r.ec = aj, r.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
}), uj = cj.ec;
const fj = "signing-key/5.7.0", S1 = new Yr(fj);
let om = null;
function ia() {
  return om || (om = new uj("secp256k1")), om;
}
class lj {
  constructor(e) {
    wf(this, "curve", "secp256k1"), wf(this, "privateKey", Ti(e)), mF(this.privateKey) !== 32 && S1.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    const r = ia().keyFromPrivate(wn(this.privateKey));
    wf(this, "publicKey", "0x" + r.getPublic(!1, "hex")), wf(this, "compressedPublicKey", "0x" + r.getPublic(!0, "hex")), wf(this, "_isSigningKey", !0);
  }
  _addPoint(e) {
    const r = ia().keyFromPublic(wn(this.publicKey)), n = ia().keyFromPublic(wn(e));
    return "0x" + r.pub.add(n.pub).encodeCompressed("hex");
  }
  signDigest(e) {
    const r = ia().keyFromPrivate(wn(this.privateKey)), n = wn(e);
    n.length !== 32 && S1.throwArgumentError("bad digest length", "digest", e);
    const i = r.sign(n, { canonical: !0 });
    return W4({
      recoveryParam: i.recoveryParam,
      r: uu("0x" + i.r.toString(16), 32),
      s: uu("0x" + i.s.toString(16), 32)
    });
  }
  computeSharedSecret(e) {
    const r = ia().keyFromPrivate(wn(this.privateKey)), n = ia().keyFromPublic(wn(p8(e)));
    return uu("0x" + r.derive(n.getPublic()).toString(16), 32);
  }
  static isSigningKey(e) {
    return !!(e && e._isSigningKey);
  }
}
function hj(t, e) {
  const r = W4(e), n = { r: wn(r.r), s: wn(r.s) };
  return "0x" + ia().recoverPubKey(wn(t), n, r.recoveryParam).encode("hex", !1);
}
function p8(t, e) {
  const r = wn(t);
  return r.length === 32 ? new lj(r).publicKey : r.length === 33 ? "0x" + ia().keyFromPublic(r).getPublic(!1, "hex") : r.length === 65 ? Ti(r) : S1.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
var Sx;
(function(t) {
  t[t.legacy = 0] = "legacy", t[t.eip2930 = 1] = "eip2930", t[t.eip1559 = 2] = "eip1559";
})(Sx || (Sx = {}));
function dj(t) {
  const e = p8(t);
  return MF(gx(jv(gx(e, 1)), 12));
}
function pj(t, e) {
  return dj(hj(wn(t), e));
}
var Vv = {}, V0 = {};
Object.defineProperty(V0, "__esModule", { value: !0 });
var Vn = or, A1 = ki, gj = 20;
function mj(t, e, r) {
  for (var n = 1634760805, i = 857760878, s = 2036477234, o = 1797285236, a = r[3] << 24 | r[2] << 16 | r[1] << 8 | r[0], u = r[7] << 24 | r[6] << 16 | r[5] << 8 | r[4], h = r[11] << 24 | r[10] << 16 | r[9] << 8 | r[8], d = r[15] << 24 | r[14] << 16 | r[13] << 8 | r[12], p = r[19] << 24 | r[18] << 16 | r[17] << 8 | r[16], x = r[23] << 24 | r[22] << 16 | r[21] << 8 | r[20], A = r[27] << 24 | r[26] << 16 | r[25] << 8 | r[24], I = r[31] << 24 | r[30] << 16 | r[29] << 8 | r[28], N = e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0], L = e[7] << 24 | e[6] << 16 | e[5] << 8 | e[4], F = e[11] << 24 | e[10] << 16 | e[9] << 8 | e[8], $ = e[15] << 24 | e[14] << 16 | e[13] << 8 | e[12], W = n, z = i, V = s, te = o, R = a, K = u, pe = h, _e = d, Y = p, S = x, m = A, f = I, g = N, b = L, w = F, _ = $, E = 0; E < gj; E += 2)
    W = W + R | 0, g ^= W, g = g >>> 16 | g << 16, Y = Y + g | 0, R ^= Y, R = R >>> 20 | R << 12, z = z + K | 0, b ^= z, b = b >>> 16 | b << 16, S = S + b | 0, K ^= S, K = K >>> 20 | K << 12, V = V + pe | 0, w ^= V, w = w >>> 16 | w << 16, m = m + w | 0, pe ^= m, pe = pe >>> 20 | pe << 12, te = te + _e | 0, _ ^= te, _ = _ >>> 16 | _ << 16, f = f + _ | 0, _e ^= f, _e = _e >>> 20 | _e << 12, V = V + pe | 0, w ^= V, w = w >>> 24 | w << 8, m = m + w | 0, pe ^= m, pe = pe >>> 25 | pe << 7, te = te + _e | 0, _ ^= te, _ = _ >>> 24 | _ << 8, f = f + _ | 0, _e ^= f, _e = _e >>> 25 | _e << 7, z = z + K | 0, b ^= z, b = b >>> 24 | b << 8, S = S + b | 0, K ^= S, K = K >>> 25 | K << 7, W = W + R | 0, g ^= W, g = g >>> 24 | g << 8, Y = Y + g | 0, R ^= Y, R = R >>> 25 | R << 7, W = W + K | 0, _ ^= W, _ = _ >>> 16 | _ << 16, m = m + _ | 0, K ^= m, K = K >>> 20 | K << 12, z = z + pe | 0, g ^= z, g = g >>> 16 | g << 16, f = f + g | 0, pe ^= f, pe = pe >>> 20 | pe << 12, V = V + _e | 0, b ^= V, b = b >>> 16 | b << 16, Y = Y + b | 0, _e ^= Y, _e = _e >>> 20 | _e << 12, te = te + R | 0, w ^= te, w = w >>> 16 | w << 16, S = S + w | 0, R ^= S, R = R >>> 20 | R << 12, V = V + _e | 0, b ^= V, b = b >>> 24 | b << 8, Y = Y + b | 0, _e ^= Y, _e = _e >>> 25 | _e << 7, te = te + R | 0, w ^= te, w = w >>> 24 | w << 8, S = S + w | 0, R ^= S, R = R >>> 25 | R << 7, z = z + pe | 0, g ^= z, g = g >>> 24 | g << 8, f = f + g | 0, pe ^= f, pe = pe >>> 25 | pe << 7, W = W + K | 0, _ ^= W, _ = _ >>> 24 | _ << 8, m = m + _ | 0, K ^= m, K = K >>> 25 | K << 7;
  Vn.writeUint32LE(W + n | 0, t, 0), Vn.writeUint32LE(z + i | 0, t, 4), Vn.writeUint32LE(V + s | 0, t, 8), Vn.writeUint32LE(te + o | 0, t, 12), Vn.writeUint32LE(R + a | 0, t, 16), Vn.writeUint32LE(K + u | 0, t, 20), Vn.writeUint32LE(pe + h | 0, t, 24), Vn.writeUint32LE(_e + d | 0, t, 28), Vn.writeUint32LE(Y + p | 0, t, 32), Vn.writeUint32LE(S + x | 0, t, 36), Vn.writeUint32LE(m + A | 0, t, 40), Vn.writeUint32LE(f + I | 0, t, 44), Vn.writeUint32LE(g + N | 0, t, 48), Vn.writeUint32LE(b + L | 0, t, 52), Vn.writeUint32LE(w + F | 0, t, 56), Vn.writeUint32LE(_ + $ | 0, t, 60);
}
function g8(t, e, r, n, i) {
  if (i === void 0 && (i = 0), t.length !== 32)
    throw new Error("ChaCha: key size must be 32 bytes");
  if (n.length < r.length)
    throw new Error("ChaCha: destination is shorter than source");
  var s, o;
  if (i === 0) {
    if (e.length !== 8 && e.length !== 12)
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    s = new Uint8Array(16), o = s.length - e.length, s.set(e, o);
  } else {
    if (e.length !== 16)
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    s = e, o = i;
  }
  for (var a = new Uint8Array(64), u = 0; u < r.length; u += 64) {
    mj(a, s, t);
    for (var h = u; h < u + 64 && h < r.length; h++)
      n[h] = r[h] ^ a[h - u];
    bj(s, 0, o);
  }
  return A1.wipe(a), i === 0 && A1.wipe(s), n;
}
V0.streamXOR = g8;
function vj(t, e, r, n) {
  return n === void 0 && (n = 0), A1.wipe(r), g8(t, e, r, r, n);
}
V0.stream = vj;
function bj(t, e, r) {
  for (var n = 1; r--; )
    n = n + (t[e] & 255) | 0, t[e] = n & 255, n >>>= 8, e++;
  if (n > 0)
    throw new Error("ChaCha: counter overflow");
}
var m8 = {}, Aa = {};
Object.defineProperty(Aa, "__esModule", { value: !0 });
function yj(t, e, r) {
  return ~(t - 1) & e | t - 1 & r;
}
Aa.select = yj;
function wj(t, e) {
  return (t | 0) - (e | 0) - 1 >>> 31 & 1;
}
Aa.lessOrEqual = wj;
function v8(t, e) {
  if (t.length !== e.length)
    return 0;
  for (var r = 0, n = 0; n < t.length; n++)
    r |= t[n] ^ e[n];
  return 1 & r - 1 >>> 8;
}
Aa.compare = v8;
function xj(t, e) {
  return t.length === 0 || e.length === 0 ? !1 : v8(t, e) !== 0;
}
Aa.equal = xj;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = Aa, r = ki;
  t.DIGEST_LENGTH = 16;
  var n = (
    /** @class */
    function() {
      function o(a) {
        this.digestLength = t.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
        var u = a[0] | a[1] << 8;
        this._r[0] = u & 8191;
        var h = a[2] | a[3] << 8;
        this._r[1] = (u >>> 13 | h << 3) & 8191;
        var d = a[4] | a[5] << 8;
        this._r[2] = (h >>> 10 | d << 6) & 7939;
        var p = a[6] | a[7] << 8;
        this._r[3] = (d >>> 7 | p << 9) & 8191;
        var x = a[8] | a[9] << 8;
        this._r[4] = (p >>> 4 | x << 12) & 255, this._r[5] = x >>> 1 & 8190;
        var A = a[10] | a[11] << 8;
        this._r[6] = (x >>> 14 | A << 2) & 8191;
        var I = a[12] | a[13] << 8;
        this._r[7] = (A >>> 11 | I << 5) & 8065;
        var N = a[14] | a[15] << 8;
        this._r[8] = (I >>> 8 | N << 8) & 8191, this._r[9] = N >>> 5 & 127, this._pad[0] = a[16] | a[17] << 8, this._pad[1] = a[18] | a[19] << 8, this._pad[2] = a[20] | a[21] << 8, this._pad[3] = a[22] | a[23] << 8, this._pad[4] = a[24] | a[25] << 8, this._pad[5] = a[26] | a[27] << 8, this._pad[6] = a[28] | a[29] << 8, this._pad[7] = a[30] | a[31] << 8;
      }
      return o.prototype._blocks = function(a, u, h) {
        for (var d = this._fin ? 0 : 2048, p = this._h[0], x = this._h[1], A = this._h[2], I = this._h[3], N = this._h[4], L = this._h[5], F = this._h[6], $ = this._h[7], W = this._h[8], z = this._h[9], V = this._r[0], te = this._r[1], R = this._r[2], K = this._r[3], pe = this._r[4], _e = this._r[5], Y = this._r[6], S = this._r[7], m = this._r[8], f = this._r[9]; h >= 16; ) {
          var g = a[u + 0] | a[u + 1] << 8;
          p += g & 8191;
          var b = a[u + 2] | a[u + 3] << 8;
          x += (g >>> 13 | b << 3) & 8191;
          var w = a[u + 4] | a[u + 5] << 8;
          A += (b >>> 10 | w << 6) & 8191;
          var _ = a[u + 6] | a[u + 7] << 8;
          I += (w >>> 7 | _ << 9) & 8191;
          var E = a[u + 8] | a[u + 9] << 8;
          N += (_ >>> 4 | E << 12) & 8191, L += E >>> 1 & 8191;
          var v = a[u + 10] | a[u + 11] << 8;
          F += (E >>> 14 | v << 2) & 8191;
          var M = a[u + 12] | a[u + 13] << 8;
          $ += (v >>> 11 | M << 5) & 8191;
          var P = a[u + 14] | a[u + 15] << 8;
          W += (M >>> 8 | P << 8) & 8191, z += P >>> 5 | d;
          var B = 0, ue = B;
          ue += p * V, ue += x * (5 * f), ue += A * (5 * m), ue += I * (5 * S), ue += N * (5 * Y), B = ue >>> 13, ue &= 8191, ue += L * (5 * _e), ue += F * (5 * pe), ue += $ * (5 * K), ue += W * (5 * R), ue += z * (5 * te), B += ue >>> 13, ue &= 8191;
          var D = B;
          D += p * te, D += x * V, D += A * (5 * f), D += I * (5 * m), D += N * (5 * S), B = D >>> 13, D &= 8191, D += L * (5 * Y), D += F * (5 * _e), D += $ * (5 * pe), D += W * (5 * K), D += z * (5 * R), B += D >>> 13, D &= 8191;
          var oe = B;
          oe += p * R, oe += x * te, oe += A * V, oe += I * (5 * f), oe += N * (5 * m), B = oe >>> 13, oe &= 8191, oe += L * (5 * S), oe += F * (5 * Y), oe += $ * (5 * _e), oe += W * (5 * pe), oe += z * (5 * K), B += oe >>> 13, oe &= 8191;
          var Z = B;
          Z += p * K, Z += x * R, Z += A * te, Z += I * V, Z += N * (5 * f), B = Z >>> 13, Z &= 8191, Z += L * (5 * m), Z += F * (5 * S), Z += $ * (5 * Y), Z += W * (5 * _e), Z += z * (5 * pe), B += Z >>> 13, Z &= 8191;
          var J = B;
          J += p * pe, J += x * K, J += A * R, J += I * te, J += N * V, B = J >>> 13, J &= 8191, J += L * (5 * f), J += F * (5 * m), J += $ * (5 * S), J += W * (5 * Y), J += z * (5 * _e), B += J >>> 13, J &= 8191;
          var Q = B;
          Q += p * _e, Q += x * pe, Q += A * K, Q += I * R, Q += N * te, B = Q >>> 13, Q &= 8191, Q += L * V, Q += F * (5 * f), Q += $ * (5 * m), Q += W * (5 * S), Q += z * (5 * Y), B += Q >>> 13, Q &= 8191;
          var T = B;
          T += p * Y, T += x * _e, T += A * pe, T += I * K, T += N * R, B = T >>> 13, T &= 8191, T += L * te, T += F * V, T += $ * (5 * f), T += W * (5 * m), T += z * (5 * S), B += T >>> 13, T &= 8191;
          var X = B;
          X += p * S, X += x * Y, X += A * _e, X += I * pe, X += N * K, B = X >>> 13, X &= 8191, X += L * R, X += F * te, X += $ * V, X += W * (5 * f), X += z * (5 * m), B += X >>> 13, X &= 8191;
          var re = B;
          re += p * m, re += x * S, re += A * Y, re += I * _e, re += N * pe, B = re >>> 13, re &= 8191, re += L * K, re += F * R, re += $ * te, re += W * V, re += z * (5 * f), B += re >>> 13, re &= 8191;
          var de = B;
          de += p * f, de += x * m, de += A * S, de += I * Y, de += N * _e, B = de >>> 13, de &= 8191, de += L * pe, de += F * K, de += $ * R, de += W * te, de += z * V, B += de >>> 13, de &= 8191, B = (B << 2) + B | 0, B = B + ue | 0, ue = B & 8191, B = B >>> 13, D += B, p = ue, x = D, A = oe, I = Z, N = J, L = Q, F = T, $ = X, W = re, z = de, u += 16, h -= 16;
        }
        this._h[0] = p, this._h[1] = x, this._h[2] = A, this._h[3] = I, this._h[4] = N, this._h[5] = L, this._h[6] = F, this._h[7] = $, this._h[8] = W, this._h[9] = z;
      }, o.prototype.finish = function(a, u) {
        u === void 0 && (u = 0);
        var h = new Uint16Array(10), d, p, x, A;
        if (this._leftover) {
          for (A = this._leftover, this._buffer[A++] = 1; A < 16; A++)
            this._buffer[A] = 0;
          this._fin = 1, this._blocks(this._buffer, 0, 16);
        }
        for (d = this._h[1] >>> 13, this._h[1] &= 8191, A = 2; A < 10; A++)
          this._h[A] += d, d = this._h[A] >>> 13, this._h[A] &= 8191;
        for (this._h[0] += d * 5, d = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += d, d = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += d, h[0] = this._h[0] + 5, d = h[0] >>> 13, h[0] &= 8191, A = 1; A < 10; A++)
          h[A] = this._h[A] + d, d = h[A] >>> 13, h[A] &= 8191;
        for (h[9] -= 8192, p = (d ^ 1) - 1, A = 0; A < 10; A++)
          h[A] &= p;
        for (p = ~p, A = 0; A < 10; A++)
          this._h[A] = this._h[A] & p | h[A];
        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, x = this._h[0] + this._pad[0], this._h[0] = x & 65535, A = 1; A < 8; A++)
          x = (this._h[A] + this._pad[A] | 0) + (x >>> 16) | 0, this._h[A] = x & 65535;
        return a[u + 0] = this._h[0] >>> 0, a[u + 1] = this._h[0] >>> 8, a[u + 2] = this._h[1] >>> 0, a[u + 3] = this._h[1] >>> 8, a[u + 4] = this._h[2] >>> 0, a[u + 5] = this._h[2] >>> 8, a[u + 6] = this._h[3] >>> 0, a[u + 7] = this._h[3] >>> 8, a[u + 8] = this._h[4] >>> 0, a[u + 9] = this._h[4] >>> 8, a[u + 10] = this._h[5] >>> 0, a[u + 11] = this._h[5] >>> 8, a[u + 12] = this._h[6] >>> 0, a[u + 13] = this._h[6] >>> 8, a[u + 14] = this._h[7] >>> 0, a[u + 15] = this._h[7] >>> 8, this._finished = !0, this;
      }, o.prototype.update = function(a) {
        var u = 0, h = a.length, d;
        if (this._leftover) {
          d = 16 - this._leftover, d > h && (d = h);
          for (var p = 0; p < d; p++)
            this._buffer[this._leftover + p] = a[u + p];
          if (h -= d, u += d, this._leftover += d, this._leftover < 16)
            return this;
          this._blocks(this._buffer, 0, 16), this._leftover = 0;
        }
        if (h >= 16 && (d = h - h % 16, this._blocks(a, u, d), u += d, h -= d), h) {
          for (var p = 0; p < h; p++)
            this._buffer[this._leftover + p] = a[u + p];
          this._leftover += h;
        }
        return this;
      }, o.prototype.digest = function() {
        if (this._finished)
          throw new Error("Poly1305 was finished");
        var a = new Uint8Array(16);
        return this.finish(a), a;
      }, o.prototype.clean = function() {
        return r.wipe(this._buffer), r.wipe(this._r), r.wipe(this._h), r.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;
      }, o;
    }()
  );
  t.Poly1305 = n;
  function i(o, a) {
    var u = new n(o);
    u.update(a);
    var h = u.digest();
    return u.clean(), h;
  }
  t.oneTimeAuth = i;
  function s(o, a) {
    return o.length !== t.DIGEST_LENGTH || a.length !== t.DIGEST_LENGTH ? !1 : e.equal(o, a);
  }
  t.equal = s;
})(m8);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = V0, r = m8, n = ki, i = or, s = Aa;
  t.KEY_LENGTH = 32, t.NONCE_LENGTH = 12, t.TAG_LENGTH = 16;
  var o = new Uint8Array(16), a = (
    /** @class */
    function() {
      function u(h) {
        if (this.nonceLength = t.NONCE_LENGTH, this.tagLength = t.TAG_LENGTH, h.length !== t.KEY_LENGTH)
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(h);
      }
      return u.prototype.seal = function(h, d, p, x) {
        if (h.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        var A = new Uint8Array(16);
        A.set(h, A.length - h.length);
        var I = new Uint8Array(32);
        e.stream(this._key, A, I, 4);
        var N = d.length + this.tagLength, L;
        if (x) {
          if (x.length !== N)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          L = x;
        } else
          L = new Uint8Array(N);
        return e.streamXOR(this._key, A, d, L, 4), this._authenticate(L.subarray(L.length - this.tagLength, L.length), I, L.subarray(0, L.length - this.tagLength), p), n.wipe(A), L;
      }, u.prototype.open = function(h, d, p, x) {
        if (h.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        if (d.length < this.tagLength)
          return null;
        var A = new Uint8Array(16);
        A.set(h, A.length - h.length);
        var I = new Uint8Array(32);
        e.stream(this._key, A, I, 4);
        var N = new Uint8Array(this.tagLength);
        if (this._authenticate(N, I, d.subarray(0, d.length - this.tagLength), p), !s.equal(N, d.subarray(d.length - this.tagLength, d.length)))
          return null;
        var L = d.length - this.tagLength, F;
        if (x) {
          if (x.length !== L)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          F = x;
        } else
          F = new Uint8Array(L);
        return e.streamXOR(this._key, A, d.subarray(0, d.length - this.tagLength), F, 4), n.wipe(A), F;
      }, u.prototype.clean = function() {
        return n.wipe(this._key), this;
      }, u.prototype._authenticate = function(h, d, p, x) {
        var A = new r.Poly1305(d);
        x && (A.update(x), x.length % 16 > 0 && A.update(o.subarray(x.length % 16))), A.update(p), p.length % 16 > 0 && A.update(o.subarray(p.length % 16));
        var I = new Uint8Array(8);
        x && i.writeUint64LE(x.length, I), A.update(I), i.writeUint64LE(p.length, I), A.update(I);
        for (var N = A.digest(), L = 0; L < N.length; L++)
          h[L] = N[L];
        A.clean(), n.wipe(N), n.wipe(I);
      }, u;
    }()
  );
  t.ChaCha20Poly1305 = a;
})(Vv);
var b8 = {}, Vl = {}, Gv = {};
Object.defineProperty(Gv, "__esModule", { value: !0 });
function _j(t) {
  return typeof t.saveState < "u" && typeof t.restoreState < "u" && typeof t.cleanSavedState < "u";
}
Gv.isSerializableHash = _j;
Object.defineProperty(Vl, "__esModule", { value: !0 });
var Os = Gv, Ej = Aa, Sj = ki, y8 = (
  /** @class */
  function() {
    function t(e, r) {
      this._finished = !1, this._inner = new e(), this._outer = new e(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
      var n = new Uint8Array(this.blockSize);
      r.length > this.blockSize ? this._inner.update(r).finish(n).clean() : n.set(r);
      for (var i = 0; i < n.length; i++)
        n[i] ^= 54;
      this._inner.update(n);
      for (var i = 0; i < n.length; i++)
        n[i] ^= 106;
      this._outer.update(n), Os.isSerializableHash(this._inner) && Os.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), Sj.wipe(n);
    }
    return t.prototype.reset = function() {
      if (!Os.isSerializableHash(this._inner) || !Os.isSerializableHash(this._outer))
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, t.prototype.clean = function() {
      Os.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), Os.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();
    }, t.prototype.update = function(e) {
      return this._inner.update(e), this;
    }, t.prototype.finish = function(e) {
      return this._finished ? (this._outer.finish(e), this) : (this._inner.finish(e), this._outer.update(e.subarray(0, this.digestLength)).finish(e), this._finished = !0, this);
    }, t.prototype.digest = function() {
      var e = new Uint8Array(this.digestLength);
      return this.finish(e), e;
    }, t.prototype.saveState = function() {
      if (!Os.isSerializableHash(this._inner))
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      return this._inner.saveState();
    }, t.prototype.restoreState = function(e) {
      if (!Os.isSerializableHash(this._inner) || !Os.isSerializableHash(this._outer))
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      return this._inner.restoreState(e), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, t.prototype.cleanSavedState = function(e) {
      if (!Os.isSerializableHash(this._inner))
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      this._inner.cleanSavedState(e);
    }, t;
  }()
);
Vl.HMAC = y8;
function Aj(t, e, r) {
  var n = new y8(t, e);
  n.update(r);
  var i = n.digest();
  return n.clean(), i;
}
Vl.hmac = Aj;
Vl.equal = Ej.equal;
Object.defineProperty(b8, "__esModule", { value: !0 });
var Ax = Vl, Px = ki, Pj = (
  /** @class */
  function() {
    function t(e, r, n, i) {
      n === void 0 && (n = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = e, this._info = i;
      var s = Ax.hmac(this._hash, n, r);
      this._hmac = new Ax.HMAC(e, s), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;
    }
    return t.prototype._fillBuffer = function() {
      this._counter[0]++;
      var e = this._counter[0];
      if (e === 0)
        throw new Error("hkdf: cannot expand more");
      this._hmac.reset(), e > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;
    }, t.prototype.expand = function(e) {
      for (var r = new Uint8Array(e), n = 0; n < r.length; n++)
        this._bufpos === this._buffer.length && this._fillBuffer(), r[n] = this._buffer[this._bufpos++];
      return r;
    }, t.prototype.clean = function() {
      this._hmac.clean(), Px.wipe(this._buffer), Px.wipe(this._counter), this._bufpos = 0;
    }, t;
  }()
), Mj = b8.HKDF = Pj, Gl = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = or, r = ki;
  t.DIGEST_LENGTH = 32, t.BLOCK_SIZE = 64;
  var n = (
    /** @class */
    function() {
      function a() {
        this.digestLength = t.DIGEST_LENGTH, this.blockSize = t.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return a.prototype._initState = function() {
        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
      }, a.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, a.prototype.clean = function() {
        r.wipe(this._buffer), r.wipe(this._temp), this.reset();
      }, a.prototype.update = function(u, h) {
        if (h === void 0 && (h = u.length), this._finished)
          throw new Error("SHA256: can't update because hash was finished.");
        var d = 0;
        if (this._bytesHashed += h, this._bufferLength > 0) {
          for (; this._bufferLength < this.blockSize && h > 0; )
            this._buffer[this._bufferLength++] = u[d++], h--;
          this._bufferLength === this.blockSize && (s(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (h >= this.blockSize && (d = s(this._temp, this._state, u, d, h), h %= this.blockSize); h > 0; )
          this._buffer[this._bufferLength++] = u[d++], h--;
        return this;
      }, a.prototype.finish = function(u) {
        if (!this._finished) {
          var h = this._bytesHashed, d = this._bufferLength, p = h / 536870912 | 0, x = h << 3, A = h % 64 < 56 ? 64 : 128;
          this._buffer[d] = 128;
          for (var I = d + 1; I < A - 8; I++)
            this._buffer[I] = 0;
          e.writeUint32BE(p, this._buffer, A - 8), e.writeUint32BE(x, this._buffer, A - 4), s(this._temp, this._state, this._buffer, 0, A), this._finished = !0;
        }
        for (var I = 0; I < this.digestLength / 4; I++)
          e.writeUint32BE(this._state[I], u, I * 4);
        return this;
      }, a.prototype.digest = function() {
        var u = new Uint8Array(this.digestLength);
        return this.finish(u), u;
      }, a.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, a.prototype.restoreState = function(u) {
        return this._state.set(u.state), this._bufferLength = u.bufferLength, u.buffer && this._buffer.set(u.buffer), this._bytesHashed = u.bytesHashed, this._finished = !1, this;
      }, a.prototype.cleanSavedState = function(u) {
        r.wipe(u.state), u.buffer && r.wipe(u.buffer), u.bufferLength = 0, u.bytesHashed = 0;
      }, a;
    }()
  );
  t.SHA256 = n;
  var i = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function s(a, u, h, d, p) {
    for (; p >= 64; ) {
      for (var x = u[0], A = u[1], I = u[2], N = u[3], L = u[4], F = u[5], $ = u[6], W = u[7], z = 0; z < 16; z++) {
        var V = d + z * 4;
        a[z] = e.readUint32BE(h, V);
      }
      for (var z = 16; z < 64; z++) {
        var te = a[z - 2], R = (te >>> 17 | te << 15) ^ (te >>> 19 | te << 13) ^ te >>> 10;
        te = a[z - 15];
        var K = (te >>> 7 | te << 25) ^ (te >>> 18 | te << 14) ^ te >>> 3;
        a[z] = (R + a[z - 7] | 0) + (K + a[z - 16] | 0);
      }
      for (var z = 0; z < 64; z++) {
        var R = (((L >>> 6 | L << 26) ^ (L >>> 11 | L << 21) ^ (L >>> 25 | L << 7)) + (L & F ^ ~L & $) | 0) + (W + (i[z] + a[z] | 0) | 0) | 0, K = ((x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)) + (x & A ^ x & I ^ A & I) | 0;
        W = $, $ = F, F = L, L = N + R | 0, N = I, I = A, A = x, x = R + K | 0;
      }
      u[0] += x, u[1] += A, u[2] += I, u[3] += N, u[4] += L, u[5] += F, u[6] += $, u[7] += W, d += 64, p -= 64;
    }
    return d;
  }
  function o(a) {
    var u = new n();
    u.update(a);
    var h = u.digest();
    return u.clean(), h;
  }
  t.hash = o;
})(Gl);
var Yv = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.sharedKey = t.generateKeyPair = t.generateKeyPairFromSeed = t.scalarMultBase = t.scalarMult = t.SHARED_KEY_LENGTH = t.SECRET_KEY_LENGTH = t.PUBLIC_KEY_LENGTH = void 0;
  const e = Ea, r = ki;
  t.PUBLIC_KEY_LENGTH = 32, t.SECRET_KEY_LENGTH = 32, t.SHARED_KEY_LENGTH = 32;
  function n(z) {
    const V = new Float64Array(16);
    if (z)
      for (let te = 0; te < z.length; te++)
        V[te] = z[te];
    return V;
  }
  const i = new Uint8Array(32);
  i[0] = 9;
  const s = n([56129, 1]);
  function o(z) {
    let V = 1;
    for (let te = 0; te < 16; te++) {
      let R = z[te] + V + 65535;
      V = Math.floor(R / 65536), z[te] = R - V * 65536;
    }
    z[0] += V - 1 + 37 * (V - 1);
  }
  function a(z, V, te) {
    const R = ~(te - 1);
    for (let K = 0; K < 16; K++) {
      const pe = R & (z[K] ^ V[K]);
      z[K] ^= pe, V[K] ^= pe;
    }
  }
  function u(z, V) {
    const te = n(), R = n();
    for (let K = 0; K < 16; K++)
      R[K] = V[K];
    o(R), o(R), o(R);
    for (let K = 0; K < 2; K++) {
      te[0] = R[0] - 65517;
      for (let _e = 1; _e < 15; _e++)
        te[_e] = R[_e] - 65535 - (te[_e - 1] >> 16 & 1), te[_e - 1] &= 65535;
      te[15] = R[15] - 32767 - (te[14] >> 16 & 1);
      const pe = te[15] >> 16 & 1;
      te[14] &= 65535, a(R, te, 1 - pe);
    }
    for (let K = 0; K < 16; K++)
      z[2 * K] = R[K] & 255, z[2 * K + 1] = R[K] >> 8;
  }
  function h(z, V) {
    for (let te = 0; te < 16; te++)
      z[te] = V[2 * te] + (V[2 * te + 1] << 8);
    z[15] &= 32767;
  }
  function d(z, V, te) {
    for (let R = 0; R < 16; R++)
      z[R] = V[R] + te[R];
  }
  function p(z, V, te) {
    for (let R = 0; R < 16; R++)
      z[R] = V[R] - te[R];
  }
  function x(z, V, te) {
    let R, K, pe = 0, _e = 0, Y = 0, S = 0, m = 0, f = 0, g = 0, b = 0, w = 0, _ = 0, E = 0, v = 0, M = 0, P = 0, B = 0, ue = 0, D = 0, oe = 0, Z = 0, J = 0, Q = 0, T = 0, X = 0, re = 0, de = 0, ie = 0, ce = 0, me = 0, Pe = 0, De = 0, Ce = 0, $e = te[0], Me = te[1], Ne = te[2], Ke = te[3], Le = te[4], qe = te[5], ze = te[6], Ee = te[7], Ze = te[8], at = te[9], ke = te[10], Qe = te[11], tt = te[12], Ye = te[13], dt = te[14], lt = te[15];
    R = V[0], pe += R * $e, _e += R * Me, Y += R * Ne, S += R * Ke, m += R * Le, f += R * qe, g += R * ze, b += R * Ee, w += R * Ze, _ += R * at, E += R * ke, v += R * Qe, M += R * tt, P += R * Ye, B += R * dt, ue += R * lt, R = V[1], _e += R * $e, Y += R * Me, S += R * Ne, m += R * Ke, f += R * Le, g += R * qe, b += R * ze, w += R * Ee, _ += R * Ze, E += R * at, v += R * ke, M += R * Qe, P += R * tt, B += R * Ye, ue += R * dt, D += R * lt, R = V[2], Y += R * $e, S += R * Me, m += R * Ne, f += R * Ke, g += R * Le, b += R * qe, w += R * ze, _ += R * Ee, E += R * Ze, v += R * at, M += R * ke, P += R * Qe, B += R * tt, ue += R * Ye, D += R * dt, oe += R * lt, R = V[3], S += R * $e, m += R * Me, f += R * Ne, g += R * Ke, b += R * Le, w += R * qe, _ += R * ze, E += R * Ee, v += R * Ze, M += R * at, P += R * ke, B += R * Qe, ue += R * tt, D += R * Ye, oe += R * dt, Z += R * lt, R = V[4], m += R * $e, f += R * Me, g += R * Ne, b += R * Ke, w += R * Le, _ += R * qe, E += R * ze, v += R * Ee, M += R * Ze, P += R * at, B += R * ke, ue += R * Qe, D += R * tt, oe += R * Ye, Z += R * dt, J += R * lt, R = V[5], f += R * $e, g += R * Me, b += R * Ne, w += R * Ke, _ += R * Le, E += R * qe, v += R * ze, M += R * Ee, P += R * Ze, B += R * at, ue += R * ke, D += R * Qe, oe += R * tt, Z += R * Ye, J += R * dt, Q += R * lt, R = V[6], g += R * $e, b += R * Me, w += R * Ne, _ += R * Ke, E += R * Le, v += R * qe, M += R * ze, P += R * Ee, B += R * Ze, ue += R * at, D += R * ke, oe += R * Qe, Z += R * tt, J += R * Ye, Q += R * dt, T += R * lt, R = V[7], b += R * $e, w += R * Me, _ += R * Ne, E += R * Ke, v += R * Le, M += R * qe, P += R * ze, B += R * Ee, ue += R * Ze, D += R * at, oe += R * ke, Z += R * Qe, J += R * tt, Q += R * Ye, T += R * dt, X += R * lt, R = V[8], w += R * $e, _ += R * Me, E += R * Ne, v += R * Ke, M += R * Le, P += R * qe, B += R * ze, ue += R * Ee, D += R * Ze, oe += R * at, Z += R * ke, J += R * Qe, Q += R * tt, T += R * Ye, X += R * dt, re += R * lt, R = V[9], _ += R * $e, E += R * Me, v += R * Ne, M += R * Ke, P += R * Le, B += R * qe, ue += R * ze, D += R * Ee, oe += R * Ze, Z += R * at, J += R * ke, Q += R * Qe, T += R * tt, X += R * Ye, re += R * dt, de += R * lt, R = V[10], E += R * $e, v += R * Me, M += R * Ne, P += R * Ke, B += R * Le, ue += R * qe, D += R * ze, oe += R * Ee, Z += R * Ze, J += R * at, Q += R * ke, T += R * Qe, X += R * tt, re += R * Ye, de += R * dt, ie += R * lt, R = V[11], v += R * $e, M += R * Me, P += R * Ne, B += R * Ke, ue += R * Le, D += R * qe, oe += R * ze, Z += R * Ee, J += R * Ze, Q += R * at, T += R * ke, X += R * Qe, re += R * tt, de += R * Ye, ie += R * dt, ce += R * lt, R = V[12], M += R * $e, P += R * Me, B += R * Ne, ue += R * Ke, D += R * Le, oe += R * qe, Z += R * ze, J += R * Ee, Q += R * Ze, T += R * at, X += R * ke, re += R * Qe, de += R * tt, ie += R * Ye, ce += R * dt, me += R * lt, R = V[13], P += R * $e, B += R * Me, ue += R * Ne, D += R * Ke, oe += R * Le, Z += R * qe, J += R * ze, Q += R * Ee, T += R * Ze, X += R * at, re += R * ke, de += R * Qe, ie += R * tt, ce += R * Ye, me += R * dt, Pe += R * lt, R = V[14], B += R * $e, ue += R * Me, D += R * Ne, oe += R * Ke, Z += R * Le, J += R * qe, Q += R * ze, T += R * Ee, X += R * Ze, re += R * at, de += R * ke, ie += R * Qe, ce += R * tt, me += R * Ye, Pe += R * dt, De += R * lt, R = V[15], ue += R * $e, D += R * Me, oe += R * Ne, Z += R * Ke, J += R * Le, Q += R * qe, T += R * ze, X += R * Ee, re += R * Ze, de += R * at, ie += R * ke, ce += R * Qe, me += R * tt, Pe += R * Ye, De += R * dt, Ce += R * lt, pe += 38 * D, _e += 38 * oe, Y += 38 * Z, S += 38 * J, m += 38 * Q, f += 38 * T, g += 38 * X, b += 38 * re, w += 38 * de, _ += 38 * ie, E += 38 * ce, v += 38 * me, M += 38 * Pe, P += 38 * De, B += 38 * Ce, K = 1, R = pe + K + 65535, K = Math.floor(R / 65536), pe = R - K * 65536, R = _e + K + 65535, K = Math.floor(R / 65536), _e = R - K * 65536, R = Y + K + 65535, K = Math.floor(R / 65536), Y = R - K * 65536, R = S + K + 65535, K = Math.floor(R / 65536), S = R - K * 65536, R = m + K + 65535, K = Math.floor(R / 65536), m = R - K * 65536, R = f + K + 65535, K = Math.floor(R / 65536), f = R - K * 65536, R = g + K + 65535, K = Math.floor(R / 65536), g = R - K * 65536, R = b + K + 65535, K = Math.floor(R / 65536), b = R - K * 65536, R = w + K + 65535, K = Math.floor(R / 65536), w = R - K * 65536, R = _ + K + 65535, K = Math.floor(R / 65536), _ = R - K * 65536, R = E + K + 65535, K = Math.floor(R / 65536), E = R - K * 65536, R = v + K + 65535, K = Math.floor(R / 65536), v = R - K * 65536, R = M + K + 65535, K = Math.floor(R / 65536), M = R - K * 65536, R = P + K + 65535, K = Math.floor(R / 65536), P = R - K * 65536, R = B + K + 65535, K = Math.floor(R / 65536), B = R - K * 65536, R = ue + K + 65535, K = Math.floor(R / 65536), ue = R - K * 65536, pe += K - 1 + 37 * (K - 1), K = 1, R = pe + K + 65535, K = Math.floor(R / 65536), pe = R - K * 65536, R = _e + K + 65535, K = Math.floor(R / 65536), _e = R - K * 65536, R = Y + K + 65535, K = Math.floor(R / 65536), Y = R - K * 65536, R = S + K + 65535, K = Math.floor(R / 65536), S = R - K * 65536, R = m + K + 65535, K = Math.floor(R / 65536), m = R - K * 65536, R = f + K + 65535, K = Math.floor(R / 65536), f = R - K * 65536, R = g + K + 65535, K = Math.floor(R / 65536), g = R - K * 65536, R = b + K + 65535, K = Math.floor(R / 65536), b = R - K * 65536, R = w + K + 65535, K = Math.floor(R / 65536), w = R - K * 65536, R = _ + K + 65535, K = Math.floor(R / 65536), _ = R - K * 65536, R = E + K + 65535, K = Math.floor(R / 65536), E = R - K * 65536, R = v + K + 65535, K = Math.floor(R / 65536), v = R - K * 65536, R = M + K + 65535, K = Math.floor(R / 65536), M = R - K * 65536, R = P + K + 65535, K = Math.floor(R / 65536), P = R - K * 65536, R = B + K + 65535, K = Math.floor(R / 65536), B = R - K * 65536, R = ue + K + 65535, K = Math.floor(R / 65536), ue = R - K * 65536, pe += K - 1 + 37 * (K - 1), z[0] = pe, z[1] = _e, z[2] = Y, z[3] = S, z[4] = m, z[5] = f, z[6] = g, z[7] = b, z[8] = w, z[9] = _, z[10] = E, z[11] = v, z[12] = M, z[13] = P, z[14] = B, z[15] = ue;
  }
  function A(z, V) {
    x(z, V, V);
  }
  function I(z, V) {
    const te = n();
    for (let R = 0; R < 16; R++)
      te[R] = V[R];
    for (let R = 253; R >= 0; R--)
      A(te, te), R !== 2 && R !== 4 && x(te, te, V);
    for (let R = 0; R < 16; R++)
      z[R] = te[R];
  }
  function N(z, V) {
    const te = new Uint8Array(32), R = new Float64Array(80), K = n(), pe = n(), _e = n(), Y = n(), S = n(), m = n();
    for (let w = 0; w < 31; w++)
      te[w] = z[w];
    te[31] = z[31] & 127 | 64, te[0] &= 248, h(R, V);
    for (let w = 0; w < 16; w++)
      pe[w] = R[w];
    K[0] = Y[0] = 1;
    for (let w = 254; w >= 0; --w) {
      const _ = te[w >>> 3] >>> (w & 7) & 1;
      a(K, pe, _), a(_e, Y, _), d(S, K, _e), p(K, K, _e), d(_e, pe, Y), p(pe, pe, Y), A(Y, S), A(m, K), x(K, _e, K), x(_e, pe, S), d(S, K, _e), p(K, K, _e), A(pe, K), p(_e, Y, m), x(K, _e, s), d(K, K, Y), x(_e, _e, K), x(K, Y, m), x(Y, pe, R), A(pe, S), a(K, pe, _), a(_e, Y, _);
    }
    for (let w = 0; w < 16; w++)
      R[w + 16] = K[w], R[w + 32] = _e[w], R[w + 48] = pe[w], R[w + 64] = Y[w];
    const f = R.subarray(32), g = R.subarray(16);
    I(f, f), x(g, g, f);
    const b = new Uint8Array(32);
    return u(b, g), b;
  }
  t.scalarMult = N;
  function L(z) {
    return N(z, i);
  }
  t.scalarMultBase = L;
  function F(z) {
    if (z.length !== t.SECRET_KEY_LENGTH)
      throw new Error(`x25519: seed must be ${t.SECRET_KEY_LENGTH} bytes`);
    const V = new Uint8Array(z);
    return {
      publicKey: L(V),
      secretKey: V
    };
  }
  t.generateKeyPairFromSeed = F;
  function $(z) {
    const V = (0, e.randomBytes)(32, z), te = F(V);
    return (0, r.wipe)(V), te;
  }
  t.generateKeyPair = $;
  function W(z, V, te = !1) {
    if (z.length !== t.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect secret key length");
    if (V.length !== t.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect public key length");
    const R = N(z, V);
    if (te) {
      let K = 0;
      for (let pe = 0; pe < R.length; pe++)
        K |= R[pe];
      if (K === 0)
        throw new Error("X25519: invalid shared key");
    }
    return R;
  }
  t.sharedKey = W;
})(Yv);
var w8 = {};
const Ij = "elliptic", Cj = "6.6.0", Tj = "EC cryptography", Rj = "lib/elliptic.js", Dj = [
  "lib"
], Oj = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, Nj = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, Lj = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], kj = "Fedor Indutny <fedor@indutny.com>", $j = "MIT", Bj = {
  url: "https://github.com/indutny/elliptic/issues"
}, Fj = "https://github.com/indutny/elliptic", Uj = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, jj = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, qj = {
  name: Ij,
  version: Cj,
  description: Tj,
  main: Rj,
  files: Dj,
  scripts: Oj,
  repository: Nj,
  keywords: Lj,
  author: kj,
  license: $j,
  bugs: Bj,
  homepage: Fj,
  devDependencies: Uj,
  dependencies: jj
};
var Bi = {}, Jv = { exports: {} };
Jv.exports;
(function(t) {
  (function(e, r) {
    function n(Y, S) {
      if (!Y) throw new Error(S || "Assertion failed");
    }
    function i(Y, S) {
      Y.super_ = S;
      var m = function() {
      };
      m.prototype = S.prototype, Y.prototype = new m(), Y.prototype.constructor = Y;
    }
    function s(Y, S, m) {
      if (s.isBN(Y))
        return Y;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, Y !== null && ((S === "le" || S === "be") && (m = S, S = 10), this._init(Y || 0, S || 10, m || "be"));
    }
    typeof e == "object" ? e.exports = s : r.BN = s, s.BN = s, s.wordSize = 26;
    var o;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = zl.Buffer;
    } catch {
    }
    s.isBN = function(S) {
      return S instanceof s ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === s.wordSize && Array.isArray(S.words);
    }, s.max = function(S, m) {
      return S.cmp(m) > 0 ? S : m;
    }, s.min = function(S, m) {
      return S.cmp(m) < 0 ? S : m;
    }, s.prototype._init = function(S, m, f) {
      if (typeof S == "number")
        return this._initNumber(S, m, f);
      if (typeof S == "object")
        return this._initArray(S, m, f);
      m === "hex" && (m = 16), n(m === (m | 0) && m >= 2 && m <= 36), S = S.toString().replace(/\s+/g, "");
      var g = 0;
      S[0] === "-" && (g++, this.negative = 1), g < S.length && (m === 16 ? this._parseHex(S, g, f) : (this._parseBase(S, m, g), f === "le" && this._initArray(this.toArray(), m, f)));
    }, s.prototype._initNumber = function(S, m, f) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (n(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), f === "le" && this._initArray(this.toArray(), m, f);
    }, s.prototype._initArray = function(S, m, f) {
      if (n(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var g = 0; g < this.length; g++)
        this.words[g] = 0;
      var b, w, _ = 0;
      if (f === "be")
        for (g = S.length - 1, b = 0; g >= 0; g -= 3)
          w = S[g] | S[g - 1] << 8 | S[g - 2] << 16, this.words[b] |= w << _ & 67108863, this.words[b + 1] = w >>> 26 - _ & 67108863, _ += 24, _ >= 26 && (_ -= 26, b++);
      else if (f === "le")
        for (g = 0, b = 0; g < S.length; g += 3)
          w = S[g] | S[g + 1] << 8 | S[g + 2] << 16, this.words[b] |= w << _ & 67108863, this.words[b + 1] = w >>> 26 - _ & 67108863, _ += 24, _ >= 26 && (_ -= 26, b++);
      return this.strip();
    };
    function a(Y, S) {
      var m = Y.charCodeAt(S);
      return m >= 65 && m <= 70 ? m - 55 : m >= 97 && m <= 102 ? m - 87 : m - 48 & 15;
    }
    function u(Y, S, m) {
      var f = a(Y, m);
      return m - 1 >= S && (f |= a(Y, m - 1) << 4), f;
    }
    s.prototype._parseHex = function(S, m, f) {
      this.length = Math.ceil((S.length - m) / 6), this.words = new Array(this.length);
      for (var g = 0; g < this.length; g++)
        this.words[g] = 0;
      var b = 0, w = 0, _;
      if (f === "be")
        for (g = S.length - 1; g >= m; g -= 2)
          _ = u(S, m, g) << b, this.words[w] |= _ & 67108863, b >= 18 ? (b -= 18, w += 1, this.words[w] |= _ >>> 26) : b += 8;
      else {
        var E = S.length - m;
        for (g = E % 2 === 0 ? m + 1 : m; g < S.length; g += 2)
          _ = u(S, m, g) << b, this.words[w] |= _ & 67108863, b >= 18 ? (b -= 18, w += 1, this.words[w] |= _ >>> 26) : b += 8;
      }
      this.strip();
    };
    function h(Y, S, m, f) {
      for (var g = 0, b = Math.min(Y.length, m), w = S; w < b; w++) {
        var _ = Y.charCodeAt(w) - 48;
        g *= f, _ >= 49 ? g += _ - 49 + 10 : _ >= 17 ? g += _ - 17 + 10 : g += _;
      }
      return g;
    }
    s.prototype._parseBase = function(S, m, f) {
      this.words = [0], this.length = 1;
      for (var g = 0, b = 1; b <= 67108863; b *= m)
        g++;
      g--, b = b / m | 0;
      for (var w = S.length - f, _ = w % g, E = Math.min(w, w - _) + f, v = 0, M = f; M < E; M += g)
        v = h(S, M, M + g, m), this.imuln(b), this.words[0] + v < 67108864 ? this.words[0] += v : this._iaddn(v);
      if (_ !== 0) {
        var P = 1;
        for (v = h(S, M, S.length, m), M = 0; M < _; M++)
          P *= m;
        this.imuln(P), this.words[0] + v < 67108864 ? this.words[0] += v : this._iaddn(v);
      }
      this.strip();
    }, s.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var m = 0; m < this.length; m++)
        S.words[m] = this.words[m];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, s.prototype.clone = function() {
      var S = new s(null);
      return this.copy(S), S;
    }, s.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, s.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, s.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, s.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var d = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], p = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], x = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    s.prototype.toString = function(S, m) {
      S = S || 10, m = m | 0 || 1;
      var f;
      if (S === 16 || S === "hex") {
        f = "";
        for (var g = 0, b = 0, w = 0; w < this.length; w++) {
          var _ = this.words[w], E = ((_ << g | b) & 16777215).toString(16);
          b = _ >>> 24 - g & 16777215, g += 2, g >= 26 && (g -= 26, w--), b !== 0 || w !== this.length - 1 ? f = d[6 - E.length] + E + f : f = E + f;
        }
        for (b !== 0 && (f = b.toString(16) + f); f.length % m !== 0; )
          f = "0" + f;
        return this.negative !== 0 && (f = "-" + f), f;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var v = p[S], M = x[S];
        f = "";
        var P = this.clone();
        for (P.negative = 0; !P.isZero(); ) {
          var B = P.modn(M).toString(S);
          P = P.idivn(M), P.isZero() ? f = B + f : f = d[v - B.length] + B + f;
        }
        for (this.isZero() && (f = "0" + f); f.length % m !== 0; )
          f = "0" + f;
        return this.negative !== 0 && (f = "-" + f), f;
      }
      n(!1, "Base should be between 2 and 36");
    }, s.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, s.prototype.toJSON = function() {
      return this.toString(16);
    }, s.prototype.toBuffer = function(S, m) {
      return n(typeof o < "u"), this.toArrayLike(o, S, m);
    }, s.prototype.toArray = function(S, m) {
      return this.toArrayLike(Array, S, m);
    }, s.prototype.toArrayLike = function(S, m, f) {
      var g = this.byteLength(), b = f || Math.max(1, g);
      n(g <= b, "byte array longer than desired length"), n(b > 0, "Requested array length <= 0"), this.strip();
      var w = m === "le", _ = new S(b), E, v, M = this.clone();
      if (w) {
        for (v = 0; !M.isZero(); v++)
          E = M.andln(255), M.iushrn(8), _[v] = E;
        for (; v < b; v++)
          _[v] = 0;
      } else {
        for (v = 0; v < b - g; v++)
          _[v] = 0;
        for (v = 0; !M.isZero(); v++)
          E = M.andln(255), M.iushrn(8), _[b - v - 1] = E;
      }
      return _;
    }, Math.clz32 ? s.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : s.prototype._countBits = function(S) {
      var m = S, f = 0;
      return m >= 4096 && (f += 13, m >>>= 13), m >= 64 && (f += 7, m >>>= 7), m >= 8 && (f += 4, m >>>= 4), m >= 2 && (f += 2, m >>>= 2), f + m;
    }, s.prototype._zeroBits = function(S) {
      if (S === 0) return 26;
      var m = S, f = 0;
      return m & 8191 || (f += 13, m >>>= 13), m & 127 || (f += 7, m >>>= 7), m & 15 || (f += 4, m >>>= 4), m & 3 || (f += 2, m >>>= 2), m & 1 || f++, f;
    }, s.prototype.bitLength = function() {
      var S = this.words[this.length - 1], m = this._countBits(S);
      return (this.length - 1) * 26 + m;
    };
    function A(Y) {
      for (var S = new Array(Y.bitLength()), m = 0; m < S.length; m++) {
        var f = m / 26 | 0, g = m % 26;
        S[m] = (Y.words[f] & 1 << g) >>> g;
      }
      return S;
    }
    s.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var S = 0, m = 0; m < this.length; m++) {
        var f = this._zeroBits(this.words[m]);
        if (S += f, f !== 26) break;
      }
      return S;
    }, s.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, s.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, s.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, s.prototype.isNeg = function() {
      return this.negative !== 0;
    }, s.prototype.neg = function() {
      return this.clone().ineg();
    }, s.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, s.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var m = 0; m < S.length; m++)
        this.words[m] = this.words[m] | S.words[m];
      return this.strip();
    }, s.prototype.ior = function(S) {
      return n((this.negative | S.negative) === 0), this.iuor(S);
    }, s.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, s.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, s.prototype.iuand = function(S) {
      var m;
      this.length > S.length ? m = S : m = this;
      for (var f = 0; f < m.length; f++)
        this.words[f] = this.words[f] & S.words[f];
      return this.length = m.length, this.strip();
    }, s.prototype.iand = function(S) {
      return n((this.negative | S.negative) === 0), this.iuand(S);
    }, s.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, s.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, s.prototype.iuxor = function(S) {
      var m, f;
      this.length > S.length ? (m = this, f = S) : (m = S, f = this);
      for (var g = 0; g < f.length; g++)
        this.words[g] = m.words[g] ^ f.words[g];
      if (this !== m)
        for (; g < m.length; g++)
          this.words[g] = m.words[g];
      return this.length = m.length, this.strip();
    }, s.prototype.ixor = function(S) {
      return n((this.negative | S.negative) === 0), this.iuxor(S);
    }, s.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, s.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, s.prototype.inotn = function(S) {
      n(typeof S == "number" && S >= 0);
      var m = Math.ceil(S / 26) | 0, f = S % 26;
      this._expand(m), f > 0 && m--;
      for (var g = 0; g < m; g++)
        this.words[g] = ~this.words[g] & 67108863;
      return f > 0 && (this.words[g] = ~this.words[g] & 67108863 >> 26 - f), this.strip();
    }, s.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, s.prototype.setn = function(S, m) {
      n(typeof S == "number" && S >= 0);
      var f = S / 26 | 0, g = S % 26;
      return this._expand(f + 1), m ? this.words[f] = this.words[f] | 1 << g : this.words[f] = this.words[f] & ~(1 << g), this.strip();
    }, s.prototype.iadd = function(S) {
      var m;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, m = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, m = this.isub(S), S.negative = 1, m._normSign();
      var f, g;
      this.length > S.length ? (f = this, g = S) : (f = S, g = this);
      for (var b = 0, w = 0; w < g.length; w++)
        m = (f.words[w] | 0) + (g.words[w] | 0) + b, this.words[w] = m & 67108863, b = m >>> 26;
      for (; b !== 0 && w < f.length; w++)
        m = (f.words[w] | 0) + b, this.words[w] = m & 67108863, b = m >>> 26;
      if (this.length = f.length, b !== 0)
        this.words[this.length] = b, this.length++;
      else if (f !== this)
        for (; w < f.length; w++)
          this.words[w] = f.words[w];
      return this;
    }, s.prototype.add = function(S) {
      var m;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, m = this.sub(S), S.negative ^= 1, m) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, m = S.sub(this), this.negative = 1, m) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, s.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var m = this.iadd(S);
        return S.negative = 1, m._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var f = this.cmp(S);
      if (f === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var g, b;
      f > 0 ? (g = this, b = S) : (g = S, b = this);
      for (var w = 0, _ = 0; _ < b.length; _++)
        m = (g.words[_] | 0) - (b.words[_] | 0) + w, w = m >> 26, this.words[_] = m & 67108863;
      for (; w !== 0 && _ < g.length; _++)
        m = (g.words[_] | 0) + w, w = m >> 26, this.words[_] = m & 67108863;
      if (w === 0 && _ < g.length && g !== this)
        for (; _ < g.length; _++)
          this.words[_] = g.words[_];
      return this.length = Math.max(this.length, _), g !== this && (this.negative = 1), this.strip();
    }, s.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function I(Y, S, m) {
      m.negative = S.negative ^ Y.negative;
      var f = Y.length + S.length | 0;
      m.length = f, f = f - 1 | 0;
      var g = Y.words[0] | 0, b = S.words[0] | 0, w = g * b, _ = w & 67108863, E = w / 67108864 | 0;
      m.words[0] = _;
      for (var v = 1; v < f; v++) {
        for (var M = E >>> 26, P = E & 67108863, B = Math.min(v, S.length - 1), ue = Math.max(0, v - Y.length + 1); ue <= B; ue++) {
          var D = v - ue | 0;
          g = Y.words[D] | 0, b = S.words[ue] | 0, w = g * b + P, M += w / 67108864 | 0, P = w & 67108863;
        }
        m.words[v] = P | 0, E = M | 0;
      }
      return E !== 0 ? m.words[v] = E | 0 : m.length--, m.strip();
    }
    var N = function(S, m, f) {
      var g = S.words, b = m.words, w = f.words, _ = 0, E, v, M, P = g[0] | 0, B = P & 8191, ue = P >>> 13, D = g[1] | 0, oe = D & 8191, Z = D >>> 13, J = g[2] | 0, Q = J & 8191, T = J >>> 13, X = g[3] | 0, re = X & 8191, de = X >>> 13, ie = g[4] | 0, ce = ie & 8191, me = ie >>> 13, Pe = g[5] | 0, De = Pe & 8191, Ce = Pe >>> 13, $e = g[6] | 0, Me = $e & 8191, Ne = $e >>> 13, Ke = g[7] | 0, Le = Ke & 8191, qe = Ke >>> 13, ze = g[8] | 0, Ee = ze & 8191, Ze = ze >>> 13, at = g[9] | 0, ke = at & 8191, Qe = at >>> 13, tt = b[0] | 0, Ye = tt & 8191, dt = tt >>> 13, lt = b[1] | 0, ct = lt & 8191, qt = lt >>> 13, Yt = b[2] | 0, Et = Yt & 8191, Qt = Yt >>> 13, Jt = b[3] | 0, Dt = Jt & 8191, kt = Jt >>> 13, Ct = b[4] | 0, gt = Ct & 8191, Rt = Ct >>> 13, Nt = b[5] | 0, vt = Nt & 8191, $t = Nt >>> 13, Ft = b[6] | 0, rt = Ft & 8191, Bt = Ft >>> 13, k = b[7] | 0, j = k & 8191, H = k >>> 13, C = b[8] | 0, G = C & 8191, U = C >>> 13, se = b[9] | 0, he = se & 8191, xe = se >>> 13;
      f.negative = S.negative ^ m.negative, f.length = 19, E = Math.imul(B, Ye), v = Math.imul(B, dt), v = v + Math.imul(ue, Ye) | 0, M = Math.imul(ue, dt);
      var Te = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, E = Math.imul(oe, Ye), v = Math.imul(oe, dt), v = v + Math.imul(Z, Ye) | 0, M = Math.imul(Z, dt), E = E + Math.imul(B, ct) | 0, v = v + Math.imul(B, qt) | 0, v = v + Math.imul(ue, ct) | 0, M = M + Math.imul(ue, qt) | 0;
      var Re = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, E = Math.imul(Q, Ye), v = Math.imul(Q, dt), v = v + Math.imul(T, Ye) | 0, M = Math.imul(T, dt), E = E + Math.imul(oe, ct) | 0, v = v + Math.imul(oe, qt) | 0, v = v + Math.imul(Z, ct) | 0, M = M + Math.imul(Z, qt) | 0, E = E + Math.imul(B, Et) | 0, v = v + Math.imul(B, Qt) | 0, v = v + Math.imul(ue, Et) | 0, M = M + Math.imul(ue, Qt) | 0;
      var nt = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, E = Math.imul(re, Ye), v = Math.imul(re, dt), v = v + Math.imul(de, Ye) | 0, M = Math.imul(de, dt), E = E + Math.imul(Q, ct) | 0, v = v + Math.imul(Q, qt) | 0, v = v + Math.imul(T, ct) | 0, M = M + Math.imul(T, qt) | 0, E = E + Math.imul(oe, Et) | 0, v = v + Math.imul(oe, Qt) | 0, v = v + Math.imul(Z, Et) | 0, M = M + Math.imul(Z, Qt) | 0, E = E + Math.imul(B, Dt) | 0, v = v + Math.imul(B, kt) | 0, v = v + Math.imul(ue, Dt) | 0, M = M + Math.imul(ue, kt) | 0;
      var Ue = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (Ue >>> 26) | 0, Ue &= 67108863, E = Math.imul(ce, Ye), v = Math.imul(ce, dt), v = v + Math.imul(me, Ye) | 0, M = Math.imul(me, dt), E = E + Math.imul(re, ct) | 0, v = v + Math.imul(re, qt) | 0, v = v + Math.imul(de, ct) | 0, M = M + Math.imul(de, qt) | 0, E = E + Math.imul(Q, Et) | 0, v = v + Math.imul(Q, Qt) | 0, v = v + Math.imul(T, Et) | 0, M = M + Math.imul(T, Qt) | 0, E = E + Math.imul(oe, Dt) | 0, v = v + Math.imul(oe, kt) | 0, v = v + Math.imul(Z, Dt) | 0, M = M + Math.imul(Z, kt) | 0, E = E + Math.imul(B, gt) | 0, v = v + Math.imul(B, Rt) | 0, v = v + Math.imul(ue, gt) | 0, M = M + Math.imul(ue, Rt) | 0;
      var pt = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, E = Math.imul(De, Ye), v = Math.imul(De, dt), v = v + Math.imul(Ce, Ye) | 0, M = Math.imul(Ce, dt), E = E + Math.imul(ce, ct) | 0, v = v + Math.imul(ce, qt) | 0, v = v + Math.imul(me, ct) | 0, M = M + Math.imul(me, qt) | 0, E = E + Math.imul(re, Et) | 0, v = v + Math.imul(re, Qt) | 0, v = v + Math.imul(de, Et) | 0, M = M + Math.imul(de, Qt) | 0, E = E + Math.imul(Q, Dt) | 0, v = v + Math.imul(Q, kt) | 0, v = v + Math.imul(T, Dt) | 0, M = M + Math.imul(T, kt) | 0, E = E + Math.imul(oe, gt) | 0, v = v + Math.imul(oe, Rt) | 0, v = v + Math.imul(Z, gt) | 0, M = M + Math.imul(Z, Rt) | 0, E = E + Math.imul(B, vt) | 0, v = v + Math.imul(B, $t) | 0, v = v + Math.imul(ue, vt) | 0, M = M + Math.imul(ue, $t) | 0;
      var it = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, E = Math.imul(Me, Ye), v = Math.imul(Me, dt), v = v + Math.imul(Ne, Ye) | 0, M = Math.imul(Ne, dt), E = E + Math.imul(De, ct) | 0, v = v + Math.imul(De, qt) | 0, v = v + Math.imul(Ce, ct) | 0, M = M + Math.imul(Ce, qt) | 0, E = E + Math.imul(ce, Et) | 0, v = v + Math.imul(ce, Qt) | 0, v = v + Math.imul(me, Et) | 0, M = M + Math.imul(me, Qt) | 0, E = E + Math.imul(re, Dt) | 0, v = v + Math.imul(re, kt) | 0, v = v + Math.imul(de, Dt) | 0, M = M + Math.imul(de, kt) | 0, E = E + Math.imul(Q, gt) | 0, v = v + Math.imul(Q, Rt) | 0, v = v + Math.imul(T, gt) | 0, M = M + Math.imul(T, Rt) | 0, E = E + Math.imul(oe, vt) | 0, v = v + Math.imul(oe, $t) | 0, v = v + Math.imul(Z, vt) | 0, M = M + Math.imul(Z, $t) | 0, E = E + Math.imul(B, rt) | 0, v = v + Math.imul(B, Bt) | 0, v = v + Math.imul(ue, rt) | 0, M = M + Math.imul(ue, Bt) | 0;
      var et = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, E = Math.imul(Le, Ye), v = Math.imul(Le, dt), v = v + Math.imul(qe, Ye) | 0, M = Math.imul(qe, dt), E = E + Math.imul(Me, ct) | 0, v = v + Math.imul(Me, qt) | 0, v = v + Math.imul(Ne, ct) | 0, M = M + Math.imul(Ne, qt) | 0, E = E + Math.imul(De, Et) | 0, v = v + Math.imul(De, Qt) | 0, v = v + Math.imul(Ce, Et) | 0, M = M + Math.imul(Ce, Qt) | 0, E = E + Math.imul(ce, Dt) | 0, v = v + Math.imul(ce, kt) | 0, v = v + Math.imul(me, Dt) | 0, M = M + Math.imul(me, kt) | 0, E = E + Math.imul(re, gt) | 0, v = v + Math.imul(re, Rt) | 0, v = v + Math.imul(de, gt) | 0, M = M + Math.imul(de, Rt) | 0, E = E + Math.imul(Q, vt) | 0, v = v + Math.imul(Q, $t) | 0, v = v + Math.imul(T, vt) | 0, M = M + Math.imul(T, $t) | 0, E = E + Math.imul(oe, rt) | 0, v = v + Math.imul(oe, Bt) | 0, v = v + Math.imul(Z, rt) | 0, M = M + Math.imul(Z, Bt) | 0, E = E + Math.imul(B, j) | 0, v = v + Math.imul(B, H) | 0, v = v + Math.imul(ue, j) | 0, M = M + Math.imul(ue, H) | 0;
      var St = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, E = Math.imul(Ee, Ye), v = Math.imul(Ee, dt), v = v + Math.imul(Ze, Ye) | 0, M = Math.imul(Ze, dt), E = E + Math.imul(Le, ct) | 0, v = v + Math.imul(Le, qt) | 0, v = v + Math.imul(qe, ct) | 0, M = M + Math.imul(qe, qt) | 0, E = E + Math.imul(Me, Et) | 0, v = v + Math.imul(Me, Qt) | 0, v = v + Math.imul(Ne, Et) | 0, M = M + Math.imul(Ne, Qt) | 0, E = E + Math.imul(De, Dt) | 0, v = v + Math.imul(De, kt) | 0, v = v + Math.imul(Ce, Dt) | 0, M = M + Math.imul(Ce, kt) | 0, E = E + Math.imul(ce, gt) | 0, v = v + Math.imul(ce, Rt) | 0, v = v + Math.imul(me, gt) | 0, M = M + Math.imul(me, Rt) | 0, E = E + Math.imul(re, vt) | 0, v = v + Math.imul(re, $t) | 0, v = v + Math.imul(de, vt) | 0, M = M + Math.imul(de, $t) | 0, E = E + Math.imul(Q, rt) | 0, v = v + Math.imul(Q, Bt) | 0, v = v + Math.imul(T, rt) | 0, M = M + Math.imul(T, Bt) | 0, E = E + Math.imul(oe, j) | 0, v = v + Math.imul(oe, H) | 0, v = v + Math.imul(Z, j) | 0, M = M + Math.imul(Z, H) | 0, E = E + Math.imul(B, G) | 0, v = v + Math.imul(B, U) | 0, v = v + Math.imul(ue, G) | 0, M = M + Math.imul(ue, U) | 0;
      var Tt = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, E = Math.imul(ke, Ye), v = Math.imul(ke, dt), v = v + Math.imul(Qe, Ye) | 0, M = Math.imul(Qe, dt), E = E + Math.imul(Ee, ct) | 0, v = v + Math.imul(Ee, qt) | 0, v = v + Math.imul(Ze, ct) | 0, M = M + Math.imul(Ze, qt) | 0, E = E + Math.imul(Le, Et) | 0, v = v + Math.imul(Le, Qt) | 0, v = v + Math.imul(qe, Et) | 0, M = M + Math.imul(qe, Qt) | 0, E = E + Math.imul(Me, Dt) | 0, v = v + Math.imul(Me, kt) | 0, v = v + Math.imul(Ne, Dt) | 0, M = M + Math.imul(Ne, kt) | 0, E = E + Math.imul(De, gt) | 0, v = v + Math.imul(De, Rt) | 0, v = v + Math.imul(Ce, gt) | 0, M = M + Math.imul(Ce, Rt) | 0, E = E + Math.imul(ce, vt) | 0, v = v + Math.imul(ce, $t) | 0, v = v + Math.imul(me, vt) | 0, M = M + Math.imul(me, $t) | 0, E = E + Math.imul(re, rt) | 0, v = v + Math.imul(re, Bt) | 0, v = v + Math.imul(de, rt) | 0, M = M + Math.imul(de, Bt) | 0, E = E + Math.imul(Q, j) | 0, v = v + Math.imul(Q, H) | 0, v = v + Math.imul(T, j) | 0, M = M + Math.imul(T, H) | 0, E = E + Math.imul(oe, G) | 0, v = v + Math.imul(oe, U) | 0, v = v + Math.imul(Z, G) | 0, M = M + Math.imul(Z, U) | 0, E = E + Math.imul(B, he) | 0, v = v + Math.imul(B, xe) | 0, v = v + Math.imul(ue, he) | 0, M = M + Math.imul(ue, xe) | 0;
      var At = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, E = Math.imul(ke, ct), v = Math.imul(ke, qt), v = v + Math.imul(Qe, ct) | 0, M = Math.imul(Qe, qt), E = E + Math.imul(Ee, Et) | 0, v = v + Math.imul(Ee, Qt) | 0, v = v + Math.imul(Ze, Et) | 0, M = M + Math.imul(Ze, Qt) | 0, E = E + Math.imul(Le, Dt) | 0, v = v + Math.imul(Le, kt) | 0, v = v + Math.imul(qe, Dt) | 0, M = M + Math.imul(qe, kt) | 0, E = E + Math.imul(Me, gt) | 0, v = v + Math.imul(Me, Rt) | 0, v = v + Math.imul(Ne, gt) | 0, M = M + Math.imul(Ne, Rt) | 0, E = E + Math.imul(De, vt) | 0, v = v + Math.imul(De, $t) | 0, v = v + Math.imul(Ce, vt) | 0, M = M + Math.imul(Ce, $t) | 0, E = E + Math.imul(ce, rt) | 0, v = v + Math.imul(ce, Bt) | 0, v = v + Math.imul(me, rt) | 0, M = M + Math.imul(me, Bt) | 0, E = E + Math.imul(re, j) | 0, v = v + Math.imul(re, H) | 0, v = v + Math.imul(de, j) | 0, M = M + Math.imul(de, H) | 0, E = E + Math.imul(Q, G) | 0, v = v + Math.imul(Q, U) | 0, v = v + Math.imul(T, G) | 0, M = M + Math.imul(T, U) | 0, E = E + Math.imul(oe, he) | 0, v = v + Math.imul(oe, xe) | 0, v = v + Math.imul(Z, he) | 0, M = M + Math.imul(Z, xe) | 0;
      var _t = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, E = Math.imul(ke, Et), v = Math.imul(ke, Qt), v = v + Math.imul(Qe, Et) | 0, M = Math.imul(Qe, Qt), E = E + Math.imul(Ee, Dt) | 0, v = v + Math.imul(Ee, kt) | 0, v = v + Math.imul(Ze, Dt) | 0, M = M + Math.imul(Ze, kt) | 0, E = E + Math.imul(Le, gt) | 0, v = v + Math.imul(Le, Rt) | 0, v = v + Math.imul(qe, gt) | 0, M = M + Math.imul(qe, Rt) | 0, E = E + Math.imul(Me, vt) | 0, v = v + Math.imul(Me, $t) | 0, v = v + Math.imul(Ne, vt) | 0, M = M + Math.imul(Ne, $t) | 0, E = E + Math.imul(De, rt) | 0, v = v + Math.imul(De, Bt) | 0, v = v + Math.imul(Ce, rt) | 0, M = M + Math.imul(Ce, Bt) | 0, E = E + Math.imul(ce, j) | 0, v = v + Math.imul(ce, H) | 0, v = v + Math.imul(me, j) | 0, M = M + Math.imul(me, H) | 0, E = E + Math.imul(re, G) | 0, v = v + Math.imul(re, U) | 0, v = v + Math.imul(de, G) | 0, M = M + Math.imul(de, U) | 0, E = E + Math.imul(Q, he) | 0, v = v + Math.imul(Q, xe) | 0, v = v + Math.imul(T, he) | 0, M = M + Math.imul(T, xe) | 0;
      var ht = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, E = Math.imul(ke, Dt), v = Math.imul(ke, kt), v = v + Math.imul(Qe, Dt) | 0, M = Math.imul(Qe, kt), E = E + Math.imul(Ee, gt) | 0, v = v + Math.imul(Ee, Rt) | 0, v = v + Math.imul(Ze, gt) | 0, M = M + Math.imul(Ze, Rt) | 0, E = E + Math.imul(Le, vt) | 0, v = v + Math.imul(Le, $t) | 0, v = v + Math.imul(qe, vt) | 0, M = M + Math.imul(qe, $t) | 0, E = E + Math.imul(Me, rt) | 0, v = v + Math.imul(Me, Bt) | 0, v = v + Math.imul(Ne, rt) | 0, M = M + Math.imul(Ne, Bt) | 0, E = E + Math.imul(De, j) | 0, v = v + Math.imul(De, H) | 0, v = v + Math.imul(Ce, j) | 0, M = M + Math.imul(Ce, H) | 0, E = E + Math.imul(ce, G) | 0, v = v + Math.imul(ce, U) | 0, v = v + Math.imul(me, G) | 0, M = M + Math.imul(me, U) | 0, E = E + Math.imul(re, he) | 0, v = v + Math.imul(re, xe) | 0, v = v + Math.imul(de, he) | 0, M = M + Math.imul(de, xe) | 0;
      var xt = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, E = Math.imul(ke, gt), v = Math.imul(ke, Rt), v = v + Math.imul(Qe, gt) | 0, M = Math.imul(Qe, Rt), E = E + Math.imul(Ee, vt) | 0, v = v + Math.imul(Ee, $t) | 0, v = v + Math.imul(Ze, vt) | 0, M = M + Math.imul(Ze, $t) | 0, E = E + Math.imul(Le, rt) | 0, v = v + Math.imul(Le, Bt) | 0, v = v + Math.imul(qe, rt) | 0, M = M + Math.imul(qe, Bt) | 0, E = E + Math.imul(Me, j) | 0, v = v + Math.imul(Me, H) | 0, v = v + Math.imul(Ne, j) | 0, M = M + Math.imul(Ne, H) | 0, E = E + Math.imul(De, G) | 0, v = v + Math.imul(De, U) | 0, v = v + Math.imul(Ce, G) | 0, M = M + Math.imul(Ce, U) | 0, E = E + Math.imul(ce, he) | 0, v = v + Math.imul(ce, xe) | 0, v = v + Math.imul(me, he) | 0, M = M + Math.imul(me, xe) | 0;
      var st = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, E = Math.imul(ke, vt), v = Math.imul(ke, $t), v = v + Math.imul(Qe, vt) | 0, M = Math.imul(Qe, $t), E = E + Math.imul(Ee, rt) | 0, v = v + Math.imul(Ee, Bt) | 0, v = v + Math.imul(Ze, rt) | 0, M = M + Math.imul(Ze, Bt) | 0, E = E + Math.imul(Le, j) | 0, v = v + Math.imul(Le, H) | 0, v = v + Math.imul(qe, j) | 0, M = M + Math.imul(qe, H) | 0, E = E + Math.imul(Me, G) | 0, v = v + Math.imul(Me, U) | 0, v = v + Math.imul(Ne, G) | 0, M = M + Math.imul(Ne, U) | 0, E = E + Math.imul(De, he) | 0, v = v + Math.imul(De, xe) | 0, v = v + Math.imul(Ce, he) | 0, M = M + Math.imul(Ce, xe) | 0;
      var bt = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, E = Math.imul(ke, rt), v = Math.imul(ke, Bt), v = v + Math.imul(Qe, rt) | 0, M = Math.imul(Qe, Bt), E = E + Math.imul(Ee, j) | 0, v = v + Math.imul(Ee, H) | 0, v = v + Math.imul(Ze, j) | 0, M = M + Math.imul(Ze, H) | 0, E = E + Math.imul(Le, G) | 0, v = v + Math.imul(Le, U) | 0, v = v + Math.imul(qe, G) | 0, M = M + Math.imul(qe, U) | 0, E = E + Math.imul(Me, he) | 0, v = v + Math.imul(Me, xe) | 0, v = v + Math.imul(Ne, he) | 0, M = M + Math.imul(Ne, xe) | 0;
      var ut = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, E = Math.imul(ke, j), v = Math.imul(ke, H), v = v + Math.imul(Qe, j) | 0, M = Math.imul(Qe, H), E = E + Math.imul(Ee, G) | 0, v = v + Math.imul(Ee, U) | 0, v = v + Math.imul(Ze, G) | 0, M = M + Math.imul(Ze, U) | 0, E = E + Math.imul(Le, he) | 0, v = v + Math.imul(Le, xe) | 0, v = v + Math.imul(qe, he) | 0, M = M + Math.imul(qe, xe) | 0;
      var ot = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, E = Math.imul(ke, G), v = Math.imul(ke, U), v = v + Math.imul(Qe, G) | 0, M = Math.imul(Qe, U), E = E + Math.imul(Ee, he) | 0, v = v + Math.imul(Ee, xe) | 0, v = v + Math.imul(Ze, he) | 0, M = M + Math.imul(Ze, xe) | 0;
      var Se = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, E = Math.imul(ke, he), v = Math.imul(ke, xe), v = v + Math.imul(Qe, he) | 0, M = Math.imul(Qe, xe);
      var Ae = (_ + E | 0) + ((v & 8191) << 13) | 0;
      return _ = (M + (v >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, w[0] = Te, w[1] = Re, w[2] = nt, w[3] = Ue, w[4] = pt, w[5] = it, w[6] = et, w[7] = St, w[8] = Tt, w[9] = At, w[10] = _t, w[11] = ht, w[12] = xt, w[13] = st, w[14] = bt, w[15] = ut, w[16] = ot, w[17] = Se, w[18] = Ae, _ !== 0 && (w[19] = _, f.length++), f;
    };
    Math.imul || (N = I);
    function L(Y, S, m) {
      m.negative = S.negative ^ Y.negative, m.length = Y.length + S.length;
      for (var f = 0, g = 0, b = 0; b < m.length - 1; b++) {
        var w = g;
        g = 0;
        for (var _ = f & 67108863, E = Math.min(b, S.length - 1), v = Math.max(0, b - Y.length + 1); v <= E; v++) {
          var M = b - v, P = Y.words[M] | 0, B = S.words[v] | 0, ue = P * B, D = ue & 67108863;
          w = w + (ue / 67108864 | 0) | 0, D = D + _ | 0, _ = D & 67108863, w = w + (D >>> 26) | 0, g += w >>> 26, w &= 67108863;
        }
        m.words[b] = _, f = w, w = g;
      }
      return f !== 0 ? m.words[b] = f : m.length--, m.strip();
    }
    function F(Y, S, m) {
      var f = new $();
      return f.mulp(Y, S, m);
    }
    s.prototype.mulTo = function(S, m) {
      var f, g = this.length + S.length;
      return this.length === 10 && S.length === 10 ? f = N(this, S, m) : g < 63 ? f = I(this, S, m) : g < 1024 ? f = L(this, S, m) : f = F(this, S, m), f;
    };
    function $(Y, S) {
      this.x = Y, this.y = S;
    }
    $.prototype.makeRBT = function(S) {
      for (var m = new Array(S), f = s.prototype._countBits(S) - 1, g = 0; g < S; g++)
        m[g] = this.revBin(g, f, S);
      return m;
    }, $.prototype.revBin = function(S, m, f) {
      if (S === 0 || S === f - 1) return S;
      for (var g = 0, b = 0; b < m; b++)
        g |= (S & 1) << m - b - 1, S >>= 1;
      return g;
    }, $.prototype.permute = function(S, m, f, g, b, w) {
      for (var _ = 0; _ < w; _++)
        g[_] = m[S[_]], b[_] = f[S[_]];
    }, $.prototype.transform = function(S, m, f, g, b, w) {
      this.permute(w, S, m, f, g, b);
      for (var _ = 1; _ < b; _ <<= 1)
        for (var E = _ << 1, v = Math.cos(2 * Math.PI / E), M = Math.sin(2 * Math.PI / E), P = 0; P < b; P += E)
          for (var B = v, ue = M, D = 0; D < _; D++) {
            var oe = f[P + D], Z = g[P + D], J = f[P + D + _], Q = g[P + D + _], T = B * J - ue * Q;
            Q = B * Q + ue * J, J = T, f[P + D] = oe + J, g[P + D] = Z + Q, f[P + D + _] = oe - J, g[P + D + _] = Z - Q, D !== E && (T = v * B - M * ue, ue = v * ue + M * B, B = T);
          }
    }, $.prototype.guessLen13b = function(S, m) {
      var f = Math.max(m, S) | 1, g = f & 1, b = 0;
      for (f = f / 2 | 0; f; f = f >>> 1)
        b++;
      return 1 << b + 1 + g;
    }, $.prototype.conjugate = function(S, m, f) {
      if (!(f <= 1))
        for (var g = 0; g < f / 2; g++) {
          var b = S[g];
          S[g] = S[f - g - 1], S[f - g - 1] = b, b = m[g], m[g] = -m[f - g - 1], m[f - g - 1] = -b;
        }
    }, $.prototype.normalize13b = function(S, m) {
      for (var f = 0, g = 0; g < m / 2; g++) {
        var b = Math.round(S[2 * g + 1] / m) * 8192 + Math.round(S[2 * g] / m) + f;
        S[g] = b & 67108863, b < 67108864 ? f = 0 : f = b / 67108864 | 0;
      }
      return S;
    }, $.prototype.convert13b = function(S, m, f, g) {
      for (var b = 0, w = 0; w < m; w++)
        b = b + (S[w] | 0), f[2 * w] = b & 8191, b = b >>> 13, f[2 * w + 1] = b & 8191, b = b >>> 13;
      for (w = 2 * m; w < g; ++w)
        f[w] = 0;
      n(b === 0), n((b & -8192) === 0);
    }, $.prototype.stub = function(S) {
      for (var m = new Array(S), f = 0; f < S; f++)
        m[f] = 0;
      return m;
    }, $.prototype.mulp = function(S, m, f) {
      var g = 2 * this.guessLen13b(S.length, m.length), b = this.makeRBT(g), w = this.stub(g), _ = new Array(g), E = new Array(g), v = new Array(g), M = new Array(g), P = new Array(g), B = new Array(g), ue = f.words;
      ue.length = g, this.convert13b(S.words, S.length, _, g), this.convert13b(m.words, m.length, M, g), this.transform(_, w, E, v, g, b), this.transform(M, w, P, B, g, b);
      for (var D = 0; D < g; D++) {
        var oe = E[D] * P[D] - v[D] * B[D];
        v[D] = E[D] * B[D] + v[D] * P[D], E[D] = oe;
      }
      return this.conjugate(E, v, g), this.transform(E, v, ue, w, g, b), this.conjugate(ue, w, g), this.normalize13b(ue, g), f.negative = S.negative ^ m.negative, f.length = S.length + m.length, f.strip();
    }, s.prototype.mul = function(S) {
      var m = new s(null);
      return m.words = new Array(this.length + S.length), this.mulTo(S, m);
    }, s.prototype.mulf = function(S) {
      var m = new s(null);
      return m.words = new Array(this.length + S.length), F(this, S, m);
    }, s.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, s.prototype.imuln = function(S) {
      n(typeof S == "number"), n(S < 67108864);
      for (var m = 0, f = 0; f < this.length; f++) {
        var g = (this.words[f] | 0) * S, b = (g & 67108863) + (m & 67108863);
        m >>= 26, m += g / 67108864 | 0, m += b >>> 26, this.words[f] = b & 67108863;
      }
      return m !== 0 && (this.words[f] = m, this.length++), this;
    }, s.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, s.prototype.sqr = function() {
      return this.mul(this);
    }, s.prototype.isqr = function() {
      return this.imul(this.clone());
    }, s.prototype.pow = function(S) {
      var m = A(S);
      if (m.length === 0) return new s(1);
      for (var f = this, g = 0; g < m.length && m[g] === 0; g++, f = f.sqr())
        ;
      if (++g < m.length)
        for (var b = f.sqr(); g < m.length; g++, b = b.sqr())
          m[g] !== 0 && (f = f.mul(b));
      return f;
    }, s.prototype.iushln = function(S) {
      n(typeof S == "number" && S >= 0);
      var m = S % 26, f = (S - m) / 26, g = 67108863 >>> 26 - m << 26 - m, b;
      if (m !== 0) {
        var w = 0;
        for (b = 0; b < this.length; b++) {
          var _ = this.words[b] & g, E = (this.words[b] | 0) - _ << m;
          this.words[b] = E | w, w = _ >>> 26 - m;
        }
        w && (this.words[b] = w, this.length++);
      }
      if (f !== 0) {
        for (b = this.length - 1; b >= 0; b--)
          this.words[b + f] = this.words[b];
        for (b = 0; b < f; b++)
          this.words[b] = 0;
        this.length += f;
      }
      return this.strip();
    }, s.prototype.ishln = function(S) {
      return n(this.negative === 0), this.iushln(S);
    }, s.prototype.iushrn = function(S, m, f) {
      n(typeof S == "number" && S >= 0);
      var g;
      m ? g = (m - m % 26) / 26 : g = 0;
      var b = S % 26, w = Math.min((S - b) / 26, this.length), _ = 67108863 ^ 67108863 >>> b << b, E = f;
      if (g -= w, g = Math.max(0, g), E) {
        for (var v = 0; v < w; v++)
          E.words[v] = this.words[v];
        E.length = w;
      }
      if (w !== 0) if (this.length > w)
        for (this.length -= w, v = 0; v < this.length; v++)
          this.words[v] = this.words[v + w];
      else
        this.words[0] = 0, this.length = 1;
      var M = 0;
      for (v = this.length - 1; v >= 0 && (M !== 0 || v >= g); v--) {
        var P = this.words[v] | 0;
        this.words[v] = M << 26 - b | P >>> b, M = P & _;
      }
      return E && M !== 0 && (E.words[E.length++] = M), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, s.prototype.ishrn = function(S, m, f) {
      return n(this.negative === 0), this.iushrn(S, m, f);
    }, s.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, s.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, s.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, s.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, s.prototype.testn = function(S) {
      n(typeof S == "number" && S >= 0);
      var m = S % 26, f = (S - m) / 26, g = 1 << m;
      if (this.length <= f) return !1;
      var b = this.words[f];
      return !!(b & g);
    }, s.prototype.imaskn = function(S) {
      n(typeof S == "number" && S >= 0);
      var m = S % 26, f = (S - m) / 26;
      if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= f)
        return this;
      if (m !== 0 && f++, this.length = Math.min(f, this.length), m !== 0) {
        var g = 67108863 ^ 67108863 >>> m << m;
        this.words[this.length - 1] &= g;
      }
      return this.strip();
    }, s.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, s.prototype.iaddn = function(S) {
      return n(typeof S == "number"), n(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, s.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var m = 0; m < this.length && this.words[m] >= 67108864; m++)
        this.words[m] -= 67108864, m === this.length - 1 ? this.words[m + 1] = 1 : this.words[m + 1]++;
      return this.length = Math.max(this.length, m + 1), this;
    }, s.prototype.isubn = function(S) {
      if (n(typeof S == "number"), n(S < 67108864), S < 0) return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var m = 0; m < this.length && this.words[m] < 0; m++)
          this.words[m] += 67108864, this.words[m + 1] -= 1;
      return this.strip();
    }, s.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, s.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, s.prototype.iabs = function() {
      return this.negative = 0, this;
    }, s.prototype.abs = function() {
      return this.clone().iabs();
    }, s.prototype._ishlnsubmul = function(S, m, f) {
      var g = S.length + f, b;
      this._expand(g);
      var w, _ = 0;
      for (b = 0; b < S.length; b++) {
        w = (this.words[b + f] | 0) + _;
        var E = (S.words[b] | 0) * m;
        w -= E & 67108863, _ = (w >> 26) - (E / 67108864 | 0), this.words[b + f] = w & 67108863;
      }
      for (; b < this.length - f; b++)
        w = (this.words[b + f] | 0) + _, _ = w >> 26, this.words[b + f] = w & 67108863;
      if (_ === 0) return this.strip();
      for (n(_ === -1), _ = 0, b = 0; b < this.length; b++)
        w = -(this.words[b] | 0) + _, _ = w >> 26, this.words[b] = w & 67108863;
      return this.negative = 1, this.strip();
    }, s.prototype._wordDiv = function(S, m) {
      var f = this.length - S.length, g = this.clone(), b = S, w = b.words[b.length - 1] | 0, _ = this._countBits(w);
      f = 26 - _, f !== 0 && (b = b.ushln(f), g.iushln(f), w = b.words[b.length - 1] | 0);
      var E = g.length - b.length, v;
      if (m !== "mod") {
        v = new s(null), v.length = E + 1, v.words = new Array(v.length);
        for (var M = 0; M < v.length; M++)
          v.words[M] = 0;
      }
      var P = g.clone()._ishlnsubmul(b, 1, E);
      P.negative === 0 && (g = P, v && (v.words[E] = 1));
      for (var B = E - 1; B >= 0; B--) {
        var ue = (g.words[b.length + B] | 0) * 67108864 + (g.words[b.length + B - 1] | 0);
        for (ue = Math.min(ue / w | 0, 67108863), g._ishlnsubmul(b, ue, B); g.negative !== 0; )
          ue--, g.negative = 0, g._ishlnsubmul(b, 1, B), g.isZero() || (g.negative ^= 1);
        v && (v.words[B] = ue);
      }
      return v && v.strip(), g.strip(), m !== "div" && f !== 0 && g.iushrn(f), {
        div: v || null,
        mod: g
      };
    }, s.prototype.divmod = function(S, m, f) {
      if (n(!S.isZero()), this.isZero())
        return {
          div: new s(0),
          mod: new s(0)
        };
      var g, b, w;
      return this.negative !== 0 && S.negative === 0 ? (w = this.neg().divmod(S, m), m !== "mod" && (g = w.div.neg()), m !== "div" && (b = w.mod.neg(), f && b.negative !== 0 && b.iadd(S)), {
        div: g,
        mod: b
      }) : this.negative === 0 && S.negative !== 0 ? (w = this.divmod(S.neg(), m), m !== "mod" && (g = w.div.neg()), {
        div: g,
        mod: w.mod
      }) : this.negative & S.negative ? (w = this.neg().divmod(S.neg(), m), m !== "div" && (b = w.mod.neg(), f && b.negative !== 0 && b.isub(S)), {
        div: w.div,
        mod: b
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new s(0),
        mod: this
      } : S.length === 1 ? m === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : m === "mod" ? {
        div: null,
        mod: new s(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new s(this.modn(S.words[0]))
      } : this._wordDiv(S, m);
    }, s.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, s.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, s.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, s.prototype.divRound = function(S) {
      var m = this.divmod(S);
      if (m.mod.isZero()) return m.div;
      var f = m.div.negative !== 0 ? m.mod.isub(S) : m.mod, g = S.ushrn(1), b = S.andln(1), w = f.cmp(g);
      return w < 0 || b === 1 && w === 0 ? m.div : m.div.negative !== 0 ? m.div.isubn(1) : m.div.iaddn(1);
    }, s.prototype.modn = function(S) {
      n(S <= 67108863);
      for (var m = (1 << 26) % S, f = 0, g = this.length - 1; g >= 0; g--)
        f = (m * f + (this.words[g] | 0)) % S;
      return f;
    }, s.prototype.idivn = function(S) {
      n(S <= 67108863);
      for (var m = 0, f = this.length - 1; f >= 0; f--) {
        var g = (this.words[f] | 0) + m * 67108864;
        this.words[f] = g / S | 0, m = g % S;
      }
      return this.strip();
    }, s.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, s.prototype.egcd = function(S) {
      n(S.negative === 0), n(!S.isZero());
      var m = this, f = S.clone();
      m.negative !== 0 ? m = m.umod(S) : m = m.clone();
      for (var g = new s(1), b = new s(0), w = new s(0), _ = new s(1), E = 0; m.isEven() && f.isEven(); )
        m.iushrn(1), f.iushrn(1), ++E;
      for (var v = f.clone(), M = m.clone(); !m.isZero(); ) {
        for (var P = 0, B = 1; !(m.words[0] & B) && P < 26; ++P, B <<= 1) ;
        if (P > 0)
          for (m.iushrn(P); P-- > 0; )
            (g.isOdd() || b.isOdd()) && (g.iadd(v), b.isub(M)), g.iushrn(1), b.iushrn(1);
        for (var ue = 0, D = 1; !(f.words[0] & D) && ue < 26; ++ue, D <<= 1) ;
        if (ue > 0)
          for (f.iushrn(ue); ue-- > 0; )
            (w.isOdd() || _.isOdd()) && (w.iadd(v), _.isub(M)), w.iushrn(1), _.iushrn(1);
        m.cmp(f) >= 0 ? (m.isub(f), g.isub(w), b.isub(_)) : (f.isub(m), w.isub(g), _.isub(b));
      }
      return {
        a: w,
        b: _,
        gcd: f.iushln(E)
      };
    }, s.prototype._invmp = function(S) {
      n(S.negative === 0), n(!S.isZero());
      var m = this, f = S.clone();
      m.negative !== 0 ? m = m.umod(S) : m = m.clone();
      for (var g = new s(1), b = new s(0), w = f.clone(); m.cmpn(1) > 0 && f.cmpn(1) > 0; ) {
        for (var _ = 0, E = 1; !(m.words[0] & E) && _ < 26; ++_, E <<= 1) ;
        if (_ > 0)
          for (m.iushrn(_); _-- > 0; )
            g.isOdd() && g.iadd(w), g.iushrn(1);
        for (var v = 0, M = 1; !(f.words[0] & M) && v < 26; ++v, M <<= 1) ;
        if (v > 0)
          for (f.iushrn(v); v-- > 0; )
            b.isOdd() && b.iadd(w), b.iushrn(1);
        m.cmp(f) >= 0 ? (m.isub(f), g.isub(b)) : (f.isub(m), b.isub(g));
      }
      var P;
      return m.cmpn(1) === 0 ? P = g : P = b, P.cmpn(0) < 0 && P.iadd(S), P;
    }, s.prototype.gcd = function(S) {
      if (this.isZero()) return S.abs();
      if (S.isZero()) return this.abs();
      var m = this.clone(), f = S.clone();
      m.negative = 0, f.negative = 0;
      for (var g = 0; m.isEven() && f.isEven(); g++)
        m.iushrn(1), f.iushrn(1);
      do {
        for (; m.isEven(); )
          m.iushrn(1);
        for (; f.isEven(); )
          f.iushrn(1);
        var b = m.cmp(f);
        if (b < 0) {
          var w = m;
          m = f, f = w;
        } else if (b === 0 || f.cmpn(1) === 0)
          break;
        m.isub(f);
      } while (!0);
      return f.iushln(g);
    }, s.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, s.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, s.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, s.prototype.andln = function(S) {
      return this.words[0] & S;
    }, s.prototype.bincn = function(S) {
      n(typeof S == "number");
      var m = S % 26, f = (S - m) / 26, g = 1 << m;
      if (this.length <= f)
        return this._expand(f + 1), this.words[f] |= g, this;
      for (var b = g, w = f; b !== 0 && w < this.length; w++) {
        var _ = this.words[w] | 0;
        _ += b, b = _ >>> 26, _ &= 67108863, this.words[w] = _;
      }
      return b !== 0 && (this.words[w] = b, this.length++), this;
    }, s.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, s.prototype.cmpn = function(S) {
      var m = S < 0;
      if (this.negative !== 0 && !m) return -1;
      if (this.negative === 0 && m) return 1;
      this.strip();
      var f;
      if (this.length > 1)
        f = 1;
      else {
        m && (S = -S), n(S <= 67108863, "Number is too big");
        var g = this.words[0] | 0;
        f = g === S ? 0 : g < S ? -1 : 1;
      }
      return this.negative !== 0 ? -f | 0 : f;
    }, s.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0) return -1;
      if (this.negative === 0 && S.negative !== 0) return 1;
      var m = this.ucmp(S);
      return this.negative !== 0 ? -m | 0 : m;
    }, s.prototype.ucmp = function(S) {
      if (this.length > S.length) return 1;
      if (this.length < S.length) return -1;
      for (var m = 0, f = this.length - 1; f >= 0; f--) {
        var g = this.words[f] | 0, b = S.words[f] | 0;
        if (g !== b) {
          g < b ? m = -1 : g > b && (m = 1);
          break;
        }
      }
      return m;
    }, s.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, s.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, s.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, s.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, s.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, s.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, s.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, s.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, s.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, s.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, s.red = function(S) {
      return new pe(S);
    }, s.prototype.toRed = function(S) {
      return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, s.prototype.fromRed = function() {
      return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, s.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, s.prototype.forceRed = function(S) {
      return n(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, s.prototype.redAdd = function(S) {
      return n(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, s.prototype.redIAdd = function(S) {
      return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, s.prototype.redSub = function(S) {
      return n(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, s.prototype.redISub = function(S) {
      return n(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, s.prototype.redShl = function(S) {
      return n(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, s.prototype.redMul = function(S) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, s.prototype.redIMul = function(S) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, s.prototype.redSqr = function() {
      return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, s.prototype.redISqr = function() {
      return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, s.prototype.redSqrt = function() {
      return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, s.prototype.redInvm = function() {
      return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, s.prototype.redNeg = function() {
      return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, s.prototype.redPow = function(S) {
      return n(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var W = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function z(Y, S) {
      this.name = Y, this.p = new s(S, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    z.prototype._tmp = function() {
      var S = new s(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, z.prototype.ireduce = function(S) {
      var m = S, f;
      do
        this.split(m, this.tmp), m = this.imulK(m), m = m.iadd(this.tmp), f = m.bitLength();
      while (f > this.n);
      var g = f < this.n ? -1 : m.ucmp(this.p);
      return g === 0 ? (m.words[0] = 0, m.length = 1) : g > 0 ? m.isub(this.p) : m.strip !== void 0 ? m.strip() : m._strip(), m;
    }, z.prototype.split = function(S, m) {
      S.iushrn(this.n, 0, m);
    }, z.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function V() {
      z.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(V, z), V.prototype.split = function(S, m) {
      for (var f = 4194303, g = Math.min(S.length, 9), b = 0; b < g; b++)
        m.words[b] = S.words[b];
      if (m.length = g, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var w = S.words[9];
      for (m.words[m.length++] = w & f, b = 10; b < S.length; b++) {
        var _ = S.words[b] | 0;
        S.words[b - 10] = (_ & f) << 4 | w >>> 22, w = _;
      }
      w >>>= 22, S.words[b - 10] = w, w === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, V.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var m = 0, f = 0; f < S.length; f++) {
        var g = S.words[f] | 0;
        m += g * 977, S.words[f] = m & 67108863, m = g * 64 + (m / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function te() {
      z.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(te, z);
    function R() {
      z.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(R, z);
    function K() {
      z.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(K, z), K.prototype.imulK = function(S) {
      for (var m = 0, f = 0; f < S.length; f++) {
        var g = (S.words[f] | 0) * 19 + m, b = g & 67108863;
        g >>>= 26, S.words[f] = b, m = g;
      }
      return m !== 0 && (S.words[S.length++] = m), S;
    }, s._prime = function(S) {
      if (W[S]) return W[S];
      var m;
      if (S === "k256")
        m = new V();
      else if (S === "p224")
        m = new te();
      else if (S === "p192")
        m = new R();
      else if (S === "p25519")
        m = new K();
      else
        throw new Error("Unknown prime " + S);
      return W[S] = m, m;
    };
    function pe(Y) {
      if (typeof Y == "string") {
        var S = s._prime(Y);
        this.m = S.p, this.prime = S;
      } else
        n(Y.gtn(1), "modulus must be greater than 1"), this.m = Y, this.prime = null;
    }
    pe.prototype._verify1 = function(S) {
      n(S.negative === 0, "red works only with positives"), n(S.red, "red works only with red numbers");
    }, pe.prototype._verify2 = function(S, m) {
      n((S.negative | m.negative) === 0, "red works only with positives"), n(
        S.red && S.red === m.red,
        "red works only with red numbers"
      );
    }, pe.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, pe.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, pe.prototype.add = function(S, m) {
      this._verify2(S, m);
      var f = S.add(m);
      return f.cmp(this.m) >= 0 && f.isub(this.m), f._forceRed(this);
    }, pe.prototype.iadd = function(S, m) {
      this._verify2(S, m);
      var f = S.iadd(m);
      return f.cmp(this.m) >= 0 && f.isub(this.m), f;
    }, pe.prototype.sub = function(S, m) {
      this._verify2(S, m);
      var f = S.sub(m);
      return f.cmpn(0) < 0 && f.iadd(this.m), f._forceRed(this);
    }, pe.prototype.isub = function(S, m) {
      this._verify2(S, m);
      var f = S.isub(m);
      return f.cmpn(0) < 0 && f.iadd(this.m), f;
    }, pe.prototype.shl = function(S, m) {
      return this._verify1(S), this.imod(S.ushln(m));
    }, pe.prototype.imul = function(S, m) {
      return this._verify2(S, m), this.imod(S.imul(m));
    }, pe.prototype.mul = function(S, m) {
      return this._verify2(S, m), this.imod(S.mul(m));
    }, pe.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, pe.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, pe.prototype.sqrt = function(S) {
      if (S.isZero()) return S.clone();
      var m = this.m.andln(3);
      if (n(m % 2 === 1), m === 3) {
        var f = this.m.add(new s(1)).iushrn(2);
        return this.pow(S, f);
      }
      for (var g = this.m.subn(1), b = 0; !g.isZero() && g.andln(1) === 0; )
        b++, g.iushrn(1);
      n(!g.isZero());
      var w = new s(1).toRed(this), _ = w.redNeg(), E = this.m.subn(1).iushrn(1), v = this.m.bitLength();
      for (v = new s(2 * v * v).toRed(this); this.pow(v, E).cmp(_) !== 0; )
        v.redIAdd(_);
      for (var M = this.pow(v, g), P = this.pow(S, g.addn(1).iushrn(1)), B = this.pow(S, g), ue = b; B.cmp(w) !== 0; ) {
        for (var D = B, oe = 0; D.cmp(w) !== 0; oe++)
          D = D.redSqr();
        n(oe < ue);
        var Z = this.pow(M, new s(1).iushln(ue - oe - 1));
        P = P.redMul(Z), M = Z.redSqr(), B = B.redMul(M), ue = oe;
      }
      return P;
    }, pe.prototype.invm = function(S) {
      var m = S._invmp(this.m);
      return m.negative !== 0 ? (m.negative = 0, this.imod(m).redNeg()) : this.imod(m);
    }, pe.prototype.pow = function(S, m) {
      if (m.isZero()) return new s(1).toRed(this);
      if (m.cmpn(1) === 0) return S.clone();
      var f = 4, g = new Array(1 << f);
      g[0] = new s(1).toRed(this), g[1] = S;
      for (var b = 2; b < g.length; b++)
        g[b] = this.mul(g[b - 1], S);
      var w = g[0], _ = 0, E = 0, v = m.bitLength() % 26;
      for (v === 0 && (v = 26), b = m.length - 1; b >= 0; b--) {
        for (var M = m.words[b], P = v - 1; P >= 0; P--) {
          var B = M >> P & 1;
          if (w !== g[0] && (w = this.sqr(w)), B === 0 && _ === 0) {
            E = 0;
            continue;
          }
          _ <<= 1, _ |= B, E++, !(E !== f && (b !== 0 || P !== 0)) && (w = this.mul(w, g[_]), E = 0, _ = 0);
        }
        v = 26;
      }
      return w;
    }, pe.prototype.convertTo = function(S) {
      var m = S.umod(this.m);
      return m === S ? m.clone() : m;
    }, pe.prototype.convertFrom = function(S) {
      var m = S.clone();
      return m.red = null, m;
    }, s.mont = function(S) {
      return new _e(S);
    };
    function _e(Y) {
      pe.call(this, Y), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(_e, pe), _e.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, _e.prototype.convertFrom = function(S) {
      var m = this.imod(S.mul(this.rinv));
      return m.red = null, m;
    }, _e.prototype.imul = function(S, m) {
      if (S.isZero() || m.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var f = S.imul(m), g = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), b = f.isub(g).iushrn(this.shift), w = b;
      return b.cmp(this.m) >= 0 ? w = b.isub(this.m) : b.cmpn(0) < 0 && (w = b.iadd(this.m)), w._forceRed(this);
    }, _e.prototype.mul = function(S, m) {
      if (S.isZero() || m.isZero()) return new s(0)._forceRed(this);
      var f = S.mul(m), g = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), b = f.isub(g).iushrn(this.shift), w = b;
      return b.cmp(this.m) >= 0 ? w = b.isub(this.m) : b.cmpn(0) < 0 && (w = b.iadd(this.m)), w._forceRed(this);
    }, _e.prototype.invm = function(S) {
      var m = this.imod(S._invmp(this.m).mul(this.r2));
      return m._forceRed(this);
    };
  })(t, gn);
})(Jv);
var Uo = Jv.exports, Xv = {};
(function(t) {
  var e = t;
  function r(s, o) {
    if (Array.isArray(s))
      return s.slice();
    if (!s)
      return [];
    var a = [];
    if (typeof s != "string") {
      for (var u = 0; u < s.length; u++)
        a[u] = s[u] | 0;
      return a;
    }
    if (o === "hex") {
      s = s.replace(/[^a-z0-9]+/ig, ""), s.length % 2 !== 0 && (s = "0" + s);
      for (var u = 0; u < s.length; u += 2)
        a.push(parseInt(s[u] + s[u + 1], 16));
    } else
      for (var u = 0; u < s.length; u++) {
        var h = s.charCodeAt(u), d = h >> 8, p = h & 255;
        d ? a.push(d, p) : a.push(p);
      }
    return a;
  }
  e.toArray = r;
  function n(s) {
    return s.length === 1 ? "0" + s : s;
  }
  e.zero2 = n;
  function i(s) {
    for (var o = "", a = 0; a < s.length; a++)
      o += n(s[a].toString(16));
    return o;
  }
  e.toHex = i, e.encode = function(o, a) {
    return a === "hex" ? i(o) : o;
  };
})(Xv);
(function(t) {
  var e = t, r = Uo, n = mc, i = Xv;
  e.assert = n, e.toArray = i.toArray, e.zero2 = i.zero2, e.toHex = i.toHex, e.encode = i.encode;
  function s(d, p, x) {
    var A = new Array(Math.max(d.bitLength(), x) + 1), I;
    for (I = 0; I < A.length; I += 1)
      A[I] = 0;
    var N = 1 << p + 1, L = d.clone();
    for (I = 0; I < A.length; I++) {
      var F, $ = L.andln(N - 1);
      L.isOdd() ? ($ > (N >> 1) - 1 ? F = (N >> 1) - $ : F = $, L.isubn(F)) : F = 0, A[I] = F, L.iushrn(1);
    }
    return A;
  }
  e.getNAF = s;
  function o(d, p) {
    var x = [
      [],
      []
    ];
    d = d.clone(), p = p.clone();
    for (var A = 0, I = 0, N; d.cmpn(-A) > 0 || p.cmpn(-I) > 0; ) {
      var L = d.andln(3) + A & 3, F = p.andln(3) + I & 3;
      L === 3 && (L = -1), F === 3 && (F = -1);
      var $;
      L & 1 ? (N = d.andln(7) + A & 7, (N === 3 || N === 5) && F === 2 ? $ = -L : $ = L) : $ = 0, x[0].push($);
      var W;
      F & 1 ? (N = p.andln(7) + I & 7, (N === 3 || N === 5) && L === 2 ? W = -F : W = F) : W = 0, x[1].push(W), 2 * A === $ + 1 && (A = 1 - A), 2 * I === W + 1 && (I = 1 - I), d.iushrn(1), p.iushrn(1);
    }
    return x;
  }
  e.getJSF = o;
  function a(d, p, x) {
    var A = "_" + p;
    d.prototype[p] = function() {
      return this[A] !== void 0 ? this[A] : this[A] = x.call(this);
    };
  }
  e.cachedProperty = a;
  function u(d) {
    return typeof d == "string" ? e.toArray(d, "hex") : d;
  }
  e.parseBytes = u;
  function h(d) {
    return new r(d, "hex", "le");
  }
  e.intFromLE = h;
})(Bi);
var Zv = { exports: {} }, am;
Zv.exports = function(e) {
  return am || (am = new ca(null)), am.generate(e);
};
function ca(t) {
  this.rand = t;
}
Zv.exports.Rand = ca;
ca.prototype.generate = function(e) {
  return this._rand(e);
};
ca.prototype._rand = function(e) {
  if (this.rand.getBytes)
    return this.rand.getBytes(e);
  for (var r = new Uint8Array(e), n = 0; n < r.length; n++)
    r[n] = this.rand.getByte();
  return r;
};
if (typeof self == "object")
  self.crypto && self.crypto.getRandomValues ? ca.prototype._rand = function(e) {
    var r = new Uint8Array(e);
    return self.crypto.getRandomValues(r), r;
  } : self.msCrypto && self.msCrypto.getRandomValues ? ca.prototype._rand = function(e) {
    var r = new Uint8Array(e);
    return self.msCrypto.getRandomValues(r), r;
  } : typeof window == "object" && (ca.prototype._rand = function() {
    throw new Error("Not implemented yet");
  });
else
  try {
    var Mx = zl;
    if (typeof Mx.randomBytes != "function")
      throw new Error("Not supported");
    ca.prototype._rand = function(e) {
      return Mx.randomBytes(e);
    };
  } catch {
  }
var x8 = Zv.exports, Qv = {}, Ua = Uo, Yl = Bi, i0 = Yl.getNAF, zj = Yl.getJSF, s0 = Yl.assert;
function Pa(t, e) {
  this.type = t, this.p = new Ua(e.p, 16), this.red = e.prime ? Ua.red(e.prime) : Ua.mont(this.p), this.zero = new Ua(0).toRed(this.red), this.one = new Ua(1).toRed(this.red), this.two = new Ua(2).toRed(this.red), this.n = e.n && new Ua(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var r = this.n && this.p.div(this.n);
  !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var G0 = Pa;
Pa.prototype.point = function() {
  throw new Error("Not implemented");
};
Pa.prototype.validate = function() {
  throw new Error("Not implemented");
};
Pa.prototype._fixedNafMul = function(e, r) {
  s0(e.precomputed);
  var n = e._getDoubles(), i = i0(r, 1, this._bitLength), s = (1 << n.step + 1) - (n.step % 2 === 0 ? 2 : 1);
  s /= 3;
  var o = [], a, u;
  for (a = 0; a < i.length; a += n.step) {
    u = 0;
    for (var h = a + n.step - 1; h >= a; h--)
      u = (u << 1) + i[h];
    o.push(u);
  }
  for (var d = this.jpoint(null, null, null), p = this.jpoint(null, null, null), x = s; x > 0; x--) {
    for (a = 0; a < o.length; a++)
      u = o[a], u === x ? p = p.mixedAdd(n.points[a]) : u === -x && (p = p.mixedAdd(n.points[a].neg()));
    d = d.add(p);
  }
  return d.toP();
};
Pa.prototype._wnafMul = function(e, r) {
  var n = 4, i = e._getNAFPoints(n);
  n = i.wnd;
  for (var s = i.points, o = i0(r, n, this._bitLength), a = this.jpoint(null, null, null), u = o.length - 1; u >= 0; u--) {
    for (var h = 0; u >= 0 && o[u] === 0; u--)
      h++;
    if (u >= 0 && h++, a = a.dblp(h), u < 0)
      break;
    var d = o[u];
    s0(d !== 0), e.type === "affine" ? d > 0 ? a = a.mixedAdd(s[d - 1 >> 1]) : a = a.mixedAdd(s[-d - 1 >> 1].neg()) : d > 0 ? a = a.add(s[d - 1 >> 1]) : a = a.add(s[-d - 1 >> 1].neg());
  }
  return e.type === "affine" ? a.toP() : a;
};
Pa.prototype._wnafMulAdd = function(e, r, n, i, s) {
  var o = this._wnafT1, a = this._wnafT2, u = this._wnafT3, h = 0, d, p, x;
  for (d = 0; d < i; d++) {
    x = r[d];
    var A = x._getNAFPoints(e);
    o[d] = A.wnd, a[d] = A.points;
  }
  for (d = i - 1; d >= 1; d -= 2) {
    var I = d - 1, N = d;
    if (o[I] !== 1 || o[N] !== 1) {
      u[I] = i0(n[I], o[I], this._bitLength), u[N] = i0(n[N], o[N], this._bitLength), h = Math.max(u[I].length, h), h = Math.max(u[N].length, h);
      continue;
    }
    var L = [
      r[I],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      r[N]
      /* 7 */
    ];
    r[I].y.cmp(r[N].y) === 0 ? (L[1] = r[I].add(r[N]), L[2] = r[I].toJ().mixedAdd(r[N].neg())) : r[I].y.cmp(r[N].y.redNeg()) === 0 ? (L[1] = r[I].toJ().mixedAdd(r[N]), L[2] = r[I].add(r[N].neg())) : (L[1] = r[I].toJ().mixedAdd(r[N]), L[2] = r[I].toJ().mixedAdd(r[N].neg()));
    var F = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], $ = zj(n[I], n[N]);
    for (h = Math.max($[0].length, h), u[I] = new Array(h), u[N] = new Array(h), p = 0; p < h; p++) {
      var W = $[0][p] | 0, z = $[1][p] | 0;
      u[I][p] = F[(W + 1) * 3 + (z + 1)], u[N][p] = 0, a[I] = L;
    }
  }
  var V = this.jpoint(null, null, null), te = this._wnafT4;
  for (d = h; d >= 0; d--) {
    for (var R = 0; d >= 0; ) {
      var K = !0;
      for (p = 0; p < i; p++)
        te[p] = u[p][d] | 0, te[p] !== 0 && (K = !1);
      if (!K)
        break;
      R++, d--;
    }
    if (d >= 0 && R++, V = V.dblp(R), d < 0)
      break;
    for (p = 0; p < i; p++) {
      var pe = te[p];
      pe !== 0 && (pe > 0 ? x = a[p][pe - 1 >> 1] : pe < 0 && (x = a[p][-pe - 1 >> 1].neg()), x.type === "affine" ? V = V.mixedAdd(x) : V = V.add(x));
    }
  }
  for (d = 0; d < i; d++)
    a[d] = null;
  return s ? V : V.toP();
};
function ss(t, e) {
  this.curve = t, this.type = e, this.precomputed = null;
}
Pa.BasePoint = ss;
ss.prototype.eq = function() {
  throw new Error("Not implemented");
};
ss.prototype.validate = function() {
  return this.curve.validate(this);
};
Pa.prototype.decodePoint = function(e, r) {
  e = Yl.toArray(e, r);
  var n = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * n) {
    e[0] === 6 ? s0(e[e.length - 1] % 2 === 0) : e[0] === 7 && s0(e[e.length - 1] % 2 === 1);
    var i = this.point(
      e.slice(1, 1 + n),
      e.slice(1 + n, 1 + 2 * n)
    );
    return i;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n)
    return this.pointFromX(e.slice(1, 1 + n), e[0] === 3);
  throw new Error("Unknown point format");
};
ss.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
ss.prototype._encode = function(e) {
  var r = this.curve.p.byteLength(), n = this.getX().toArray("be", r);
  return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", r));
};
ss.prototype.encode = function(e, r) {
  return Yl.encode(this._encode(r), e);
};
ss.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var r = {
    doubles: null,
    naf: null,
    beta: null
  };
  return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
};
ss.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var r = this.precomputed.doubles;
  return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : !1;
};
ss.prototype._getDoubles = function(e, r) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var n = [this], i = this, s = 0; s < r; s += e) {
    for (var o = 0; o < e; o++)
      i = i.dbl();
    n.push(i);
  }
  return {
    step: e,
    points: n
  };
};
ss.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var r = [this], n = (1 << e) - 1, i = n === 1 ? null : this.dbl(), s = 1; s < n; s++)
    r[s] = r[s - 1].add(i);
  return {
    wnd: e,
    points: r
  };
};
ss.prototype._getBeta = function() {
  return null;
};
ss.prototype.dblp = function(e) {
  for (var r = this, n = 0; n < e; n++)
    r = r.dbl();
  return r;
};
var Hj = Bi, rn = Uo, eb = z0, $u = G0, Wj = Hj.assert;
function os(t) {
  $u.call(this, "short", t), this.a = new rn(t.a, 16).toRed(this.red), this.b = new rn(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
eb(os, $u);
var Kj = os;
os.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var r, n;
    if (e.beta)
      r = new rn(e.beta, 16).toRed(this.red);
    else {
      var i = this._getEndoRoots(this.p);
      r = i[0].cmp(i[1]) < 0 ? i[0] : i[1], r = r.toRed(this.red);
    }
    if (e.lambda)
      n = new rn(e.lambda, 16);
    else {
      var s = this._getEndoRoots(this.n);
      this.g.mul(s[0]).x.cmp(this.g.x.redMul(r)) === 0 ? n = s[0] : (n = s[1], Wj(this.g.mul(n).x.cmp(this.g.x.redMul(r)) === 0));
    }
    var o;
    return e.basis ? o = e.basis.map(function(a) {
      return {
        a: new rn(a.a, 16),
        b: new rn(a.b, 16)
      };
    }) : o = this._getEndoBasis(n), {
      beta: r,
      lambda: n,
      basis: o
    };
  }
};
os.prototype._getEndoRoots = function(e) {
  var r = e === this.p ? this.red : rn.mont(e), n = new rn(2).toRed(r).redInvm(), i = n.redNeg(), s = new rn(3).toRed(r).redNeg().redSqrt().redMul(n), o = i.redAdd(s).fromRed(), a = i.redSub(s).fromRed();
  return [o, a];
};
os.prototype._getEndoBasis = function(e) {
  for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), n = e, i = this.n.clone(), s = new rn(1), o = new rn(0), a = new rn(0), u = new rn(1), h, d, p, x, A, I, N, L = 0, F, $; n.cmpn(0) !== 0; ) {
    var W = i.div(n);
    F = i.sub(W.mul(n)), $ = a.sub(W.mul(s));
    var z = u.sub(W.mul(o));
    if (!p && F.cmp(r) < 0)
      h = N.neg(), d = s, p = F.neg(), x = $;
    else if (p && ++L === 2)
      break;
    N = F, i = n, n = F, a = s, s = $, u = o, o = z;
  }
  A = F.neg(), I = $;
  var V = p.sqr().add(x.sqr()), te = A.sqr().add(I.sqr());
  return te.cmp(V) >= 0 && (A = h, I = d), p.negative && (p = p.neg(), x = x.neg()), A.negative && (A = A.neg(), I = I.neg()), [
    { a: p, b: x },
    { a: A, b: I }
  ];
};
os.prototype._endoSplit = function(e) {
  var r = this.endo.basis, n = r[0], i = r[1], s = i.b.mul(e).divRound(this.n), o = n.b.neg().mul(e).divRound(this.n), a = s.mul(n.a), u = o.mul(i.a), h = s.mul(n.b), d = o.mul(i.b), p = e.sub(a).sub(u), x = h.add(d).neg();
  return { k1: p, k2: x };
};
os.prototype.pointFromX = function(e, r) {
  e = new rn(e, 16), e.red || (e = e.toRed(this.red));
  var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), i = n.redSqrt();
  if (i.redSqr().redSub(n).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var s = i.fromRed().isOdd();
  return (r && !s || !r && s) && (i = i.redNeg()), this.point(e, i);
};
os.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var r = e.x, n = e.y, i = this.a.redMul(r), s = r.redSqr().redMul(r).redIAdd(i).redIAdd(this.b);
  return n.redSqr().redISub(s).cmpn(0) === 0;
};
os.prototype._endoWnafMulAdd = function(e, r, n) {
  for (var i = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < e.length; o++) {
    var a = this._endoSplit(r[o]), u = e[o], h = u._getBeta();
    a.k1.negative && (a.k1.ineg(), u = u.neg(!0)), a.k2.negative && (a.k2.ineg(), h = h.neg(!0)), i[o * 2] = u, i[o * 2 + 1] = h, s[o * 2] = a.k1, s[o * 2 + 1] = a.k2;
  }
  for (var d = this._wnafMulAdd(1, i, s, o * 2, n), p = 0; p < o * 2; p++)
    i[p] = null, s[p] = null;
  return d;
};
function Ln(t, e, r, n) {
  $u.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new rn(e, 16), this.y = new rn(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
eb(Ln, $u.BasePoint);
os.prototype.point = function(e, r, n) {
  return new Ln(this, e, r, n);
};
os.prototype.pointFromJSON = function(e, r) {
  return Ln.fromJSON(this, e, r);
};
Ln.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var n = this.curve, i = function(s) {
        return n.point(s.x.redMul(n.endo.beta), s.y);
      };
      e.beta = r, r.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(i)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(i)
        }
      };
    }
    return r;
  }
};
Ln.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Ln.fromJSON = function(e, r, n) {
  typeof r == "string" && (r = JSON.parse(r));
  var i = e.point(r[0], r[1], n);
  if (!r[2])
    return i;
  function s(a) {
    return e.point(a[0], a[1], n);
  }
  var o = r[2];
  return i.precomputed = {
    beta: null,
    doubles: o.doubles && {
      step: o.doubles.step,
      points: [i].concat(o.doubles.points.map(s))
    },
    naf: o.naf && {
      wnd: o.naf.wnd,
      points: [i].concat(o.naf.points.map(s))
    }
  }, i;
};
Ln.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Ln.prototype.isInfinity = function() {
  return this.inf;
};
Ln.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var r = this.y.redSub(e.y);
  r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
  var n = r.redSqr().redISub(this.x).redISub(e.x), i = r.redMul(this.x.redSub(n)).redISub(this.y);
  return this.curve.point(n, i);
};
Ln.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var r = this.curve.a, n = this.x.redSqr(), i = e.redInvm(), s = n.redAdd(n).redIAdd(n).redIAdd(r).redMul(i), o = s.redSqr().redISub(this.x.redAdd(this.x)), a = s.redMul(this.x.redSub(o)).redISub(this.y);
  return this.curve.point(o, a);
};
Ln.prototype.getX = function() {
  return this.x.fromRed();
};
Ln.prototype.getY = function() {
  return this.y.fromRed();
};
Ln.prototype.mul = function(e) {
  return e = new rn(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
Ln.prototype.mulAdd = function(e, r, n) {
  var i = [this, r], s = [e, n];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2);
};
Ln.prototype.jmulAdd = function(e, r, n) {
  var i = [this, r], s = [e, n];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, !0) : this.curve._wnafMulAdd(1, i, s, 2, !0);
};
Ln.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
Ln.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var r = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var n = this.precomputed, i = function(s) {
      return s.neg();
    };
    r.precomputed = {
      naf: n.naf && {
        wnd: n.naf.wnd,
        points: n.naf.points.map(i)
      },
      doubles: n.doubles && {
        step: n.doubles.step,
        points: n.doubles.points.map(i)
      }
    };
  }
  return r;
};
Ln.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function zn(t, e, r, n) {
  $u.BasePoint.call(this, t, "jacobian"), e === null && r === null && n === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new rn(0)) : (this.x = new rn(e, 16), this.y = new rn(r, 16), this.z = new rn(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
eb(zn, $u.BasePoint);
os.prototype.jpoint = function(e, r, n) {
  return new zn(this, e, r, n);
};
zn.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), r = e.redSqr(), n = this.x.redMul(r), i = this.y.redMul(r).redMul(e);
  return this.curve.point(n, i);
};
zn.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
zn.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var r = e.z.redSqr(), n = this.z.redSqr(), i = this.x.redMul(r), s = e.x.redMul(n), o = this.y.redMul(r.redMul(e.z)), a = e.y.redMul(n.redMul(this.z)), u = i.redSub(s), h = o.redSub(a);
  if (u.cmpn(0) === 0)
    return h.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var d = u.redSqr(), p = d.redMul(u), x = i.redMul(d), A = h.redSqr().redIAdd(p).redISub(x).redISub(x), I = h.redMul(x.redISub(A)).redISub(o.redMul(p)), N = this.z.redMul(e.z).redMul(u);
  return this.curve.jpoint(A, I, N);
};
zn.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var r = this.z.redSqr(), n = this.x, i = e.x.redMul(r), s = this.y, o = e.y.redMul(r).redMul(this.z), a = n.redSub(i), u = s.redSub(o);
  if (a.cmpn(0) === 0)
    return u.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var h = a.redSqr(), d = h.redMul(a), p = n.redMul(h), x = u.redSqr().redIAdd(d).redISub(p).redISub(p), A = u.redMul(p.redISub(x)).redISub(s.redMul(d)), I = this.z.redMul(a);
  return this.curve.jpoint(x, A, I);
};
zn.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var r;
  if (this.curve.zeroA || this.curve.threeA) {
    var n = this;
    for (r = 0; r < e; r++)
      n = n.dbl();
    return n;
  }
  var i = this.curve.a, s = this.curve.tinv, o = this.x, a = this.y, u = this.z, h = u.redSqr().redSqr(), d = a.redAdd(a);
  for (r = 0; r < e; r++) {
    var p = o.redSqr(), x = d.redSqr(), A = x.redSqr(), I = p.redAdd(p).redIAdd(p).redIAdd(i.redMul(h)), N = o.redMul(x), L = I.redSqr().redISub(N.redAdd(N)), F = N.redISub(L), $ = I.redMul(F);
    $ = $.redIAdd($).redISub(A);
    var W = d.redMul(u);
    r + 1 < e && (h = h.redMul(A)), o = L, u = W, d = $;
  }
  return this.curve.jpoint(o, d.redMul(s), u);
};
zn.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
zn.prototype._zeroDbl = function() {
  var e, r, n;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
    a = a.redIAdd(a);
    var u = i.redAdd(i).redIAdd(i), h = u.redSqr().redISub(a).redISub(a), d = o.redIAdd(o);
    d = d.redIAdd(d), d = d.redIAdd(d), e = h, r = u.redMul(a.redISub(h)).redISub(d), n = this.y.redAdd(this.y);
  } else {
    var p = this.x.redSqr(), x = this.y.redSqr(), A = x.redSqr(), I = this.x.redAdd(x).redSqr().redISub(p).redISub(A);
    I = I.redIAdd(I);
    var N = p.redAdd(p).redIAdd(p), L = N.redSqr(), F = A.redIAdd(A);
    F = F.redIAdd(F), F = F.redIAdd(F), e = L.redISub(I).redISub(I), r = N.redMul(I.redISub(e)).redISub(F), n = this.y.redMul(this.z), n = n.redIAdd(n);
  }
  return this.curve.jpoint(e, r, n);
};
zn.prototype._threeDbl = function() {
  var e, r, n;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
    a = a.redIAdd(a);
    var u = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a), h = u.redSqr().redISub(a).redISub(a);
    e = h;
    var d = o.redIAdd(o);
    d = d.redIAdd(d), d = d.redIAdd(d), r = u.redMul(a.redISub(h)).redISub(d), n = this.y.redAdd(this.y);
  } else {
    var p = this.z.redSqr(), x = this.y.redSqr(), A = this.x.redMul(x), I = this.x.redSub(p).redMul(this.x.redAdd(p));
    I = I.redAdd(I).redIAdd(I);
    var N = A.redIAdd(A);
    N = N.redIAdd(N);
    var L = N.redAdd(N);
    e = I.redSqr().redISub(L), n = this.y.redAdd(this.z).redSqr().redISub(x).redISub(p);
    var F = x.redSqr();
    F = F.redIAdd(F), F = F.redIAdd(F), F = F.redIAdd(F), r = I.redMul(N.redISub(e)).redISub(F);
  }
  return this.curve.jpoint(e, r, n);
};
zn.prototype._dbl = function() {
  var e = this.curve.a, r = this.x, n = this.y, i = this.z, s = i.redSqr().redSqr(), o = r.redSqr(), a = n.redSqr(), u = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(s)), h = r.redAdd(r);
  h = h.redIAdd(h);
  var d = h.redMul(a), p = u.redSqr().redISub(d.redAdd(d)), x = d.redISub(p), A = a.redSqr();
  A = A.redIAdd(A), A = A.redIAdd(A), A = A.redIAdd(A);
  var I = u.redMul(x).redISub(A), N = n.redAdd(n).redMul(i);
  return this.curve.jpoint(p, I, N);
};
zn.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr(), i = r.redSqr(), s = e.redAdd(e).redIAdd(e), o = s.redSqr(), a = this.x.redAdd(r).redSqr().redISub(e).redISub(i);
  a = a.redIAdd(a), a = a.redAdd(a).redIAdd(a), a = a.redISub(o);
  var u = a.redSqr(), h = i.redIAdd(i);
  h = h.redIAdd(h), h = h.redIAdd(h), h = h.redIAdd(h);
  var d = s.redIAdd(a).redSqr().redISub(o).redISub(u).redISub(h), p = r.redMul(d);
  p = p.redIAdd(p), p = p.redIAdd(p);
  var x = this.x.redMul(u).redISub(p);
  x = x.redIAdd(x), x = x.redIAdd(x);
  var A = this.y.redMul(d.redMul(h.redISub(d)).redISub(a.redMul(u)));
  A = A.redIAdd(A), A = A.redIAdd(A), A = A.redIAdd(A);
  var I = this.z.redAdd(a).redSqr().redISub(n).redISub(u);
  return this.curve.jpoint(x, A, I);
};
zn.prototype.mul = function(e, r) {
  return e = new rn(e, r), this.curve._wnafMul(this, e);
};
zn.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var r = this.z.redSqr(), n = e.z.redSqr();
  if (this.x.redMul(n).redISub(e.x.redMul(r)).cmpn(0) !== 0)
    return !1;
  var i = r.redMul(this.z), s = n.redMul(e.z);
  return this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0) === 0;
};
zn.prototype.eqXToP = function(e) {
  var r = this.z.redSqr(), n = e.toRed(this.curve.red).redMul(r);
  if (this.x.cmp(n) === 0)
    return !0;
  for (var i = e.clone(), s = this.curve.redN.redMul(r); ; ) {
    if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)
      return !1;
    if (n.redIAdd(s), this.x.cmp(n) === 0)
      return !0;
  }
};
zn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
zn.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var Xc = Uo, _8 = z0, Y0 = G0, Vj = Bi;
function Bu(t) {
  Y0.call(this, "mont", t), this.a = new Xc(t.a, 16).toRed(this.red), this.b = new Xc(t.b, 16).toRed(this.red), this.i4 = new Xc(4).toRed(this.red).redInvm(), this.two = new Xc(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
_8(Bu, Y0);
var Gj = Bu;
Bu.prototype.validate = function(e) {
  var r = e.normalize().x, n = r.redSqr(), i = n.redMul(r).redAdd(n.redMul(this.a)).redAdd(r), s = i.redSqrt();
  return s.redSqr().cmp(i) === 0;
};
function On(t, e, r) {
  Y0.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new Xc(e, 16), this.z = new Xc(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
_8(On, Y0.BasePoint);
Bu.prototype.decodePoint = function(e, r) {
  return this.point(Vj.toArray(e, r), 1);
};
Bu.prototype.point = function(e, r) {
  return new On(this, e, r);
};
Bu.prototype.pointFromJSON = function(e) {
  return On.fromJSON(this, e);
};
On.prototype.precompute = function() {
};
On.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
On.fromJSON = function(e, r) {
  return new On(e, r[0], r[1] || e.one);
};
On.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
On.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
On.prototype.dbl = function() {
  var e = this.x.redAdd(this.z), r = e.redSqr(), n = this.x.redSub(this.z), i = n.redSqr(), s = r.redSub(i), o = r.redMul(i), a = s.redMul(i.redAdd(this.curve.a24.redMul(s)));
  return this.curve.point(o, a);
};
On.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
On.prototype.diffAdd = function(e, r) {
  var n = this.x.redAdd(this.z), i = this.x.redSub(this.z), s = e.x.redAdd(e.z), o = e.x.redSub(e.z), a = o.redMul(n), u = s.redMul(i), h = r.z.redMul(a.redAdd(u).redSqr()), d = r.x.redMul(a.redISub(u).redSqr());
  return this.curve.point(h, d);
};
On.prototype.mul = function(e) {
  for (var r = e.clone(), n = this, i = this.curve.point(null, null), s = this, o = []; r.cmpn(0) !== 0; r.iushrn(1))
    o.push(r.andln(1));
  for (var a = o.length - 1; a >= 0; a--)
    o[a] === 0 ? (n = n.diffAdd(i, s), i = i.dbl()) : (i = n.diffAdd(i, s), n = n.dbl());
  return i;
};
On.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
On.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
On.prototype.eq = function(e) {
  return this.getX().cmp(e.getX()) === 0;
};
On.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
On.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var Yj = Bi, _o = Uo, E8 = z0, J0 = G0, Jj = Yj.assert;
function to(t) {
  this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, J0.call(this, "edwards", t), this.a = new _o(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new _o(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new _o(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), Jj(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
}
E8(to, J0);
var Xj = to;
to.prototype._mulA = function(e) {
  return this.mOneA ? e.redNeg() : this.a.redMul(e);
};
to.prototype._mulC = function(e) {
  return this.oneC ? e : this.c.redMul(e);
};
to.prototype.jpoint = function(e, r, n, i) {
  return this.point(e, r, n, i);
};
to.prototype.pointFromX = function(e, r) {
  e = new _o(e, 16), e.red || (e = e.toRed(this.red));
  var n = e.redSqr(), i = this.c2.redSub(this.a.redMul(n)), s = this.one.redSub(this.c2.redMul(this.d).redMul(n)), o = i.redMul(s.redInvm()), a = o.redSqrt();
  if (a.redSqr().redSub(o).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var u = a.fromRed().isOdd();
  return (r && !u || !r && u) && (a = a.redNeg()), this.point(e, a);
};
to.prototype.pointFromY = function(e, r) {
  e = new _o(e, 16), e.red || (e = e.toRed(this.red));
  var n = e.redSqr(), i = n.redSub(this.c2), s = n.redMul(this.d).redMul(this.c2).redSub(this.a), o = i.redMul(s.redInvm());
  if (o.cmp(this.zero) === 0) {
    if (r)
      throw new Error("invalid point");
    return this.point(this.zero, e);
  }
  var a = o.redSqrt();
  if (a.redSqr().redSub(o).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return a.fromRed().isOdd() !== r && (a = a.redNeg()), this.point(a, e);
};
to.prototype.validate = function(e) {
  if (e.isInfinity())
    return !0;
  e.normalize();
  var r = e.x.redSqr(), n = e.y.redSqr(), i = r.redMul(this.a).redAdd(n), s = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(n)));
  return i.cmp(s) === 0;
};
function Wr(t, e, r, n, i) {
  J0.BasePoint.call(this, t, "projective"), e === null && r === null && n === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new _o(e, 16), this.y = new _o(r, 16), this.z = n ? new _o(n, 16) : this.curve.one, this.t = i && new _o(i, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
E8(Wr, J0.BasePoint);
to.prototype.pointFromJSON = function(e) {
  return Wr.fromJSON(this, e);
};
to.prototype.point = function(e, r, n, i) {
  return new Wr(this, e, r, n, i);
};
Wr.fromJSON = function(e, r) {
  return new Wr(e, r[0], r[1], r[2]);
};
Wr.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Wr.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Wr.prototype._extDbl = function() {
  var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr();
  n = n.redIAdd(n);
  var i = this.curve._mulA(e), s = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r), o = i.redAdd(r), a = o.redSub(n), u = i.redSub(r), h = s.redMul(a), d = o.redMul(u), p = s.redMul(u), x = a.redMul(o);
  return this.curve.point(h, d, x, p);
};
Wr.prototype._projDbl = function() {
  var e = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), n = this.y.redSqr(), i, s, o, a, u, h;
  if (this.curve.twisted) {
    a = this.curve._mulA(r);
    var d = a.redAdd(n);
    this.zOne ? (i = e.redSub(r).redSub(n).redMul(d.redSub(this.curve.two)), s = d.redMul(a.redSub(n)), o = d.redSqr().redSub(d).redSub(d)) : (u = this.z.redSqr(), h = d.redSub(u).redISub(u), i = e.redSub(r).redISub(n).redMul(h), s = d.redMul(a.redSub(n)), o = d.redMul(h));
  } else
    a = r.redAdd(n), u = this.curve._mulC(this.z).redSqr(), h = a.redSub(u).redSub(u), i = this.curve._mulC(e.redISub(a)).redMul(h), s = this.curve._mulC(a).redMul(r.redISub(n)), o = a.redMul(h);
  return this.curve.point(i, s, o);
};
Wr.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Wr.prototype._extAdd = function(e) {
  var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), n = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), i = this.t.redMul(this.curve.dd).redMul(e.t), s = this.z.redMul(e.z.redAdd(e.z)), o = n.redSub(r), a = s.redSub(i), u = s.redAdd(i), h = n.redAdd(r), d = o.redMul(a), p = u.redMul(h), x = o.redMul(h), A = a.redMul(u);
  return this.curve.point(d, p, A, x);
};
Wr.prototype._projAdd = function(e) {
  var r = this.z.redMul(e.z), n = r.redSqr(), i = this.x.redMul(e.x), s = this.y.redMul(e.y), o = this.curve.d.redMul(i).redMul(s), a = n.redSub(o), u = n.redAdd(o), h = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(i).redISub(s), d = r.redMul(a).redMul(h), p, x;
  return this.curve.twisted ? (p = r.redMul(u).redMul(s.redSub(this.curve._mulA(i))), x = a.redMul(u)) : (p = r.redMul(u).redMul(s.redSub(i)), x = this.curve._mulC(a).redMul(u)), this.curve.point(d, p, x);
};
Wr.prototype.add = function(e) {
  return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
};
Wr.prototype.mul = function(e) {
  return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
};
Wr.prototype.mulAdd = function(e, r, n) {
  return this.curve._wnafMulAdd(1, [this, r], [e, n], 2, !1);
};
Wr.prototype.jmulAdd = function(e, r, n) {
  return this.curve._wnafMulAdd(1, [this, r], [e, n], 2, !0);
};
Wr.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var e = this.z.redInvm();
  return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this;
};
Wr.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Wr.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
Wr.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
Wr.prototype.eq = function(e) {
  return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
};
Wr.prototype.eqXToP = function(e) {
  var r = e.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(r) === 0)
    return !0;
  for (var n = e.clone(), i = this.curve.redN.redMul(this.z); ; ) {
    if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0)
      return !1;
    if (r.redIAdd(i), this.x.cmp(r) === 0)
      return !0;
  }
};
Wr.prototype.toP = Wr.prototype.normalize;
Wr.prototype.mixedAdd = Wr.prototype.add;
(function(t) {
  var e = t;
  e.base = G0, e.short = Kj, e.mont = Gj, e.edwards = Xj;
})(Qv);
var X0 = {}, cm, Ix;
function Zj() {
  return Ix || (Ix = 1, cm = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), cm;
}
(function(t) {
  var e = t, r = Kl, n = Qv, i = Bi, s = i.assert;
  function o(h) {
    h.type === "short" ? this.curve = new n.short(h) : h.type === "edwards" ? this.curve = new n.edwards(h) : this.curve = new n.mont(h), this.g = this.curve.g, this.n = this.curve.n, this.hash = h.hash, s(this.g.validate(), "Invalid curve"), s(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  e.PresetCurve = o;
  function a(h, d) {
    Object.defineProperty(e, h, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var p = new o(d);
        return Object.defineProperty(e, h, {
          configurable: !0,
          enumerable: !0,
          value: p
        }), p;
      }
    });
  }
  a("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: r.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), a("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: r.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), a("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: r.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), a("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: r.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), a("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: r.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), a("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: r.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), a("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: r.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var u;
  try {
    u = Zj();
  } catch {
    u = void 0;
  }
  a("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: r.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      u
    ]
  });
})(X0);
var Qj = Kl, rc = Xv, S8 = mc;
function ma(t) {
  if (!(this instanceof ma))
    return new ma(t);
  this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var e = rc.toArray(t.entropy, t.entropyEnc || "hex"), r = rc.toArray(t.nonce, t.nonceEnc || "hex"), n = rc.toArray(t.pers, t.persEnc || "hex");
  S8(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(e, r, n);
}
var eq = ma;
ma.prototype._init = function(e, r, n) {
  var i = e.concat(r).concat(n);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var s = 0; s < this.V.length; s++)
    this.K[s] = 0, this.V[s] = 1;
  this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656;
};
ma.prototype._hmac = function() {
  return new Qj.hmac(this.hash, this.K);
};
ma.prototype._update = function(e) {
  var r = this._hmac().update(this.V).update([0]);
  e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
ma.prototype.reseed = function(e, r, n, i) {
  typeof r != "string" && (i = n, n = r, r = null), e = rc.toArray(e, r), n = rc.toArray(n, i), S8(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(n || [])), this._reseed = 1;
};
ma.prototype.generate = function(e, r, n, i) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof r != "string" && (i = n, n = r, r = null), n && (n = rc.toArray(n, i || "hex"), this._update(n));
  for (var s = []; s.length < e; )
    this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
  var o = s.slice(0, e);
  return this._update(n), this._reseed++, rc.encode(o, r);
};
var tq = Uo, rq = Bi, P1 = rq.assert;
function Zn(t, e) {
  this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var nq = Zn;
Zn.fromPublic = function(e, r, n) {
  return r instanceof Zn ? r : new Zn(e, {
    pub: r,
    pubEnc: n
  });
};
Zn.fromPrivate = function(e, r, n) {
  return r instanceof Zn ? r : new Zn(e, {
    priv: r,
    privEnc: n
  });
};
Zn.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
Zn.prototype.getPublic = function(e, r) {
  return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
};
Zn.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
Zn.prototype._importPrivate = function(e, r) {
  this.priv = new tq(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
Zn.prototype._importPublic = function(e, r) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? P1(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && P1(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, r);
};
Zn.prototype.derive = function(e) {
  return e.validate() || P1(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
Zn.prototype.sign = function(e, r, n) {
  return this.ec.sign(e, this, r, n);
};
Zn.prototype.verify = function(e, r, n) {
  return this.ec.verify(e, r, this, void 0, n);
};
Zn.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var o0 = Uo, tb = Bi, iq = tb.assert;
function Z0(t, e) {
  if (t instanceof Z0)
    return t;
  this._importDER(t, e) || (iq(t.r && t.s, "Signature without r or s"), this.r = new o0(t.r, 16), this.s = new o0(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
}
var sq = Z0;
function oq() {
  this.place = 0;
}
function um(t, e) {
  var r = t[e.place++];
  if (!(r & 128))
    return r;
  var n = r & 15;
  if (n === 0 || n > 4 || t[e.place] === 0)
    return !1;
  for (var i = 0, s = 0, o = e.place; s < n; s++, o++)
    i <<= 8, i |= t[o], i >>>= 0;
  return i <= 127 ? !1 : (e.place = o, i);
}
function Cx(t) {
  for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r; )
    e++;
  return e === 0 ? t : t.slice(e);
}
Z0.prototype._importDER = function(e, r) {
  e = tb.toArray(e, r);
  var n = new oq();
  if (e[n.place++] !== 48)
    return !1;
  var i = um(e, n);
  if (i === !1 || i + n.place !== e.length || e[n.place++] !== 2)
    return !1;
  var s = um(e, n);
  if (s === !1 || e[n.place] & 128)
    return !1;
  var o = e.slice(n.place, s + n.place);
  if (n.place += s, e[n.place++] !== 2)
    return !1;
  var a = um(e, n);
  if (a === !1 || e.length !== a + n.place || e[n.place] & 128)
    return !1;
  var u = e.slice(n.place, a + n.place);
  if (o[0] === 0)
    if (o[1] & 128)
      o = o.slice(1);
    else
      return !1;
  if (u[0] === 0)
    if (u[1] & 128)
      u = u.slice(1);
    else
      return !1;
  return this.r = new o0(o), this.s = new o0(u), this.recoveryParam = null, !0;
};
function fm(t, e) {
  if (e < 128) {
    t.push(e);
    return;
  }
  var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
  for (t.push(r | 128); --r; )
    t.push(e >>> (r << 3) & 255);
  t.push(e);
}
Z0.prototype.toDER = function(e) {
  var r = this.r.toArray(), n = this.s.toArray();
  for (r[0] & 128 && (r = [0].concat(r)), n[0] & 128 && (n = [0].concat(n)), r = Cx(r), n = Cx(n); !n[0] && !(n[1] & 128); )
    n = n.slice(1);
  var i = [2];
  fm(i, r.length), i = i.concat(r), i.push(2), fm(i, n.length);
  var s = i.concat(n), o = [48];
  return fm(o, s.length), o = o.concat(s), tb.encode(o, e);
};
var Eo = Uo, A8 = eq, aq = Bi, lm = X0, cq = x8, P8 = aq.assert, rb = nq, Q0 = sq;
function es(t) {
  if (!(this instanceof es))
    return new es(t);
  typeof t == "string" && (P8(
    Object.prototype.hasOwnProperty.call(lm, t),
    "Unknown curve " + t
  ), t = lm[t]), t instanceof lm.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
}
var uq = es;
es.prototype.keyPair = function(e) {
  return new rb(this, e);
};
es.prototype.keyFromPrivate = function(e, r) {
  return rb.fromPrivate(this, e, r);
};
es.prototype.keyFromPublic = function(e, r) {
  return rb.fromPublic(this, e, r);
};
es.prototype.genKeyPair = function(e) {
  e || (e = {});
  for (var r = new A8({
    hash: this.hash,
    pers: e.pers,
    persEnc: e.persEnc || "utf8",
    entropy: e.entropy || cq(this.hash.hmacStrength),
    entropyEnc: e.entropy && e.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), n = this.n.byteLength(), i = this.n.sub(new Eo(2)); ; ) {
    var s = new Eo(r.generate(n));
    if (!(s.cmp(i) > 0))
      return s.iaddn(1), this.keyFromPrivate(s);
  }
};
es.prototype._truncateToN = function(e, r, n) {
  var i;
  if (Eo.isBN(e) || typeof e == "number")
    e = new Eo(e, 16), i = e.byteLength();
  else if (typeof e == "object")
    i = e.length, e = new Eo(e, 16);
  else {
    var s = e.toString();
    i = s.length + 1 >>> 1, e = new Eo(s, 16);
  }
  typeof n != "number" && (n = i * 8);
  var o = n - this.n.bitLength();
  return o > 0 && (e = e.ushrn(o)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
};
es.prototype.sign = function(e, r, n, i) {
  typeof n == "object" && (i = n, n = null), i || (i = {}), r = this.keyFromPrivate(r, n), e = this._truncateToN(e, !1, i.msgBitLength);
  for (var s = this.n.byteLength(), o = r.getPrivate().toArray("be", s), a = e.toArray("be", s), u = new A8({
    hash: this.hash,
    entropy: o,
    nonce: a,
    pers: i.pers,
    persEnc: i.persEnc || "utf8"
  }), h = this.n.sub(new Eo(1)), d = 0; ; d++) {
    var p = i.k ? i.k(d) : new Eo(u.generate(this.n.byteLength()));
    if (p = this._truncateToN(p, !0), !(p.cmpn(1) <= 0 || p.cmp(h) >= 0)) {
      var x = this.g.mul(p);
      if (!x.isInfinity()) {
        var A = x.getX(), I = A.umod(this.n);
        if (I.cmpn(0) !== 0) {
          var N = p.invm(this.n).mul(I.mul(r.getPrivate()).iadd(e));
          if (N = N.umod(this.n), N.cmpn(0) !== 0) {
            var L = (x.getY().isOdd() ? 1 : 0) | (A.cmp(I) !== 0 ? 2 : 0);
            return i.canonical && N.cmp(this.nh) > 0 && (N = this.n.sub(N), L ^= 1), new Q0({ r: I, s: N, recoveryParam: L });
          }
        }
      }
    }
  }
};
es.prototype.verify = function(e, r, n, i, s) {
  s || (s = {}), e = this._truncateToN(e, !1, s.msgBitLength), n = this.keyFromPublic(n, i), r = new Q0(r, "hex");
  var o = r.r, a = r.s;
  if (o.cmpn(1) < 0 || o.cmp(this.n) >= 0 || a.cmpn(1) < 0 || a.cmp(this.n) >= 0)
    return !1;
  var u = a.invm(this.n), h = u.mul(e).umod(this.n), d = u.mul(o).umod(this.n), p;
  return this.curve._maxwellTrick ? (p = this.g.jmulAdd(h, n.getPublic(), d), p.isInfinity() ? !1 : p.eqXToP(o)) : (p = this.g.mulAdd(h, n.getPublic(), d), p.isInfinity() ? !1 : p.getX().umod(this.n).cmp(o) === 0);
};
es.prototype.recoverPubKey = function(t, e, r, n) {
  P8((3 & r) === r, "The recovery param is more than two bits"), e = new Q0(e, n);
  var i = this.n, s = new Eo(t), o = e.r, a = e.s, u = r & 1, h = r >> 1;
  if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && h)
    throw new Error("Unable to find sencond key candinate");
  h ? o = this.curve.pointFromX(o.add(this.curve.n), u) : o = this.curve.pointFromX(o, u);
  var d = e.r.invm(i), p = i.sub(s).mul(d).umod(i), x = a.mul(d).umod(i);
  return this.g.mulAdd(p, o, x);
};
es.prototype.getKeyRecoveryParam = function(t, e, r, n) {
  if (e = new Q0(e, n), e.recoveryParam !== null)
    return e.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var s;
    try {
      s = this.recoverPubKey(t, e, i);
    } catch {
      continue;
    }
    if (s.eq(r))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var Jl = Bi, M8 = Jl.assert, Tx = Jl.parseBytes, Fu = Jl.cachedProperty;
function Dn(t, e) {
  this.eddsa = t, this._secret = Tx(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = Tx(e.pub);
}
Dn.fromPublic = function(e, r) {
  return r instanceof Dn ? r : new Dn(e, { pub: r });
};
Dn.fromSecret = function(e, r) {
  return r instanceof Dn ? r : new Dn(e, { secret: r });
};
Dn.prototype.secret = function() {
  return this._secret;
};
Fu(Dn, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
Fu(Dn, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
Fu(Dn, "privBytes", function() {
  var e = this.eddsa, r = this.hash(), n = e.encodingLength - 1, i = r.slice(0, e.encodingLength);
  return i[0] &= 248, i[n] &= 127, i[n] |= 64, i;
});
Fu(Dn, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
Fu(Dn, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
Fu(Dn, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
Dn.prototype.sign = function(e) {
  return M8(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
};
Dn.prototype.verify = function(e, r) {
  return this.eddsa.verify(e, r, this);
};
Dn.prototype.getSecret = function(e) {
  return M8(this._secret, "KeyPair is public only"), Jl.encode(this.secret(), e);
};
Dn.prototype.getPublic = function(e) {
  return Jl.encode(this.pubBytes(), e);
};
var fq = Dn, lq = Uo, ep = Bi, Rx = ep.assert, tp = ep.cachedProperty, hq = ep.parseBytes;
function bc(t, e) {
  this.eddsa = t, typeof e != "object" && (e = hq(e)), Array.isArray(e) && (Rx(e.length === t.encodingLength * 2, "Signature has invalid size"), e = {
    R: e.slice(0, t.encodingLength),
    S: e.slice(t.encodingLength)
  }), Rx(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof lq && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
}
tp(bc, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
tp(bc, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
tp(bc, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
tp(bc, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
bc.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
bc.prototype.toHex = function() {
  return ep.encode(this.toBytes(), "hex").toUpperCase();
};
var dq = bc, pq = Kl, gq = X0, Eu = Bi, mq = Eu.assert, I8 = Eu.parseBytes, C8 = fq, Dx = dq;
function _i(t) {
  if (mq(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof _i))
    return new _i(t);
  t = gq[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = pq.sha512;
}
var vq = _i;
_i.prototype.sign = function(e, r) {
  e = I8(e);
  var n = this.keyFromSecret(r), i = this.hashInt(n.messagePrefix(), e), s = this.g.mul(i), o = this.encodePoint(s), a = this.hashInt(o, n.pubBytes(), e).mul(n.priv()), u = i.add(a).umod(this.curve.n);
  return this.makeSignature({ R: s, S: u, Rencoded: o });
};
_i.prototype.verify = function(e, r, n) {
  if (e = I8(e), r = this.makeSignature(r), r.S().gte(r.eddsa.curve.n) || r.S().isNeg())
    return !1;
  var i = this.keyFromPublic(n), s = this.hashInt(r.Rencoded(), i.pubBytes(), e), o = this.g.mul(r.S()), a = r.R().add(i.pub().mul(s));
  return a.eq(o);
};
_i.prototype.hashInt = function() {
  for (var e = this.hash(), r = 0; r < arguments.length; r++)
    e.update(arguments[r]);
  return Eu.intFromLE(e.digest()).umod(this.curve.n);
};
_i.prototype.keyFromPublic = function(e) {
  return C8.fromPublic(this, e);
};
_i.prototype.keyFromSecret = function(e) {
  return C8.fromSecret(this, e);
};
_i.prototype.makeSignature = function(e) {
  return e instanceof Dx ? e : new Dx(this, e);
};
_i.prototype.encodePoint = function(e) {
  var r = e.getY().toArray("le", this.encodingLength);
  return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r;
};
_i.prototype.decodePoint = function(e) {
  e = Eu.parseBytes(e);
  var r = e.length - 1, n = e.slice(0, r).concat(e[r] & -129), i = (e[r] & 128) !== 0, s = Eu.intFromLE(n);
  return this.curve.pointFromY(s, i);
};
_i.prototype.encodeInt = function(e) {
  return e.toArray("le", this.encodingLength);
};
_i.prototype.decodeInt = function(e) {
  return Eu.intFromLE(e);
};
_i.prototype.isPoint = function(e) {
  return e instanceof this.pointClass;
};
(function(t) {
  var e = t;
  e.version = qj.version, e.utils = Bi, e.rand = x8, e.curve = Qv, e.curves = X0, e.ec = uq, e.eddsa = vq;
})(w8);
const bq = { waku: { publish: "waku_publish", batchPublish: "waku_batchPublish", subscribe: "waku_subscribe", batchSubscribe: "waku_batchSubscribe", subscription: "waku_subscription", unsubscribe: "waku_unsubscribe", batchUnsubscribe: "waku_batchUnsubscribe", batchFetchMessages: "waku_batchFetchMessages" }, irn: { publish: "irn_publish", batchPublish: "irn_batchPublish", subscribe: "irn_subscribe", batchSubscribe: "irn_batchSubscribe", subscription: "irn_subscription", unsubscribe: "irn_unsubscribe", batchUnsubscribe: "irn_batchUnsubscribe", batchFetchMessages: "irn_batchFetchMessages" }, iridium: { publish: "iridium_publish", batchPublish: "iridium_batchPublish", subscribe: "iridium_subscribe", batchSubscribe: "iridium_batchSubscribe", subscription: "iridium_subscription", unsubscribe: "iridium_unsubscribe", batchUnsubscribe: "iridium_batchUnsubscribe", batchFetchMessages: "iridium_batchFetchMessages" } }, yq = ":";
function fu(t) {
  const [e, r] = t.split(yq);
  return { namespace: e, reference: r };
}
function T8(t, e) {
  return t.includes(":") ? [t] : e.chains || [];
}
var wq = Object.defineProperty, Ox = Object.getOwnPropertySymbols, xq = Object.prototype.hasOwnProperty, _q = Object.prototype.propertyIsEnumerable, Nx = (t, e, r) => e in t ? wq(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Lx = (t, e) => {
  for (var r in e || (e = {})) xq.call(e, r) && Nx(t, r, e[r]);
  if (Ox) for (var r of Ox(e)) _q.call(e, r) && Nx(t, r, e[r]);
  return t;
};
const Eq = "ReactNative", Ri = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, Sq = "js";
function a0() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function Uu() {
  return !Wl() && !!Bv() && navigator.product === Eq;
}
function Xl() {
  return !a0() && !!Bv() && !!Wl();
}
function Zl() {
  return Uu() ? Ri.reactNative : a0() ? Ri.node : Xl() ? Ri.browser : Ri.unknown;
}
function Aq() {
  var t;
  try {
    return Uu() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (t = global.Application) == null ? void 0 : t.applicationId : void 0;
  } catch {
    return;
  }
}
function Pq(t, e) {
  let r = yl.parse(t);
  return r = Lx(Lx({}, r), e), t = yl.stringify(r), t;
}
function R8() {
  return j4() || { name: "", description: "", url: "", icons: [""] };
}
function Mq() {
  if (Zl() === Ri.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: r, Version: n } = global.Platform;
    return [r, n].join("-");
  }
  const t = FB();
  if (t === null) return "unknown";
  const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
  return t.type === "browser" ? [e, t.name, t.version].join("-") : [e, t.version].join("-");
}
function Iq() {
  var t;
  const e = Zl();
  return e === Ri.browser ? [e, ((t = U4()) == null ? void 0 : t.host) || "unknown"].join(":") : e;
}
function D8(t, e, r) {
  const n = Mq(), i = Iq();
  return [[t, e].join("-"), [Sq, r].join("-"), n, i].join("/");
}
function Cq({ protocol: t, version: e, relayUrl: r, sdkVersion: n, auth: i, projectId: s, useOnCloseEvent: o, bundleId: a }) {
  const u = r.split("?"), h = D8(t, e, n), d = { auth: i, ua: h, projectId: s, useOnCloseEvent: o, origin: a || void 0 }, p = Pq(u[1] || "", d);
  return u[0] + "?" + p;
}
function Za(t, e) {
  return t.filter((r) => e.includes(r)).length === t.length;
}
function O8(t) {
  return Object.fromEntries(t.entries());
}
function N8(t) {
  return new Map(Object.entries(t));
}
function Ha(t = mt.FIVE_MINUTES, e) {
  const r = mt.toMiliseconds(t || mt.FIVE_MINUTES);
  let n, i, s;
  return { resolve: (o) => {
    s && n && (clearTimeout(s), n(o));
  }, reject: (o) => {
    s && i && (clearTimeout(s), i(o));
  }, done: () => new Promise((o, a) => {
    s = setTimeout(() => {
      a(new Error(e));
    }, r), n = o, i = a;
  }) };
}
function lu(t, e, r) {
  return new Promise(async (n, i) => {
    const s = setTimeout(() => i(new Error(r)), e);
    try {
      const o = await t;
      n(o);
    } catch (o) {
      i(o);
    }
    clearTimeout(s);
  });
}
function L8(t, e) {
  if (typeof e == "string" && e.startsWith(`${t}:`)) return e;
  if (t.toLowerCase() === "topic") {
    if (typeof e != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (t.toLowerCase() === "id") {
    if (typeof e != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${t}`);
}
function Tq(t) {
  return L8("topic", t);
}
function Rq(t) {
  return L8("id", t);
}
function k8(t) {
  const [e, r] = t.split(":"), n = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof r == "string") n.topic = r;
  else if (e === "id" && Number.isInteger(Number(r))) n.id = Number(r);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${r}`);
  return n;
}
function En(t, e) {
  return mt.fromMiliseconds(Date.now() + mt.toMiliseconds(t));
}
function sa(t) {
  return Date.now() >= mt.toMiliseconds(t);
}
function vr(t, e) {
  return `${t}${e ? `:${e}` : ""}`;
}
function Md(t = [], e = []) {
  return [.../* @__PURE__ */ new Set([...t, ...e])];
}
async function Dq({ id: t, topic: e, wcDeepLink: r }) {
  var n;
  try {
    if (!r) return;
    const i = typeof r == "string" ? JSON.parse(r) : r, s = i == null ? void 0 : i.href;
    if (typeof s != "string") return;
    const o = Oq(s, t, e), a = Zl();
    if (a === Ri.browser) {
      if (!((n = Wl()) != null && n.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      o.startsWith("https://") || o.startsWith("http://") ? window.open(o, "_blank", "noreferrer noopener") : window.open(o, Lq() ? "_blank" : "_self", "noreferrer noopener");
    } else a === Ri.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(o);
  } catch (i) {
    console.error(i);
  }
}
function Oq(t, e, r) {
  const n = `requestId=${e}&sessionTopic=${r}`;
  t.endsWith("/") && (t = t.slice(0, -1));
  let i = `${t}`;
  if (t.startsWith("https://t.me")) {
    const s = t.includes("?") ? "&startapp=" : "?startapp=";
    i = `${i}${s}${kq(n, !0)}`;
  } else i = `${i}/wc?${n}`;
  return i;
}
async function Nq(t, e) {
  let r = "";
  try {
    if (Xl() && (r = localStorage.getItem(e), r)) return r;
    r = await t.getItem(e);
  } catch (n) {
    console.error(n);
  }
  return r;
}
function kx(t, e) {
  if (!t.includes(e)) return null;
  const r = t.split(/([&,?,=])/), n = r.indexOf(e);
  return r[n + 2];
}
function $x() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t) => {
    const e = Math.random() * 16 | 0;
    return (t === "x" ? e : e & 3 | 8).toString(16);
  });
}
function nb() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function Lq() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function kq(t, e = !1) {
  const r = Buffer.from(t).toString("base64");
  return e ? r.replace(/[=]/g, "") : r;
}
function $8(t) {
  return Buffer.from(t, "base64").toString("utf-8");
}
const $q = "https://rpc.walletconnect.org/v1";
async function Bq(t, e, r, n, i, s) {
  switch (r.t) {
    case "eip191":
      return Fq(t, e, r.s);
    case "eip1271":
      return await Uq(t, e, r.s, n, i, s);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${r.t}`);
  }
}
function Fq(t, e, r) {
  return pj(K4(e), r).toLowerCase() === t.toLowerCase();
}
async function Uq(t, e, r, n, i, s) {
  const o = fu(n);
  if (!o.namespace || !o.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${n}`);
  try {
    const a = "0x1626ba7e", u = "0000000000000000000000000000000000000000000000000000000000000040", h = "0000000000000000000000000000000000000000000000000000000000000041", d = r.substring(2), p = K4(e).substring(2), x = a + p + u + h + d, A = await fetch(`${s || $q}/?chainId=${n}&projectId=${i}`, { method: "POST", body: JSON.stringify({ id: jq(), jsonrpc: "2.0", method: "eth_call", params: [{ to: t, data: x }, "latest"] }) }), { result: I } = await A.json();
    return I ? I.slice(0, a.length).toLowerCase() === a.toLowerCase() : !1;
  } catch (a) {
    return console.error("isValidEip1271Signature: ", a), !1;
  }
}
function jq() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
var qq = Object.defineProperty, zq = Object.defineProperties, Hq = Object.getOwnPropertyDescriptors, Bx = Object.getOwnPropertySymbols, Wq = Object.prototype.hasOwnProperty, Kq = Object.prototype.propertyIsEnumerable, Fx = (t, e, r) => e in t ? qq(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Vq = (t, e) => {
  for (var r in e || (e = {})) Wq.call(e, r) && Fx(t, r, e[r]);
  if (Bx) for (var r of Bx(e)) Kq.call(e, r) && Fx(t, r, e[r]);
  return t;
}, Gq = (t, e) => zq(t, Hq(e));
const Yq = "did:pkh:", ib = (t) => t == null ? void 0 : t.split(":"), Jq = (t) => {
  const e = t && ib(t);
  if (e) return t.includes(Yq) ? e[3] : e[1];
}, M1 = (t) => {
  const e = t && ib(t);
  if (e) return e[2] + ":" + e[3];
}, c0 = (t) => {
  const e = t && ib(t);
  if (e) return e.pop();
};
async function Ux(t) {
  const { cacao: e, projectId: r } = t, { s: n, p: i } = e, s = B8(i, i.iss), o = c0(i.iss);
  return await Bq(o, s, n, M1(i.iss), r);
}
const B8 = (t, e) => {
  const r = `${t.domain} wants you to sign in with your Ethereum account:`, n = c0(e);
  if (!t.aud && !t.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let i = t.statement || void 0;
  const s = `URI: ${t.aud || t.uri}`, o = `Version: ${t.version}`, a = `Chain ID: ${Jq(e)}`, u = `Nonce: ${t.nonce}`, h = `Issued At: ${t.iat}`, d = t.exp ? `Expiration Time: ${t.exp}` : void 0, p = t.nbf ? `Not Before: ${t.nbf}` : void 0, x = t.requestId ? `Request ID: ${t.requestId}` : void 0, A = t.resources ? `Resources:${t.resources.map((N) => `
- ${N}`).join("")}` : void 0, I = Id(t.resources);
  if (I) {
    const N = wl(I);
    i = sz(i, N);
  }
  return [r, n, "", i, "", s, o, a, u, h, d, p, x, A].filter((N) => N != null).join(`
`);
};
function Xq(t) {
  return Buffer.from(JSON.stringify(t)).toString("base64");
}
function Zq(t) {
  return JSON.parse(Buffer.from(t, "base64").toString("utf-8"));
}
function cc(t) {
  if (!t) throw new Error("No recap provided, value is undefined");
  if (!t.att) throw new Error("No `att` property found");
  const e = Object.keys(t.att);
  if (!(e != null && e.length)) throw new Error("No resources found in `att` property");
  e.forEach((r) => {
    const n = t.att[r];
    if (Array.isArray(n)) throw new Error(`Resource must be an object: ${r}`);
    if (typeof n != "object") throw new Error(`Resource must be an object: ${r}`);
    if (!Object.keys(n).length) throw new Error(`Resource object is empty: ${r}`);
    Object.keys(n).forEach((i) => {
      const s = n[i];
      if (!Array.isArray(s)) throw new Error(`Ability limits ${i} must be an array of objects, found: ${s}`);
      if (!s.length) throw new Error(`Value of ${i} is empty array, must be an array with objects`);
      s.forEach((o) => {
        if (typeof o != "object") throw new Error(`Ability limits (${i}) must be an array of objects, found: ${o}`);
      });
    });
  });
}
function Qq(t, e, r, n = {}) {
  return r == null || r.sort((i, s) => i.localeCompare(s)), { att: { [t]: ez(e, r, n) } };
}
function ez(t, e, r = {}) {
  e = e == null ? void 0 : e.sort((i, s) => i.localeCompare(s));
  const n = e.map((i) => ({ [`${t}/${i}`]: [r] }));
  return Object.assign({}, ...n);
}
function F8(t) {
  return cc(t), `urn:recap:${Xq(t).replace(/=/g, "")}`;
}
function wl(t) {
  const e = Zq(t.replace("urn:recap:", ""));
  return cc(e), e;
}
function tz(t, e, r) {
  const n = Qq(t, e, r);
  return F8(n);
}
function rz(t) {
  return t && t.includes("urn:recap:");
}
function nz(t, e) {
  const r = wl(t), n = wl(e), i = iz(r, n);
  return F8(i);
}
function iz(t, e) {
  cc(t), cc(e);
  const r = Object.keys(t.att).concat(Object.keys(e.att)).sort((i, s) => i.localeCompare(s)), n = { att: {} };
  return r.forEach((i) => {
    var s, o;
    Object.keys(((s = t.att) == null ? void 0 : s[i]) || {}).concat(Object.keys(((o = e.att) == null ? void 0 : o[i]) || {})).sort((a, u) => a.localeCompare(u)).forEach((a) => {
      var u, h;
      n.att[i] = Gq(Vq({}, n.att[i]), { [a]: ((u = t.att[i]) == null ? void 0 : u[a]) || ((h = e.att[i]) == null ? void 0 : h[a]) });
    });
  }), n;
}
function sz(t = "", e) {
  cc(e);
  const r = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (t.includes(r)) return t;
  const n = [];
  let i = 0;
  Object.keys(e.att).forEach((a) => {
    const u = Object.keys(e.att[a]).map((p) => ({ ability: p.split("/")[0], action: p.split("/")[1] }));
    u.sort((p, x) => p.action.localeCompare(x.action));
    const h = {};
    u.forEach((p) => {
      h[p.ability] || (h[p.ability] = []), h[p.ability].push(p.action);
    });
    const d = Object.keys(h).map((p) => (i++, `(${i}) '${p}': '${h[p].join("', '")}' for '${a}'.`));
    n.push(d.join(", ").replace(".,", "."));
  });
  const s = n.join(" "), o = `${r}${s}`;
  return `${t ? t + " " : ""}${o}`;
}
function jx(t) {
  var e;
  const r = wl(t);
  cc(r);
  const n = (e = r.att) == null ? void 0 : e.eip155;
  return n ? Object.keys(n).map((i) => i.split("/")[1]) : [];
}
function qx(t) {
  const e = wl(t);
  cc(e);
  const r = [];
  return Object.values(e.att).forEach((n) => {
    Object.values(n).forEach((i) => {
      var s;
      (s = i == null ? void 0 : i[0]) != null && s.chains && r.push(i[0].chains);
    });
  }), [...new Set(r.flat())];
}
function Id(t) {
  if (!t) return;
  const e = t == null ? void 0 : t[t.length - 1];
  return rz(e) ? e : void 0;
}
const U8 = "base10", oi = "base16", ua = "base64pad", Ef = "base64url", Ql = "utf8", j8 = 0, Mo = 1, eh = 2, oz = 0, zx = 1, Uf = 12, sb = 32;
function az() {
  const t = Yv.generateKeyPair();
  return { privateKey: Rn(t.secretKey, oi), publicKey: Rn(t.publicKey, oi) };
}
function I1() {
  const t = Ea.randomBytes(sb);
  return Rn(t, oi);
}
function cz(t, e) {
  const r = Yv.sharedKey(Tn(t, oi), Tn(e, oi), !0), n = new Mj(Gl.SHA256, r).expand(sb);
  return Rn(n, oi);
}
function Cd(t) {
  const e = Gl.hash(Tn(t, oi));
  return Rn(e, oi);
}
function yo(t) {
  const e = Gl.hash(Tn(t, Ql));
  return Rn(e, oi);
}
function q8(t) {
  return Tn(`${t}`, U8);
}
function uc(t) {
  return Number(Rn(t, U8));
}
function uz(t) {
  const e = q8(typeof t.type < "u" ? t.type : j8);
  if (uc(e) === Mo && typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const r = typeof t.senderPublicKey < "u" ? Tn(t.senderPublicKey, oi) : void 0, n = typeof t.iv < "u" ? Tn(t.iv, oi) : Ea.randomBytes(Uf), i = new Vv.ChaCha20Poly1305(Tn(t.symKey, oi)).seal(n, Tn(t.message, Ql));
  return z8({ type: e, sealed: i, iv: n, senderPublicKey: r, encoding: t.encoding });
}
function fz(t, e) {
  const r = q8(eh), n = Ea.randomBytes(Uf), i = Tn(t, Ql);
  return z8({ type: r, sealed: i, iv: n, encoding: e });
}
function lz(t) {
  const e = new Vv.ChaCha20Poly1305(Tn(t.symKey, oi)), { sealed: r, iv: n } = xl({ encoded: t.encoded, encoding: t == null ? void 0 : t.encoding }), i = e.open(n, r);
  if (i === null) throw new Error("Failed to decrypt");
  return Rn(i, Ql);
}
function hz(t, e) {
  const { sealed: r } = xl({ encoded: t, encoding: e });
  return Rn(r, Ql);
}
function z8(t) {
  const { encoding: e = ua } = t;
  if (uc(t.type) === eh) return Rn(Ed([t.type, t.sealed]), e);
  if (uc(t.type) === Mo) {
    if (typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return Rn(Ed([t.type, t.senderPublicKey, t.iv, t.sealed]), e);
  }
  return Rn(Ed([t.type, t.iv, t.sealed]), e);
}
function xl(t) {
  const { encoded: e, encoding: r = ua } = t, n = Tn(e, r), i = n.slice(oz, zx), s = zx;
  if (uc(i) === Mo) {
    const h = s + sb, d = h + Uf, p = n.slice(s, h), x = n.slice(h, d), A = n.slice(d);
    return { type: i, sealed: A, iv: x, senderPublicKey: p };
  }
  if (uc(i) === eh) {
    const h = n.slice(s), d = Ea.randomBytes(Uf);
    return { type: i, sealed: h, iv: d };
  }
  const o = s + Uf, a = n.slice(s, o), u = n.slice(o);
  return { type: i, sealed: u, iv: a };
}
function dz(t, e) {
  const r = xl({ encoded: t, encoding: e == null ? void 0 : e.encoding });
  return H8({ type: uc(r.type), senderPublicKey: typeof r.senderPublicKey < "u" ? Rn(r.senderPublicKey, oi) : void 0, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey });
}
function H8(t) {
  const e = (t == null ? void 0 : t.type) || j8;
  if (e === Mo) {
    if (typeof (t == null ? void 0 : t.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (t == null ? void 0 : t.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: t == null ? void 0 : t.senderPublicKey, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey };
}
function Hx(t) {
  return t.type === Mo && typeof t.senderPublicKey == "string" && typeof t.receiverPublicKey == "string";
}
function Wx(t) {
  return t.type === eh;
}
function pz(t) {
  return new w8.ec("p256").keyFromPublic({ x: Buffer.from(t.x, "base64").toString("hex"), y: Buffer.from(t.y, "base64").toString("hex") }, "hex");
}
function gz(t) {
  let e = t.replace(/-/g, "+").replace(/_/g, "/");
  const r = e.length % 4;
  return r > 0 && (e += "=".repeat(4 - r)), e;
}
function mz(t) {
  return Buffer.from(gz(t), "base64");
}
function vz(t, e) {
  const [r, n, i] = t.split("."), s = mz(i);
  if (s.length !== 64) throw new Error("Invalid signature length");
  const o = s.slice(0, 32).toString("hex"), a = s.slice(32, 64).toString("hex"), u = `${r}.${n}`, h = new Gl.SHA256().update(Buffer.from(u)).digest(), d = pz(e), p = Buffer.from(h).toString("hex");
  if (!d.verify(p, { r: o, s: a })) throw new Error("Invalid signature");
  return v1(t).payload;
}
const bz = "irn";
function C1(t) {
  return (t == null ? void 0 : t.relay) || { protocol: bz };
}
function kf(t) {
  const e = bq[t];
  if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${t}`);
  return e;
}
var yz = Object.defineProperty, wz = Object.defineProperties, xz = Object.getOwnPropertyDescriptors, Kx = Object.getOwnPropertySymbols, _z = Object.prototype.hasOwnProperty, Ez = Object.prototype.propertyIsEnumerable, Vx = (t, e, r) => e in t ? yz(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Gx = (t, e) => {
  for (var r in e || (e = {})) _z.call(e, r) && Vx(t, r, e[r]);
  if (Kx) for (var r of Kx(e)) Ez.call(e, r) && Vx(t, r, e[r]);
  return t;
}, Sz = (t, e) => wz(t, xz(e));
function Az(t, e = "-") {
  const r = {}, n = "relay" + e;
  return Object.keys(t).forEach((i) => {
    if (i.startsWith(n)) {
      const s = i.replace(n, ""), o = t[i];
      r[s] = o;
    }
  }), r;
}
function Yx(t) {
  if (!t.includes("wc:")) {
    const u = $8(t);
    u != null && u.includes("wc:") && (t = u);
  }
  t = t.includes("wc://") ? t.replace("wc://", "") : t, t = t.includes("wc:") ? t.replace("wc:", "") : t;
  const e = t.indexOf(":"), r = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0, n = t.substring(0, e), i = t.substring(e + 1, r).split("@"), s = typeof r < "u" ? t.substring(r) : "", o = yl.parse(s), a = typeof o.methods == "string" ? o.methods.split(",") : void 0;
  return { protocol: n, topic: Pz(i[0]), version: parseInt(i[1], 10), symKey: o.symKey, relay: Az(o), methods: a, expiryTimestamp: o.expiryTimestamp ? parseInt(o.expiryTimestamp, 10) : void 0 };
}
function Pz(t) {
  return t.startsWith("//") ? t.substring(2) : t;
}
function Mz(t, e = "-") {
  const r = "relay", n = {};
  return Object.keys(t).forEach((i) => {
    const s = r + e + i;
    t[i] && (n[s] = t[i]);
  }), n;
}
function Jx(t) {
  return `${t.protocol}:${t.topic}@${t.version}?` + yl.stringify(Gx(Sz(Gx({ symKey: t.symKey }, Mz(t.relay)), { expiryTimestamp: t.expiryTimestamp }), t.methods ? { methods: t.methods.join(",") } : {}));
}
function ud(t, e, r) {
  return `${t}?wc_ev=${r}&topic=${e}`;
}
function ju(t) {
  const e = [];
  return t.forEach((r) => {
    const [n, i] = r.split(":");
    e.push(`${n}:${i}`);
  }), e;
}
function Iz(t) {
  const e = [];
  return Object.values(t).forEach((r) => {
    e.push(...ju(r.accounts));
  }), e;
}
function Cz(t, e) {
  const r = [];
  return Object.values(t).forEach((n) => {
    ju(n.accounts).includes(e) && r.push(...n.methods);
  }), r;
}
function Tz(t, e) {
  const r = [];
  return Object.values(t).forEach((n) => {
    ju(n.accounts).includes(e) && r.push(...n.events);
  }), r;
}
function ob(t) {
  return t.includes(":");
}
function $f(t) {
  return ob(t) ? t.split(":")[0] : t;
}
function Rz(t) {
  const e = {};
  return t == null || t.forEach((r) => {
    const [n, i] = r.split(":");
    e[n] || (e[n] = { accounts: [], chains: [], events: [] }), e[n].accounts.push(r), e[n].chains.push(`${n}:${i}`);
  }), e;
}
function Xx(t, e) {
  e = e.map((n) => n.replace("did:pkh:", ""));
  const r = Rz(e);
  for (const [n, i] of Object.entries(r)) i.methods ? i.methods = Md(i.methods, t) : i.methods = t, i.events = ["chainChanged", "accountsChanged"];
  return r;
}
const Dz = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, Oz = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function ft(t, e) {
  const { message: r, code: n } = Oz[t];
  return { message: e ? `${r} ${e}` : r, code: n };
}
function Or(t, e) {
  const { message: r, code: n } = Dz[t];
  return { message: e ? `${r} ${e}` : r, code: n };
}
function fc(t, e) {
  return !!Array.isArray(t);
}
function _l(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;
}
function gi(t) {
  return typeof t > "u";
}
function dn(t, e) {
  return e && gi(t) ? !0 : typeof t == "string" && !!t.trim().length;
}
function ab(t, e) {
  return typeof t == "number" && !isNaN(t);
}
function Nz(t, e) {
  const { requiredNamespaces: r } = e, n = Object.keys(t.namespaces), i = Object.keys(r);
  let s = !0;
  return Za(i, n) ? (n.forEach((o) => {
    const { accounts: a, methods: u, events: h } = t.namespaces[o], d = ju(a), p = r[o];
    (!Za(T8(o, p), d) || !Za(p.methods, u) || !Za(p.events, h)) && (s = !1);
  }), s) : !1;
}
function u0(t) {
  return dn(t, !1) && t.includes(":") ? t.split(":").length === 2 : !1;
}
function Lz(t) {
  if (dn(t, !1) && t.includes(":")) {
    const e = t.split(":");
    if (e.length === 3) {
      const r = e[0] + ":" + e[1];
      return !!e[2] && u0(r);
    }
  }
  return !1;
}
function kz(t) {
  function e(r) {
    try {
      return typeof new URL(r) < "u";
    } catch {
      return !1;
    }
  }
  try {
    if (dn(t, !1)) {
      if (e(t)) return !0;
      const r = $8(t);
      return e(r);
    }
  } catch {
  }
  return !1;
}
function $z(t) {
  var e;
  return (e = t == null ? void 0 : t.proposer) == null ? void 0 : e.publicKey;
}
function Bz(t) {
  return t == null ? void 0 : t.topic;
}
function Fz(t, e) {
  let r = null;
  return dn(t == null ? void 0 : t.publicKey, !1) || (r = ft("MISSING_OR_INVALID", `${e} controller public key should be a string`)), r;
}
function Zx(t) {
  let e = !0;
  return fc(t) ? t.length && (e = t.every((r) => dn(r, !1))) : e = !1, e;
}
function Uz(t, e, r) {
  let n = null;
  return fc(e) && e.length ? e.forEach((i) => {
    n || u0(i) || (n = Or("UNSUPPORTED_CHAINS", `${r}, chain ${i} should be a string and conform to "namespace:chainId" format`));
  }) : u0(t) || (n = Or("UNSUPPORTED_CHAINS", `${r}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), n;
}
function jz(t, e, r) {
  let n = null;
  return Object.entries(t).forEach(([i, s]) => {
    if (n) return;
    const o = Uz(i, T8(i, s), `${e} ${r}`);
    o && (n = o);
  }), n;
}
function qz(t, e) {
  let r = null;
  return fc(t) ? t.forEach((n) => {
    r || Lz(n) || (r = Or("UNSUPPORTED_ACCOUNTS", `${e}, account ${n} should be a string and conform to "namespace:chainId:address" format`));
  }) : r = Or("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), r;
}
function zz(t, e) {
  let r = null;
  return Object.values(t).forEach((n) => {
    if (r) return;
    const i = qz(n == null ? void 0 : n.accounts, `${e} namespace`);
    i && (r = i);
  }), r;
}
function Hz(t, e) {
  let r = null;
  return Zx(t == null ? void 0 : t.methods) ? Zx(t == null ? void 0 : t.events) || (r = Or("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : r = Or("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), r;
}
function W8(t, e) {
  let r = null;
  return Object.values(t).forEach((n) => {
    if (r) return;
    const i = Hz(n, `${e}, namespace`);
    i && (r = i);
  }), r;
}
function Wz(t, e, r) {
  let n = null;
  if (t && _l(t)) {
    const i = W8(t, e);
    i && (n = i);
    const s = jz(t, e, r);
    s && (n = s);
  } else n = ft("MISSING_OR_INVALID", `${e}, ${r} should be an object with data`);
  return n;
}
function hm(t, e) {
  let r = null;
  if (t && _l(t)) {
    const n = W8(t, e);
    n && (r = n);
    const i = zz(t, e);
    i && (r = i);
  } else r = ft("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return r;
}
function K8(t) {
  return dn(t.protocol, !0);
}
function Kz(t, e) {
  let r = !1;
  return t ? t && fc(t) && t.length && t.forEach((n) => {
    r = K8(n);
  }) : r = !0, r;
}
function Vz(t) {
  return typeof t == "number";
}
function pi(t) {
  return typeof t < "u" && typeof t !== null;
}
function Gz(t) {
  return !(!t || typeof t != "object" || !t.code || !ab(t.code) || !t.message || !dn(t.message, !1));
}
function Yz(t) {
  return !(gi(t) || !dn(t.method, !1));
}
function Jz(t) {
  return !(gi(t) || gi(t.result) && gi(t.error) || !ab(t.id) || !dn(t.jsonrpc, !1));
}
function Xz(t) {
  return !(gi(t) || !dn(t.name, !1));
}
function Qx(t, e) {
  return !(!u0(e) || !Iz(t).includes(e));
}
function Zz(t, e, r) {
  return dn(r, !1) ? Cz(t, e).includes(r) : !1;
}
function Qz(t, e, r) {
  return dn(r, !1) ? Tz(t, e).includes(r) : !1;
}
function e3(t, e, r) {
  let n = null;
  const i = eH(t), s = tH(e), o = Object.keys(i), a = Object.keys(s), u = t3(Object.keys(t)), h = t3(Object.keys(e)), d = u.filter((p) => !h.includes(p));
  return d.length && (n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces keys don't satisfy requiredNamespaces.
      Required: ${d.toString()}
      Received: ${Object.keys(e).toString()}`)), Za(o, a) || (n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`)), Object.keys(e).forEach((p) => {
    if (!p.includes(":") || n) return;
    const x = ju(e[p].accounts);
    x.includes(p) || (n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces accounts don't satisfy namespace accounts for ${p}
        Required: ${p}
        Approved: ${x.toString()}`));
  }), o.forEach((p) => {
    n || (Za(i[p].methods, s[p].methods) ? Za(i[p].events, s[p].events) || (n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces events don't satisfy namespace events for ${p}`)) : n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces methods don't satisfy namespace methods for ${p}`));
  }), n;
}
function eH(t) {
  const e = {};
  return Object.keys(t).forEach((r) => {
    var n;
    r.includes(":") ? e[r] = t[r] : (n = t[r].chains) == null || n.forEach((i) => {
      e[i] = { methods: t[r].methods, events: t[r].events };
    });
  }), e;
}
function t3(t) {
  return [...new Set(t.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function tH(t) {
  const e = {};
  return Object.keys(t).forEach((r) => {
    if (r.includes(":")) e[r] = t[r];
    else {
      const n = ju(t[r].accounts);
      n == null || n.forEach((i) => {
        e[i] = { accounts: t[r].accounts.filter((s) => s.includes(`${i}:`)), methods: t[r].methods, events: t[r].events };
      });
    }
  }), e;
}
function rH(t, e) {
  return ab(t) && t <= e.max && t >= e.min;
}
function r3() {
  const t = Zl();
  return new Promise((e) => {
    switch (t) {
      case Ri.browser:
        e(nH());
        break;
      case Ri.reactNative:
        e(iH());
        break;
      case Ri.node:
        e(sH());
        break;
      default:
        e(!0);
    }
  });
}
function nH() {
  return Xl() && (navigator == null ? void 0 : navigator.onLine);
}
async function iH() {
  if (Uu() && typeof global < "u" && global != null && global.NetInfo) {
    const t = await (global == null ? void 0 : global.NetInfo.fetch());
    return t == null ? void 0 : t.isConnected;
  }
  return !0;
}
function sH() {
  return !0;
}
function oH(t) {
  switch (Zl()) {
    case Ri.browser:
      aH(t);
      break;
    case Ri.reactNative:
      cH(t);
      break;
  }
}
function aH(t) {
  !Uu() && Xl() && (window.addEventListener("online", () => t(!0)), window.addEventListener("offline", () => t(!1)));
}
function cH(t) {
  Uu() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener((e) => t(e == null ? void 0 : e.isConnected)));
}
const dm = {};
class Sf {
  static get(e) {
    return dm[e];
  }
  static set(e, r) {
    dm[e] = r;
  }
  static delete(e) {
    delete dm[e];
  }
}
const uH = "PARSE_ERROR", fH = "INVALID_REQUEST", lH = "METHOD_NOT_FOUND", hH = "INVALID_PARAMS", V8 = "INTERNAL_ERROR", cb = "SERVER_ERROR", dH = [-32700, -32600, -32601, -32602, -32603], jf = {
  [uH]: { code: -32700, message: "Parse error" },
  [fH]: { code: -32600, message: "Invalid Request" },
  [lH]: { code: -32601, message: "Method not found" },
  [hH]: { code: -32602, message: "Invalid params" },
  [V8]: { code: -32603, message: "Internal error" },
  [cb]: { code: -32e3, message: "Server error" }
}, G8 = cb;
function pH(t) {
  return dH.includes(t);
}
function n3(t) {
  return Object.keys(jf).includes(t) ? jf[t] : jf[G8];
}
function gH(t) {
  const e = Object.values(jf).find((r) => r.code === t);
  return e || jf[G8];
}
function Y8(t, e, r) {
  return t.message.includes("getaddrinfo ENOTFOUND") || t.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${r} RPC url at ${e}`) : t;
}
var J8 = {}, po = {}, i3;
function mH() {
  if (i3) return po;
  i3 = 1, Object.defineProperty(po, "__esModule", { value: !0 }), po.isBrowserCryptoAvailable = po.getSubtleCrypto = po.getBrowerCrypto = void 0;
  function t() {
    return (gn == null ? void 0 : gn.crypto) || (gn == null ? void 0 : gn.msCrypto) || {};
  }
  po.getBrowerCrypto = t;
  function e() {
    const n = t();
    return n.subtle || n.webkitSubtle;
  }
  po.getSubtleCrypto = e;
  function r() {
    return !!t() && !!e();
  }
  return po.isBrowserCryptoAvailable = r, po;
}
var go = {}, s3;
function vH() {
  if (s3) return go;
  s3 = 1, Object.defineProperty(go, "__esModule", { value: !0 }), go.isBrowser = go.isNode = go.isReactNative = void 0;
  function t() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  go.isReactNative = t;
  function e() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
  }
  go.isNode = e;
  function r() {
    return !t() && !e();
  }
  return go.isBrowser = r, go;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = Fl;
  e.__exportStar(mH(), t), e.__exportStar(vH(), t);
})(J8);
function oa(t = 3) {
  const e = Date.now() * Math.pow(10, t), r = Math.floor(Math.random() * Math.pow(10, t));
  return e + r;
}
function Qa(t = 6) {
  return BigInt(oa(t));
}
function fa(t, e, r) {
  return {
    id: r || oa(),
    jsonrpc: "2.0",
    method: t,
    params: e
  };
}
function rp(t, e) {
  return {
    id: t,
    jsonrpc: "2.0",
    result: e
  };
}
function np(t, e, r) {
  return {
    id: t,
    jsonrpc: "2.0",
    error: bH(e)
  };
}
function bH(t, e) {
  return typeof t > "u" ? n3(V8) : (typeof t == "string" && (t = Object.assign(Object.assign({}, n3(cb)), { message: t })), pH(t.code) && (t = gH(t.code)), t);
}
let yH = class {
}, wH = class extends yH {
  constructor() {
    super();
  }
}, xH = class extends wH {
  constructor(e) {
    super();
  }
};
const _H = "^https?:", EH = "^wss?:";
function SH(t) {
  const e = t.match(new RegExp(/^\w+:/, "gi"));
  if (!(!e || !e.length))
    return e[0];
}
function X8(t, e) {
  const r = SH(t);
  return typeof r > "u" ? !1 : new RegExp(e).test(r);
}
function o3(t) {
  return X8(t, _H);
}
function a3(t) {
  return X8(t, EH);
}
function AH(t) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(t);
}
function Z8(t) {
  return typeof t == "object" && "id" in t && "jsonrpc" in t && t.jsonrpc === "2.0";
}
function ub(t) {
  return Z8(t) && "method" in t;
}
function ip(t) {
  return Z8(t) && (Bs(t) || Zi(t));
}
function Bs(t) {
  return "result" in t;
}
function Zi(t) {
  return "error" in t;
}
let as = class extends xH {
  constructor(e) {
    super(e), this.events = new rs.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners();
  }
  async connect(e = this.connection) {
    await this.open(e);
  }
  async disconnect() {
    await this.close();
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async request(e, r) {
    return this.requestStrict(fa(e.method, e.params || [], e.id || Qa().toString()), r);
  }
  async requestStrict(e, r) {
    return new Promise(async (n, i) => {
      if (!this.connection.connected) try {
        await this.open();
      } catch (s) {
        i(s);
      }
      this.events.on(`${e.id}`, (s) => {
        Zi(s) ? i(s.error) : n(s.result);
      });
      try {
        await this.connection.send(e, r);
      } catch (s) {
        i(s);
      }
    });
  }
  setConnection(e = this.connection) {
    return e;
  }
  onPayload(e) {
    this.events.emit("payload", e), ip(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", { type: e.method, data: e.params });
  }
  onClose(e) {
    e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(e = this.connection) {
    this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (e) => this.onPayload(e)), this.connection.on("close", (e) => this.onClose(e)), this.connection.on("error", (e) => this.events.emit("error", e)), this.connection.on("register_error", (e) => this.onClose()), this.hasRegisteredEventListeners = !0);
  }
};
const PH = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"), MH = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", c3 = (t) => t.split("?")[0], u3 = 10, IH = PH();
let CH = class {
  constructor(e) {
    if (this.url = e, this.events = new rs.EventEmitter(), this.registering = !1, !a3(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, r) => {
      if (typeof this.socket > "u") {
        r(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n) => {
        this.onClose(n), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(No(e));
    } catch (r) {
      this.onError(e.id, r);
    }
  }
  register(e = this.url) {
    if (!a3(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const r = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= r || this.events.listenerCount("open") >= r) && this.events.setMaxListeners(r + 1), new Promise((n, i) => {
        this.events.once("register_error", (s) => {
          this.resetMaxListeners(), i(s);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return i(new Error("WebSocket connection is missing or invalid"));
          n(this.socket);
        });
      });
    }
    return this.url = e, this.registering = !0, new Promise((r, n) => {
      const i = new URLSearchParams(e).get("origin"), s = J8.isReactNative() ? { headers: { origin: i } } : { rejectUnauthorized: !AH(e) }, o = new IH(e, [], s);
      MH() ? o.onerror = (a) => {
        const u = a;
        n(this.emitError(u.error));
      } : o.on("error", (a) => {
        n(this.emitError(a));
      }), o.onopen = () => {
        this.onOpen(o), r(o);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (r) => this.onPayload(r), e.onclose = (r) => this.onClose(r), this.socket = e, this.registering = !1, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const r = typeof e.data == "string" ? oc(e.data) : e.data;
    this.events.emit("payload", r);
  }
  onError(e, r) {
    const n = this.parseError(r), i = n.message || n.toString(), s = np(e, i);
    this.events.emit("payload", s);
  }
  parseError(e, r = this.url) {
    return Y8(e, c3(r), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > u3 && this.events.setMaxListeners(u3);
  }
  emitError(e) {
    const r = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${c3(this.url)}`));
    return this.events.emit("register_error", r), r;
  }
};
var f0 = { exports: {} };
f0.exports;
(function(t, e) {
  var r = 200, n = "__lodash_hash_undefined__", i = 1, s = 2, o = 9007199254740991, a = "[object Arguments]", u = "[object Array]", h = "[object AsyncFunction]", d = "[object Boolean]", p = "[object Date]", x = "[object Error]", A = "[object Function]", I = "[object GeneratorFunction]", N = "[object Map]", L = "[object Number]", F = "[object Null]", $ = "[object Object]", W = "[object Promise]", z = "[object Proxy]", V = "[object RegExp]", te = "[object Set]", R = "[object String]", K = "[object Symbol]", pe = "[object Undefined]", _e = "[object WeakMap]", Y = "[object ArrayBuffer]", S = "[object DataView]", m = "[object Float32Array]", f = "[object Float64Array]", g = "[object Int8Array]", b = "[object Int16Array]", w = "[object Int32Array]", _ = "[object Uint8Array]", E = "[object Uint8ClampedArray]", v = "[object Uint16Array]", M = "[object Uint32Array]", P = /[\\^$.*+?()[\]{}|]/g, B = /^\[object .+?Constructor\]$/, ue = /^(?:0|[1-9]\d*)$/, D = {};
  D[m] = D[f] = D[g] = D[b] = D[w] = D[_] = D[E] = D[v] = D[M] = !0, D[a] = D[u] = D[Y] = D[d] = D[S] = D[p] = D[x] = D[A] = D[N] = D[L] = D[$] = D[V] = D[te] = D[R] = D[_e] = !1;
  var oe = typeof gn == "object" && gn && gn.Object === Object && gn, Z = typeof self == "object" && self && self.Object === Object && self, J = oe || Z || Function("return this")(), Q = e && !e.nodeType && e, T = Q && !0 && t && !t.nodeType && t, X = T && T.exports === Q, re = X && oe.process, de = function() {
    try {
      return re && re.binding && re.binding("util");
    } catch {
    }
  }(), ie = de && de.isTypedArray;
  function ce(ae, ye) {
    for (var Ge = -1, Pt = ae == null ? 0 : ae.length, Ur = 0, rr = []; ++Ge < Pt; ) {
      var Kr = ae[Ge];
      ye(Kr, Ge, ae) && (rr[Ur++] = Kr);
    }
    return rr;
  }
  function me(ae, ye) {
    for (var Ge = -1, Pt = ye.length, Ur = ae.length; ++Ge < Pt; )
      ae[Ur + Ge] = ye[Ge];
    return ae;
  }
  function Pe(ae, ye) {
    for (var Ge = -1, Pt = ae == null ? 0 : ae.length; ++Ge < Pt; )
      if (ye(ae[Ge], Ge, ae))
        return !0;
    return !1;
  }
  function De(ae, ye) {
    for (var Ge = -1, Pt = Array(ae); ++Ge < ae; )
      Pt[Ge] = ye(Ge);
    return Pt;
  }
  function Ce(ae) {
    return function(ye) {
      return ae(ye);
    };
  }
  function $e(ae, ye) {
    return ae.has(ye);
  }
  function Me(ae, ye) {
    return ae == null ? void 0 : ae[ye];
  }
  function Ne(ae) {
    var ye = -1, Ge = Array(ae.size);
    return ae.forEach(function(Pt, Ur) {
      Ge[++ye] = [Ur, Pt];
    }), Ge;
  }
  function Ke(ae, ye) {
    return function(Ge) {
      return ae(ye(Ge));
    };
  }
  function Le(ae) {
    var ye = -1, Ge = Array(ae.size);
    return ae.forEach(function(Pt) {
      Ge[++ye] = Pt;
    }), Ge;
  }
  var qe = Array.prototype, ze = Function.prototype, Ee = Object.prototype, Ze = J["__core-js_shared__"], at = ze.toString, ke = Ee.hasOwnProperty, Qe = function() {
    var ae = /[^.]+$/.exec(Ze && Ze.keys && Ze.keys.IE_PROTO || "");
    return ae ? "Symbol(src)_1." + ae : "";
  }(), tt = Ee.toString, Ye = RegExp(
    "^" + at.call(ke).replace(P, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), dt = X ? J.Buffer : void 0, lt = J.Symbol, ct = J.Uint8Array, qt = Ee.propertyIsEnumerable, Yt = qe.splice, Et = lt ? lt.toStringTag : void 0, Qt = Object.getOwnPropertySymbols, Jt = dt ? dt.isBuffer : void 0, Dt = Ke(Object.keys, Object), kt = br(J, "DataView"), Ct = br(J, "Map"), gt = br(J, "Promise"), Rt = br(J, "Set"), Nt = br(J, "WeakMap"), vt = br(Object, "create"), $t = ro(kt), Ft = ro(Ct), rt = ro(gt), Bt = ro(Rt), k = ro(Nt), j = lt ? lt.prototype : void 0, H = j ? j.valueOf : void 0;
  function C(ae) {
    var ye = -1, Ge = ae == null ? 0 : ae.length;
    for (this.clear(); ++ye < Ge; ) {
      var Pt = ae[ye];
      this.set(Pt[0], Pt[1]);
    }
  }
  function G() {
    this.__data__ = vt ? vt(null) : {}, this.size = 0;
  }
  function U(ae) {
    var ye = this.has(ae) && delete this.__data__[ae];
    return this.size -= ye ? 1 : 0, ye;
  }
  function se(ae) {
    var ye = this.__data__;
    if (vt) {
      var Ge = ye[ae];
      return Ge === n ? void 0 : Ge;
    }
    return ke.call(ye, ae) ? ye[ae] : void 0;
  }
  function he(ae) {
    var ye = this.__data__;
    return vt ? ye[ae] !== void 0 : ke.call(ye, ae);
  }
  function xe(ae, ye) {
    var Ge = this.__data__;
    return this.size += this.has(ae) ? 0 : 1, Ge[ae] = vt && ye === void 0 ? n : ye, this;
  }
  C.prototype.clear = G, C.prototype.delete = U, C.prototype.get = se, C.prototype.has = he, C.prototype.set = xe;
  function Te(ae) {
    var ye = -1, Ge = ae == null ? 0 : ae.length;
    for (this.clear(); ++ye < Ge; ) {
      var Pt = ae[ye];
      this.set(Pt[0], Pt[1]);
    }
  }
  function Re() {
    this.__data__ = [], this.size = 0;
  }
  function nt(ae) {
    var ye = this.__data__, Ge = Je(ye, ae);
    if (Ge < 0)
      return !1;
    var Pt = ye.length - 1;
    return Ge == Pt ? ye.pop() : Yt.call(ye, Ge, 1), --this.size, !0;
  }
  function Ue(ae) {
    var ye = this.__data__, Ge = Je(ye, ae);
    return Ge < 0 ? void 0 : ye[Ge][1];
  }
  function pt(ae) {
    return Je(this.__data__, ae) > -1;
  }
  function it(ae, ye) {
    var Ge = this.__data__, Pt = Je(Ge, ae);
    return Pt < 0 ? (++this.size, Ge.push([ae, ye])) : Ge[Pt][1] = ye, this;
  }
  Te.prototype.clear = Re, Te.prototype.delete = nt, Te.prototype.get = Ue, Te.prototype.has = pt, Te.prototype.set = it;
  function et(ae) {
    var ye = -1, Ge = ae == null ? 0 : ae.length;
    for (this.clear(); ++ye < Ge; ) {
      var Pt = ae[ye];
      this.set(Pt[0], Pt[1]);
    }
  }
  function St() {
    this.size = 0, this.__data__ = {
      hash: new C(),
      map: new (Ct || Te)(),
      string: new C()
    };
  }
  function Tt(ae) {
    var ye = gr(this, ae).delete(ae);
    return this.size -= ye ? 1 : 0, ye;
  }
  function At(ae) {
    return gr(this, ae).get(ae);
  }
  function _t(ae) {
    return gr(this, ae).has(ae);
  }
  function ht(ae, ye) {
    var Ge = gr(this, ae), Pt = Ge.size;
    return Ge.set(ae, ye), this.size += Ge.size == Pt ? 0 : 1, this;
  }
  et.prototype.clear = St, et.prototype.delete = Tt, et.prototype.get = At, et.prototype.has = _t, et.prototype.set = ht;
  function xt(ae) {
    var ye = -1, Ge = ae == null ? 0 : ae.length;
    for (this.__data__ = new et(); ++ye < Ge; )
      this.add(ae[ye]);
  }
  function st(ae) {
    return this.__data__.set(ae, n), this;
  }
  function bt(ae) {
    return this.__data__.has(ae);
  }
  xt.prototype.add = xt.prototype.push = st, xt.prototype.has = bt;
  function ut(ae) {
    var ye = this.__data__ = new Te(ae);
    this.size = ye.size;
  }
  function ot() {
    this.__data__ = new Te(), this.size = 0;
  }
  function Se(ae) {
    var ye = this.__data__, Ge = ye.delete(ae);
    return this.size = ye.size, Ge;
  }
  function Ae(ae) {
    return this.__data__.get(ae);
  }
  function Ve(ae) {
    return this.__data__.has(ae);
  }
  function Fe(ae, ye) {
    var Ge = this.__data__;
    if (Ge instanceof Te) {
      var Pt = Ge.__data__;
      if (!Ct || Pt.length < r - 1)
        return Pt.push([ae, ye]), this.size = ++Ge.size, this;
      Ge = this.__data__ = new et(Pt);
    }
    return Ge.set(ae, ye), this.size = Ge.size, this;
  }
  ut.prototype.clear = ot, ut.prototype.delete = Se, ut.prototype.get = Ae, ut.prototype.has = Ve, ut.prototype.set = Fe;
  function je(ae, ye) {
    var Ge = Sc(ae), Pt = !Ge && hh(ae), Ur = !Ge && !Pt && Yu(ae), rr = !Ge && !Pt && !Ur && gh(ae), Kr = Ge || Pt || Ur || rr, vn = Kr ? De(ae.length, String) : [], xr = vn.length;
    for (var jr in ae)
      ke.call(ae, jr) && !(Kr && // Safari 9 has enumerable `arguments.length` in strict mode.
      (jr == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      Ur && (jr == "offset" || jr == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      rr && (jr == "buffer" || jr == "byteLength" || jr == "byteOffset") || // Skip index properties.
      nn(jr, xr))) && vn.push(jr);
    return vn;
  }
  function Je(ae, ye) {
    for (var Ge = ae.length; Ge--; )
      if (lh(ae[Ge][0], ye))
        return Ge;
    return -1;
  }
  function Lt(ae, ye, Ge) {
    var Pt = ye(ae);
    return Sc(ae) ? Pt : me(Pt, Ge(ae));
  }
  function zt(ae) {
    return ae == null ? ae === void 0 ? pe : F : Et && Et in Object(ae) ? $r(ae) : Rp(ae);
  }
  function Xt(ae) {
    return Ia(ae) && zt(ae) == a;
  }
  function Ht(ae, ye, Ge, Pt, Ur) {
    return ae === ye ? !0 : ae == null || ye == null || !Ia(ae) && !Ia(ye) ? ae !== ae && ye !== ye : le(ae, ye, Ge, Pt, Ht, Ur);
  }
  function le(ae, ye, Ge, Pt, Ur, rr) {
    var Kr = Sc(ae), vn = Sc(ye), xr = Kr ? u : Ir(ae), jr = vn ? u : Ir(ye);
    xr = xr == a ? $ : xr, jr = jr == a ? $ : jr;
    var an = xr == $, ci = jr == $, bn = xr == jr;
    if (bn && Yu(ae)) {
      if (!Yu(ye))
        return !1;
      Kr = !0, an = !1;
    }
    if (bn && !an)
      return rr || (rr = new ut()), Kr || gh(ae) ? Zt(ae, ye, Ge, Pt, Ur, rr) : pr(ae, ye, xr, Ge, Pt, Ur, rr);
    if (!(Ge & i)) {
      var Vr = an && ke.call(ae, "__wrapped__"), Qn = ci && ke.call(ye, "__wrapped__");
      if (Vr || Qn) {
        var us = Vr ? ae.value() : ae, Fi = Qn ? ye.value() : ye;
        return rr || (rr = new ut()), Ur(us, Fi, Ge, Pt, rr);
      }
    }
    return bn ? (rr || (rr = new ut()), fr(ae, ye, Ge, Pt, Ur, rr)) : !1;
  }
  function tr(ae) {
    if (!ph(ae) || on(ae))
      return !1;
    var ye = Ac(ae) ? Ye : B;
    return ye.test(ro(ae));
  }
  function hr(ae) {
    return Ia(ae) && dh(ae.length) && !!D[zt(ae)];
  }
  function dr(ae) {
    if (!fh(ae))
      return Dt(ae);
    var ye = [];
    for (var Ge in Object(ae))
      ke.call(ae, Ge) && Ge != "constructor" && ye.push(Ge);
    return ye;
  }
  function Zt(ae, ye, Ge, Pt, Ur, rr) {
    var Kr = Ge & i, vn = ae.length, xr = ye.length;
    if (vn != xr && !(Kr && xr > vn))
      return !1;
    var jr = rr.get(ae);
    if (jr && rr.get(ye))
      return jr == ye;
    var an = -1, ci = !0, bn = Ge & s ? new xt() : void 0;
    for (rr.set(ae, ye), rr.set(ye, ae); ++an < vn; ) {
      var Vr = ae[an], Qn = ye[an];
      if (Pt)
        var us = Kr ? Pt(Qn, Vr, an, ye, ae, rr) : Pt(Vr, Qn, an, ae, ye, rr);
      if (us !== void 0) {
        if (us)
          continue;
        ci = !1;
        break;
      }
      if (bn) {
        if (!Pe(ye, function(Fi, Ms) {
          if (!$e(bn, Ms) && (Vr === Fi || Ur(Vr, Fi, Ge, Pt, rr)))
            return bn.push(Ms);
        })) {
          ci = !1;
          break;
        }
      } else if (!(Vr === Qn || Ur(Vr, Qn, Ge, Pt, rr))) {
        ci = !1;
        break;
      }
    }
    return rr.delete(ae), rr.delete(ye), ci;
  }
  function pr(ae, ye, Ge, Pt, Ur, rr, Kr) {
    switch (Ge) {
      case S:
        if (ae.byteLength != ye.byteLength || ae.byteOffset != ye.byteOffset)
          return !1;
        ae = ae.buffer, ye = ye.buffer;
      case Y:
        return !(ae.byteLength != ye.byteLength || !rr(new ct(ae), new ct(ye)));
      case d:
      case p:
      case L:
        return lh(+ae, +ye);
      case x:
        return ae.name == ye.name && ae.message == ye.message;
      case V:
      case R:
        return ae == ye + "";
      case N:
        var vn = Ne;
      case te:
        var xr = Pt & i;
        if (vn || (vn = Le), ae.size != ye.size && !xr)
          return !1;
        var jr = Kr.get(ae);
        if (jr)
          return jr == ye;
        Pt |= s, Kr.set(ae, ye);
        var an = Zt(vn(ae), vn(ye), Pt, Ur, rr, Kr);
        return Kr.delete(ae), an;
      case K:
        if (H)
          return H.call(ae) == H.call(ye);
    }
    return !1;
  }
  function fr(ae, ye, Ge, Pt, Ur, rr) {
    var Kr = Ge & i, vn = Rr(ae), xr = vn.length, jr = Rr(ye), an = jr.length;
    if (xr != an && !Kr)
      return !1;
    for (var ci = xr; ci--; ) {
      var bn = vn[ci];
      if (!(Kr ? bn in ye : ke.call(ye, bn)))
        return !1;
    }
    var Vr = rr.get(ae);
    if (Vr && rr.get(ye))
      return Vr == ye;
    var Qn = !0;
    rr.set(ae, ye), rr.set(ye, ae);
    for (var us = Kr; ++ci < xr; ) {
      bn = vn[ci];
      var Fi = ae[bn], Ms = ye[bn];
      if (Pt)
        var Ju = Kr ? Pt(Ms, Fi, bn, ye, ae, rr) : Pt(Fi, Ms, bn, ae, ye, rr);
      if (!(Ju === void 0 ? Fi === Ms || Ur(Fi, Ms, Ge, Pt, rr) : Ju)) {
        Qn = !1;
        break;
      }
      us || (us = bn == "constructor");
    }
    if (Qn && !us) {
      var Ca = ae.constructor, Pn = ye.constructor;
      Ca != Pn && "constructor" in ae && "constructor" in ye && !(typeof Ca == "function" && Ca instanceof Ca && typeof Pn == "function" && Pn instanceof Pn) && (Qn = !1);
    }
    return rr.delete(ae), rr.delete(ye), Qn;
  }
  function Rr(ae) {
    return Lt(ae, Np, Br);
  }
  function gr(ae, ye) {
    var Ge = ae.__data__;
    return sn(ye) ? Ge[typeof ye == "string" ? "string" : "hash"] : Ge.map;
  }
  function br(ae, ye) {
    var Ge = Me(ae, ye);
    return tr(Ge) ? Ge : void 0;
  }
  function $r(ae) {
    var ye = ke.call(ae, Et), Ge = ae[Et];
    try {
      ae[Et] = void 0;
      var Pt = !0;
    } catch {
    }
    var Ur = tt.call(ae);
    return Pt && (ye ? ae[Et] = Ge : delete ae[Et]), Ur;
  }
  var Br = Qt ? function(ae) {
    return ae == null ? [] : (ae = Object(ae), ce(Qt(ae), function(ye) {
      return qt.call(ae, ye);
    }));
  } : Fr, Ir = zt;
  (kt && Ir(new kt(new ArrayBuffer(1))) != S || Ct && Ir(new Ct()) != N || gt && Ir(gt.resolve()) != W || Rt && Ir(new Rt()) != te || Nt && Ir(new Nt()) != _e) && (Ir = function(ae) {
    var ye = zt(ae), Ge = ye == $ ? ae.constructor : void 0, Pt = Ge ? ro(Ge) : "";
    if (Pt)
      switch (Pt) {
        case $t:
          return S;
        case Ft:
          return N;
        case rt:
          return W;
        case Bt:
          return te;
        case k:
          return _e;
      }
    return ye;
  });
  function nn(ae, ye) {
    return ye = ye ?? o, !!ye && (typeof ae == "number" || ue.test(ae)) && ae > -1 && ae % 1 == 0 && ae < ye;
  }
  function sn(ae) {
    var ye = typeof ae;
    return ye == "string" || ye == "number" || ye == "symbol" || ye == "boolean" ? ae !== "__proto__" : ae === null;
  }
  function on(ae) {
    return !!Qe && Qe in ae;
  }
  function fh(ae) {
    var ye = ae && ae.constructor, Ge = typeof ye == "function" && ye.prototype || Ee;
    return ae === Ge;
  }
  function Rp(ae) {
    return tt.call(ae);
  }
  function ro(ae) {
    if (ae != null) {
      try {
        return at.call(ae);
      } catch {
      }
      try {
        return ae + "";
      } catch {
      }
    }
    return "";
  }
  function lh(ae, ye) {
    return ae === ye || ae !== ae && ye !== ye;
  }
  var hh = Xt(/* @__PURE__ */ function() {
    return arguments;
  }()) ? Xt : function(ae) {
    return Ia(ae) && ke.call(ae, "callee") && !qt.call(ae, "callee");
  }, Sc = Array.isArray;
  function Dp(ae) {
    return ae != null && dh(ae.length) && !Ac(ae);
  }
  var Yu = Jt || Dr;
  function Op(ae, ye) {
    return Ht(ae, ye);
  }
  function Ac(ae) {
    if (!ph(ae))
      return !1;
    var ye = zt(ae);
    return ye == A || ye == I || ye == h || ye == z;
  }
  function dh(ae) {
    return typeof ae == "number" && ae > -1 && ae % 1 == 0 && ae <= o;
  }
  function ph(ae) {
    var ye = typeof ae;
    return ae != null && (ye == "object" || ye == "function");
  }
  function Ia(ae) {
    return ae != null && typeof ae == "object";
  }
  var gh = ie ? Ce(ie) : hr;
  function Np(ae) {
    return Dp(ae) ? je(ae) : dr(ae);
  }
  function Fr() {
    return [];
  }
  function Dr() {
    return !1;
  }
  t.exports = Op;
})(f0, f0.exports);
var TH = f0.exports;
const RH = /* @__PURE__ */ ts(TH), Q8 = "wc", eE = 2, tE = "core", Xs = `${Q8}@2:${tE}:`, DH = { logger: "error" }, OH = { database: ":memory:" }, NH = "crypto", f3 = "client_ed25519_seed", LH = mt.ONE_DAY, kH = "keychain", $H = "0.3", BH = "messages", FH = "0.3", UH = mt.SIX_HOURS, jH = "publisher", rE = "irn", qH = "error", nE = "wss://relay.walletconnect.org", zH = "relayer", ii = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", publish: "relayer_publish" }, HH = "_subscription", Vi = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, WH = 0.1, T1 = "2.17.2", zr = { link_mode: "link_mode", relay: "relay" }, KH = "0.3", VH = "WALLETCONNECT_CLIENT_ID", l3 = "WALLETCONNECT_LINK_MODE_APPS", Fs = { created: "subscription_created", deleted: "subscription_deleted", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, GH = "subscription", YH = "0.3", JH = mt.FIVE_SECONDS * 1e3, XH = "pairing", ZH = "0.3", Af = { wc_pairingDelete: { req: { ttl: mt.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: mt.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: mt.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: mt.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: mt.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: mt.ONE_DAY, prompt: !1, tag: 0 } } }, Ga = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" }, gs = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, QH = "history", eW = "0.3", tW = "expirer", Ji = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, rW = "0.3", nW = "verify-api", iW = "https://verify.walletconnect.com", iE = "https://verify.walletconnect.org", qf = iE, sW = `${qf}/v3`, oW = [iW, iE], aW = "echo", cW = "https://echo.walletconnect.com", $s = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal" }, bo = { no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_listener_not_found: "proposal_listener_not_found" }, ms = { session_approve_started: "session_approve_started", session_namespaces_validation_success: "session_namespaces_validation_success", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" }, ja = { no_internet_connection: "no_internet_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" }, qa = { authenticated_session_approve_started: "authenticated_session_approve_started", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve" }, Pf = { no_internet_connection: "no_internet_connection", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" }, uW = 0.1, fW = "event-client", lW = 86400, hW = "https://pulse.walletconnect.org/batch";
function dW(t, e) {
  if (t.length >= 255) throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++) r[n] = 255;
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i), o = s.charCodeAt(0);
    if (r[o] !== 255) throw new TypeError(s + " is ambiguous");
    r[o] = i;
  }
  var a = t.length, u = t.charAt(0), h = Math.log(a) / Math.log(256), d = Math.log(256) / Math.log(a);
  function p(I) {
    if (I instanceof Uint8Array || (ArrayBuffer.isView(I) ? I = new Uint8Array(I.buffer, I.byteOffset, I.byteLength) : Array.isArray(I) && (I = Uint8Array.from(I))), !(I instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (I.length === 0) return "";
    for (var N = 0, L = 0, F = 0, $ = I.length; F !== $ && I[F] === 0; ) F++, N++;
    for (var W = ($ - F) * d + 1 >>> 0, z = new Uint8Array(W); F !== $; ) {
      for (var V = I[F], te = 0, R = W - 1; (V !== 0 || te < L) && R !== -1; R--, te++) V += 256 * z[R] >>> 0, z[R] = V % a >>> 0, V = V / a >>> 0;
      if (V !== 0) throw new Error("Non-zero carry");
      L = te, F++;
    }
    for (var K = W - L; K !== W && z[K] === 0; ) K++;
    for (var pe = u.repeat(N); K < W; ++K) pe += t.charAt(z[K]);
    return pe;
  }
  function x(I) {
    if (typeof I != "string") throw new TypeError("Expected String");
    if (I.length === 0) return new Uint8Array();
    var N = 0;
    if (I[N] !== " ") {
      for (var L = 0, F = 0; I[N] === u; ) L++, N++;
      for (var $ = (I.length - N) * h + 1 >>> 0, W = new Uint8Array($); I[N]; ) {
        var z = r[I.charCodeAt(N)];
        if (z === 255) return;
        for (var V = 0, te = $ - 1; (z !== 0 || V < F) && te !== -1; te--, V++) z += a * W[te] >>> 0, W[te] = z % 256 >>> 0, z = z / 256 >>> 0;
        if (z !== 0) throw new Error("Non-zero carry");
        F = V, N++;
      }
      if (I[N] !== " ") {
        for (var R = $ - F; R !== $ && W[R] === 0; ) R++;
        for (var K = new Uint8Array(L + ($ - R)), pe = L; R !== $; ) K[pe++] = W[R++];
        return K;
      }
    }
  }
  function A(I) {
    var N = x(I);
    if (N) return N;
    throw new Error(`Non-${e} character`);
  }
  return { encode: p, decodeUnsafe: x, decode: A };
}
var pW = dW, gW = pW;
const sE = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array") return t;
  if (t instanceof ArrayBuffer) return new Uint8Array(t);
  if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, mW = (t) => new TextEncoder().encode(t), vW = (t) => new TextDecoder().decode(t);
class bW {
  constructor(e, r, n) {
    this.name = e, this.prefix = r, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class yW {
  constructor(e, r, n) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return oE(this, e);
  }
}
class wW {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return oE(this, e);
  }
  decode(e) {
    const r = e[0], n = this.decoders[r];
    if (n) return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const oE = (t, e) => new wW({ ...t.decoders || { [t.prefix]: t }, ...e.decoders || { [e.prefix]: e } });
class xW {
  constructor(e, r, n, i) {
    this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = i, this.encoder = new bW(e, r, n), this.decoder = new yW(e, r, i);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const sp = ({ name: t, prefix: e, encode: r, decode: n }) => new xW(t, e, r, n), th = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: n, decode: i } = gW(r, e);
  return sp({ prefix: t, name: e, encode: n, decode: (s) => sE(i(s)) });
}, _W = (t, e, r, n) => {
  const i = {};
  for (let d = 0; d < e.length; ++d) i[e[d]] = d;
  let s = t.length;
  for (; t[s - 1] === "="; ) --s;
  const o = new Uint8Array(s * r / 8 | 0);
  let a = 0, u = 0, h = 0;
  for (let d = 0; d < s; ++d) {
    const p = i[t[d]];
    if (p === void 0) throw new SyntaxError(`Non-${n} character`);
    u = u << r | p, a += r, a >= 8 && (a -= 8, o[h++] = 255 & u >> a);
  }
  if (a >= r || 255 & u << 8 - a) throw new SyntaxError("Unexpected end of data");
  return o;
}, EW = (t, e, r) => {
  const n = e[e.length - 1] === "=", i = (1 << r) - 1;
  let s = "", o = 0, a = 0;
  for (let u = 0; u < t.length; ++u) for (a = a << 8 | t[u], o += 8; o > r; ) o -= r, s += e[i & a >> o];
  if (o && (s += e[i & a << r - o]), n) for (; s.length * r & 7; ) s += "=";
  return s;
}, Hn = ({ name: t, prefix: e, bitsPerChar: r, alphabet: n }) => sp({ prefix: e, name: t, encode(i) {
  return EW(i, n, r);
}, decode(i) {
  return _W(i, n, r, t);
} }), SW = sp({ prefix: "\0", name: "identity", encode: (t) => vW(t), decode: (t) => mW(t) });
var AW = Object.freeze({ __proto__: null, identity: SW });
const PW = Hn({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var MW = Object.freeze({ __proto__: null, base2: PW });
const IW = Hn({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var CW = Object.freeze({ __proto__: null, base8: IW });
const TW = th({ prefix: "9", name: "base10", alphabet: "0123456789" });
var RW = Object.freeze({ __proto__: null, base10: TW });
const DW = Hn({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), OW = Hn({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var NW = Object.freeze({ __proto__: null, base16: DW, base16upper: OW });
const LW = Hn({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), kW = Hn({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), $W = Hn({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), BW = Hn({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), FW = Hn({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), UW = Hn({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), jW = Hn({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), qW = Hn({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), zW = Hn({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var HW = Object.freeze({ __proto__: null, base32: LW, base32upper: kW, base32pad: $W, base32padupper: BW, base32hex: FW, base32hexupper: UW, base32hexpad: jW, base32hexpadupper: qW, base32z: zW });
const WW = th({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), KW = th({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var VW = Object.freeze({ __proto__: null, base36: WW, base36upper: KW });
const GW = th({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), YW = th({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var JW = Object.freeze({ __proto__: null, base58btc: GW, base58flickr: YW });
const XW = Hn({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), ZW = Hn({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), QW = Hn({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), eK = Hn({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var tK = Object.freeze({ __proto__: null, base64: XW, base64pad: ZW, base64url: QW, base64urlpad: eK });
const aE = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), rK = aE.reduce((t, e, r) => (t[r] = e, t), []), nK = aE.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function iK(t) {
  return t.reduce((e, r) => (e += rK[r], e), "");
}
function sK(t) {
  const e = [];
  for (const r of t) {
    const n = nK[r.codePointAt(0)];
    if (n === void 0) throw new Error(`Non-base256emoji character: ${r}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const oK = sp({ prefix: "🚀", name: "base256emoji", encode: iK, decode: sK });
var aK = Object.freeze({ __proto__: null, base256emoji: oK }), cK = cE, h3 = 128, uK = 127, fK = ~uK, lK = Math.pow(2, 31);
function cE(t, e, r) {
  e = e || [], r = r || 0;
  for (var n = r; t >= lK; ) e[r++] = t & 255 | h3, t /= 128;
  for (; t & fK; ) e[r++] = t & 255 | h3, t >>>= 7;
  return e[r] = t | 0, cE.bytes = r - n + 1, e;
}
var hK = R1, dK = 128, d3 = 127;
function R1(t, n) {
  var r = 0, n = n || 0, i = 0, s = n, o, a = t.length;
  do {
    if (s >= a) throw R1.bytes = 0, new RangeError("Could not decode varint");
    o = t[s++], r += i < 28 ? (o & d3) << i : (o & d3) * Math.pow(2, i), i += 7;
  } while (o >= dK);
  return R1.bytes = s - n, r;
}
var pK = Math.pow(2, 7), gK = Math.pow(2, 14), mK = Math.pow(2, 21), vK = Math.pow(2, 28), bK = Math.pow(2, 35), yK = Math.pow(2, 42), wK = Math.pow(2, 49), xK = Math.pow(2, 56), _K = Math.pow(2, 63), EK = function(t) {
  return t < pK ? 1 : t < gK ? 2 : t < mK ? 3 : t < vK ? 4 : t < bK ? 5 : t < yK ? 6 : t < wK ? 7 : t < xK ? 8 : t < _K ? 9 : 10;
}, SK = { encode: cK, decode: hK, encodingLength: EK }, uE = SK;
const p3 = (t, e, r = 0) => (uE.encode(t, e, r), e), g3 = (t) => uE.encodingLength(t), D1 = (t, e) => {
  const r = e.byteLength, n = g3(t), i = n + g3(r), s = new Uint8Array(i + r);
  return p3(t, s, 0), p3(r, s, n), s.set(e, i), new AK(t, r, e, s);
};
class AK {
  constructor(e, r, n, i) {
    this.code = e, this.size = r, this.digest = n, this.bytes = i;
  }
}
const fE = ({ name: t, code: e, encode: r }) => new PK(t, e, r);
class PK {
  constructor(e, r, n) {
    this.name = e, this.code = r, this.encode = n;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const r = this.encode(e);
      return r instanceof Uint8Array ? D1(this.code, r) : r.then((n) => D1(this.code, n));
    } else throw Error("Unknown type, must be binary type");
  }
}
const lE = (t) => async (e) => new Uint8Array(await crypto.subtle.digest(t, e)), MK = fE({ name: "sha2-256", code: 18, encode: lE("SHA-256") }), IK = fE({ name: "sha2-512", code: 19, encode: lE("SHA-512") });
var CK = Object.freeze({ __proto__: null, sha256: MK, sha512: IK });
const hE = 0, TK = "identity", dE = sE, RK = (t) => D1(hE, dE(t)), DK = { code: hE, name: TK, encode: dE, digest: RK };
var OK = Object.freeze({ __proto__: null, identity: DK });
new TextEncoder(), new TextDecoder();
const m3 = { ...AW, ...MW, ...CW, ...RW, ...NW, ...HW, ...VW, ...JW, ...tK, ...aK };
({ ...CK, ...OK });
function NK(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(t) : new Uint8Array(t);
}
function pE(t, e, r, n) {
  return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: r }, decoder: { decode: n } };
}
const v3 = pE("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), pm = pE("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = NK(t.length);
  for (let r = 0; r < t.length; r++) e[r] = t.charCodeAt(r);
  return e;
}), LK = { utf8: v3, "utf-8": v3, hex: m3.base16, latin1: pm, ascii: pm, binary: pm, ...m3 };
function kK(t, e = "utf8") {
  const r = LK[e];
  if (!r) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t, "utf8") : r.decoder.decode(`${r.prefix}${t}`);
}
let $K = class {
  constructor(e, r) {
    this.core = e, this.logger = r, this.keychain = /* @__PURE__ */ new Map(), this.name = kH, this.version = $H, this.initialized = !1, this.storagePrefix = Xs, this.init = async () => {
      if (!this.initialized) {
        const n = await this.getKeyChain();
        typeof n < "u" && (this.keychain = n), this.initialized = !0;
      }
    }, this.has = (n) => (this.isInitialized(), this.keychain.has(n)), this.set = async (n, i) => {
      this.isInitialized(), this.keychain.set(n, i), await this.persist();
    }, this.get = (n) => {
      this.isInitialized();
      const i = this.keychain.get(n);
      if (typeof i > "u") {
        const { message: s } = ft("NO_MATCHING_KEY", `${this.name}: ${n}`);
        throw new Error(s);
      }
      return i;
    }, this.del = async (n) => {
      this.isInitialized(), this.keychain.delete(n), await this.persist();
    }, this.core = e, this.logger = ai(r, this.name);
  }
  get context() {
    return Si(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, O8(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? N8(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}, BK = class {
  constructor(e, r, n) {
    this.core = e, this.logger = r, this.name = NH, this.randomSessionIdentifier = I1(), this.initialized = !1, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0);
    }, this.hasKeys = (i) => (this.isInitialized(), this.keychain.has(i)), this.getClientId = async () => {
      this.isInitialized();
      const i = await this.getClientSeed(), s = rx(i);
      return F4(s.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const i = az();
      return this.setPrivateKey(i.publicKey, i.privateKey);
    }, this.signJWT = async (i) => {
      this.isInitialized();
      const s = await this.getClientSeed(), o = rx(s), a = this.randomSessionIdentifier;
      return await TB(a, i, LH, o);
    }, this.generateSharedKey = (i, s, o) => {
      this.isInitialized();
      const a = this.getPrivateKey(i), u = cz(a, s);
      return this.setSymKey(u, o);
    }, this.setSymKey = async (i, s) => {
      this.isInitialized();
      const o = s || Cd(i);
      return await this.keychain.set(o, i), o;
    }, this.deleteKeyPair = async (i) => {
      this.isInitialized(), await this.keychain.del(i);
    }, this.deleteSymKey = async (i) => {
      this.isInitialized(), await this.keychain.del(i);
    }, this.encode = async (i, s, o) => {
      this.isInitialized();
      const a = H8(o), u = No(s);
      if (Wx(a)) return fz(u, o == null ? void 0 : o.encoding);
      if (Hx(a)) {
        const x = a.senderPublicKey, A = a.receiverPublicKey;
        i = await this.generateSharedKey(x, A);
      }
      const h = this.getSymKey(i), { type: d, senderPublicKey: p } = a;
      return uz({ type: d, symKey: h, message: u, senderPublicKey: p, encoding: o == null ? void 0 : o.encoding });
    }, this.decode = async (i, s, o) => {
      this.isInitialized();
      const a = dz(s, o);
      if (Wx(a)) {
        const u = hz(s, o == null ? void 0 : o.encoding);
        return oc(u);
      }
      if (Hx(a)) {
        const u = a.receiverPublicKey, h = a.senderPublicKey;
        i = await this.generateSharedKey(u, h);
      }
      try {
        const u = this.getSymKey(i), h = lz({ symKey: u, encoded: s, encoding: o == null ? void 0 : o.encoding });
        return oc(h);
      } catch (u) {
        this.logger.error(`Failed to decode message from topic: '${i}', clientId: '${await this.getClientId()}'`), this.logger.error(u);
      }
    }, this.getPayloadType = (i, s = ua) => {
      const o = xl({ encoded: i, encoding: s });
      return uc(o.type);
    }, this.getPayloadSenderPublicKey = (i, s = ua) => {
      const o = xl({ encoded: i, encoding: s });
      return o.senderPublicKey ? Rn(o.senderPublicKey, oi) : void 0;
    }, this.core = e, this.logger = ai(r, this.name), this.keychain = n || new $K(this.core, this.logger);
  }
  get context() {
    return Si(this.logger);
  }
  async setPrivateKey(e, r) {
    return await this.keychain.set(e, r), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(f3);
    } catch {
      e = I1(), await this.keychain.set(f3, e);
    }
    return kK(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
class FK extends kk {
  constructor(e, r) {
    super(e, r), this.logger = e, this.core = r, this.messages = /* @__PURE__ */ new Map(), this.name = BH, this.version = FH, this.initialized = !1, this.storagePrefix = Xs, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const n = await this.getRelayerMessages();
          typeof n < "u" && (this.messages = n), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (n) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(n);
        } finally {
          this.initialized = !0;
        }
      }
    }, this.set = async (n, i) => {
      this.isInitialized();
      const s = yo(i);
      let o = this.messages.get(n);
      return typeof o > "u" && (o = {}), typeof o[s] < "u" || (o[s] = i, this.messages.set(n, o), await this.persist()), s;
    }, this.get = (n) => {
      this.isInitialized();
      let i = this.messages.get(n);
      return typeof i > "u" && (i = {}), i;
    }, this.has = (n, i) => {
      this.isInitialized();
      const s = this.get(n), o = yo(i);
      return typeof s[o] < "u";
    }, this.del = async (n) => {
      this.isInitialized(), this.messages.delete(n), await this.persist();
    }, this.logger = ai(e, this.name), this.core = r;
  }
  get context() {
    return Si(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, O8(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? N8(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class UK extends $k {
  constructor(e, r) {
    super(e, r), this.relayer = e, this.logger = r, this.events = new rs.EventEmitter(), this.name = jH, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = mt.toMiliseconds(mt.ONE_MINUTE), this.failedPublishTimeout = mt.toMiliseconds(mt.ONE_SECOND), this.needsTransportRestart = !1, this.publish = async (n, i, s) => {
      var o;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: n, message: i, opts: s } });
      const a = (s == null ? void 0 : s.ttl) || UH, u = C1(s), h = (s == null ? void 0 : s.prompt) || !1, d = (s == null ? void 0 : s.tag) || 0, p = (s == null ? void 0 : s.id) || Qa().toString(), x = { topic: n, message: i, opts: { ttl: a, relay: u, prompt: h, tag: d, id: p, attestation: s == null ? void 0 : s.attestation } }, A = `Failed to publish payload, please try again. id:${p} tag:${d}`, I = Date.now();
      let N, L = 1;
      try {
        for (; N === void 0; ) {
          if (Date.now() - I > this.publishTimeout) throw new Error(A);
          this.logger.trace({ id: p, attempts: L }, `publisher.publish - attempt ${L}`), N = await await lu(this.rpcPublish(n, i, a, u, h, d, p, s == null ? void 0 : s.attestation).catch((F) => this.logger.warn(F)), this.publishTimeout, A), L++, N || await new Promise((F) => setTimeout(F, this.failedPublishTimeout));
        }
        this.relayer.events.emit(ii.publish, x), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { id: p, topic: n, message: i, opts: s } });
      } catch (F) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(F), (o = s == null ? void 0 : s.internal) != null && o.throwOnFailedPublish) throw F;
        this.queue.set(p, x);
      }
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.relayer = e, this.logger = ai(r, this.name), this.registerEventListeners();
  }
  get context() {
    return Si(this.logger);
  }
  rpcPublish(e, r, n, i, s, o, a, u) {
    var h, d, p, x;
    const A = { method: kf(i.protocol).publish, params: { topic: e, message: r, ttl: n, prompt: s, tag: o, attestation: u }, id: a };
    return gi((h = A.params) == null ? void 0 : h.prompt) && ((d = A.params) == null || delete d.prompt), gi((p = A.params) == null ? void 0 : p.tag) && ((x = A.params) == null || delete x.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: A }), this.relayer.request(A);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: r, message: n, opts: i } = e;
      await this.publish(r, n, i);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(Ru.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = !1, this.relayer.events.emit(ii.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(ii.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
}
class jK {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, r) => {
      const n = this.get(e);
      this.exists(e, r) || this.map.set(e, [...n, r]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, r) => this.get(e).includes(r), this.delete = (e, r) => {
      if (typeof r > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const n = this.get(e);
      if (!this.exists(e, r)) return;
      const i = n.filter((s) => s !== r);
      if (!i.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, i);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var qK = Object.defineProperty, zK = Object.defineProperties, HK = Object.getOwnPropertyDescriptors, b3 = Object.getOwnPropertySymbols, WK = Object.prototype.hasOwnProperty, KK = Object.prototype.propertyIsEnumerable, y3 = (t, e, r) => e in t ? qK(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Mf = (t, e) => {
  for (var r in e || (e = {})) WK.call(e, r) && y3(t, r, e[r]);
  if (b3) for (var r of b3(e)) KK.call(e, r) && y3(t, r, e[r]);
  return t;
}, gm = (t, e) => zK(t, HK(e));
class VK extends Uk {
  constructor(e, r) {
    super(e, r), this.relayer = e, this.logger = r, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new jK(), this.events = new rs.EventEmitter(), this.name = GH, this.version = YH, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = Xs, this.subscribeTimeout = mt.toMiliseconds(mt.ONE_MINUTE), this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.pendingBatchMessages = [], this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = !0;
    }, this.subscribe = async (n, i) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: i } });
      try {
        const s = C1(i), o = { topic: n, relay: s, transportType: i == null ? void 0 : i.transportType };
        this.pending.set(n, o);
        const a = await this.rpcSubscribe(n, s, i);
        return typeof a == "string" && (this.onSubscribe(a, o), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: i } })), a;
      } catch (s) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(s), s;
      }
    }, this.unsubscribe = async (n, i) => {
      await this.restartToComplete(), this.isInitialized(), typeof (i == null ? void 0 : i.id) < "u" ? await this.unsubscribeById(n, i.id, i) : await this.unsubscribeByTopic(n, i);
    }, this.isSubscribed = async (n) => {
      if (this.topics.includes(n)) return !0;
      const i = `${this.pendingSubscriptionWatchLabel}_${n}`;
      return await new Promise((s, o) => {
        const a = new mt.Watch();
        a.start(i);
        const u = setInterval(() => {
          !this.pending.has(n) && this.topics.includes(n) && (clearInterval(u), a.stop(i), s(!0)), a.elapsed(i) >= JH && (clearInterval(u), a.stop(i), o(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => !1);
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.start = async () => {
      await this.onConnect();
    }, this.stop = async () => {
      await this.onDisconnect();
    }, this.restart = async () => {
      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;
    }, this.relayer = e, this.logger = ai(r, this.name), this.clientId = "";
  }
  get context() {
    return Si(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, r) {
    let n = !1;
    try {
      n = this.getSubscription(e).topic === r;
    } catch {
    }
    return n;
  }
  onEnable() {
    this.cached = [], this.initialized = !0;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, r) {
    const n = this.topicMap.get(e);
    await Promise.all(n.map(async (i) => await this.unsubscribeById(e, i, r)));
  }
  async unsubscribeById(e, r, n) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: r, opts: n } });
    try {
      const i = C1(n);
      await this.rpcUnsubscribe(e, r, i);
      const s = Or("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, r, s), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: r, opts: n } });
    } catch (i) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i), i;
    }
  }
  async rpcSubscribe(e, r, n) {
    var i;
    (n == null ? void 0 : n.transportType) === zr.relay && await this.restartToComplete();
    const s = { method: kf(r.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s });
    const o = (i = n == null ? void 0 : n.internal) == null ? void 0 : i.throwOnFailedPublish;
    try {
      const a = yo(e + this.clientId);
      if ((n == null ? void 0 : n.transportType) === zr.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(s).catch((h) => this.logger.warn(h));
      }, mt.toMiliseconds(mt.ONE_SECOND)), a;
      const u = await lu(this.relayer.request(s).catch((h) => this.logger.warn(h)), this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!u && o) throw new Error(`Subscribing to ${e} failed, please try again`);
      return u ? a : null;
    } catch (a) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(ii.connection_stalled), o) throw a;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const r = e[0].relay, n = { method: kf(r.protocol).batchSubscribe, params: { topics: e.map((i) => i.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    try {
      return await await lu(this.relayer.request(n).catch((i) => this.logger.warn(i)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(ii.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const r = e[0].relay, n = { method: kf(r.protocol).batchFetchMessages, params: { topics: e.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    let i;
    try {
      i = await await lu(this.relayer.request(n).catch((s) => this.logger.warn(s)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(ii.connection_stalled);
    }
    return i;
  }
  rpcUnsubscribe(e, r, n) {
    const i = { method: kf(n.protocol).unsubscribe, params: { topic: e, id: r } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i }), this.relayer.request(i);
  }
  onSubscribe(e, r) {
    this.setSubscription(e, gm(Mf({}, r), { id: e })), this.pending.delete(r.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((r) => {
      this.setSubscription(r.id, Mf({}, r)), this.pending.delete(r.topic);
    });
  }
  async onUnsubscribe(e, r, n) {
    this.events.removeAllListeners(r), this.hasSubscription(r, e) && this.deleteSubscription(r, n), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, r) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: r }), this.addSubscription(e, r);
  }
  addSubscription(e, r) {
    this.subscriptions.set(e, Mf({}, r)), this.topicMap.set(r.topic, e), this.events.emit(Fs.created, r);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const r = this.subscriptions.get(e);
    if (!r) {
      const { message: n } = ft("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return r;
  }
  deleteSubscription(e, r) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: r });
    const n = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(n.topic, e), this.events.emit(Fs.deleted, gm(Mf({}, n), { reason: r }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(Fs.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let r = 0; r < e; r++) {
        const n = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchFetchMessages(n), await this.batchSubscribe(n);
      }
    }
    this.events.emit(Fs.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: r } = ft("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length) return;
    const r = await this.rpcBatchSubscribe(e);
    fc(r) && this.onBatchSubscribe(r.map((n, i) => gm(Mf({}, e[i]), { id: n })));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const r = await this.rpcBatchFetchMessages(e);
    r && r.messages && (this.pendingBatchMessages = this.pendingBatchMessages.concat(r.messages));
  }
  async onConnect() {
    await this.restart(), this.onEnable();
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || !this.relayer.connected) return;
    const e = [];
    this.pending.forEach((r) => {
      e.push(r);
    }), await this.batchSubscribe(e), this.pendingBatchMessages.length && (await this.relayer.handleBatchMessageEvents(this.pendingBatchMessages), this.pendingBatchMessages = []);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(Ru.pulse, async () => {
      await this.checkPending();
    }), this.events.on(Fs.created, async (e) => {
      const r = Fs.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), await this.persist();
    }), this.events.on(Fs.deleted, async (e) => {
      const r = Fs.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen(), this.restartInProgress && await new Promise((e) => {
      const r = setInterval(() => {
        this.restartInProgress || (clearInterval(r), e());
      }, this.pollingInterval);
    });
  }
}
var GK = Object.defineProperty, w3 = Object.getOwnPropertySymbols, YK = Object.prototype.hasOwnProperty, JK = Object.prototype.propertyIsEnumerable, x3 = (t, e, r) => e in t ? GK(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, _3 = (t, e) => {
  for (var r in e || (e = {})) YK.call(e, r) && x3(t, r, e[r]);
  if (w3) for (var r of w3(e)) JK.call(e, r) && x3(t, r, e[r]);
  return t;
};
class XK extends Bk {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new rs.EventEmitter(), this.name = zH, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "stalled", "interrupted"], this.hasExperiencedNetworkDisruption = !1, this.requestsInFlight = /* @__PURE__ */ new Map(), this.heartBeatTimeout = mt.toMiliseconds(mt.THIRTY_SECONDS + mt.ONE_SECOND), this.request = async (r) => {
      var n, i;
      this.logger.debug("Publishing Request Payload");
      const s = r.id || Qa().toString();
      await this.toEstablishConnection();
      try {
        const o = this.provider.request(r);
        this.requestsInFlight.set(s, { promise: o, request: r }), this.logger.trace({ id: s, method: r.method, topic: (n = r.params) == null ? void 0 : n.topic }, "relayer.request - attempt to publish...");
        const a = await new Promise(async (u, h) => {
          const d = () => {
            h(new Error(`relayer.request - publish interrupted, id: ${s}`));
          };
          this.provider.on(Vi.disconnect, d);
          const p = await o;
          this.provider.off(Vi.disconnect, d), u(p);
        });
        return this.logger.trace({ id: s, method: r.method, topic: (i = r.params) == null ? void 0 : i.topic }, "relayer.request - published"), a;
      } catch (o) {
        throw this.logger.debug(`Failed to Publish Request: ${s}`), o;
      } finally {
        this.requestsInFlight.delete(s);
      }
    }, this.resetPingTimeout = () => {
      if (a0()) try {
        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
          var r, n, i;
          (i = (n = (r = this.provider) == null ? void 0 : r.connection) == null ? void 0 : n.socket) == null || i.terminate();
        }, this.heartBeatTimeout);
      } catch (r) {
        this.logger.warn(r);
      }
    }, this.onPayloadHandler = (r) => {
      this.onProviderPayload(r), this.resetPingTimeout();
    }, this.onConnectHandler = () => {
      this.logger.trace("relayer connected"), this.startPingTimeout(), this.events.emit(ii.connect);
    }, this.onDisconnectHandler = () => {
      this.logger.trace("relayer disconnected"), this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (r) => {
      this.logger.error(r), this.events.emit(ii.error, r), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(Vi.payload, this.onPayloadHandler), this.provider.on(Vi.connect, this.onConnectHandler), this.provider.on(Vi.disconnect, this.onDisconnectHandler), this.provider.on(Vi.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? ai(e.logger, this.name) : jl($0({ level: e.logger || qH })), this.messages = new FK(this.logger, e.core), this.subscriber = new VK(this, this.logger), this.publisher = new UK(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || nE, this.projectId = e.projectId, this.bundleId = Aq(), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = !0, this.subscriber.cached.length > 0) try {
      await this.transportOpen();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  get context() {
    return Si(this.logger);
  }
  get connected() {
    var e, r, n;
    return ((n = (r = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : r.socket) == null ? void 0 : n.readyState) === 1;
  }
  get connecting() {
    var e, r, n;
    return ((n = (r = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : r.socket) == null ? void 0 : n.readyState) === 0;
  }
  async publish(e, r, n) {
    this.isInitialized(), await this.publisher.publish(e, r, n), await this.recordMessageEvent({ topic: e, message: r, publishedAt: Date.now(), transportType: zr.relay });
  }
  async subscribe(e, r) {
    var n, i, s;
    this.isInitialized(), (r == null ? void 0 : r.transportType) === "relay" && await this.toEstablishConnection();
    const o = typeof ((n = r == null ? void 0 : r.internal) == null ? void 0 : n.throwOnFailedPublish) > "u" ? !0 : (i = r == null ? void 0 : r.internal) == null ? void 0 : i.throwOnFailedPublish;
    let a = ((s = this.subscriber.topicMap.get(e)) == null ? void 0 : s[0]) || "", u;
    const h = (d) => {
      d.topic === e && (this.subscriber.off(Fs.created, h), u());
    };
    return await Promise.all([new Promise((d) => {
      u = d, this.subscriber.on(Fs.created, h);
    }), new Promise(async (d, p) => {
      a = await this.subscriber.subscribe(e, _3({ internal: { throwOnFailedPublish: o } }, r)).catch((x) => {
        o && p(x);
      }) || a, d();
    })]), a;
  }
  async unsubscribe(e, r) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, r);
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async transportDisconnect() {
    if (!this.hasExperiencedNetworkDisruption && this.connected && this.requestsInFlight.size > 0) try {
      await Promise.all(Array.from(this.requestsInFlight.values()).map((e) => e.promise));
    } catch (e) {
      this.logger.warn(e);
    }
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await lu(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = !0, await this.transportDisconnect();
  }
  async transportOpen(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), await this.createProvider(), this.connectionAttemptInProgress = !0, this.transportExplicitlyClosed = !1;
    try {
      await new Promise(async (r, n) => {
        const i = () => {
          this.provider.off(Vi.disconnect, i), n(new Error("Connection interrupted while trying to subscribe"));
        };
        this.provider.on(Vi.disconnect, i), await lu(this.provider.connect(), mt.toMiliseconds(mt.ONE_MINUTE), `Socket stalled when trying to connect to ${this.relayUrl}`).catch((s) => {
          n(s);
        }).finally(() => {
          clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;
        }), this.subscriber.start().catch((s) => {
          this.logger.error(s), this.onDisconnectHandler();
        }), this.hasExperiencedNetworkDisruption = !1, r();
      });
    } catch (r) {
      this.logger.error(r);
      const n = r;
      if (this.hasExperiencedNetworkDisruption = !0, !this.isConnectionStalled(n.message)) throw r;
    } finally {
      this.connectionAttemptInProgress = !1;
    }
  }
  async restartTransport(e) {
    this.connectionAttemptInProgress || (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await r3()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const r = e.sort((n, i) => n.publishedAt - i.publishedAt);
    this.logger.trace(`Batch of ${r.length} message events sorted`);
    for (const n of r) try {
      await this.onMessageEvent(n);
    } catch (i) {
      this.logger.warn(i);
    }
    this.logger.trace(`Batch of ${r.length} message events processed`);
  }
  async onLinkMessageEvent(e, r) {
    const { topic: n } = e;
    if (!r.sessionExists) {
      const i = En(mt.FIVE_MINUTES), s = { topic: n, expiry: i, relay: { protocol: "irn" }, active: !1 };
      await this.core.pairing.pairings.set(n, s);
    }
    this.events.emit(ii.message, e), await this.recordMessageEvent(e);
  }
  startPingTimeout() {
    var e, r, n, i, s;
    if (a0()) try {
      (r = (e = this.provider) == null ? void 0 : e.connection) != null && r.socket && ((s = (i = (n = this.provider) == null ? void 0 : n.connection) == null ? void 0 : i.socket) == null || s.once("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o) {
      this.logger.warn(o);
    }
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((r) => e.includes(r));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new as(new CH(Cq({ sdkVersion: T1, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: !0, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: r, message: n } = e;
    await this.messages.set(r, n);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: r, message: n } = e;
    if (!n || n.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${n}`), !0;
    if (!await this.subscriber.isSubscribed(r)) return this.logger.debug(`Ignoring message for non-subscribed topic ${r}`), !0;
    const i = this.messages.has(r, n);
    return i && this.logger.debug(`Ignoring duplicate message: ${n}`), i;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), ub(e)) {
      if (!e.method.endsWith(HH)) return;
      const r = e.params, { topic: n, message: i, publishedAt: s, attestation: o } = r.data, a = { topic: n, message: i, publishedAt: s, transportType: zr.relay, attestation: o };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(_3({ type: "event", event: r.id }, a)), this.events.emit(r.id, a), await this.acknowledgePayload(e), await this.onMessageEvent(a);
    } else ip(e) && this.events.emit(ii.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(ii.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const r = rp(e.id, !0);
    await this.provider.connection.send(r);
  }
  unregisterProviderListeners() {
    this.provider.off(Vi.payload, this.onPayloadHandler), this.provider.off(Vi.connect, this.onConnectHandler), this.provider.off(Vi.disconnect, this.onDisconnectHandler), this.provider.off(Vi.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await r3();
    oH(async (r) => {
      e !== r && (e = r, r ? await this.restartTransport().catch((n) => this.logger.error(n)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportDisconnect(), this.transportExplicitlyClosed = !1));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), this.requestsInFlight.clear(), clearTimeout(this.pingTimeout), this.events.emit(ii.disconnect), this.connectionAttemptInProgress = !1, !this.transportExplicitlyClosed && (this.reconnectTimeout || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e));
    }, mt.toMiliseconds(WH))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (this.connectionAttemptInProgress && await new Promise((e) => {
      const r = setInterval(() => {
        this.connected && (clearInterval(r), e());
      }, this.connectionStatusPollingInterval);
    }), await this.transportOpen());
  }
}
var ZK = Object.defineProperty, E3 = Object.getOwnPropertySymbols, QK = Object.prototype.hasOwnProperty, eV = Object.prototype.propertyIsEnumerable, S3 = (t, e, r) => e in t ? ZK(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, A3 = (t, e) => {
  for (var r in e || (e = {})) QK.call(e, r) && S3(t, r, e[r]);
  if (E3) for (var r of E3(e)) eV.call(e, r) && S3(t, r, e[r]);
  return t;
};
class yc extends Fk {
  constructor(e, r, n, i = Xs, s = void 0) {
    super(e, r, n, i), this.core = e, this.logger = r, this.name = n, this.map = /* @__PURE__ */ new Map(), this.version = KH, this.cached = [], this.initialized = !1, this.storagePrefix = Xs, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o) => {
        this.getKey && o !== null && !gi(o) ? this.map.set(this.getKey(o), o) : $z(o) ? this.map.set(o.id, o) : Bz(o) && this.map.set(o.topic, o);
      }), this.cached = [], this.initialized = !0);
    }, this.set = async (o, a) => {
      this.isInitialized(), this.map.has(o) ? await this.update(o, a) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o, value: a }), this.map.set(o, a), await this.persist());
    }, this.get = (o) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o }), this.getData(o)), this.getAll = (o) => (this.isInitialized(), o ? this.values.filter((a) => Object.keys(o).every((u) => RH(a[u], o[u]))) : this.values), this.update = async (o, a) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o, update: a });
      const u = A3(A3({}, this.getData(o)), a);
      this.map.set(o, u), await this.persist();
    }, this.delete = async (o, a) => {
      this.isInitialized(), this.map.has(o) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o, reason: a }), this.map.delete(o), this.addToRecentlyDeleted(o), await this.persist());
    }, this.logger = ai(r, this.name), this.storagePrefix = i, this.getKey = s;
  }
  get context() {
    return Si(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const r = this.map.get(e);
    if (!r) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: i } = ft("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(i), new Error(i);
      }
      const { message: n } = ft("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(n), new Error(n);
    }
    return r;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: r } = ft("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class tV {
  constructor(e, r) {
    this.core = e, this.logger = r, this.name = XH, this.version = ZH, this.events = new Lv(), this.initialized = !1, this.storagePrefix = Xs, this.ignoredPayloadTypes = [Mo], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
    }, this.register = ({ methods: n }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...n])];
    }, this.create = async (n) => {
      this.isInitialized();
      const i = I1(), s = await this.core.crypto.setSymKey(i), o = En(mt.FIVE_MINUTES), a = { protocol: rE }, u = { topic: s, expiry: o, relay: a, active: !1, methods: n == null ? void 0 : n.methods }, h = Jx({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: i, relay: a, expiryTimestamp: o, methods: n == null ? void 0 : n.methods });
      return this.events.emit(Ga.create, u), this.core.expirer.set(s, o), await this.pairings.set(s, u), await this.core.relayer.subscribe(s, { transportType: n == null ? void 0 : n.transportType }), { topic: s, uri: h };
    }, this.pair = async (n) => {
      this.isInitialized();
      const i = this.core.eventClient.createEvent({ properties: { topic: n == null ? void 0 : n.uri, trace: [$s.pairing_started] } });
      this.isValidPair(n, i);
      const { topic: s, symKey: o, relay: a, expiryTimestamp: u, methods: h } = Yx(n.uri);
      i.props.properties.topic = s, i.addTrace($s.pairing_uri_validation_success), i.addTrace($s.pairing_uri_not_expired);
      let d;
      if (this.pairings.keys.includes(s)) {
        if (d = this.pairings.get(s), i.addTrace($s.existing_pairing), d.active) throw i.setError(bo.active_pairing_already_exists), new Error(`Pairing already exists: ${s}. Please try again with a new connection URI.`);
        i.addTrace($s.pairing_not_expired);
      }
      const p = u || En(mt.FIVE_MINUTES), x = { topic: s, relay: a, expiry: p, active: !1, methods: h };
      this.core.expirer.set(s, p), await this.pairings.set(s, x), i.addTrace($s.store_new_pairing), n.activatePairing && await this.activate({ topic: s }), this.events.emit(Ga.create, x), i.addTrace($s.emit_inactive_pairing), this.core.crypto.keychain.has(s) || await this.core.crypto.setSymKey(o, s), i.addTrace($s.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        i.setError(bo.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(s, { relay: a });
      } catch (A) {
        throw i.setError(bo.subscribe_pairing_topic_failure), A;
      }
      return i.addTrace($s.subscribe_pairing_topic_success), x;
    }, this.activate = async ({ topic: n }) => {
      this.isInitialized();
      const i = En(mt.THIRTY_DAYS);
      this.core.expirer.set(n, i), await this.pairings.update(n, { active: !0, expiry: i });
    }, this.ping = async (n) => {
      this.isInitialized(), await this.isValidPing(n);
      const { topic: i } = n;
      if (this.pairings.keys.includes(i)) {
        const s = await this.sendRequest(i, "wc_pairingPing", {}), { done: o, resolve: a, reject: u } = Ha();
        this.events.once(vr("pairing_ping", s), ({ error: h }) => {
          h ? u(h) : a();
        }), await o();
      }
    }, this.updateExpiry = async ({ topic: n, expiry: i }) => {
      this.isInitialized(), await this.pairings.update(n, { expiry: i });
    }, this.updateMetadata = async ({ topic: n, metadata: i }) => {
      this.isInitialized(), await this.pairings.update(n, { peerMetadata: i });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (n) => {
      this.isInitialized(), await this.isValidDisconnect(n);
      const { topic: i } = n;
      this.pairings.keys.includes(i) && (await this.sendRequest(i, "wc_pairingDelete", Or("USER_DISCONNECTED")), await this.deletePairing(i));
    }, this.formatUriFromPairing = (n) => {
      this.isInitialized();
      const { topic: i, relay: s, expiry: o, methods: a } = n, u = this.core.crypto.keychain.get(i);
      return Jx({ protocol: this.core.protocol, version: this.core.version, topic: i, symKey: u, relay: s, expiryTimestamp: o, methods: a });
    }, this.sendRequest = async (n, i, s) => {
      const o = fa(i, s), a = await this.core.crypto.encode(n, o), u = Af[i].req;
      return this.core.history.set(n, o), this.core.relayer.publish(n, a, u), o.id;
    }, this.sendResult = async (n, i, s) => {
      const o = rp(n, s), a = await this.core.crypto.encode(i, o), u = await this.core.history.get(i, n), h = Af[u.request.method].res;
      await this.core.relayer.publish(i, a, h), await this.core.history.resolve(o);
    }, this.sendError = async (n, i, s) => {
      const o = np(n, s), a = await this.core.crypto.encode(i, o), u = await this.core.history.get(i, n), h = Af[u.request.method] ? Af[u.request.method].res : Af.unregistered_method.res;
      await this.core.relayer.publish(i, a, h), await this.core.history.resolve(o);
    }, this.deletePairing = async (n, i) => {
      await this.core.relayer.unsubscribe(n), await Promise.all([this.pairings.delete(n, Or("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(n), i ? Promise.resolve() : this.core.expirer.del(n)]);
    }, this.cleanup = async () => {
      const n = this.pairings.getAll().filter((i) => sa(i.expiry));
      await Promise.all(n.map((i) => this.deletePairing(i.topic)));
    }, this.onRelayEventRequest = (n) => {
      const { topic: i, payload: s } = n;
      switch (s.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i, s);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i, s);
        default:
          return this.onUnknownRpcMethodRequest(i, s);
      }
    }, this.onRelayEventResponse = async (n) => {
      const { topic: i, payload: s } = n, o = (await this.core.history.get(i, s.id)).request.method;
      switch (o) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i, s);
        default:
          return this.onUnknownRpcMethodResponse(o);
      }
    }, this.onPairingPingRequest = async (n, i) => {
      const { id: s } = i;
      try {
        this.isValidPing({ topic: n }), await this.sendResult(s, n, !0), this.events.emit(Ga.ping, { id: s, topic: n });
      } catch (o) {
        await this.sendError(s, n, o), this.logger.error(o);
      }
    }, this.onPairingPingResponse = (n, i) => {
      const { id: s } = i;
      setTimeout(() => {
        Bs(i) ? this.events.emit(vr("pairing_ping", s), {}) : Zi(i) && this.events.emit(vr("pairing_ping", s), { error: i.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (n, i) => {
      const { id: s } = i;
      try {
        this.isValidDisconnect({ topic: n }), await this.deletePairing(n), this.events.emit(Ga.delete, { id: s, topic: n });
      } catch (o) {
        await this.sendError(s, n, o), this.logger.error(o);
      }
    }, this.onUnknownRpcMethodRequest = async (n, i) => {
      const { id: s, method: o } = i;
      try {
        if (this.registeredMethods.includes(o)) return;
        const a = Or("WC_METHOD_UNSUPPORTED", o);
        await this.sendError(s, n, a), this.logger.error(a);
      } catch (a) {
        await this.sendError(s, n, a), this.logger.error(a);
      }
    }, this.onUnknownRpcMethodResponse = (n) => {
      this.registeredMethods.includes(n) || this.logger.error(Or("WC_METHOD_UNSUPPORTED", n));
    }, this.isValidPair = (n, i) => {
      var s;
      if (!pi(n)) {
        const { message: a } = ft("MISSING_OR_INVALID", `pair() params: ${n}`);
        throw i.setError(bo.malformed_pairing_uri), new Error(a);
      }
      if (!kz(n.uri)) {
        const { message: a } = ft("MISSING_OR_INVALID", `pair() uri: ${n.uri}`);
        throw i.setError(bo.malformed_pairing_uri), new Error(a);
      }
      const o = Yx(n == null ? void 0 : n.uri);
      if (!((s = o == null ? void 0 : o.relay) != null && s.protocol)) {
        const { message: a } = ft("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw i.setError(bo.malformed_pairing_uri), new Error(a);
      }
      if (!(o != null && o.symKey)) {
        const { message: a } = ft("MISSING_OR_INVALID", "pair() uri#symKey");
        throw i.setError(bo.malformed_pairing_uri), new Error(a);
      }
      if (o != null && o.expiryTimestamp && mt.toMiliseconds(o == null ? void 0 : o.expiryTimestamp) < Date.now()) {
        i.setError(bo.pairing_expired);
        const { message: a } = ft("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a);
      }
    }, this.isValidPing = async (n) => {
      if (!pi(n)) {
        const { message: s } = ft("MISSING_OR_INVALID", `ping() params: ${n}`);
        throw new Error(s);
      }
      const { topic: i } = n;
      await this.isValidPairingTopic(i);
    }, this.isValidDisconnect = async (n) => {
      if (!pi(n)) {
        const { message: s } = ft("MISSING_OR_INVALID", `disconnect() params: ${n}`);
        throw new Error(s);
      }
      const { topic: i } = n;
      await this.isValidPairingTopic(i);
    }, this.isValidPairingTopic = async (n) => {
      if (!dn(n, !1)) {
        const { message: i } = ft("MISSING_OR_INVALID", `pairing topic should be a string: ${n}`);
        throw new Error(i);
      }
      if (!this.pairings.keys.includes(n)) {
        const { message: i } = ft("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n}`);
        throw new Error(i);
      }
      if (sa(this.pairings.get(n).expiry)) {
        await this.deletePairing(n);
        const { message: i } = ft("EXPIRED", `pairing topic: ${n}`);
        throw new Error(i);
      }
    }, this.core = e, this.logger = ai(r, this.name), this.pairings = new yc(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return Si(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(ii.message, async (e) => {
      const { topic: r, message: n, transportType: i } = e;
      if (!this.pairings.keys.includes(r) || i === zr.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(n))) return;
      const s = await this.core.crypto.decode(r, n);
      try {
        ub(s) ? (this.core.history.set(r, s), this.onRelayEventRequest({ topic: r, payload: s })) : ip(s) && (await this.core.history.resolve(s), await this.onRelayEventResponse({ topic: r, payload: s }), this.core.history.delete(r, s.id));
      } catch (o) {
        this.logger.error(o);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(Ji.expired, async (e) => {
      const { topic: r } = k8(e.target);
      r && this.pairings.keys.includes(r) && (await this.deletePairing(r, !0), this.events.emit(Ga.expire, { topic: r }));
    });
  }
}
class rV extends Lk {
  constructor(e, r) {
    super(e, r), this.core = e, this.logger = r, this.records = /* @__PURE__ */ new Map(), this.events = new rs.EventEmitter(), this.name = QH, this.version = eW, this.cached = [], this.initialized = !1, this.storagePrefix = Xs, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.records.set(n.id, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.set = (n, i, s) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: n, request: i, chainId: s }), this.records.has(i.id)) return;
      const o = { id: i.id, topic: n, request: { method: i.method, params: i.params || null }, chainId: s, expiry: En(mt.THIRTY_DAYS) };
      this.records.set(o.id, o), this.persist(), this.events.emit(gs.created, o);
    }, this.resolve = async (n) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: n }), !this.records.has(n.id)) return;
      const i = await this.getRecord(n.id);
      typeof i.response > "u" && (i.response = Zi(n) ? { error: n.error } : { result: n.result }, this.records.set(i.id, i), this.persist(), this.events.emit(gs.updated, i));
    }, this.get = async (n, i) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: n, id: i }), await this.getRecord(i)), this.delete = (n, i) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i }), this.values.forEach((s) => {
        if (s.topic === n) {
          if (typeof i < "u" && s.id !== i) return;
          this.records.delete(s.id), this.events.emit(gs.deleted, s);
        }
      }), this.persist();
    }, this.exists = async (n, i) => (this.isInitialized(), this.records.has(i) ? (await this.getRecord(i)).topic === n : !1), this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.logger = ai(r, this.name);
  }
  get context() {
    return Si(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((r) => {
      if (typeof r.response < "u") return;
      const n = { topic: r.topic, request: fa(r.request.method, r.request.params, r.id), chainId: r.chainId };
      return e.push(n);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const r = this.records.get(e);
    if (!r) {
      const { message: n } = ft("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return r;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(gs.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: r } = ft("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(gs.created, (e) => {
      const r = gs.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e });
    }), this.events.on(gs.updated, (e) => {
      const r = gs.updated;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e });
    }), this.events.on(gs.deleted, (e) => {
      const r = gs.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e });
    }), this.core.heartbeat.on(Ru.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = !1;
      this.records.forEach((r) => {
        mt.toMiliseconds(r.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${r.id}`), this.records.delete(r.id), this.events.emit(gs.deleted, r, !1), e = !0);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class nV extends jk {
  constructor(e, r) {
    super(e, r), this.core = e, this.logger = r, this.expirations = /* @__PURE__ */ new Map(), this.events = new rs.EventEmitter(), this.name = tW, this.version = rW, this.cached = [], this.initialized = !1, this.storagePrefix = Xs, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.expirations.set(n.target, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.has = (n) => {
      try {
        const i = this.formatTarget(n);
        return typeof this.getExpiration(i) < "u";
      } catch {
        return !1;
      }
    }, this.set = (n, i) => {
      this.isInitialized();
      const s = this.formatTarget(n), o = { target: s, expiry: i };
      this.expirations.set(s, o), this.checkExpiry(s, o), this.events.emit(Ji.created, { target: s, expiration: o });
    }, this.get = (n) => {
      this.isInitialized();
      const i = this.formatTarget(n);
      return this.getExpiration(i);
    }, this.del = (n) => {
      if (this.isInitialized(), this.has(n)) {
        const i = this.formatTarget(n), s = this.getExpiration(i);
        this.expirations.delete(i), this.events.emit(Ji.deleted, { target: i, expiration: s });
      }
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.logger = ai(r, this.name);
  }
  get context() {
    return Si(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return Tq(e);
    if (typeof e == "number") return Rq(e);
    const { message: r } = ft("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(r);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(Ji.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: r } = ft("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const r = this.expirations.get(e);
    if (!r) {
      const { message: n } = ft("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(n), new Error(n);
    }
    return r;
  }
  checkExpiry(e, r) {
    const { expiry: n } = r;
    mt.toMiliseconds(n) - Date.now() <= 0 && this.expire(e, r);
  }
  expire(e, r) {
    this.expirations.delete(e), this.events.emit(Ji.expired, { target: e, expiration: r });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, r) => this.checkExpiry(r, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(Ru.pulse, () => this.checkExpirations()), this.events.on(Ji.created, (e) => {
      const r = Ji.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    }), this.events.on(Ji.expired, (e) => {
      const r = Ji.expired;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    }), this.events.on(Ji.deleted, (e) => {
      const r = Ji.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class iV extends qk {
  constructor(e, r, n) {
    super(e, r, n), this.core = e, this.logger = r, this.store = n, this.name = nW, this.verifyUrlV3 = sW, this.storagePrefix = Xs, this.version = eE, this.init = async () => {
      var i;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && mt.toMiliseconds((i = this.publicKey) == null ? void 0 : i.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }, this.register = async (i) => {
      if (!Xl() || this.isDevEnv) return;
      const s = window.location.origin, { id: o, decryptedId: a } = i, u = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${s}&id=${o}&decryptedId=${a}`;
      try {
        const h = Wl(), d = this.startAbortTimer(mt.ONE_SECOND * 5), p = await new Promise((x, A) => {
          const I = () => {
            window.removeEventListener("message", L), h.body.removeChild(N), A("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", I);
          const N = h.createElement("iframe");
          N.src = u, N.style.display = "none", N.addEventListener("error", I, { signal: this.abortController.signal });
          const L = (F) => {
            if (F.data && typeof F.data == "string") try {
              const $ = JSON.parse(F.data);
              if ($.type === "verify_attestation") {
                if (v1($.attestation).payload.id !== o) return;
                clearInterval(d), h.body.removeChild(N), this.abortController.signal.removeEventListener("abort", I), window.removeEventListener("message", L), x($.attestation === null ? "" : $.attestation);
              }
            } catch ($) {
              this.logger.warn($);
            }
          };
          h.body.appendChild(N), window.addEventListener("message", L, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", p), p;
      } catch (h) {
        this.logger.warn(h);
      }
      return "";
    }, this.resolve = async (i) => {
      if (this.isDevEnv) return "";
      const { attestationId: s, hash: o, encryptedId: a } = i;
      if (s === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (s) {
        if (v1(s).payload.id !== a) return;
        const h = await this.isValidJwtAttestation(s);
        if (h) {
          if (!h.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h;
        }
      }
      if (!o) return;
      const u = this.getVerifyUrl(i == null ? void 0 : i.verifyUrl);
      return this.fetchAttestation(o, u);
    }, this.fetchAttestation = async (i, s) => {
      this.logger.debug(`resolving attestation: ${i} from url: ${s}`);
      const o = this.startAbortTimer(mt.ONE_SECOND * 5), a = await fetch(`${s}/attestation/${i}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o), a.status === 200 ? await a.json() : void 0;
    }, this.getVerifyUrl = (i) => {
      let s = i || qf;
      return oW.includes(s) || (this.logger.info(`verify url: ${s}, not included in trusted list, assigning default: ${qf}`), s = qf), s;
    }, this.fetchPublicKey = async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const i = this.startAbortTimer(mt.FIVE_SECONDS), s = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(i), await s.json();
      } catch (i) {
        this.logger.warn(i);
      }
    }, this.persistPublicKey = async (i) => {
      this.logger.debug("persisting public key to local storage", i), await this.store.setItem(this.storeKey, i), this.publicKey = i;
    }, this.removePublicKey = async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }, this.isValidJwtAttestation = async (i) => {
      const s = await this.getPublicKey();
      try {
        if (s) return this.validateAttestation(i, s);
      } catch (a) {
        this.logger.error(a), this.logger.warn("error validating attestation");
      }
      const o = await this.fetchAndPersistPublicKey();
      try {
        if (o) return this.validateAttestation(i, o);
      } catch (a) {
        this.logger.error(a), this.logger.warn("error validating attestation");
      }
    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (s) => {
        const o = await this.fetchPublicKey();
        o && (await this.persistPublicKey(o), s(o));
      });
      const i = await this.fetchPromise;
      return this.fetchPromise = void 0, i;
    }, this.validateAttestation = (i, s) => {
      const o = vz(i, s.publicKey), a = { hasExpired: mt.toMiliseconds(o.exp) < Date.now(), payload: o };
      if (a.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a.payload.origin, isScam: a.payload.isScam, isVerified: a.payload.isVerified };
    }, this.logger = ai(r, this.name), this.abortController = new AbortController(), this.isDevEnv = nb(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return Si(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), mt.toMiliseconds(e));
  }
}
class sV extends zk {
  constructor(e, r) {
    super(e, r), this.projectId = e, this.logger = r, this.context = aW, this.registerDeviceToken = async (n) => {
      const { clientId: i, token: s, notificationType: o, enableEncrypted: a = !1 } = n, u = `${cW}/${this.projectId}/clients`;
      await fetch(u, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i, type: o, token: s, always_raw: a }) });
    }, this.logger = ai(r, this.context);
  }
}
var oV = Object.defineProperty, P3 = Object.getOwnPropertySymbols, aV = Object.prototype.hasOwnProperty, cV = Object.prototype.propertyIsEnumerable, M3 = (t, e, r) => e in t ? oV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, If = (t, e) => {
  for (var r in e || (e = {})) aV.call(e, r) && M3(t, r, e[r]);
  if (P3) for (var r of P3(e)) cV.call(e, r) && M3(t, r, e[r]);
  return t;
};
class uV extends Hk {
  constructor(e, r, n = !0) {
    super(e, r, n), this.core = e, this.logger = r, this.context = fW, this.storagePrefix = Xs, this.storageVersion = uW, this.events = /* @__PURE__ */ new Map(), this.shouldPersist = !1, this.init = async () => {
      if (!nb()) try {
        const i = { eventId: $x(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: D8(this.core.relayer.protocol, this.core.relayer.version, T1) } } };
        await this.sendEvent([i]);
      } catch (i) {
        this.logger.warn(i);
      }
    }, this.createEvent = (i) => {
      const { event: s = "ERROR", type: o = "", properties: { topic: a, trace: u } } = i, h = $x(), d = this.core.projectId || "", p = Date.now(), x = If({ eventId: h, timestamp: p, props: { event: s, type: o, properties: { topic: a, trace: u } }, bundleId: d, domain: this.getAppDomain() }, this.setMethods(h));
      return this.telemetryEnabled && (this.events.set(h, x), this.shouldPersist = !0), x;
    }, this.getEvent = (i) => {
      const { eventId: s, topic: o } = i;
      if (s) return this.events.get(s);
      const a = Array.from(this.events.values()).find((u) => u.props.properties.topic === o);
      if (a) return If(If({}, a), this.setMethods(a.eventId));
    }, this.deleteEvent = (i) => {
      const { eventId: s } = i;
      this.events.delete(s), this.shouldPersist = !0;
    }, this.setEventListeners = () => {
      this.core.heartbeat.on(Ru.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((i) => {
          mt.fromMiliseconds(Date.now()) - mt.fromMiliseconds(i.timestamp) > lW && (this.events.delete(i.eventId), this.shouldPersist = !0);
        });
      });
    }, this.setMethods = (i) => ({ addTrace: (s) => this.addTrace(i, s), setError: (s) => this.setError(i, s) }), this.addTrace = (i, s) => {
      const o = this.events.get(i);
      o && (o.props.properties.trace.push(s), this.events.set(i, o), this.shouldPersist = !0);
    }, this.setError = (i, s) => {
      const o = this.events.get(i);
      o && (o.props.type = s, o.timestamp = Date.now(), this.events.set(i, o), this.shouldPersist = !0);
    }, this.persist = async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = !1;
    }, this.restore = async () => {
      try {
        const i = await this.core.storage.getItem(this.storageKey) || [];
        if (!i.length) return;
        i.forEach((s) => {
          this.events.set(s.eventId, If(If({}, s), this.setMethods(s.eventId)));
        });
      } catch (i) {
        this.logger.warn(i);
      }
    }, this.submit = async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const i = [];
      for (const [s, o] of this.events) o.props.type && i.push(o);
      if (i.length !== 0) try {
        if ((await this.sendEvent(i)).ok) for (const s of i) this.events.delete(s.eventId), this.shouldPersist = !0;
      } catch (s) {
        this.logger.warn(s);
      }
    }, this.sendEvent = async (i) => {
      const s = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${hW}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${T1}${s}`, { method: "POST", body: JSON.stringify(i) });
    }, this.getAppDomain = () => R8().url, this.logger = ai(r, this.context), this.telemetryEnabled = n, n ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
}
var fV = Object.defineProperty, I3 = Object.getOwnPropertySymbols, lV = Object.prototype.hasOwnProperty, hV = Object.prototype.propertyIsEnumerable, C3 = (t, e, r) => e in t ? fV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, T3 = (t, e) => {
  for (var r in e || (e = {})) lV.call(e, r) && C3(t, r, e[r]);
  if (I3) for (var r of I3(e)) hV.call(e, r) && C3(t, r, e[r]);
  return t;
};
class fb extends Nk {
  constructor(e) {
    var r;
    super(e), this.protocol = Q8, this.version = eE, this.name = tE, this.events = new rs.EventEmitter(), this.initialized = !1, this.on = (o, a) => this.events.on(o, a), this.once = (o, a) => this.events.once(o, a), this.off = (o, a) => this.events.off(o, a), this.removeListener = (o, a) => this.events.removeListener(o, a), this.dispatchEnvelope = ({ topic: o, message: a, sessionExists: u }) => {
      if (!o || !a) return;
      const h = { topic: o, message: a, publishedAt: Date.now(), transportType: zr.link_mode };
      this.relayer.onLinkMessageEvent(h, { sessionExists: u });
    }, this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || nE, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const n = $0({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : DH.logger }), { logger: i, chunkLoggerController: s } = Ok({ opts: n, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = s, (r = this.logChunkController) != null && r.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var o, a;
      (o = this.logChunkController) != null && o.downloadLogsBlobInBrowser && ((a = this.logChunkController) == null || a.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = ai(i, this.name), this.heartbeat = new ML(), this.crypto = new BK(this, this.logger, e == null ? void 0 : e.keychain), this.history = new rV(this, this.logger), this.expirer = new nV(this, this.logger), this.storage = e != null && e.storage ? e.storage : new sk(T3(T3({}, OH), e == null ? void 0 : e.storageOptions)), this.relayer = new XK({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new tV(this, this.logger), this.verify = new iV(this, this.logger, this.storage), this.echoClient = new sV(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new uV(this, this.logger, e == null ? void 0 : e.telemetryEnabled);
  }
  static async init(e) {
    const r = new fb(e);
    await r.initialize();
    const n = await r.crypto.getClientId();
    return await r.storage.setItem(VH, n), r;
  }
  get context() {
    return Si(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(l3, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.eventClient.init(), this.linkModeSupportedApps = await this.storage.getItem(l3) || [], this.initialized = !0, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
}
const dV = fb, gE = "wc", mE = 2, vE = "client", lb = `${gE}@${mE}:${vE}:`, mm = { name: vE, logger: "error" }, R3 = "WALLETCONNECT_DEEPLINK_CHOICE", pV = "proposal", bE = "Proposal expired", gV = "session", Hc = mt.SEVEN_DAYS, mV = "engine", In = { wc_sessionPropose: { req: { ttl: mt.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1101 }, reject: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1120 }, autoReject: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1121 } }, wc_sessionSettle: { req: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: mt.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: mt.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: mt.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: mt.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: mt.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: mt.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: mt.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: mt.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: mt.ONE_DAY, prompt: !1, tag: 1114 }, res: { ttl: mt.ONE_DAY, prompt: !1, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: mt.ONE_HOUR, prompt: !0, tag: 1116 }, res: { ttl: mt.ONE_HOUR, prompt: !1, tag: 1117 }, reject: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1118 }, autoReject: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1119 } } }, vm = { min: mt.FIVE_MINUTES, max: mt.SEVEN_DAYS }, Ns = { idle: "IDLE", active: "ACTIVE" }, vV = "request", bV = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"], yV = "wc", wV = "auth", xV = "authKeys", _V = "pairingTopics", EV = "requests", op = `${yV}@${1.5}:${wV}:`, Td = `${op}:PUB_KEY`;
var SV = Object.defineProperty, AV = Object.defineProperties, PV = Object.getOwnPropertyDescriptors, D3 = Object.getOwnPropertySymbols, MV = Object.prototype.hasOwnProperty, IV = Object.prototype.propertyIsEnumerable, O3 = (t, e, r) => e in t ? SV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, tn = (t, e) => {
  for (var r in e || (e = {})) MV.call(e, r) && O3(t, r, e[r]);
  if (D3) for (var r of D3(e)) IV.call(e, r) && O3(t, r, e[r]);
  return t;
}, vs = (t, e) => AV(t, PV(e));
class CV extends Kk {
  constructor(e) {
    super(e), this.name = mV, this.events = new Lv(), this.initialized = !1, this.requestQueue = { state: Ns.idle, queue: [] }, this.sessionRequestQueue = { state: Ns.idle, queue: [] }, this.requestQueueDelay = mt.ONE_SECOND, this.expectedPairingMethodMap = /* @__PURE__ */ new Map(), this.recentlyDeletedMap = /* @__PURE__ */ new Map(), this.recentlyDeletedLimit = 200, this.relayMessageCache = [], this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(In) }), this.initialized = !0, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, mt.toMiliseconds(this.requestQueueDelay)));
    }, this.connect = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const n = vs(tn({}, r), { requiredNamespaces: r.requiredNamespaces || {}, optionalNamespaces: r.optionalNamespaces || {} });
      await this.isValidConnect(n);
      const { pairingTopic: i, requiredNamespaces: s, optionalNamespaces: o, sessionProperties: a, relays: u } = n;
      let h = i, d, p = !1;
      try {
        h && (p = this.client.core.pairing.pairings.get(h).active);
      } catch (z) {
        throw this.client.logger.error(`connect() -> pairing.get(${h}) failed`), z;
      }
      if (!h || !p) {
        const { topic: z, uri: V } = await this.client.core.pairing.create();
        h = z, d = V;
      }
      if (!h) {
        const { message: z } = ft("NO_MATCHING_KEY", `connect() pairing topic: ${h}`);
        throw new Error(z);
      }
      const x = await this.client.core.crypto.generateKeyPair(), A = In.wc_sessionPropose.req.ttl || mt.FIVE_MINUTES, I = En(A), N = tn({ requiredNamespaces: s, optionalNamespaces: o, relays: u ?? [{ protocol: rE }], proposer: { publicKey: x, metadata: this.client.metadata }, expiryTimestamp: I, pairingTopic: h }, a && { sessionProperties: a }), { reject: L, resolve: F, done: $ } = Ha(A, bE);
      this.events.once(vr("session_connect"), async ({ error: z, session: V }) => {
        if (z) L(z);
        else if (V) {
          V.self.publicKey = x;
          const te = vs(tn({}, V), { pairingTopic: N.pairingTopic, requiredNamespaces: N.requiredNamespaces, optionalNamespaces: N.optionalNamespaces, transportType: zr.relay });
          await this.client.session.set(V.topic, te), await this.setExpiry(V.topic, V.expiry), h && await this.client.core.pairing.updateMetadata({ topic: h, metadata: V.peer.metadata }), this.cleanupDuplicatePairings(te), F(te);
        }
      });
      const W = await this.sendRequest({ topic: h, method: "wc_sessionPropose", params: N, throwOnFailedPublish: !0 });
      return await this.setProposal(W, tn({ id: W }, N)), { uri: d, approval: $ };
    }, this.pair = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(r);
      } catch (n) {
        throw this.client.logger.error("pair() failed"), n;
      }
    }, this.approve = async (r) => {
      var n, i, s;
      const o = this.client.core.eventClient.createEvent({ properties: { topic: (n = r == null ? void 0 : r.id) == null ? void 0 : n.toString(), trace: [ms.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (K) {
        throw o.setError(ja.no_internet_connection), K;
      }
      try {
        await this.isValidProposalId(r == null ? void 0 : r.id);
      } catch (K) {
        throw this.client.logger.error(`approve() -> proposal.get(${r == null ? void 0 : r.id}) failed`), o.setError(ja.proposal_not_found), K;
      }
      try {
        await this.isValidApprove(r);
      } catch (K) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), o.setError(ja.session_approve_namespace_validation_failure), K;
      }
      const { id: a, relayProtocol: u, namespaces: h, sessionProperties: d, sessionConfig: p } = r, x = this.client.proposal.get(a);
      this.client.core.eventClient.deleteEvent({ eventId: o.eventId });
      const { pairingTopic: A, proposer: I, requiredNamespaces: N, optionalNamespaces: L } = x;
      let F = (i = this.client.core.eventClient) == null ? void 0 : i.getEvent({ topic: A });
      F || (F = (s = this.client.core.eventClient) == null ? void 0 : s.createEvent({ type: ms.session_approve_started, properties: { topic: A, trace: [ms.session_approve_started, ms.session_namespaces_validation_success] } }));
      const $ = await this.client.core.crypto.generateKeyPair(), W = I.publicKey, z = await this.client.core.crypto.generateSharedKey($, W), V = tn(tn({ relay: { protocol: u ?? "irn" }, namespaces: h, controller: { publicKey: $, metadata: this.client.metadata }, expiry: En(Hc) }, d && { sessionProperties: d }), p && { sessionConfig: p }), te = zr.relay;
      F.addTrace(ms.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(z, { transportType: te });
      } catch (K) {
        throw F.setError(ja.subscribe_session_topic_failure), K;
      }
      F.addTrace(ms.subscribe_session_topic_success);
      const R = vs(tn({}, V), { topic: z, requiredNamespaces: N, optionalNamespaces: L, pairingTopic: A, acknowledged: !1, self: V.controller, peer: { publicKey: I.publicKey, metadata: I.metadata }, controller: $, transportType: zr.relay });
      await this.client.session.set(z, R), F.addTrace(ms.store_session);
      try {
        F.addTrace(ms.publishing_session_settle), await this.sendRequest({ topic: z, method: "wc_sessionSettle", params: V, throwOnFailedPublish: !0 }).catch((K) => {
          throw F == null || F.setError(ja.session_settle_publish_failure), K;
        }), F.addTrace(ms.session_settle_publish_success), F.addTrace(ms.publishing_session_approve), await this.sendResult({ id: a, topic: A, result: { relay: { protocol: u ?? "irn" }, responderPublicKey: $ }, throwOnFailedPublish: !0 }).catch((K) => {
          throw F == null || F.setError(ja.session_approve_publish_failure), K;
        }), F.addTrace(ms.session_approve_publish_success);
      } catch (K) {
        throw this.client.logger.error(K), this.client.session.delete(z, Or("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(z), K;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: F.eventId }), await this.client.core.pairing.updateMetadata({ topic: A, metadata: I.metadata }), await this.client.proposal.delete(a, Or("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: A }), await this.setExpiry(z, En(Hc)), { topic: z, acknowledged: () => Promise.resolve(this.client.session.get(z)) };
    }, this.reject = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(r);
      } catch (o) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), o;
      }
      const { id: n, reason: i } = r;
      let s;
      try {
        s = this.client.proposal.get(n).pairingTopic;
      } catch (o) {
        throw this.client.logger.error(`reject() -> proposal.get(${n}) failed`), o;
      }
      s && (await this.sendError({ id: n, topic: s, error: i, rpcOpts: In.wc_sessionPropose.reject }), await this.client.proposal.delete(n, Or("USER_DISCONNECTED")));
    }, this.update = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(r);
      } catch (p) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), p;
      }
      const { topic: n, namespaces: i } = r, { done: s, resolve: o, reject: a } = Ha(), u = oa(), h = Qa().toString(), d = this.client.session.get(n).namespaces;
      return this.events.once(vr("session_update", u), ({ error: p }) => {
        p ? a(p) : o();
      }), await this.client.session.update(n, { namespaces: i }), await this.sendRequest({ topic: n, method: "wc_sessionUpdate", params: { namespaces: i }, throwOnFailedPublish: !0, clientRpcId: u, relayRpcId: h }).catch((p) => {
        this.client.logger.error(p), this.client.session.update(n, { namespaces: d }), a(p);
      }), { acknowledged: s };
    }, this.extend = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(r);
      } catch (u) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), u;
      }
      const { topic: n } = r, i = oa(), { done: s, resolve: o, reject: a } = Ha();
      return this.events.once(vr("session_extend", i), ({ error: u }) => {
        u ? a(u) : o();
      }), await this.setExpiry(n, En(Hc)), this.sendRequest({ topic: n, method: "wc_sessionExtend", params: {}, clientRpcId: i, throwOnFailedPublish: !0 }).catch((u) => {
        a(u);
      }), { acknowledged: s };
    }, this.request = async (r) => {
      this.isInitialized();
      try {
        await this.isValidRequest(r);
      } catch (I) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), I;
      }
      const { chainId: n, request: i, topic: s, expiry: o = In.wc_sessionRequest.req.ttl } = r, a = this.client.session.get(s);
      (a == null ? void 0 : a.transportType) === zr.relay && await this.confirmOnlineStateOrThrow();
      const u = oa(), h = Qa().toString(), { done: d, resolve: p, reject: x } = Ha(o, "Request expired. Please try again.");
      this.events.once(vr("session_request", u), ({ error: I, result: N }) => {
        I ? x(I) : p(N);
      });
      const A = this.getAppLinkIfEnabled(a.peer.metadata, a.transportType);
      return A ? (await this.sendRequest({ clientRpcId: u, relayRpcId: h, topic: s, method: "wc_sessionRequest", params: { request: vs(tn({}, i), { expiryTimestamp: En(o) }), chainId: n }, expiry: o, throwOnFailedPublish: !0, appLink: A }).catch((I) => x(I)), this.client.events.emit("session_request_sent", { topic: s, request: i, chainId: n, id: u }), await d()) : await Promise.all([new Promise(async (I) => {
        await this.sendRequest({ clientRpcId: u, relayRpcId: h, topic: s, method: "wc_sessionRequest", params: { request: vs(tn({}, i), { expiryTimestamp: En(o) }), chainId: n }, expiry: o, throwOnFailedPublish: !0 }).catch((N) => x(N)), this.client.events.emit("session_request_sent", { topic: s, request: i, chainId: n, id: u }), I();
      }), new Promise(async (I) => {
        var N;
        if (!((N = a.sessionConfig) != null && N.disableDeepLink)) {
          const L = await Nq(this.client.core.storage, R3);
          await Dq({ id: u, topic: s, wcDeepLink: L });
        }
        I();
      }), d()]).then((I) => I[2]);
    }, this.respond = async (r) => {
      this.isInitialized(), await this.isValidRespond(r);
      const { topic: n, response: i } = r, { id: s } = i, o = this.client.session.get(n);
      o.transportType === zr.relay && await this.confirmOnlineStateOrThrow();
      const a = this.getAppLinkIfEnabled(o.peer.metadata, o.transportType);
      Bs(i) ? await this.sendResult({ id: s, topic: n, result: i.result, throwOnFailedPublish: !0, appLink: a }) : Zi(i) && await this.sendError({ id: s, topic: n, error: i.error, appLink: a }), this.cleanupAfterResponse(r);
    }, this.ping = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(r);
      } catch (i) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), i;
      }
      const { topic: n } = r;
      if (this.client.session.keys.includes(n)) {
        const i = oa(), s = Qa().toString(), { done: o, resolve: a, reject: u } = Ha();
        this.events.once(vr("session_ping", i), ({ error: h }) => {
          h ? u(h) : a();
        }), await Promise.all([this.sendRequest({ topic: n, method: "wc_sessionPing", params: {}, throwOnFailedPublish: !0, clientRpcId: i, relayRpcId: s }), o()]);
      } else this.client.core.pairing.pairings.keys.includes(n) && await this.client.core.pairing.ping({ topic: n });
    }, this.emit = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(r);
      const { topic: n, event: i, chainId: s } = r, o = Qa().toString();
      await this.sendRequest({ topic: n, method: "wc_sessionEvent", params: { event: i, chainId: s }, throwOnFailedPublish: !0, relayRpcId: o });
    }, this.disconnect = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(r);
      const { topic: n } = r;
      if (this.client.session.keys.includes(n)) await this.sendRequest({ topic: n, method: "wc_sessionDelete", params: Or("USER_DISCONNECTED"), throwOnFailedPublish: !0 }), await this.deleteSession({ topic: n, emitEvent: !1 });
      else if (this.client.core.pairing.pairings.keys.includes(n)) await this.client.core.pairing.disconnect({ topic: n });
      else {
        const { message: i } = ft("MISMATCHED_TOPIC", `Session or pairing topic not found: ${n}`);
        throw new Error(i);
      }
    }, this.find = (r) => (this.isInitialized(), this.client.session.getAll().filter((n) => Nz(n, r))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (r, n) => {
      var i;
      this.isInitialized(), this.isValidAuthenticate(r);
      const s = n && this.client.core.linkModeSupportedApps.includes(n) && ((i = this.client.metadata.redirect) == null ? void 0 : i.linkMode), o = s ? zr.link_mode : zr.relay;
      o === zr.relay && await this.confirmOnlineStateOrThrow();
      const { chains: a, statement: u = "", uri: h, domain: d, nonce: p, type: x, exp: A, nbf: I, methods: N = [], expiry: L } = r, F = [...r.resources || []], { topic: $, uri: W } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: o });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: $, uri: W } });
      const z = await this.client.core.crypto.generateKeyPair(), V = Cd(z);
      if (await Promise.all([this.client.auth.authKeys.set(Td, { responseTopic: V, publicKey: z }), this.client.auth.pairingTopics.set(V, { topic: V, pairingTopic: $ })]), await this.client.core.relayer.subscribe(V, { transportType: o }), this.client.logger.info(`sending request to new pairing topic: ${$}`), N.length > 0) {
        const { namespace: _ } = fu(a[0]);
        let E = tz(_, "request", N);
        Id(F) && (E = nz(E, F.pop())), F.push(E);
      }
      const te = L && L > In.wc_sessionAuthenticate.req.ttl ? L : In.wc_sessionAuthenticate.req.ttl, R = { authPayload: { type: x ?? "caip122", chains: a, statement: u, aud: h, domain: d, version: "1", nonce: p, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: A, nbf: I, resources: F }, requester: { publicKey: z, metadata: this.client.metadata }, expiryTimestamp: En(te) }, K = { eip155: { chains: a, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...N])], events: ["chainChanged", "accountsChanged"] } }, pe = { requiredNamespaces: {}, optionalNamespaces: K, relays: [{ protocol: "irn" }], pairingTopic: $, proposer: { publicKey: z, metadata: this.client.metadata }, expiryTimestamp: En(In.wc_sessionPropose.req.ttl) }, { done: _e, resolve: Y, reject: S } = Ha(te, "Request expired"), m = async ({ error: _, session: E }) => {
        if (this.events.off(vr("session_request", g), f), _) S(_);
        else if (E) {
          E.self.publicKey = z, await this.client.session.set(E.topic, E), await this.setExpiry(E.topic, E.expiry), $ && await this.client.core.pairing.updateMetadata({ topic: $, metadata: E.peer.metadata });
          const v = this.client.session.get(E.topic);
          await this.deleteProposal(b), Y({ session: v });
        }
      }, f = async (_) => {
        var E, v, M;
        if (await this.deletePendingAuthRequest(g, { message: "fulfilled", code: 0 }), _.error) {
          const J = Or("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return _.error.code === J.code ? void 0 : (this.events.off(vr("session_connect"), m), S(_.error.message));
        }
        await this.deleteProposal(b), this.events.off(vr("session_connect"), m);
        const { cacaos: P, responder: B } = _.result, ue = [], D = [];
        for (const J of P) {
          await Ux({ cacao: J, projectId: this.client.core.projectId }) || (this.client.logger.error(J, "Signature verification failed"), S(Or("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: Q } = J, T = Id(Q.resources), X = [M1(Q.iss)], re = c0(Q.iss);
          if (T) {
            const de = jx(T), ie = qx(T);
            ue.push(...de), X.push(...ie);
          }
          for (const de of X) D.push(`${de}:${re}`);
        }
        const oe = await this.client.core.crypto.generateSharedKey(z, B.publicKey);
        let Z;
        ue.length > 0 && (Z = { topic: oe, acknowledged: !0, self: { publicKey: z, metadata: this.client.metadata }, peer: B, controller: B.publicKey, expiry: En(Hc), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: $, namespaces: Xx([...new Set(ue)], [...new Set(D)]), transportType: o }, await this.client.core.relayer.subscribe(oe, { transportType: o }), await this.client.session.set(oe, Z), $ && await this.client.core.pairing.updateMetadata({ topic: $, metadata: B.metadata }), Z = this.client.session.get(oe)), (E = this.client.metadata.redirect) != null && E.linkMode && (v = B.metadata.redirect) != null && v.linkMode && (M = B.metadata.redirect) != null && M.universal && n && (this.client.core.addLinkModeSupportedApp(B.metadata.redirect.universal), this.client.session.update(oe, { transportType: zr.link_mode })), Y({ auths: P, session: Z });
      }, g = oa(), b = oa();
      this.events.once(vr("session_connect"), m), this.events.once(vr("session_request", g), f);
      let w;
      try {
        if (s) {
          const _ = fa("wc_sessionAuthenticate", R, g);
          this.client.core.history.set($, _);
          const E = await this.client.core.crypto.encode("", _, { type: eh, encoding: Ef });
          w = ud(n, $, E);
        } else await Promise.all([this.sendRequest({ topic: $, method: "wc_sessionAuthenticate", params: R, expiry: r.expiry, throwOnFailedPublish: !0, clientRpcId: g }), this.sendRequest({ topic: $, method: "wc_sessionPropose", params: pe, expiry: In.wc_sessionPropose.req.ttl, throwOnFailedPublish: !0, clientRpcId: b })]);
      } catch (_) {
        throw this.events.off(vr("session_connect"), m), this.events.off(vr("session_request", g), f), _;
      }
      return await this.setProposal(b, tn({ id: b }, pe)), await this.setAuthRequest(g, { request: vs(tn({}, R), { verifyContext: {} }), pairingTopic: $, transportType: o }), { uri: w ?? W, response: _e };
    }, this.approveSessionAuthenticate = async (r) => {
      const { id: n, auths: i } = r, s = this.client.core.eventClient.createEvent({ properties: { topic: n.toString(), trace: [qa.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (L) {
        throw s.setError(Pf.no_internet_connection), L;
      }
      const o = this.getPendingAuthRequest(n);
      if (!o) throw s.setError(Pf.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${n}`);
      const a = o.transportType || zr.relay;
      a === zr.relay && await this.confirmOnlineStateOrThrow();
      const u = o.requester.publicKey, h = await this.client.core.crypto.generateKeyPair(), d = Cd(u), p = { type: Mo, receiverPublicKey: u, senderPublicKey: h }, x = [], A = [];
      for (const L of i) {
        if (!await Ux({ cacao: L, projectId: this.client.core.projectId })) {
          s.setError(Pf.invalid_cacao);
          const V = Or("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: n, topic: d, error: V, encodeOpts: p }), new Error(V.message);
        }
        s.addTrace(qa.cacaos_verified);
        const { p: F } = L, $ = Id(F.resources), W = [M1(F.iss)], z = c0(F.iss);
        if ($) {
          const V = jx($), te = qx($);
          x.push(...V), W.push(...te);
        }
        for (const V of W) A.push(`${V}:${z}`);
      }
      const I = await this.client.core.crypto.generateSharedKey(h, u);
      s.addTrace(qa.create_authenticated_session_topic);
      let N;
      if ((x == null ? void 0 : x.length) > 0) {
        N = { topic: I, acknowledged: !0, self: { publicKey: h, metadata: this.client.metadata }, peer: { publicKey: u, metadata: o.requester.metadata }, controller: u, expiry: En(Hc), authentication: i, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: o.pairingTopic, namespaces: Xx([...new Set(x)], [...new Set(A)]), transportType: a }, s.addTrace(qa.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(I, { transportType: a });
        } catch (L) {
          throw s.setError(Pf.subscribe_authenticated_session_topic_failure), L;
        }
        s.addTrace(qa.subscribe_authenticated_session_topic_success), await this.client.session.set(I, N), s.addTrace(qa.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: o.pairingTopic, metadata: o.requester.metadata });
      }
      s.addTrace(qa.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: d, id: n, result: { cacaos: i, responder: { publicKey: h, metadata: this.client.metadata } }, encodeOpts: p, throwOnFailedPublish: !0, appLink: this.getAppLinkIfEnabled(o.requester.metadata, a) });
      } catch (L) {
        throw s.setError(Pf.authenticated_session_approve_publish_failure), L;
      }
      return await this.client.auth.requests.delete(n, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: o.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: s.eventId }), { session: N };
    }, this.rejectSessionAuthenticate = async (r) => {
      this.isInitialized();
      const { id: n, reason: i } = r, s = this.getPendingAuthRequest(n);
      if (!s) throw new Error(`Could not find pending auth request with id ${n}`);
      s.transportType === zr.relay && await this.confirmOnlineStateOrThrow();
      const o = s.requester.publicKey, a = await this.client.core.crypto.generateKeyPair(), u = Cd(o), h = { type: Mo, receiverPublicKey: o, senderPublicKey: a };
      await this.sendError({ id: n, topic: u, error: i, encodeOpts: h, rpcOpts: In.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(s.requester.metadata, s.transportType) }), await this.client.auth.requests.delete(n, { message: "rejected", code: 0 }), await this.client.proposal.delete(n, Or("USER_DISCONNECTED"));
    }, this.formatAuthMessage = (r) => {
      this.isInitialized();
      const { request: n, iss: i } = r;
      return B8(n, i);
    }, this.processRelayMessageCache = () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const r = this.relayMessageCache.shift();
          r && await this.onRelayMessage(r);
        } catch (r) {
          this.client.logger.error(r);
        }
      }, 50);
    }, this.cleanupDuplicatePairings = async (r) => {
      if (r.pairingTopic) try {
        const n = this.client.core.pairing.pairings.get(r.pairingTopic), i = this.client.core.pairing.pairings.getAll().filter((s) => {
          var o, a;
          return ((o = s.peerMetadata) == null ? void 0 : o.url) && ((a = s.peerMetadata) == null ? void 0 : a.url) === r.peer.metadata.url && s.topic && s.topic !== n.topic;
        });
        if (i.length === 0) return;
        this.client.logger.info(`Cleaning up ${i.length} duplicate pairing(s)`), await Promise.all(i.map((s) => this.client.core.pairing.disconnect({ topic: s.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (n) {
        this.client.logger.error(n);
      }
    }, this.deleteSession = async (r) => {
      var n;
      const { topic: i, expirerHasDeleted: s = !1, emitEvent: o = !0, id: a = 0 } = r, { self: u } = this.client.session.get(i);
      await this.client.core.relayer.unsubscribe(i), await this.client.session.delete(i, Or("USER_DISCONNECTED")), this.addToRecentlyDeleted(i, "session"), this.client.core.crypto.keychain.has(u.publicKey) && await this.client.core.crypto.deleteKeyPair(u.publicKey), this.client.core.crypto.keychain.has(i) && await this.client.core.crypto.deleteSymKey(i), s || this.client.core.expirer.del(i), this.client.core.storage.removeItem(R3).catch((h) => this.client.logger.warn(h)), this.getPendingSessionRequests().forEach((h) => {
        h.topic === i && this.deletePendingSessionRequest(h.id, Or("USER_DISCONNECTED"));
      }), i === ((n = this.sessionRequestQueue.queue[0]) == null ? void 0 : n.topic) && (this.sessionRequestQueue.state = Ns.idle), o && this.client.events.emit("session_delete", { id: a, topic: i });
    }, this.deleteProposal = async (r, n) => {
      if (n) try {
        const i = this.client.proposal.get(r), s = this.client.core.eventClient.getEvent({ topic: i.pairingTopic });
        s == null || s.setError(ja.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(r, Or("USER_DISCONNECTED")), n ? Promise.resolve() : this.client.core.expirer.del(r)]), this.addToRecentlyDeleted(r, "proposal");
    }, this.deletePendingSessionRequest = async (r, n, i = !1) => {
      await Promise.all([this.client.pendingRequest.delete(r, n), i ? Promise.resolve() : this.client.core.expirer.del(r)]), this.addToRecentlyDeleted(r, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((s) => s.id !== r), i && (this.sessionRequestQueue.state = Ns.idle, this.client.events.emit("session_request_expire", { id: r }));
    }, this.deletePendingAuthRequest = async (r, n, i = !1) => {
      await Promise.all([this.client.auth.requests.delete(r, n), i ? Promise.resolve() : this.client.core.expirer.del(r)]);
    }, this.setExpiry = async (r, n) => {
      this.client.session.keys.includes(r) && (this.client.core.expirer.set(r, n), await this.client.session.update(r, { expiry: n }));
    }, this.setProposal = async (r, n) => {
      this.client.core.expirer.set(r, En(In.wc_sessionPropose.req.ttl)), await this.client.proposal.set(r, n);
    }, this.setAuthRequest = async (r, n) => {
      const { request: i, pairingTopic: s, transportType: o = zr.relay } = n;
      this.client.core.expirer.set(r, i.expiryTimestamp), await this.client.auth.requests.set(r, { authPayload: i.authPayload, requester: i.requester, expiryTimestamp: i.expiryTimestamp, id: r, pairingTopic: s, verifyContext: i.verifyContext, transportType: o });
    }, this.setPendingSessionRequest = async (r) => {
      const { id: n, topic: i, params: s, verifyContext: o } = r, a = s.request.expiryTimestamp || En(In.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(n, a), await this.client.pendingRequest.set(n, { id: n, topic: i, params: s, verifyContext: o });
    }, this.sendRequest = async (r) => {
      const { topic: n, method: i, params: s, expiry: o, relayRpcId: a, clientRpcId: u, throwOnFailedPublish: h, appLink: d } = r, p = fa(i, s, u);
      let x;
      const A = !!d;
      try {
        const L = A ? Ef : ua;
        x = await this.client.core.crypto.encode(n, p, { encoding: L });
      } catch (L) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${n} failed`), L;
      }
      let I;
      if (bV.includes(i)) {
        const L = yo(JSON.stringify(p)), F = yo(x);
        I = await this.client.core.verify.register({ id: F, decryptedId: L });
      }
      const N = In[i].req;
      if (N.attestation = I, o && (N.ttl = o), a && (N.id = a), this.client.core.history.set(n, p), A) {
        const L = ud(d, n, x);
        await global.Linking.openURL(L, this.client.name);
      } else {
        const L = In[i].req;
        o && (L.ttl = o), a && (L.id = a), h ? (L.internal = vs(tn({}, L.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(n, x, L)) : this.client.core.relayer.publish(n, x, L).catch((F) => this.client.logger.error(F));
      }
      return p.id;
    }, this.sendResult = async (r) => {
      const { id: n, topic: i, result: s, throwOnFailedPublish: o, encodeOpts: a, appLink: u } = r, h = rp(n, s);
      let d;
      const p = u && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const A = p ? Ef : ua;
        d = await this.client.core.crypto.encode(i, h, vs(tn({}, a || {}), { encoding: A }));
      } catch (A) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${i} failed`), A;
      }
      let x;
      try {
        x = await this.client.core.history.get(i, n);
      } catch (A) {
        throw this.client.logger.error(`sendResult() -> history.get(${i}, ${n}) failed`), A;
      }
      if (p) {
        const A = ud(u, i, d);
        await global.Linking.openURL(A, this.client.name);
      } else {
        const A = In[x.request.method].res;
        o ? (A.internal = vs(tn({}, A.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(i, d, A)) : this.client.core.relayer.publish(i, d, A).catch((I) => this.client.logger.error(I));
      }
      await this.client.core.history.resolve(h);
    }, this.sendError = async (r) => {
      const { id: n, topic: i, error: s, encodeOpts: o, rpcOpts: a, appLink: u } = r, h = np(n, s);
      let d;
      const p = u && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const A = p ? Ef : ua;
        d = await this.client.core.crypto.encode(i, h, vs(tn({}, o || {}), { encoding: A }));
      } catch (A) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${i} failed`), A;
      }
      let x;
      try {
        x = await this.client.core.history.get(i, n);
      } catch (A) {
        throw this.client.logger.error(`sendError() -> history.get(${i}, ${n}) failed`), A;
      }
      if (p) {
        const A = ud(u, i, d);
        await global.Linking.openURL(A, this.client.name);
      } else {
        const A = a || In[x.request.method].res;
        this.client.core.relayer.publish(i, d, A);
      }
      await this.client.core.history.resolve(h);
    }, this.cleanup = async () => {
      const r = [], n = [];
      this.client.session.getAll().forEach((i) => {
        let s = !1;
        sa(i.expiry) && (s = !0), this.client.core.crypto.keychain.has(i.topic) || (s = !0), s && r.push(i.topic);
      }), this.client.proposal.getAll().forEach((i) => {
        sa(i.expiryTimestamp) && n.push(i.id);
      }), await Promise.all([...r.map((i) => this.deleteSession({ topic: i })), ...n.map((i) => this.deleteProposal(i))]);
    }, this.onRelayEventRequest = async (r) => {
      this.requestQueue.queue.push(r), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === Ns.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = Ns.active;
        const r = this.requestQueue.queue.shift();
        if (r) try {
          await this.processRequest(r);
        } catch (n) {
          this.client.logger.warn(n);
        }
      }
      this.requestQueue.state = Ns.idle;
    }, this.processRequest = async (r) => {
      const { topic: n, payload: i, attestation: s, transportType: o, encryptedId: a } = r, u = i.method;
      if (!this.shouldIgnorePairingRequest({ topic: n, requestMethod: u })) switch (u) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: n, payload: i, attestation: s, encryptedId: a });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(n, i);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(n, i);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(n, i);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(n, i);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(n, i);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: n, payload: i, attestation: s, encryptedId: a, transportType: o });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(n, i);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: n, payload: i, attestation: s, encryptedId: a, transportType: o });
        default:
          return this.client.logger.info(`Unsupported request method ${u}`);
      }
    }, this.onRelayEventResponse = async (r) => {
      const { topic: n, payload: i, transportType: s } = r, o = (await this.client.core.history.get(n, i.id)).request.method;
      switch (o) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(n, i, s);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(n, i);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(n, i);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(n, i);
        case "wc_sessionPing":
          return this.onSessionPingResponse(n, i);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(n, i);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(n, i);
        default:
          return this.client.logger.info(`Unsupported response method ${o}`);
      }
    }, this.onRelayEventUnknownPayload = (r) => {
      const { topic: n } = r, { message: i } = ft("MISSING_OR_INVALID", `Decoded payload on topic ${n} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(i);
    }, this.shouldIgnorePairingRequest = (r) => {
      const { topic: n, requestMethod: i } = r, s = this.expectedPairingMethodMap.get(n);
      return !s || s.includes(i) ? !1 : !!(s.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }, this.onSessionProposeRequest = async (r) => {
      const { topic: n, payload: i, attestation: s, encryptedId: o } = r, { params: a, id: u } = i;
      try {
        const h = this.client.core.eventClient.getEvent({ topic: n });
        this.isValidConnect(tn({}, i.params));
        const d = a.expiryTimestamp || En(In.wc_sessionPropose.req.ttl), p = tn({ id: u, pairingTopic: n, expiryTimestamp: d }, a);
        await this.setProposal(u, p);
        const x = await this.getVerifyContext({ attestationId: s, hash: yo(JSON.stringify(i)), encryptedId: o, metadata: p.proposer.metadata });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), h == null || h.setError(bo.proposal_listener_not_found)), h == null || h.addTrace($s.emit_session_proposal), this.client.events.emit("session_proposal", { id: u, params: p, verifyContext: x });
      } catch (h) {
        await this.sendError({ id: u, topic: n, error: h, rpcOpts: In.wc_sessionPropose.autoReject }), this.client.logger.error(h);
      }
    }, this.onSessionProposeResponse = async (r, n, i) => {
      const { id: s } = n;
      if (Bs(n)) {
        const { result: o } = n;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: o });
        const a = this.client.proposal.get(s);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: a });
        const u = a.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: u });
        const h = o.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: h });
        const d = await this.client.core.crypto.generateSharedKey(u, h);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: d });
        const p = await this.client.core.relayer.subscribe(d, { transportType: i });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p }), await this.client.core.pairing.activate({ topic: r });
      } else if (Zi(n)) {
        await this.client.proposal.delete(s, Or("USER_DISCONNECTED"));
        const o = vr("session_connect");
        if (this.events.listenerCount(o) === 0) throw new Error(`emitting ${o} without any listeners, 954`);
        this.events.emit(vr("session_connect"), { error: n.error });
      }
    }, this.onSessionSettleRequest = async (r, n) => {
      const { id: i, params: s } = n;
      try {
        this.isValidSessionSettleRequest(s);
        const { relay: o, controller: a, expiry: u, namespaces: h, sessionProperties: d, sessionConfig: p } = n.params, x = vs(tn(tn({ topic: r, relay: o, expiry: u, namespaces: h, acknowledged: !0, pairingTopic: "", requiredNamespaces: {}, optionalNamespaces: {}, controller: a.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: a.publicKey, metadata: a.metadata } }, d && { sessionProperties: d }), p && { sessionConfig: p }), { transportType: zr.relay }), A = vr("session_connect");
        if (this.events.listenerCount(A) === 0) throw new Error(`emitting ${A} without any listeners 997`);
        this.events.emit(vr("session_connect"), { session: x }), await this.sendResult({ id: n.id, topic: r, result: !0, throwOnFailedPublish: !0 });
      } catch (o) {
        await this.sendError({ id: i, topic: r, error: o }), this.client.logger.error(o);
      }
    }, this.onSessionSettleResponse = async (r, n) => {
      const { id: i } = n;
      Bs(n) ? (await this.client.session.update(r, { acknowledged: !0 }), this.events.emit(vr("session_approve", i), {})) : Zi(n) && (await this.client.session.delete(r, Or("USER_DISCONNECTED")), this.events.emit(vr("session_approve", i), { error: n.error }));
    }, this.onSessionUpdateRequest = async (r, n) => {
      const { params: i, id: s } = n;
      try {
        const o = `${r}_session_update`, a = Sf.get(o);
        if (a && this.isRequestOutOfSync(a, s)) {
          this.client.logger.info(`Discarding out of sync request - ${s}`), this.sendError({ id: s, topic: r, error: Or("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(tn({ topic: r }, i));
        try {
          Sf.set(o, s), await this.client.session.update(r, { namespaces: i.namespaces }), await this.sendResult({ id: s, topic: r, result: !0, throwOnFailedPublish: !0 });
        } catch (u) {
          throw Sf.delete(o), u;
        }
        this.client.events.emit("session_update", { id: s, topic: r, params: i });
      } catch (o) {
        await this.sendError({ id: s, topic: r, error: o }), this.client.logger.error(o);
      }
    }, this.isRequestOutOfSync = (r, n) => parseInt(n.toString().slice(0, -3)) <= parseInt(r.toString().slice(0, -3)), this.onSessionUpdateResponse = (r, n) => {
      const { id: i } = n, s = vr("session_update", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      Bs(n) ? this.events.emit(vr("session_update", i), {}) : Zi(n) && this.events.emit(vr("session_update", i), { error: n.error });
    }, this.onSessionExtendRequest = async (r, n) => {
      const { id: i } = n;
      try {
        this.isValidExtend({ topic: r }), await this.setExpiry(r, En(Hc)), await this.sendResult({ id: i, topic: r, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_extend", { id: i, topic: r });
      } catch (s) {
        await this.sendError({ id: i, topic: r, error: s }), this.client.logger.error(s);
      }
    }, this.onSessionExtendResponse = (r, n) => {
      const { id: i } = n, s = vr("session_extend", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      Bs(n) ? this.events.emit(vr("session_extend", i), {}) : Zi(n) && this.events.emit(vr("session_extend", i), { error: n.error });
    }, this.onSessionPingRequest = async (r, n) => {
      const { id: i } = n;
      try {
        this.isValidPing({ topic: r }), await this.sendResult({ id: i, topic: r, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_ping", { id: i, topic: r });
      } catch (s) {
        await this.sendError({ id: i, topic: r, error: s }), this.client.logger.error(s);
      }
    }, this.onSessionPingResponse = (r, n) => {
      const { id: i } = n, s = vr("session_ping", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      setTimeout(() => {
        Bs(n) ? this.events.emit(vr("session_ping", i), {}) : Zi(n) && this.events.emit(vr("session_ping", i), { error: n.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (r, n) => {
      const { id: i } = n;
      try {
        this.isValidDisconnect({ topic: r, reason: n.params }), Promise.all([new Promise((s) => {
          this.client.core.relayer.once(ii.publish, async () => {
            s(await this.deleteSession({ topic: r, id: i }));
          });
        }), this.sendResult({ id: i, topic: r, result: !0, throwOnFailedPublish: !0 }), this.cleanupPendingSentRequestsForTopic({ topic: r, error: Or("USER_DISCONNECTED") })]).catch((s) => this.client.logger.error(s));
      } catch (s) {
        this.client.logger.error(s);
      }
    }, this.onSessionRequest = async (r) => {
      var n, i, s;
      const { topic: o, payload: a, attestation: u, encryptedId: h, transportType: d } = r, { id: p, params: x } = a;
      try {
        await this.isValidRequest(tn({ topic: o }, x));
        const A = this.client.session.get(o), I = await this.getVerifyContext({ attestationId: u, hash: yo(JSON.stringify(fa("wc_sessionRequest", x, p))), encryptedId: h, metadata: A.peer.metadata, transportType: d }), N = { id: p, topic: o, params: x, verifyContext: I };
        await this.setPendingSessionRequest(N), d === zr.link_mode && (n = A.peer.metadata.redirect) != null && n.universal && this.client.core.addLinkModeSupportedApp((i = A.peer.metadata.redirect) == null ? void 0 : i.universal), (s = this.client.signConfig) != null && s.disableRequestQueue ? this.emitSessionRequest(N) : (this.addSessionRequestToSessionRequestQueue(N), this.processSessionRequestQueue());
      } catch (A) {
        await this.sendError({ id: p, topic: o, error: A }), this.client.logger.error(A);
      }
    }, this.onSessionRequestResponse = (r, n) => {
      const { id: i } = n, s = vr("session_request", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      Bs(n) ? this.events.emit(vr("session_request", i), { result: n.result }) : Zi(n) && this.events.emit(vr("session_request", i), { error: n.error });
    }, this.onSessionEventRequest = async (r, n) => {
      const { id: i, params: s } = n;
      try {
        const o = `${r}_session_event_${s.event.name}`, a = Sf.get(o);
        if (a && this.isRequestOutOfSync(a, i)) {
          this.client.logger.info(`Discarding out of sync request - ${i}`);
          return;
        }
        this.isValidEmit(tn({ topic: r }, s)), this.client.events.emit("session_event", { id: i, topic: r, params: s }), Sf.set(o, i);
      } catch (o) {
        await this.sendError({ id: i, topic: r, error: o }), this.client.logger.error(o);
      }
    }, this.onSessionAuthenticateResponse = (r, n) => {
      const { id: i } = n;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: r, payload: n }), Bs(n) ? this.events.emit(vr("session_request", i), { result: n.result }) : Zi(n) && this.events.emit(vr("session_request", i), { error: n.error });
    }, this.onSessionAuthenticateRequest = async (r) => {
      var n;
      const { topic: i, payload: s, attestation: o, encryptedId: a, transportType: u } = r;
      try {
        const { requester: h, authPayload: d, expiryTimestamp: p } = s.params, x = await this.getVerifyContext({ attestationId: o, hash: yo(JSON.stringify(s)), encryptedId: a, metadata: h.metadata, transportType: u }), A = { requester: h, pairingTopic: i, id: s.id, authPayload: d, verifyContext: x, expiryTimestamp: p };
        await this.setAuthRequest(s.id, { request: A, pairingTopic: i, transportType: u }), u === zr.link_mode && (n = h.metadata.redirect) != null && n.universal && this.client.core.addLinkModeSupportedApp(h.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: i, params: s.params, id: s.id, verifyContext: x });
      } catch (h) {
        this.client.logger.error(h);
        const d = s.params.requester.publicKey, p = await this.client.core.crypto.generateKeyPair(), x = this.getAppLinkIfEnabled(s.params.requester.metadata, u), A = { type: Mo, receiverPublicKey: d, senderPublicKey: p };
        await this.sendError({ id: s.id, topic: i, error: h, encodeOpts: A, rpcOpts: In.wc_sessionAuthenticate.autoReject, appLink: x });
      }
    }, this.addSessionRequestToSessionRequestQueue = (r) => {
      this.sessionRequestQueue.queue.push(r);
    }, this.cleanupAfterResponse = (r) => {
      this.deletePendingSessionRequest(r.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = Ns.idle, this.processSessionRequestQueue();
      }, mt.toMiliseconds(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: r, error: n }) => {
      const i = this.client.core.history.pending;
      i.length > 0 && i.filter((s) => s.topic === r && s.request.method === "wc_sessionRequest").forEach((s) => {
        const o = s.request.id, a = vr("session_request", o);
        if (this.events.listenerCount(a) === 0) throw new Error(`emitting ${a} without any listeners`);
        this.events.emit(vr("session_request", s.request.id), { error: n });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === Ns.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const r = this.sessionRequestQueue.queue[0];
      if (!r) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = Ns.active, this.emitSessionRequest(r);
      } catch (n) {
        this.client.logger.error(n);
      }
    }, this.emitSessionRequest = (r) => {
      this.client.events.emit("session_request", r);
    }, this.onPairingCreated = (r) => {
      if (r.methods && this.expectedPairingMethodMap.set(r.topic, r.methods), r.active) return;
      const n = this.client.proposal.getAll().find((i) => i.pairingTopic === r.topic);
      n && this.onSessionProposeRequest({ topic: r.topic, payload: fa("wc_sessionPropose", { requiredNamespaces: n.requiredNamespaces, optionalNamespaces: n.optionalNamespaces, relays: n.relays, proposer: n.proposer, sessionProperties: n.sessionProperties }, n.id) });
    }, this.isValidConnect = async (r) => {
      if (!pi(r)) {
        const { message: u } = ft("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(r)}`);
        throw new Error(u);
      }
      const { pairingTopic: n, requiredNamespaces: i, optionalNamespaces: s, sessionProperties: o, relays: a } = r;
      if (gi(n) || await this.isValidPairingTopic(n), !Kz(a)) {
        const { message: u } = ft("MISSING_OR_INVALID", `connect() relays: ${a}`);
        throw new Error(u);
      }
      !gi(i) && _l(i) !== 0 && this.validateNamespaces(i, "requiredNamespaces"), !gi(s) && _l(s) !== 0 && this.validateNamespaces(s, "optionalNamespaces"), gi(o) || this.validateSessionProps(o, "sessionProperties");
    }, this.validateNamespaces = (r, n) => {
      const i = Wz(r, "connect()", n);
      if (i) throw new Error(i.message);
    }, this.isValidApprove = async (r) => {
      if (!pi(r)) throw new Error(ft("MISSING_OR_INVALID", `approve() params: ${r}`).message);
      const { id: n, namespaces: i, relayProtocol: s, sessionProperties: o } = r;
      this.checkRecentlyDeleted(n), await this.isValidProposalId(n);
      const a = this.client.proposal.get(n), u = hm(i, "approve()");
      if (u) throw new Error(u.message);
      const h = e3(a.requiredNamespaces, i, "approve()");
      if (h) throw new Error(h.message);
      if (!dn(s, !0)) {
        const { message: d } = ft("MISSING_OR_INVALID", `approve() relayProtocol: ${s}`);
        throw new Error(d);
      }
      gi(o) || this.validateSessionProps(o, "sessionProperties");
    }, this.isValidReject = async (r) => {
      if (!pi(r)) {
        const { message: s } = ft("MISSING_OR_INVALID", `reject() params: ${r}`);
        throw new Error(s);
      }
      const { id: n, reason: i } = r;
      if (this.checkRecentlyDeleted(n), await this.isValidProposalId(n), !Gz(i)) {
        const { message: s } = ft("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(i)}`);
        throw new Error(s);
      }
    }, this.isValidSessionSettleRequest = (r) => {
      if (!pi(r)) {
        const { message: h } = ft("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${r}`);
        throw new Error(h);
      }
      const { relay: n, controller: i, namespaces: s, expiry: o } = r;
      if (!K8(n)) {
        const { message: h } = ft("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(h);
      }
      const a = Fz(i, "onSessionSettleRequest()");
      if (a) throw new Error(a.message);
      const u = hm(s, "onSessionSettleRequest()");
      if (u) throw new Error(u.message);
      if (sa(o)) {
        const { message: h } = ft("EXPIRED", "onSessionSettleRequest()");
        throw new Error(h);
      }
    }, this.isValidUpdate = async (r) => {
      if (!pi(r)) {
        const { message: u } = ft("MISSING_OR_INVALID", `update() params: ${r}`);
        throw new Error(u);
      }
      const { topic: n, namespaces: i } = r;
      this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
      const s = this.client.session.get(n), o = hm(i, "update()");
      if (o) throw new Error(o.message);
      const a = e3(s.requiredNamespaces, i, "update()");
      if (a) throw new Error(a.message);
    }, this.isValidExtend = async (r) => {
      if (!pi(r)) {
        const { message: i } = ft("MISSING_OR_INVALID", `extend() params: ${r}`);
        throw new Error(i);
      }
      const { topic: n } = r;
      this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
    }, this.isValidRequest = async (r) => {
      if (!pi(r)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() params: ${r}`);
        throw new Error(u);
      }
      const { topic: n, request: i, chainId: s, expiry: o } = r;
      this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
      const { namespaces: a } = this.client.session.get(n);
      if (!Qx(a, s)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() chainId: ${s}`);
        throw new Error(u);
      }
      if (!Yz(i)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() ${JSON.stringify(i)}`);
        throw new Error(u);
      }
      if (!Zz(a, s, i.method)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() method: ${i.method}`);
        throw new Error(u);
      }
      if (o && !rH(o, vm)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() expiry: ${o}. Expiry must be a number (in seconds) between ${vm.min} and ${vm.max}`);
        throw new Error(u);
      }
    }, this.isValidRespond = async (r) => {
      var n;
      if (!pi(r)) {
        const { message: o } = ft("MISSING_OR_INVALID", `respond() params: ${r}`);
        throw new Error(o);
      }
      const { topic: i, response: s } = r;
      try {
        await this.isValidSessionTopic(i);
      } catch (o) {
        throw (n = r == null ? void 0 : r.response) != null && n.id && this.cleanupAfterResponse(r), o;
      }
      if (!Jz(s)) {
        const { message: o } = ft("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(s)}`);
        throw new Error(o);
      }
    }, this.isValidPing = async (r) => {
      if (!pi(r)) {
        const { message: i } = ft("MISSING_OR_INVALID", `ping() params: ${r}`);
        throw new Error(i);
      }
      const { topic: n } = r;
      await this.isValidSessionOrPairingTopic(n);
    }, this.isValidEmit = async (r) => {
      if (!pi(r)) {
        const { message: a } = ft("MISSING_OR_INVALID", `emit() params: ${r}`);
        throw new Error(a);
      }
      const { topic: n, event: i, chainId: s } = r;
      await this.isValidSessionTopic(n);
      const { namespaces: o } = this.client.session.get(n);
      if (!Qx(o, s)) {
        const { message: a } = ft("MISSING_OR_INVALID", `emit() chainId: ${s}`);
        throw new Error(a);
      }
      if (!Xz(i)) {
        const { message: a } = ft("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
        throw new Error(a);
      }
      if (!Qz(o, s, i.name)) {
        const { message: a } = ft("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
        throw new Error(a);
      }
    }, this.isValidDisconnect = async (r) => {
      if (!pi(r)) {
        const { message: i } = ft("MISSING_OR_INVALID", `disconnect() params: ${r}`);
        throw new Error(i);
      }
      const { topic: n } = r;
      await this.isValidSessionOrPairingTopic(n);
    }, this.isValidAuthenticate = (r) => {
      const { chains: n, uri: i, domain: s, nonce: o } = r;
      if (!Array.isArray(n) || n.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!dn(i, !1)) throw new Error("uri is required parameter");
      if (!dn(s, !1)) throw new Error("domain is required parameter");
      if (!dn(o, !1)) throw new Error("nonce is required parameter");
      if ([...new Set(n.map((u) => fu(u).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: a } = fu(n[0]);
      if (a !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }, this.getVerifyContext = async (r) => {
      const { attestationId: n, hash: i, encryptedId: s, metadata: o, transportType: a } = r, u = { verified: { verifyUrl: o.verifyUrl || qf, validation: "UNKNOWN", origin: o.url || "" } };
      try {
        if (a === zr.link_mode) {
          const d = this.getAppLinkIfEnabled(o, a);
          return u.verified.validation = d && new URL(d).origin === new URL(o.url).origin ? "VALID" : "INVALID", u;
        }
        const h = await this.client.core.verify.resolve({ attestationId: n, hash: i, encryptedId: s, verifyUrl: o.verifyUrl });
        h && (u.verified.origin = h.origin, u.verified.isScam = h.isScam, u.verified.validation = h.origin === new URL(o.url).origin ? "VALID" : "INVALID");
      } catch (h) {
        this.client.logger.warn(h);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(u)}`), u;
    }, this.validateSessionProps = (r, n) => {
      Object.values(r).forEach((i) => {
        if (!dn(i, !1)) {
          const { message: s } = ft("MISSING_OR_INVALID", `${n} must be in Record<string, string> format. Received: ${JSON.stringify(i)}`);
          throw new Error(s);
        }
      });
    }, this.getPendingAuthRequest = (r) => {
      const n = this.client.auth.requests.get(r);
      return typeof n == "object" ? n : void 0;
    }, this.addToRecentlyDeleted = (r, n) => {
      if (this.recentlyDeletedMap.set(r, n), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let i = 0;
        const s = this.recentlyDeletedLimit / 2;
        for (const o of this.recentlyDeletedMap.keys()) {
          if (i++ >= s) break;
          this.recentlyDeletedMap.delete(o);
        }
      }
    }, this.checkRecentlyDeleted = (r) => {
      const n = this.recentlyDeletedMap.get(r);
      if (n) {
        const { message: i } = ft("MISSING_OR_INVALID", `Record was recently deleted - ${n}: ${r}`);
        throw new Error(i);
      }
    }, this.isLinkModeEnabled = (r, n) => {
      var i, s, o, a, u, h, d, p, x;
      return !r || n !== zr.link_mode ? !1 : ((s = (i = this.client.metadata) == null ? void 0 : i.redirect) == null ? void 0 : s.linkMode) === !0 && ((a = (o = this.client.metadata) == null ? void 0 : o.redirect) == null ? void 0 : a.universal) !== void 0 && ((h = (u = this.client.metadata) == null ? void 0 : u.redirect) == null ? void 0 : h.universal) !== "" && ((d = r == null ? void 0 : r.redirect) == null ? void 0 : d.universal) !== void 0 && ((p = r == null ? void 0 : r.redirect) == null ? void 0 : p.universal) !== "" && ((x = r == null ? void 0 : r.redirect) == null ? void 0 : x.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(r.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }, this.getAppLinkIfEnabled = (r, n) => {
      var i;
      return this.isLinkModeEnabled(r, n) ? (i = r == null ? void 0 : r.redirect) == null ? void 0 : i.universal : void 0;
    }, this.handleLinkModeMessage = ({ url: r }) => {
      if (!r || !r.includes("wc_ev") || !r.includes("topic")) return;
      const n = kx(r, "topic") || "", i = decodeURIComponent(kx(r, "wc_ev") || ""), s = this.client.session.keys.includes(n);
      s && this.client.session.update(n, { transportType: zr.link_mode }), this.client.core.dispatchEnvelope({ topic: n, message: i, sessionExists: s });
    }, this.registerLinkModeListeners = async () => {
      var r;
      if (nb() || Uu() && (r = this.client.metadata.redirect) != null && r.linkMode) {
        const n = global == null ? void 0 : global.Linking;
        if (typeof n < "u") {
          n.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const i = await n.getInitialURL();
          i && setTimeout(() => {
            this.handleLinkModeMessage({ url: i });
          }, 50);
        }
      }
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(ii.message, (e) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(e) : this.onRelayMessage(e);
    });
  }
  async onRelayMessage(e) {
    const { topic: r, message: n, attestation: i, transportType: s } = e, { publicKey: o } = this.client.auth.authKeys.keys.includes(Td) ? this.client.auth.authKeys.get(Td) : { publicKey: void 0 }, a = await this.client.core.crypto.decode(r, n, { receiverPublicKey: o, encoding: s === zr.link_mode ? Ef : ua });
    try {
      ub(a) ? (this.client.core.history.set(r, a), this.onRelayEventRequest({ topic: r, payload: a, attestation: i, transportType: s, encryptedId: yo(n) })) : ip(a) ? (await this.client.core.history.resolve(a), await this.onRelayEventResponse({ topic: r, payload: a, transportType: s }), this.client.core.history.delete(r, a.id)) : this.onRelayEventUnknownPayload({ topic: r, payload: a, transportType: s });
    } catch (u) {
      this.client.logger.error(u);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(Ji.expired, async (e) => {
      const { topic: r, id: n } = k8(e.target);
      if (n && this.client.pendingRequest.keys.includes(n)) return await this.deletePendingSessionRequest(n, ft("EXPIRED"), !0);
      if (n && this.client.auth.requests.keys.includes(n)) return await this.deletePendingAuthRequest(n, ft("EXPIRED"), !0);
      r ? this.client.session.keys.includes(r) && (await this.deleteSession({ topic: r, expirerHasDeleted: !0 }), this.client.events.emit("session_expire", { topic: r })) : n && (await this.deleteProposal(n, !0), this.client.events.emit("proposal_expire", { id: n }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(Ga.create, (e) => this.onPairingCreated(e)), this.client.core.pairing.events.on(Ga.delete, (e) => {
      this.addToRecentlyDeleted(e.topic, "pairing");
    });
  }
  isValidPairingTopic(e) {
    if (!dn(e, !1)) {
      const { message: r } = ft("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
      throw new Error(r);
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: r } = ft("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (sa(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: r } = ft("EXPIRED", `pairing topic: ${e}`);
      throw new Error(r);
    }
  }
  async isValidSessionTopic(e) {
    if (!dn(e, !1)) {
      const { message: r } = ft("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
      throw new Error(r);
    }
    if (this.checkRecentlyDeleted(e), !this.client.session.keys.includes(e)) {
      const { message: r } = ft("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (sa(this.client.session.get(e).expiry)) {
      await this.deleteSession({ topic: e });
      const { message: r } = ft("EXPIRED", `session topic: ${e}`);
      throw new Error(r);
    }
    if (!this.client.core.crypto.keychain.has(e)) {
      const { message: r } = ft("MISSING_OR_INVALID", `session topic does not exist in keychain: ${e}`);
      throw await this.deleteSession({ topic: e }), new Error(r);
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if (this.checkRecentlyDeleted(e), this.client.session.keys.includes(e)) await this.isValidSessionTopic(e);
    else if (this.client.core.pairing.pairings.keys.includes(e)) this.isValidPairingTopic(e);
    else if (dn(e, !1)) {
      const { message: r } = ft("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
      throw new Error(r);
    } else {
      const { message: r } = ft("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
      throw new Error(r);
    }
  }
  async isValidProposalId(e) {
    if (!Vz(e)) {
      const { message: r } = ft("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
      throw new Error(r);
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: r } = ft("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (sa(this.client.proposal.get(e).expiryTimestamp)) {
      await this.deleteProposal(e);
      const { message: r } = ft("EXPIRED", `proposal id: ${e}`);
      throw new Error(r);
    }
  }
}
class TV extends yc {
  constructor(e, r) {
    super(e, r, pV, lb), this.core = e, this.logger = r;
  }
}
let RV = class extends yc {
  constructor(e, r) {
    super(e, r, gV, lb), this.core = e, this.logger = r;
  }
};
class DV extends yc {
  constructor(e, r) {
    super(e, r, vV, lb, (n) => n.id), this.core = e, this.logger = r;
  }
}
class OV extends yc {
  constructor(e, r) {
    super(e, r, xV, op, () => Td), this.core = e, this.logger = r;
  }
}
class NV extends yc {
  constructor(e, r) {
    super(e, r, _V, op), this.core = e, this.logger = r;
  }
}
class LV extends yc {
  constructor(e, r) {
    super(e, r, EV, op, (n) => n.id), this.core = e, this.logger = r;
  }
}
class kV {
  constructor(e, r) {
    this.core = e, this.logger = r, this.authKeys = new OV(this.core, this.logger), this.pairingTopics = new NV(this.core, this.logger), this.requests = new LV(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
}
class hb extends Wk {
  constructor(e) {
    super(e), this.protocol = gE, this.version = mE, this.name = mm.name, this.events = new rs.EventEmitter(), this.on = (n, i) => this.events.on(n, i), this.once = (n, i) => this.events.once(n, i), this.off = (n, i) => this.events.off(n, i), this.removeListener = (n, i) => this.events.removeListener(n, i), this.removeAllListeners = (n) => this.events.removeAllListeners(n), this.connect = async (n) => {
      try {
        return await this.engine.connect(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.pair = async (n) => {
      try {
        return await this.engine.pair(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.approve = async (n) => {
      try {
        return await this.engine.approve(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.reject = async (n) => {
      try {
        return await this.engine.reject(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.update = async (n) => {
      try {
        return await this.engine.update(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.extend = async (n) => {
      try {
        return await this.engine.extend(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.request = async (n) => {
      try {
        return await this.engine.request(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.respond = async (n) => {
      try {
        return await this.engine.respond(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.ping = async (n) => {
      try {
        return await this.engine.ping(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.emit = async (n) => {
      try {
        return await this.engine.emit(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.disconnect = async (n) => {
      try {
        return await this.engine.disconnect(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.find = (n) => {
      try {
        return this.engine.find(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.authenticate = async (n, i) => {
      try {
        return await this.engine.authenticate(n, i);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.formatAuthMessage = (n) => {
      try {
        return this.engine.formatAuthMessage(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.approveSessionAuthenticate = async (n) => {
      try {
        return await this.engine.approveSessionAuthenticate(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.rejectSessionAuthenticate = async (n) => {
      try {
        return await this.engine.rejectSessionAuthenticate(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.name = (e == null ? void 0 : e.name) || mm.name, this.metadata = (e == null ? void 0 : e.metadata) || R8(), this.signConfig = e == null ? void 0 : e.signConfig;
    const r = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : jl($0({ level: (e == null ? void 0 : e.logger) || mm.logger }));
    this.core = (e == null ? void 0 : e.core) || new dV(e), this.logger = ai(r, this.name), this.session = new RV(this.core, this.logger), this.proposal = new TV(this.core, this.logger), this.pendingRequest = new DV(this.core, this.logger), this.engine = new CV(this), this.auth = new kV(this.core, this.logger);
  }
  static async init(e) {
    const r = new hb(e);
    return await r.initialize(), r;
  }
  get context() {
    return Si(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), this.engine.processRelayMessageCache();
    } catch (e) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(e.message), e;
    }
  }
}
var l0 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
l0.exports;
(function(t, e) {
  (function() {
    var r, n = "4.17.21", i = 200, s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", o = "Expected a function", a = "Invalid `variable` option passed into `_.template`", u = "__lodash_hash_undefined__", h = 500, d = "__lodash_placeholder__", p = 1, x = 2, A = 4, I = 1, N = 2, L = 1, F = 2, $ = 4, W = 8, z = 16, V = 32, te = 64, R = 128, K = 256, pe = 512, _e = 30, Y = "...", S = 800, m = 16, f = 1, g = 2, b = 3, w = 1 / 0, _ = 9007199254740991, E = 17976931348623157e292, v = NaN, M = 4294967295, P = M - 1, B = M >>> 1, ue = [
      ["ary", R],
      ["bind", L],
      ["bindKey", F],
      ["curry", W],
      ["curryRight", z],
      ["flip", pe],
      ["partial", V],
      ["partialRight", te],
      ["rearg", K]
    ], D = "[object Arguments]", oe = "[object Array]", Z = "[object AsyncFunction]", J = "[object Boolean]", Q = "[object Date]", T = "[object DOMException]", X = "[object Error]", re = "[object Function]", de = "[object GeneratorFunction]", ie = "[object Map]", ce = "[object Number]", me = "[object Null]", Pe = "[object Object]", De = "[object Promise]", Ce = "[object Proxy]", $e = "[object RegExp]", Me = "[object Set]", Ne = "[object String]", Ke = "[object Symbol]", Le = "[object Undefined]", qe = "[object WeakMap]", ze = "[object WeakSet]", Ee = "[object ArrayBuffer]", Ze = "[object DataView]", at = "[object Float32Array]", ke = "[object Float64Array]", Qe = "[object Int8Array]", tt = "[object Int16Array]", Ye = "[object Int32Array]", dt = "[object Uint8Array]", lt = "[object Uint8ClampedArray]", ct = "[object Uint16Array]", qt = "[object Uint32Array]", Yt = /\b__p \+= '';/g, Et = /\b(__p \+=) '' \+/g, Qt = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Jt = /&(?:amp|lt|gt|quot|#39);/g, Dt = /[&<>"']/g, kt = RegExp(Jt.source), Ct = RegExp(Dt.source), gt = /<%-([\s\S]+?)%>/g, Rt = /<%([\s\S]+?)%>/g, Nt = /<%=([\s\S]+?)%>/g, vt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, $t = /^\w*$/, Ft = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, rt = /[\\^$.*+?()[\]{}|]/g, Bt = RegExp(rt.source), k = /^\s+/, j = /\s/, H = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, C = /\{\n\/\* \[wrapped with (.+)\] \*/, G = /,? & /, U = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, se = /[()=,{}\[\]\/\s]/, he = /\\(\\)?/g, xe = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Te = /\w*$/, Re = /^[-+]0x[0-9a-f]+$/i, nt = /^0b[01]+$/i, Ue = /^\[object .+?Constructor\]$/, pt = /^0o[0-7]+$/i, it = /^(?:0|[1-9]\d*)$/, et = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, St = /($^)/, Tt = /['\n\r\u2028\u2029\\]/g, At = "\\ud800-\\udfff", _t = "\\u0300-\\u036f", ht = "\\ufe20-\\ufe2f", xt = "\\u20d0-\\u20ff", st = _t + ht + xt, bt = "\\u2700-\\u27bf", ut = "a-z\\xdf-\\xf6\\xf8-\\xff", ot = "\\xac\\xb1\\xd7\\xf7", Se = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Ae = "\\u2000-\\u206f", Ve = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Fe = "A-Z\\xc0-\\xd6\\xd8-\\xde", je = "\\ufe0e\\ufe0f", Je = ot + Se + Ae + Ve, Lt = "['’]", zt = "[" + At + "]", Xt = "[" + Je + "]", Ht = "[" + st + "]", le = "\\d+", tr = "[" + bt + "]", hr = "[" + ut + "]", dr = "[^" + At + Je + le + bt + ut + Fe + "]", Zt = "\\ud83c[\\udffb-\\udfff]", pr = "(?:" + Ht + "|" + Zt + ")", fr = "[^" + At + "]", Rr = "(?:\\ud83c[\\udde6-\\uddff]){2}", gr = "[\\ud800-\\udbff][\\udc00-\\udfff]", br = "[" + Fe + "]", $r = "\\u200d", Br = "(?:" + hr + "|" + dr + ")", Ir = "(?:" + br + "|" + dr + ")", nn = "(?:" + Lt + "(?:d|ll|m|re|s|t|ve))?", sn = "(?:" + Lt + "(?:D|LL|M|RE|S|T|VE))?", on = pr + "?", fh = "[" + je + "]?", Rp = "(?:" + $r + "(?:" + [fr, Rr, gr].join("|") + ")" + fh + on + ")*", ro = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", lh = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", hh = fh + on + Rp, Sc = "(?:" + [tr, Rr, gr].join("|") + ")" + hh, Dp = "(?:" + [fr + Ht + "?", Ht, Rr, gr, zt].join("|") + ")", Yu = RegExp(Lt, "g"), Op = RegExp(Ht, "g"), Ac = RegExp(Zt + "(?=" + Zt + ")|" + Dp + hh, "g"), dh = RegExp([
      br + "?" + hr + "+" + nn + "(?=" + [Xt, br, "$"].join("|") + ")",
      Ir + "+" + sn + "(?=" + [Xt, br + Br, "$"].join("|") + ")",
      br + "?" + Br + "+" + nn,
      br + "+" + sn,
      lh,
      ro,
      le,
      Sc
    ].join("|"), "g"), ph = RegExp("[" + $r + At + st + je + "]"), Ia = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, gh = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], Np = -1, Fr = {};
    Fr[at] = Fr[ke] = Fr[Qe] = Fr[tt] = Fr[Ye] = Fr[dt] = Fr[lt] = Fr[ct] = Fr[qt] = !0, Fr[D] = Fr[oe] = Fr[Ee] = Fr[J] = Fr[Ze] = Fr[Q] = Fr[X] = Fr[re] = Fr[ie] = Fr[ce] = Fr[Pe] = Fr[$e] = Fr[Me] = Fr[Ne] = Fr[qe] = !1;
    var Dr = {};
    Dr[D] = Dr[oe] = Dr[Ee] = Dr[Ze] = Dr[J] = Dr[Q] = Dr[at] = Dr[ke] = Dr[Qe] = Dr[tt] = Dr[Ye] = Dr[ie] = Dr[ce] = Dr[Pe] = Dr[$e] = Dr[Me] = Dr[Ne] = Dr[Ke] = Dr[dt] = Dr[lt] = Dr[ct] = Dr[qt] = !0, Dr[X] = Dr[re] = Dr[qe] = !1;
    var ae = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, ye = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, Ge = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, Pt = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, Ur = parseFloat, rr = parseInt, Kr = typeof gn == "object" && gn && gn.Object === Object && gn, vn = typeof self == "object" && self && self.Object === Object && self, xr = Kr || vn || Function("return this")(), jr = e && !e.nodeType && e, an = jr && !0 && t && !t.nodeType && t, ci = an && an.exports === jr, bn = ci && Kr.process, Vr = function() {
      try {
        var be = an && an.require && an.require("util").types;
        return be || bn && bn.binding && bn.binding("util");
      } catch {
      }
    }(), Qn = Vr && Vr.isArrayBuffer, us = Vr && Vr.isDate, Fi = Vr && Vr.isMap, Ms = Vr && Vr.isRegExp, Ju = Vr && Vr.isSet, Ca = Vr && Vr.isTypedArray;
    function Pn(be, Be, Ie) {
      switch (Ie.length) {
        case 0:
          return be.call(Be);
        case 1:
          return be.call(Be, Ie[0]);
        case 2:
          return be.call(Be, Ie[0], Ie[1]);
        case 3:
          return be.call(Be, Ie[0], Ie[1], Ie[2]);
      }
      return be.apply(Be, Ie);
    }
    function q9(be, Be, Ie, It) {
      for (var er = -1, Pr = be == null ? 0 : be.length; ++er < Pr; ) {
        var xn = be[er];
        Be(It, xn, Ie(xn), be);
      }
      return It;
    }
    function Ui(be, Be) {
      for (var Ie = -1, It = be == null ? 0 : be.length; ++Ie < It && Be(be[Ie], Ie, be) !== !1; )
        ;
      return be;
    }
    function z9(be, Be) {
      for (var Ie = be == null ? 0 : be.length; Ie-- && Be(be[Ie], Ie, be) !== !1; )
        ;
      return be;
    }
    function hy(be, Be) {
      for (var Ie = -1, It = be == null ? 0 : be.length; ++Ie < It; )
        if (!Be(be[Ie], Ie, be))
          return !1;
      return !0;
    }
    function jo(be, Be) {
      for (var Ie = -1, It = be == null ? 0 : be.length, er = 0, Pr = []; ++Ie < It; ) {
        var xn = be[Ie];
        Be(xn, Ie, be) && (Pr[er++] = xn);
      }
      return Pr;
    }
    function mh(be, Be) {
      var Ie = be == null ? 0 : be.length;
      return !!Ie && Pc(be, Be, 0) > -1;
    }
    function Lp(be, Be, Ie) {
      for (var It = -1, er = be == null ? 0 : be.length; ++It < er; )
        if (Ie(Be, be[It]))
          return !0;
      return !1;
    }
    function Xr(be, Be) {
      for (var Ie = -1, It = be == null ? 0 : be.length, er = Array(It); ++Ie < It; )
        er[Ie] = Be(be[Ie], Ie, be);
      return er;
    }
    function qo(be, Be) {
      for (var Ie = -1, It = Be.length, er = be.length; ++Ie < It; )
        be[er + Ie] = Be[Ie];
      return be;
    }
    function kp(be, Be, Ie, It) {
      var er = -1, Pr = be == null ? 0 : be.length;
      for (It && Pr && (Ie = be[++er]); ++er < Pr; )
        Ie = Be(Ie, be[er], er, be);
      return Ie;
    }
    function H9(be, Be, Ie, It) {
      var er = be == null ? 0 : be.length;
      for (It && er && (Ie = be[--er]); er--; )
        Ie = Be(Ie, be[er], er, be);
      return Ie;
    }
    function $p(be, Be) {
      for (var Ie = -1, It = be == null ? 0 : be.length; ++Ie < It; )
        if (Be(be[Ie], Ie, be))
          return !0;
      return !1;
    }
    var W9 = Bp("length");
    function K9(be) {
      return be.split("");
    }
    function V9(be) {
      return be.match(U) || [];
    }
    function dy(be, Be, Ie) {
      var It;
      return Ie(be, function(er, Pr, xn) {
        if (Be(er, Pr, xn))
          return It = Pr, !1;
      }), It;
    }
    function vh(be, Be, Ie, It) {
      for (var er = be.length, Pr = Ie + (It ? 1 : -1); It ? Pr-- : ++Pr < er; )
        if (Be(be[Pr], Pr, be))
          return Pr;
      return -1;
    }
    function Pc(be, Be, Ie) {
      return Be === Be ? sA(be, Be, Ie) : vh(be, py, Ie);
    }
    function G9(be, Be, Ie, It) {
      for (var er = Ie - 1, Pr = be.length; ++er < Pr; )
        if (It(be[er], Be))
          return er;
      return -1;
    }
    function py(be) {
      return be !== be;
    }
    function gy(be, Be) {
      var Ie = be == null ? 0 : be.length;
      return Ie ? Up(be, Be) / Ie : v;
    }
    function Bp(be) {
      return function(Be) {
        return Be == null ? r : Be[be];
      };
    }
    function Fp(be) {
      return function(Be) {
        return be == null ? r : be[Be];
      };
    }
    function my(be, Be, Ie, It, er) {
      return er(be, function(Pr, xn, qr) {
        Ie = It ? (It = !1, Pr) : Be(Ie, Pr, xn, qr);
      }), Ie;
    }
    function Y9(be, Be) {
      var Ie = be.length;
      for (be.sort(Be); Ie--; )
        be[Ie] = be[Ie].value;
      return be;
    }
    function Up(be, Be) {
      for (var Ie, It = -1, er = be.length; ++It < er; ) {
        var Pr = Be(be[It]);
        Pr !== r && (Ie = Ie === r ? Pr : Ie + Pr);
      }
      return Ie;
    }
    function jp(be, Be) {
      for (var Ie = -1, It = Array(be); ++Ie < be; )
        It[Ie] = Be(Ie);
      return It;
    }
    function J9(be, Be) {
      return Xr(Be, function(Ie) {
        return [Ie, be[Ie]];
      });
    }
    function vy(be) {
      return be && be.slice(0, xy(be) + 1).replace(k, "");
    }
    function Ai(be) {
      return function(Be) {
        return be(Be);
      };
    }
    function qp(be, Be) {
      return Xr(Be, function(Ie) {
        return be[Ie];
      });
    }
    function Xu(be, Be) {
      return be.has(Be);
    }
    function by(be, Be) {
      for (var Ie = -1, It = be.length; ++Ie < It && Pc(Be, be[Ie], 0) > -1; )
        ;
      return Ie;
    }
    function yy(be, Be) {
      for (var Ie = be.length; Ie-- && Pc(Be, be[Ie], 0) > -1; )
        ;
      return Ie;
    }
    function X9(be, Be) {
      for (var Ie = be.length, It = 0; Ie--; )
        be[Ie] === Be && ++It;
      return It;
    }
    var Z9 = Fp(ae), Q9 = Fp(ye);
    function eA(be) {
      return "\\" + Pt[be];
    }
    function tA(be, Be) {
      return be == null ? r : be[Be];
    }
    function Mc(be) {
      return ph.test(be);
    }
    function rA(be) {
      return Ia.test(be);
    }
    function nA(be) {
      for (var Be, Ie = []; !(Be = be.next()).done; )
        Ie.push(Be.value);
      return Ie;
    }
    function zp(be) {
      var Be = -1, Ie = Array(be.size);
      return be.forEach(function(It, er) {
        Ie[++Be] = [er, It];
      }), Ie;
    }
    function wy(be, Be) {
      return function(Ie) {
        return be(Be(Ie));
      };
    }
    function zo(be, Be) {
      for (var Ie = -1, It = be.length, er = 0, Pr = []; ++Ie < It; ) {
        var xn = be[Ie];
        (xn === Be || xn === d) && (be[Ie] = d, Pr[er++] = Ie);
      }
      return Pr;
    }
    function bh(be) {
      var Be = -1, Ie = Array(be.size);
      return be.forEach(function(It) {
        Ie[++Be] = It;
      }), Ie;
    }
    function iA(be) {
      var Be = -1, Ie = Array(be.size);
      return be.forEach(function(It) {
        Ie[++Be] = [It, It];
      }), Ie;
    }
    function sA(be, Be, Ie) {
      for (var It = Ie - 1, er = be.length; ++It < er; )
        if (be[It] === Be)
          return It;
      return -1;
    }
    function oA(be, Be, Ie) {
      for (var It = Ie + 1; It--; )
        if (be[It] === Be)
          return It;
      return It;
    }
    function Ic(be) {
      return Mc(be) ? cA(be) : W9(be);
    }
    function fs(be) {
      return Mc(be) ? uA(be) : K9(be);
    }
    function xy(be) {
      for (var Be = be.length; Be-- && j.test(be.charAt(Be)); )
        ;
      return Be;
    }
    var aA = Fp(Ge);
    function cA(be) {
      for (var Be = Ac.lastIndex = 0; Ac.test(be); )
        ++Be;
      return Be;
    }
    function uA(be) {
      return be.match(Ac) || [];
    }
    function fA(be) {
      return be.match(dh) || [];
    }
    var lA = function be(Be) {
      Be = Be == null ? xr : Cc.defaults(xr.Object(), Be, Cc.pick(xr, gh));
      var Ie = Be.Array, It = Be.Date, er = Be.Error, Pr = Be.Function, xn = Be.Math, qr = Be.Object, Hp = Be.RegExp, hA = Be.String, ji = Be.TypeError, yh = Ie.prototype, dA = Pr.prototype, Tc = qr.prototype, wh = Be["__core-js_shared__"], xh = dA.toString, Tr = Tc.hasOwnProperty, pA = 0, _y = function() {
        var c = /[^.]+$/.exec(wh && wh.keys && wh.keys.IE_PROTO || "");
        return c ? "Symbol(src)_1." + c : "";
      }(), _h = Tc.toString, gA = xh.call(qr), mA = xr._, vA = Hp(
        "^" + xh.call(Tr).replace(rt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Eh = ci ? Be.Buffer : r, Ho = Be.Symbol, Sh = Be.Uint8Array, Ey = Eh ? Eh.allocUnsafe : r, Ah = wy(qr.getPrototypeOf, qr), Sy = qr.create, Ay = Tc.propertyIsEnumerable, Ph = yh.splice, Py = Ho ? Ho.isConcatSpreadable : r, Zu = Ho ? Ho.iterator : r, Ta = Ho ? Ho.toStringTag : r, Mh = function() {
        try {
          var c = La(qr, "defineProperty");
          return c({}, "", {}), c;
        } catch {
        }
      }(), bA = Be.clearTimeout !== xr.clearTimeout && Be.clearTimeout, yA = It && It.now !== xr.Date.now && It.now, wA = Be.setTimeout !== xr.setTimeout && Be.setTimeout, Ih = xn.ceil, Ch = xn.floor, Wp = qr.getOwnPropertySymbols, xA = Eh ? Eh.isBuffer : r, My = Be.isFinite, _A = yh.join, EA = wy(qr.keys, qr), _n = xn.max, Wn = xn.min, SA = It.now, AA = Be.parseInt, Iy = xn.random, PA = yh.reverse, Kp = La(Be, "DataView"), Qu = La(Be, "Map"), Vp = La(Be, "Promise"), Rc = La(Be, "Set"), ef = La(Be, "WeakMap"), tf = La(qr, "create"), Th = ef && new ef(), Dc = {}, MA = ka(Kp), IA = ka(Qu), CA = ka(Vp), TA = ka(Rc), RA = ka(ef), Rh = Ho ? Ho.prototype : r, rf = Rh ? Rh.valueOf : r, Cy = Rh ? Rh.toString : r;
      function ee(c) {
        if (en(c) && !nr(c) && !(c instanceof yr)) {
          if (c instanceof qi)
            return c;
          if (Tr.call(c, "__wrapped__"))
            return Tw(c);
        }
        return new qi(c);
      }
      var Oc = /* @__PURE__ */ function() {
        function c() {
        }
        return function(l) {
          if (!Zr(l))
            return {};
          if (Sy)
            return Sy(l);
          c.prototype = l;
          var y = new c();
          return c.prototype = r, y;
        };
      }();
      function Dh() {
      }
      function qi(c, l) {
        this.__wrapped__ = c, this.__actions__ = [], this.__chain__ = !!l, this.__index__ = 0, this.__values__ = r;
      }
      ee.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: gt,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: Rt,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: Nt,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: ee
        }
      }, ee.prototype = Dh.prototype, ee.prototype.constructor = ee, qi.prototype = Oc(Dh.prototype), qi.prototype.constructor = qi;
      function yr(c) {
        this.__wrapped__ = c, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = M, this.__views__ = [];
      }
      function DA() {
        var c = new yr(this.__wrapped__);
        return c.__actions__ = ui(this.__actions__), c.__dir__ = this.__dir__, c.__filtered__ = this.__filtered__, c.__iteratees__ = ui(this.__iteratees__), c.__takeCount__ = this.__takeCount__, c.__views__ = ui(this.__views__), c;
      }
      function OA() {
        if (this.__filtered__) {
          var c = new yr(this);
          c.__dir__ = -1, c.__filtered__ = !0;
        } else
          c = this.clone(), c.__dir__ *= -1;
        return c;
      }
      function NA() {
        var c = this.__wrapped__.value(), l = this.__dir__, y = nr(c), O = l < 0, q = y ? c.length : 0, ne = KP(0, q, this.__views__), fe = ne.start, ge = ne.end, we = ge - fe, He = O ? ge : fe - 1, We = this.__iteratees__, Xe = We.length, wt = 0, Ot = Wn(we, this.__takeCount__);
        if (!y || !O && q == we && Ot == we)
          return Qy(c, this.__actions__);
        var Wt = [];
        e:
          for (; we-- && wt < Ot; ) {
            He += l;
            for (var ur = -1, Kt = c[He]; ++ur < Xe; ) {
              var mr = We[ur], _r = mr.iteratee, Ii = mr.type, ri = _r(Kt);
              if (Ii == g)
                Kt = ri;
              else if (!ri) {
                if (Ii == f)
                  continue e;
                break e;
              }
            }
            Wt[wt++] = Kt;
          }
        return Wt;
      }
      yr.prototype = Oc(Dh.prototype), yr.prototype.constructor = yr;
      function Ra(c) {
        var l = -1, y = c == null ? 0 : c.length;
        for (this.clear(); ++l < y; ) {
          var O = c[l];
          this.set(O[0], O[1]);
        }
      }
      function LA() {
        this.__data__ = tf ? tf(null) : {}, this.size = 0;
      }
      function kA(c) {
        var l = this.has(c) && delete this.__data__[c];
        return this.size -= l ? 1 : 0, l;
      }
      function $A(c) {
        var l = this.__data__;
        if (tf) {
          var y = l[c];
          return y === u ? r : y;
        }
        return Tr.call(l, c) ? l[c] : r;
      }
      function BA(c) {
        var l = this.__data__;
        return tf ? l[c] !== r : Tr.call(l, c);
      }
      function FA(c, l) {
        var y = this.__data__;
        return this.size += this.has(c) ? 0 : 1, y[c] = tf && l === r ? u : l, this;
      }
      Ra.prototype.clear = LA, Ra.prototype.delete = kA, Ra.prototype.get = $A, Ra.prototype.has = BA, Ra.prototype.set = FA;
      function no(c) {
        var l = -1, y = c == null ? 0 : c.length;
        for (this.clear(); ++l < y; ) {
          var O = c[l];
          this.set(O[0], O[1]);
        }
      }
      function UA() {
        this.__data__ = [], this.size = 0;
      }
      function jA(c) {
        var l = this.__data__, y = Oh(l, c);
        if (y < 0)
          return !1;
        var O = l.length - 1;
        return y == O ? l.pop() : Ph.call(l, y, 1), --this.size, !0;
      }
      function qA(c) {
        var l = this.__data__, y = Oh(l, c);
        return y < 0 ? r : l[y][1];
      }
      function zA(c) {
        return Oh(this.__data__, c) > -1;
      }
      function HA(c, l) {
        var y = this.__data__, O = Oh(y, c);
        return O < 0 ? (++this.size, y.push([c, l])) : y[O][1] = l, this;
      }
      no.prototype.clear = UA, no.prototype.delete = jA, no.prototype.get = qA, no.prototype.has = zA, no.prototype.set = HA;
      function io(c) {
        var l = -1, y = c == null ? 0 : c.length;
        for (this.clear(); ++l < y; ) {
          var O = c[l];
          this.set(O[0], O[1]);
        }
      }
      function WA() {
        this.size = 0, this.__data__ = {
          hash: new Ra(),
          map: new (Qu || no)(),
          string: new Ra()
        };
      }
      function KA(c) {
        var l = Wh(this, c).delete(c);
        return this.size -= l ? 1 : 0, l;
      }
      function VA(c) {
        return Wh(this, c).get(c);
      }
      function GA(c) {
        return Wh(this, c).has(c);
      }
      function YA(c, l) {
        var y = Wh(this, c), O = y.size;
        return y.set(c, l), this.size += y.size == O ? 0 : 1, this;
      }
      io.prototype.clear = WA, io.prototype.delete = KA, io.prototype.get = VA, io.prototype.has = GA, io.prototype.set = YA;
      function Da(c) {
        var l = -1, y = c == null ? 0 : c.length;
        for (this.__data__ = new io(); ++l < y; )
          this.add(c[l]);
      }
      function JA(c) {
        return this.__data__.set(c, u), this;
      }
      function XA(c) {
        return this.__data__.has(c);
      }
      Da.prototype.add = Da.prototype.push = JA, Da.prototype.has = XA;
      function ls(c) {
        var l = this.__data__ = new no(c);
        this.size = l.size;
      }
      function ZA() {
        this.__data__ = new no(), this.size = 0;
      }
      function QA(c) {
        var l = this.__data__, y = l.delete(c);
        return this.size = l.size, y;
      }
      function eP(c) {
        return this.__data__.get(c);
      }
      function tP(c) {
        return this.__data__.has(c);
      }
      function rP(c, l) {
        var y = this.__data__;
        if (y instanceof no) {
          var O = y.__data__;
          if (!Qu || O.length < i - 1)
            return O.push([c, l]), this.size = ++y.size, this;
          y = this.__data__ = new io(O);
        }
        return y.set(c, l), this.size = y.size, this;
      }
      ls.prototype.clear = ZA, ls.prototype.delete = QA, ls.prototype.get = eP, ls.prototype.has = tP, ls.prototype.set = rP;
      function Ty(c, l) {
        var y = nr(c), O = !y && $a(c), q = !y && !O && Yo(c), ne = !y && !O && !q && $c(c), fe = y || O || q || ne, ge = fe ? jp(c.length, hA) : [], we = ge.length;
        for (var He in c)
          (l || Tr.call(c, He)) && !(fe && // Safari 9 has enumerable `arguments.length` in strict mode.
          (He == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          q && (He == "offset" || He == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          ne && (He == "buffer" || He == "byteLength" || He == "byteOffset") || // Skip index properties.
          co(He, we))) && ge.push(He);
        return ge;
      }
      function Ry(c) {
        var l = c.length;
        return l ? c[ig(0, l - 1)] : r;
      }
      function nP(c, l) {
        return Kh(ui(c), Oa(l, 0, c.length));
      }
      function iP(c) {
        return Kh(ui(c));
      }
      function Gp(c, l, y) {
        (y !== r && !hs(c[l], y) || y === r && !(l in c)) && so(c, l, y);
      }
      function nf(c, l, y) {
        var O = c[l];
        (!(Tr.call(c, l) && hs(O, y)) || y === r && !(l in c)) && so(c, l, y);
      }
      function Oh(c, l) {
        for (var y = c.length; y--; )
          if (hs(c[y][0], l))
            return y;
        return -1;
      }
      function sP(c, l, y, O) {
        return Wo(c, function(q, ne, fe) {
          l(O, q, y(q), fe);
        }), O;
      }
      function Dy(c, l) {
        return c && Cs(l, Mn(l), c);
      }
      function oP(c, l) {
        return c && Cs(l, li(l), c);
      }
      function so(c, l, y) {
        l == "__proto__" && Mh ? Mh(c, l, {
          configurable: !0,
          enumerable: !0,
          value: y,
          writable: !0
        }) : c[l] = y;
      }
      function Yp(c, l) {
        for (var y = -1, O = l.length, q = Ie(O), ne = c == null; ++y < O; )
          q[y] = ne ? r : Cg(c, l[y]);
        return q;
      }
      function Oa(c, l, y) {
        return c === c && (y !== r && (c = c <= y ? c : y), l !== r && (c = c >= l ? c : l)), c;
      }
      function zi(c, l, y, O, q, ne) {
        var fe, ge = l & p, we = l & x, He = l & A;
        if (y && (fe = q ? y(c, O, q, ne) : y(c)), fe !== r)
          return fe;
        if (!Zr(c))
          return c;
        var We = nr(c);
        if (We) {
          if (fe = GP(c), !ge)
            return ui(c, fe);
        } else {
          var Xe = Kn(c), wt = Xe == re || Xe == de;
          if (Yo(c))
            return rw(c, ge);
          if (Xe == Pe || Xe == D || wt && !q) {
            if (fe = we || wt ? {} : xw(c), !ge)
              return we ? $P(c, oP(fe, c)) : kP(c, Dy(fe, c));
          } else {
            if (!Dr[Xe])
              return q ? c : {};
            fe = YP(c, Xe, ge);
          }
        }
        ne || (ne = new ls());
        var Ot = ne.get(c);
        if (Ot)
          return Ot;
        ne.set(c, fe), Jw(c) ? c.forEach(function(Kt) {
          fe.add(zi(Kt, l, y, Kt, c, ne));
        }) : Gw(c) && c.forEach(function(Kt, mr) {
          fe.set(mr, zi(Kt, l, y, mr, c, ne));
        });
        var Wt = He ? we ? gg : pg : we ? li : Mn, ur = We ? r : Wt(c);
        return Ui(ur || c, function(Kt, mr) {
          ur && (mr = Kt, Kt = c[mr]), nf(fe, mr, zi(Kt, l, y, mr, c, ne));
        }), fe;
      }
      function aP(c) {
        var l = Mn(c);
        return function(y) {
          return Oy(y, c, l);
        };
      }
      function Oy(c, l, y) {
        var O = y.length;
        if (c == null)
          return !O;
        for (c = qr(c); O--; ) {
          var q = y[O], ne = l[q], fe = c[q];
          if (fe === r && !(q in c) || !ne(fe))
            return !1;
        }
        return !0;
      }
      function Ny(c, l, y) {
        if (typeof c != "function")
          throw new ji(o);
        return lf(function() {
          c.apply(r, y);
        }, l);
      }
      function sf(c, l, y, O) {
        var q = -1, ne = mh, fe = !0, ge = c.length, we = [], He = l.length;
        if (!ge)
          return we;
        y && (l = Xr(l, Ai(y))), O ? (ne = Lp, fe = !1) : l.length >= i && (ne = Xu, fe = !1, l = new Da(l));
        e:
          for (; ++q < ge; ) {
            var We = c[q], Xe = y == null ? We : y(We);
            if (We = O || We !== 0 ? We : 0, fe && Xe === Xe) {
              for (var wt = He; wt--; )
                if (l[wt] === Xe)
                  continue e;
              we.push(We);
            } else ne(l, Xe, O) || we.push(We);
          }
        return we;
      }
      var Wo = aw(Is), Ly = aw(Xp, !0);
      function cP(c, l) {
        var y = !0;
        return Wo(c, function(O, q, ne) {
          return y = !!l(O, q, ne), y;
        }), y;
      }
      function Nh(c, l, y) {
        for (var O = -1, q = c.length; ++O < q; ) {
          var ne = c[O], fe = l(ne);
          if (fe != null && (ge === r ? fe === fe && !Mi(fe) : y(fe, ge)))
            var ge = fe, we = ne;
        }
        return we;
      }
      function uP(c, l, y, O) {
        var q = c.length;
        for (y = ar(y), y < 0 && (y = -y > q ? 0 : q + y), O = O === r || O > q ? q : ar(O), O < 0 && (O += q), O = y > O ? 0 : Zw(O); y < O; )
          c[y++] = l;
        return c;
      }
      function ky(c, l) {
        var y = [];
        return Wo(c, function(O, q, ne) {
          l(O, q, ne) && y.push(O);
        }), y;
      }
      function kn(c, l, y, O, q) {
        var ne = -1, fe = c.length;
        for (y || (y = XP), q || (q = []); ++ne < fe; ) {
          var ge = c[ne];
          l > 0 && y(ge) ? l > 1 ? kn(ge, l - 1, y, O, q) : qo(q, ge) : O || (q[q.length] = ge);
        }
        return q;
      }
      var Jp = cw(), $y = cw(!0);
      function Is(c, l) {
        return c && Jp(c, l, Mn);
      }
      function Xp(c, l) {
        return c && $y(c, l, Mn);
      }
      function Lh(c, l) {
        return jo(l, function(y) {
          return uo(c[y]);
        });
      }
      function Na(c, l) {
        l = Vo(l, c);
        for (var y = 0, O = l.length; c != null && y < O; )
          c = c[Ts(l[y++])];
        return y && y == O ? c : r;
      }
      function By(c, l, y) {
        var O = l(c);
        return nr(c) ? O : qo(O, y(c));
      }
      function ei(c) {
        return c == null ? c === r ? Le : me : Ta && Ta in qr(c) ? WP(c) : iM(c);
      }
      function Zp(c, l) {
        return c > l;
      }
      function fP(c, l) {
        return c != null && Tr.call(c, l);
      }
      function lP(c, l) {
        return c != null && l in qr(c);
      }
      function hP(c, l, y) {
        return c >= Wn(l, y) && c < _n(l, y);
      }
      function Qp(c, l, y) {
        for (var O = y ? Lp : mh, q = c[0].length, ne = c.length, fe = ne, ge = Ie(ne), we = 1 / 0, He = []; fe--; ) {
          var We = c[fe];
          fe && l && (We = Xr(We, Ai(l))), we = Wn(We.length, we), ge[fe] = !y && (l || q >= 120 && We.length >= 120) ? new Da(fe && We) : r;
        }
        We = c[0];
        var Xe = -1, wt = ge[0];
        e:
          for (; ++Xe < q && He.length < we; ) {
            var Ot = We[Xe], Wt = l ? l(Ot) : Ot;
            if (Ot = y || Ot !== 0 ? Ot : 0, !(wt ? Xu(wt, Wt) : O(He, Wt, y))) {
              for (fe = ne; --fe; ) {
                var ur = ge[fe];
                if (!(ur ? Xu(ur, Wt) : O(c[fe], Wt, y)))
                  continue e;
              }
              wt && wt.push(Wt), He.push(Ot);
            }
          }
        return He;
      }
      function dP(c, l, y, O) {
        return Is(c, function(q, ne, fe) {
          l(O, y(q), ne, fe);
        }), O;
      }
      function of(c, l, y) {
        l = Vo(l, c), c = Aw(c, l);
        var O = c == null ? c : c[Ts(Wi(l))];
        return O == null ? r : Pn(O, c, y);
      }
      function Fy(c) {
        return en(c) && ei(c) == D;
      }
      function pP(c) {
        return en(c) && ei(c) == Ee;
      }
      function gP(c) {
        return en(c) && ei(c) == Q;
      }
      function af(c, l, y, O, q) {
        return c === l ? !0 : c == null || l == null || !en(c) && !en(l) ? c !== c && l !== l : mP(c, l, y, O, af, q);
      }
      function mP(c, l, y, O, q, ne) {
        var fe = nr(c), ge = nr(l), we = fe ? oe : Kn(c), He = ge ? oe : Kn(l);
        we = we == D ? Pe : we, He = He == D ? Pe : He;
        var We = we == Pe, Xe = He == Pe, wt = we == He;
        if (wt && Yo(c)) {
          if (!Yo(l))
            return !1;
          fe = !0, We = !1;
        }
        if (wt && !We)
          return ne || (ne = new ls()), fe || $c(c) ? bw(c, l, y, O, q, ne) : zP(c, l, we, y, O, q, ne);
        if (!(y & I)) {
          var Ot = We && Tr.call(c, "__wrapped__"), Wt = Xe && Tr.call(l, "__wrapped__");
          if (Ot || Wt) {
            var ur = Ot ? c.value() : c, Kt = Wt ? l.value() : l;
            return ne || (ne = new ls()), q(ur, Kt, y, O, ne);
          }
        }
        return wt ? (ne || (ne = new ls()), HP(c, l, y, O, q, ne)) : !1;
      }
      function vP(c) {
        return en(c) && Kn(c) == ie;
      }
      function eg(c, l, y, O) {
        var q = y.length, ne = q, fe = !O;
        if (c == null)
          return !ne;
        for (c = qr(c); q--; ) {
          var ge = y[q];
          if (fe && ge[2] ? ge[1] !== c[ge[0]] : !(ge[0] in c))
            return !1;
        }
        for (; ++q < ne; ) {
          ge = y[q];
          var we = ge[0], He = c[we], We = ge[1];
          if (fe && ge[2]) {
            if (He === r && !(we in c))
              return !1;
          } else {
            var Xe = new ls();
            if (O)
              var wt = O(He, We, we, c, l, Xe);
            if (!(wt === r ? af(We, He, I | N, O, Xe) : wt))
              return !1;
          }
        }
        return !0;
      }
      function Uy(c) {
        if (!Zr(c) || QP(c))
          return !1;
        var l = uo(c) ? vA : Ue;
        return l.test(ka(c));
      }
      function bP(c) {
        return en(c) && ei(c) == $e;
      }
      function yP(c) {
        return en(c) && Kn(c) == Me;
      }
      function wP(c) {
        return en(c) && Zh(c.length) && !!Fr[ei(c)];
      }
      function jy(c) {
        return typeof c == "function" ? c : c == null ? hi : typeof c == "object" ? nr(c) ? Hy(c[0], c[1]) : zy(c) : u2(c);
      }
      function tg(c) {
        if (!ff(c))
          return EA(c);
        var l = [];
        for (var y in qr(c))
          Tr.call(c, y) && y != "constructor" && l.push(y);
        return l;
      }
      function xP(c) {
        if (!Zr(c))
          return nM(c);
        var l = ff(c), y = [];
        for (var O in c)
          O == "constructor" && (l || !Tr.call(c, O)) || y.push(O);
        return y;
      }
      function rg(c, l) {
        return c < l;
      }
      function qy(c, l) {
        var y = -1, O = fi(c) ? Ie(c.length) : [];
        return Wo(c, function(q, ne, fe) {
          O[++y] = l(q, ne, fe);
        }), O;
      }
      function zy(c) {
        var l = vg(c);
        return l.length == 1 && l[0][2] ? Ew(l[0][0], l[0][1]) : function(y) {
          return y === c || eg(y, c, l);
        };
      }
      function Hy(c, l) {
        return yg(c) && _w(l) ? Ew(Ts(c), l) : function(y) {
          var O = Cg(y, c);
          return O === r && O === l ? Tg(y, c) : af(l, O, I | N);
        };
      }
      function kh(c, l, y, O, q) {
        c !== l && Jp(l, function(ne, fe) {
          if (q || (q = new ls()), Zr(ne))
            _P(c, l, fe, y, kh, O, q);
          else {
            var ge = O ? O(xg(c, fe), ne, fe + "", c, l, q) : r;
            ge === r && (ge = ne), Gp(c, fe, ge);
          }
        }, li);
      }
      function _P(c, l, y, O, q, ne, fe) {
        var ge = xg(c, y), we = xg(l, y), He = fe.get(we);
        if (He) {
          Gp(c, y, He);
          return;
        }
        var We = ne ? ne(ge, we, y + "", c, l, fe) : r, Xe = We === r;
        if (Xe) {
          var wt = nr(we), Ot = !wt && Yo(we), Wt = !wt && !Ot && $c(we);
          We = we, wt || Ot || Wt ? nr(ge) ? We = ge : cn(ge) ? We = ui(ge) : Ot ? (Xe = !1, We = rw(we, !0)) : Wt ? (Xe = !1, We = nw(we, !0)) : We = [] : hf(we) || $a(we) ? (We = ge, $a(ge) ? We = Qw(ge) : (!Zr(ge) || uo(ge)) && (We = xw(we))) : Xe = !1;
        }
        Xe && (fe.set(we, We), q(We, we, O, ne, fe), fe.delete(we)), Gp(c, y, We);
      }
      function Wy(c, l) {
        var y = c.length;
        if (y)
          return l += l < 0 ? y : 0, co(l, y) ? c[l] : r;
      }
      function Ky(c, l, y) {
        l.length ? l = Xr(l, function(ne) {
          return nr(ne) ? function(fe) {
            return Na(fe, ne.length === 1 ? ne[0] : ne);
          } : ne;
        }) : l = [hi];
        var O = -1;
        l = Xr(l, Ai(jt()));
        var q = qy(c, function(ne, fe, ge) {
          var we = Xr(l, function(He) {
            return He(ne);
          });
          return { criteria: we, index: ++O, value: ne };
        });
        return Y9(q, function(ne, fe) {
          return LP(ne, fe, y);
        });
      }
      function EP(c, l) {
        return Vy(c, l, function(y, O) {
          return Tg(c, O);
        });
      }
      function Vy(c, l, y) {
        for (var O = -1, q = l.length, ne = {}; ++O < q; ) {
          var fe = l[O], ge = Na(c, fe);
          y(ge, fe) && cf(ne, Vo(fe, c), ge);
        }
        return ne;
      }
      function SP(c) {
        return function(l) {
          return Na(l, c);
        };
      }
      function ng(c, l, y, O) {
        var q = O ? G9 : Pc, ne = -1, fe = l.length, ge = c;
        for (c === l && (l = ui(l)), y && (ge = Xr(c, Ai(y))); ++ne < fe; )
          for (var we = 0, He = l[ne], We = y ? y(He) : He; (we = q(ge, We, we, O)) > -1; )
            ge !== c && Ph.call(ge, we, 1), Ph.call(c, we, 1);
        return c;
      }
      function Gy(c, l) {
        for (var y = c ? l.length : 0, O = y - 1; y--; ) {
          var q = l[y];
          if (y == O || q !== ne) {
            var ne = q;
            co(q) ? Ph.call(c, q, 1) : ag(c, q);
          }
        }
        return c;
      }
      function ig(c, l) {
        return c + Ch(Iy() * (l - c + 1));
      }
      function AP(c, l, y, O) {
        for (var q = -1, ne = _n(Ih((l - c) / (y || 1)), 0), fe = Ie(ne); ne--; )
          fe[O ? ne : ++q] = c, c += y;
        return fe;
      }
      function sg(c, l) {
        var y = "";
        if (!c || l < 1 || l > _)
          return y;
        do
          l % 2 && (y += c), l = Ch(l / 2), l && (c += c);
        while (l);
        return y;
      }
      function lr(c, l) {
        return _g(Sw(c, l, hi), c + "");
      }
      function PP(c) {
        return Ry(Bc(c));
      }
      function MP(c, l) {
        var y = Bc(c);
        return Kh(y, Oa(l, 0, y.length));
      }
      function cf(c, l, y, O) {
        if (!Zr(c))
          return c;
        l = Vo(l, c);
        for (var q = -1, ne = l.length, fe = ne - 1, ge = c; ge != null && ++q < ne; ) {
          var we = Ts(l[q]), He = y;
          if (we === "__proto__" || we === "constructor" || we === "prototype")
            return c;
          if (q != fe) {
            var We = ge[we];
            He = O ? O(We, we, ge) : r, He === r && (He = Zr(We) ? We : co(l[q + 1]) ? [] : {});
          }
          nf(ge, we, He), ge = ge[we];
        }
        return c;
      }
      var Yy = Th ? function(c, l) {
        return Th.set(c, l), c;
      } : hi, IP = Mh ? function(c, l) {
        return Mh(c, "toString", {
          configurable: !0,
          enumerable: !1,
          value: Dg(l),
          writable: !0
        });
      } : hi;
      function CP(c) {
        return Kh(Bc(c));
      }
      function Hi(c, l, y) {
        var O = -1, q = c.length;
        l < 0 && (l = -l > q ? 0 : q + l), y = y > q ? q : y, y < 0 && (y += q), q = l > y ? 0 : y - l >>> 0, l >>>= 0;
        for (var ne = Ie(q); ++O < q; )
          ne[O] = c[O + l];
        return ne;
      }
      function TP(c, l) {
        var y;
        return Wo(c, function(O, q, ne) {
          return y = l(O, q, ne), !y;
        }), !!y;
      }
      function $h(c, l, y) {
        var O = 0, q = c == null ? O : c.length;
        if (typeof l == "number" && l === l && q <= B) {
          for (; O < q; ) {
            var ne = O + q >>> 1, fe = c[ne];
            fe !== null && !Mi(fe) && (y ? fe <= l : fe < l) ? O = ne + 1 : q = ne;
          }
          return q;
        }
        return og(c, l, hi, y);
      }
      function og(c, l, y, O) {
        var q = 0, ne = c == null ? 0 : c.length;
        if (ne === 0)
          return 0;
        l = y(l);
        for (var fe = l !== l, ge = l === null, we = Mi(l), He = l === r; q < ne; ) {
          var We = Ch((q + ne) / 2), Xe = y(c[We]), wt = Xe !== r, Ot = Xe === null, Wt = Xe === Xe, ur = Mi(Xe);
          if (fe)
            var Kt = O || Wt;
          else He ? Kt = Wt && (O || wt) : ge ? Kt = Wt && wt && (O || !Ot) : we ? Kt = Wt && wt && !Ot && (O || !ur) : Ot || ur ? Kt = !1 : Kt = O ? Xe <= l : Xe < l;
          Kt ? q = We + 1 : ne = We;
        }
        return Wn(ne, P);
      }
      function Jy(c, l) {
        for (var y = -1, O = c.length, q = 0, ne = []; ++y < O; ) {
          var fe = c[y], ge = l ? l(fe) : fe;
          if (!y || !hs(ge, we)) {
            var we = ge;
            ne[q++] = fe === 0 ? 0 : fe;
          }
        }
        return ne;
      }
      function Xy(c) {
        return typeof c == "number" ? c : Mi(c) ? v : +c;
      }
      function Pi(c) {
        if (typeof c == "string")
          return c;
        if (nr(c))
          return Xr(c, Pi) + "";
        if (Mi(c))
          return Cy ? Cy.call(c) : "";
        var l = c + "";
        return l == "0" && 1 / c == -w ? "-0" : l;
      }
      function Ko(c, l, y) {
        var O = -1, q = mh, ne = c.length, fe = !0, ge = [], we = ge;
        if (y)
          fe = !1, q = Lp;
        else if (ne >= i) {
          var He = l ? null : jP(c);
          if (He)
            return bh(He);
          fe = !1, q = Xu, we = new Da();
        } else
          we = l ? [] : ge;
        e:
          for (; ++O < ne; ) {
            var We = c[O], Xe = l ? l(We) : We;
            if (We = y || We !== 0 ? We : 0, fe && Xe === Xe) {
              for (var wt = we.length; wt--; )
                if (we[wt] === Xe)
                  continue e;
              l && we.push(Xe), ge.push(We);
            } else q(we, Xe, y) || (we !== ge && we.push(Xe), ge.push(We));
          }
        return ge;
      }
      function ag(c, l) {
        return l = Vo(l, c), c = Aw(c, l), c == null || delete c[Ts(Wi(l))];
      }
      function Zy(c, l, y, O) {
        return cf(c, l, y(Na(c, l)), O);
      }
      function Bh(c, l, y, O) {
        for (var q = c.length, ne = O ? q : -1; (O ? ne-- : ++ne < q) && l(c[ne], ne, c); )
          ;
        return y ? Hi(c, O ? 0 : ne, O ? ne + 1 : q) : Hi(c, O ? ne + 1 : 0, O ? q : ne);
      }
      function Qy(c, l) {
        var y = c;
        return y instanceof yr && (y = y.value()), kp(l, function(O, q) {
          return q.func.apply(q.thisArg, qo([O], q.args));
        }, y);
      }
      function cg(c, l, y) {
        var O = c.length;
        if (O < 2)
          return O ? Ko(c[0]) : [];
        for (var q = -1, ne = Ie(O); ++q < O; )
          for (var fe = c[q], ge = -1; ++ge < O; )
            ge != q && (ne[q] = sf(ne[q] || fe, c[ge], l, y));
        return Ko(kn(ne, 1), l, y);
      }
      function ew(c, l, y) {
        for (var O = -1, q = c.length, ne = l.length, fe = {}; ++O < q; ) {
          var ge = O < ne ? l[O] : r;
          y(fe, c[O], ge);
        }
        return fe;
      }
      function ug(c) {
        return cn(c) ? c : [];
      }
      function fg(c) {
        return typeof c == "function" ? c : hi;
      }
      function Vo(c, l) {
        return nr(c) ? c : yg(c, l) ? [c] : Cw(Cr(c));
      }
      var RP = lr;
      function Go(c, l, y) {
        var O = c.length;
        return y = y === r ? O : y, !l && y >= O ? c : Hi(c, l, y);
      }
      var tw = bA || function(c) {
        return xr.clearTimeout(c);
      };
      function rw(c, l) {
        if (l)
          return c.slice();
        var y = c.length, O = Ey ? Ey(y) : new c.constructor(y);
        return c.copy(O), O;
      }
      function lg(c) {
        var l = new c.constructor(c.byteLength);
        return new Sh(l).set(new Sh(c)), l;
      }
      function DP(c, l) {
        var y = l ? lg(c.buffer) : c.buffer;
        return new c.constructor(y, c.byteOffset, c.byteLength);
      }
      function OP(c) {
        var l = new c.constructor(c.source, Te.exec(c));
        return l.lastIndex = c.lastIndex, l;
      }
      function NP(c) {
        return rf ? qr(rf.call(c)) : {};
      }
      function nw(c, l) {
        var y = l ? lg(c.buffer) : c.buffer;
        return new c.constructor(y, c.byteOffset, c.length);
      }
      function iw(c, l) {
        if (c !== l) {
          var y = c !== r, O = c === null, q = c === c, ne = Mi(c), fe = l !== r, ge = l === null, we = l === l, He = Mi(l);
          if (!ge && !He && !ne && c > l || ne && fe && we && !ge && !He || O && fe && we || !y && we || !q)
            return 1;
          if (!O && !ne && !He && c < l || He && y && q && !O && !ne || ge && y && q || !fe && q || !we)
            return -1;
        }
        return 0;
      }
      function LP(c, l, y) {
        for (var O = -1, q = c.criteria, ne = l.criteria, fe = q.length, ge = y.length; ++O < fe; ) {
          var we = iw(q[O], ne[O]);
          if (we) {
            if (O >= ge)
              return we;
            var He = y[O];
            return we * (He == "desc" ? -1 : 1);
          }
        }
        return c.index - l.index;
      }
      function sw(c, l, y, O) {
        for (var q = -1, ne = c.length, fe = y.length, ge = -1, we = l.length, He = _n(ne - fe, 0), We = Ie(we + He), Xe = !O; ++ge < we; )
          We[ge] = l[ge];
        for (; ++q < fe; )
          (Xe || q < ne) && (We[y[q]] = c[q]);
        for (; He--; )
          We[ge++] = c[q++];
        return We;
      }
      function ow(c, l, y, O) {
        for (var q = -1, ne = c.length, fe = -1, ge = y.length, we = -1, He = l.length, We = _n(ne - ge, 0), Xe = Ie(We + He), wt = !O; ++q < We; )
          Xe[q] = c[q];
        for (var Ot = q; ++we < He; )
          Xe[Ot + we] = l[we];
        for (; ++fe < ge; )
          (wt || q < ne) && (Xe[Ot + y[fe]] = c[q++]);
        return Xe;
      }
      function ui(c, l) {
        var y = -1, O = c.length;
        for (l || (l = Ie(O)); ++y < O; )
          l[y] = c[y];
        return l;
      }
      function Cs(c, l, y, O) {
        var q = !y;
        y || (y = {});
        for (var ne = -1, fe = l.length; ++ne < fe; ) {
          var ge = l[ne], we = O ? O(y[ge], c[ge], ge, y, c) : r;
          we === r && (we = c[ge]), q ? so(y, ge, we) : nf(y, ge, we);
        }
        return y;
      }
      function kP(c, l) {
        return Cs(c, bg(c), l);
      }
      function $P(c, l) {
        return Cs(c, yw(c), l);
      }
      function Fh(c, l) {
        return function(y, O) {
          var q = nr(y) ? q9 : sP, ne = l ? l() : {};
          return q(y, c, jt(O, 2), ne);
        };
      }
      function Nc(c) {
        return lr(function(l, y) {
          var O = -1, q = y.length, ne = q > 1 ? y[q - 1] : r, fe = q > 2 ? y[2] : r;
          for (ne = c.length > 3 && typeof ne == "function" ? (q--, ne) : r, fe && ti(y[0], y[1], fe) && (ne = q < 3 ? r : ne, q = 1), l = qr(l); ++O < q; ) {
            var ge = y[O];
            ge && c(l, ge, O, ne);
          }
          return l;
        });
      }
      function aw(c, l) {
        return function(y, O) {
          if (y == null)
            return y;
          if (!fi(y))
            return c(y, O);
          for (var q = y.length, ne = l ? q : -1, fe = qr(y); (l ? ne-- : ++ne < q) && O(fe[ne], ne, fe) !== !1; )
            ;
          return y;
        };
      }
      function cw(c) {
        return function(l, y, O) {
          for (var q = -1, ne = qr(l), fe = O(l), ge = fe.length; ge--; ) {
            var we = fe[c ? ge : ++q];
            if (y(ne[we], we, ne) === !1)
              break;
          }
          return l;
        };
      }
      function BP(c, l, y) {
        var O = l & L, q = uf(c);
        function ne() {
          var fe = this && this !== xr && this instanceof ne ? q : c;
          return fe.apply(O ? y : this, arguments);
        }
        return ne;
      }
      function uw(c) {
        return function(l) {
          l = Cr(l);
          var y = Mc(l) ? fs(l) : r, O = y ? y[0] : l.charAt(0), q = y ? Go(y, 1).join("") : l.slice(1);
          return O[c]() + q;
        };
      }
      function Lc(c) {
        return function(l) {
          return kp(a2(o2(l).replace(Yu, "")), c, "");
        };
      }
      function uf(c) {
        return function() {
          var l = arguments;
          switch (l.length) {
            case 0:
              return new c();
            case 1:
              return new c(l[0]);
            case 2:
              return new c(l[0], l[1]);
            case 3:
              return new c(l[0], l[1], l[2]);
            case 4:
              return new c(l[0], l[1], l[2], l[3]);
            case 5:
              return new c(l[0], l[1], l[2], l[3], l[4]);
            case 6:
              return new c(l[0], l[1], l[2], l[3], l[4], l[5]);
            case 7:
              return new c(l[0], l[1], l[2], l[3], l[4], l[5], l[6]);
          }
          var y = Oc(c.prototype), O = c.apply(y, l);
          return Zr(O) ? O : y;
        };
      }
      function FP(c, l, y) {
        var O = uf(c);
        function q() {
          for (var ne = arguments.length, fe = Ie(ne), ge = ne, we = kc(q); ge--; )
            fe[ge] = arguments[ge];
          var He = ne < 3 && fe[0] !== we && fe[ne - 1] !== we ? [] : zo(fe, we);
          if (ne -= He.length, ne < y)
            return pw(
              c,
              l,
              Uh,
              q.placeholder,
              r,
              fe,
              He,
              r,
              r,
              y - ne
            );
          var We = this && this !== xr && this instanceof q ? O : c;
          return Pn(We, this, fe);
        }
        return q;
      }
      function fw(c) {
        return function(l, y, O) {
          var q = qr(l);
          if (!fi(l)) {
            var ne = jt(y, 3);
            l = Mn(l), y = function(ge) {
              return ne(q[ge], ge, q);
            };
          }
          var fe = c(l, y, O);
          return fe > -1 ? q[ne ? l[fe] : fe] : r;
        };
      }
      function lw(c) {
        return ao(function(l) {
          var y = l.length, O = y, q = qi.prototype.thru;
          for (c && l.reverse(); O--; ) {
            var ne = l[O];
            if (typeof ne != "function")
              throw new ji(o);
            if (q && !fe && Hh(ne) == "wrapper")
              var fe = new qi([], !0);
          }
          for (O = fe ? O : y; ++O < y; ) {
            ne = l[O];
            var ge = Hh(ne), we = ge == "wrapper" ? mg(ne) : r;
            we && wg(we[0]) && we[1] == (R | W | V | K) && !we[4].length && we[9] == 1 ? fe = fe[Hh(we[0])].apply(fe, we[3]) : fe = ne.length == 1 && wg(ne) ? fe[ge]() : fe.thru(ne);
          }
          return function() {
            var He = arguments, We = He[0];
            if (fe && He.length == 1 && nr(We))
              return fe.plant(We).value();
            for (var Xe = 0, wt = y ? l[Xe].apply(this, He) : We; ++Xe < y; )
              wt = l[Xe].call(this, wt);
            return wt;
          };
        });
      }
      function Uh(c, l, y, O, q, ne, fe, ge, we, He) {
        var We = l & R, Xe = l & L, wt = l & F, Ot = l & (W | z), Wt = l & pe, ur = wt ? r : uf(c);
        function Kt() {
          for (var mr = arguments.length, _r = Ie(mr), Ii = mr; Ii--; )
            _r[Ii] = arguments[Ii];
          if (Ot)
            var ri = kc(Kt), Ci = X9(_r, ri);
          if (O && (_r = sw(_r, O, q, Ot)), ne && (_r = ow(_r, ne, fe, Ot)), mr -= Ci, Ot && mr < He) {
            var un = zo(_r, ri);
            return pw(
              c,
              l,
              Uh,
              Kt.placeholder,
              y,
              _r,
              un,
              ge,
              we,
              He - mr
            );
          }
          var ds = Xe ? y : this, lo = wt ? ds[c] : c;
          return mr = _r.length, ge ? _r = sM(_r, ge) : Wt && mr > 1 && _r.reverse(), We && we < mr && (_r.length = we), this && this !== xr && this instanceof Kt && (lo = ur || uf(lo)), lo.apply(ds, _r);
        }
        return Kt;
      }
      function hw(c, l) {
        return function(y, O) {
          return dP(y, c, l(O), {});
        };
      }
      function jh(c, l) {
        return function(y, O) {
          var q;
          if (y === r && O === r)
            return l;
          if (y !== r && (q = y), O !== r) {
            if (q === r)
              return O;
            typeof y == "string" || typeof O == "string" ? (y = Pi(y), O = Pi(O)) : (y = Xy(y), O = Xy(O)), q = c(y, O);
          }
          return q;
        };
      }
      function hg(c) {
        return ao(function(l) {
          return l = Xr(l, Ai(jt())), lr(function(y) {
            var O = this;
            return c(l, function(q) {
              return Pn(q, O, y);
            });
          });
        });
      }
      function qh(c, l) {
        l = l === r ? " " : Pi(l);
        var y = l.length;
        if (y < 2)
          return y ? sg(l, c) : l;
        var O = sg(l, Ih(c / Ic(l)));
        return Mc(l) ? Go(fs(O), 0, c).join("") : O.slice(0, c);
      }
      function UP(c, l, y, O) {
        var q = l & L, ne = uf(c);
        function fe() {
          for (var ge = -1, we = arguments.length, He = -1, We = O.length, Xe = Ie(We + we), wt = this && this !== xr && this instanceof fe ? ne : c; ++He < We; )
            Xe[He] = O[He];
          for (; we--; )
            Xe[He++] = arguments[++ge];
          return Pn(wt, q ? y : this, Xe);
        }
        return fe;
      }
      function dw(c) {
        return function(l, y, O) {
          return O && typeof O != "number" && ti(l, y, O) && (y = O = r), l = fo(l), y === r ? (y = l, l = 0) : y = fo(y), O = O === r ? l < y ? 1 : -1 : fo(O), AP(l, y, O, c);
        };
      }
      function zh(c) {
        return function(l, y) {
          return typeof l == "string" && typeof y == "string" || (l = Ki(l), y = Ki(y)), c(l, y);
        };
      }
      function pw(c, l, y, O, q, ne, fe, ge, we, He) {
        var We = l & W, Xe = We ? fe : r, wt = We ? r : fe, Ot = We ? ne : r, Wt = We ? r : ne;
        l |= We ? V : te, l &= ~(We ? te : V), l & $ || (l &= ~(L | F));
        var ur = [
          c,
          l,
          q,
          Ot,
          Xe,
          Wt,
          wt,
          ge,
          we,
          He
        ], Kt = y.apply(r, ur);
        return wg(c) && Pw(Kt, ur), Kt.placeholder = O, Mw(Kt, c, l);
      }
      function dg(c) {
        var l = xn[c];
        return function(y, O) {
          if (y = Ki(y), O = O == null ? 0 : Wn(ar(O), 292), O && My(y)) {
            var q = (Cr(y) + "e").split("e"), ne = l(q[0] + "e" + (+q[1] + O));
            return q = (Cr(ne) + "e").split("e"), +(q[0] + "e" + (+q[1] - O));
          }
          return l(y);
        };
      }
      var jP = Rc && 1 / bh(new Rc([, -0]))[1] == w ? function(c) {
        return new Rc(c);
      } : Lg;
      function gw(c) {
        return function(l) {
          var y = Kn(l);
          return y == ie ? zp(l) : y == Me ? iA(l) : J9(l, c(l));
        };
      }
      function oo(c, l, y, O, q, ne, fe, ge) {
        var we = l & F;
        if (!we && typeof c != "function")
          throw new ji(o);
        var He = O ? O.length : 0;
        if (He || (l &= ~(V | te), O = q = r), fe = fe === r ? fe : _n(ar(fe), 0), ge = ge === r ? ge : ar(ge), He -= q ? q.length : 0, l & te) {
          var We = O, Xe = q;
          O = q = r;
        }
        var wt = we ? r : mg(c), Ot = [
          c,
          l,
          y,
          O,
          q,
          We,
          Xe,
          ne,
          fe,
          ge
        ];
        if (wt && rM(Ot, wt), c = Ot[0], l = Ot[1], y = Ot[2], O = Ot[3], q = Ot[4], ge = Ot[9] = Ot[9] === r ? we ? 0 : c.length : _n(Ot[9] - He, 0), !ge && l & (W | z) && (l &= ~(W | z)), !l || l == L)
          var Wt = BP(c, l, y);
        else l == W || l == z ? Wt = FP(c, l, ge) : (l == V || l == (L | V)) && !q.length ? Wt = UP(c, l, y, O) : Wt = Uh.apply(r, Ot);
        var ur = wt ? Yy : Pw;
        return Mw(ur(Wt, Ot), c, l);
      }
      function mw(c, l, y, O) {
        return c === r || hs(c, Tc[y]) && !Tr.call(O, y) ? l : c;
      }
      function vw(c, l, y, O, q, ne) {
        return Zr(c) && Zr(l) && (ne.set(l, c), kh(c, l, r, vw, ne), ne.delete(l)), c;
      }
      function qP(c) {
        return hf(c) ? r : c;
      }
      function bw(c, l, y, O, q, ne) {
        var fe = y & I, ge = c.length, we = l.length;
        if (ge != we && !(fe && we > ge))
          return !1;
        var He = ne.get(c), We = ne.get(l);
        if (He && We)
          return He == l && We == c;
        var Xe = -1, wt = !0, Ot = y & N ? new Da() : r;
        for (ne.set(c, l), ne.set(l, c); ++Xe < ge; ) {
          var Wt = c[Xe], ur = l[Xe];
          if (O)
            var Kt = fe ? O(ur, Wt, Xe, l, c, ne) : O(Wt, ur, Xe, c, l, ne);
          if (Kt !== r) {
            if (Kt)
              continue;
            wt = !1;
            break;
          }
          if (Ot) {
            if (!$p(l, function(mr, _r) {
              if (!Xu(Ot, _r) && (Wt === mr || q(Wt, mr, y, O, ne)))
                return Ot.push(_r);
            })) {
              wt = !1;
              break;
            }
          } else if (!(Wt === ur || q(Wt, ur, y, O, ne))) {
            wt = !1;
            break;
          }
        }
        return ne.delete(c), ne.delete(l), wt;
      }
      function zP(c, l, y, O, q, ne, fe) {
        switch (y) {
          case Ze:
            if (c.byteLength != l.byteLength || c.byteOffset != l.byteOffset)
              return !1;
            c = c.buffer, l = l.buffer;
          case Ee:
            return !(c.byteLength != l.byteLength || !ne(new Sh(c), new Sh(l)));
          case J:
          case Q:
          case ce:
            return hs(+c, +l);
          case X:
            return c.name == l.name && c.message == l.message;
          case $e:
          case Ne:
            return c == l + "";
          case ie:
            var ge = zp;
          case Me:
            var we = O & I;
            if (ge || (ge = bh), c.size != l.size && !we)
              return !1;
            var He = fe.get(c);
            if (He)
              return He == l;
            O |= N, fe.set(c, l);
            var We = bw(ge(c), ge(l), O, q, ne, fe);
            return fe.delete(c), We;
          case Ke:
            if (rf)
              return rf.call(c) == rf.call(l);
        }
        return !1;
      }
      function HP(c, l, y, O, q, ne) {
        var fe = y & I, ge = pg(c), we = ge.length, He = pg(l), We = He.length;
        if (we != We && !fe)
          return !1;
        for (var Xe = we; Xe--; ) {
          var wt = ge[Xe];
          if (!(fe ? wt in l : Tr.call(l, wt)))
            return !1;
        }
        var Ot = ne.get(c), Wt = ne.get(l);
        if (Ot && Wt)
          return Ot == l && Wt == c;
        var ur = !0;
        ne.set(c, l), ne.set(l, c);
        for (var Kt = fe; ++Xe < we; ) {
          wt = ge[Xe];
          var mr = c[wt], _r = l[wt];
          if (O)
            var Ii = fe ? O(_r, mr, wt, l, c, ne) : O(mr, _r, wt, c, l, ne);
          if (!(Ii === r ? mr === _r || q(mr, _r, y, O, ne) : Ii)) {
            ur = !1;
            break;
          }
          Kt || (Kt = wt == "constructor");
        }
        if (ur && !Kt) {
          var ri = c.constructor, Ci = l.constructor;
          ri != Ci && "constructor" in c && "constructor" in l && !(typeof ri == "function" && ri instanceof ri && typeof Ci == "function" && Ci instanceof Ci) && (ur = !1);
        }
        return ne.delete(c), ne.delete(l), ur;
      }
      function ao(c) {
        return _g(Sw(c, r, Ow), c + "");
      }
      function pg(c) {
        return By(c, Mn, bg);
      }
      function gg(c) {
        return By(c, li, yw);
      }
      var mg = Th ? function(c) {
        return Th.get(c);
      } : Lg;
      function Hh(c) {
        for (var l = c.name + "", y = Dc[l], O = Tr.call(Dc, l) ? y.length : 0; O--; ) {
          var q = y[O], ne = q.func;
          if (ne == null || ne == c)
            return q.name;
        }
        return l;
      }
      function kc(c) {
        var l = Tr.call(ee, "placeholder") ? ee : c;
        return l.placeholder;
      }
      function jt() {
        var c = ee.iteratee || Og;
        return c = c === Og ? jy : c, arguments.length ? c(arguments[0], arguments[1]) : c;
      }
      function Wh(c, l) {
        var y = c.__data__;
        return ZP(l) ? y[typeof l == "string" ? "string" : "hash"] : y.map;
      }
      function vg(c) {
        for (var l = Mn(c), y = l.length; y--; ) {
          var O = l[y], q = c[O];
          l[y] = [O, q, _w(q)];
        }
        return l;
      }
      function La(c, l) {
        var y = tA(c, l);
        return Uy(y) ? y : r;
      }
      function WP(c) {
        var l = Tr.call(c, Ta), y = c[Ta];
        try {
          c[Ta] = r;
          var O = !0;
        } catch {
        }
        var q = _h.call(c);
        return O && (l ? c[Ta] = y : delete c[Ta]), q;
      }
      var bg = Wp ? function(c) {
        return c == null ? [] : (c = qr(c), jo(Wp(c), function(l) {
          return Ay.call(c, l);
        }));
      } : kg, yw = Wp ? function(c) {
        for (var l = []; c; )
          qo(l, bg(c)), c = Ah(c);
        return l;
      } : kg, Kn = ei;
      (Kp && Kn(new Kp(new ArrayBuffer(1))) != Ze || Qu && Kn(new Qu()) != ie || Vp && Kn(Vp.resolve()) != De || Rc && Kn(new Rc()) != Me || ef && Kn(new ef()) != qe) && (Kn = function(c) {
        var l = ei(c), y = l == Pe ? c.constructor : r, O = y ? ka(y) : "";
        if (O)
          switch (O) {
            case MA:
              return Ze;
            case IA:
              return ie;
            case CA:
              return De;
            case TA:
              return Me;
            case RA:
              return qe;
          }
        return l;
      });
      function KP(c, l, y) {
        for (var O = -1, q = y.length; ++O < q; ) {
          var ne = y[O], fe = ne.size;
          switch (ne.type) {
            case "drop":
              c += fe;
              break;
            case "dropRight":
              l -= fe;
              break;
            case "take":
              l = Wn(l, c + fe);
              break;
            case "takeRight":
              c = _n(c, l - fe);
              break;
          }
        }
        return { start: c, end: l };
      }
      function VP(c) {
        var l = c.match(C);
        return l ? l[1].split(G) : [];
      }
      function ww(c, l, y) {
        l = Vo(l, c);
        for (var O = -1, q = l.length, ne = !1; ++O < q; ) {
          var fe = Ts(l[O]);
          if (!(ne = c != null && y(c, fe)))
            break;
          c = c[fe];
        }
        return ne || ++O != q ? ne : (q = c == null ? 0 : c.length, !!q && Zh(q) && co(fe, q) && (nr(c) || $a(c)));
      }
      function GP(c) {
        var l = c.length, y = new c.constructor(l);
        return l && typeof c[0] == "string" && Tr.call(c, "index") && (y.index = c.index, y.input = c.input), y;
      }
      function xw(c) {
        return typeof c.constructor == "function" && !ff(c) ? Oc(Ah(c)) : {};
      }
      function YP(c, l, y) {
        var O = c.constructor;
        switch (l) {
          case Ee:
            return lg(c);
          case J:
          case Q:
            return new O(+c);
          case Ze:
            return DP(c, y);
          case at:
          case ke:
          case Qe:
          case tt:
          case Ye:
          case dt:
          case lt:
          case ct:
          case qt:
            return nw(c, y);
          case ie:
            return new O();
          case ce:
          case Ne:
            return new O(c);
          case $e:
            return OP(c);
          case Me:
            return new O();
          case Ke:
            return NP(c);
        }
      }
      function JP(c, l) {
        var y = l.length;
        if (!y)
          return c;
        var O = y - 1;
        return l[O] = (y > 1 ? "& " : "") + l[O], l = l.join(y > 2 ? ", " : " "), c.replace(H, `{
/* [wrapped with ` + l + `] */
`);
      }
      function XP(c) {
        return nr(c) || $a(c) || !!(Py && c && c[Py]);
      }
      function co(c, l) {
        var y = typeof c;
        return l = l ?? _, !!l && (y == "number" || y != "symbol" && it.test(c)) && c > -1 && c % 1 == 0 && c < l;
      }
      function ti(c, l, y) {
        if (!Zr(y))
          return !1;
        var O = typeof l;
        return (O == "number" ? fi(y) && co(l, y.length) : O == "string" && l in y) ? hs(y[l], c) : !1;
      }
      function yg(c, l) {
        if (nr(c))
          return !1;
        var y = typeof c;
        return y == "number" || y == "symbol" || y == "boolean" || c == null || Mi(c) ? !0 : $t.test(c) || !vt.test(c) || l != null && c in qr(l);
      }
      function ZP(c) {
        var l = typeof c;
        return l == "string" || l == "number" || l == "symbol" || l == "boolean" ? c !== "__proto__" : c === null;
      }
      function wg(c) {
        var l = Hh(c), y = ee[l];
        if (typeof y != "function" || !(l in yr.prototype))
          return !1;
        if (c === y)
          return !0;
        var O = mg(y);
        return !!O && c === O[0];
      }
      function QP(c) {
        return !!_y && _y in c;
      }
      var eM = wh ? uo : $g;
      function ff(c) {
        var l = c && c.constructor, y = typeof l == "function" && l.prototype || Tc;
        return c === y;
      }
      function _w(c) {
        return c === c && !Zr(c);
      }
      function Ew(c, l) {
        return function(y) {
          return y == null ? !1 : y[c] === l && (l !== r || c in qr(y));
        };
      }
      function tM(c) {
        var l = Jh(c, function(O) {
          return y.size === h && y.clear(), O;
        }), y = l.cache;
        return l;
      }
      function rM(c, l) {
        var y = c[1], O = l[1], q = y | O, ne = q < (L | F | R), fe = O == R && y == W || O == R && y == K && c[7].length <= l[8] || O == (R | K) && l[7].length <= l[8] && y == W;
        if (!(ne || fe))
          return c;
        O & L && (c[2] = l[2], q |= y & L ? 0 : $);
        var ge = l[3];
        if (ge) {
          var we = c[3];
          c[3] = we ? sw(we, ge, l[4]) : ge, c[4] = we ? zo(c[3], d) : l[4];
        }
        return ge = l[5], ge && (we = c[5], c[5] = we ? ow(we, ge, l[6]) : ge, c[6] = we ? zo(c[5], d) : l[6]), ge = l[7], ge && (c[7] = ge), O & R && (c[8] = c[8] == null ? l[8] : Wn(c[8], l[8])), c[9] == null && (c[9] = l[9]), c[0] = l[0], c[1] = q, c;
      }
      function nM(c) {
        var l = [];
        if (c != null)
          for (var y in qr(c))
            l.push(y);
        return l;
      }
      function iM(c) {
        return _h.call(c);
      }
      function Sw(c, l, y) {
        return l = _n(l === r ? c.length - 1 : l, 0), function() {
          for (var O = arguments, q = -1, ne = _n(O.length - l, 0), fe = Ie(ne); ++q < ne; )
            fe[q] = O[l + q];
          q = -1;
          for (var ge = Ie(l + 1); ++q < l; )
            ge[q] = O[q];
          return ge[l] = y(fe), Pn(c, this, ge);
        };
      }
      function Aw(c, l) {
        return l.length < 2 ? c : Na(c, Hi(l, 0, -1));
      }
      function sM(c, l) {
        for (var y = c.length, O = Wn(l.length, y), q = ui(c); O--; ) {
          var ne = l[O];
          c[O] = co(ne, y) ? q[ne] : r;
        }
        return c;
      }
      function xg(c, l) {
        if (!(l === "constructor" && typeof c[l] == "function") && l != "__proto__")
          return c[l];
      }
      var Pw = Iw(Yy), lf = wA || function(c, l) {
        return xr.setTimeout(c, l);
      }, _g = Iw(IP);
      function Mw(c, l, y) {
        var O = l + "";
        return _g(c, JP(O, oM(VP(O), y)));
      }
      function Iw(c) {
        var l = 0, y = 0;
        return function() {
          var O = SA(), q = m - (O - y);
          if (y = O, q > 0) {
            if (++l >= S)
              return arguments[0];
          } else
            l = 0;
          return c.apply(r, arguments);
        };
      }
      function Kh(c, l) {
        var y = -1, O = c.length, q = O - 1;
        for (l = l === r ? O : l; ++y < l; ) {
          var ne = ig(y, q), fe = c[ne];
          c[ne] = c[y], c[y] = fe;
        }
        return c.length = l, c;
      }
      var Cw = tM(function(c) {
        var l = [];
        return c.charCodeAt(0) === 46 && l.push(""), c.replace(Ft, function(y, O, q, ne) {
          l.push(q ? ne.replace(he, "$1") : O || y);
        }), l;
      });
      function Ts(c) {
        if (typeof c == "string" || Mi(c))
          return c;
        var l = c + "";
        return l == "0" && 1 / c == -w ? "-0" : l;
      }
      function ka(c) {
        if (c != null) {
          try {
            return xh.call(c);
          } catch {
          }
          try {
            return c + "";
          } catch {
          }
        }
        return "";
      }
      function oM(c, l) {
        return Ui(ue, function(y) {
          var O = "_." + y[0];
          l & y[1] && !mh(c, O) && c.push(O);
        }), c.sort();
      }
      function Tw(c) {
        if (c instanceof yr)
          return c.clone();
        var l = new qi(c.__wrapped__, c.__chain__);
        return l.__actions__ = ui(c.__actions__), l.__index__ = c.__index__, l.__values__ = c.__values__, l;
      }
      function aM(c, l, y) {
        (y ? ti(c, l, y) : l === r) ? l = 1 : l = _n(ar(l), 0);
        var O = c == null ? 0 : c.length;
        if (!O || l < 1)
          return [];
        for (var q = 0, ne = 0, fe = Ie(Ih(O / l)); q < O; )
          fe[ne++] = Hi(c, q, q += l);
        return fe;
      }
      function cM(c) {
        for (var l = -1, y = c == null ? 0 : c.length, O = 0, q = []; ++l < y; ) {
          var ne = c[l];
          ne && (q[O++] = ne);
        }
        return q;
      }
      function uM() {
        var c = arguments.length;
        if (!c)
          return [];
        for (var l = Ie(c - 1), y = arguments[0], O = c; O--; )
          l[O - 1] = arguments[O];
        return qo(nr(y) ? ui(y) : [y], kn(l, 1));
      }
      var fM = lr(function(c, l) {
        return cn(c) ? sf(c, kn(l, 1, cn, !0)) : [];
      }), lM = lr(function(c, l) {
        var y = Wi(l);
        return cn(y) && (y = r), cn(c) ? sf(c, kn(l, 1, cn, !0), jt(y, 2)) : [];
      }), hM = lr(function(c, l) {
        var y = Wi(l);
        return cn(y) && (y = r), cn(c) ? sf(c, kn(l, 1, cn, !0), r, y) : [];
      });
      function dM(c, l, y) {
        var O = c == null ? 0 : c.length;
        return O ? (l = y || l === r ? 1 : ar(l), Hi(c, l < 0 ? 0 : l, O)) : [];
      }
      function pM(c, l, y) {
        var O = c == null ? 0 : c.length;
        return O ? (l = y || l === r ? 1 : ar(l), l = O - l, Hi(c, 0, l < 0 ? 0 : l)) : [];
      }
      function gM(c, l) {
        return c && c.length ? Bh(c, jt(l, 3), !0, !0) : [];
      }
      function mM(c, l) {
        return c && c.length ? Bh(c, jt(l, 3), !0) : [];
      }
      function vM(c, l, y, O) {
        var q = c == null ? 0 : c.length;
        return q ? (y && typeof y != "number" && ti(c, l, y) && (y = 0, O = q), uP(c, l, y, O)) : [];
      }
      function Rw(c, l, y) {
        var O = c == null ? 0 : c.length;
        if (!O)
          return -1;
        var q = y == null ? 0 : ar(y);
        return q < 0 && (q = _n(O + q, 0)), vh(c, jt(l, 3), q);
      }
      function Dw(c, l, y) {
        var O = c == null ? 0 : c.length;
        if (!O)
          return -1;
        var q = O - 1;
        return y !== r && (q = ar(y), q = y < 0 ? _n(O + q, 0) : Wn(q, O - 1)), vh(c, jt(l, 3), q, !0);
      }
      function Ow(c) {
        var l = c == null ? 0 : c.length;
        return l ? kn(c, 1) : [];
      }
      function bM(c) {
        var l = c == null ? 0 : c.length;
        return l ? kn(c, w) : [];
      }
      function yM(c, l) {
        var y = c == null ? 0 : c.length;
        return y ? (l = l === r ? 1 : ar(l), kn(c, l)) : [];
      }
      function wM(c) {
        for (var l = -1, y = c == null ? 0 : c.length, O = {}; ++l < y; ) {
          var q = c[l];
          O[q[0]] = q[1];
        }
        return O;
      }
      function Nw(c) {
        return c && c.length ? c[0] : r;
      }
      function xM(c, l, y) {
        var O = c == null ? 0 : c.length;
        if (!O)
          return -1;
        var q = y == null ? 0 : ar(y);
        return q < 0 && (q = _n(O + q, 0)), Pc(c, l, q);
      }
      function _M(c) {
        var l = c == null ? 0 : c.length;
        return l ? Hi(c, 0, -1) : [];
      }
      var EM = lr(function(c) {
        var l = Xr(c, ug);
        return l.length && l[0] === c[0] ? Qp(l) : [];
      }), SM = lr(function(c) {
        var l = Wi(c), y = Xr(c, ug);
        return l === Wi(y) ? l = r : y.pop(), y.length && y[0] === c[0] ? Qp(y, jt(l, 2)) : [];
      }), AM = lr(function(c) {
        var l = Wi(c), y = Xr(c, ug);
        return l = typeof l == "function" ? l : r, l && y.pop(), y.length && y[0] === c[0] ? Qp(y, r, l) : [];
      });
      function PM(c, l) {
        return c == null ? "" : _A.call(c, l);
      }
      function Wi(c) {
        var l = c == null ? 0 : c.length;
        return l ? c[l - 1] : r;
      }
      function MM(c, l, y) {
        var O = c == null ? 0 : c.length;
        if (!O)
          return -1;
        var q = O;
        return y !== r && (q = ar(y), q = q < 0 ? _n(O + q, 0) : Wn(q, O - 1)), l === l ? oA(c, l, q) : vh(c, py, q, !0);
      }
      function IM(c, l) {
        return c && c.length ? Wy(c, ar(l)) : r;
      }
      var CM = lr(Lw);
      function Lw(c, l) {
        return c && c.length && l && l.length ? ng(c, l) : c;
      }
      function TM(c, l, y) {
        return c && c.length && l && l.length ? ng(c, l, jt(y, 2)) : c;
      }
      function RM(c, l, y) {
        return c && c.length && l && l.length ? ng(c, l, r, y) : c;
      }
      var DM = ao(function(c, l) {
        var y = c == null ? 0 : c.length, O = Yp(c, l);
        return Gy(c, Xr(l, function(q) {
          return co(q, y) ? +q : q;
        }).sort(iw)), O;
      });
      function OM(c, l) {
        var y = [];
        if (!(c && c.length))
          return y;
        var O = -1, q = [], ne = c.length;
        for (l = jt(l, 3); ++O < ne; ) {
          var fe = c[O];
          l(fe, O, c) && (y.push(fe), q.push(O));
        }
        return Gy(c, q), y;
      }
      function Eg(c) {
        return c == null ? c : PA.call(c);
      }
      function NM(c, l, y) {
        var O = c == null ? 0 : c.length;
        return O ? (y && typeof y != "number" && ti(c, l, y) ? (l = 0, y = O) : (l = l == null ? 0 : ar(l), y = y === r ? O : ar(y)), Hi(c, l, y)) : [];
      }
      function LM(c, l) {
        return $h(c, l);
      }
      function kM(c, l, y) {
        return og(c, l, jt(y, 2));
      }
      function $M(c, l) {
        var y = c == null ? 0 : c.length;
        if (y) {
          var O = $h(c, l);
          if (O < y && hs(c[O], l))
            return O;
        }
        return -1;
      }
      function BM(c, l) {
        return $h(c, l, !0);
      }
      function FM(c, l, y) {
        return og(c, l, jt(y, 2), !0);
      }
      function UM(c, l) {
        var y = c == null ? 0 : c.length;
        if (y) {
          var O = $h(c, l, !0) - 1;
          if (hs(c[O], l))
            return O;
        }
        return -1;
      }
      function jM(c) {
        return c && c.length ? Jy(c) : [];
      }
      function qM(c, l) {
        return c && c.length ? Jy(c, jt(l, 2)) : [];
      }
      function zM(c) {
        var l = c == null ? 0 : c.length;
        return l ? Hi(c, 1, l) : [];
      }
      function HM(c, l, y) {
        return c && c.length ? (l = y || l === r ? 1 : ar(l), Hi(c, 0, l < 0 ? 0 : l)) : [];
      }
      function WM(c, l, y) {
        var O = c == null ? 0 : c.length;
        return O ? (l = y || l === r ? 1 : ar(l), l = O - l, Hi(c, l < 0 ? 0 : l, O)) : [];
      }
      function KM(c, l) {
        return c && c.length ? Bh(c, jt(l, 3), !1, !0) : [];
      }
      function VM(c, l) {
        return c && c.length ? Bh(c, jt(l, 3)) : [];
      }
      var GM = lr(function(c) {
        return Ko(kn(c, 1, cn, !0));
      }), YM = lr(function(c) {
        var l = Wi(c);
        return cn(l) && (l = r), Ko(kn(c, 1, cn, !0), jt(l, 2));
      }), JM = lr(function(c) {
        var l = Wi(c);
        return l = typeof l == "function" ? l : r, Ko(kn(c, 1, cn, !0), r, l);
      });
      function XM(c) {
        return c && c.length ? Ko(c) : [];
      }
      function ZM(c, l) {
        return c && c.length ? Ko(c, jt(l, 2)) : [];
      }
      function QM(c, l) {
        return l = typeof l == "function" ? l : r, c && c.length ? Ko(c, r, l) : [];
      }
      function Sg(c) {
        if (!(c && c.length))
          return [];
        var l = 0;
        return c = jo(c, function(y) {
          if (cn(y))
            return l = _n(y.length, l), !0;
        }), jp(l, function(y) {
          return Xr(c, Bp(y));
        });
      }
      function kw(c, l) {
        if (!(c && c.length))
          return [];
        var y = Sg(c);
        return l == null ? y : Xr(y, function(O) {
          return Pn(l, r, O);
        });
      }
      var eI = lr(function(c, l) {
        return cn(c) ? sf(c, l) : [];
      }), tI = lr(function(c) {
        return cg(jo(c, cn));
      }), rI = lr(function(c) {
        var l = Wi(c);
        return cn(l) && (l = r), cg(jo(c, cn), jt(l, 2));
      }), nI = lr(function(c) {
        var l = Wi(c);
        return l = typeof l == "function" ? l : r, cg(jo(c, cn), r, l);
      }), iI = lr(Sg);
      function sI(c, l) {
        return ew(c || [], l || [], nf);
      }
      function oI(c, l) {
        return ew(c || [], l || [], cf);
      }
      var aI = lr(function(c) {
        var l = c.length, y = l > 1 ? c[l - 1] : r;
        return y = typeof y == "function" ? (c.pop(), y) : r, kw(c, y);
      });
      function $w(c) {
        var l = ee(c);
        return l.__chain__ = !0, l;
      }
      function cI(c, l) {
        return l(c), c;
      }
      function Vh(c, l) {
        return l(c);
      }
      var uI = ao(function(c) {
        var l = c.length, y = l ? c[0] : 0, O = this.__wrapped__, q = function(ne) {
          return Yp(ne, c);
        };
        return l > 1 || this.__actions__.length || !(O instanceof yr) || !co(y) ? this.thru(q) : (O = O.slice(y, +y + (l ? 1 : 0)), O.__actions__.push({
          func: Vh,
          args: [q],
          thisArg: r
        }), new qi(O, this.__chain__).thru(function(ne) {
          return l && !ne.length && ne.push(r), ne;
        }));
      });
      function fI() {
        return $w(this);
      }
      function lI() {
        return new qi(this.value(), this.__chain__);
      }
      function hI() {
        this.__values__ === r && (this.__values__ = Xw(this.value()));
        var c = this.__index__ >= this.__values__.length, l = c ? r : this.__values__[this.__index__++];
        return { done: c, value: l };
      }
      function dI() {
        return this;
      }
      function pI(c) {
        for (var l, y = this; y instanceof Dh; ) {
          var O = Tw(y);
          O.__index__ = 0, O.__values__ = r, l ? q.__wrapped__ = O : l = O;
          var q = O;
          y = y.__wrapped__;
        }
        return q.__wrapped__ = c, l;
      }
      function gI() {
        var c = this.__wrapped__;
        if (c instanceof yr) {
          var l = c;
          return this.__actions__.length && (l = new yr(this)), l = l.reverse(), l.__actions__.push({
            func: Vh,
            args: [Eg],
            thisArg: r
          }), new qi(l, this.__chain__);
        }
        return this.thru(Eg);
      }
      function mI() {
        return Qy(this.__wrapped__, this.__actions__);
      }
      var vI = Fh(function(c, l, y) {
        Tr.call(c, y) ? ++c[y] : so(c, y, 1);
      });
      function bI(c, l, y) {
        var O = nr(c) ? hy : cP;
        return y && ti(c, l, y) && (l = r), O(c, jt(l, 3));
      }
      function yI(c, l) {
        var y = nr(c) ? jo : ky;
        return y(c, jt(l, 3));
      }
      var wI = fw(Rw), xI = fw(Dw);
      function _I(c, l) {
        return kn(Gh(c, l), 1);
      }
      function EI(c, l) {
        return kn(Gh(c, l), w);
      }
      function SI(c, l, y) {
        return y = y === r ? 1 : ar(y), kn(Gh(c, l), y);
      }
      function Bw(c, l) {
        var y = nr(c) ? Ui : Wo;
        return y(c, jt(l, 3));
      }
      function Fw(c, l) {
        var y = nr(c) ? z9 : Ly;
        return y(c, jt(l, 3));
      }
      var AI = Fh(function(c, l, y) {
        Tr.call(c, y) ? c[y].push(l) : so(c, y, [l]);
      });
      function PI(c, l, y, O) {
        c = fi(c) ? c : Bc(c), y = y && !O ? ar(y) : 0;
        var q = c.length;
        return y < 0 && (y = _n(q + y, 0)), Qh(c) ? y <= q && c.indexOf(l, y) > -1 : !!q && Pc(c, l, y) > -1;
      }
      var MI = lr(function(c, l, y) {
        var O = -1, q = typeof l == "function", ne = fi(c) ? Ie(c.length) : [];
        return Wo(c, function(fe) {
          ne[++O] = q ? Pn(l, fe, y) : of(fe, l, y);
        }), ne;
      }), II = Fh(function(c, l, y) {
        so(c, y, l);
      });
      function Gh(c, l) {
        var y = nr(c) ? Xr : qy;
        return y(c, jt(l, 3));
      }
      function CI(c, l, y, O) {
        return c == null ? [] : (nr(l) || (l = l == null ? [] : [l]), y = O ? r : y, nr(y) || (y = y == null ? [] : [y]), Ky(c, l, y));
      }
      var TI = Fh(function(c, l, y) {
        c[y ? 0 : 1].push(l);
      }, function() {
        return [[], []];
      });
      function RI(c, l, y) {
        var O = nr(c) ? kp : my, q = arguments.length < 3;
        return O(c, jt(l, 4), y, q, Wo);
      }
      function DI(c, l, y) {
        var O = nr(c) ? H9 : my, q = arguments.length < 3;
        return O(c, jt(l, 4), y, q, Ly);
      }
      function OI(c, l) {
        var y = nr(c) ? jo : ky;
        return y(c, Xh(jt(l, 3)));
      }
      function NI(c) {
        var l = nr(c) ? Ry : PP;
        return l(c);
      }
      function LI(c, l, y) {
        (y ? ti(c, l, y) : l === r) ? l = 1 : l = ar(l);
        var O = nr(c) ? nP : MP;
        return O(c, l);
      }
      function kI(c) {
        var l = nr(c) ? iP : CP;
        return l(c);
      }
      function $I(c) {
        if (c == null)
          return 0;
        if (fi(c))
          return Qh(c) ? Ic(c) : c.length;
        var l = Kn(c);
        return l == ie || l == Me ? c.size : tg(c).length;
      }
      function BI(c, l, y) {
        var O = nr(c) ? $p : TP;
        return y && ti(c, l, y) && (l = r), O(c, jt(l, 3));
      }
      var FI = lr(function(c, l) {
        if (c == null)
          return [];
        var y = l.length;
        return y > 1 && ti(c, l[0], l[1]) ? l = [] : y > 2 && ti(l[0], l[1], l[2]) && (l = [l[0]]), Ky(c, kn(l, 1), []);
      }), Yh = yA || function() {
        return xr.Date.now();
      };
      function UI(c, l) {
        if (typeof l != "function")
          throw new ji(o);
        return c = ar(c), function() {
          if (--c < 1)
            return l.apply(this, arguments);
        };
      }
      function Uw(c, l, y) {
        return l = y ? r : l, l = c && l == null ? c.length : l, oo(c, R, r, r, r, r, l);
      }
      function jw(c, l) {
        var y;
        if (typeof l != "function")
          throw new ji(o);
        return c = ar(c), function() {
          return --c > 0 && (y = l.apply(this, arguments)), c <= 1 && (l = r), y;
        };
      }
      var Ag = lr(function(c, l, y) {
        var O = L;
        if (y.length) {
          var q = zo(y, kc(Ag));
          O |= V;
        }
        return oo(c, O, l, y, q);
      }), qw = lr(function(c, l, y) {
        var O = L | F;
        if (y.length) {
          var q = zo(y, kc(qw));
          O |= V;
        }
        return oo(l, O, c, y, q);
      });
      function zw(c, l, y) {
        l = y ? r : l;
        var O = oo(c, W, r, r, r, r, r, l);
        return O.placeholder = zw.placeholder, O;
      }
      function Hw(c, l, y) {
        l = y ? r : l;
        var O = oo(c, z, r, r, r, r, r, l);
        return O.placeholder = Hw.placeholder, O;
      }
      function Ww(c, l, y) {
        var O, q, ne, fe, ge, we, He = 0, We = !1, Xe = !1, wt = !0;
        if (typeof c != "function")
          throw new ji(o);
        l = Ki(l) || 0, Zr(y) && (We = !!y.leading, Xe = "maxWait" in y, ne = Xe ? _n(Ki(y.maxWait) || 0, l) : ne, wt = "trailing" in y ? !!y.trailing : wt);
        function Ot(un) {
          var ds = O, lo = q;
          return O = q = r, He = un, fe = c.apply(lo, ds), fe;
        }
        function Wt(un) {
          return He = un, ge = lf(mr, l), We ? Ot(un) : fe;
        }
        function ur(un) {
          var ds = un - we, lo = un - He, f2 = l - ds;
          return Xe ? Wn(f2, ne - lo) : f2;
        }
        function Kt(un) {
          var ds = un - we, lo = un - He;
          return we === r || ds >= l || ds < 0 || Xe && lo >= ne;
        }
        function mr() {
          var un = Yh();
          if (Kt(un))
            return _r(un);
          ge = lf(mr, ur(un));
        }
        function _r(un) {
          return ge = r, wt && O ? Ot(un) : (O = q = r, fe);
        }
        function Ii() {
          ge !== r && tw(ge), He = 0, O = we = q = ge = r;
        }
        function ri() {
          return ge === r ? fe : _r(Yh());
        }
        function Ci() {
          var un = Yh(), ds = Kt(un);
          if (O = arguments, q = this, we = un, ds) {
            if (ge === r)
              return Wt(we);
            if (Xe)
              return tw(ge), ge = lf(mr, l), Ot(we);
          }
          return ge === r && (ge = lf(mr, l)), fe;
        }
        return Ci.cancel = Ii, Ci.flush = ri, Ci;
      }
      var jI = lr(function(c, l) {
        return Ny(c, 1, l);
      }), qI = lr(function(c, l, y) {
        return Ny(c, Ki(l) || 0, y);
      });
      function zI(c) {
        return oo(c, pe);
      }
      function Jh(c, l) {
        if (typeof c != "function" || l != null && typeof l != "function")
          throw new ji(o);
        var y = function() {
          var O = arguments, q = l ? l.apply(this, O) : O[0], ne = y.cache;
          if (ne.has(q))
            return ne.get(q);
          var fe = c.apply(this, O);
          return y.cache = ne.set(q, fe) || ne, fe;
        };
        return y.cache = new (Jh.Cache || io)(), y;
      }
      Jh.Cache = io;
      function Xh(c) {
        if (typeof c != "function")
          throw new ji(o);
        return function() {
          var l = arguments;
          switch (l.length) {
            case 0:
              return !c.call(this);
            case 1:
              return !c.call(this, l[0]);
            case 2:
              return !c.call(this, l[0], l[1]);
            case 3:
              return !c.call(this, l[0], l[1], l[2]);
          }
          return !c.apply(this, l);
        };
      }
      function HI(c) {
        return jw(2, c);
      }
      var WI = RP(function(c, l) {
        l = l.length == 1 && nr(l[0]) ? Xr(l[0], Ai(jt())) : Xr(kn(l, 1), Ai(jt()));
        var y = l.length;
        return lr(function(O) {
          for (var q = -1, ne = Wn(O.length, y); ++q < ne; )
            O[q] = l[q].call(this, O[q]);
          return Pn(c, this, O);
        });
      }), Pg = lr(function(c, l) {
        var y = zo(l, kc(Pg));
        return oo(c, V, r, l, y);
      }), Kw = lr(function(c, l) {
        var y = zo(l, kc(Kw));
        return oo(c, te, r, l, y);
      }), KI = ao(function(c, l) {
        return oo(c, K, r, r, r, l);
      });
      function VI(c, l) {
        if (typeof c != "function")
          throw new ji(o);
        return l = l === r ? l : ar(l), lr(c, l);
      }
      function GI(c, l) {
        if (typeof c != "function")
          throw new ji(o);
        return l = l == null ? 0 : _n(ar(l), 0), lr(function(y) {
          var O = y[l], q = Go(y, 0, l);
          return O && qo(q, O), Pn(c, this, q);
        });
      }
      function YI(c, l, y) {
        var O = !0, q = !0;
        if (typeof c != "function")
          throw new ji(o);
        return Zr(y) && (O = "leading" in y ? !!y.leading : O, q = "trailing" in y ? !!y.trailing : q), Ww(c, l, {
          leading: O,
          maxWait: l,
          trailing: q
        });
      }
      function JI(c) {
        return Uw(c, 1);
      }
      function XI(c, l) {
        return Pg(fg(l), c);
      }
      function ZI() {
        if (!arguments.length)
          return [];
        var c = arguments[0];
        return nr(c) ? c : [c];
      }
      function QI(c) {
        return zi(c, A);
      }
      function eC(c, l) {
        return l = typeof l == "function" ? l : r, zi(c, A, l);
      }
      function tC(c) {
        return zi(c, p | A);
      }
      function rC(c, l) {
        return l = typeof l == "function" ? l : r, zi(c, p | A, l);
      }
      function nC(c, l) {
        return l == null || Oy(c, l, Mn(l));
      }
      function hs(c, l) {
        return c === l || c !== c && l !== l;
      }
      var iC = zh(Zp), sC = zh(function(c, l) {
        return c >= l;
      }), $a = Fy(/* @__PURE__ */ function() {
        return arguments;
      }()) ? Fy : function(c) {
        return en(c) && Tr.call(c, "callee") && !Ay.call(c, "callee");
      }, nr = Ie.isArray, oC = Qn ? Ai(Qn) : pP;
      function fi(c) {
        return c != null && Zh(c.length) && !uo(c);
      }
      function cn(c) {
        return en(c) && fi(c);
      }
      function aC(c) {
        return c === !0 || c === !1 || en(c) && ei(c) == J;
      }
      var Yo = xA || $g, cC = us ? Ai(us) : gP;
      function uC(c) {
        return en(c) && c.nodeType === 1 && !hf(c);
      }
      function fC(c) {
        if (c == null)
          return !0;
        if (fi(c) && (nr(c) || typeof c == "string" || typeof c.splice == "function" || Yo(c) || $c(c) || $a(c)))
          return !c.length;
        var l = Kn(c);
        if (l == ie || l == Me)
          return !c.size;
        if (ff(c))
          return !tg(c).length;
        for (var y in c)
          if (Tr.call(c, y))
            return !1;
        return !0;
      }
      function lC(c, l) {
        return af(c, l);
      }
      function hC(c, l, y) {
        y = typeof y == "function" ? y : r;
        var O = y ? y(c, l) : r;
        return O === r ? af(c, l, r, y) : !!O;
      }
      function Mg(c) {
        if (!en(c))
          return !1;
        var l = ei(c);
        return l == X || l == T || typeof c.message == "string" && typeof c.name == "string" && !hf(c);
      }
      function dC(c) {
        return typeof c == "number" && My(c);
      }
      function uo(c) {
        if (!Zr(c))
          return !1;
        var l = ei(c);
        return l == re || l == de || l == Z || l == Ce;
      }
      function Vw(c) {
        return typeof c == "number" && c == ar(c);
      }
      function Zh(c) {
        return typeof c == "number" && c > -1 && c % 1 == 0 && c <= _;
      }
      function Zr(c) {
        var l = typeof c;
        return c != null && (l == "object" || l == "function");
      }
      function en(c) {
        return c != null && typeof c == "object";
      }
      var Gw = Fi ? Ai(Fi) : vP;
      function pC(c, l) {
        return c === l || eg(c, l, vg(l));
      }
      function gC(c, l, y) {
        return y = typeof y == "function" ? y : r, eg(c, l, vg(l), y);
      }
      function mC(c) {
        return Yw(c) && c != +c;
      }
      function vC(c) {
        if (eM(c))
          throw new er(s);
        return Uy(c);
      }
      function bC(c) {
        return c === null;
      }
      function yC(c) {
        return c == null;
      }
      function Yw(c) {
        return typeof c == "number" || en(c) && ei(c) == ce;
      }
      function hf(c) {
        if (!en(c) || ei(c) != Pe)
          return !1;
        var l = Ah(c);
        if (l === null)
          return !0;
        var y = Tr.call(l, "constructor") && l.constructor;
        return typeof y == "function" && y instanceof y && xh.call(y) == gA;
      }
      var Ig = Ms ? Ai(Ms) : bP;
      function wC(c) {
        return Vw(c) && c >= -_ && c <= _;
      }
      var Jw = Ju ? Ai(Ju) : yP;
      function Qh(c) {
        return typeof c == "string" || !nr(c) && en(c) && ei(c) == Ne;
      }
      function Mi(c) {
        return typeof c == "symbol" || en(c) && ei(c) == Ke;
      }
      var $c = Ca ? Ai(Ca) : wP;
      function xC(c) {
        return c === r;
      }
      function _C(c) {
        return en(c) && Kn(c) == qe;
      }
      function EC(c) {
        return en(c) && ei(c) == ze;
      }
      var SC = zh(rg), AC = zh(function(c, l) {
        return c <= l;
      });
      function Xw(c) {
        if (!c)
          return [];
        if (fi(c))
          return Qh(c) ? fs(c) : ui(c);
        if (Zu && c[Zu])
          return nA(c[Zu]());
        var l = Kn(c), y = l == ie ? zp : l == Me ? bh : Bc;
        return y(c);
      }
      function fo(c) {
        if (!c)
          return c === 0 ? c : 0;
        if (c = Ki(c), c === w || c === -w) {
          var l = c < 0 ? -1 : 1;
          return l * E;
        }
        return c === c ? c : 0;
      }
      function ar(c) {
        var l = fo(c), y = l % 1;
        return l === l ? y ? l - y : l : 0;
      }
      function Zw(c) {
        return c ? Oa(ar(c), 0, M) : 0;
      }
      function Ki(c) {
        if (typeof c == "number")
          return c;
        if (Mi(c))
          return v;
        if (Zr(c)) {
          var l = typeof c.valueOf == "function" ? c.valueOf() : c;
          c = Zr(l) ? l + "" : l;
        }
        if (typeof c != "string")
          return c === 0 ? c : +c;
        c = vy(c);
        var y = nt.test(c);
        return y || pt.test(c) ? rr(c.slice(2), y ? 2 : 8) : Re.test(c) ? v : +c;
      }
      function Qw(c) {
        return Cs(c, li(c));
      }
      function PC(c) {
        return c ? Oa(ar(c), -_, _) : c === 0 ? c : 0;
      }
      function Cr(c) {
        return c == null ? "" : Pi(c);
      }
      var MC = Nc(function(c, l) {
        if (ff(l) || fi(l)) {
          Cs(l, Mn(l), c);
          return;
        }
        for (var y in l)
          Tr.call(l, y) && nf(c, y, l[y]);
      }), e2 = Nc(function(c, l) {
        Cs(l, li(l), c);
      }), ed = Nc(function(c, l, y, O) {
        Cs(l, li(l), c, O);
      }), IC = Nc(function(c, l, y, O) {
        Cs(l, Mn(l), c, O);
      }), CC = ao(Yp);
      function TC(c, l) {
        var y = Oc(c);
        return l == null ? y : Dy(y, l);
      }
      var RC = lr(function(c, l) {
        c = qr(c);
        var y = -1, O = l.length, q = O > 2 ? l[2] : r;
        for (q && ti(l[0], l[1], q) && (O = 1); ++y < O; )
          for (var ne = l[y], fe = li(ne), ge = -1, we = fe.length; ++ge < we; ) {
            var He = fe[ge], We = c[He];
            (We === r || hs(We, Tc[He]) && !Tr.call(c, He)) && (c[He] = ne[He]);
          }
        return c;
      }), DC = lr(function(c) {
        return c.push(r, vw), Pn(t2, r, c);
      });
      function OC(c, l) {
        return dy(c, jt(l, 3), Is);
      }
      function NC(c, l) {
        return dy(c, jt(l, 3), Xp);
      }
      function LC(c, l) {
        return c == null ? c : Jp(c, jt(l, 3), li);
      }
      function kC(c, l) {
        return c == null ? c : $y(c, jt(l, 3), li);
      }
      function $C(c, l) {
        return c && Is(c, jt(l, 3));
      }
      function BC(c, l) {
        return c && Xp(c, jt(l, 3));
      }
      function FC(c) {
        return c == null ? [] : Lh(c, Mn(c));
      }
      function UC(c) {
        return c == null ? [] : Lh(c, li(c));
      }
      function Cg(c, l, y) {
        var O = c == null ? r : Na(c, l);
        return O === r ? y : O;
      }
      function jC(c, l) {
        return c != null && ww(c, l, fP);
      }
      function Tg(c, l) {
        return c != null && ww(c, l, lP);
      }
      var qC = hw(function(c, l, y) {
        l != null && typeof l.toString != "function" && (l = _h.call(l)), c[l] = y;
      }, Dg(hi)), zC = hw(function(c, l, y) {
        l != null && typeof l.toString != "function" && (l = _h.call(l)), Tr.call(c, l) ? c[l].push(y) : c[l] = [y];
      }, jt), HC = lr(of);
      function Mn(c) {
        return fi(c) ? Ty(c) : tg(c);
      }
      function li(c) {
        return fi(c) ? Ty(c, !0) : xP(c);
      }
      function WC(c, l) {
        var y = {};
        return l = jt(l, 3), Is(c, function(O, q, ne) {
          so(y, l(O, q, ne), O);
        }), y;
      }
      function KC(c, l) {
        var y = {};
        return l = jt(l, 3), Is(c, function(O, q, ne) {
          so(y, q, l(O, q, ne));
        }), y;
      }
      var VC = Nc(function(c, l, y) {
        kh(c, l, y);
      }), t2 = Nc(function(c, l, y, O) {
        kh(c, l, y, O);
      }), GC = ao(function(c, l) {
        var y = {};
        if (c == null)
          return y;
        var O = !1;
        l = Xr(l, function(ne) {
          return ne = Vo(ne, c), O || (O = ne.length > 1), ne;
        }), Cs(c, gg(c), y), O && (y = zi(y, p | x | A, qP));
        for (var q = l.length; q--; )
          ag(y, l[q]);
        return y;
      });
      function YC(c, l) {
        return r2(c, Xh(jt(l)));
      }
      var JC = ao(function(c, l) {
        return c == null ? {} : EP(c, l);
      });
      function r2(c, l) {
        if (c == null)
          return {};
        var y = Xr(gg(c), function(O) {
          return [O];
        });
        return l = jt(l), Vy(c, y, function(O, q) {
          return l(O, q[0]);
        });
      }
      function XC(c, l, y) {
        l = Vo(l, c);
        var O = -1, q = l.length;
        for (q || (q = 1, c = r); ++O < q; ) {
          var ne = c == null ? r : c[Ts(l[O])];
          ne === r && (O = q, ne = y), c = uo(ne) ? ne.call(c) : ne;
        }
        return c;
      }
      function ZC(c, l, y) {
        return c == null ? c : cf(c, l, y);
      }
      function QC(c, l, y, O) {
        return O = typeof O == "function" ? O : r, c == null ? c : cf(c, l, y, O);
      }
      var n2 = gw(Mn), i2 = gw(li);
      function eT(c, l, y) {
        var O = nr(c), q = O || Yo(c) || $c(c);
        if (l = jt(l, 4), y == null) {
          var ne = c && c.constructor;
          q ? y = O ? new ne() : [] : Zr(c) ? y = uo(ne) ? Oc(Ah(c)) : {} : y = {};
        }
        return (q ? Ui : Is)(c, function(fe, ge, we) {
          return l(y, fe, ge, we);
        }), y;
      }
      function tT(c, l) {
        return c == null ? !0 : ag(c, l);
      }
      function rT(c, l, y) {
        return c == null ? c : Zy(c, l, fg(y));
      }
      function nT(c, l, y, O) {
        return O = typeof O == "function" ? O : r, c == null ? c : Zy(c, l, fg(y), O);
      }
      function Bc(c) {
        return c == null ? [] : qp(c, Mn(c));
      }
      function iT(c) {
        return c == null ? [] : qp(c, li(c));
      }
      function sT(c, l, y) {
        return y === r && (y = l, l = r), y !== r && (y = Ki(y), y = y === y ? y : 0), l !== r && (l = Ki(l), l = l === l ? l : 0), Oa(Ki(c), l, y);
      }
      function oT(c, l, y) {
        return l = fo(l), y === r ? (y = l, l = 0) : y = fo(y), c = Ki(c), hP(c, l, y);
      }
      function aT(c, l, y) {
        if (y && typeof y != "boolean" && ti(c, l, y) && (l = y = r), y === r && (typeof l == "boolean" ? (y = l, l = r) : typeof c == "boolean" && (y = c, c = r)), c === r && l === r ? (c = 0, l = 1) : (c = fo(c), l === r ? (l = c, c = 0) : l = fo(l)), c > l) {
          var O = c;
          c = l, l = O;
        }
        if (y || c % 1 || l % 1) {
          var q = Iy();
          return Wn(c + q * (l - c + Ur("1e-" + ((q + "").length - 1))), l);
        }
        return ig(c, l);
      }
      var cT = Lc(function(c, l, y) {
        return l = l.toLowerCase(), c + (y ? s2(l) : l);
      });
      function s2(c) {
        return Rg(Cr(c).toLowerCase());
      }
      function o2(c) {
        return c = Cr(c), c && c.replace(et, Z9).replace(Op, "");
      }
      function uT(c, l, y) {
        c = Cr(c), l = Pi(l);
        var O = c.length;
        y = y === r ? O : Oa(ar(y), 0, O);
        var q = y;
        return y -= l.length, y >= 0 && c.slice(y, q) == l;
      }
      function fT(c) {
        return c = Cr(c), c && Ct.test(c) ? c.replace(Dt, Q9) : c;
      }
      function lT(c) {
        return c = Cr(c), c && Bt.test(c) ? c.replace(rt, "\\$&") : c;
      }
      var hT = Lc(function(c, l, y) {
        return c + (y ? "-" : "") + l.toLowerCase();
      }), dT = Lc(function(c, l, y) {
        return c + (y ? " " : "") + l.toLowerCase();
      }), pT = uw("toLowerCase");
      function gT(c, l, y) {
        c = Cr(c), l = ar(l);
        var O = l ? Ic(c) : 0;
        if (!l || O >= l)
          return c;
        var q = (l - O) / 2;
        return qh(Ch(q), y) + c + qh(Ih(q), y);
      }
      function mT(c, l, y) {
        c = Cr(c), l = ar(l);
        var O = l ? Ic(c) : 0;
        return l && O < l ? c + qh(l - O, y) : c;
      }
      function vT(c, l, y) {
        c = Cr(c), l = ar(l);
        var O = l ? Ic(c) : 0;
        return l && O < l ? qh(l - O, y) + c : c;
      }
      function bT(c, l, y) {
        return y || l == null ? l = 0 : l && (l = +l), AA(Cr(c).replace(k, ""), l || 0);
      }
      function yT(c, l, y) {
        return (y ? ti(c, l, y) : l === r) ? l = 1 : l = ar(l), sg(Cr(c), l);
      }
      function wT() {
        var c = arguments, l = Cr(c[0]);
        return c.length < 3 ? l : l.replace(c[1], c[2]);
      }
      var xT = Lc(function(c, l, y) {
        return c + (y ? "_" : "") + l.toLowerCase();
      });
      function _T(c, l, y) {
        return y && typeof y != "number" && ti(c, l, y) && (l = y = r), y = y === r ? M : y >>> 0, y ? (c = Cr(c), c && (typeof l == "string" || l != null && !Ig(l)) && (l = Pi(l), !l && Mc(c)) ? Go(fs(c), 0, y) : c.split(l, y)) : [];
      }
      var ET = Lc(function(c, l, y) {
        return c + (y ? " " : "") + Rg(l);
      });
      function ST(c, l, y) {
        return c = Cr(c), y = y == null ? 0 : Oa(ar(y), 0, c.length), l = Pi(l), c.slice(y, y + l.length) == l;
      }
      function AT(c, l, y) {
        var O = ee.templateSettings;
        y && ti(c, l, y) && (l = r), c = Cr(c), l = ed({}, l, O, mw);
        var q = ed({}, l.imports, O.imports, mw), ne = Mn(q), fe = qp(q, ne), ge, we, He = 0, We = l.interpolate || St, Xe = "__p += '", wt = Hp(
          (l.escape || St).source + "|" + We.source + "|" + (We === Nt ? xe : St).source + "|" + (l.evaluate || St).source + "|$",
          "g"
        ), Ot = "//# sourceURL=" + (Tr.call(l, "sourceURL") ? (l.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Np + "]") + `
`;
        c.replace(wt, function(Kt, mr, _r, Ii, ri, Ci) {
          return _r || (_r = Ii), Xe += c.slice(He, Ci).replace(Tt, eA), mr && (ge = !0, Xe += `' +
__e(` + mr + `) +
'`), ri && (we = !0, Xe += `';
` + ri + `;
__p += '`), _r && (Xe += `' +
((__t = (` + _r + `)) == null ? '' : __t) +
'`), He = Ci + Kt.length, Kt;
        }), Xe += `';
`;
        var Wt = Tr.call(l, "variable") && l.variable;
        if (!Wt)
          Xe = `with (obj) {
` + Xe + `
}
`;
        else if (se.test(Wt))
          throw new er(a);
        Xe = (we ? Xe.replace(Yt, "") : Xe).replace(Et, "$1").replace(Qt, "$1;"), Xe = "function(" + (Wt || "obj") + `) {
` + (Wt ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (ge ? ", __e = _.escape" : "") + (we ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Xe + `return __p
}`;
        var ur = c2(function() {
          return Pr(ne, Ot + "return " + Xe).apply(r, fe);
        });
        if (ur.source = Xe, Mg(ur))
          throw ur;
        return ur;
      }
      function PT(c) {
        return Cr(c).toLowerCase();
      }
      function MT(c) {
        return Cr(c).toUpperCase();
      }
      function IT(c, l, y) {
        if (c = Cr(c), c && (y || l === r))
          return vy(c);
        if (!c || !(l = Pi(l)))
          return c;
        var O = fs(c), q = fs(l), ne = by(O, q), fe = yy(O, q) + 1;
        return Go(O, ne, fe).join("");
      }
      function CT(c, l, y) {
        if (c = Cr(c), c && (y || l === r))
          return c.slice(0, xy(c) + 1);
        if (!c || !(l = Pi(l)))
          return c;
        var O = fs(c), q = yy(O, fs(l)) + 1;
        return Go(O, 0, q).join("");
      }
      function TT(c, l, y) {
        if (c = Cr(c), c && (y || l === r))
          return c.replace(k, "");
        if (!c || !(l = Pi(l)))
          return c;
        var O = fs(c), q = by(O, fs(l));
        return Go(O, q).join("");
      }
      function RT(c, l) {
        var y = _e, O = Y;
        if (Zr(l)) {
          var q = "separator" in l ? l.separator : q;
          y = "length" in l ? ar(l.length) : y, O = "omission" in l ? Pi(l.omission) : O;
        }
        c = Cr(c);
        var ne = c.length;
        if (Mc(c)) {
          var fe = fs(c);
          ne = fe.length;
        }
        if (y >= ne)
          return c;
        var ge = y - Ic(O);
        if (ge < 1)
          return O;
        var we = fe ? Go(fe, 0, ge).join("") : c.slice(0, ge);
        if (q === r)
          return we + O;
        if (fe && (ge += we.length - ge), Ig(q)) {
          if (c.slice(ge).search(q)) {
            var He, We = we;
            for (q.global || (q = Hp(q.source, Cr(Te.exec(q)) + "g")), q.lastIndex = 0; He = q.exec(We); )
              var Xe = He.index;
            we = we.slice(0, Xe === r ? ge : Xe);
          }
        } else if (c.indexOf(Pi(q), ge) != ge) {
          var wt = we.lastIndexOf(q);
          wt > -1 && (we = we.slice(0, wt));
        }
        return we + O;
      }
      function DT(c) {
        return c = Cr(c), c && kt.test(c) ? c.replace(Jt, aA) : c;
      }
      var OT = Lc(function(c, l, y) {
        return c + (y ? " " : "") + l.toUpperCase();
      }), Rg = uw("toUpperCase");
      function a2(c, l, y) {
        return c = Cr(c), l = y ? r : l, l === r ? rA(c) ? fA(c) : V9(c) : c.match(l) || [];
      }
      var c2 = lr(function(c, l) {
        try {
          return Pn(c, r, l);
        } catch (y) {
          return Mg(y) ? y : new er(y);
        }
      }), NT = ao(function(c, l) {
        return Ui(l, function(y) {
          y = Ts(y), so(c, y, Ag(c[y], c));
        }), c;
      });
      function LT(c) {
        var l = c == null ? 0 : c.length, y = jt();
        return c = l ? Xr(c, function(O) {
          if (typeof O[1] != "function")
            throw new ji(o);
          return [y(O[0]), O[1]];
        }) : [], lr(function(O) {
          for (var q = -1; ++q < l; ) {
            var ne = c[q];
            if (Pn(ne[0], this, O))
              return Pn(ne[1], this, O);
          }
        });
      }
      function kT(c) {
        return aP(zi(c, p));
      }
      function Dg(c) {
        return function() {
          return c;
        };
      }
      function $T(c, l) {
        return c == null || c !== c ? l : c;
      }
      var BT = lw(), FT = lw(!0);
      function hi(c) {
        return c;
      }
      function Og(c) {
        return jy(typeof c == "function" ? c : zi(c, p));
      }
      function UT(c) {
        return zy(zi(c, p));
      }
      function jT(c, l) {
        return Hy(c, zi(l, p));
      }
      var qT = lr(function(c, l) {
        return function(y) {
          return of(y, c, l);
        };
      }), zT = lr(function(c, l) {
        return function(y) {
          return of(c, y, l);
        };
      });
      function Ng(c, l, y) {
        var O = Mn(l), q = Lh(l, O);
        y == null && !(Zr(l) && (q.length || !O.length)) && (y = l, l = c, c = this, q = Lh(l, Mn(l)));
        var ne = !(Zr(y) && "chain" in y) || !!y.chain, fe = uo(c);
        return Ui(q, function(ge) {
          var we = l[ge];
          c[ge] = we, fe && (c.prototype[ge] = function() {
            var He = this.__chain__;
            if (ne || He) {
              var We = c(this.__wrapped__), Xe = We.__actions__ = ui(this.__actions__);
              return Xe.push({ func: we, args: arguments, thisArg: c }), We.__chain__ = He, We;
            }
            return we.apply(c, qo([this.value()], arguments));
          });
        }), c;
      }
      function HT() {
        return xr._ === this && (xr._ = mA), this;
      }
      function Lg() {
      }
      function WT(c) {
        return c = ar(c), lr(function(l) {
          return Wy(l, c);
        });
      }
      var KT = hg(Xr), VT = hg(hy), GT = hg($p);
      function u2(c) {
        return yg(c) ? Bp(Ts(c)) : SP(c);
      }
      function YT(c) {
        return function(l) {
          return c == null ? r : Na(c, l);
        };
      }
      var JT = dw(), XT = dw(!0);
      function kg() {
        return [];
      }
      function $g() {
        return !1;
      }
      function ZT() {
        return {};
      }
      function QT() {
        return "";
      }
      function eR() {
        return !0;
      }
      function tR(c, l) {
        if (c = ar(c), c < 1 || c > _)
          return [];
        var y = M, O = Wn(c, M);
        l = jt(l), c -= M;
        for (var q = jp(O, l); ++y < c; )
          l(y);
        return q;
      }
      function rR(c) {
        return nr(c) ? Xr(c, Ts) : Mi(c) ? [c] : ui(Cw(Cr(c)));
      }
      function nR(c) {
        var l = ++pA;
        return Cr(c) + l;
      }
      var iR = jh(function(c, l) {
        return c + l;
      }, 0), sR = dg("ceil"), oR = jh(function(c, l) {
        return c / l;
      }, 1), aR = dg("floor");
      function cR(c) {
        return c && c.length ? Nh(c, hi, Zp) : r;
      }
      function uR(c, l) {
        return c && c.length ? Nh(c, jt(l, 2), Zp) : r;
      }
      function fR(c) {
        return gy(c, hi);
      }
      function lR(c, l) {
        return gy(c, jt(l, 2));
      }
      function hR(c) {
        return c && c.length ? Nh(c, hi, rg) : r;
      }
      function dR(c, l) {
        return c && c.length ? Nh(c, jt(l, 2), rg) : r;
      }
      var pR = jh(function(c, l) {
        return c * l;
      }, 1), gR = dg("round"), mR = jh(function(c, l) {
        return c - l;
      }, 0);
      function vR(c) {
        return c && c.length ? Up(c, hi) : 0;
      }
      function bR(c, l) {
        return c && c.length ? Up(c, jt(l, 2)) : 0;
      }
      return ee.after = UI, ee.ary = Uw, ee.assign = MC, ee.assignIn = e2, ee.assignInWith = ed, ee.assignWith = IC, ee.at = CC, ee.before = jw, ee.bind = Ag, ee.bindAll = NT, ee.bindKey = qw, ee.castArray = ZI, ee.chain = $w, ee.chunk = aM, ee.compact = cM, ee.concat = uM, ee.cond = LT, ee.conforms = kT, ee.constant = Dg, ee.countBy = vI, ee.create = TC, ee.curry = zw, ee.curryRight = Hw, ee.debounce = Ww, ee.defaults = RC, ee.defaultsDeep = DC, ee.defer = jI, ee.delay = qI, ee.difference = fM, ee.differenceBy = lM, ee.differenceWith = hM, ee.drop = dM, ee.dropRight = pM, ee.dropRightWhile = gM, ee.dropWhile = mM, ee.fill = vM, ee.filter = yI, ee.flatMap = _I, ee.flatMapDeep = EI, ee.flatMapDepth = SI, ee.flatten = Ow, ee.flattenDeep = bM, ee.flattenDepth = yM, ee.flip = zI, ee.flow = BT, ee.flowRight = FT, ee.fromPairs = wM, ee.functions = FC, ee.functionsIn = UC, ee.groupBy = AI, ee.initial = _M, ee.intersection = EM, ee.intersectionBy = SM, ee.intersectionWith = AM, ee.invert = qC, ee.invertBy = zC, ee.invokeMap = MI, ee.iteratee = Og, ee.keyBy = II, ee.keys = Mn, ee.keysIn = li, ee.map = Gh, ee.mapKeys = WC, ee.mapValues = KC, ee.matches = UT, ee.matchesProperty = jT, ee.memoize = Jh, ee.merge = VC, ee.mergeWith = t2, ee.method = qT, ee.methodOf = zT, ee.mixin = Ng, ee.negate = Xh, ee.nthArg = WT, ee.omit = GC, ee.omitBy = YC, ee.once = HI, ee.orderBy = CI, ee.over = KT, ee.overArgs = WI, ee.overEvery = VT, ee.overSome = GT, ee.partial = Pg, ee.partialRight = Kw, ee.partition = TI, ee.pick = JC, ee.pickBy = r2, ee.property = u2, ee.propertyOf = YT, ee.pull = CM, ee.pullAll = Lw, ee.pullAllBy = TM, ee.pullAllWith = RM, ee.pullAt = DM, ee.range = JT, ee.rangeRight = XT, ee.rearg = KI, ee.reject = OI, ee.remove = OM, ee.rest = VI, ee.reverse = Eg, ee.sampleSize = LI, ee.set = ZC, ee.setWith = QC, ee.shuffle = kI, ee.slice = NM, ee.sortBy = FI, ee.sortedUniq = jM, ee.sortedUniqBy = qM, ee.split = _T, ee.spread = GI, ee.tail = zM, ee.take = HM, ee.takeRight = WM, ee.takeRightWhile = KM, ee.takeWhile = VM, ee.tap = cI, ee.throttle = YI, ee.thru = Vh, ee.toArray = Xw, ee.toPairs = n2, ee.toPairsIn = i2, ee.toPath = rR, ee.toPlainObject = Qw, ee.transform = eT, ee.unary = JI, ee.union = GM, ee.unionBy = YM, ee.unionWith = JM, ee.uniq = XM, ee.uniqBy = ZM, ee.uniqWith = QM, ee.unset = tT, ee.unzip = Sg, ee.unzipWith = kw, ee.update = rT, ee.updateWith = nT, ee.values = Bc, ee.valuesIn = iT, ee.without = eI, ee.words = a2, ee.wrap = XI, ee.xor = tI, ee.xorBy = rI, ee.xorWith = nI, ee.zip = iI, ee.zipObject = sI, ee.zipObjectDeep = oI, ee.zipWith = aI, ee.entries = n2, ee.entriesIn = i2, ee.extend = e2, ee.extendWith = ed, Ng(ee, ee), ee.add = iR, ee.attempt = c2, ee.camelCase = cT, ee.capitalize = s2, ee.ceil = sR, ee.clamp = sT, ee.clone = QI, ee.cloneDeep = tC, ee.cloneDeepWith = rC, ee.cloneWith = eC, ee.conformsTo = nC, ee.deburr = o2, ee.defaultTo = $T, ee.divide = oR, ee.endsWith = uT, ee.eq = hs, ee.escape = fT, ee.escapeRegExp = lT, ee.every = bI, ee.find = wI, ee.findIndex = Rw, ee.findKey = OC, ee.findLast = xI, ee.findLastIndex = Dw, ee.findLastKey = NC, ee.floor = aR, ee.forEach = Bw, ee.forEachRight = Fw, ee.forIn = LC, ee.forInRight = kC, ee.forOwn = $C, ee.forOwnRight = BC, ee.get = Cg, ee.gt = iC, ee.gte = sC, ee.has = jC, ee.hasIn = Tg, ee.head = Nw, ee.identity = hi, ee.includes = PI, ee.indexOf = xM, ee.inRange = oT, ee.invoke = HC, ee.isArguments = $a, ee.isArray = nr, ee.isArrayBuffer = oC, ee.isArrayLike = fi, ee.isArrayLikeObject = cn, ee.isBoolean = aC, ee.isBuffer = Yo, ee.isDate = cC, ee.isElement = uC, ee.isEmpty = fC, ee.isEqual = lC, ee.isEqualWith = hC, ee.isError = Mg, ee.isFinite = dC, ee.isFunction = uo, ee.isInteger = Vw, ee.isLength = Zh, ee.isMap = Gw, ee.isMatch = pC, ee.isMatchWith = gC, ee.isNaN = mC, ee.isNative = vC, ee.isNil = yC, ee.isNull = bC, ee.isNumber = Yw, ee.isObject = Zr, ee.isObjectLike = en, ee.isPlainObject = hf, ee.isRegExp = Ig, ee.isSafeInteger = wC, ee.isSet = Jw, ee.isString = Qh, ee.isSymbol = Mi, ee.isTypedArray = $c, ee.isUndefined = xC, ee.isWeakMap = _C, ee.isWeakSet = EC, ee.join = PM, ee.kebabCase = hT, ee.last = Wi, ee.lastIndexOf = MM, ee.lowerCase = dT, ee.lowerFirst = pT, ee.lt = SC, ee.lte = AC, ee.max = cR, ee.maxBy = uR, ee.mean = fR, ee.meanBy = lR, ee.min = hR, ee.minBy = dR, ee.stubArray = kg, ee.stubFalse = $g, ee.stubObject = ZT, ee.stubString = QT, ee.stubTrue = eR, ee.multiply = pR, ee.nth = IM, ee.noConflict = HT, ee.noop = Lg, ee.now = Yh, ee.pad = gT, ee.padEnd = mT, ee.padStart = vT, ee.parseInt = bT, ee.random = aT, ee.reduce = RI, ee.reduceRight = DI, ee.repeat = yT, ee.replace = wT, ee.result = XC, ee.round = gR, ee.runInContext = be, ee.sample = NI, ee.size = $I, ee.snakeCase = xT, ee.some = BI, ee.sortedIndex = LM, ee.sortedIndexBy = kM, ee.sortedIndexOf = $M, ee.sortedLastIndex = BM, ee.sortedLastIndexBy = FM, ee.sortedLastIndexOf = UM, ee.startCase = ET, ee.startsWith = ST, ee.subtract = mR, ee.sum = vR, ee.sumBy = bR, ee.template = AT, ee.times = tR, ee.toFinite = fo, ee.toInteger = ar, ee.toLength = Zw, ee.toLower = PT, ee.toNumber = Ki, ee.toSafeInteger = PC, ee.toString = Cr, ee.toUpper = MT, ee.trim = IT, ee.trimEnd = CT, ee.trimStart = TT, ee.truncate = RT, ee.unescape = DT, ee.uniqueId = nR, ee.upperCase = OT, ee.upperFirst = Rg, ee.each = Bw, ee.eachRight = Fw, ee.first = Nw, Ng(ee, function() {
        var c = {};
        return Is(ee, function(l, y) {
          Tr.call(ee.prototype, y) || (c[y] = l);
        }), c;
      }(), { chain: !1 }), ee.VERSION = n, Ui(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(c) {
        ee[c].placeholder = ee;
      }), Ui(["drop", "take"], function(c, l) {
        yr.prototype[c] = function(y) {
          y = y === r ? 1 : _n(ar(y), 0);
          var O = this.__filtered__ && !l ? new yr(this) : this.clone();
          return O.__filtered__ ? O.__takeCount__ = Wn(y, O.__takeCount__) : O.__views__.push({
            size: Wn(y, M),
            type: c + (O.__dir__ < 0 ? "Right" : "")
          }), O;
        }, yr.prototype[c + "Right"] = function(y) {
          return this.reverse()[c](y).reverse();
        };
      }), Ui(["filter", "map", "takeWhile"], function(c, l) {
        var y = l + 1, O = y == f || y == b;
        yr.prototype[c] = function(q) {
          var ne = this.clone();
          return ne.__iteratees__.push({
            iteratee: jt(q, 3),
            type: y
          }), ne.__filtered__ = ne.__filtered__ || O, ne;
        };
      }), Ui(["head", "last"], function(c, l) {
        var y = "take" + (l ? "Right" : "");
        yr.prototype[c] = function() {
          return this[y](1).value()[0];
        };
      }), Ui(["initial", "tail"], function(c, l) {
        var y = "drop" + (l ? "" : "Right");
        yr.prototype[c] = function() {
          return this.__filtered__ ? new yr(this) : this[y](1);
        };
      }), yr.prototype.compact = function() {
        return this.filter(hi);
      }, yr.prototype.find = function(c) {
        return this.filter(c).head();
      }, yr.prototype.findLast = function(c) {
        return this.reverse().find(c);
      }, yr.prototype.invokeMap = lr(function(c, l) {
        return typeof c == "function" ? new yr(this) : this.map(function(y) {
          return of(y, c, l);
        });
      }), yr.prototype.reject = function(c) {
        return this.filter(Xh(jt(c)));
      }, yr.prototype.slice = function(c, l) {
        c = ar(c);
        var y = this;
        return y.__filtered__ && (c > 0 || l < 0) ? new yr(y) : (c < 0 ? y = y.takeRight(-c) : c && (y = y.drop(c)), l !== r && (l = ar(l), y = l < 0 ? y.dropRight(-l) : y.take(l - c)), y);
      }, yr.prototype.takeRightWhile = function(c) {
        return this.reverse().takeWhile(c).reverse();
      }, yr.prototype.toArray = function() {
        return this.take(M);
      }, Is(yr.prototype, function(c, l) {
        var y = /^(?:filter|find|map|reject)|While$/.test(l), O = /^(?:head|last)$/.test(l), q = ee[O ? "take" + (l == "last" ? "Right" : "") : l], ne = O || /^find/.test(l);
        q && (ee.prototype[l] = function() {
          var fe = this.__wrapped__, ge = O ? [1] : arguments, we = fe instanceof yr, He = ge[0], We = we || nr(fe), Xe = function(mr) {
            var _r = q.apply(ee, qo([mr], ge));
            return O && wt ? _r[0] : _r;
          };
          We && y && typeof He == "function" && He.length != 1 && (we = We = !1);
          var wt = this.__chain__, Ot = !!this.__actions__.length, Wt = ne && !wt, ur = we && !Ot;
          if (!ne && We) {
            fe = ur ? fe : new yr(this);
            var Kt = c.apply(fe, ge);
            return Kt.__actions__.push({ func: Vh, args: [Xe], thisArg: r }), new qi(Kt, wt);
          }
          return Wt && ur ? c.apply(this, ge) : (Kt = this.thru(Xe), Wt ? O ? Kt.value()[0] : Kt.value() : Kt);
        });
      }), Ui(["pop", "push", "shift", "sort", "splice", "unshift"], function(c) {
        var l = yh[c], y = /^(?:push|sort|unshift)$/.test(c) ? "tap" : "thru", O = /^(?:pop|shift)$/.test(c);
        ee.prototype[c] = function() {
          var q = arguments;
          if (O && !this.__chain__) {
            var ne = this.value();
            return l.apply(nr(ne) ? ne : [], q);
          }
          return this[y](function(fe) {
            return l.apply(nr(fe) ? fe : [], q);
          });
        };
      }), Is(yr.prototype, function(c, l) {
        var y = ee[l];
        if (y) {
          var O = y.name + "";
          Tr.call(Dc, O) || (Dc[O] = []), Dc[O].push({ name: l, func: y });
        }
      }), Dc[Uh(r, F).name] = [{
        name: "wrapper",
        func: r
      }], yr.prototype.clone = DA, yr.prototype.reverse = OA, yr.prototype.value = NA, ee.prototype.at = uI, ee.prototype.chain = fI, ee.prototype.commit = lI, ee.prototype.next = hI, ee.prototype.plant = pI, ee.prototype.reverse = gI, ee.prototype.toJSON = ee.prototype.valueOf = ee.prototype.value = mI, ee.prototype.first = ee.prototype.head, Zu && (ee.prototype[Zu] = dI), ee;
    }, Cc = lA();
    an ? ((an.exports = Cc)._ = Cc, jr._ = Cc) : xr._ = Cc;
  }).call(gn);
})(l0, l0.exports);
var $V = l0.exports, O1 = { exports: {} };
(function(t, e) {
  var r = typeof self < "u" ? self : gn, n = function() {
    function s() {
      this.fetch = !1, this.DOMException = r.DOMException;
    }
    return s.prototype = r, new s();
  }();
  (function(s) {
    (function(o) {
      var a = {
        searchParams: "URLSearchParams" in s,
        iterable: "Symbol" in s && "iterator" in Symbol,
        blob: "FileReader" in s && "Blob" in s && function() {
          try {
            return new Blob(), !0;
          } catch {
            return !1;
          }
        }(),
        formData: "FormData" in s,
        arrayBuffer: "ArrayBuffer" in s
      };
      function u(f) {
        return f && DataView.prototype.isPrototypeOf(f);
      }
      if (a.arrayBuffer)
        var h = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ], d = ArrayBuffer.isView || function(f) {
          return f && h.indexOf(Object.prototype.toString.call(f)) > -1;
        };
      function p(f) {
        if (typeof f != "string" && (f = String(f)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(f))
          throw new TypeError("Invalid character in header field name");
        return f.toLowerCase();
      }
      function x(f) {
        return typeof f != "string" && (f = String(f)), f;
      }
      function A(f) {
        var g = {
          next: function() {
            var b = f.shift();
            return { done: b === void 0, value: b };
          }
        };
        return a.iterable && (g[Symbol.iterator] = function() {
          return g;
        }), g;
      }
      function I(f) {
        this.map = {}, f instanceof I ? f.forEach(function(g, b) {
          this.append(b, g);
        }, this) : Array.isArray(f) ? f.forEach(function(g) {
          this.append(g[0], g[1]);
        }, this) : f && Object.getOwnPropertyNames(f).forEach(function(g) {
          this.append(g, f[g]);
        }, this);
      }
      I.prototype.append = function(f, g) {
        f = p(f), g = x(g);
        var b = this.map[f];
        this.map[f] = b ? b + ", " + g : g;
      }, I.prototype.delete = function(f) {
        delete this.map[p(f)];
      }, I.prototype.get = function(f) {
        return f = p(f), this.has(f) ? this.map[f] : null;
      }, I.prototype.has = function(f) {
        return this.map.hasOwnProperty(p(f));
      }, I.prototype.set = function(f, g) {
        this.map[p(f)] = x(g);
      }, I.prototype.forEach = function(f, g) {
        for (var b in this.map)
          this.map.hasOwnProperty(b) && f.call(g, this.map[b], b, this);
      }, I.prototype.keys = function() {
        var f = [];
        return this.forEach(function(g, b) {
          f.push(b);
        }), A(f);
      }, I.prototype.values = function() {
        var f = [];
        return this.forEach(function(g) {
          f.push(g);
        }), A(f);
      }, I.prototype.entries = function() {
        var f = [];
        return this.forEach(function(g, b) {
          f.push([b, g]);
        }), A(f);
      }, a.iterable && (I.prototype[Symbol.iterator] = I.prototype.entries);
      function N(f) {
        if (f.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        f.bodyUsed = !0;
      }
      function L(f) {
        return new Promise(function(g, b) {
          f.onload = function() {
            g(f.result);
          }, f.onerror = function() {
            b(f.error);
          };
        });
      }
      function F(f) {
        var g = new FileReader(), b = L(g);
        return g.readAsArrayBuffer(f), b;
      }
      function $(f) {
        var g = new FileReader(), b = L(g);
        return g.readAsText(f), b;
      }
      function W(f) {
        for (var g = new Uint8Array(f), b = new Array(g.length), w = 0; w < g.length; w++)
          b[w] = String.fromCharCode(g[w]);
        return b.join("");
      }
      function z(f) {
        if (f.slice)
          return f.slice(0);
        var g = new Uint8Array(f.byteLength);
        return g.set(new Uint8Array(f)), g.buffer;
      }
      function V() {
        return this.bodyUsed = !1, this._initBody = function(f) {
          this._bodyInit = f, f ? typeof f == "string" ? this._bodyText = f : a.blob && Blob.prototype.isPrototypeOf(f) ? this._bodyBlob = f : a.formData && FormData.prototype.isPrototypeOf(f) ? this._bodyFormData = f : a.searchParams && URLSearchParams.prototype.isPrototypeOf(f) ? this._bodyText = f.toString() : a.arrayBuffer && a.blob && u(f) ? (this._bodyArrayBuffer = z(f.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : a.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(f) || d(f)) ? this._bodyArrayBuffer = z(f) : this._bodyText = f = Object.prototype.toString.call(f) : this._bodyText = "", this.headers.get("content-type") || (typeof f == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : a.searchParams && URLSearchParams.prototype.isPrototypeOf(f) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, a.blob && (this.blob = function() {
          var f = N(this);
          if (f)
            return f;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? N(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(F);
        }), this.text = function() {
          var f = N(this);
          if (f)
            return f;
          if (this._bodyBlob)
            return $(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(W(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, a.formData && (this.formData = function() {
          return this.text().then(pe);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var te = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function R(f) {
        var g = f.toUpperCase();
        return te.indexOf(g) > -1 ? g : f;
      }
      function K(f, g) {
        g = g || {};
        var b = g.body;
        if (f instanceof K) {
          if (f.bodyUsed)
            throw new TypeError("Already read");
          this.url = f.url, this.credentials = f.credentials, g.headers || (this.headers = new I(f.headers)), this.method = f.method, this.mode = f.mode, this.signal = f.signal, !b && f._bodyInit != null && (b = f._bodyInit, f.bodyUsed = !0);
        } else
          this.url = String(f);
        if (this.credentials = g.credentials || this.credentials || "same-origin", (g.headers || !this.headers) && (this.headers = new I(g.headers)), this.method = R(g.method || this.method || "GET"), this.mode = g.mode || this.mode || null, this.signal = g.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && b)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(b);
      }
      K.prototype.clone = function() {
        return new K(this, { body: this._bodyInit });
      };
      function pe(f) {
        var g = new FormData();
        return f.trim().split("&").forEach(function(b) {
          if (b) {
            var w = b.split("="), _ = w.shift().replace(/\+/g, " "), E = w.join("=").replace(/\+/g, " ");
            g.append(decodeURIComponent(_), decodeURIComponent(E));
          }
        }), g;
      }
      function _e(f) {
        var g = new I(), b = f.replace(/\r?\n[\t ]+/g, " ");
        return b.split(/\r?\n/).forEach(function(w) {
          var _ = w.split(":"), E = _.shift().trim();
          if (E) {
            var v = _.join(":").trim();
            g.append(E, v);
          }
        }), g;
      }
      V.call(K.prototype);
      function Y(f, g) {
        g || (g = {}), this.type = "default", this.status = g.status === void 0 ? 200 : g.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in g ? g.statusText : "OK", this.headers = new I(g.headers), this.url = g.url || "", this._initBody(f);
      }
      V.call(Y.prototype), Y.prototype.clone = function() {
        return new Y(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new I(this.headers),
          url: this.url
        });
      }, Y.error = function() {
        var f = new Y(null, { status: 0, statusText: "" });
        return f.type = "error", f;
      };
      var S = [301, 302, 303, 307, 308];
      Y.redirect = function(f, g) {
        if (S.indexOf(g) === -1)
          throw new RangeError("Invalid status code");
        return new Y(null, { status: g, headers: { location: f } });
      }, o.DOMException = s.DOMException;
      try {
        new o.DOMException();
      } catch {
        o.DOMException = function(g, b) {
          this.message = g, this.name = b;
          var w = Error(g);
          this.stack = w.stack;
        }, o.DOMException.prototype = Object.create(Error.prototype), o.DOMException.prototype.constructor = o.DOMException;
      }
      function m(f, g) {
        return new Promise(function(b, w) {
          var _ = new K(f, g);
          if (_.signal && _.signal.aborted)
            return w(new o.DOMException("Aborted", "AbortError"));
          var E = new XMLHttpRequest();
          function v() {
            E.abort();
          }
          E.onload = function() {
            var M = {
              status: E.status,
              statusText: E.statusText,
              headers: _e(E.getAllResponseHeaders() || "")
            };
            M.url = "responseURL" in E ? E.responseURL : M.headers.get("X-Request-URL");
            var P = "response" in E ? E.response : E.responseText;
            b(new Y(P, M));
          }, E.onerror = function() {
            w(new TypeError("Network request failed"));
          }, E.ontimeout = function() {
            w(new TypeError("Network request failed"));
          }, E.onabort = function() {
            w(new o.DOMException("Aborted", "AbortError"));
          }, E.open(_.method, _.url, !0), _.credentials === "include" ? E.withCredentials = !0 : _.credentials === "omit" && (E.withCredentials = !1), "responseType" in E && a.blob && (E.responseType = "blob"), _.headers.forEach(function(M, P) {
            E.setRequestHeader(P, M);
          }), _.signal && (_.signal.addEventListener("abort", v), E.onreadystatechange = function() {
            E.readyState === 4 && _.signal.removeEventListener("abort", v);
          }), E.send(typeof _._bodyInit > "u" ? null : _._bodyInit);
        });
      }
      return m.polyfill = !0, s.fetch || (s.fetch = m, s.Headers = I, s.Request = K, s.Response = Y), o.Headers = I, o.Request = K, o.Response = Y, o.fetch = m, Object.defineProperty(o, "__esModule", { value: !0 }), o;
    })({});
  })(n), n.fetch.ponyfill = !0, delete n.fetch.polyfill;
  var i = n;
  e = i.fetch, e.default = i.fetch, e.fetch = i.fetch, e.Headers = i.Headers, e.Request = i.Request, e.Response = i.Response, t.exports = e;
})(O1, O1.exports);
var BV = O1.exports;
const N3 = /* @__PURE__ */ ts(BV);
var FV = Object.defineProperty, UV = Object.defineProperties, jV = Object.getOwnPropertyDescriptors, L3 = Object.getOwnPropertySymbols, qV = Object.prototype.hasOwnProperty, zV = Object.prototype.propertyIsEnumerable, k3 = (t, e, r) => e in t ? FV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, $3 = (t, e) => {
  for (var r in e || (e = {})) qV.call(e, r) && k3(t, r, e[r]);
  if (L3) for (var r of L3(e)) zV.call(e, r) && k3(t, r, e[r]);
  return t;
}, B3 = (t, e) => UV(t, jV(e));
const HV = { Accept: "application/json", "Content-Type": "application/json" }, WV = "POST", F3 = { headers: HV, method: WV }, U3 = 10;
let Ss = class {
  constructor(e, r = !1) {
    if (this.url = e, this.disableProviderPing = r, this.events = new rs.EventEmitter(), this.isAvailable = !1, this.registering = !1, !o3(e)) throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
    this.url = e, this.disableProviderPing = r;
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    if (!this.isAvailable) throw new Error("Connection already closed");
    this.onClose();
  }
  async send(e) {
    this.isAvailable || await this.register();
    try {
      const r = No(e), n = await (await N3(this.url, B3($3({}, F3), { body: r }))).json();
      this.onPayload({ data: n });
    } catch (r) {
      this.onError(e.id, r);
    }
  }
  async register(e = this.url) {
    if (!o3(e)) throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
    if (this.registering) {
      const r = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= r || this.events.listenerCount("open") >= r) && this.events.setMaxListeners(r + 1), new Promise((n, i) => {
        this.events.once("register_error", (s) => {
          this.resetMaxListeners(), i(s);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.isAvailable > "u") return i(new Error("HTTP connection is missing or invalid"));
          n();
        });
      });
    }
    this.url = e, this.registering = !0;
    try {
      if (!this.disableProviderPing) {
        const r = No({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
        await N3(e, B3($3({}, F3), { body: r }));
      }
      this.onOpen();
    } catch (r) {
      const n = this.parseError(r);
      throw this.events.emit("register_error", n), this.onClose(), n;
    }
  }
  onOpen() {
    this.isAvailable = !0, this.registering = !1, this.events.emit("open");
  }
  onClose() {
    this.isAvailable = !1, this.registering = !1, this.events.emit("close");
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const r = typeof e.data == "string" ? oc(e.data) : e.data;
    this.events.emit("payload", r);
  }
  onError(e, r) {
    const n = this.parseError(r), i = n.message || n.toString(), s = np(e, i);
    this.events.emit("payload", s);
  }
  parseError(e, r = this.url) {
    return Y8(e, r, "HTTP");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > U3 && this.events.setMaxListeners(U3);
  }
};
const j3 = "error", KV = "wss://relay.walletconnect.org", VV = "wc", GV = "universal_provider", q3 = `${VV}@2:${GV}:`, yE = "https://rpc.walletconnect.org/v1/", Yc = "generic", YV = `${yE}bundler`, cs = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
var JV = Object.defineProperty, XV = Object.defineProperties, ZV = Object.getOwnPropertyDescriptors, z3 = Object.getOwnPropertySymbols, QV = Object.prototype.hasOwnProperty, eG = Object.prototype.propertyIsEnumerable, H3 = (t, e, r) => e in t ? JV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, fd = (t, e) => {
  for (var r in e || (e = {})) QV.call(e, r) && H3(t, r, e[r]);
  if (z3) for (var r of z3(e)) eG.call(e, r) && H3(t, r, e[r]);
  return t;
}, tG = (t, e) => XV(t, ZV(e));
function Ni(t, e, r) {
  var n;
  const i = fu(t);
  return ((n = e.rpcMap) == null ? void 0 : n[i.reference]) || `${yE}?chainId=${i.namespace}:${i.reference}&projectId=${r}`;
}
function wc(t) {
  return t.includes(":") ? t.split(":")[1] : t;
}
function wE(t) {
  return t.map((e) => `${e.split(":")[0]}:${e.split(":")[1]}`);
}
function rG(t, e) {
  const r = Object.keys(e.namespaces).filter((i) => i.includes(t));
  if (!r.length) return [];
  const n = [];
  return r.forEach((i) => {
    const s = e.namespaces[i].accounts;
    n.push(...s);
  }), n;
}
function bm(t = {}, e = {}) {
  const r = W3(t), n = W3(e);
  return $V.merge(r, n);
}
function W3(t) {
  var e, r, n, i;
  const s = {};
  if (!_l(t)) return s;
  for (const [o, a] of Object.entries(t)) {
    const u = ob(o) ? [o] : a.chains, h = a.methods || [], d = a.events || [], p = a.rpcMap || {}, x = $f(o);
    s[x] = tG(fd(fd({}, s[x]), a), { chains: Md(u, (e = s[x]) == null ? void 0 : e.chains), methods: Md(h, (r = s[x]) == null ? void 0 : r.methods), events: Md(d, (n = s[x]) == null ? void 0 : n.events), rpcMap: fd(fd({}, p), (i = s[x]) == null ? void 0 : i.rpcMap) });
  }
  return s;
}
function nG(t) {
  return t.includes(":") ? t.split(":")[2] : t;
}
function K3(t) {
  const e = {};
  for (const [r, n] of Object.entries(t)) {
    const i = n.methods || [], s = n.events || [], o = n.accounts || [], a = ob(r) ? [r] : n.chains ? n.chains : wE(n.accounts);
    e[r] = { chains: a, methods: i, events: s, accounts: o };
  }
  return e;
}
function ym(t) {
  return typeof t == "number" ? t : t.includes("0x") ? parseInt(t, 16) : (t = t.includes(":") ? t.split(":")[1] : t, isNaN(Number(t)) ? t : Number(t));
}
const xE = {}, Ar = (t) => xE[t], wm = (t, e) => {
  xE[t] = e;
};
class iG {
  constructor(e) {
    this.name = "polkadot", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = wc(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Ni(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new as(new Ss(n, Ar("disableProviderPing")));
  }
}
var sG = Object.defineProperty, oG = Object.defineProperties, aG = Object.getOwnPropertyDescriptors, V3 = Object.getOwnPropertySymbols, cG = Object.prototype.hasOwnProperty, uG = Object.prototype.propertyIsEnumerable, G3 = (t, e, r) => e in t ? sG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Y3 = (t, e) => {
  for (var r in e || (e = {})) cG.call(e, r) && G3(t, r, e[r]);
  if (V3) for (var r of V3(e)) uG.call(e, r) && G3(t, r, e[r]);
  return t;
}, J3 = (t, e) => oG(t, aG(e));
class fG {
  constructor(e) {
    this.name = "eip155", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(e) {
    switch (e.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(e);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(e);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(e);
    }
    return this.namespace.methods.includes(e.request.method) ? await this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(parseInt(e), r), this.chainId = parseInt(e), this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  createHttpProvider(e, r) {
    const n = r || Ni(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new as(new Ss(n, Ar("disableProviderPing")));
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = parseInt(wc(r));
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const e = this.chainId, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  async handleSwitchChain(e) {
    var r, n;
    let i = e.request.params ? (r = e.request.params[0]) == null ? void 0 : r.chainId : "0x0";
    i = i.startsWith("0x") ? i : `0x${i}`;
    const s = parseInt(i, 16);
    if (this.isChainApproved(s)) this.setDefaultChain(`${s}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: e.topic, request: { method: e.request.method, params: [{ chainId: i }] }, chainId: (n = this.namespace.chains) == null ? void 0 : n[0] }), this.setDefaultChain(`${s}`);
    else throw new Error(`Failed to switch to chain 'eip155:${s}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(e) {
    return this.namespace.chains.includes(`${this.name}:${e}`);
  }
  async getCapabilities(e) {
    var r, n, i;
    const s = (n = (r = e.request) == null ? void 0 : r.params) == null ? void 0 : n[0];
    if (!s) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const o = this.client.session.get(e.topic), a = ((i = o == null ? void 0 : o.sessionProperties) == null ? void 0 : i.capabilities) || {};
    if (a != null && a[s]) return a == null ? void 0 : a[s];
    const u = await this.client.request(e);
    try {
      await this.client.session.update(e.topic, { sessionProperties: J3(Y3({}, o.sessionProperties || {}), { capabilities: J3(Y3({}, a || {}), { [s]: u }) }) });
    } catch (h) {
      console.warn("Failed to update session with capabilities", h);
    }
    return u;
  }
  async getCallStatus(e) {
    var r, n;
    const i = this.client.session.get(e.topic), s = (r = i.sessionProperties) == null ? void 0 : r.bundler_name;
    if (s) {
      const a = this.getBundlerUrl(e.chainId, s);
      try {
        return await this.getUserOperationReceipt(a, e);
      } catch (u) {
        console.warn("Failed to fetch call status from bundler", u, a);
      }
    }
    const o = (n = i.sessionProperties) == null ? void 0 : n.bundler_url;
    if (o) try {
      return await this.getUserOperationReceipt(o, e);
    } catch (a) {
      console.warn("Failed to fetch call status from custom bundler", a, o);
    }
    if (this.namespace.methods.includes(e.request.method)) return await this.client.request(e);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(e, r) {
    var n;
    const i = new URL(e), s = await fetch(i, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(fa("eth_getUserOperationReceipt", [(n = r.request.params) == null ? void 0 : n[0]])) });
    if (!s.ok) throw new Error(`Failed to fetch user operation receipt - ${s.status}`);
    return await s.json();
  }
  getBundlerUrl(e, r) {
    return `${YV}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${r}`;
  }
}
class lG {
  constructor(e) {
    this.name = "solana", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = wc(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Ni(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new as(new Ss(n, Ar("disableProviderPing")));
  }
}
let hG = class {
  constructor(e) {
    this.name = "cosmos", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = wc(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Ni(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new as(new Ss(n, Ar("disableProviderPing")));
  }
}, dG = class {
  constructor(e) {
    this.name = "algorand", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    if (!this.httpProviders[e]) {
      const n = r || Ni(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
      if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, n);
    }
    this.chainId = e, this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      e[r] = this.createHttpProvider(r, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Ni(e, this.namespace, this.client.core.projectId);
    return typeof n > "u" ? void 0 : new as(new Ss(n, Ar("disableProviderPing")));
  }
}, pG = class {
  constructor(e) {
    this.name = "cip34", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      const n = this.getCardanoRPCUrl(r), i = wc(r);
      e[i] = this.createHttpProvider(i, n);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  getCardanoRPCUrl(e) {
    const r = this.namespace.rpcMap;
    if (r) return r[e];
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || this.getCardanoRPCUrl(e);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new as(new Ss(n, Ar("disableProviderPing")));
  }
}, gG = class {
  constructor(e) {
    this.name = "elrond", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = wc(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Ni(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new as(new Ss(n, Ar("disableProviderPing")));
  }
};
class mG {
  constructor(e) {
    this.name = "multiversx", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = wc(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Ni(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new as(new Ss(n, Ar("disableProviderPing")));
  }
}
let vG = class {
  constructor(e) {
    this.name = "near", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    if (this.chainId = e, !this.httpProviders[e]) {
      const n = r || Ni(`${this.name}:${e}`, this.namespace);
      if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, n);
    }
    this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      e[r] = this.createHttpProvider(r, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Ni(e, this.namespace);
    return typeof n > "u" ? void 0 : new as(new Ss(n, Ar("disableProviderPing")));
  }
};
class bG {
  constructor(e) {
    this.name = "tezos", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    if (this.chainId = e, !this.httpProviders[e]) {
      const n = r || Ni(`${this.name}:${e}`, this.namespace);
      if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, n);
    }
    this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      e[r] = this.createHttpProvider(r);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Ni(e, this.namespace);
    return typeof n > "u" ? void 0 : new as(new Ss(n));
  }
}
class yG {
  constructor(e) {
    this.name = Yc, this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(e.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(e.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(e.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(e.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider(e.chainId).request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var e, r;
    const n = {};
    return (r = (e = this.namespace) == null ? void 0 : e.accounts) == null || r.forEach((i) => {
      const s = fu(i);
      n[`${s.namespace}:${s.reference}`] = this.createHttpProvider(i);
    }), n;
  }
  getHttpProvider(e) {
    const r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Ni(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new as(new Ss(n, Ar("disableProviderPing")));
  }
}
var wG = Object.defineProperty, xG = Object.defineProperties, _G = Object.getOwnPropertyDescriptors, X3 = Object.getOwnPropertySymbols, EG = Object.prototype.hasOwnProperty, SG = Object.prototype.propertyIsEnumerable, Z3 = (t, e, r) => e in t ? wG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, ld = (t, e) => {
  for (var r in e || (e = {})) EG.call(e, r) && Z3(t, r, e[r]);
  if (X3) for (var r of X3(e)) SG.call(e, r) && Z3(t, r, e[r]);
  return t;
}, xm = (t, e) => xG(t, _G(e));
let _E = class EE {
  constructor(e) {
    this.events = new Lv(), this.rpcProviders = {}, this.shouldAbortPairingAttempt = !1, this.maxPairingAttempts = 10, this.disableProviderPing = !1, this.providerOpts = e, this.logger = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : jl($0({ level: (e == null ? void 0 : e.logger) || j3 })), this.disableProviderPing = (e == null ? void 0 : e.disableProviderPing) || !1;
  }
  static async init(e) {
    const r = new EE(e);
    return await r.initialize(), r;
  }
  async request(e, r, n) {
    const [i, s] = this.validateChain(r);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(i).request({ request: ld({}, e), chainId: `${i}:${s}`, topic: this.session.topic, expiry: n });
  }
  sendAsync(e, r, n, i) {
    const s = (/* @__PURE__ */ new Date()).getTime();
    this.request(e, n, i).then((o) => r(null, rp(s, o))).catch((o) => r(o, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var e;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (e = this.session) == null ? void 0 : e.topic, reason: Or("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(e) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(e), await this.cleanupPendingPairings(), !e.skipPairing) return await this.pair(e.pairingTopic);
  }
  async authenticate(e, r) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(e), await this.cleanupPendingPairings();
    const { uri: n, response: i } = await this.client.authenticate(e, r);
    n && (this.uri = n, this.events.emit("display_uri", n));
    const s = await i();
    if (this.session = s.session, this.session) {
      const o = K3(this.session.namespaces);
      this.namespaces = bm(this.namespaces, o), this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return s;
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  get isWalletConnect() {
    return !0;
  }
  async pair(e) {
    this.shouldAbortPairingAttempt = !1;
    let r = 0;
    do {
      if (this.shouldAbortPairingAttempt) throw new Error("Pairing aborted");
      if (r >= this.maxPairingAttempts) throw new Error("Max auto pairing attempts reached");
      const { uri: n, approval: i } = await this.client.connect({ pairingTopic: e, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties });
      n && (this.uri = n, this.events.emit("display_uri", n)), await i().then((s) => {
        this.session = s;
        const o = K3(s.namespaces);
        this.namespaces = bm(this.namespaces, o), this.persist("namespaces", this.namespaces);
      }).catch((s) => {
        if (s.message !== bE) throw s;
        r++;
      });
    } while (!this.session);
    return this.onConnect(), this.session;
  }
  setDefaultChain(e, r) {
    try {
      if (!this.session) return;
      const [n, i] = this.validateChain(e), s = this.getProvider(n);
      s.name === Yc ? s.setDefaultChain(`${n}:${i}`, r) : s.setDefaultChain(i, r);
    } catch (n) {
      if (!/Please call connect/.test(n.message)) throw n;
    }
  }
  async cleanupPendingPairings(e = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const r = this.client.pairing.getAll();
    if (fc(r)) {
      for (const n of r) e.deletePairings ? this.client.core.expirer.set(n.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(n.topic);
      this.logger.info(`Inactive pairings cleared: ${r.length}`);
    }
  }
  abortPairingAttempt() {
    this.shouldAbortPairingAttempt = !0;
  }
  async checkStorage() {
    if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
      const e = this.client.session.keys.length - 1;
      this.session = this.client.session.get(this.client.session.keys[e]), this.createProviders();
    }
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    this.client = this.providerOpts.client || await hb.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || j3, relayUrl: this.providerOpts.relayUrl || KV, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const e = [...new Set(Object.keys(this.session.namespaces).map((r) => $f(r)))];
    wm("client", this.client), wm("events", this.events), wm("disableProviderPing", this.disableProviderPing), e.forEach((r) => {
      if (!this.session) return;
      const n = rG(r, this.session), i = wE(n), s = bm(this.namespaces, this.optionalNamespaces), o = xm(ld({}, s[r]), { accounts: n, chains: i });
      switch (r) {
        case "eip155":
          this.rpcProviders[r] = new fG({ namespace: o });
          break;
        case "algorand":
          this.rpcProviders[r] = new dG({ namespace: o });
          break;
        case "solana":
          this.rpcProviders[r] = new lG({ namespace: o });
          break;
        case "cosmos":
          this.rpcProviders[r] = new hG({ namespace: o });
          break;
        case "polkadot":
          this.rpcProviders[r] = new iG({ namespace: o });
          break;
        case "cip34":
          this.rpcProviders[r] = new pG({ namespace: o });
          break;
        case "elrond":
          this.rpcProviders[r] = new gG({ namespace: o });
          break;
        case "multiversx":
          this.rpcProviders[r] = new mG({ namespace: o });
          break;
        case "near":
          this.rpcProviders[r] = new vG({ namespace: o });
          break;
        case "tezos":
          this.rpcProviders[r] = new bG({ namespace: o });
          break;
        default:
          this.rpcProviders[Yc] ? this.rpcProviders[Yc].updateNamespace(o) : this.rpcProviders[Yc] = new yG({ namespace: o });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (e) => {
      this.events.emit("session_ping", e);
    }), this.client.on("session_event", (e) => {
      const { params: r } = e, { event: n } = r;
      if (n.name === "accountsChanged") {
        const i = n.data;
        i && fc(i) && this.events.emit("accountsChanged", i.map(nG));
      } else if (n.name === "chainChanged") {
        const i = r.chainId, s = r.event.data, o = $f(i), a = ym(i) !== ym(s) ? `${o}:${ym(s)}` : i;
        this.onChainChanged(a);
      } else this.events.emit(n.name, n.data);
      this.events.emit("session_event", e);
    }), this.client.on("session_update", ({ topic: e, params: r }) => {
      var n;
      const { namespaces: i } = r, s = (n = this.client) == null ? void 0 : n.session.get(e);
      this.session = xm(ld({}, s), { namespaces: i }), this.onSessionUpdate(), this.events.emit("session_update", { topic: e, params: r });
    }), this.client.on("session_delete", async (e) => {
      await this.cleanup(), this.events.emit("session_delete", e), this.events.emit("disconnect", xm(ld({}, Or("USER_DISCONNECTED")), { data: e.topic }));
    }), this.on(cs.DEFAULT_CHAIN_CHANGED, (e) => {
      this.onChainChanged(e, !0);
    });
  }
  getProvider(e) {
    return this.rpcProviders[e] || this.rpcProviders[Yc];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((e) => {
      var r;
      this.getProvider(e).updateNamespace((r = this.session) == null ? void 0 : r.namespaces[e]);
    });
  }
  setNamespaces(e) {
    const { namespaces: r, optionalNamespaces: n, sessionProperties: i } = e;
    r && Object.keys(r).length && (this.namespaces = r), n && Object.keys(n).length && (this.optionalNamespaces = n), this.sessionProperties = i, this.persist("namespaces", r), this.persist("optionalNamespaces", n);
  }
  validateChain(e) {
    const [r, n] = (e == null ? void 0 : e.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [r, n];
    if (r && !Object.keys(this.namespaces || {}).map((o) => $f(o)).includes(r)) throw new Error(`Namespace '${r}' is not configured. Please call connect() first with namespace config.`);
    if (r && n) return [r, n];
    const i = $f(Object.keys(this.namespaces)[0]), s = this.rpcProviders[i].getDefaultChain();
    return [i, s];
  }
  async requestAccounts() {
    const [e] = this.validateChain();
    return await this.getProvider(e).requestAccounts();
  }
  onChainChanged(e, r = !1) {
    if (!this.namespaces) return;
    const [n, i] = this.validateChain(e);
    i && (r || this.getProvider(n).setDefaultChain(i), this.namespaces[n] ? this.namespaces[n].defaultChain = i : this.namespaces[`${n}:${i}`] ? this.namespaces[`${n}:${i}`].defaultChain = i : this.namespaces[`${n}:${i}`] = { defaultChain: i }, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", i));
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({ deletePairings: !0 });
  }
  persist(e, r) {
    this.client.core.storage.setItem(`${q3}/${e}`, r);
  }
  async getFromStore(e) {
    return await this.client.core.storage.getItem(`${q3}/${e}`);
  }
};
const AG = _E;
function PG() {
  return new Promise((t) => {
    const e = [];
    let r;
    window.addEventListener("eip6963:announceProvider", (n) => {
      const { detail: i } = n;
      r && clearTimeout(r), e.push(i), r = setTimeout(() => t(e), 200);
    }), r = setTimeout(() => t(e), 200), window.dispatchEvent(new Event("eip6963:requestProvider"));
  });
}
class Zs {
  constructor(e, r) {
    this.scope = e, this.module = r;
  }
  storeObject(e, r) {
    this.setItem(e, JSON.stringify(r));
  }
  loadObject(e) {
    const r = this.getItem(e);
    return r ? JSON.parse(r) : void 0;
  }
  setItem(e, r) {
    localStorage.setItem(this.scopedKey(e), r);
  }
  getItem(e) {
    return localStorage.getItem(this.scopedKey(e));
  }
  removeItem(e) {
    localStorage.removeItem(this.scopedKey(e));
  }
  clear() {
    const e = this.scopedKey(""), r = [];
    for (let n = 0; n < localStorage.length; n++) {
      const i = localStorage.key(n);
      typeof i == "string" && i.startsWith(e) && r.push(i);
    }
    r.forEach((n) => localStorage.removeItem(n));
  }
  scopedKey(e) {
    return `-${this.scope}${this.module ? `:${this.module}` : ""}:${e}`;
  }
  static clearAll() {
    new Zs("CBWSDK").clear(), new Zs("walletlink").clear();
  }
}
const fn = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901,
    unsupportedChain: 4902
  }
}, N1 = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  4001: {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  4100: {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  4200: {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  4900: {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  4901: {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  },
  4902: {
    standard: "EIP-3085",
    message: "Unrecognized chain ID."
  }
}, SE = "Unspecified error message.", MG = "Unspecified server error.";
function db(t, e = SE) {
  if (t && Number.isInteger(t)) {
    const r = t.toString();
    if (L1(N1, r))
      return N1[r].message;
    if (AE(t))
      return MG;
  }
  return e;
}
function IG(t) {
  if (!Number.isInteger(t))
    return !1;
  const e = t.toString();
  return !!(N1[e] || AE(t));
}
function CG(t, { shouldIncludeStack: e = !1 } = {}) {
  const r = {};
  if (t && typeof t == "object" && !Array.isArray(t) && L1(t, "code") && IG(t.code)) {
    const n = t;
    r.code = n.code, n.message && typeof n.message == "string" ? (r.message = n.message, L1(n, "data") && (r.data = n.data)) : (r.message = db(r.code), r.data = { originalError: Q3(t) });
  } else
    r.code = fn.rpc.internal, r.message = e6(t, "message") ? t.message : SE, r.data = { originalError: Q3(t) };
  return e && (r.stack = e6(t, "stack") ? t.stack : void 0), r;
}
function AE(t) {
  return t >= -32099 && t <= -32e3;
}
function Q3(t) {
  return t && typeof t == "object" && !Array.isArray(t) ? Object.assign({}, t) : t;
}
function L1(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function e6(t, e) {
  return typeof t == "object" && t !== null && e in t && typeof t[e] == "string";
}
const Sr = {
  rpc: {
    parse: (t) => Gi(fn.rpc.parse, t),
    invalidRequest: (t) => Gi(fn.rpc.invalidRequest, t),
    invalidParams: (t) => Gi(fn.rpc.invalidParams, t),
    methodNotFound: (t) => Gi(fn.rpc.methodNotFound, t),
    internal: (t) => Gi(fn.rpc.internal, t),
    server: (t) => {
      if (!t || typeof t != "object" || Array.isArray(t))
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      const { code: e } = t;
      if (!Number.isInteger(e) || e > -32005 || e < -32099)
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      return Gi(e, t);
    },
    invalidInput: (t) => Gi(fn.rpc.invalidInput, t),
    resourceNotFound: (t) => Gi(fn.rpc.resourceNotFound, t),
    resourceUnavailable: (t) => Gi(fn.rpc.resourceUnavailable, t),
    transactionRejected: (t) => Gi(fn.rpc.transactionRejected, t),
    methodNotSupported: (t) => Gi(fn.rpc.methodNotSupported, t),
    limitExceeded: (t) => Gi(fn.rpc.limitExceeded, t)
  },
  provider: {
    userRejectedRequest: (t) => Wc(fn.provider.userRejectedRequest, t),
    unauthorized: (t) => Wc(fn.provider.unauthorized, t),
    unsupportedMethod: (t) => Wc(fn.provider.unsupportedMethod, t),
    disconnected: (t) => Wc(fn.provider.disconnected, t),
    chainDisconnected: (t) => Wc(fn.provider.chainDisconnected, t),
    unsupportedChain: (t) => Wc(fn.provider.unsupportedChain, t),
    custom: (t) => {
      if (!t || typeof t != "object" || Array.isArray(t))
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      const { code: e, message: r, data: n } = t;
      if (!r || typeof r != "string")
        throw new Error('"message" must be a nonempty string');
      return new IE(e, r, n);
    }
  }
};
function Gi(t, e) {
  const [r, n] = PE(e);
  return new ME(t, r || db(t), n);
}
function Wc(t, e) {
  const [r, n] = PE(e);
  return new IE(t, r || db(t), n);
}
function PE(t) {
  if (t) {
    if (typeof t == "string")
      return [t];
    if (typeof t == "object" && !Array.isArray(t)) {
      const { message: e, data: r } = t;
      if (e && typeof e != "string")
        throw new Error("Must specify string message.");
      return [e || void 0, r];
    }
  }
  return [];
}
class ME extends Error {
  constructor(e, r, n) {
    if (!Number.isInteger(e))
      throw new Error('"code" must be an integer.');
    if (!r || typeof r != "string")
      throw new Error('"message" must be a nonempty string.');
    super(r), this.code = e, n !== void 0 && (this.data = n);
  }
}
class IE extends ME {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(e, r, n) {
    if (!TG(e))
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(e, r, n);
  }
}
function TG(t) {
  return Number.isInteger(t) && t >= 1e3 && t <= 4999;
}
function pb() {
  return (t) => t;
}
const El = pb(), RG = pb(), DG = pb();
function wo(t) {
  return Math.floor(t);
}
const CE = /^[0-9]*$/, TE = /^[a-f0-9]*$/;
function Ya(t) {
  return gb(crypto.getRandomValues(new Uint8Array(t)));
}
function gb(t) {
  return [...t].map((e) => e.toString(16).padStart(2, "0")).join("");
}
function Rd(t) {
  return new Uint8Array(t.match(/.{1,2}/g).map((e) => Number.parseInt(e, 16)));
}
function zf(t, e = !1) {
  const r = t.toString("hex");
  return El(e ? `0x${r}` : r);
}
function _m(t) {
  return zf(k1(t), !0);
}
function Ls(t) {
  return DG(t.toString(10));
}
function la(t) {
  return El(`0x${BigInt(t).toString(16)}`);
}
function RE(t) {
  return t.startsWith("0x") || t.startsWith("0X");
}
function mb(t) {
  return RE(t) ? t.slice(2) : t;
}
function DE(t) {
  return RE(t) ? `0x${t.slice(2)}` : `0x${t}`;
}
function ap(t) {
  if (typeof t != "string")
    return !1;
  const e = mb(t).toLowerCase();
  return TE.test(e);
}
function OG(t, e = !1) {
  if (typeof t == "string") {
    const r = mb(t).toLowerCase();
    if (TE.test(r))
      return El(e ? `0x${r}` : r);
  }
  throw Sr.rpc.invalidParams(`"${String(t)}" is not a hexadecimal string`);
}
function vb(t, e = !1) {
  let r = OG(t, !1);
  return r.length % 2 === 1 && (r = El(`0${r}`)), e ? El(`0x${r}`) : r;
}
function Qo(t) {
  if (typeof t == "string") {
    const e = mb(t).toLowerCase();
    if (ap(e) && e.length === 40)
      return RG(DE(e));
  }
  throw Sr.rpc.invalidParams(`Invalid Ethereum address: ${String(t)}`);
}
function k1(t) {
  if (Buffer.isBuffer(t))
    return t;
  if (typeof t == "string") {
    if (ap(t)) {
      const e = vb(t, !1);
      return Buffer.from(e, "hex");
    }
    return Buffer.from(t, "utf8");
  }
  throw Sr.rpc.invalidParams(`Not binary data: ${String(t)}`);
}
function Hf(t) {
  if (typeof t == "number" && Number.isInteger(t))
    return wo(t);
  if (typeof t == "string") {
    if (CE.test(t))
      return wo(Number(t));
    if (ap(t))
      return wo(Number(BigInt(vb(t, !0))));
  }
  throw Sr.rpc.invalidParams(`Not an integer: ${String(t)}`);
}
function Cf(t) {
  if (t !== null && (typeof t == "bigint" || LG(t)))
    return BigInt(t.toString(10));
  if (typeof t == "number")
    return BigInt(Hf(t));
  if (typeof t == "string") {
    if (CE.test(t))
      return BigInt(t);
    if (ap(t))
      return BigInt(vb(t, !0));
  }
  throw Sr.rpc.invalidParams(`Not an integer: ${String(t)}`);
}
function NG(t) {
  if (typeof t == "string")
    return JSON.parse(t);
  if (typeof t == "object")
    return t;
  throw Sr.rpc.invalidParams(`Not a JSON string or an object: ${String(t)}`);
}
function LG(t) {
  if (t == null || typeof t.constructor != "function")
    return !1;
  const { constructor: e } = t;
  return typeof e.config == "function" && typeof e.EUCLID == "number";
}
async function kG() {
  return crypto.subtle.generateKey({
    name: "ECDH",
    namedCurve: "P-256"
  }, !0, ["deriveKey"]);
}
async function $G(t, e) {
  return crypto.subtle.deriveKey({
    name: "ECDH",
    public: e
  }, t, {
    name: "AES-GCM",
    length: 256
  }, !1, ["encrypt", "decrypt"]);
}
async function BG(t, e) {
  const r = crypto.getRandomValues(new Uint8Array(12)), n = await crypto.subtle.encrypt({
    name: "AES-GCM",
    iv: r
  }, t, new TextEncoder().encode(e));
  return { iv: r, cipherText: n };
}
async function FG(t, { iv: e, cipherText: r }) {
  const n = await crypto.subtle.decrypt({
    name: "AES-GCM",
    iv: e
  }, t, r);
  return new TextDecoder().decode(n);
}
function OE(t) {
  switch (t) {
    case "public":
      return "spki";
    case "private":
      return "pkcs8";
  }
}
async function NE(t, e) {
  const r = OE(t), n = await crypto.subtle.exportKey(r, e);
  return gb(new Uint8Array(n));
}
async function LE(t, e) {
  const r = OE(t), n = Rd(e).buffer;
  return await crypto.subtle.importKey(r, new Uint8Array(n), {
    name: "ECDH",
    namedCurve: "P-256"
  }, !0, t === "private" ? ["deriveKey"] : []);
}
async function UG(t, e) {
  const r = JSON.stringify(t, (n, i) => {
    if (!(i instanceof Error))
      return i;
    const s = i;
    return Object.assign(Object.assign({}, s.code ? { code: s.code } : {}), { message: s.message });
  });
  return BG(e, r);
}
async function jG(t, e) {
  return JSON.parse(await FG(e, t));
}
const Em = {
  storageKey: "ownPrivateKey",
  keyType: "private"
}, Sm = {
  storageKey: "ownPublicKey",
  keyType: "public"
}, Am = {
  storageKey: "peerPublicKey",
  keyType: "public"
};
class qG {
  constructor() {
    this.storage = new Zs("CBWSDK", "SCWKeyManager"), this.ownPrivateKey = null, this.ownPublicKey = null, this.peerPublicKey = null, this.sharedSecret = null;
  }
  async getOwnPublicKey() {
    return await this.loadKeysIfNeeded(), this.ownPublicKey;
  }
  // returns null if the shared secret is not yet derived
  async getSharedSecret() {
    return await this.loadKeysIfNeeded(), this.sharedSecret;
  }
  async setPeerPublicKey(e) {
    this.sharedSecret = null, this.peerPublicKey = e, await this.storeKey(Am, e), await this.loadKeysIfNeeded();
  }
  async clear() {
    this.ownPrivateKey = null, this.ownPublicKey = null, this.peerPublicKey = null, this.sharedSecret = null, this.storage.removeItem(Sm.storageKey), this.storage.removeItem(Em.storageKey), this.storage.removeItem(Am.storageKey);
  }
  async generateKeyPair() {
    const e = await kG();
    this.ownPrivateKey = e.privateKey, this.ownPublicKey = e.publicKey, await this.storeKey(Em, e.privateKey), await this.storeKey(Sm, e.publicKey);
  }
  async loadKeysIfNeeded() {
    if (this.ownPrivateKey === null && (this.ownPrivateKey = await this.loadKey(Em)), this.ownPublicKey === null && (this.ownPublicKey = await this.loadKey(Sm)), (this.ownPrivateKey === null || this.ownPublicKey === null) && await this.generateKeyPair(), this.peerPublicKey === null && (this.peerPublicKey = await this.loadKey(Am)), this.sharedSecret === null) {
      if (this.ownPrivateKey === null || this.peerPublicKey === null)
        return;
      this.sharedSecret = await $G(this.ownPrivateKey, this.peerPublicKey);
    }
  }
  // storage methods
  async loadKey(e) {
    const r = this.storage.getItem(e.storageKey);
    return r ? LE(e.keyType, r) : null;
  }
  async storeKey(e, r) {
    const n = await NE(e.keyType, r);
    this.storage.setItem(e.storageKey, n);
  }
}
const rh = "4.2.4", kE = "@coinbase/wallet-sdk";
async function $E(t, e) {
  const r = Object.assign(Object.assign({}, t), { jsonrpc: "2.0", id: crypto.randomUUID() }), n = await window.fetch(e, {
    method: "POST",
    body: JSON.stringify(r),
    mode: "cors",
    headers: {
      "Content-Type": "application/json",
      "X-Cbw-Sdk-Version": rh,
      "X-Cbw-Sdk-Platform": kE
    }
  }), { result: i, error: s } = await n.json();
  if (s)
    throw s;
  return i;
}
function zG() {
  return globalThis.coinbaseWalletExtension;
}
function HG() {
  var t, e;
  try {
    const r = globalThis;
    return (t = r.ethereum) !== null && t !== void 0 ? t : (e = r.top) === null || e === void 0 ? void 0 : e.ethereum;
  } catch {
    return;
  }
}
function WG({ metadata: t, preference: e }) {
  var r, n;
  const { appName: i, appLogoUrl: s, appChainIds: o } = t;
  if (e.options !== "smartWalletOnly") {
    const u = zG();
    if (u)
      return (r = u.setAppInfo) === null || r === void 0 || r.call(u, i, s, o, e), u;
  }
  const a = HG();
  if (a != null && a.isCoinbaseBrowser)
    return (n = a.setAppInfo) === null || n === void 0 || n.call(a, i, s, o, e), a;
}
function KG(t) {
  if (!t || typeof t != "object" || Array.isArray(t))
    throw Sr.rpc.invalidParams({
      message: "Expected a single, non-array, object argument.",
      data: t
    });
  const { method: e, params: r } = t;
  if (typeof e != "string" || e.length === 0)
    throw Sr.rpc.invalidParams({
      message: "'args.method' must be a non-empty string.",
      data: t
    });
  if (r !== void 0 && !Array.isArray(r) && (typeof r != "object" || r === null))
    throw Sr.rpc.invalidParams({
      message: "'args.params' must be an object or array if provided.",
      data: t
    });
  switch (e) {
    case "eth_sign":
    case "eth_signTypedData_v2":
    case "eth_subscribe":
    case "eth_unsubscribe":
      throw Sr.provider.unsupportedMethod();
  }
}
const t6 = "accounts", r6 = "activeChain", n6 = "availableChains", i6 = "walletCapabilities";
class VG {
  constructor(e) {
    var r, n, i;
    this.metadata = e.metadata, this.communicator = e.communicator, this.callback = e.callback, this.keyManager = new qG(), this.storage = new Zs("CBWSDK", "SCWStateManager"), this.accounts = (r = this.storage.loadObject(t6)) !== null && r !== void 0 ? r : [], this.chain = this.storage.loadObject(r6) || {
      id: (i = (n = e.metadata.appChainIds) === null || n === void 0 ? void 0 : n[0]) !== null && i !== void 0 ? i : 1
    }, this.handshake = this.handshake.bind(this), this.request = this.request.bind(this), this.createRequestMessage = this.createRequestMessage.bind(this), this.decryptResponseMessage = this.decryptResponseMessage.bind(this);
  }
  async handshake(e) {
    var r, n;
    const i = await this.createRequestMessage({
      handshake: {
        method: e.method,
        params: Object.assign({}, this.metadata, (r = e.params) !== null && r !== void 0 ? r : {})
      }
    }), s = await this.communicator.postRequestAndWaitForResponse(i);
    if ("failure" in s.content)
      throw s.content.failure;
    const o = await LE("public", s.sender);
    await this.keyManager.setPeerPublicKey(o);
    const u = (await this.decryptResponseMessage(s)).result;
    if ("error" in u)
      throw u.error;
    const h = u.value;
    this.accounts = h, this.storage.storeObject(t6, h), (n = this.callback) === null || n === void 0 || n.call(this, "accountsChanged", h);
  }
  async request(e) {
    var r;
    if (this.accounts.length === 0)
      throw Sr.provider.unauthorized();
    switch (e.method) {
      case "eth_requestAccounts":
        return (r = this.callback) === null || r === void 0 || r.call(this, "connect", { chainId: la(this.chain.id) }), this.accounts;
      case "eth_accounts":
        return this.accounts;
      case "eth_coinbase":
        return this.accounts[0];
      case "net_version":
        return this.chain.id;
      case "eth_chainId":
        return la(this.chain.id);
      case "wallet_getCapabilities":
        return this.storage.loadObject(i6);
      case "wallet_switchEthereumChain":
        return this.handleSwitchChainRequest(e);
      case "eth_ecRecover":
      case "personal_sign":
      case "personal_ecRecover":
      case "eth_signTransaction":
      case "eth_sendTransaction":
      case "eth_signTypedData_v1":
      case "eth_signTypedData_v3":
      case "eth_signTypedData_v4":
      case "eth_signTypedData":
      case "wallet_addEthereumChain":
      case "wallet_watchAsset":
      case "wallet_sendCalls":
      case "wallet_showCallsStatus":
      case "wallet_grantPermissions":
        return this.sendRequestToPopup(e);
      default:
        if (!this.chain.rpcUrl)
          throw Sr.rpc.internal("No RPC URL set for chain");
        return $E(e, this.chain.rpcUrl);
    }
  }
  async sendRequestToPopup(e) {
    var r, n;
    await ((n = (r = this.communicator).waitForPopupLoaded) === null || n === void 0 ? void 0 : n.call(r));
    const i = await this.sendEncryptedRequest(e), o = (await this.decryptResponseMessage(i)).result;
    if ("error" in o)
      throw o.error;
    return o.value;
  }
  async cleanup() {
    var e, r;
    this.storage.clear(), await this.keyManager.clear(), this.accounts = [], this.chain = {
      id: (r = (e = this.metadata.appChainIds) === null || e === void 0 ? void 0 : e[0]) !== null && r !== void 0 ? r : 1
    };
  }
  /**
   * @returns `null` if the request was successful.
   * https://eips.ethereum.org/EIPS/eip-3326#wallet_switchethereumchain
   */
  async handleSwitchChainRequest(e) {
    var r;
    const n = e.params;
    if (!n || !(!((r = n[0]) === null || r === void 0) && r.chainId))
      throw Sr.rpc.invalidParams();
    const i = Hf(n[0].chainId);
    if (this.updateChain(i))
      return null;
    const o = await this.sendRequestToPopup(e);
    return o === null && this.updateChain(i), o;
  }
  async sendEncryptedRequest(e) {
    const r = await this.keyManager.getSharedSecret();
    if (!r)
      throw Sr.provider.unauthorized("No valid session found, try requestAccounts before other methods");
    const n = await UG({
      action: e,
      chainId: this.chain.id
    }, r), i = await this.createRequestMessage({ encrypted: n });
    return this.communicator.postRequestAndWaitForResponse(i);
  }
  async createRequestMessage(e) {
    const r = await NE("public", await this.keyManager.getOwnPublicKey());
    return {
      id: crypto.randomUUID(),
      sender: r,
      content: e,
      timestamp: /* @__PURE__ */ new Date()
    };
  }
  async decryptResponseMessage(e) {
    var r, n;
    const i = e.content;
    if ("failure" in i)
      throw i.failure;
    const s = await this.keyManager.getSharedSecret();
    if (!s)
      throw Sr.provider.unauthorized("Invalid session");
    const o = await jG(i.encrypted, s), a = (r = o.data) === null || r === void 0 ? void 0 : r.chains;
    if (a) {
      const h = Object.entries(a).map(([d, p]) => ({
        id: Number(d),
        rpcUrl: p
      }));
      this.storage.storeObject(n6, h), this.updateChain(this.chain.id, h);
    }
    const u = (n = o.data) === null || n === void 0 ? void 0 : n.capabilities;
    return u && this.storage.storeObject(i6, u), o;
  }
  updateChain(e, r) {
    var n;
    const i = r ?? this.storage.loadObject(n6), s = i == null ? void 0 : i.find((o) => o.id === e);
    return s ? (s !== this.chain && (this.chain = s, this.storage.storeObject(r6, s), (n = this.callback) === null || n === void 0 || n.call(this, "chainChanged", la(s.id))), !0) : !1;
  }
}
const GG = /* @__PURE__ */ bv(PD), { keccak_256: YG } = GG;
function BE(t) {
  return Buffer.allocUnsafe(t).fill(0);
}
function JG(t) {
  return t.toString(2).length;
}
function FE(t, e) {
  let r = t.toString(16);
  r.length % 2 !== 0 && (r = "0" + r);
  const n = r.match(/.{1,2}/g).map((i) => parseInt(i, 16));
  for (; n.length < e; )
    n.unshift(0);
  return Buffer.from(n);
}
function XG(t, e) {
  const r = t < 0n;
  let n;
  if (r) {
    const i = (1n << BigInt(e)) - 1n;
    n = (~t & i) + 1n;
  } else
    n = t;
  return n &= (1n << BigInt(e)) - 1n, n;
}
function UE(t, e, r) {
  const n = BE(e);
  return t = cp(t), r ? t.length < e ? (t.copy(n), n) : t.slice(0, e) : t.length < e ? (t.copy(n, e - t.length), n) : t.slice(-e);
}
function ZG(t, e) {
  return UE(t, e, !0);
}
function cp(t) {
  if (!Buffer.isBuffer(t))
    if (Array.isArray(t))
      t = Buffer.from(t);
    else if (typeof t == "string")
      jE(t) ? t = Buffer.from(tY(qE(t)), "hex") : t = Buffer.from(t);
    else if (typeof t == "number")
      t = intToBuffer(t);
    else if (t == null)
      t = Buffer.allocUnsafe(0);
    else if (typeof t == "bigint")
      t = FE(t);
    else if (t.toArray)
      t = Buffer.from(t.toArray());
    else
      throw new Error("invalid type");
  return t;
}
function QG(t) {
  return t = cp(t), "0x" + t.toString("hex");
}
function eY(t, e) {
  if (t = cp(t), e || (e = 256), e !== 256)
    throw new Error("unsupported");
  return Buffer.from(YG(new Uint8Array(t)));
}
function tY(t) {
  return t.length % 2 ? "0" + t : t;
}
function jE(t) {
  return typeof t == "string" && t.match(/^0x[0-9A-Fa-f]*$/);
}
function qE(t) {
  return typeof t == "string" && t.startsWith("0x") ? t.slice(2) : t;
}
var zE = {
  zeros: BE,
  setLength: UE,
  setLengthRight: ZG,
  isHexString: jE,
  stripHexPrefix: qE,
  toBuffer: cp,
  bufferToHex: QG,
  keccak: eY,
  bitLengthFromBigInt: JG,
  bufferBEFromBigInt: FE,
  twosFromBigInt: XG
};
const ni = zE;
function HE(t) {
  return t.startsWith("int[") ? "int256" + t.slice(3) : t === "int" ? "int256" : t.startsWith("uint[") ? "uint256" + t.slice(4) : t === "uint" ? "uint256" : t.startsWith("fixed[") ? "fixed128x128" + t.slice(5) : t === "fixed" ? "fixed128x128" : t.startsWith("ufixed[") ? "ufixed128x128" + t.slice(6) : t === "ufixed" ? "ufixed128x128" : t;
}
function hu(t) {
  return Number.parseInt(/^\D+(\d+)$/.exec(t)[1], 10);
}
function s6(t) {
  var e = /^\D+(\d+)x(\d+)$/.exec(t);
  return [Number.parseInt(e[1], 10), Number.parseInt(e[2], 10)];
}
function WE(t) {
  var e = t.match(/(.*)\[(.*?)\]$/);
  return e ? e[2] === "" ? "dynamic" : Number.parseInt(e[2], 10) : null;
}
function Ja(t) {
  var e = typeof t;
  if (e === "string" || e === "number")
    return BigInt(t);
  if (e === "bigint")
    return t;
  throw new Error("Argument is not a number");
}
function Us(t, e) {
  var r, n, i, s;
  if (t === "address")
    return Us("uint160", Ja(e));
  if (t === "bool")
    return Us("uint8", e ? 1 : 0);
  if (t === "string")
    return Us("bytes", new Buffer(e, "utf8"));
  if (nY(t)) {
    if (typeof e.length > "u")
      throw new Error("Not an array?");
    if (r = WE(t), r !== "dynamic" && r !== 0 && e.length > r)
      throw new Error("Elements exceed array size: " + r);
    i = [], t = t.slice(0, t.lastIndexOf("[")), typeof e == "string" && (e = JSON.parse(e));
    for (s in e)
      i.push(Us(t, e[s]));
    if (r === "dynamic") {
      var o = Us("uint256", e.length);
      i.unshift(o);
    }
    return Buffer.concat(i);
  } else {
    if (t === "bytes")
      return e = new Buffer(e), i = Buffer.concat([Us("uint256", e.length), e]), e.length % 32 !== 0 && (i = Buffer.concat([i, ni.zeros(32 - e.length % 32)])), i;
    if (t.startsWith("bytes")) {
      if (r = hu(t), r < 1 || r > 32)
        throw new Error("Invalid bytes<N> width: " + r);
      return ni.setLengthRight(e, 32);
    } else if (t.startsWith("uint")) {
      if (r = hu(t), r % 8 || r < 8 || r > 256)
        throw new Error("Invalid uint<N> width: " + r);
      n = Ja(e);
      const a = ni.bitLengthFromBigInt(n);
      if (a > r)
        throw new Error("Supplied uint exceeds width: " + r + " vs " + a);
      if (n < 0)
        throw new Error("Supplied uint is negative");
      return ni.bufferBEFromBigInt(n, 32);
    } else if (t.startsWith("int")) {
      if (r = hu(t), r % 8 || r < 8 || r > 256)
        throw new Error("Invalid int<N> width: " + r);
      n = Ja(e);
      const a = ni.bitLengthFromBigInt(n);
      if (a > r)
        throw new Error("Supplied int exceeds width: " + r + " vs " + a);
      const u = ni.twosFromBigInt(n, 256);
      return ni.bufferBEFromBigInt(u, 32);
    } else if (t.startsWith("ufixed")) {
      if (r = s6(t), n = Ja(e), n < 0)
        throw new Error("Supplied ufixed is negative");
      return Us("uint256", n * BigInt(2) ** BigInt(r[1]));
    } else if (t.startsWith("fixed"))
      return r = s6(t), Us("int256", Ja(e) * BigInt(2) ** BigInt(r[1]));
  }
  throw new Error("Unsupported or invalid type: " + t);
}
function rY(t) {
  return t === "string" || t === "bytes" || WE(t) === "dynamic";
}
function nY(t) {
  return t.lastIndexOf("]") === t.length - 1;
}
function iY(t, e) {
  var r = [], n = [], i = 32 * t.length;
  for (var s in t) {
    var o = HE(t[s]), a = e[s], u = Us(o, a);
    rY(o) ? (r.push(Us("uint256", i)), n.push(u), i += u.length) : r.push(u);
  }
  return Buffer.concat(r.concat(n));
}
function KE(t, e) {
  if (t.length !== e.length)
    throw new Error("Number of types are not matching the values");
  for (var r, n, i = [], s = 0; s < t.length; s++) {
    var o = HE(t[s]), a = e[s];
    if (o === "bytes")
      i.push(a);
    else if (o === "string")
      i.push(new Buffer(a, "utf8"));
    else if (o === "bool")
      i.push(new Buffer(a ? "01" : "00", "hex"));
    else if (o === "address")
      i.push(ni.setLength(a, 20));
    else if (o.startsWith("bytes")) {
      if (r = hu(o), r < 1 || r > 32)
        throw new Error("Invalid bytes<N> width: " + r);
      i.push(ni.setLengthRight(a, r));
    } else if (o.startsWith("uint")) {
      if (r = hu(o), r % 8 || r < 8 || r > 256)
        throw new Error("Invalid uint<N> width: " + r);
      n = Ja(a);
      const u = ni.bitLengthFromBigInt(n);
      if (u > r)
        throw new Error("Supplied uint exceeds width: " + r + " vs " + u);
      i.push(ni.bufferBEFromBigInt(n, r / 8));
    } else if (o.startsWith("int")) {
      if (r = hu(o), r % 8 || r < 8 || r > 256)
        throw new Error("Invalid int<N> width: " + r);
      n = Ja(a);
      const u = ni.bitLengthFromBigInt(n);
      if (u > r)
        throw new Error("Supplied int exceeds width: " + r + " vs " + u);
      const h = ni.twosFromBigInt(n, r);
      i.push(ni.bufferBEFromBigInt(h, r / 8));
    } else
      throw new Error("Unsupported or invalid type: " + o);
  }
  return Buffer.concat(i);
}
function sY(t, e) {
  return ni.keccak(KE(t, e));
}
var oY = {
  rawEncode: iY,
  solidityPack: KE,
  soliditySHA3: sY
};
const bs = zE, Wf = oY, VE = {
  type: "object",
  properties: {
    types: {
      type: "object",
      additionalProperties: {
        type: "array",
        items: {
          type: "object",
          properties: {
            name: { type: "string" },
            type: { type: "string" }
          },
          required: ["name", "type"]
        }
      }
    },
    primaryType: { type: "string" },
    domain: { type: "object" },
    message: { type: "object" }
  },
  required: ["types", "primaryType", "domain", "message"]
}, Pm = {
  /**
   * Encodes an object by encoding and concatenating each of its members
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of an object
   */
  encodeData(t, e, r, n = !0) {
    const i = ["bytes32"], s = [this.hashType(t, r)];
    if (n) {
      const o = (a, u, h) => {
        if (r[u] !== void 0)
          return ["bytes32", h == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : bs.keccak(this.encodeData(u, h, r, n))];
        if (h === void 0)
          throw new Error(`missing value for field ${a} of type ${u}`);
        if (u === "bytes")
          return ["bytes32", bs.keccak(h)];
        if (u === "string")
          return typeof h == "string" && (h = Buffer.from(h, "utf8")), ["bytes32", bs.keccak(h)];
        if (u.lastIndexOf("]") === u.length - 1) {
          const d = u.slice(0, u.lastIndexOf("[")), p = h.map((x) => o(a, d, x));
          return ["bytes32", bs.keccak(Wf.rawEncode(
            p.map(([x]) => x),
            p.map(([, x]) => x)
          ))];
        }
        return [u, h];
      };
      for (const a of r[t]) {
        const [u, h] = o(a.name, a.type, e[a.name]);
        i.push(u), s.push(h);
      }
    } else
      for (const o of r[t]) {
        let a = e[o.name];
        if (a !== void 0)
          if (o.type === "bytes")
            i.push("bytes32"), a = bs.keccak(a), s.push(a);
          else if (o.type === "string")
            i.push("bytes32"), typeof a == "string" && (a = Buffer.from(a, "utf8")), a = bs.keccak(a), s.push(a);
          else if (r[o.type] !== void 0)
            i.push("bytes32"), a = bs.keccak(this.encodeData(o.type, a, r, n)), s.push(a);
          else {
            if (o.type.lastIndexOf("]") === o.type.length - 1)
              throw new Error("Arrays currently unimplemented in encodeData");
            i.push(o.type), s.push(a);
          }
      }
    return Wf.rawEncode(i, s);
  },
  /**
   * Encodes the type of an object by encoding a comma delimited list of its members
   *
   * @param {string} primaryType - Root type to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of the type of an object
   */
  encodeType(t, e) {
    let r = "", n = this.findTypeDependencies(t, e).filter((i) => i !== t);
    n = [t].concat(n.sort());
    for (const i of n) {
      if (!e[i])
        throw new Error("No type definition specified: " + i);
      r += i + "(" + e[i].map(({ name: o, type: a }) => a + " " + o).join(",") + ")";
    }
    return r;
  },
  /**
   * Finds all types within a type definition object
   *
   * @param {string} primaryType - Root type
   * @param {Object} types - Type definitions
   * @param {Array} results - current set of accumulated types
   * @returns {Array} - Set of all types found in the type definition
   */
  findTypeDependencies(t, e, r = []) {
    if (t = t.match(/^\w*/)[0], r.includes(t) || e[t] === void 0)
      return r;
    r.push(t);
    for (const n of e[t])
      for (const i of this.findTypeDependencies(n.type, e, r))
        !r.includes(i) && r.push(i);
    return r;
  },
  /**
   * Hashes an object
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to hash
   * @param {Object} types - Type definitions
   * @returns {Buffer} - Hash of an object
   */
  hashStruct(t, e, r, n = !0) {
    return bs.keccak(this.encodeData(t, e, r, n));
  },
  /**
   * Hashes the type of an object
   *
   * @param {string} primaryType - Root type to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashType(t, e) {
    return bs.keccak(this.encodeType(t, e));
  },
  /**
   * Removes properties from a message object that are not defined per EIP-712
   *
   * @param {Object} data - typed message object
   * @returns {Object} - typed message object with only allowed fields
   */
  sanitizeData(t) {
    const e = {};
    for (const r in VE.properties)
      t[r] && (e[r] = t[r]);
    return e.types && (e.types = Object.assign({ EIP712Domain: [] }, e.types)), e;
  },
  /**
   * Returns the hash of a typed message as per EIP-712 for signing
   *
   * @param {Object} typedData - Types message data to sign
   * @returns {string} - sha3 hash for signing
   */
  hash(t, e = !0) {
    const r = this.sanitizeData(t), n = [Buffer.from("1901", "hex")];
    return n.push(this.hashStruct("EIP712Domain", r.domain, r.types, e)), r.primaryType !== "EIP712Domain" && n.push(this.hashStruct(r.primaryType, r.message, r.types, e)), bs.keccak(Buffer.concat(n));
  }
};
var aY = {
  TYPED_MESSAGE_SCHEMA: VE,
  TypedDataUtils: Pm,
  hashForSignTypedDataLegacy: function(t) {
    return cY(t.data);
  },
  hashForSignTypedData_v3: function(t) {
    return Pm.hash(t.data, !1);
  },
  hashForSignTypedData_v4: function(t) {
    return Pm.hash(t.data);
  }
};
function cY(t) {
  const e = new Error("Expect argument to be non-empty array");
  if (typeof t != "object" || !t.length) throw e;
  const r = t.map(function(s) {
    return s.type === "bytes" ? bs.toBuffer(s.value) : s.value;
  }), n = t.map(function(s) {
    return s.type;
  }), i = t.map(function(s) {
    if (!s.name) throw e;
    return s.type + " " + s.name;
  });
  return Wf.soliditySHA3(
    ["bytes32", "bytes32"],
    [
      Wf.soliditySHA3(new Array(t.length).fill("string"), i),
      Wf.soliditySHA3(n, r)
    ]
  );
}
const hd = /* @__PURE__ */ ts(aY), uY = "walletUsername", $1 = "Addresses", fY = "AppVersion";
function Bn(t) {
  return t.errorMessage !== void 0;
}
class lY {
  // @param secret hex representation of 32-byte secret
  constructor(e) {
    this.secret = e;
  }
  /**
   *
   * @param plainText string to be encrypted
   * returns hex string representation of bytes in the order: initialization vector (iv),
   * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the
   * encrypted plainText.
   */
  async encrypt(e) {
    const r = this.secret;
    if (r.length !== 64)
      throw Error("secret must be 256 bits");
    const n = crypto.getRandomValues(new Uint8Array(12)), i = await crypto.subtle.importKey("raw", Rd(r), { name: "aes-gcm" }, !1, ["encrypt", "decrypt"]), s = new TextEncoder(), o = await window.crypto.subtle.encrypt({
      name: "AES-GCM",
      iv: n
    }, i, s.encode(e)), a = 16, u = o.slice(o.byteLength - a), h = o.slice(0, o.byteLength - a), d = new Uint8Array(u), p = new Uint8Array(h), x = new Uint8Array([...n, ...d, ...p]);
    return gb(x);
  }
  /**
   *
   * @param cipherText hex string representation of bytes in the order: initialization vector (iv),
   * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.
   */
  async decrypt(e) {
    const r = this.secret;
    if (r.length !== 64)
      throw Error("secret must be 256 bits");
    return new Promise((n, i) => {
      (async function() {
        const s = await crypto.subtle.importKey("raw", Rd(r), { name: "aes-gcm" }, !1, ["encrypt", "decrypt"]), o = Rd(e), a = o.slice(0, 12), u = o.slice(12, 28), h = o.slice(28), d = new Uint8Array([...h, ...u]), p = {
          name: "AES-GCM",
          iv: new Uint8Array(a)
        };
        try {
          const x = await window.crypto.subtle.decrypt(p, s, d), A = new TextDecoder();
          n(A.decode(x));
        } catch (x) {
          i(x);
        }
      })();
    });
  }
}
class hY {
  constructor(e, r, n) {
    this.linkAPIUrl = e, this.sessionId = r;
    const i = `${r}:${n}`;
    this.auth = `Basic ${btoa(i)}`;
  }
  // mark unseen events as seen
  async markUnseenEventsAsSeen(e) {
    return Promise.all(e.map((r) => fetch(`${this.linkAPIUrl}/events/${r.eventId}/seen`, {
      method: "POST",
      headers: {
        Authorization: this.auth
      }
    }))).catch((r) => console.error("Unabled to mark event as failed:", r));
  }
  async fetchUnseenEvents() {
    var e;
    const r = await fetch(`${this.linkAPIUrl}/events?unseen=true`, {
      headers: {
        Authorization: this.auth
      }
    });
    if (r.ok) {
      const { events: n, error: i } = await r.json();
      if (i)
        throw new Error(`Check unseen events failed: ${i}`);
      const s = (e = n == null ? void 0 : n.filter((o) => o.event === "Web3Response").map((o) => ({
        type: "Event",
        sessionId: this.sessionId,
        eventId: o.id,
        event: o.event,
        data: o.data
      }))) !== null && e !== void 0 ? e : [];
      return this.markUnseenEventsAsSeen(s), s;
    }
    throw new Error(`Check unseen events failed: ${r.status}`);
  }
}
var So;
(function(t) {
  t[t.DISCONNECTED = 0] = "DISCONNECTED", t[t.CONNECTING = 1] = "CONNECTING", t[t.CONNECTED = 2] = "CONNECTED";
})(So || (So = {}));
class dY {
  setConnectionStateListener(e) {
    this.connectionStateListener = e;
  }
  setIncomingDataListener(e) {
    this.incomingDataListener = e;
  }
  /**
   * Constructor
   * @param url WebSocket server URL
   * @param [WebSocketClass] Custom WebSocket implementation
   */
  constructor(e, r = WebSocket) {
    this.WebSocketClass = r, this.webSocket = null, this.pendingData = [], this.url = e.replace(/^http/, "ws");
  }
  /**
   * Make a websocket connection
   * @returns a Promise that resolves when connected
   */
  async connect() {
    if (this.webSocket)
      throw new Error("webSocket object is not null");
    return new Promise((e, r) => {
      var n;
      let i;
      try {
        this.webSocket = i = new this.WebSocketClass(this.url);
      } catch (s) {
        r(s);
        return;
      }
      (n = this.connectionStateListener) === null || n === void 0 || n.call(this, So.CONNECTING), i.onclose = (s) => {
        var o;
        this.clearWebSocket(), r(new Error(`websocket error ${s.code}: ${s.reason}`)), (o = this.connectionStateListener) === null || o === void 0 || o.call(this, So.DISCONNECTED);
      }, i.onopen = (s) => {
        var o;
        e(), (o = this.connectionStateListener) === null || o === void 0 || o.call(this, So.CONNECTED), this.pendingData.length > 0 && ([...this.pendingData].forEach((u) => this.sendData(u)), this.pendingData = []);
      }, i.onmessage = (s) => {
        var o, a;
        if (s.data === "h")
          (o = this.incomingDataListener) === null || o === void 0 || o.call(this, {
            type: "Heartbeat"
          });
        else
          try {
            const u = JSON.parse(s.data);
            (a = this.incomingDataListener) === null || a === void 0 || a.call(this, u);
          } catch {
          }
      };
    });
  }
  /**
   * Disconnect from server
   */
  disconnect() {
    var e;
    const { webSocket: r } = this;
    if (r) {
      this.clearWebSocket(), (e = this.connectionStateListener) === null || e === void 0 || e.call(this, So.DISCONNECTED), this.connectionStateListener = void 0, this.incomingDataListener = void 0;
      try {
        r.close();
      } catch {
      }
    }
  }
  /**
   * Send data to server
   * @param data text to send
   */
  sendData(e) {
    const { webSocket: r } = this;
    if (!r) {
      this.pendingData.push(e), this.connect();
      return;
    }
    r.send(e);
  }
  clearWebSocket() {
    const { webSocket: e } = this;
    e && (this.webSocket = null, e.onclose = null, e.onerror = null, e.onmessage = null, e.onopen = null);
  }
}
const o6 = 1e4, pY = 6e4;
class gY {
  /**
   * Constructor
   * @param session Session
   * @param linkAPIUrl Coinbase Wallet link server URL
   * @param listener WalletLinkConnectionUpdateListener
   * @param [WebSocketClass] Custom WebSocket implementation
   */
  constructor({ session: e, linkAPIUrl: r, listener: n }) {
    this.destroyed = !1, this.lastHeartbeatResponse = 0, this.nextReqId = wo(1), this._connected = !1, this._linked = !1, this.shouldFetchUnseenEventsOnConnect = !1, this.requestResolutions = /* @__PURE__ */ new Map(), this.handleSessionMetadataUpdated = (s) => {
      if (!s)
        return;
      (/* @__PURE__ */ new Map([
        ["__destroyed", this.handleDestroyed],
        ["EthereumAddress", this.handleAccountUpdated],
        ["WalletUsername", this.handleWalletUsernameUpdated],
        ["AppVersion", this.handleAppVersionUpdated],
        [
          "ChainId",
          // ChainId and JsonRpcUrl are always updated together
          (a) => s.JsonRpcUrl && this.handleChainUpdated(a, s.JsonRpcUrl)
        ]
      ])).forEach((a, u) => {
        const h = s[u];
        h !== void 0 && a(h);
      });
    }, this.handleDestroyed = (s) => {
      var o;
      s === "1" && ((o = this.listener) === null || o === void 0 || o.resetAndReload());
    }, this.handleAccountUpdated = async (s) => {
      var o;
      const a = await this.cipher.decrypt(s);
      (o = this.listener) === null || o === void 0 || o.accountUpdated(a);
    }, this.handleMetadataUpdated = async (s, o) => {
      var a;
      const u = await this.cipher.decrypt(o);
      (a = this.listener) === null || a === void 0 || a.metadataUpdated(s, u);
    }, this.handleWalletUsernameUpdated = async (s) => {
      this.handleMetadataUpdated(uY, s);
    }, this.handleAppVersionUpdated = async (s) => {
      this.handleMetadataUpdated(fY, s);
    }, this.handleChainUpdated = async (s, o) => {
      var a;
      const u = await this.cipher.decrypt(s), h = await this.cipher.decrypt(o);
      (a = this.listener) === null || a === void 0 || a.chainUpdated(u, h);
    }, this.session = e, this.cipher = new lY(e.secret), this.listener = n;
    const i = new dY(`${r}/rpc`, WebSocket);
    i.setConnectionStateListener(async (s) => {
      let o = !1;
      switch (s) {
        case So.DISCONNECTED:
          if (!this.destroyed) {
            const a = async () => {
              await new Promise((u) => setTimeout(u, 5e3)), this.destroyed || i.connect().catch(() => {
                a();
              });
            };
            a();
          }
          break;
        case So.CONNECTED:
          o = await this.handleConnected(), this.updateLastHeartbeat(), setInterval(() => {
            this.heartbeat();
          }, o6), this.shouldFetchUnseenEventsOnConnect && this.fetchUnseenEventsAPI();
          break;
        case So.CONNECTING:
          break;
      }
      this.connected !== o && (this.connected = o);
    }), i.setIncomingDataListener((s) => {
      var o;
      switch (s.type) {
        case "Heartbeat":
          this.updateLastHeartbeat();
          return;
        case "IsLinkedOK":
        case "Linked": {
          const a = s.type === "IsLinkedOK" ? s.linked : void 0;
          this.linked = a || s.onlineGuests > 0;
          break;
        }
        case "GetSessionConfigOK":
        case "SessionConfigUpdated": {
          this.handleSessionMetadataUpdated(s.metadata);
          break;
        }
        case "Event": {
          this.handleIncomingEvent(s);
          break;
        }
      }
      s.id !== void 0 && ((o = this.requestResolutions.get(s.id)) === null || o === void 0 || o(s));
    }), this.ws = i, this.http = new hY(r, e.id, e.key);
  }
  /**
   * Make a connection to the server
   */
  connect() {
    if (this.destroyed)
      throw new Error("instance is destroyed");
    this.ws.connect();
  }
  /**
   * Terminate connection, and mark as destroyed. To reconnect, create a new
   * instance of WalletSDKConnection
   */
  async destroy() {
    this.destroyed || (await this.makeRequest({
      type: "SetSessionConfig",
      id: wo(this.nextReqId++),
      sessionId: this.session.id,
      metadata: { __destroyed: "1" }
    }, { timeout: 1e3 }), this.destroyed = !0, this.ws.disconnect(), this.listener = void 0);
  }
  get connected() {
    return this._connected;
  }
  set connected(e) {
    this._connected = e;
  }
  get linked() {
    return this._linked;
  }
  set linked(e) {
    var r, n;
    this._linked = e, e && ((r = this.onceLinked) === null || r === void 0 || r.call(this)), (n = this.listener) === null || n === void 0 || n.linkedUpdated(e);
  }
  setOnceLinked(e) {
    return new Promise((r) => {
      this.linked ? e().then(r) : this.onceLinked = () => {
        e().then(r), this.onceLinked = void 0;
      };
    });
  }
  async handleIncomingEvent(e) {
    var r;
    if (e.type !== "Event" || e.event !== "Web3Response")
      return;
    const n = await this.cipher.decrypt(e.data), i = JSON.parse(n);
    if (i.type !== "WEB3_RESPONSE")
      return;
    const { id: s, response: o } = i;
    (r = this.listener) === null || r === void 0 || r.handleWeb3ResponseMessage(s, o);
  }
  async checkUnseenEvents() {
    if (!this.connected) {
      this.shouldFetchUnseenEventsOnConnect = !0;
      return;
    }
    await new Promise((e) => setTimeout(e, 250));
    try {
      await this.fetchUnseenEventsAPI();
    } catch (e) {
      console.error("Unable to check for unseen events", e);
    }
  }
  async fetchUnseenEventsAPI() {
    this.shouldFetchUnseenEventsOnConnect = !1, (await this.http.fetchUnseenEvents()).forEach((r) => this.handleIncomingEvent(r));
  }
  /**
   * Publish an event and emit event ID when successful
   * @param event event name
   * @param unencryptedData unencrypted event data
   * @param callWebhook whether the webhook should be invoked
   * @returns a Promise that emits event ID when successful
   */
  async publishEvent(e, r, n = !1) {
    const i = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, r), { origin: location.origin, location: location.href, relaySource: "coinbaseWalletExtension" in window && window.coinbaseWalletExtension ? "injected_sdk" : "sdk" }))), s = {
      type: "PublishEvent",
      id: wo(this.nextReqId++),
      sessionId: this.session.id,
      event: e,
      data: i,
      callWebhook: n
    };
    return this.setOnceLinked(async () => {
      const o = await this.makeRequest(s);
      if (o.type === "Fail")
        throw new Error(o.error || "failed to publish event");
      return o.eventId;
    });
  }
  sendData(e) {
    this.ws.sendData(JSON.stringify(e));
  }
  updateLastHeartbeat() {
    this.lastHeartbeatResponse = Date.now();
  }
  heartbeat() {
    if (Date.now() - this.lastHeartbeatResponse > o6 * 2) {
      this.ws.disconnect();
      return;
    }
    try {
      this.ws.sendData("h");
    } catch {
    }
  }
  async makeRequest(e, r = { timeout: pY }) {
    const n = e.id;
    this.sendData(e);
    let i;
    return Promise.race([
      new Promise((s, o) => {
        i = window.setTimeout(() => {
          o(new Error(`request ${n} timed out`));
        }, r.timeout);
      }),
      new Promise((s) => {
        this.requestResolutions.set(n, (o) => {
          clearTimeout(i), s(o), this.requestResolutions.delete(n);
        });
      })
    ]);
  }
  async handleConnected() {
    return (await this.makeRequest({
      type: "HostSession",
      id: wo(this.nextReqId++),
      sessionId: this.session.id,
      sessionKey: this.session.key
    })).type === "Fail" ? !1 : (this.sendData({
      type: "IsLinked",
      id: wo(this.nextReqId++),
      sessionId: this.session.id
    }), this.sendData({
      type: "GetSessionConfig",
      id: wo(this.nextReqId++),
      sessionId: this.session.id
    }), !0);
  }
}
class mY {
  constructor() {
    this._nextRequestId = 0, this.callbacks = /* @__PURE__ */ new Map();
  }
  makeRequestId() {
    this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
    const e = this._nextRequestId, r = DE(e.toString(16));
    return this.callbacks.get(r) && this.callbacks.delete(r), e;
  }
}
const a6 = "session:id", c6 = "session:secret", u6 = "session:linked";
class du {
  constructor(e, r, n, i = !1) {
    this.storage = e, this.id = r, this.secret = n, this.key = aD(t4(`${r}, ${n} WalletLink`)), this._linked = !!i;
  }
  static create(e) {
    const r = Ya(16), n = Ya(32);
    return new du(e, r, n).save();
  }
  static load(e) {
    const r = e.getItem(a6), n = e.getItem(u6), i = e.getItem(c6);
    return r && i ? new du(e, r, i, n === "1") : null;
  }
  get linked() {
    return this._linked;
  }
  set linked(e) {
    this._linked = e, this.persistLinked();
  }
  save() {
    return this.storage.setItem(a6, this.id), this.storage.setItem(c6, this.secret), this.persistLinked(), this;
  }
  persistLinked() {
    this.storage.setItem(u6, this._linked ? "1" : "0");
  }
}
function vY() {
  try {
    return window.frameElement !== null;
  } catch {
    return !1;
  }
}
function bY() {
  try {
    return vY() && window.top ? window.top.location : window.location;
  } catch {
    return window.location;
  }
}
function yY() {
  var t;
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test((t = window == null ? void 0 : window.navigator) === null || t === void 0 ? void 0 : t.userAgent);
}
function GE() {
  var t, e;
  return (e = (t = window == null ? void 0 : window.matchMedia) === null || t === void 0 ? void 0 : t.call(window, "(prefers-color-scheme: dark)").matches) !== null && e !== void 0 ? e : !1;
}
const wY = '@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}';
function YE() {
  const t = document.createElement("style");
  t.type = "text/css", t.appendChild(document.createTextNode(wY)), document.documentElement.appendChild(t);
}
function JE(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number") n += t;
  else if (typeof t == "object") if (Array.isArray(t)) for (e = 0; e < t.length; e++) t[e] && (r = JE(t[e])) && (n && (n += " "), n += r);
  else for (e in t) t[e] && (n && (n += " "), n += e);
  return n;
}
function Kf() {
  for (var t, e, r = 0, n = ""; r < arguments.length; ) (t = arguments[r++]) && (e = JE(t)) && (n && (n += " "), n += e);
  return n;
}
var up, Jr, XE, Xa, f6, ZE, B1, QE, bb, F1, U1, Sl = {}, eS = [], xY = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, yb = Array.isArray;
function ha(t, e) {
  for (var r in e) t[r] = e[r];
  return t;
}
function wb(t) {
  t && t.parentNode && t.parentNode.removeChild(t);
}
function Nr(t, e, r) {
  var n, i, s, o = {};
  for (s in e) s == "key" ? n = e[s] : s == "ref" ? i = e[s] : o[s] = e[s];
  if (arguments.length > 2 && (o.children = arguments.length > 3 ? up.call(arguments, 2) : r), typeof t == "function" && t.defaultProps != null) for (s in t.defaultProps) o[s] === void 0 && (o[s] = t.defaultProps[s]);
  return Dd(t, o, n, i, null);
}
function Dd(t, e, r, n, i) {
  var s = { type: t, props: e, key: r, ref: n, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: i ?? ++XE, __i: -1, __u: 0 };
  return i == null && Jr.vnode != null && Jr.vnode(s), s;
}
function nh(t) {
  return t.children;
}
function Od(t, e) {
  this.props = t, this.context = e;
}
function Su(t, e) {
  if (e == null) return t.__ ? Su(t.__, t.__i + 1) : null;
  for (var r; e < t.__k.length; e++) if ((r = t.__k[e]) != null && r.__e != null) return r.__e;
  return typeof t.type == "function" ? Su(t) : null;
}
function tS(t) {
  var e, r;
  if ((t = t.__) != null && t.__c != null) {
    for (t.__e = t.__c.base = null, e = 0; e < t.__k.length; e++) if ((r = t.__k[e]) != null && r.__e != null) {
      t.__e = t.__c.base = r.__e;
      break;
    }
    return tS(t);
  }
}
function l6(t) {
  (!t.__d && (t.__d = !0) && Xa.push(t) && !h0.__r++ || f6 !== Jr.debounceRendering) && ((f6 = Jr.debounceRendering) || ZE)(h0);
}
function h0() {
  var t, e, r, n, i, s, o, a;
  for (Xa.sort(B1); t = Xa.shift(); ) t.__d && (e = Xa.length, n = void 0, s = (i = (r = t).__v).__e, o = [], a = [], r.__P && ((n = ha({}, i)).__v = i.__v + 1, Jr.vnode && Jr.vnode(n), xb(r.__P, n, i, r.__n, r.__P.namespaceURI, 32 & i.__u ? [s] : null, o, s ?? Su(i), !!(32 & i.__u), a), n.__v = i.__v, n.__.__k[n.__i] = n, iS(o, n, a), n.__e != s && tS(n)), Xa.length > e && Xa.sort(B1));
  h0.__r = 0;
}
function rS(t, e, r, n, i, s, o, a, u, h, d) {
  var p, x, A, I, N, L, F = n && n.__k || eS, $ = e.length;
  for (u = _Y(r, e, F, u), p = 0; p < $; p++) (A = r.__k[p]) != null && (x = A.__i === -1 ? Sl : F[A.__i] || Sl, A.__i = p, L = xb(t, A, x, i, s, o, a, u, h, d), I = A.__e, A.ref && x.ref != A.ref && (x.ref && _b(x.ref, null, A), d.push(A.ref, A.__c || I, A)), N == null && I != null && (N = I), 4 & A.__u || x.__k === A.__k ? u = nS(A, u, t) : typeof A.type == "function" && L !== void 0 ? u = L : I && (u = I.nextSibling), A.__u &= -7);
  return r.__e = N, u;
}
function _Y(t, e, r, n) {
  var i, s, o, a, u, h = e.length, d = r.length, p = d, x = 0;
  for (t.__k = [], i = 0; i < h; i++) (s = e[i]) != null && typeof s != "boolean" && typeof s != "function" ? (a = i + x, (s = t.__k[i] = typeof s == "string" || typeof s == "number" || typeof s == "bigint" || s.constructor == String ? Dd(null, s, null, null, null) : yb(s) ? Dd(nh, { children: s }, null, null, null) : s.constructor === void 0 && s.__b > 0 ? Dd(s.type, s.props, s.key, s.ref ? s.ref : null, s.__v) : s).__ = t, s.__b = t.__b + 1, o = null, (u = s.__i = EY(s, r, a, p)) !== -1 && (p--, (o = r[u]) && (o.__u |= 2)), o == null || o.__v === null ? (u == -1 && x--, typeof s.type != "function" && (s.__u |= 4)) : u !== a && (u == a - 1 ? x-- : u == a + 1 ? x++ : (u > a ? x-- : x++, s.__u |= 4))) : s = t.__k[i] = null;
  if (p) for (i = 0; i < d; i++) (o = r[i]) != null && !(2 & o.__u) && (o.__e == n && (n = Su(o)), sS(o, o));
  return n;
}
function nS(t, e, r) {
  var n, i;
  if (typeof t.type == "function") {
    for (n = t.__k, i = 0; n && i < n.length; i++) n[i] && (n[i].__ = t, e = nS(n[i], e, r));
    return e;
  }
  t.__e != e && (e && t.type && !r.contains(e) && (e = Su(t)), r.insertBefore(t.__e, e || null), e = t.__e);
  do
    e = e && e.nextSibling;
  while (e != null && e.nodeType === 8);
  return e;
}
function EY(t, e, r, n) {
  var i = t.key, s = t.type, o = r - 1, a = r + 1, u = e[r];
  if (u === null || u && i == u.key && s === u.type && !(2 & u.__u)) return r;
  if ((typeof s != "function" || s === nh || i) && n > (u != null && !(2 & u.__u) ? 1 : 0)) for (; o >= 0 || a < e.length; ) {
    if (o >= 0) {
      if ((u = e[o]) && !(2 & u.__u) && i == u.key && s === u.type) return o;
      o--;
    }
    if (a < e.length) {
      if ((u = e[a]) && !(2 & u.__u) && i == u.key && s === u.type) return a;
      a++;
    }
  }
  return -1;
}
function h6(t, e, r) {
  e[0] === "-" ? t.setProperty(e, r ?? "") : t[e] = r == null ? "" : typeof r != "number" || xY.test(e) ? r : r + "px";
}
function dd(t, e, r, n, i) {
  var s;
  e: if (e === "style") if (typeof r == "string") t.style.cssText = r;
  else {
    if (typeof n == "string" && (t.style.cssText = n = ""), n) for (e in n) r && e in r || h6(t.style, e, "");
    if (r) for (e in r) n && r[e] === n[e] || h6(t.style, e, r[e]);
  }
  else if (e[0] === "o" && e[1] === "n") s = e !== (e = e.replace(QE, "$1")), e = e.toLowerCase() in t || e === "onFocusOut" || e === "onFocusIn" ? e.toLowerCase().slice(2) : e.slice(2), t.l || (t.l = {}), t.l[e + s] = r, r ? n ? r.u = n.u : (r.u = bb, t.addEventListener(e, s ? U1 : F1, s)) : t.removeEventListener(e, s ? U1 : F1, s);
  else {
    if (i == "http://www.w3.org/2000/svg") e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if (e != "width" && e != "height" && e != "href" && e != "list" && e != "form" && e != "tabIndex" && e != "download" && e != "rowSpan" && e != "colSpan" && e != "role" && e != "popover" && e in t) try {
      t[e] = r ?? "";
      break e;
    } catch {
    }
    typeof r == "function" || (r == null || r === !1 && e[4] !== "-" ? t.removeAttribute(e) : t.setAttribute(e, e == "popover" && r == 1 ? "" : r));
  }
}
function d6(t) {
  return function(e) {
    if (this.l) {
      var r = this.l[e.type + t];
      if (e.t == null) e.t = bb++;
      else if (e.t < r.u) return;
      return r(Jr.event ? Jr.event(e) : e);
    }
  };
}
function xb(t, e, r, n, i, s, o, a, u, h) {
  var d, p, x, A, I, N, L, F, $, W, z, V, te, R, K, pe, _e, Y = e.type;
  if (e.constructor !== void 0) return null;
  128 & r.__u && (u = !!(32 & r.__u), s = [a = e.__e = r.__e]), (d = Jr.__b) && d(e);
  e: if (typeof Y == "function") try {
    if (F = e.props, $ = "prototype" in Y && Y.prototype.render, W = (d = Y.contextType) && n[d.__c], z = d ? W ? W.props.value : d.__ : n, r.__c ? L = (p = e.__c = r.__c).__ = p.__E : ($ ? e.__c = p = new Y(F, z) : (e.__c = p = new Od(F, z), p.constructor = Y, p.render = AY), W && W.sub(p), p.props = F, p.state || (p.state = {}), p.context = z, p.__n = n, x = p.__d = !0, p.__h = [], p._sb = []), $ && p.__s == null && (p.__s = p.state), $ && Y.getDerivedStateFromProps != null && (p.__s == p.state && (p.__s = ha({}, p.__s)), ha(p.__s, Y.getDerivedStateFromProps(F, p.__s))), A = p.props, I = p.state, p.__v = e, x) $ && Y.getDerivedStateFromProps == null && p.componentWillMount != null && p.componentWillMount(), $ && p.componentDidMount != null && p.__h.push(p.componentDidMount);
    else {
      if ($ && Y.getDerivedStateFromProps == null && F !== A && p.componentWillReceiveProps != null && p.componentWillReceiveProps(F, z), !p.__e && (p.shouldComponentUpdate != null && p.shouldComponentUpdate(F, p.__s, z) === !1 || e.__v === r.__v)) {
        for (e.__v !== r.__v && (p.props = F, p.state = p.__s, p.__d = !1), e.__e = r.__e, e.__k = r.__k, e.__k.some(function(S) {
          S && (S.__ = e);
        }), V = 0; V < p._sb.length; V++) p.__h.push(p._sb[V]);
        p._sb = [], p.__h.length && o.push(p);
        break e;
      }
      p.componentWillUpdate != null && p.componentWillUpdate(F, p.__s, z), $ && p.componentDidUpdate != null && p.__h.push(function() {
        p.componentDidUpdate(A, I, N);
      });
    }
    if (p.context = z, p.props = F, p.__P = t, p.__e = !1, te = Jr.__r, R = 0, $) {
      for (p.state = p.__s, p.__d = !1, te && te(e), d = p.render(p.props, p.state, p.context), K = 0; K < p._sb.length; K++) p.__h.push(p._sb[K]);
      p._sb = [];
    } else do
      p.__d = !1, te && te(e), d = p.render(p.props, p.state, p.context), p.state = p.__s;
    while (p.__d && ++R < 25);
    p.state = p.__s, p.getChildContext != null && (n = ha(ha({}, n), p.getChildContext())), $ && !x && p.getSnapshotBeforeUpdate != null && (N = p.getSnapshotBeforeUpdate(A, I)), a = rS(t, yb(pe = d != null && d.type === nh && d.key == null ? d.props.children : d) ? pe : [pe], e, r, n, i, s, o, a, u, h), p.base = e.__e, e.__u &= -161, p.__h.length && o.push(p), L && (p.__E = p.__ = null);
  } catch (S) {
    if (e.__v = null, u || s != null) if (S.then) {
      for (e.__u |= u ? 160 : 128; a && a.nodeType === 8 && a.nextSibling; ) a = a.nextSibling;
      s[s.indexOf(a)] = null, e.__e = a;
    } else for (_e = s.length; _e--; ) wb(s[_e]);
    else e.__e = r.__e, e.__k = r.__k;
    Jr.__e(S, e, r);
  }
  else s == null && e.__v === r.__v ? (e.__k = r.__k, e.__e = r.__e) : a = e.__e = SY(r.__e, e, r, n, i, s, o, u, h);
  return (d = Jr.diffed) && d(e), 128 & e.__u ? void 0 : a;
}
function iS(t, e, r) {
  for (var n = 0; n < r.length; n++) _b(r[n], r[++n], r[++n]);
  Jr.__c && Jr.__c(e, t), t.some(function(i) {
    try {
      t = i.__h, i.__h = [], t.some(function(s) {
        s.call(i);
      });
    } catch (s) {
      Jr.__e(s, i.__v);
    }
  });
}
function SY(t, e, r, n, i, s, o, a, u) {
  var h, d, p, x, A, I, N, L = r.props, F = e.props, $ = e.type;
  if ($ === "svg" ? i = "http://www.w3.org/2000/svg" : $ === "math" ? i = "http://www.w3.org/1998/Math/MathML" : i || (i = "http://www.w3.org/1999/xhtml"), s != null) {
    for (h = 0; h < s.length; h++) if ((A = s[h]) && "setAttribute" in A == !!$ && ($ ? A.localName === $ : A.nodeType === 3)) {
      t = A, s[h] = null;
      break;
    }
  }
  if (t == null) {
    if ($ === null) return document.createTextNode(F);
    t = document.createElementNS(i, $, F.is && F), a && (Jr.__m && Jr.__m(e, s), a = !1), s = null;
  }
  if ($ === null) L === F || a && t.data === F || (t.data = F);
  else {
    if (s = s && up.call(t.childNodes), L = r.props || Sl, !a && s != null) for (L = {}, h = 0; h < t.attributes.length; h++) L[(A = t.attributes[h]).name] = A.value;
    for (h in L) if (A = L[h], h != "children") {
      if (h == "dangerouslySetInnerHTML") p = A;
      else if (!(h in F)) {
        if (h == "value" && "defaultValue" in F || h == "checked" && "defaultChecked" in F) continue;
        dd(t, h, null, A, i);
      }
    }
    for (h in F) A = F[h], h == "children" ? x = A : h == "dangerouslySetInnerHTML" ? d = A : h == "value" ? I = A : h == "checked" ? N = A : a && typeof A != "function" || L[h] === A || dd(t, h, A, L[h], i);
    if (d) a || p && (d.__html === p.__html || d.__html === t.innerHTML) || (t.innerHTML = d.__html), e.__k = [];
    else if (p && (t.innerHTML = ""), rS(t, yb(x) ? x : [x], e, r, n, $ === "foreignObject" ? "http://www.w3.org/1999/xhtml" : i, s, o, s ? s[0] : r.__k && Su(r, 0), a, u), s != null) for (h = s.length; h--; ) wb(s[h]);
    a || (h = "value", $ === "progress" && I == null ? t.removeAttribute("value") : I !== void 0 && (I !== t[h] || $ === "progress" && !I || $ === "option" && I !== L[h]) && dd(t, h, I, L[h], i), h = "checked", N !== void 0 && N !== t[h] && dd(t, h, N, L[h], i));
  }
  return t;
}
function _b(t, e, r) {
  try {
    if (typeof t == "function") {
      var n = typeof t.__u == "function";
      n && t.__u(), n && e == null || (t.__u = t(e));
    } else t.current = e;
  } catch (i) {
    Jr.__e(i, r);
  }
}
function sS(t, e, r) {
  var n, i;
  if (Jr.unmount && Jr.unmount(t), (n = t.ref) && (n.current && n.current !== t.__e || _b(n, null, e)), (n = t.__c) != null) {
    if (n.componentWillUnmount) try {
      n.componentWillUnmount();
    } catch (s) {
      Jr.__e(s, e);
    }
    n.base = n.__P = null;
  }
  if (n = t.__k) for (i = 0; i < n.length; i++) n[i] && sS(n[i], e, r || typeof t.type != "function");
  r || wb(t.__e), t.__c = t.__ = t.__e = void 0;
}
function AY(t, e, r) {
  return this.constructor(t, r);
}
function j1(t, e, r) {
  var n, i, s, o;
  e === document && (e = document.documentElement), Jr.__ && Jr.__(t, e), i = (n = typeof r == "function") ? null : e.__k, s = [], o = [], xb(e, t = (!n && r || e).__k = Nr(nh, null, [t]), i || Sl, Sl, e.namespaceURI, !n && r ? [r] : i ? null : e.firstChild ? up.call(e.childNodes) : null, s, !n && r ? r : i ? i.__e : e.firstChild, n, o), iS(s, t, o);
}
up = eS.slice, Jr = { __e: function(t, e, r, n) {
  for (var i, s, o; e = e.__; ) if ((i = e.__c) && !i.__) try {
    if ((s = i.constructor) && s.getDerivedStateFromError != null && (i.setState(s.getDerivedStateFromError(t)), o = i.__d), i.componentDidCatch != null && (i.componentDidCatch(t, n || {}), o = i.__d), o) return i.__E = i;
  } catch (a) {
    t = a;
  }
  throw t;
} }, XE = 0, Od.prototype.setState = function(t, e) {
  var r;
  r = this.__s != null && this.__s !== this.state ? this.__s : this.__s = ha({}, this.state), typeof t == "function" && (t = t(ha({}, r), this.props)), t && ha(r, t), t != null && this.__v && (e && this._sb.push(e), l6(this));
}, Od.prototype.forceUpdate = function(t) {
  this.__v && (this.__e = !0, t && this.__h.push(t), l6(this));
}, Od.prototype.render = nh, Xa = [], ZE = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, B1 = function(t, e) {
  return t.__v.__b - e.__v.__b;
}, h0.__r = 0, QE = /(PointerCapture)$|Capture$/i, bb = 0, F1 = d6(!1), U1 = d6(!0);
var d0, pn, Mm, p6, q1 = 0, oS = [], yn = Jr, g6 = yn.__b, m6 = yn.__r, v6 = yn.diffed, b6 = yn.__c, y6 = yn.unmount, w6 = yn.__;
function aS(t, e) {
  yn.__h && yn.__h(pn, t, q1 || e), q1 = 0;
  var r = pn.__H || (pn.__H = { __: [], __h: [] });
  return t >= r.__.length && r.__.push({}), r.__[t];
}
function x6(t) {
  return q1 = 1, PY(cS, t);
}
function PY(t, e, r) {
  var n = aS(d0++, 2);
  if (n.t = t, !n.__c && (n.__ = [cS(void 0, e), function(a) {
    var u = n.__N ? n.__N[0] : n.__[0], h = n.t(u, a);
    u !== h && (n.__N = [h, n.__[1]], n.__c.setState({}));
  }], n.__c = pn, !pn.u)) {
    var i = function(a, u, h) {
      if (!n.__c.__H) return !0;
      var d = n.__c.__H.__.filter(function(x) {
        return !!x.__c;
      });
      if (d.every(function(x) {
        return !x.__N;
      })) return !s || s.call(this, a, u, h);
      var p = n.__c.props !== a;
      return d.forEach(function(x) {
        if (x.__N) {
          var A = x.__[0];
          x.__ = x.__N, x.__N = void 0, A !== x.__[0] && (p = !0);
        }
      }), s && s.call(this, a, u, h) || p;
    };
    pn.u = !0;
    var s = pn.shouldComponentUpdate, o = pn.componentWillUpdate;
    pn.componentWillUpdate = function(a, u, h) {
      if (this.__e) {
        var d = s;
        s = void 0, i(a, u, h), s = d;
      }
      o && o.call(this, a, u, h);
    }, pn.shouldComponentUpdate = i;
  }
  return n.__N || n.__;
}
function MY(t, e) {
  var r = aS(d0++, 3);
  !yn.__s && TY(r.__H, e) && (r.__ = t, r.i = e, pn.__H.__h.push(r));
}
function IY() {
  for (var t; t = oS.shift(); ) if (t.__P && t.__H) try {
    t.__H.__h.forEach(Nd), t.__H.__h.forEach(z1), t.__H.__h = [];
  } catch (e) {
    t.__H.__h = [], yn.__e(e, t.__v);
  }
}
yn.__b = function(t) {
  pn = null, g6 && g6(t);
}, yn.__ = function(t, e) {
  t && e.__k && e.__k.__m && (t.__m = e.__k.__m), w6 && w6(t, e);
}, yn.__r = function(t) {
  m6 && m6(t), d0 = 0;
  var e = (pn = t.__c).__H;
  e && (Mm === pn ? (e.__h = [], pn.__h = [], e.__.forEach(function(r) {
    r.__N && (r.__ = r.__N), r.i = r.__N = void 0;
  })) : (e.__h.forEach(Nd), e.__h.forEach(z1), e.__h = [], d0 = 0)), Mm = pn;
}, yn.diffed = function(t) {
  v6 && v6(t);
  var e = t.__c;
  e && e.__H && (e.__H.__h.length && (oS.push(e) !== 1 && p6 === yn.requestAnimationFrame || ((p6 = yn.requestAnimationFrame) || CY)(IY)), e.__H.__.forEach(function(r) {
    r.i && (r.__H = r.i), r.i = void 0;
  })), Mm = pn = null;
}, yn.__c = function(t, e) {
  e.some(function(r) {
    try {
      r.__h.forEach(Nd), r.__h = r.__h.filter(function(n) {
        return !n.__ || z1(n);
      });
    } catch (n) {
      e.some(function(i) {
        i.__h && (i.__h = []);
      }), e = [], yn.__e(n, r.__v);
    }
  }), b6 && b6(t, e);
}, yn.unmount = function(t) {
  y6 && y6(t);
  var e, r = t.__c;
  r && r.__H && (r.__H.__.forEach(function(n) {
    try {
      Nd(n);
    } catch (i) {
      e = i;
    }
  }), r.__H = void 0, e && yn.__e(e, r.__v));
};
var _6 = typeof requestAnimationFrame == "function";
function CY(t) {
  var e, r = function() {
    clearTimeout(n), _6 && cancelAnimationFrame(e), setTimeout(t);
  }, n = setTimeout(r, 100);
  _6 && (e = requestAnimationFrame(r));
}
function Nd(t) {
  var e = pn, r = t.__c;
  typeof r == "function" && (t.__c = void 0, r()), pn = e;
}
function z1(t) {
  var e = pn;
  t.__c = t.__(), pn = e;
}
function TY(t, e) {
  return !t || t.length !== e.length || e.some(function(r, n) {
    return r !== t[n];
  });
}
function cS(t, e) {
  return typeof e == "function" ? e(t) : e;
}
const RY = ".-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}", DY = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+", OY = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=";
class NY {
  constructor() {
    this.items = /* @__PURE__ */ new Map(), this.nextItemKey = 0, this.root = null, this.darkMode = GE();
  }
  attach(e) {
    this.root = document.createElement("div"), this.root.className = "-cbwsdk-snackbar-root", e.appendChild(this.root), this.render();
  }
  presentItem(e) {
    const r = this.nextItemKey++;
    return this.items.set(r, e), this.render(), () => {
      this.items.delete(r), this.render();
    };
  }
  clear() {
    this.items.clear(), this.render();
  }
  render() {
    this.root && j1(Nr(
      "div",
      null,
      Nr(uS, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([e, r]) => Nr(LY, Object.assign({}, r, { key: e }))))
    ), this.root);
  }
}
const uS = (t) => Nr(
  "div",
  { class: Kf("-cbwsdk-snackbar-container") },
  Nr("style", null, RY),
  Nr("div", { class: "-cbwsdk-snackbar" }, t.children)
), LY = ({ autoExpand: t, message: e, menuItems: r }) => {
  const [n, i] = x6(!0), [s, o] = x6(t ?? !1);
  MY(() => {
    const u = [
      window.setTimeout(() => {
        i(!1);
      }, 1),
      window.setTimeout(() => {
        o(!0);
      }, 1e4)
    ];
    return () => {
      u.forEach(window.clearTimeout);
    };
  });
  const a = () => {
    o(!s);
  };
  return Nr(
    "div",
    { class: Kf("-cbwsdk-snackbar-instance", n && "-cbwsdk-snackbar-instance-hidden", s && "-cbwsdk-snackbar-instance-expanded") },
    Nr(
      "div",
      { class: "-cbwsdk-snackbar-instance-header", onClick: a },
      Nr("img", { src: DY, class: "-cbwsdk-snackbar-instance-header-cblogo" }),
      " ",
      Nr("div", { class: "-cbwsdk-snackbar-instance-header-message" }, e),
      Nr(
        "div",
        { class: "-gear-container" },
        !s && Nr(
          "svg",
          { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
          Nr("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" })
        ),
        Nr("img", { src: OY, class: "-gear-icon", title: "Expand" })
      )
    ),
    r && r.length > 0 && Nr("div", { class: "-cbwsdk-snackbar-instance-menu" }, r.map((u, h) => Nr(
      "div",
      { class: Kf("-cbwsdk-snackbar-instance-menu-item", u.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"), onClick: u.onClick, key: h },
      Nr(
        "svg",
        { width: u.svgWidth, height: u.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        Nr("path", { "fill-rule": u.defaultFillRule, "clip-rule": u.defaultClipRule, d: u.path, fill: "#AAAAAA" })
      ),
      Nr("span", { class: Kf("-cbwsdk-snackbar-instance-menu-item-info", u.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red") }, u.info)
    )))
  );
};
class kY {
  constructor() {
    this.attached = !1, this.snackbar = new NY();
  }
  attach() {
    if (this.attached)
      throw new Error("Coinbase Wallet SDK UI is already attached");
    const e = document.documentElement, r = document.createElement("div");
    r.className = "-cbwsdk-css-reset", e.appendChild(r), this.snackbar.attach(r), this.attached = !0, YE();
  }
  showConnecting(e) {
    let r;
    return e.isUnlinkedErrorState ? r = {
      autoExpand: !0,
      message: "Connection lost",
      menuItems: [
        {
          isRed: !1,
          info: "Reset connection",
          svgWidth: "10",
          svgHeight: "11",
          path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
          defaultFillRule: "evenodd",
          defaultClipRule: "evenodd",
          onClick: e.onResetConnection
        }
      ]
    } : r = {
      message: "Confirm on phone",
      menuItems: [
        {
          isRed: !0,
          info: "Cancel transaction",
          svgWidth: "11",
          svgHeight: "11",
          path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
          defaultFillRule: "inherit",
          defaultClipRule: "inherit",
          onClick: e.onCancel
        },
        {
          isRed: !1,
          info: "Reset connection",
          svgWidth: "10",
          svgHeight: "11",
          path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
          defaultFillRule: "evenodd",
          defaultClipRule: "evenodd",
          onClick: e.onResetConnection
        }
      ]
    }, this.snackbar.presentItem(r);
  }
}
const $Y = ".-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop{position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s;background-color:rgba(10,11,13,.5)}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box{display:block;position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);padding:20px;border-radius:8px;background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box p{display:block;font-weight:400;font-size:14px;line-height:20px;padding-bottom:12px;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box button{appearance:none;border:none;background:none;color:#0052ff;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark{background-color:#0a0b0d;color:#fff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark button{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light{background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light button{color:#0052ff}";
class BY {
  constructor() {
    this.root = null, this.darkMode = GE();
  }
  attach() {
    const e = document.documentElement;
    this.root = document.createElement("div"), this.root.className = "-cbwsdk-css-reset", e.appendChild(this.root), YE();
  }
  present(e) {
    this.render(e);
  }
  clear() {
    this.render(null);
  }
  render(e) {
    this.root && (j1(null, this.root), e && j1(Nr(FY, Object.assign({}, e, { onDismiss: () => {
      this.clear();
    }, darkMode: this.darkMode })), this.root));
  }
}
const FY = ({ title: t, buttonText: e, darkMode: r, onButtonClick: n, onDismiss: i }) => {
  const s = r ? "dark" : "light";
  return Nr(
    uS,
    { darkMode: r },
    Nr(
      "div",
      { class: "-cbwsdk-redirect-dialog" },
      Nr("style", null, $Y),
      Nr("div", { class: "-cbwsdk-redirect-dialog-backdrop", onClick: i }),
      Nr(
        "div",
        { class: Kf("-cbwsdk-redirect-dialog-box", s) },
        Nr("p", null, t),
        Nr("button", { onClick: n }, e)
      )
    )
  );
}, UY = "https://keys.coinbase.com/connect", E6 = "https://www.walletlink.org", jY = "https://go.cb-w.com/walletlink";
class S6 {
  constructor() {
    this.attached = !1, this.redirectDialog = new BY();
  }
  attach() {
    if (this.attached)
      throw new Error("Coinbase Wallet SDK UI is already attached");
    this.redirectDialog.attach(), this.attached = !0;
  }
  redirectToCoinbaseWallet(e) {
    const r = new URL(jY);
    r.searchParams.append("redirect_url", bY().href), e && r.searchParams.append("wl_url", e);
    const n = document.createElement("a");
    n.target = "cbw-opener", n.href = r.href, n.rel = "noreferrer noopener", n.click();
  }
  openCoinbaseWalletDeeplink(e) {
    this.redirectDialog.present({
      title: "Redirecting to Coinbase Wallet...",
      buttonText: "Open",
      onButtonClick: () => {
        this.redirectToCoinbaseWallet(e);
      }
    }), setTimeout(() => {
      this.redirectToCoinbaseWallet(e);
    }, 99);
  }
  showConnecting(e) {
    return () => {
      this.redirectDialog.clear();
    };
  }
}
class xo {
  constructor(e) {
    this.chainCallbackParams = { chainId: "", jsonRpcUrl: "" }, this.isMobileWeb = yY(), this.linkedUpdated = (s) => {
      this.isLinked = s;
      const o = this.storage.getItem($1);
      if (s && (this._session.linked = s), this.isUnlinkedErrorState = !1, o) {
        const a = o.split(" "), u = this.storage.getItem("IsStandaloneSigning") === "true";
        a[0] !== "" && !s && this._session.linked && !u && (this.isUnlinkedErrorState = !0);
      }
    }, this.metadataUpdated = (s, o) => {
      this.storage.setItem(s, o);
    }, this.chainUpdated = (s, o) => {
      this.chainCallbackParams.chainId === s && this.chainCallbackParams.jsonRpcUrl === o || (this.chainCallbackParams = {
        chainId: s,
        jsonRpcUrl: o
      }, this.chainCallback && this.chainCallback(o, Number.parseInt(s, 10)));
    }, this.accountUpdated = (s) => {
      this.accountsCallback && this.accountsCallback([s]), xo.accountRequestCallbackIds.size > 0 && (Array.from(xo.accountRequestCallbackIds.values()).forEach((o) => {
        this.invokeCallback(o, {
          method: "requestEthereumAccounts",
          result: [s]
        });
      }), xo.accountRequestCallbackIds.clear());
    }, this.resetAndReload = this.resetAndReload.bind(this), this.linkAPIUrl = e.linkAPIUrl, this.storage = e.storage, this.metadata = e.metadata, this.accountsCallback = e.accountsCallback, this.chainCallback = e.chainCallback;
    const { session: r, ui: n, connection: i } = this.subscribe();
    this._session = r, this.connection = i, this.relayEventManager = new mY(), this.ui = n, this.ui.attach();
  }
  subscribe() {
    const e = du.load(this.storage) || du.create(this.storage), { linkAPIUrl: r } = this, n = new gY({
      session: e,
      linkAPIUrl: r,
      listener: this
    }), i = this.isMobileWeb ? new S6() : new kY();
    return n.connect(), { session: e, ui: i, connection: n };
  }
  resetAndReload() {
    this.connection.destroy().then(() => {
      const e = du.load(this.storage);
      (e == null ? void 0 : e.id) === this._session.id && Zs.clearAll(), document.location.reload();
    }).catch((e) => {
    });
  }
  signEthereumTransaction(e) {
    return this.sendRequest({
      method: "signEthereumTransaction",
      params: {
        fromAddress: e.fromAddress,
        toAddress: e.toAddress,
        weiValue: Ls(e.weiValue),
        data: zf(e.data, !0),
        nonce: e.nonce,
        gasPriceInWei: e.gasPriceInWei ? Ls(e.gasPriceInWei) : null,
        maxFeePerGas: e.gasPriceInWei ? Ls(e.gasPriceInWei) : null,
        maxPriorityFeePerGas: e.gasPriceInWei ? Ls(e.gasPriceInWei) : null,
        gasLimit: e.gasLimit ? Ls(e.gasLimit) : null,
        chainId: e.chainId,
        shouldSubmit: !1
      }
    });
  }
  signAndSubmitEthereumTransaction(e) {
    return this.sendRequest({
      method: "signEthereumTransaction",
      params: {
        fromAddress: e.fromAddress,
        toAddress: e.toAddress,
        weiValue: Ls(e.weiValue),
        data: zf(e.data, !0),
        nonce: e.nonce,
        gasPriceInWei: e.gasPriceInWei ? Ls(e.gasPriceInWei) : null,
        maxFeePerGas: e.maxFeePerGas ? Ls(e.maxFeePerGas) : null,
        maxPriorityFeePerGas: e.maxPriorityFeePerGas ? Ls(e.maxPriorityFeePerGas) : null,
        gasLimit: e.gasLimit ? Ls(e.gasLimit) : null,
        chainId: e.chainId,
        shouldSubmit: !0
      }
    });
  }
  submitEthereumTransaction(e, r) {
    return this.sendRequest({
      method: "submitEthereumTransaction",
      params: {
        signedTransaction: zf(e, !0),
        chainId: r
      }
    });
  }
  getWalletLinkSession() {
    return this._session;
  }
  sendRequest(e) {
    let r = null;
    const n = Ya(8), i = (s) => {
      this.publishWeb3RequestCanceledEvent(n), this.handleErrorResponse(n, e.method, s), r == null || r();
    };
    return new Promise((s, o) => {
      r = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: i,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      }), this.relayEventManager.callbacks.set(n, (a) => {
        if (r == null || r(), Bn(a))
          return o(new Error(a.errorMessage));
        s(a);
      }), this.publishWeb3RequestEvent(n, e);
    });
  }
  publishWeb3RequestEvent(e, r) {
    const n = { type: "WEB3_REQUEST", id: e, request: r };
    this.publishEvent("Web3Request", n, !0).then((i) => {
    }).catch((i) => {
      this.handleWeb3ResponseMessage(n.id, {
        method: r.method,
        errorMessage: i.message
      });
    }), this.isMobileWeb && this.openCoinbaseWalletDeeplink(r.method);
  }
  // copied from MobileRelay
  openCoinbaseWalletDeeplink(e) {
    if (this.ui instanceof S6)
      switch (e) {
        case "requestEthereumAccounts":
        case "switchEthereumChain":
          return;
        default:
          window.addEventListener("blur", () => {
            window.addEventListener("focus", () => {
              this.connection.checkUnseenEvents();
            }, { once: !0 });
          }, { once: !0 }), this.ui.openCoinbaseWalletDeeplink();
          break;
      }
  }
  publishWeb3RequestCanceledEvent(e) {
    const r = {
      type: "WEB3_REQUEST_CANCELED",
      id: e
    };
    this.publishEvent("Web3RequestCanceled", r, !1).then();
  }
  publishEvent(e, r, n) {
    return this.connection.publishEvent(e, r, n);
  }
  handleWeb3ResponseMessage(e, r) {
    if (r.method === "requestEthereumAccounts") {
      xo.accountRequestCallbackIds.forEach((n) => this.invokeCallback(n, r)), xo.accountRequestCallbackIds.clear();
      return;
    }
    this.invokeCallback(e, r);
  }
  handleErrorResponse(e, r, n) {
    var i;
    const s = (i = n == null ? void 0 : n.message) !== null && i !== void 0 ? i : "Unspecified error message.";
    this.handleWeb3ResponseMessage(e, {
      method: r,
      errorMessage: s
    });
  }
  invokeCallback(e, r) {
    const n = this.relayEventManager.callbacks.get(e);
    n && (n(r), this.relayEventManager.callbacks.delete(e));
  }
  requestEthereumAccounts() {
    const { appName: e, appLogoUrl: r } = this.metadata, n = {
      method: "requestEthereumAccounts",
      params: {
        appName: e,
        appLogoUrl: r
      }
    }, i = Ya(8);
    return new Promise((s, o) => {
      this.relayEventManager.callbacks.set(i, (a) => {
        if (Bn(a))
          return o(new Error(a.errorMessage));
        s(a);
      }), xo.accountRequestCallbackIds.add(i), this.publishWeb3RequestEvent(i, n);
    });
  }
  watchAsset(e, r, n, i, s, o) {
    const a = {
      method: "watchAsset",
      params: {
        type: e,
        options: {
          address: r,
          symbol: n,
          decimals: i,
          image: s
        },
        chainId: o
      }
    };
    let u = null;
    const h = Ya(8), d = (p) => {
      this.publishWeb3RequestCanceledEvent(h), this.handleErrorResponse(h, a.method, p), u == null || u();
    };
    return u = this.ui.showConnecting({
      isUnlinkedErrorState: this.isUnlinkedErrorState,
      onCancel: d,
      onResetConnection: this.resetAndReload
      // eslint-disable-line @typescript-eslint/unbound-method
    }), new Promise((p, x) => {
      this.relayEventManager.callbacks.set(h, (A) => {
        if (u == null || u(), Bn(A))
          return x(new Error(A.errorMessage));
        p(A);
      }), this.publishWeb3RequestEvent(h, a);
    });
  }
  addEthereumChain(e, r, n, i, s, o) {
    const a = {
      method: "addEthereumChain",
      params: {
        chainId: e,
        rpcUrls: r,
        blockExplorerUrls: i,
        chainName: s,
        iconUrls: n,
        nativeCurrency: o
      }
    };
    let u = null;
    const h = Ya(8), d = (p) => {
      this.publishWeb3RequestCanceledEvent(h), this.handleErrorResponse(h, a.method, p), u == null || u();
    };
    return u = this.ui.showConnecting({
      isUnlinkedErrorState: this.isUnlinkedErrorState,
      onCancel: d,
      onResetConnection: this.resetAndReload
      // eslint-disable-line @typescript-eslint/unbound-method
    }), new Promise((p, x) => {
      this.relayEventManager.callbacks.set(h, (A) => {
        if (u == null || u(), Bn(A))
          return x(new Error(A.errorMessage));
        p(A);
      }), this.publishWeb3RequestEvent(h, a);
    });
  }
  switchEthereumChain(e, r) {
    const n = {
      method: "switchEthereumChain",
      params: Object.assign({ chainId: e }, { address: r })
    };
    let i = null;
    const s = Ya(8), o = (a) => {
      this.publishWeb3RequestCanceledEvent(s), this.handleErrorResponse(s, n.method, a), i == null || i();
    };
    return i = this.ui.showConnecting({
      isUnlinkedErrorState: this.isUnlinkedErrorState,
      onCancel: o,
      onResetConnection: this.resetAndReload
      // eslint-disable-line @typescript-eslint/unbound-method
    }), new Promise((a, u) => {
      this.relayEventManager.callbacks.set(s, (h) => {
        if (i == null || i(), Bn(h) && h.errorCode)
          return u(Sr.provider.custom({
            code: h.errorCode,
            message: "Unrecognized chain ID. Try adding the chain using addEthereumChain first."
          }));
        if (Bn(h))
          return u(new Error(h.errorMessage));
        a(h);
      }), this.publishWeb3RequestEvent(s, n);
    });
  }
}
xo.accountRequestCallbackIds = /* @__PURE__ */ new Set();
const A6 = "DefaultChainId", P6 = "DefaultJsonRpcUrl";
class fS {
  constructor(e) {
    this._relay = null, this._addresses = [], this.metadata = e.metadata, this._storage = new Zs("walletlink", E6), this.callback = e.callback || null;
    const r = this._storage.getItem($1);
    if (r) {
      const n = r.split(" ");
      n[0] !== "" && (this._addresses = n.map((i) => Qo(i)));
    }
    this.initializeRelay();
  }
  getSession() {
    const e = this.initializeRelay(), { id: r, secret: n } = e.getWalletLinkSession();
    return { id: r, secret: n };
  }
  async handshake() {
    await this._eth_requestAccounts();
  }
  get selectedAddress() {
    return this._addresses[0] || void 0;
  }
  get jsonRpcUrl() {
    var e;
    return (e = this._storage.getItem(P6)) !== null && e !== void 0 ? e : void 0;
  }
  set jsonRpcUrl(e) {
    this._storage.setItem(P6, e);
  }
  updateProviderInfo(e, r) {
    var n;
    this.jsonRpcUrl = e;
    const i = this.getChainId();
    this._storage.setItem(A6, r.toString(10)), Hf(r) !== i && ((n = this.callback) === null || n === void 0 || n.call(this, "chainChanged", la(r)));
  }
  async watchAsset(e) {
    const r = Array.isArray(e) ? e[0] : e;
    if (!r.type)
      throw Sr.rpc.invalidParams("Type is required");
    if ((r == null ? void 0 : r.type) !== "ERC20")
      throw Sr.rpc.invalidParams(`Asset of type '${r.type}' is not supported`);
    if (!(r != null && r.options))
      throw Sr.rpc.invalidParams("Options are required");
    if (!(r != null && r.options.address))
      throw Sr.rpc.invalidParams("Address is required");
    const n = this.getChainId(), { address: i, symbol: s, image: o, decimals: a } = r.options, h = await this.initializeRelay().watchAsset(r.type, i, s, a, o, n == null ? void 0 : n.toString());
    return Bn(h) ? !1 : !!h.result;
  }
  async addEthereumChain(e) {
    var r, n;
    const i = e[0];
    if (((r = i.rpcUrls) === null || r === void 0 ? void 0 : r.length) === 0)
      throw Sr.rpc.invalidParams("please pass in at least 1 rpcUrl");
    if (!i.chainName || i.chainName.trim() === "")
      throw Sr.rpc.invalidParams("chainName is a required field");
    if (!i.nativeCurrency)
      throw Sr.rpc.invalidParams("nativeCurrency is a required field");
    const s = Number.parseInt(i.chainId, 16);
    if (s === this.getChainId())
      return !1;
    const o = this.initializeRelay(), { rpcUrls: a = [], blockExplorerUrls: u = [], chainName: h, iconUrls: d = [], nativeCurrency: p } = i, x = await o.addEthereumChain(s.toString(), a, d, u, h, p);
    if (Bn(x))
      return !1;
    if (((n = x.result) === null || n === void 0 ? void 0 : n.isApproved) === !0)
      return this.updateProviderInfo(a[0], s), null;
    throw Sr.rpc.internal("unable to add ethereum chain");
  }
  async switchEthereumChain(e) {
    const r = e[0], n = Number.parseInt(r.chainId, 16), s = await this.initializeRelay().switchEthereumChain(n.toString(10), this.selectedAddress || void 0);
    if (Bn(s))
      throw s;
    const o = s.result;
    return o.isApproved && o.rpcUrl.length > 0 && this.updateProviderInfo(o.rpcUrl, n), null;
  }
  async cleanup() {
    this.callback = null, this._relay && this._relay.resetAndReload(), this._storage.clear();
  }
  _setAddresses(e, r) {
    var n;
    if (!Array.isArray(e))
      throw new Error("addresses is not an array");
    const i = e.map((s) => Qo(s));
    JSON.stringify(i) !== JSON.stringify(this._addresses) && (this._addresses = i, (n = this.callback) === null || n === void 0 || n.call(this, "accountsChanged", i), this._storage.setItem($1, i.join(" ")));
  }
  async request(e) {
    const r = e.params || [];
    switch (e.method) {
      case "eth_accounts":
        return [...this._addresses];
      case "eth_coinbase":
        return this.selectedAddress || null;
      case "net_version":
        return this.getChainId().toString(10);
      case "eth_chainId":
        return la(this.getChainId());
      case "eth_requestAccounts":
        return this._eth_requestAccounts();
      case "eth_ecRecover":
      case "personal_ecRecover":
        return this.ecRecover(e);
      case "personal_sign":
        return this.personalSign(e);
      case "eth_signTransaction":
        return this._eth_signTransaction(r);
      case "eth_sendRawTransaction":
        return this._eth_sendRawTransaction(r);
      case "eth_sendTransaction":
        return this._eth_sendTransaction(r);
      case "eth_signTypedData_v1":
      case "eth_signTypedData_v3":
      case "eth_signTypedData_v4":
      case "eth_signTypedData":
        return this.signTypedData(e);
      case "wallet_addEthereumChain":
        return this.addEthereumChain(r);
      case "wallet_switchEthereumChain":
        return this.switchEthereumChain(r);
      case "wallet_watchAsset":
        return this.watchAsset(r);
      default:
        if (!this.jsonRpcUrl)
          throw Sr.rpc.internal("No RPC URL set for chain");
        return $E(e, this.jsonRpcUrl);
    }
  }
  _ensureKnownAddress(e) {
    const r = Qo(e);
    if (!this._addresses.map((i) => Qo(i)).includes(r))
      throw new Error("Unknown Ethereum address");
  }
  _prepareTransactionParams(e) {
    const r = e.from ? Qo(e.from) : this.selectedAddress;
    if (!r)
      throw new Error("Ethereum address is unavailable");
    this._ensureKnownAddress(r);
    const n = e.to ? Qo(e.to) : null, i = e.value != null ? Cf(e.value) : BigInt(0), s = e.data ? k1(e.data) : Buffer.alloc(0), o = e.nonce != null ? Hf(e.nonce) : null, a = e.gasPrice != null ? Cf(e.gasPrice) : null, u = e.maxFeePerGas != null ? Cf(e.maxFeePerGas) : null, h = e.maxPriorityFeePerGas != null ? Cf(e.maxPriorityFeePerGas) : null, d = e.gas != null ? Cf(e.gas) : null, p = e.chainId ? Hf(e.chainId) : this.getChainId();
    return {
      fromAddress: r,
      toAddress: n,
      weiValue: i,
      data: s,
      nonce: o,
      gasPriceInWei: a,
      maxFeePerGas: u,
      maxPriorityFeePerGas: h,
      gasLimit: d,
      chainId: p
    };
  }
  async ecRecover(e) {
    const { method: r, params: n } = e;
    if (!Array.isArray(n))
      throw Sr.rpc.invalidParams();
    const s = await this.initializeRelay().sendRequest({
      method: "ethereumAddressFromSignedMessage",
      params: {
        message: _m(n[0]),
        signature: _m(n[1]),
        addPrefix: r === "personal_ecRecover"
      }
    });
    if (Bn(s))
      throw s;
    return s.result;
  }
  getChainId() {
    var e;
    return Number.parseInt((e = this._storage.getItem(A6)) !== null && e !== void 0 ? e : "1", 10);
  }
  async _eth_requestAccounts() {
    var e, r;
    if (this._addresses.length > 0)
      return (e = this.callback) === null || e === void 0 || e.call(this, "connect", { chainId: la(this.getChainId()) }), this._addresses;
    const i = await this.initializeRelay().requestEthereumAccounts();
    if (Bn(i))
      throw i;
    if (!i.result)
      throw new Error("accounts received is empty");
    return this._setAddresses(i.result), (r = this.callback) === null || r === void 0 || r.call(this, "connect", { chainId: la(this.getChainId()) }), this._addresses;
  }
  async personalSign({ params: e }) {
    if (!Array.isArray(e))
      throw Sr.rpc.invalidParams();
    const r = e[1], n = e[0];
    this._ensureKnownAddress(r);
    const s = await this.initializeRelay().sendRequest({
      method: "signEthereumMessage",
      params: {
        address: Qo(r),
        message: _m(n),
        addPrefix: !0,
        typedDataJson: null
      }
    });
    if (Bn(s))
      throw s;
    return s.result;
  }
  async _eth_signTransaction(e) {
    const r = this._prepareTransactionParams(e[0] || {}), i = await this.initializeRelay().signEthereumTransaction(r);
    if (Bn(i))
      throw i;
    return i.result;
  }
  async _eth_sendRawTransaction(e) {
    const r = k1(e[0]), i = await this.initializeRelay().submitEthereumTransaction(r, this.getChainId());
    if (Bn(i))
      throw i;
    return i.result;
  }
  async _eth_sendTransaction(e) {
    const r = this._prepareTransactionParams(e[0] || {}), i = await this.initializeRelay().signAndSubmitEthereumTransaction(r);
    if (Bn(i))
      throw i;
    return i.result;
  }
  async signTypedData(e) {
    const { method: r, params: n } = e;
    if (!Array.isArray(n))
      throw Sr.rpc.invalidParams();
    const i = (h) => {
      const d = {
        eth_signTypedData_v1: hd.hashForSignTypedDataLegacy,
        eth_signTypedData_v3: hd.hashForSignTypedData_v3,
        eth_signTypedData_v4: hd.hashForSignTypedData_v4,
        eth_signTypedData: hd.hashForSignTypedData_v4
      };
      return zf(d[r]({
        data: NG(h)
      }), !0);
    }, s = n[r === "eth_signTypedData_v1" ? 1 : 0], o = n[r === "eth_signTypedData_v1" ? 0 : 1];
    this._ensureKnownAddress(s);
    const u = await this.initializeRelay().sendRequest({
      method: "signEthereumMessage",
      params: {
        address: Qo(s),
        message: i(o),
        typedDataJson: JSON.stringify(o, null, 2),
        addPrefix: !1
      }
    });
    if (Bn(u))
      throw u;
    return u.result;
  }
  initializeRelay() {
    return this._relay || (this._relay = new xo({
      linkAPIUrl: E6,
      storage: this._storage,
      metadata: this.metadata,
      accountsCallback: this._setAddresses.bind(this),
      chainCallback: this.updateProviderInfo.bind(this)
    })), this._relay;
  }
}
const lS = "SignerType", hS = new Zs("CBWSDK", "SignerConfigurator");
function qY() {
  return hS.getItem(lS);
}
function zY(t) {
  hS.setItem(lS, t);
}
async function HY(t) {
  const { communicator: e, metadata: r, handshakeRequest: n, callback: i } = t;
  KY(e, r, i).catch(() => {
  });
  const s = {
    id: crypto.randomUUID(),
    event: "selectSignerType",
    data: Object.assign(Object.assign({}, t.preference), { handshakeRequest: n })
  }, { data: o } = await e.postRequestAndWaitForResponse(s);
  return o;
}
function WY(t) {
  const { signerType: e, metadata: r, communicator: n, callback: i } = t;
  switch (e) {
    case "scw":
      return new VG({
        metadata: r,
        callback: i,
        communicator: n
      });
    case "walletlink":
      return new fS({
        metadata: r,
        callback: i
      });
  }
}
async function KY(t, e, r) {
  await t.onMessage(({ event: i }) => i === "WalletLinkSessionRequest");
  const n = new fS({
    metadata: e,
    callback: r
  });
  t.postMessage({
    event: "WalletLinkUpdate",
    data: { session: n.getSession() }
  }), await n.handshake(), t.postMessage({
    event: "WalletLinkUpdate",
    data: { connected: !0 }
  });
}
const VY = `Coinbase Wallet SDK requires the Cross-Origin-Opener-Policy header to not be set to 'same-origin'. This is to ensure that the SDK can communicate with the Coinbase Smart Wallet app.

Please see https://www.smartwallet.dev/guides/tips/popup-tips#cross-origin-opener-policy for more information.`, GY = () => {
  let t;
  return {
    getCrossOriginOpenerPolicy: () => t === void 0 ? "undefined" : t,
    checkCrossOriginOpenerPolicy: async () => {
      if (typeof window > "u") {
        t = "non-browser-env";
        return;
      }
      try {
        const e = `${window.location.origin}${window.location.pathname}`, r = await fetch(e, {
          method: "HEAD"
        });
        if (!r.ok)
          throw new Error(`HTTP error! status: ${r.status}`);
        const n = r.headers.get("Cross-Origin-Opener-Policy");
        t = n ?? "null", t === "same-origin" && console.error(VY);
      } catch (e) {
        console.error("Error checking Cross-Origin-Opener-Policy:", e.message), t = "error";
      }
    }
  };
}, { checkCrossOriginOpenerPolicy: YY, getCrossOriginOpenerPolicy: JY } = GY(), M6 = 420, I6 = 540;
function XY(t) {
  const e = (window.innerWidth - M6) / 2 + window.screenX, r = (window.innerHeight - I6) / 2 + window.screenY;
  QY(t);
  const n = window.open(t, "Smart Wallet", `width=${M6}, height=${I6}, left=${e}, top=${r}`);
  if (n == null || n.focus(), !n)
    throw Sr.rpc.internal("Pop up window failed to open");
  return n;
}
function ZY(t) {
  t && !t.closed && t.close();
}
function QY(t) {
  const e = {
    sdkName: kE,
    sdkVersion: rh,
    origin: window.location.origin,
    coop: JY()
  };
  for (const [r, n] of Object.entries(e))
    t.searchParams.append(r, n.toString());
}
class eJ {
  constructor({ url: e = UY, metadata: r, preference: n }) {
    this.popup = null, this.listeners = /* @__PURE__ */ new Map(), this.postMessage = async (i) => {
      (await this.waitForPopupLoaded()).postMessage(i, this.url.origin);
    }, this.postRequestAndWaitForResponse = async (i) => {
      const s = this.onMessage(({ requestId: o }) => o === i.id);
      return this.postMessage(i), await s;
    }, this.onMessage = async (i) => new Promise((s, o) => {
      const a = (u) => {
        if (u.origin !== this.url.origin)
          return;
        const h = u.data;
        i(h) && (s(h), window.removeEventListener("message", a), this.listeners.delete(a));
      };
      window.addEventListener("message", a), this.listeners.set(a, { reject: o });
    }), this.disconnect = () => {
      ZY(this.popup), this.popup = null, this.listeners.forEach(({ reject: i }, s) => {
        i(Sr.provider.userRejectedRequest("Request rejected")), window.removeEventListener("message", s);
      }), this.listeners.clear();
    }, this.waitForPopupLoaded = async () => this.popup && !this.popup.closed ? (this.popup.focus(), this.popup) : (this.popup = XY(this.url), this.onMessage(({ event: i }) => i === "PopupUnload").then(this.disconnect).catch(() => {
    }), this.onMessage(({ event: i }) => i === "PopupLoaded").then((i) => {
      this.postMessage({
        requestId: i.id,
        data: {
          version: rh,
          metadata: this.metadata,
          preference: this.preference,
          location: window.location.toString()
        }
      });
    }).then(() => {
      if (!this.popup)
        throw Sr.rpc.internal();
      return this.popup;
    })), this.url = new URL(e), this.metadata = r, this.preference = n;
  }
}
function tJ(t) {
  const e = CG(rJ(t), {
    shouldIncludeStack: !0
  }), r = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
  return r.searchParams.set("version", rh), r.searchParams.set("code", e.code.toString()), r.searchParams.set("message", e.message), Object.assign(Object.assign({}, e), { docUrl: r.href });
}
function rJ(t) {
  var e;
  if (typeof t == "string")
    return {
      message: t,
      code: fn.rpc.internal
    };
  if (Bn(t)) {
    const r = t.errorMessage, n = (e = t.errorCode) !== null && e !== void 0 ? e : r.match(/(denied|rejected)/i) ? fn.provider.userRejectedRequest : void 0;
    return Object.assign(Object.assign({}, t), {
      message: r,
      code: n,
      data: { method: t.method }
    });
  }
  return t;
}
var dS = { exports: {} };
(function(t) {
  var e = Object.prototype.hasOwnProperty, r = "~";
  function n() {
  }
  Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (r = !1));
  function i(u, h, d) {
    this.fn = u, this.context = h, this.once = d || !1;
  }
  function s(u, h, d, p, x) {
    if (typeof d != "function")
      throw new TypeError("The listener must be a function");
    var A = new i(d, p || u, x), I = r ? r + h : h;
    return u._events[I] ? u._events[I].fn ? u._events[I] = [u._events[I], A] : u._events[I].push(A) : (u._events[I] = A, u._eventsCount++), u;
  }
  function o(u, h) {
    --u._eventsCount === 0 ? u._events = new n() : delete u._events[h];
  }
  function a() {
    this._events = new n(), this._eventsCount = 0;
  }
  a.prototype.eventNames = function() {
    var h = [], d, p;
    if (this._eventsCount === 0) return h;
    for (p in d = this._events)
      e.call(d, p) && h.push(r ? p.slice(1) : p);
    return Object.getOwnPropertySymbols ? h.concat(Object.getOwnPropertySymbols(d)) : h;
  }, a.prototype.listeners = function(h) {
    var d = r ? r + h : h, p = this._events[d];
    if (!p) return [];
    if (p.fn) return [p.fn];
    for (var x = 0, A = p.length, I = new Array(A); x < A; x++)
      I[x] = p[x].fn;
    return I;
  }, a.prototype.listenerCount = function(h) {
    var d = r ? r + h : h, p = this._events[d];
    return p ? p.fn ? 1 : p.length : 0;
  }, a.prototype.emit = function(h, d, p, x, A, I) {
    var N = r ? r + h : h;
    if (!this._events[N]) return !1;
    var L = this._events[N], F = arguments.length, $, W;
    if (L.fn) {
      switch (L.once && this.removeListener(h, L.fn, void 0, !0), F) {
        case 1:
          return L.fn.call(L.context), !0;
        case 2:
          return L.fn.call(L.context, d), !0;
        case 3:
          return L.fn.call(L.context, d, p), !0;
        case 4:
          return L.fn.call(L.context, d, p, x), !0;
        case 5:
          return L.fn.call(L.context, d, p, x, A), !0;
        case 6:
          return L.fn.call(L.context, d, p, x, A, I), !0;
      }
      for (W = 1, $ = new Array(F - 1); W < F; W++)
        $[W - 1] = arguments[W];
      L.fn.apply(L.context, $);
    } else {
      var z = L.length, V;
      for (W = 0; W < z; W++)
        switch (L[W].once && this.removeListener(h, L[W].fn, void 0, !0), F) {
          case 1:
            L[W].fn.call(L[W].context);
            break;
          case 2:
            L[W].fn.call(L[W].context, d);
            break;
          case 3:
            L[W].fn.call(L[W].context, d, p);
            break;
          case 4:
            L[W].fn.call(L[W].context, d, p, x);
            break;
          default:
            if (!$) for (V = 1, $ = new Array(F - 1); V < F; V++)
              $[V - 1] = arguments[V];
            L[W].fn.apply(L[W].context, $);
        }
    }
    return !0;
  }, a.prototype.on = function(h, d, p) {
    return s(this, h, d, p, !1);
  }, a.prototype.once = function(h, d, p) {
    return s(this, h, d, p, !0);
  }, a.prototype.removeListener = function(h, d, p, x) {
    var A = r ? r + h : h;
    if (!this._events[A]) return this;
    if (!d)
      return o(this, A), this;
    var I = this._events[A];
    if (I.fn)
      I.fn === d && (!x || I.once) && (!p || I.context === p) && o(this, A);
    else {
      for (var N = 0, L = [], F = I.length; N < F; N++)
        (I[N].fn !== d || x && !I[N].once || p && I[N].context !== p) && L.push(I[N]);
      L.length ? this._events[A] = L.length === 1 ? L[0] : L : o(this, A);
    }
    return this;
  }, a.prototype.removeAllListeners = function(h) {
    var d;
    return h ? (d = r ? r + h : h, this._events[d] && o(this, d)) : (this._events = new n(), this._eventsCount = 0), this;
  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, t.exports = a;
})(dS);
var nJ = dS.exports;
const iJ = /* @__PURE__ */ ts(nJ);
class sJ extends iJ {
}
var oJ = function(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
  return r;
};
class aJ extends sJ {
  constructor(e) {
    var { metadata: r } = e, n = e.preference, { keysUrl: i } = n, s = oJ(n, ["keysUrl"]);
    super(), this.signer = null, this.isCoinbaseWallet = !0, this.metadata = r, this.preference = s, this.communicator = new eJ({
      url: i,
      metadata: r,
      preference: s
    });
    const o = qY();
    o && (this.signer = this.initSigner(o));
  }
  async request(e) {
    try {
      if (KG(e), !this.signer)
        switch (e.method) {
          case "eth_requestAccounts": {
            const r = await this.requestSignerSelection(e), n = this.initSigner(r);
            await n.handshake(e), this.signer = n, zY(r);
            break;
          }
          case "net_version":
            return 1;
          case "eth_chainId":
            return la(1);
          default:
            throw Sr.provider.unauthorized("Must call 'eth_requestAccounts' before other methods");
        }
      return this.signer.request(e);
    } catch (r) {
      const { code: n } = r;
      return n === fn.provider.unauthorized && this.disconnect(), Promise.reject(tJ(r));
    }
  }
  /** @deprecated Use `.request({ method: 'eth_requestAccounts' })` instead. */
  async enable() {
    return console.warn('.enable() has been deprecated. Please use .request({ method: "eth_requestAccounts" }) instead.'), await this.request({
      method: "eth_requestAccounts"
    });
  }
  async disconnect() {
    var e;
    await ((e = this.signer) === null || e === void 0 ? void 0 : e.cleanup()), this.signer = null, Zs.clearAll(), this.emit("disconnect", Sr.provider.disconnected("User initiated disconnection"));
  }
  requestSignerSelection(e) {
    return HY({
      communicator: this.communicator,
      preference: this.preference,
      metadata: this.metadata,
      handshakeRequest: e,
      callback: this.emit.bind(this)
    });
  }
  initSigner(e) {
    return WY({
      signerType: e,
      metadata: this.metadata,
      communicator: this.communicator,
      callback: this.emit.bind(this)
    });
  }
}
function cJ(t) {
  if (t) {
    if (!["all", "smartWalletOnly", "eoaOnly"].includes(t.options))
      throw new Error(`Invalid options: ${t.options}`);
    if (t.attribution && t.attribution.auto !== void 0 && t.attribution.dataSuffix !== void 0)
      throw new Error("Attribution cannot contain both auto and dataSuffix properties");
  }
}
function uJ(t) {
  var e;
  const r = {
    metadata: t.metadata,
    preference: t.preference
  };
  return (e = WG(r)) !== null && e !== void 0 ? e : new aJ(r);
}
const fJ = {
  options: "all"
};
function lJ(t) {
  var e;
  new Zs("CBWSDK").setItem("VERSION", rh), YY();
  const n = {
    metadata: {
      appName: t.appName || "Dapp",
      appLogoUrl: t.appLogoUrl || "",
      appChainIds: t.appChainIds || []
    },
    preference: Object.assign(fJ, (e = t.preference) !== null && e !== void 0 ? e : {})
  };
  cJ(n.preference);
  let i = null;
  return {
    getProvider: () => (i || (i = uJ(n)), i)
  };
}
function pS(t, e) {
  return function() {
    return t.apply(e, arguments);
  };
}
const { toString: hJ } = Object.prototype, { getPrototypeOf: Eb } = Object, fp = /* @__PURE__ */ ((t) => (e) => {
  const r = hJ.call(e);
  return t[r] || (t[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), As = (t) => (t = t.toLowerCase(), (e) => fp(e) === t), lp = (t) => (e) => typeof e === t, { isArray: qu } = Array, Al = lp("undefined");
function dJ(t) {
  return t !== null && !Al(t) && t.constructor !== null && !Al(t.constructor) && Di(t.constructor.isBuffer) && t.constructor.isBuffer(t);
}
const gS = As("ArrayBuffer");
function pJ(t) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && gS(t.buffer), e;
}
const gJ = lp("string"), Di = lp("function"), mS = lp("number"), hp = (t) => t !== null && typeof t == "object", mJ = (t) => t === !0 || t === !1, Ld = (t) => {
  if (fp(t) !== "object")
    return !1;
  const e = Eb(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
}, vJ = As("Date"), bJ = As("File"), yJ = As("Blob"), wJ = As("FileList"), xJ = (t) => hp(t) && Di(t.pipe), _J = (t) => {
  let e;
  return t && (typeof FormData == "function" && t instanceof FormData || Di(t.append) && ((e = fp(t)) === "formdata" || // detect form-data instance
  e === "object" && Di(t.toString) && t.toString() === "[object FormData]"));
}, EJ = As("URLSearchParams"), [SJ, AJ, PJ, MJ] = ["ReadableStream", "Request", "Response", "Headers"].map(As), IJ = (t) => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function ih(t, e, { allOwnKeys: r = !1 } = {}) {
  if (t === null || typeof t > "u")
    return;
  let n, i;
  if (typeof t != "object" && (t = [t]), qu(t))
    for (n = 0, i = t.length; n < i; n++)
      e.call(null, t[n], n, t);
  else {
    const s = r ? Object.getOwnPropertyNames(t) : Object.keys(t), o = s.length;
    let a;
    for (n = 0; n < o; n++)
      a = s[n], e.call(null, t[a], a, t);
  }
}
function vS(t, e) {
  e = e.toLowerCase();
  const r = Object.keys(t);
  let n = r.length, i;
  for (; n-- > 0; )
    if (i = r[n], e === i.toLowerCase())
      return i;
  return null;
}
const ec = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, bS = (t) => !Al(t) && t !== ec;
function H1() {
  const { caseless: t } = bS(this) && this || {}, e = {}, r = (n, i) => {
    const s = t && vS(e, i) || i;
    Ld(e[s]) && Ld(n) ? e[s] = H1(e[s], n) : Ld(n) ? e[s] = H1({}, n) : qu(n) ? e[s] = n.slice() : e[s] = n;
  };
  for (let n = 0, i = arguments.length; n < i; n++)
    arguments[n] && ih(arguments[n], r);
  return e;
}
const CJ = (t, e, r, { allOwnKeys: n } = {}) => (ih(e, (i, s) => {
  r && Di(i) ? t[s] = pS(i, r) : t[s] = i;
}, { allOwnKeys: n }), t), TJ = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), RJ = (t, e, r, n) => {
  t.prototype = Object.create(e.prototype, n), t.prototype.constructor = t, Object.defineProperty(t, "super", {
    value: e.prototype
  }), r && Object.assign(t.prototype, r);
}, DJ = (t, e, r, n) => {
  let i, s, o;
  const a = {};
  if (e = e || {}, t == null) return e;
  do {
    for (i = Object.getOwnPropertyNames(t), s = i.length; s-- > 0; )
      o = i[s], (!n || n(o, t, e)) && !a[o] && (e[o] = t[o], a[o] = !0);
    t = r !== !1 && Eb(t);
  } while (t && (!r || r(t, e)) && t !== Object.prototype);
  return e;
}, OJ = (t, e, r) => {
  t = String(t), (r === void 0 || r > t.length) && (r = t.length), r -= e.length;
  const n = t.indexOf(e, r);
  return n !== -1 && n === r;
}, NJ = (t) => {
  if (!t) return null;
  if (qu(t)) return t;
  let e = t.length;
  if (!mS(e)) return null;
  const r = new Array(e);
  for (; e-- > 0; )
    r[e] = t[e];
  return r;
}, LJ = /* @__PURE__ */ ((t) => (e) => t && e instanceof t)(typeof Uint8Array < "u" && Eb(Uint8Array)), kJ = (t, e) => {
  const n = (t && t[Symbol.iterator]).call(t);
  let i;
  for (; (i = n.next()) && !i.done; ) {
    const s = i.value;
    e.call(t, s[0], s[1]);
  }
}, $J = (t, e) => {
  let r;
  const n = [];
  for (; (r = t.exec(e)) !== null; )
    n.push(r);
  return n;
}, BJ = As("HTMLFormElement"), FJ = (t) => t.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, n, i) {
    return n.toUpperCase() + i;
  }
), C6 = (({ hasOwnProperty: t }) => (e, r) => t.call(e, r))(Object.prototype), UJ = As("RegExp"), yS = (t, e) => {
  const r = Object.getOwnPropertyDescriptors(t), n = {};
  ih(r, (i, s) => {
    let o;
    (o = e(i, s, t)) !== !1 && (n[s] = o || i);
  }), Object.defineProperties(t, n);
}, jJ = (t) => {
  yS(t, (e, r) => {
    if (Di(t) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const n = t[r];
    if (Di(n)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
}, qJ = (t, e) => {
  const r = {}, n = (i) => {
    i.forEach((s) => {
      r[s] = !0;
    });
  };
  return qu(t) ? n(t) : n(String(t).split(e)), r;
}, zJ = () => {
}, HJ = (t, e) => t != null && Number.isFinite(t = +t) ? t : e, Im = "abcdefghijklmnopqrstuvwxyz", T6 = "0123456789", wS = {
  DIGIT: T6,
  ALPHA: Im,
  ALPHA_DIGIT: Im + Im.toUpperCase() + T6
}, WJ = (t = 16, e = wS.ALPHA_DIGIT) => {
  let r = "";
  const { length: n } = e;
  for (; t--; )
    r += e[Math.random() * n | 0];
  return r;
};
function KJ(t) {
  return !!(t && Di(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator]);
}
const VJ = (t) => {
  const e = new Array(10), r = (n, i) => {
    if (hp(n)) {
      if (e.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        e[i] = n;
        const s = qu(n) ? [] : {};
        return ih(n, (o, a) => {
          const u = r(o, i + 1);
          !Al(u) && (s[a] = u);
        }), e[i] = void 0, s;
      }
    }
    return n;
  };
  return r(t, 0);
}, GJ = As("AsyncFunction"), YJ = (t) => t && (hp(t) || Di(t)) && Di(t.then) && Di(t.catch), xS = ((t, e) => t ? setImmediate : e ? ((r, n) => (ec.addEventListener("message", ({ source: i, data: s }) => {
  i === ec && s === r && n.length && n.shift()();
}, !1), (i) => {
  n.push(i), ec.postMessage(r, "*");
}))(`axios@${Math.random()}`, []) : (r) => setTimeout(r))(
  typeof setImmediate == "function",
  Di(ec.postMessage)
), JJ = typeof queueMicrotask < "u" ? queueMicrotask.bind(ec) : typeof process < "u" && process.nextTick || xS, Oe = {
  isArray: qu,
  isArrayBuffer: gS,
  isBuffer: dJ,
  isFormData: _J,
  isArrayBufferView: pJ,
  isString: gJ,
  isNumber: mS,
  isBoolean: mJ,
  isObject: hp,
  isPlainObject: Ld,
  isReadableStream: SJ,
  isRequest: AJ,
  isResponse: PJ,
  isHeaders: MJ,
  isUndefined: Al,
  isDate: vJ,
  isFile: bJ,
  isBlob: yJ,
  isRegExp: UJ,
  isFunction: Di,
  isStream: xJ,
  isURLSearchParams: EJ,
  isTypedArray: LJ,
  isFileList: wJ,
  forEach: ih,
  merge: H1,
  extend: CJ,
  trim: IJ,
  stripBOM: TJ,
  inherits: RJ,
  toFlatObject: DJ,
  kindOf: fp,
  kindOfTest: As,
  endsWith: OJ,
  toArray: NJ,
  forEachEntry: kJ,
  matchAll: $J,
  isHTMLForm: BJ,
  hasOwnProperty: C6,
  hasOwnProp: C6,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: yS,
  freezeMethods: jJ,
  toObjectSet: qJ,
  toCamelCase: FJ,
  noop: zJ,
  toFiniteNumber: HJ,
  findKey: vS,
  global: ec,
  isContextDefined: bS,
  ALPHABET: wS,
  generateString: WJ,
  isSpecCompliantForm: KJ,
  toJSONObject: VJ,
  isAsyncFn: GJ,
  isThenable: YJ,
  setImmediate: xS,
  asap: JJ
};
function sr(t, e, r, n, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), r && (this.config = r), n && (this.request = n), i && (this.response = i, this.status = i.status ? i.status : null);
}
Oe.inherits(sr, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Oe.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const _S = sr.prototype, ES = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((t) => {
  ES[t] = { value: t };
});
Object.defineProperties(sr, ES);
Object.defineProperty(_S, "isAxiosError", { value: !0 });
sr.from = (t, e, r, n, i, s) => {
  const o = Object.create(_S);
  return Oe.toFlatObject(t, o, function(u) {
    return u !== Error.prototype;
  }, (a) => a !== "isAxiosError"), sr.call(o, t.message, e, r, n, i), o.cause = t, o.name = t.name, s && Object.assign(o, s), o;
};
const XJ = null;
function W1(t) {
  return Oe.isPlainObject(t) || Oe.isArray(t);
}
function SS(t) {
  return Oe.endsWith(t, "[]") ? t.slice(0, -2) : t;
}
function R6(t, e, r) {
  return t ? t.concat(e).map(function(i, s) {
    return i = SS(i), !r && s ? "[" + i + "]" : i;
  }).join(r ? "." : "") : e;
}
function ZJ(t) {
  return Oe.isArray(t) && !t.some(W1);
}
const QJ = Oe.toFlatObject(Oe, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function dp(t, e, r) {
  if (!Oe.isObject(t))
    throw new TypeError("target must be an object");
  e = e || new FormData(), r = Oe.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(N, L) {
    return !Oe.isUndefined(L[N]);
  });
  const n = r.metaTokens, i = r.visitor || d, s = r.dots, o = r.indexes, u = (r.Blob || typeof Blob < "u" && Blob) && Oe.isSpecCompliantForm(e);
  if (!Oe.isFunction(i))
    throw new TypeError("visitor must be a function");
  function h(I) {
    if (I === null) return "";
    if (Oe.isDate(I))
      return I.toISOString();
    if (!u && Oe.isBlob(I))
      throw new sr("Blob is not supported. Use a Buffer instead.");
    return Oe.isArrayBuffer(I) || Oe.isTypedArray(I) ? u && typeof Blob == "function" ? new Blob([I]) : Buffer.from(I) : I;
  }
  function d(I, N, L) {
    let F = I;
    if (I && !L && typeof I == "object") {
      if (Oe.endsWith(N, "{}"))
        N = n ? N : N.slice(0, -2), I = JSON.stringify(I);
      else if (Oe.isArray(I) && ZJ(I) || (Oe.isFileList(I) || Oe.endsWith(N, "[]")) && (F = Oe.toArray(I)))
        return N = SS(N), F.forEach(function(W, z) {
          !(Oe.isUndefined(W) || W === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? R6([N], z, s) : o === null ? N : N + "[]",
            h(W)
          );
        }), !1;
    }
    return W1(I) ? !0 : (e.append(R6(L, N, s), h(I)), !1);
  }
  const p = [], x = Object.assign(QJ, {
    defaultVisitor: d,
    convertValue: h,
    isVisitable: W1
  });
  function A(I, N) {
    if (!Oe.isUndefined(I)) {
      if (p.indexOf(I) !== -1)
        throw Error("Circular reference detected in " + N.join("."));
      p.push(I), Oe.forEach(I, function(F, $) {
        (!(Oe.isUndefined(F) || F === null) && i.call(
          e,
          F,
          Oe.isString($) ? $.trim() : $,
          N,
          x
        )) === !0 && A(F, N ? N.concat($) : [$]);
      }), p.pop();
    }
  }
  if (!Oe.isObject(t))
    throw new TypeError("data must be an object");
  return A(t), e;
}
function D6(t) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(n) {
    return e[n];
  });
}
function Sb(t, e) {
  this._pairs = [], t && dp(t, this, e);
}
const AS = Sb.prototype;
AS.append = function(e, r) {
  this._pairs.push([e, r]);
};
AS.toString = function(e) {
  const r = e ? function(n) {
    return e.call(this, n, D6);
  } : D6;
  return this._pairs.map(function(i) {
    return r(i[0]) + "=" + r(i[1]);
  }, "").join("&");
};
function eX(t) {
  return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function PS(t, e, r) {
  if (!e)
    return t;
  const n = r && r.encode || eX;
  Oe.isFunction(r) && (r = {
    serialize: r
  });
  const i = r && r.serialize;
  let s;
  if (i ? s = i(e, r) : s = Oe.isURLSearchParams(e) ? e.toString() : new Sb(e, r).toString(n), s) {
    const o = t.indexOf("#");
    o !== -1 && (t = t.slice(0, o)), t += (t.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return t;
}
class O6 {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, r, n) {
    return this.handlers.push({
      fulfilled: e,
      rejected: r,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    Oe.forEach(this.handlers, function(n) {
      n !== null && e(n);
    });
  }
}
const MS = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, tX = typeof URLSearchParams < "u" ? URLSearchParams : Sb, rX = typeof FormData < "u" ? FormData : null, nX = typeof Blob < "u" ? Blob : null, iX = {
  isBrowser: !0,
  classes: {
    URLSearchParams: tX,
    FormData: rX,
    Blob: nX
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Ab = typeof window < "u" && typeof document < "u", K1 = typeof navigator == "object" && navigator || void 0, sX = Ab && (!K1 || ["ReactNative", "NativeScript", "NS"].indexOf(K1.product) < 0), oX = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", aX = Ab && window.location.href || "http://localhost", cX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Ab,
  hasStandardBrowserEnv: sX,
  hasStandardBrowserWebWorkerEnv: oX,
  navigator: K1,
  origin: aX
}, Symbol.toStringTag, { value: "Module" })), Yn = {
  ...cX,
  ...iX
};
function uX(t, e) {
  return dp(t, new Yn.classes.URLSearchParams(), Object.assign({
    visitor: function(r, n, i, s) {
      return Yn.isNode && Oe.isBuffer(r) ? (this.append(n, r.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function fX(t) {
  return Oe.matchAll(/\w+|\[(\w*)]/g, t).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function lX(t) {
  const e = {}, r = Object.keys(t);
  let n;
  const i = r.length;
  let s;
  for (n = 0; n < i; n++)
    s = r[n], e[s] = t[s];
  return e;
}
function IS(t) {
  function e(r, n, i, s) {
    let o = r[s++];
    if (o === "__proto__") return !0;
    const a = Number.isFinite(+o), u = s >= r.length;
    return o = !o && Oe.isArray(i) ? i.length : o, u ? (Oe.hasOwnProp(i, o) ? i[o] = [i[o], n] : i[o] = n, !a) : ((!i[o] || !Oe.isObject(i[o])) && (i[o] = []), e(r, n, i[o], s) && Oe.isArray(i[o]) && (i[o] = lX(i[o])), !a);
  }
  if (Oe.isFormData(t) && Oe.isFunction(t.entries)) {
    const r = {};
    return Oe.forEachEntry(t, (n, i) => {
      e(fX(n), i, r, 0);
    }), r;
  }
  return null;
}
function hX(t, e, r) {
  if (Oe.isString(t))
    try {
      return (e || JSON.parse)(t), Oe.trim(t);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (r || JSON.stringify)(t);
}
const sh = {
  transitional: MS,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, r) {
    const n = r.getContentType() || "", i = n.indexOf("application/json") > -1, s = Oe.isObject(e);
    if (s && Oe.isHTMLForm(e) && (e = new FormData(e)), Oe.isFormData(e))
      return i ? JSON.stringify(IS(e)) : e;
    if (Oe.isArrayBuffer(e) || Oe.isBuffer(e) || Oe.isStream(e) || Oe.isFile(e) || Oe.isBlob(e) || Oe.isReadableStream(e))
      return e;
    if (Oe.isArrayBufferView(e))
      return e.buffer;
    if (Oe.isURLSearchParams(e))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let a;
    if (s) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return uX(e, this.formSerializer).toString();
      if ((a = Oe.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
        const u = this.env && this.env.FormData;
        return dp(
          a ? { "files[]": e } : e,
          u && new u(),
          this.formSerializer
        );
      }
    }
    return s || i ? (r.setContentType("application/json", !1), hX(e)) : e;
  }],
  transformResponse: [function(e) {
    const r = this.transitional || sh.transitional, n = r && r.forcedJSONParsing, i = this.responseType === "json";
    if (Oe.isResponse(e) || Oe.isReadableStream(e))
      return e;
    if (e && Oe.isString(e) && (n && !this.responseType || i)) {
      const o = !(r && r.silentJSONParsing) && i;
      try {
        return JSON.parse(e);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? sr.from(a, sr.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Yn.classes.FormData,
    Blob: Yn.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
Oe.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
  sh.headers[t] = {};
});
const dX = Oe.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), pX = (t) => {
  const e = {};
  let r, n, i;
  return t && t.split(`
`).forEach(function(o) {
    i = o.indexOf(":"), r = o.substring(0, i).trim().toLowerCase(), n = o.substring(i + 1).trim(), !(!r || e[r] && dX[r]) && (r === "set-cookie" ? e[r] ? e[r].push(n) : e[r] = [n] : e[r] = e[r] ? e[r] + ", " + n : n);
  }), e;
}, N6 = Symbol("internals");
function Tf(t) {
  return t && String(t).trim().toLowerCase();
}
function kd(t) {
  return t === !1 || t == null ? t : Oe.isArray(t) ? t.map(kd) : String(t);
}
function gX(t) {
  const e = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = r.exec(t); )
    e[n[1]] = n[2];
  return e;
}
const mX = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
function Cm(t, e, r, n, i) {
  if (Oe.isFunction(n))
    return n.call(this, e, r);
  if (i && (e = r), !!Oe.isString(e)) {
    if (Oe.isString(n))
      return e.indexOf(n) !== -1;
    if (Oe.isRegExp(n))
      return n.test(e);
  }
}
function vX(t) {
  return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, r, n) => r.toUpperCase() + n);
}
function bX(t, e) {
  const r = Oe.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(t, n + r, {
      value: function(i, s, o) {
        return this[n].call(this, e, i, s, o);
      },
      configurable: !0
    });
  });
}
let yi = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, r, n) {
    const i = this;
    function s(a, u, h) {
      const d = Tf(u);
      if (!d)
        throw new Error("header name must be a non-empty string");
      const p = Oe.findKey(i, d);
      (!p || i[p] === void 0 || h === !0 || h === void 0 && i[p] !== !1) && (i[p || u] = kd(a));
    }
    const o = (a, u) => Oe.forEach(a, (h, d) => s(h, d, u));
    if (Oe.isPlainObject(e) || e instanceof this.constructor)
      o(e, r);
    else if (Oe.isString(e) && (e = e.trim()) && !mX(e))
      o(pX(e), r);
    else if (Oe.isHeaders(e))
      for (const [a, u] of e.entries())
        s(u, a, n);
    else
      e != null && s(r, e, n);
    return this;
  }
  get(e, r) {
    if (e = Tf(e), e) {
      const n = Oe.findKey(this, e);
      if (n) {
        const i = this[n];
        if (!r)
          return i;
        if (r === !0)
          return gX(i);
        if (Oe.isFunction(r))
          return r.call(this, i, n);
        if (Oe.isRegExp(r))
          return r.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, r) {
    if (e = Tf(e), e) {
      const n = Oe.findKey(this, e);
      return !!(n && this[n] !== void 0 && (!r || Cm(this, this[n], n, r)));
    }
    return !1;
  }
  delete(e, r) {
    const n = this;
    let i = !1;
    function s(o) {
      if (o = Tf(o), o) {
        const a = Oe.findKey(n, o);
        a && (!r || Cm(n, n[a], a, r)) && (delete n[a], i = !0);
      }
    }
    return Oe.isArray(e) ? e.forEach(s) : s(e), i;
  }
  clear(e) {
    const r = Object.keys(this);
    let n = r.length, i = !1;
    for (; n--; ) {
      const s = r[n];
      (!e || Cm(this, this[s], s, e, !0)) && (delete this[s], i = !0);
    }
    return i;
  }
  normalize(e) {
    const r = this, n = {};
    return Oe.forEach(this, (i, s) => {
      const o = Oe.findKey(n, s);
      if (o) {
        r[o] = kd(i), delete r[s];
        return;
      }
      const a = e ? vX(s) : String(s).trim();
      a !== s && delete r[s], r[a] = kd(i), n[a] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const r = /* @__PURE__ */ Object.create(null);
    return Oe.forEach(this, (n, i) => {
      n != null && n !== !1 && (r[i] = e && Oe.isArray(n) ? n.join(", ") : n);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, r]) => e + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...r) {
    const n = new this(e);
    return r.forEach((i) => n.set(i)), n;
  }
  static accessor(e) {
    const n = (this[N6] = this[N6] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function s(o) {
      const a = Tf(o);
      n[a] || (bX(i, o), n[a] = !0);
    }
    return Oe.isArray(e) ? e.forEach(s) : s(e), this;
  }
};
yi.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Oe.reduceDescriptors(yi.prototype, ({ value: t }, e) => {
  let r = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => t,
    set(n) {
      this[r] = n;
    }
  };
});
Oe.freezeMethods(yi);
function Tm(t, e) {
  const r = this || sh, n = e || r, i = yi.from(n.headers);
  let s = n.data;
  return Oe.forEach(t, function(a) {
    s = a.call(r, s, i.normalize(), e ? e.status : void 0);
  }), i.normalize(), s;
}
function CS(t) {
  return !!(t && t.__CANCEL__);
}
function zu(t, e, r) {
  sr.call(this, t ?? "canceled", sr.ERR_CANCELED, e, r), this.name = "CanceledError";
}
Oe.inherits(zu, sr, {
  __CANCEL__: !0
});
function TS(t, e, r) {
  const n = r.config.validateStatus;
  !r.status || !n || n(r.status) ? t(r) : e(new sr(
    "Request failed with status code " + r.status,
    [sr.ERR_BAD_REQUEST, sr.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
function yX(t) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
  return e && e[1] || "";
}
function wX(t, e) {
  t = t || 10;
  const r = new Array(t), n = new Array(t);
  let i = 0, s = 0, o;
  return e = e !== void 0 ? e : 1e3, function(u) {
    const h = Date.now(), d = n[s];
    o || (o = h), r[i] = u, n[i] = h;
    let p = s, x = 0;
    for (; p !== i; )
      x += r[p++], p = p % t;
    if (i = (i + 1) % t, i === s && (s = (s + 1) % t), h - o < e)
      return;
    const A = d && h - d;
    return A ? Math.round(x * 1e3 / A) : void 0;
  };
}
function xX(t, e) {
  let r = 0, n = 1e3 / e, i, s;
  const o = (h, d = Date.now()) => {
    r = d, i = null, s && (clearTimeout(s), s = null), t.apply(null, h);
  };
  return [(...h) => {
    const d = Date.now(), p = d - r;
    p >= n ? o(h, d) : (i = h, s || (s = setTimeout(() => {
      s = null, o(i);
    }, n - p)));
  }, () => i && o(i)];
}
const p0 = (t, e, r = 3) => {
  let n = 0;
  const i = wX(50, 250);
  return xX((s) => {
    const o = s.loaded, a = s.lengthComputable ? s.total : void 0, u = o - n, h = i(u), d = o <= a;
    n = o;
    const p = {
      loaded: o,
      total: a,
      progress: a ? o / a : void 0,
      bytes: u,
      rate: h || void 0,
      estimated: h && a && d ? (a - o) / h : void 0,
      event: s,
      lengthComputable: a != null,
      [e ? "download" : "upload"]: !0
    };
    t(p);
  }, r);
}, L6 = (t, e) => {
  const r = t != null;
  return [(n) => e[0]({
    lengthComputable: r,
    total: t,
    loaded: n
  }), e[1]];
}, k6 = (t) => (...e) => Oe.asap(() => t(...e)), _X = Yn.hasStandardBrowserEnv ? /* @__PURE__ */ ((t, e) => (r) => (r = new URL(r, Yn.origin), t.protocol === r.protocol && t.host === r.host && (e || t.port === r.port)))(
  new URL(Yn.origin),
  Yn.navigator && /(msie|trident)/i.test(Yn.navigator.userAgent)
) : () => !0, EX = Yn.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(t, e, r, n, i, s) {
      const o = [t + "=" + encodeURIComponent(e)];
      Oe.isNumber(r) && o.push("expires=" + new Date(r).toGMTString()), Oe.isString(n) && o.push("path=" + n), Oe.isString(i) && o.push("domain=" + i), s === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(t) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(t) {
      this.write(t, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function SX(t) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
}
function AX(t, e) {
  return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t;
}
function RS(t, e) {
  return t && !SX(e) ? AX(t, e) : e;
}
const $6 = (t) => t instanceof yi ? { ...t } : t;
function lc(t, e) {
  e = e || {};
  const r = {};
  function n(h, d, p, x) {
    return Oe.isPlainObject(h) && Oe.isPlainObject(d) ? Oe.merge.call({ caseless: x }, h, d) : Oe.isPlainObject(d) ? Oe.merge({}, d) : Oe.isArray(d) ? d.slice() : d;
  }
  function i(h, d, p, x) {
    if (Oe.isUndefined(d)) {
      if (!Oe.isUndefined(h))
        return n(void 0, h, p, x);
    } else return n(h, d, p, x);
  }
  function s(h, d) {
    if (!Oe.isUndefined(d))
      return n(void 0, d);
  }
  function o(h, d) {
    if (Oe.isUndefined(d)) {
      if (!Oe.isUndefined(h))
        return n(void 0, h);
    } else return n(void 0, d);
  }
  function a(h, d, p) {
    if (p in e)
      return n(h, d);
    if (p in t)
      return n(void 0, h);
  }
  const u = {
    url: s,
    method: s,
    data: s,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (h, d, p) => i($6(h), $6(d), p, !0)
  };
  return Oe.forEach(Object.keys(Object.assign({}, t, e)), function(d) {
    const p = u[d] || i, x = p(t[d], e[d], d);
    Oe.isUndefined(x) && p !== a || (r[d] = x);
  }), r;
}
const DS = (t) => {
  const e = lc({}, t);
  let { data: r, withXSRFToken: n, xsrfHeaderName: i, xsrfCookieName: s, headers: o, auth: a } = e;
  e.headers = o = yi.from(o), e.url = PS(RS(e.baseURL, e.url), t.params, t.paramsSerializer), a && o.set(
    "Authorization",
    "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
  );
  let u;
  if (Oe.isFormData(r)) {
    if (Yn.hasStandardBrowserEnv || Yn.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if ((u = o.getContentType()) !== !1) {
      const [h, ...d] = u ? u.split(";").map((p) => p.trim()).filter(Boolean) : [];
      o.setContentType([h || "multipart/form-data", ...d].join("; "));
    }
  }
  if (Yn.hasStandardBrowserEnv && (n && Oe.isFunction(n) && (n = n(e)), n || n !== !1 && _X(e.url))) {
    const h = i && s && EX.read(s);
    h && o.set(i, h);
  }
  return e;
}, PX = typeof XMLHttpRequest < "u", MX = PX && function(t) {
  return new Promise(function(r, n) {
    const i = DS(t);
    let s = i.data;
    const o = yi.from(i.headers).normalize();
    let { responseType: a, onUploadProgress: u, onDownloadProgress: h } = i, d, p, x, A, I;
    function N() {
      A && A(), I && I(), i.cancelToken && i.cancelToken.unsubscribe(d), i.signal && i.signal.removeEventListener("abort", d);
    }
    let L = new XMLHttpRequest();
    L.open(i.method.toUpperCase(), i.url, !0), L.timeout = i.timeout;
    function F() {
      if (!L)
        return;
      const W = yi.from(
        "getAllResponseHeaders" in L && L.getAllResponseHeaders()
      ), V = {
        data: !a || a === "text" || a === "json" ? L.responseText : L.response,
        status: L.status,
        statusText: L.statusText,
        headers: W,
        config: t,
        request: L
      };
      TS(function(R) {
        r(R), N();
      }, function(R) {
        n(R), N();
      }, V), L = null;
    }
    "onloadend" in L ? L.onloadend = F : L.onreadystatechange = function() {
      !L || L.readyState !== 4 || L.status === 0 && !(L.responseURL && L.responseURL.indexOf("file:") === 0) || setTimeout(F);
    }, L.onabort = function() {
      L && (n(new sr("Request aborted", sr.ECONNABORTED, t, L)), L = null);
    }, L.onerror = function() {
      n(new sr("Network Error", sr.ERR_NETWORK, t, L)), L = null;
    }, L.ontimeout = function() {
      let z = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const V = i.transitional || MS;
      i.timeoutErrorMessage && (z = i.timeoutErrorMessage), n(new sr(
        z,
        V.clarifyTimeoutError ? sr.ETIMEDOUT : sr.ECONNABORTED,
        t,
        L
      )), L = null;
    }, s === void 0 && o.setContentType(null), "setRequestHeader" in L && Oe.forEach(o.toJSON(), function(z, V) {
      L.setRequestHeader(V, z);
    }), Oe.isUndefined(i.withCredentials) || (L.withCredentials = !!i.withCredentials), a && a !== "json" && (L.responseType = i.responseType), h && ([x, I] = p0(h, !0), L.addEventListener("progress", x)), u && L.upload && ([p, A] = p0(u), L.upload.addEventListener("progress", p), L.upload.addEventListener("loadend", A)), (i.cancelToken || i.signal) && (d = (W) => {
      L && (n(!W || W.type ? new zu(null, t, L) : W), L.abort(), L = null);
    }, i.cancelToken && i.cancelToken.subscribe(d), i.signal && (i.signal.aborted ? d() : i.signal.addEventListener("abort", d)));
    const $ = yX(i.url);
    if ($ && Yn.protocols.indexOf($) === -1) {
      n(new sr("Unsupported protocol " + $ + ":", sr.ERR_BAD_REQUEST, t));
      return;
    }
    L.send(s || null);
  });
}, IX = (t, e) => {
  const { length: r } = t = t ? t.filter(Boolean) : [];
  if (e || r) {
    let n = new AbortController(), i;
    const s = function(h) {
      if (!i) {
        i = !0, a();
        const d = h instanceof Error ? h : this.reason;
        n.abort(d instanceof sr ? d : new zu(d instanceof Error ? d.message : d));
      }
    };
    let o = e && setTimeout(() => {
      o = null, s(new sr(`timeout ${e} of ms exceeded`, sr.ETIMEDOUT));
    }, e);
    const a = () => {
      t && (o && clearTimeout(o), o = null, t.forEach((h) => {
        h.unsubscribe ? h.unsubscribe(s) : h.removeEventListener("abort", s);
      }), t = null);
    };
    t.forEach((h) => h.addEventListener("abort", s));
    const { signal: u } = n;
    return u.unsubscribe = () => Oe.asap(a), u;
  }
}, CX = function* (t, e) {
  let r = t.byteLength;
  if (r < e) {
    yield t;
    return;
  }
  let n = 0, i;
  for (; n < r; )
    i = n + e, yield t.slice(n, i), n = i;
}, TX = async function* (t, e) {
  for await (const r of RX(t))
    yield* CX(r, e);
}, RX = async function* (t) {
  if (t[Symbol.asyncIterator]) {
    yield* t;
    return;
  }
  const e = t.getReader();
  try {
    for (; ; ) {
      const { done: r, value: n } = await e.read();
      if (r)
        break;
      yield n;
    }
  } finally {
    await e.cancel();
  }
}, B6 = (t, e, r, n) => {
  const i = TX(t, e);
  let s = 0, o, a = (u) => {
    o || (o = !0, n && n(u));
  };
  return new ReadableStream({
    async pull(u) {
      try {
        const { done: h, value: d } = await i.next();
        if (h) {
          a(), u.close();
          return;
        }
        let p = d.byteLength;
        if (r) {
          let x = s += p;
          r(x);
        }
        u.enqueue(new Uint8Array(d));
      } catch (h) {
        throw a(h), h;
      }
    },
    cancel(u) {
      return a(u), i.return();
    }
  }, {
    highWaterMark: 2
  });
}, pp = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", OS = pp && typeof ReadableStream == "function", DX = pp && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((t) => (e) => t.encode(e))(new TextEncoder()) : async (t) => new Uint8Array(await new Response(t).arrayBuffer())), NS = (t, ...e) => {
  try {
    return !!t(...e);
  } catch {
    return !1;
  }
}, OX = OS && NS(() => {
  let t = !1;
  const e = new Request(Yn.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return t = !0, "half";
    }
  }).headers.has("Content-Type");
  return t && !e;
}), F6 = 64 * 1024, V1 = OS && NS(() => Oe.isReadableStream(new Response("").body)), g0 = {
  stream: V1 && ((t) => t.body)
};
pp && ((t) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !g0[e] && (g0[e] = Oe.isFunction(t[e]) ? (r) => r[e]() : (r, n) => {
      throw new sr(`Response type '${e}' is not supported`, sr.ERR_NOT_SUPPORT, n);
    });
  });
})(new Response());
const NX = async (t) => {
  if (t == null)
    return 0;
  if (Oe.isBlob(t))
    return t.size;
  if (Oe.isSpecCompliantForm(t))
    return (await new Request(Yn.origin, {
      method: "POST",
      body: t
    }).arrayBuffer()).byteLength;
  if (Oe.isArrayBufferView(t) || Oe.isArrayBuffer(t))
    return t.byteLength;
  if (Oe.isURLSearchParams(t) && (t = t + ""), Oe.isString(t))
    return (await DX(t)).byteLength;
}, LX = async (t, e) => {
  const r = Oe.toFiniteNumber(t.getContentLength());
  return r ?? NX(e);
}, kX = pp && (async (t) => {
  let {
    url: e,
    method: r,
    data: n,
    signal: i,
    cancelToken: s,
    timeout: o,
    onDownloadProgress: a,
    onUploadProgress: u,
    responseType: h,
    headers: d,
    withCredentials: p = "same-origin",
    fetchOptions: x
  } = DS(t);
  h = h ? (h + "").toLowerCase() : "text";
  let A = IX([i, s && s.toAbortSignal()], o), I;
  const N = A && A.unsubscribe && (() => {
    A.unsubscribe();
  });
  let L;
  try {
    if (u && OX && r !== "get" && r !== "head" && (L = await LX(d, n)) !== 0) {
      let V = new Request(e, {
        method: "POST",
        body: n,
        duplex: "half"
      }), te;
      if (Oe.isFormData(n) && (te = V.headers.get("content-type")) && d.setContentType(te), V.body) {
        const [R, K] = L6(
          L,
          p0(k6(u))
        );
        n = B6(V.body, F6, R, K);
      }
    }
    Oe.isString(p) || (p = p ? "include" : "omit");
    const F = "credentials" in Request.prototype;
    I = new Request(e, {
      ...x,
      signal: A,
      method: r.toUpperCase(),
      headers: d.normalize().toJSON(),
      body: n,
      duplex: "half",
      credentials: F ? p : void 0
    });
    let $ = await fetch(I);
    const W = V1 && (h === "stream" || h === "response");
    if (V1 && (a || W && N)) {
      const V = {};
      ["status", "statusText", "headers"].forEach((pe) => {
        V[pe] = $[pe];
      });
      const te = Oe.toFiniteNumber($.headers.get("content-length")), [R, K] = a && L6(
        te,
        p0(k6(a), !0)
      ) || [];
      $ = new Response(
        B6($.body, F6, R, () => {
          K && K(), N && N();
        }),
        V
      );
    }
    h = h || "text";
    let z = await g0[Oe.findKey(g0, h) || "text"]($, t);
    return !W && N && N(), await new Promise((V, te) => {
      TS(V, te, {
        data: z,
        headers: yi.from($.headers),
        status: $.status,
        statusText: $.statusText,
        config: t,
        request: I
      });
    });
  } catch (F) {
    throw N && N(), F && F.name === "TypeError" && /fetch/i.test(F.message) ? Object.assign(
      new sr("Network Error", sr.ERR_NETWORK, t, I),
      {
        cause: F.cause || F
      }
    ) : sr.from(F, F && F.code, t, I);
  }
}), G1 = {
  http: XJ,
  xhr: MX,
  fetch: kX
};
Oe.forEach(G1, (t, e) => {
  if (t) {
    try {
      Object.defineProperty(t, "name", { value: e });
    } catch {
    }
    Object.defineProperty(t, "adapterName", { value: e });
  }
});
const U6 = (t) => `- ${t}`, $X = (t) => Oe.isFunction(t) || t === null || t === !1, LS = {
  getAdapter: (t) => {
    t = Oe.isArray(t) ? t : [t];
    const { length: e } = t;
    let r, n;
    const i = {};
    for (let s = 0; s < e; s++) {
      r = t[s];
      let o;
      if (n = r, !$X(r) && (n = G1[(o = String(r)).toLowerCase()], n === void 0))
        throw new sr(`Unknown adapter '${o}'`);
      if (n)
        break;
      i[o || "#" + s] = n;
    }
    if (!n) {
      const s = Object.entries(i).map(
        ([a, u]) => `adapter ${a} ` + (u === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = e ? s.length > 1 ? `since :
` + s.map(U6).join(`
`) : " " + U6(s[0]) : "as no adapter specified";
      throw new sr(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return n;
  },
  adapters: G1
};
function Rm(t) {
  if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)
    throw new zu(null, t);
}
function j6(t) {
  return Rm(t), t.headers = yi.from(t.headers), t.data = Tm.call(
    t,
    t.transformRequest
  ), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), LS.getAdapter(t.adapter || sh.adapter)(t).then(function(n) {
    return Rm(t), n.data = Tm.call(
      t,
      t.transformResponse,
      n
    ), n.headers = yi.from(n.headers), n;
  }, function(n) {
    return CS(n) || (Rm(t), n && n.response && (n.response.data = Tm.call(
      t,
      t.transformResponse,
      n.response
    ), n.response.headers = yi.from(n.response.headers))), Promise.reject(n);
  });
}
const kS = "1.7.8", gp = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
  gp[t] = function(n) {
    return typeof n === t || "a" + (e < 1 ? "n " : " ") + t;
  };
});
const q6 = {};
gp.transitional = function(e, r, n) {
  function i(s, o) {
    return "[Axios v" + kS + "] Transitional option '" + s + "'" + o + (n ? ". " + n : "");
  }
  return (s, o, a) => {
    if (e === !1)
      throw new sr(
        i(o, " has been removed" + (r ? " in " + r : "")),
        sr.ERR_DEPRECATED
      );
    return r && !q6[o] && (q6[o] = !0, console.warn(
      i(
        o,
        " has been deprecated since v" + r + " and will be removed in the near future"
      )
    )), e ? e(s, o, a) : !0;
  };
};
gp.spelling = function(e) {
  return (r, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0);
};
function BX(t, e, r) {
  if (typeof t != "object")
    throw new sr("options must be an object", sr.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(t);
  let i = n.length;
  for (; i-- > 0; ) {
    const s = n[i], o = e[s];
    if (o) {
      const a = t[s], u = a === void 0 || o(a, s, t);
      if (u !== !0)
        throw new sr("option " + s + " must be " + u, sr.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new sr("Unknown option " + s, sr.ERR_BAD_OPTION);
  }
}
const $d = {
  assertOptions: BX,
  validators: gp
}, ks = $d.validators;
let nc = class {
  constructor(e) {
    this.defaults = e, this.interceptors = {
      request: new O6(),
      response: new O6()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, r) {
    try {
      return await this._request(e, r);
    } catch (n) {
      if (n instanceof Error) {
        let i = {};
        Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error();
        const s = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? s && !String(n.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + s) : n.stack = s;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(e, r) {
    typeof e == "string" ? (r = r || {}, r.url = e) : r = e || {}, r = lc(this.defaults, r);
    const { transitional: n, paramsSerializer: i, headers: s } = r;
    n !== void 0 && $d.assertOptions(n, {
      silentJSONParsing: ks.transitional(ks.boolean),
      forcedJSONParsing: ks.transitional(ks.boolean),
      clarifyTimeoutError: ks.transitional(ks.boolean)
    }, !1), i != null && (Oe.isFunction(i) ? r.paramsSerializer = {
      serialize: i
    } : $d.assertOptions(i, {
      encode: ks.function,
      serialize: ks.function
    }, !0)), $d.assertOptions(r, {
      baseUrl: ks.spelling("baseURL"),
      withXsrfToken: ks.spelling("withXSRFToken")
    }, !0), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let o = s && Oe.merge(
      s.common,
      s[r.method]
    );
    s && Oe.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (I) => {
        delete s[I];
      }
    ), r.headers = yi.concat(o, s);
    const a = [];
    let u = !0;
    this.interceptors.request.forEach(function(N) {
      typeof N.runWhen == "function" && N.runWhen(r) === !1 || (u = u && N.synchronous, a.unshift(N.fulfilled, N.rejected));
    });
    const h = [];
    this.interceptors.response.forEach(function(N) {
      h.push(N.fulfilled, N.rejected);
    });
    let d, p = 0, x;
    if (!u) {
      const I = [j6.bind(this), void 0];
      for (I.unshift.apply(I, a), I.push.apply(I, h), x = I.length, d = Promise.resolve(r); p < x; )
        d = d.then(I[p++], I[p++]);
      return d;
    }
    x = a.length;
    let A = r;
    for (p = 0; p < x; ) {
      const I = a[p++], N = a[p++];
      try {
        A = I(A);
      } catch (L) {
        N.call(this, L);
        break;
      }
    }
    try {
      d = j6.call(this, A);
    } catch (I) {
      return Promise.reject(I);
    }
    for (p = 0, x = h.length; p < x; )
      d = d.then(h[p++], h[p++]);
    return d;
  }
  getUri(e) {
    e = lc(this.defaults, e);
    const r = RS(e.baseURL, e.url);
    return PS(r, e.params, e.paramsSerializer);
  }
};
Oe.forEach(["delete", "get", "head", "options"], function(e) {
  nc.prototype[e] = function(r, n) {
    return this.request(lc(n || {}, {
      method: e,
      url: r,
      data: (n || {}).data
    }));
  };
});
Oe.forEach(["post", "put", "patch"], function(e) {
  function r(n) {
    return function(s, o, a) {
      return this.request(lc(a || {}, {
        method: e,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: o
      }));
    };
  }
  nc.prototype[e] = r(), nc.prototype[e + "Form"] = r(!0);
});
let FX = class $S {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(s) {
      r = s;
    });
    const n = this;
    this.promise.then((i) => {
      if (!n._listeners) return;
      let s = n._listeners.length;
      for (; s-- > 0; )
        n._listeners[s](i);
      n._listeners = null;
    }), this.promise.then = (i) => {
      let s;
      const o = new Promise((a) => {
        n.subscribe(a), s = a;
      }).then(i);
      return o.cancel = function() {
        n.unsubscribe(s);
      }, o;
    }, e(function(s, o, a) {
      n.reason || (n.reason = new zu(s, o, a), r(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(e);
    r !== -1 && this._listeners.splice(r, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), r = (n) => {
      e.abort(n);
    };
    return this.subscribe(r), e.signal.unsubscribe = () => this.unsubscribe(r), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new $S(function(i) {
        e = i;
      }),
      cancel: e
    };
  }
};
function UX(t) {
  return function(r) {
    return t.apply(null, r);
  };
}
function jX(t) {
  return Oe.isObject(t) && t.isAxiosError === !0;
}
const Y1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Y1).forEach(([t, e]) => {
  Y1[e] = t;
});
function BS(t) {
  const e = new nc(t), r = pS(nc.prototype.request, e);
  return Oe.extend(r, nc.prototype, e, { allOwnKeys: !0 }), Oe.extend(r, e, null, { allOwnKeys: !0 }), r.create = function(i) {
    return BS(lc(t, i));
  }, r;
}
const mn = BS(sh);
mn.Axios = nc;
mn.CanceledError = zu;
mn.CancelToken = FX;
mn.isCancel = CS;
mn.VERSION = kS;
mn.toFormData = dp;
mn.AxiosError = sr;
mn.Cancel = mn.CanceledError;
mn.all = function(e) {
  return Promise.all(e);
};
mn.spread = UX;
mn.isAxiosError = jX;
mn.mergeConfig = lc;
mn.AxiosHeaders = yi;
mn.formToJSON = (t) => IS(Oe.isHTMLForm(t) ? new FormData(t) : t);
mn.getAdapter = LS.getAdapter;
mn.HttpStatusCode = Y1;
mn.default = mn;
const {
  Axios: Vse,
  AxiosError: qX,
  CanceledError: Gse,
  isCancel: Yse,
  CancelToken: Jse,
  VERSION: Xse,
  all: Zse,
  Cancel: Qse,
  isAxiosError: eoe,
  spread: toe,
  toFormData: roe,
  AxiosHeaders: noe,
  HttpStatusCode: ioe,
  formToJSON: soe,
  getAdapter: ooe,
  mergeConfig: aoe
} = mn, FS = mn.create({
  baseURL: "/api/v2",
  timeout: 6e4,
  headers: {
    "Content-Type": "application/json"
  }
});
function zX(t) {
  var e, r, n;
  if (((e = t.data) == null ? void 0 : e.success) !== !0) {
    const i = new qX(
      (r = t.data) == null ? void 0 : r.errorMessage,
      (n = t.data) == null ? void 0 : n.errorCode,
      t.config,
      t.request,
      t
    );
    return Promise.reject(i);
  } else
    return t;
}
FS.interceptors.response.use(
  zX
);
class HX {
  constructor(e) {
    Rs(this, "_apiBase", "");
    this.request = e;
  }
  setApiBase(e) {
    this._apiBase = e || "";
  }
  async getNonce(e) {
    const { data: r } = await this.request.post(`${this._apiBase}/api/v2/user/nonce`, e);
    return r.data;
  }
  async getEmailCode(e) {
    const { data: r } = await this.request.post(`${this._apiBase}/api/v2/user/get_code`, e);
    return r.data;
  }
  async emailLogin(e) {
    return (await this.request.post(`${this._apiBase}/api/v2/user/login`, e)).data;
  }
  async walletLogin(e) {
    return (await this.request.post(`${this._apiBase}/api/v2/user/login`, e)).data;
  }
  async tonLogin(e) {
    return (await this.request.post(`${this._apiBase}/api/v2/user/login`, e)).data;
  }
}
const va = new HX(FS), WX = {
  projectId: "7a4434fefbcc9af474fb5c995e47d286",
  metadata: {
    name: "codatta",
    description: "codatta",
    url: "https://codatta.io/",
    icons: ["https://avatars.githubusercontent.com/u/171659315"]
  }
}, KX = lJ({
  appName: "codatta",
  appLogoUrl: "https://avatars.githubusercontent.com/u/171659315"
}), US = hc({
  saveLastUsedWallet: () => {
  },
  lastUsedWallet: null,
  wallets: [],
  initialized: !1,
  featuredWallets: [],
  config: {
    channel: "",
    device: "WEB",
    app: "",
    inviderCode: "",
    relateInfo: {}
  }
});
function xc() {
  return Fn(US);
}
function coe(t) {
  const [e, r] = Er([]), [n, i] = Er([]), [s, o] = Er(null), [a, u] = Er(!1), [h] = Er(t.config), d = (A) => {
    console.log("saveLastUsedWallet", A);
  };
  function p(A) {
    const I = A.filter((F) => F.featured || F.installed), N = A.filter((F) => !F.featured && !F.installed), L = [...I, ...N];
    r(L), i(I);
  }
  async function x() {
    const A = [], I = /* @__PURE__ */ new Map();
    MR.forEach(($) => {
      const W = new gl($);
      $.name === "Coinbase Wallet" && W.EIP6963Detected({
        info: { name: "Coinbase Wallet", uuid: "coinbase", icon: $.image, rdns: "coinbase" },
        provider: KX.getProvider()
      }), I.set(W.key, W), A.push(W);
    }), (await PG()).forEach(($) => {
      const W = I.get($.info.name);
      if (W)
        W.EIP6963Detected($);
      else {
        const z = new gl($);
        I.set(z.key, z), A.push(z);
      }
    });
    const L = JSON.parse(localStorage.getItem("cn-last-used-info") || "{}"), F = I.get(L.key);
    if (F) {
      if (F.lastUsed = !0, L.provider === "UniversalProvider") {
        const $ = await _E.init(WX);
        $.session && F.setUniversalProvider($);
      }
      o(F);
    }
    p(A), u(!0);
  }
  return si(() => {
    x(), va.setApiBase(h.apiBaseUrl);
  }, []), /* @__PURE__ */ ve.jsx(
    US.Provider,
    {
      value: {
        saveLastUsedWallet: d,
        wallets: e,
        initialized: a,
        lastUsedWallet: s,
        featuredWallets: n,
        config: h
      },
      children: t.children
    }
  );
}
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const VX = (t) => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), jS = (...t) => t.filter((e, r, n) => !!e && e.trim() !== "" && n.indexOf(e) === r).join(" ").trim();
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var GX = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const YX = gv(
  ({
    color: t = "currentColor",
    size: e = 24,
    strokeWidth: r = 2,
    absoluteStrokeWidth: n,
    className: i = "",
    children: s,
    iconNode: o,
    ...a
  }, u) => jd(
    "svg",
    {
      ref: u,
      ...GX,
      width: e,
      height: e,
      stroke: t,
      strokeWidth: n ? Number(r) * 24 / Number(e) : r,
      className: jS("lucide", i),
      ...a
    },
    [
      ...o.map(([h, d]) => jd(h, d)),
      ...Array.isArray(s) ? s : [s]
    ]
  )
);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ps = (t, e) => {
  const r = gv(
    ({ className: n, ...i }, s) => jd(YX, {
      ref: s,
      iconNode: e,
      className: jS(`lucide-${VX(t)}`, n),
      ...i
    })
  );
  return r.displayName = `${t}`, r;
};
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const JX = Ps("ArrowLeft", [
  ["path", { d: "m12 19-7-7 7-7", key: "1l729n" }],
  ["path", { d: "M19 12H5", key: "x3x0zl" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const qS = Ps("ArrowRight", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const XX = Ps("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ZX = Ps("CircleCheckBig", [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const QX = Ps("Download", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }],
  ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const eZ = Ps("Globe", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" }],
  ["path", { d: "M2 12h20", key: "9i4pu4" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const tZ = Ps("Laptop", [
  [
    "path",
    {
      d: "M20 16V7a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v9m16 0H4m16 0 1.28 2.55a1 1 0 0 1-.9 1.45H3.62a1 1 0 0 1-.9-1.45L4 16",
      key: "tarvll"
    }
  ]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const rZ = Ps("Link2", [
  ["path", { d: "M9 17H7A5 5 0 0 1 7 7h2", key: "8i5ue5" }],
  ["path", { d: "M15 7h2a5 5 0 1 1 0 10h-2", key: "1b9ql8" }],
  ["line", { x1: "8", x2: "16", y1: "12", y2: "12", key: "1jonct" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Pl = Ps("LoaderCircle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const nZ = Ps("Mail", [
  ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" }],
  ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7", key: "1ocrg3" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const zS = Ps("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
]), z6 = /* @__PURE__ */ new Set();
function mp(t, e, r) {
  t || z6.has(e) || (console.warn(e), z6.add(e));
}
function iZ(t) {
  if (typeof Proxy > "u")
    return t;
  const e = /* @__PURE__ */ new Map(), r = (...n) => (process.env.NODE_ENV !== "production" && mp(!1, "motion() is deprecated. Use motion.create() instead."), t(...n));
  return new Proxy(r, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (n, i) => i === "create" ? t : (e.has(i) || e.set(i, t(i)), e.get(i))
  });
}
function vp(t) {
  return t !== null && typeof t == "object" && typeof t.start == "function";
}
const J1 = (t) => Array.isArray(t);
function HS(t, e) {
  if (!Array.isArray(e))
    return !1;
  const r = e.length;
  if (r !== t.length)
    return !1;
  for (let n = 0; n < r; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function Ml(t) {
  return typeof t == "string" || Array.isArray(t);
}
function H6(t) {
  const e = [{}, {}];
  return t == null || t.values.forEach((r, n) => {
    e[0][n] = r.get(), e[1][n] = r.getVelocity();
  }), e;
}
function Pb(t, e, r, n) {
  if (typeof e == "function") {
    const [i, s] = H6(n);
    e = e(r !== void 0 ? r : t.custom, i, s);
  }
  if (typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function") {
    const [i, s] = H6(n);
    e = e(r !== void 0 ? r : t.custom, i, s);
  }
  return e;
}
function bp(t, e, r) {
  const n = t.getProps();
  return Pb(n, e, r !== void 0 ? r : n.custom, t);
}
const Mb = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], Ib = ["initial", ...Mb], oh = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], _c = new Set(oh), Ws = (t) => t * 1e3, Io = (t) => t / 1e3, sZ = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, oZ = (t) => ({
  type: "spring",
  stiffness: 550,
  damping: t === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), aZ = {
  type: "keyframes",
  duration: 0.8
}, cZ = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, uZ = (t, { keyframes: e }) => e.length > 2 ? aZ : _c.has(t) ? t.startsWith("scale") ? oZ(e[1]) : sZ : cZ;
function Cb(t, e) {
  return t ? t[e] || t.default || t : void 0;
}
const fZ = {
  useManualTiming: !1
}, lZ = (t) => t !== null;
function yp(t, { repeat: e, repeatType: r = "loop" }, n) {
  const i = t.filter(lZ), s = e && r !== "loop" && e % 2 === 1 ? 0 : i.length - 1;
  return !s || n === void 0 ? i[s] : n;
}
const Un = (t) => t;
function hZ(t) {
  let e = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), n = !1, i = !1;
  const s = /* @__PURE__ */ new WeakSet();
  let o = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function a(h) {
    s.has(h) && (u.schedule(h), t()), h(o);
  }
  const u = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (h, d = !1, p = !1) => {
      const A = p && n ? e : r;
      return d && s.add(h), A.has(h) || A.add(h), h;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (h) => {
      r.delete(h), s.delete(h);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (h) => {
      if (o = h, n) {
        i = !0;
        return;
      }
      n = !0, [e, r] = [r, e], r.clear(), e.forEach(a), n = !1, i && (i = !1, u.process(h));
    }
  };
  return u;
}
const pd = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
], dZ = 40;
function WS(t, e) {
  let r = !1, n = !0;
  const i = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, s = () => r = !0, o = pd.reduce((F, $) => (F[$] = hZ(s), F), {}), { read: a, resolveKeyframes: u, update: h, preRender: d, render: p, postRender: x } = o, A = () => {
    const F = performance.now();
    r = !1, i.delta = n ? 1e3 / 60 : Math.max(Math.min(F - i.timestamp, dZ), 1), i.timestamp = F, i.isProcessing = !0, a.process(i), u.process(i), h.process(i), d.process(i), p.process(i), x.process(i), i.isProcessing = !1, r && e && (n = !1, t(A));
  }, I = () => {
    r = !0, n = !0, i.isProcessing || t(A);
  };
  return { schedule: pd.reduce((F, $) => {
    const W = o[$];
    return F[$] = (z, V = !1, te = !1) => (r || I(), W.schedule(z, V, te)), F;
  }, {}), cancel: (F) => {
    for (let $ = 0; $ < pd.length; $++)
      o[pd[$]].cancel(F);
  }, state: i, steps: o };
}
const { schedule: Lr, cancel: ba, state: $n, steps: Dm } = WS(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Un, !0), KS = (t, e, r) => (((1 - 3 * r + 3 * e) * t + (3 * r - 6 * e)) * t + 3 * e) * t, pZ = 1e-7, gZ = 12;
function mZ(t, e, r, n, i) {
  let s, o, a = 0;
  do
    o = e + (r - e) / 2, s = KS(o, n, i) - t, s > 0 ? r = o : e = o;
  while (Math.abs(s) > pZ && ++a < gZ);
  return o;
}
function ah(t, e, r, n) {
  if (t === e && r === n)
    return Un;
  const i = (s) => mZ(s, 0, 1, t, r);
  return (s) => s === 0 || s === 1 ? s : KS(i(s), e, n);
}
const VS = (t) => (e) => e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, GS = (t) => (e) => 1 - t(1 - e), YS = /* @__PURE__ */ ah(0.33, 1.53, 0.69, 0.99), Tb = /* @__PURE__ */ GS(YS), JS = /* @__PURE__ */ VS(Tb), XS = (t) => (t *= 2) < 1 ? 0.5 * Tb(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))), Rb = (t) => 1 - Math.sin(Math.acos(t)), ZS = GS(Rb), QS = VS(Rb), e7 = (t) => /^0[^.\s]+$/u.test(t);
function vZ(t) {
  return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || e7(t) : !0;
}
let Hu = Un, Bo = Un;
process.env.NODE_ENV !== "production" && (Hu = (t, e) => {
  !t && typeof console < "u" && console.warn(e);
}, Bo = (t, e) => {
  if (!t)
    throw new Error(e);
});
const t7 = (t) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t), r7 = (t) => (e) => typeof e == "string" && e.startsWith(t), n7 = /* @__PURE__ */ r7("--"), bZ = /* @__PURE__ */ r7("var(--"), Db = (t) => bZ(t) ? yZ.test(t.split("/*")[0].trim()) : !1, yZ = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, wZ = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function xZ(t) {
  const e = wZ.exec(t);
  if (!e)
    return [,];
  const [, r, n, i] = e;
  return [`--${r ?? n}`, i];
}
const _Z = 4;
function i7(t, e, r = 1) {
  Bo(r <= _Z, `Max CSS variable fallback depth detected in property "${t}". This may indicate a circular fallback dependency.`);
  const [n, i] = xZ(t);
  if (!n)
    return;
  const s = window.getComputedStyle(e).getPropertyValue(n);
  if (s) {
    const o = s.trim();
    return t7(o) ? parseFloat(o) : o;
  }
  return Db(i) ? i7(i, e, r + 1) : i;
}
const ya = (t, e, r) => r > e ? e : r < t ? t : r, Wu = {
  test: (t) => typeof t == "number",
  parse: parseFloat,
  transform: (t) => t
}, Il = {
  ...Wu,
  transform: (t) => ya(0, 1, t)
}, gd = {
  ...Wu,
  default: 1
}, ch = (t) => ({
  test: (e) => typeof e == "string" && e.endsWith(t) && e.split(" ").length === 1,
  parse: parseFloat,
  transform: (e) => `${e}${t}`
}), na = /* @__PURE__ */ ch("deg"), Ks = /* @__PURE__ */ ch("%"), Vt = /* @__PURE__ */ ch("px"), EZ = /* @__PURE__ */ ch("vh"), SZ = /* @__PURE__ */ ch("vw"), W6 = {
  ...Ks,
  parse: (t) => Ks.parse(t) / 100,
  transform: (t) => Ks.transform(t * 100)
}, AZ = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]), K6 = (t) => t === Wu || t === Vt, V6 = (t, e) => parseFloat(t.split(", ")[e]), G6 = (t, e) => (r, { transform: n }) => {
  if (n === "none" || !n)
    return 0;
  const i = n.match(/^matrix3d\((.+)\)$/u);
  if (i)
    return V6(i[1], e);
  {
    const s = n.match(/^matrix\((.+)\)$/u);
    return s ? V6(s[1], t) : 0;
  }
}, PZ = /* @__PURE__ */ new Set(["x", "y", "z"]), MZ = oh.filter((t) => !PZ.has(t));
function IZ(t) {
  const e = [];
  return MZ.forEach((r) => {
    const n = t.getValue(r);
    n !== void 0 && (e.push([r, n.get()]), n.set(r.startsWith("scale") ? 1 : 0));
  }), e;
}
const Au = {
  // Dimensions
  width: ({ x: t }, { paddingLeft: e = "0", paddingRight: r = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(r),
  height: ({ y: t }, { paddingTop: e = "0", paddingBottom: r = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(r),
  top: (t, { top: e }) => parseFloat(e),
  left: (t, { left: e }) => parseFloat(e),
  bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min),
  right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min),
  // Transform
  x: G6(4, 13),
  y: G6(5, 14)
};
Au.translateX = Au.x;
Au.translateY = Au.y;
const s7 = (t) => (e) => e.test(t), CZ = {
  test: (t) => t === "auto",
  parse: (t) => t
}, o7 = [Wu, Vt, Ks, na, SZ, EZ, CZ], Y6 = (t) => o7.find(s7(t)), ic = /* @__PURE__ */ new Set();
let X1 = !1, Z1 = !1;
function a7() {
  if (Z1) {
    const t = Array.from(ic).filter((n) => n.needsMeasurement), e = new Set(t.map((n) => n.element)), r = /* @__PURE__ */ new Map();
    e.forEach((n) => {
      const i = IZ(n);
      i.length && (r.set(n, i), n.render());
    }), t.forEach((n) => n.measureInitialState()), e.forEach((n) => {
      n.render();
      const i = r.get(n);
      i && i.forEach(([s, o]) => {
        var a;
        (a = n.getValue(s)) === null || a === void 0 || a.set(o);
      });
    }), t.forEach((n) => n.measureEndState()), t.forEach((n) => {
      n.suspendedScrollY !== void 0 && window.scrollTo(0, n.suspendedScrollY);
    });
  }
  Z1 = !1, X1 = !1, ic.forEach((t) => t.complete()), ic.clear();
}
function c7() {
  ic.forEach((t) => {
    t.readKeyframes(), t.needsMeasurement && (Z1 = !0);
  });
}
function TZ() {
  c7(), a7();
}
class Ob {
  constructor(e, r, n, i, s, o = !1) {
    this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = r, this.name = n, this.motionValue = i, this.element = s, this.isAsync = o;
  }
  scheduleResolve() {
    this.isScheduled = !0, this.isAsync ? (ic.add(this), X1 || (X1 = !0, Lr.read(c7), Lr.resolveKeyframes(a7))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, name: r, element: n, motionValue: i } = this;
    for (let s = 0; s < e.length; s++)
      if (e[s] === null)
        if (s === 0) {
          const o = i == null ? void 0 : i.get(), a = e[e.length - 1];
          if (o !== void 0)
            e[0] = o;
          else if (n && r) {
            const u = n.readValue(r, a);
            u != null && (e[0] = u);
          }
          e[0] === void 0 && (e[0] = a), i && o === void 0 && i.set(e[0]);
        } else
          e[s] = e[s - 1];
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), ic.delete(this);
  }
  cancel() {
    this.isComplete || (this.isScheduled = !1, ic.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const Vf = (t) => Math.round(t * 1e5) / 1e5, Nb = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function RZ(t) {
  return t == null;
}
const DZ = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, Lb = (t, e) => (r) => !!(typeof r == "string" && DZ.test(r) && r.startsWith(t) || e && !RZ(r) && Object.prototype.hasOwnProperty.call(r, e)), u7 = (t, e, r) => (n) => {
  if (typeof n != "string")
    return n;
  const [i, s, o, a] = n.match(Nb);
  return {
    [t]: parseFloat(i),
    [e]: parseFloat(s),
    [r]: parseFloat(o),
    alpha: a !== void 0 ? parseFloat(a) : 1
  };
}, OZ = (t) => ya(0, 255, t), Om = {
  ...Wu,
  transform: (t) => Math.round(OZ(t))
}, tc = {
  test: /* @__PURE__ */ Lb("rgb", "red"),
  parse: /* @__PURE__ */ u7("red", "green", "blue"),
  transform: ({ red: t, green: e, blue: r, alpha: n = 1 }) => "rgba(" + Om.transform(t) + ", " + Om.transform(e) + ", " + Om.transform(r) + ", " + Vf(Il.transform(n)) + ")"
};
function NZ(t) {
  let e = "", r = "", n = "", i = "";
  return t.length > 5 ? (e = t.substring(1, 3), r = t.substring(3, 5), n = t.substring(5, 7), i = t.substring(7, 9)) : (e = t.substring(1, 2), r = t.substring(2, 3), n = t.substring(3, 4), i = t.substring(4, 5), e += e, r += r, n += n, i += i), {
    red: parseInt(e, 16),
    green: parseInt(r, 16),
    blue: parseInt(n, 16),
    alpha: i ? parseInt(i, 16) / 255 : 1
  };
}
const Q1 = {
  test: /* @__PURE__ */ Lb("#"),
  parse: NZ,
  transform: tc.transform
}, Zc = {
  test: /* @__PURE__ */ Lb("hsl", "hue"),
  parse: /* @__PURE__ */ u7("hue", "saturation", "lightness"),
  transform: ({ hue: t, saturation: e, lightness: r, alpha: n = 1 }) => "hsla(" + Math.round(t) + ", " + Ks.transform(Vf(e)) + ", " + Ks.transform(Vf(r)) + ", " + Vf(Il.transform(n)) + ")"
}, Gn = {
  test: (t) => tc.test(t) || Q1.test(t) || Zc.test(t),
  parse: (t) => tc.test(t) ? tc.parse(t) : Zc.test(t) ? Zc.parse(t) : Q1.parse(t),
  transform: (t) => typeof t == "string" ? t : t.hasOwnProperty("red") ? tc.transform(t) : Zc.transform(t)
}, LZ = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function kZ(t) {
  var e, r;
  return isNaN(t) && typeof t == "string" && (((e = t.match(Nb)) === null || e === void 0 ? void 0 : e.length) || 0) + (((r = t.match(LZ)) === null || r === void 0 ? void 0 : r.length) || 0) > 0;
}
const f7 = "number", l7 = "color", $Z = "var", BZ = "var(", J6 = "${}", FZ = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function Cl(t) {
  const e = t.toString(), r = [], n = {
    color: [],
    number: [],
    var: []
  }, i = [];
  let s = 0;
  const a = e.replace(FZ, (u) => (Gn.test(u) ? (n.color.push(s), i.push(l7), r.push(Gn.parse(u))) : u.startsWith(BZ) ? (n.var.push(s), i.push($Z), r.push(u)) : (n.number.push(s), i.push(f7), r.push(parseFloat(u))), ++s, J6)).split(J6);
  return { values: r, split: a, indexes: n, types: i };
}
function h7(t) {
  return Cl(t).values;
}
function d7(t) {
  const { split: e, types: r } = Cl(t), n = e.length;
  return (i) => {
    let s = "";
    for (let o = 0; o < n; o++)
      if (s += e[o], i[o] !== void 0) {
        const a = r[o];
        a === f7 ? s += Vf(i[o]) : a === l7 ? s += Gn.transform(i[o]) : s += i[o];
      }
    return s;
  };
}
const UZ = (t) => typeof t == "number" ? 0 : t;
function jZ(t) {
  const e = h7(t);
  return d7(t)(e.map(UZ));
}
const wa = {
  test: kZ,
  parse: h7,
  createTransformer: d7,
  getAnimatableNone: jZ
}, qZ = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function zZ(t) {
  const [e, r] = t.slice(0, -1).split("(");
  if (e === "drop-shadow")
    return t;
  const [n] = r.match(Nb) || [];
  if (!n)
    return t;
  const i = r.replace(n, "");
  let s = qZ.has(e) ? 1 : 0;
  return n !== r && (s *= 100), e + "(" + s + i + ")";
}
const HZ = /\b([a-z-]*)\(.*?\)/gu, ev = {
  ...wa,
  getAnimatableNone: (t) => {
    const e = t.match(HZ);
    return e ? e.map(zZ).join(" ") : t;
  }
}, WZ = {
  // Border props
  borderWidth: Vt,
  borderTopWidth: Vt,
  borderRightWidth: Vt,
  borderBottomWidth: Vt,
  borderLeftWidth: Vt,
  borderRadius: Vt,
  radius: Vt,
  borderTopLeftRadius: Vt,
  borderTopRightRadius: Vt,
  borderBottomRightRadius: Vt,
  borderBottomLeftRadius: Vt,
  // Positioning props
  width: Vt,
  maxWidth: Vt,
  height: Vt,
  maxHeight: Vt,
  top: Vt,
  right: Vt,
  bottom: Vt,
  left: Vt,
  // Spacing props
  padding: Vt,
  paddingTop: Vt,
  paddingRight: Vt,
  paddingBottom: Vt,
  paddingLeft: Vt,
  margin: Vt,
  marginTop: Vt,
  marginRight: Vt,
  marginBottom: Vt,
  marginLeft: Vt,
  // Misc
  backgroundPositionX: Vt,
  backgroundPositionY: Vt
}, KZ = {
  rotate: na,
  rotateX: na,
  rotateY: na,
  rotateZ: na,
  scale: gd,
  scaleX: gd,
  scaleY: gd,
  scaleZ: gd,
  skew: na,
  skewX: na,
  skewY: na,
  distance: Vt,
  translateX: Vt,
  translateY: Vt,
  translateZ: Vt,
  x: Vt,
  y: Vt,
  z: Vt,
  perspective: Vt,
  transformPerspective: Vt,
  opacity: Il,
  originX: W6,
  originY: W6,
  originZ: Vt
}, X6 = {
  ...Wu,
  transform: Math.round
}, kb = {
  ...WZ,
  ...KZ,
  zIndex: X6,
  size: Vt,
  // SVG
  fillOpacity: Il,
  strokeOpacity: Il,
  numOctaves: X6
}, VZ = {
  ...kb,
  // Color props
  color: Gn,
  backgroundColor: Gn,
  outlineColor: Gn,
  fill: Gn,
  stroke: Gn,
  // Border props
  borderColor: Gn,
  borderTopColor: Gn,
  borderRightColor: Gn,
  borderBottomColor: Gn,
  borderLeftColor: Gn,
  filter: ev,
  WebkitFilter: ev
}, $b = (t) => VZ[t];
function p7(t, e) {
  let r = $b(t);
  return r !== ev && (r = wa), r.getAnimatableNone ? r.getAnimatableNone(e) : void 0;
}
const GZ = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function YZ(t, e, r) {
  let n = 0, i;
  for (; n < t.length && !i; ) {
    const s = t[n];
    typeof s == "string" && !GZ.has(s) && Cl(s).values.length && (i = t[n]), n++;
  }
  if (i && r)
    for (const s of e)
      t[s] = p7(r, i);
}
class g7 extends Ob {
  constructor(e, r, n, i, s) {
    super(e, r, n, i, s, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: r, name: n } = this;
    if (!r || !r.current)
      return;
    super.readKeyframes();
    for (let u = 0; u < e.length; u++) {
      let h = e[u];
      if (typeof h == "string" && (h = h.trim(), Db(h))) {
        const d = i7(h, r.current);
        d !== void 0 && (e[u] = d), u === e.length - 1 && (this.finalKeyframe = h);
      }
    }
    if (this.resolveNoneKeyframes(), !AZ.has(n) || e.length !== 2)
      return;
    const [i, s] = e, o = Y6(i), a = Y6(s);
    if (o !== a)
      if (K6(o) && K6(a))
        for (let u = 0; u < e.length; u++) {
          const h = e[u];
          typeof h == "string" && (e[u] = parseFloat(h));
        }
      else
        this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: r } = this, n = [];
    for (let i = 0; i < e.length; i++)
      vZ(e[i]) && n.push(i);
    n.length && YZ(e, n, r);
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: r, name: n } = this;
    if (!e || !e.current)
      return;
    n === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Au[n](e.measureViewportBox(), window.getComputedStyle(e.current)), r[0] = this.measuredOrigin;
    const i = r[r.length - 1];
    i !== void 0 && e.getValue(n, i).jump(i, !1);
  }
  measureEndState() {
    var e;
    const { element: r, name: n, unresolvedKeyframes: i } = this;
    if (!r || !r.current)
      return;
    const s = r.getValue(n);
    s && s.jump(this.measuredOrigin, !1);
    const o = i.length - 1, a = i[o];
    i[o] = Au[n](r.measureViewportBox(), window.getComputedStyle(r.current)), a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a), !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach(([u, h]) => {
      r.getValue(u).set(h);
    }), this.resolveNoneKeyframes();
  }
}
function Bb(t) {
  return typeof t == "function";
}
let Bd;
function JZ() {
  Bd = void 0;
}
const Vs = {
  now: () => (Bd === void 0 && Vs.set($n.isProcessing || fZ.useManualTiming ? $n.timestamp : performance.now()), Bd),
  set: (t) => {
    Bd = t, queueMicrotask(JZ);
  }
}, Z6 = (t, e) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && // It's animatable if we have a string
(wa.test(t) || t === "0") && // And it contains numbers and/or colors
!t.startsWith("url("));
function XZ(t) {
  const e = t[0];
  if (t.length === 1)
    return !0;
  for (let r = 0; r < t.length; r++)
    if (t[r] !== e)
      return !0;
}
function ZZ(t, e, r, n) {
  const i = t[0];
  if (i === null)
    return !1;
  if (e === "display" || e === "visibility")
    return !0;
  const s = t[t.length - 1], o = Z6(i, e), a = Z6(s, e);
  return Hu(o === a, `You are trying to animate ${e} from "${i}" to "${s}". ${i} is not an animatable value - to enable this animation set ${i} to a value animatable to ${s} via the \`style\` property.`), !o || !a ? !1 : XZ(t) || (r === "spring" || Bb(r)) && n;
}
const QZ = 40;
class m7 {
  constructor({ autoplay: e = !0, delay: r = 0, type: n = "keyframes", repeat: i = 0, repeatDelay: s = 0, repeatType: o = "loop", ...a }) {
    this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = Vs.now(), this.options = {
      autoplay: e,
      delay: r,
      type: n,
      repeat: i,
      repeatDelay: s,
      repeatType: o,
      ...a
    }, this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    return this.resolvedAt ? this.resolvedAt - this.createdAt > QZ ? this.resolvedAt : this.createdAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && TZ(), this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(e, r) {
    this.resolvedAt = Vs.now(), this.hasAttemptedResolve = !0;
    const { name: n, type: i, velocity: s, delay: o, onComplete: a, onUpdate: u, isGenerator: h } = this.options;
    if (!h && !ZZ(e, n, i, s))
      if (o)
        this.options.duration = 0;
      else {
        u == null || u(yp(e, this.options, r)), a == null || a(), this.resolveFinishedPromise();
        return;
      }
    const d = this.initPlayback(e, r);
    d !== !1 && (this._resolved = {
      keyframes: e,
      finalKeyframe: r,
      ...d
    }, this.onPostResolved());
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(e, r) {
    return this.currentFinishedPromise.then(e, r);
  }
  flatten() {
    this.options.type = "keyframes", this.options.ease = "linear";
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((e) => {
      this.resolveFinishedPromise = e;
    });
  }
}
function v7(t, e) {
  return e ? t * (1e3 / e) : 0;
}
const eQ = 5;
function b7(t, e, r) {
  const n = Math.max(e - eQ, 0);
  return v7(r - t(n), e - n);
}
const Nm = 1e-3, tQ = 0.01, Q6 = 10, rQ = 0.05, nQ = 1;
function iQ({ duration: t = 800, bounce: e = 0.25, velocity: r = 0, mass: n = 1 }) {
  let i, s;
  Hu(t <= Ws(Q6), "Spring duration must be 10 seconds or less");
  let o = 1 - e;
  o = ya(rQ, nQ, o), t = ya(tQ, Q6, Io(t)), o < 1 ? (i = (h) => {
    const d = h * o, p = d * t, x = d - r, A = tv(h, o), I = Math.exp(-p);
    return Nm - x / A * I;
  }, s = (h) => {
    const p = h * o * t, x = p * r + r, A = Math.pow(o, 2) * Math.pow(h, 2) * t, I = Math.exp(-p), N = tv(Math.pow(h, 2), o);
    return (-i(h) + Nm > 0 ? -1 : 1) * ((x - A) * I) / N;
  }) : (i = (h) => {
    const d = Math.exp(-h * t), p = (h - r) * t + 1;
    return -Nm + d * p;
  }, s = (h) => {
    const d = Math.exp(-h * t), p = (r - h) * (t * t);
    return d * p;
  });
  const a = 5 / t, u = oQ(i, s, a);
  if (t = Ws(t), isNaN(u))
    return {
      stiffness: 100,
      damping: 10,
      duration: t
    };
  {
    const h = Math.pow(u, 2) * n;
    return {
      stiffness: h,
      damping: o * 2 * Math.sqrt(n * h),
      duration: t
    };
  }
}
const sQ = 12;
function oQ(t, e, r) {
  let n = r;
  for (let i = 1; i < sQ; i++)
    n = n - t(n) / e(n);
  return n;
}
function tv(t, e) {
  return t * Math.sqrt(1 - e * e);
}
const aQ = ["duration", "bounce"], cQ = ["stiffness", "damping", "mass"];
function e_(t, e) {
  return e.some((r) => t[r] !== void 0);
}
function uQ(t) {
  let e = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...t
  };
  if (!e_(t, cQ) && e_(t, aQ)) {
    const r = iQ(t);
    e = {
      ...e,
      ...r,
      mass: 1
    }, e.isResolvedFromDuration = !0;
  }
  return e;
}
function y7({ keyframes: t, restDelta: e, restSpeed: r, ...n }) {
  const i = t[0], s = t[t.length - 1], o = { done: !1, value: i }, { stiffness: a, damping: u, mass: h, duration: d, velocity: p, isResolvedFromDuration: x } = uQ({
    ...n,
    velocity: -Io(n.velocity || 0)
  }), A = p || 0, I = u / (2 * Math.sqrt(a * h)), N = s - i, L = Io(Math.sqrt(a / h)), F = Math.abs(N) < 5;
  r || (r = F ? 0.01 : 2), e || (e = F ? 5e-3 : 0.5);
  let $;
  if (I < 1) {
    const W = tv(L, I);
    $ = (z) => {
      const V = Math.exp(-I * L * z);
      return s - V * ((A + I * L * N) / W * Math.sin(W * z) + N * Math.cos(W * z));
    };
  } else if (I === 1)
    $ = (W) => s - Math.exp(-L * W) * (N + (A + L * N) * W);
  else {
    const W = L * Math.sqrt(I * I - 1);
    $ = (z) => {
      const V = Math.exp(-I * L * z), te = Math.min(W * z, 300);
      return s - V * ((A + I * L * N) * Math.sinh(te) + W * N * Math.cosh(te)) / W;
    };
  }
  return {
    calculatedDuration: x && d || null,
    next: (W) => {
      const z = $(W);
      if (x)
        o.done = W >= d;
      else {
        let V = 0;
        I < 1 && (V = W === 0 ? Ws(A) : b7($, W, z));
        const te = Math.abs(V) <= r, R = Math.abs(s - z) <= e;
        o.done = te && R;
      }
      return o.value = o.done ? s : z, o;
    }
  };
}
function t_({ keyframes: t, velocity: e = 0, power: r = 0.8, timeConstant: n = 325, bounceDamping: i = 10, bounceStiffness: s = 500, modifyTarget: o, min: a, max: u, restDelta: h = 0.5, restSpeed: d }) {
  const p = t[0], x = {
    done: !1,
    value: p
  }, A = (K) => a !== void 0 && K < a || u !== void 0 && K > u, I = (K) => a === void 0 ? u : u === void 0 || Math.abs(a - K) < Math.abs(u - K) ? a : u;
  let N = r * e;
  const L = p + N, F = o === void 0 ? L : o(L);
  F !== L && (N = F - p);
  const $ = (K) => -N * Math.exp(-K / n), W = (K) => F + $(K), z = (K) => {
    const pe = $(K), _e = W(K);
    x.done = Math.abs(pe) <= h, x.value = x.done ? F : _e;
  };
  let V, te;
  const R = (K) => {
    A(x.value) && (V = K, te = y7({
      keyframes: [x.value, I(x.value)],
      velocity: b7(W, K, x.value),
      // TODO: This should be passing * 1000
      damping: i,
      stiffness: s,
      restDelta: h,
      restSpeed: d
    }));
  };
  return R(0), {
    calculatedDuration: null,
    next: (K) => {
      let pe = !1;
      return !te && V === void 0 && (pe = !0, z(K), R(K)), V !== void 0 && K >= V ? te.next(K - V) : (!pe && z(K), x);
    }
  };
}
const fQ = /* @__PURE__ */ ah(0.42, 0, 1, 1), lQ = /* @__PURE__ */ ah(0, 0, 0.58, 1), w7 = /* @__PURE__ */ ah(0.42, 0, 0.58, 1), hQ = (t) => Array.isArray(t) && typeof t[0] != "number", Fb = (t) => Array.isArray(t) && typeof t[0] == "number", r_ = {
  linear: Un,
  easeIn: fQ,
  easeInOut: w7,
  easeOut: lQ,
  circIn: Rb,
  circInOut: QS,
  circOut: ZS,
  backIn: Tb,
  backInOut: JS,
  backOut: YS,
  anticipate: XS
}, n_ = (t) => {
  if (Fb(t)) {
    Bo(t.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [e, r, n, i] = t;
    return ah(e, r, n, i);
  } else if (typeof t == "string")
    return Bo(r_[t] !== void 0, `Invalid easing type '${t}'`), r_[t];
  return t;
}, dQ = (t, e) => (r) => e(t(r)), Co = (...t) => t.reduce(dQ), Pu = (t, e, r) => {
  const n = e - t;
  return n === 0 ? 1 : (r - t) / n;
}, Qr = (t, e, r) => t + (e - t) * r;
function Lm(t, e, r) {
  return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? t + (e - t) * 6 * r : r < 1 / 2 ? e : r < 2 / 3 ? t + (e - t) * (2 / 3 - r) * 6 : t;
}
function pQ({ hue: t, saturation: e, lightness: r, alpha: n }) {
  t /= 360, e /= 100, r /= 100;
  let i = 0, s = 0, o = 0;
  if (!e)
    i = s = o = r;
  else {
    const a = r < 0.5 ? r * (1 + e) : r + e - r * e, u = 2 * r - a;
    i = Lm(u, a, t + 1 / 3), s = Lm(u, a, t), o = Lm(u, a, t - 1 / 3);
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(s * 255),
    blue: Math.round(o * 255),
    alpha: n
  };
}
function m0(t, e) {
  return (r) => r > 0 ? e : t;
}
const km = (t, e, r) => {
  const n = t * t, i = r * (e * e - n) + n;
  return i < 0 ? 0 : Math.sqrt(i);
}, gQ = [Q1, tc, Zc], mQ = (t) => gQ.find((e) => e.test(t));
function i_(t) {
  const e = mQ(t);
  if (Hu(!!e, `'${t}' is not an animatable color. Use the equivalent color code instead.`), !e)
    return !1;
  let r = e.parse(t);
  return e === Zc && (r = pQ(r)), r;
}
const s_ = (t, e) => {
  const r = i_(t), n = i_(e);
  if (!r || !n)
    return m0(t, e);
  const i = { ...r };
  return (s) => (i.red = km(r.red, n.red, s), i.green = km(r.green, n.green, s), i.blue = km(r.blue, n.blue, s), i.alpha = Qr(r.alpha, n.alpha, s), tc.transform(i));
}, rv = /* @__PURE__ */ new Set(["none", "hidden"]);
function vQ(t, e) {
  return rv.has(t) ? (r) => r <= 0 ? t : e : (r) => r >= 1 ? e : t;
}
function bQ(t, e) {
  return (r) => Qr(t, e, r);
}
function Ub(t) {
  return typeof t == "number" ? bQ : typeof t == "string" ? Db(t) ? m0 : Gn.test(t) ? s_ : xQ : Array.isArray(t) ? x7 : typeof t == "object" ? Gn.test(t) ? s_ : yQ : m0;
}
function x7(t, e) {
  const r = [...t], n = r.length, i = t.map((s, o) => Ub(s)(s, e[o]));
  return (s) => {
    for (let o = 0; o < n; o++)
      r[o] = i[o](s);
    return r;
  };
}
function yQ(t, e) {
  const r = { ...t, ...e }, n = {};
  for (const i in r)
    t[i] !== void 0 && e[i] !== void 0 && (n[i] = Ub(t[i])(t[i], e[i]));
  return (i) => {
    for (const s in n)
      r[s] = n[s](i);
    return r;
  };
}
function wQ(t, e) {
  var r;
  const n = [], i = { color: 0, var: 0, number: 0 };
  for (let s = 0; s < e.values.length; s++) {
    const o = e.types[s], a = t.indexes[o][i[o]], u = (r = t.values[a]) !== null && r !== void 0 ? r : 0;
    n[s] = u, i[o]++;
  }
  return n;
}
const xQ = (t, e) => {
  const r = wa.createTransformer(e), n = Cl(t), i = Cl(e);
  return n.indexes.var.length === i.indexes.var.length && n.indexes.color.length === i.indexes.color.length && n.indexes.number.length >= i.indexes.number.length ? rv.has(t) && !i.values.length || rv.has(e) && !n.values.length ? vQ(t, e) : Co(x7(wQ(n, i), i.values), r) : (Hu(!0, `Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), m0(t, e));
};
function _7(t, e, r) {
  return typeof t == "number" && typeof e == "number" && typeof r == "number" ? Qr(t, e, r) : Ub(t)(t, e);
}
function _Q(t, e, r) {
  const n = [], i = r || _7, s = t.length - 1;
  for (let o = 0; o < s; o++) {
    let a = i(t[o], t[o + 1]);
    if (e) {
      const u = Array.isArray(e) ? e[o] || Un : e;
      a = Co(u, a);
    }
    n.push(a);
  }
  return n;
}
function EQ(t, e, { clamp: r = !0, ease: n, mixer: i } = {}) {
  const s = t.length;
  if (Bo(s === e.length, "Both input and output ranges must be the same length"), s === 1)
    return () => e[0];
  if (s === 2 && t[0] === t[1])
    return () => e[1];
  t[0] > t[s - 1] && (t = [...t].reverse(), e = [...e].reverse());
  const o = _Q(e, n, i), a = o.length, u = (h) => {
    let d = 0;
    if (a > 1)
      for (; d < t.length - 2 && !(h < t[d + 1]); d++)
        ;
    const p = Pu(t[d], t[d + 1], h);
    return o[d](p);
  };
  return r ? (h) => u(ya(t[0], t[s - 1], h)) : u;
}
function SQ(t, e) {
  const r = t[t.length - 1];
  for (let n = 1; n <= e; n++) {
    const i = Pu(0, e, n);
    t.push(Qr(r, 1, i));
  }
}
function AQ(t) {
  const e = [0];
  return SQ(e, t.length - 1), e;
}
function PQ(t, e) {
  return t.map((r) => r * e);
}
function MQ(t, e) {
  return t.map(() => e || w7).splice(0, t.length - 1);
}
function v0({ duration: t = 300, keyframes: e, times: r, ease: n = "easeInOut" }) {
  const i = hQ(n) ? n.map(n_) : n_(n), s = {
    done: !1,
    value: e[0]
  }, o = PQ(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    r && r.length === e.length ? r : AQ(e),
    t
  ), a = EQ(o, e, {
    ease: Array.isArray(i) ? i : MQ(e, i)
  });
  return {
    calculatedDuration: t,
    next: (u) => (s.value = a(u), s.done = u >= t, s)
  };
}
const o_ = 2e4;
function IQ(t) {
  let e = 0;
  const r = 50;
  let n = t.next(e);
  for (; !n.done && e < o_; )
    e += r, n = t.next(e);
  return e >= o_ ? 1 / 0 : e;
}
const CQ = (t) => {
  const e = ({ timestamp: r }) => t(r);
  return {
    start: () => Lr.update(e, !0),
    stop: () => ba(e),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => $n.isProcessing ? $n.timestamp : Vs.now()
  };
}, TQ = {
  decay: t_,
  inertia: t_,
  tween: v0,
  keyframes: v0,
  spring: y7
}, RQ = (t) => t / 100;
class jb extends m7 {
  constructor(e) {
    super(e), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
      if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
        return;
      this.teardown();
      const { onStop: u } = this.options;
      u && u();
    };
    const { name: r, motionValue: n, element: i, keyframes: s } = this.options, o = (i == null ? void 0 : i.KeyframeResolver) || Ob, a = (u, h) => this.onKeyframesResolved(u, h);
    this.resolver = new o(s, a, r, n, i), this.resolver.scheduleResolve();
  }
  flatten() {
    super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
  }
  initPlayback(e) {
    const { type: r = "keyframes", repeat: n = 0, repeatDelay: i = 0, repeatType: s, velocity: o = 0 } = this.options, a = Bb(r) ? r : TQ[r] || v0;
    let u, h;
    a !== v0 && typeof e[0] != "number" && (process.env.NODE_ENV !== "production" && Bo(e.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${e}`), u = Co(RQ, _7(e[0], e[1])), e = [0, 100]);
    const d = a({ ...this.options, keyframes: e });
    s === "mirror" && (h = a({
      ...this.options,
      keyframes: [...e].reverse(),
      velocity: -o
    })), d.calculatedDuration === null && (d.calculatedDuration = IQ(d));
    const { calculatedDuration: p } = d, x = p + i, A = x * (n + 1) - i;
    return {
      generator: d,
      mirroredGenerator: h,
      mapPercentToKeyframes: u,
      calculatedDuration: p,
      resolvedDuration: x,
      totalDuration: A
    };
  }
  onPostResolved() {
    const { autoplay: e = !0 } = this.options;
    this.play(), this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState;
  }
  tick(e, r = !1) {
    const { resolved: n } = this;
    if (!n) {
      const { keyframes: K } = this.options;
      return { done: !0, value: K[K.length - 1] };
    }
    const { finalKeyframe: i, generator: s, mirroredGenerator: o, mapPercentToKeyframes: a, keyframes: u, calculatedDuration: h, totalDuration: d, resolvedDuration: p } = n;
    if (this.startTime === null)
      return s.next(0);
    const { delay: x, repeat: A, repeatType: I, repeatDelay: N, onUpdate: L } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - d / this.speed, this.startTime)), r ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed;
    const F = this.currentTime - x * (this.speed >= 0 ? 1 : -1), $ = this.speed >= 0 ? F < 0 : F > d;
    this.currentTime = Math.max(F, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = d);
    let W = this.currentTime, z = s;
    if (A) {
      const K = Math.min(this.currentTime, d) / p;
      let pe = Math.floor(K), _e = K % 1;
      !_e && K >= 1 && (_e = 1), _e === 1 && pe--, pe = Math.min(pe, A + 1), !!(pe % 2) && (I === "reverse" ? (_e = 1 - _e, N && (_e -= N / p)) : I === "mirror" && (z = o)), W = ya(0, 1, _e) * p;
    }
    const V = $ ? { done: !1, value: u[0] } : z.next(W);
    a && (V.value = a(V.value));
    let { done: te } = V;
    !$ && h !== null && (te = this.speed >= 0 ? this.currentTime >= d : this.currentTime <= 0);
    const R = this.holdTime === null && (this.state === "finished" || this.state === "running" && te);
    return R && i !== void 0 && (V.value = yp(u, this.options, i)), L && L(V.value), R && this.finish(), V;
  }
  get duration() {
    const { resolved: e } = this;
    return e ? Io(e.calculatedDuration) : 0;
  }
  get time() {
    return Io(this.currentTime);
  }
  set time(e) {
    e = Ws(e), this.currentTime = e, this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(e) {
    const r = this.playbackSpeed !== e;
    this.playbackSpeed = e, r && (this.time = Io(this.currentTime));
  }
  play() {
    if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver: e = CQ, onPlay: r, startTime: n } = this.options;
    this.driver || (this.driver = e((s) => this.tick(s))), r && r();
    const i = this.driver.now();
    this.holdTime !== null ? this.startTime = i - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = i) : this.startTime = n ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    var e;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused", this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0;
  }
  complete() {
    this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.teardown(), this.state = "finished";
    const { onComplete: e } = this.options;
    e && e();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(e) {
    return this.startTime = 0, this.tick(e, !0);
  }
}
const DQ = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]), OQ = 10, NQ = (t, e) => {
  let r = "";
  const n = Math.max(Math.round(e / OQ), 2);
  for (let i = 0; i < n; i++)
    r += t(Pu(0, n - 1, i)) + ", ";
  return `linear(${r.substring(0, r.length - 2)})`;
};
function qb(t) {
  let e;
  return () => (e === void 0 && (e = t()), e);
}
const LQ = {
  linearEasing: void 0
};
function kQ(t, e) {
  const r = qb(t);
  return () => {
    var n;
    return (n = LQ[e]) !== null && n !== void 0 ? n : r();
  };
}
const b0 = /* @__PURE__ */ kQ(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing");
function E7(t) {
  return !!(typeof t == "function" && b0() || !t || typeof t == "string" && (t in nv || b0()) || Fb(t) || Array.isArray(t) && t.every(E7));
}
const Bf = ([t, e, r, n]) => `cubic-bezier(${t}, ${e}, ${r}, ${n})`, nv = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ Bf([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ Bf([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ Bf([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ Bf([0.33, 1.53, 0.69, 0.99])
};
function S7(t, e) {
  if (t)
    return typeof t == "function" && b0() ? NQ(t, e) : Fb(t) ? Bf(t) : Array.isArray(t) ? t.map((r) => S7(r, e) || nv.easeOut) : nv[t];
}
function $Q(t, e, r, { delay: n = 0, duration: i = 300, repeat: s = 0, repeatType: o = "loop", ease: a = "easeInOut", times: u } = {}) {
  const h = { [e]: r };
  u && (h.offset = u);
  const d = S7(a, i);
  return Array.isArray(d) && (h.easing = d), t.animate(h, {
    delay: n,
    duration: i,
    easing: Array.isArray(d) ? "linear" : d,
    fill: "both",
    iterations: s + 1,
    direction: o === "reverse" ? "alternate" : "normal"
  });
}
function a_(t, e) {
  t.timeline = e, t.onfinish = null;
}
const BQ = /* @__PURE__ */ qb(() => Object.hasOwnProperty.call(Element.prototype, "animate")), y0 = 10, FQ = 2e4;
function UQ(t) {
  return Bb(t.type) || t.type === "spring" || !E7(t.ease);
}
function jQ(t, e) {
  const r = new jb({
    ...e,
    keyframes: t,
    repeat: 0,
    delay: 0,
    isGenerator: !0
  });
  let n = { done: !1, value: t[0] };
  const i = [];
  let s = 0;
  for (; !n.done && s < FQ; )
    n = r.sample(s), i.push(n.value), s += y0;
  return {
    times: void 0,
    keyframes: i,
    duration: s - y0,
    ease: "linear"
  };
}
const A7 = {
  anticipate: XS,
  backInOut: JS,
  circInOut: QS
};
function qQ(t) {
  return t in A7;
}
class c_ extends m7 {
  constructor(e) {
    super(e);
    const { name: r, motionValue: n, element: i, keyframes: s } = this.options;
    this.resolver = new g7(s, (o, a) => this.onKeyframesResolved(o, a), r, n, i), this.resolver.scheduleResolve();
  }
  initPlayback(e, r) {
    var n;
    let { duration: i = 300, times: s, ease: o, type: a, motionValue: u, name: h, startTime: d } = this.options;
    if (!(!((n = u.owner) === null || n === void 0) && n.current))
      return !1;
    if (typeof o == "string" && b0() && qQ(o) && (o = A7[o]), UQ(this.options)) {
      const { onComplete: x, onUpdate: A, motionValue: I, element: N, ...L } = this.options, F = jQ(e, L);
      e = F.keyframes, e.length === 1 && (e[1] = e[0]), i = F.duration, s = F.times, o = F.ease, a = "keyframes";
    }
    const p = $Q(u.owner.current, h, e, { ...this.options, duration: i, times: s, ease: o });
    return p.startTime = d ?? this.calcStartTime(), this.pendingTimeline ? (a_(p, this.pendingTimeline), this.pendingTimeline = void 0) : p.onfinish = () => {
      const { onComplete: x } = this.options;
      u.set(yp(e, this.options, r)), x && x(), this.cancel(), this.resolveFinishedPromise();
    }, {
      animation: p,
      duration: i,
      times: s,
      type: a,
      ease: o,
      keyframes: e
    };
  }
  get duration() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { duration: r } = e;
    return Io(r);
  }
  get time() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { animation: r } = e;
    return Io(r.currentTime || 0);
  }
  set time(e) {
    const { resolved: r } = this;
    if (!r)
      return;
    const { animation: n } = r;
    n.currentTime = Ws(e);
  }
  get speed() {
    const { resolved: e } = this;
    if (!e)
      return 1;
    const { animation: r } = e;
    return r.playbackRate;
  }
  set speed(e) {
    const { resolved: r } = this;
    if (!r)
      return;
    const { animation: n } = r;
    n.playbackRate = e;
  }
  get state() {
    const { resolved: e } = this;
    if (!e)
      return "idle";
    const { animation: r } = e;
    return r.playState;
  }
  get startTime() {
    const { resolved: e } = this;
    if (!e)
      return null;
    const { animation: r } = e;
    return r.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(e) {
    if (!this._resolved)
      this.pendingTimeline = e;
    else {
      const { resolved: r } = this;
      if (!r)
        return Un;
      const { animation: n } = r;
      a_(n, e);
    }
    return Un;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: r } = e;
    r.playState === "finished" && this.updateFinishedPromise(), r.play();
  }
  pause() {
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: r } = e;
    r.pause();
  }
  stop() {
    if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: r, keyframes: n, duration: i, type: s, ease: o, times: a } = e;
    if (r.playState === "idle" || r.playState === "finished")
      return;
    if (this.time) {
      const { motionValue: h, onUpdate: d, onComplete: p, element: x, ...A } = this.options, I = new jb({
        ...A,
        keyframes: n,
        duration: i,
        type: s,
        ease: o,
        times: a,
        isGenerator: !0
      }), N = Ws(this.time);
      h.setWithVelocity(I.sample(N - y0).value, I.sample(N).value, y0);
    }
    const { onStop: u } = this.options;
    u && u(), this.cancel();
  }
  complete() {
    const { resolved: e } = this;
    e && e.animation.finish();
  }
  cancel() {
    const { resolved: e } = this;
    e && e.animation.cancel();
  }
  static supports(e) {
    const { motionValue: r, name: n, repeatDelay: i, repeatType: s, damping: o, type: a } = e;
    return BQ() && n && DQ.has(n) && r && r.owner && r.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !r.owner.getProps().onUpdate && !i && s !== "mirror" && o !== 0 && a !== "inertia";
  }
}
const zQ = qb(() => window.ScrollTimeline !== void 0);
class HQ {
  constructor(e) {
    this.stop = () => this.runAll("stop"), this.animations = e.filter(Boolean);
  }
  then(e, r) {
    return Promise.all(this.animations).then(e).catch(r);
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(e) {
    return this.animations[0][e];
  }
  setAll(e, r) {
    for (let n = 0; n < this.animations.length; n++)
      this.animations[n][e] = r;
  }
  attachTimeline(e, r) {
    const n = this.animations.map((i) => zQ() && i.attachTimeline ? i.attachTimeline(e) : r(i));
    return () => {
      n.forEach((i, s) => {
        i && i(), this.animations[s].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(e) {
    this.setAll("time", e);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(e) {
    this.setAll("speed", e);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let e = 0;
    for (let r = 0; r < this.animations.length; r++)
      e = Math.max(e, this.animations[r].duration);
    return e;
  }
  runAll(e) {
    this.animations.forEach((r) => r[e]());
  }
  flatten() {
    this.runAll("flatten");
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
function WQ({ when: t, delay: e, delayChildren: r, staggerChildren: n, staggerDirection: i, repeat: s, repeatType: o, repeatDelay: a, from: u, elapsed: h, ...d }) {
  return !!Object.keys(d).length;
}
const zb = (t, e, r, n = {}, i, s) => (o) => {
  const a = Cb(n, t) || {}, u = a.delay || n.delay || 0;
  let { elapsed: h = 0 } = n;
  h = h - Ws(u);
  let d = {
    keyframes: Array.isArray(r) ? r : [null, r],
    ease: "easeOut",
    velocity: e.getVelocity(),
    ...a,
    delay: -h,
    onUpdate: (x) => {
      e.set(x), a.onUpdate && a.onUpdate(x);
    },
    onComplete: () => {
      o(), a.onComplete && a.onComplete();
    },
    name: t,
    motionValue: e,
    element: s ? void 0 : i
  };
  WQ(a) || (d = {
    ...d,
    ...uZ(t, d)
  }), d.duration && (d.duration = Ws(d.duration)), d.repeatDelay && (d.repeatDelay = Ws(d.repeatDelay)), d.from !== void 0 && (d.keyframes[0] = d.from);
  let p = !1;
  if ((d.type === !1 || d.duration === 0 && !d.repeatDelay) && (d.duration = 0, d.delay === 0 && (p = !0)), p && !s && e.get() !== void 0) {
    const x = yp(d.keyframes, a);
    if (x !== void 0)
      return Lr.update(() => {
        d.onUpdate(x), d.onComplete();
      }), new HQ([]);
  }
  return !s && c_.supports(d) ? new c_(d) : new jb(d);
}, KQ = (t) => !!(t && typeof t == "object" && t.mix && t.toValue), VQ = (t) => J1(t) ? t[t.length - 1] || 0 : t;
function Hb(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function Wb(t, e) {
  const r = t.indexOf(e);
  r > -1 && t.splice(r, 1);
}
class Kb {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return Hb(this.subscriptions, e), () => Wb(this.subscriptions, e);
  }
  notify(e, r, n) {
    const i = this.subscriptions.length;
    if (i)
      if (i === 1)
        this.subscriptions[0](e, r, n);
      else
        for (let s = 0; s < i; s++) {
          const o = this.subscriptions[s];
          o && o(e, r, n);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const u_ = 30, GQ = (t) => !isNaN(parseFloat(t));
class YQ {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(e, r = {}) {
    this.version = "11.11.17", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (n, i = !0) => {
      const s = Vs.now();
      this.updatedAt !== s && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(n), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), i && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.hasAnimated = !1, this.setCurrent(e), this.owner = r.owner;
  }
  setCurrent(e) {
    this.current = e, this.updatedAt = Vs.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = GQ(this.current));
  }
  setPrevFrameValue(e = this.current) {
    this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(e) {
    return process.env.NODE_ENV !== "production" && mp(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", e);
  }
  on(e, r) {
    this.events[e] || (this.events[e] = new Kb());
    const n = this.events[e].add(r);
    return e === "change" ? () => {
      n(), Lr.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : n;
  }
  clearListeners() {
    for (const e in this.events)
      this.events[e].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(e, r) {
    this.passiveEffect = e, this.stopPassiveEffect = r;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(e, r = !0) {
    !r || !this.passiveEffect ? this.updateAndNotify(e, r) : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, r, n) {
    this.set(r), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - n;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(e, r = !0) {
    this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, r && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const e = Vs.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > u_)
      return 0;
    const r = Math.min(this.updatedAt - this.prevUpdatedAt, u_);
    return v7(parseFloat(this.current) - parseFloat(this.prevFrameValue), r);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(e) {
    return this.stop(), new Promise((r) => {
      this.hasAnimated = !0, this.animation = e(r), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Tl(t, e) {
  return new YQ(t, e);
}
function JQ(t, e, r) {
  t.hasValue(e) ? t.getValue(e).set(r) : t.addValue(e, Tl(r));
}
function XQ(t, e) {
  const r = bp(t, e);
  let { transitionEnd: n = {}, transition: i = {}, ...s } = r || {};
  s = { ...s, ...n };
  for (const o in s) {
    const a = VQ(s[o]);
    JQ(t, o, a);
  }
}
const Vb = (t) => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), ZQ = "framerAppearId", P7 = "data-" + Vb(ZQ);
function M7(t) {
  return t.props[P7];
}
const Jn = (t) => !!(t && t.getVelocity);
function QQ(t) {
  return !!(Jn(t) && t.add);
}
function iv(t, e) {
  const r = t.getValue("willChange");
  if (QQ(r))
    return r.add(e);
}
function eee({ protectedKeys: t, needsAnimating: e }, r) {
  const n = t.hasOwnProperty(r) && e[r] !== !0;
  return e[r] = !1, n;
}
function I7(t, e, { delay: r = 0, transitionOverride: n, type: i } = {}) {
  var s;
  let { transition: o = t.getDefaultTransition(), transitionEnd: a, ...u } = e;
  n && (o = n);
  const h = [], d = i && t.animationState && t.animationState.getState()[i];
  for (const p in u) {
    const x = t.getValue(p, (s = t.latestValues[p]) !== null && s !== void 0 ? s : null), A = u[p];
    if (A === void 0 || d && eee(d, p))
      continue;
    const I = {
      delay: r,
      ...Cb(o || {}, p)
    };
    let N = !1;
    if (window.MotionHandoffAnimation) {
      const F = M7(t);
      if (F) {
        const $ = window.MotionHandoffAnimation(F, p, Lr);
        $ !== null && (I.startTime = $, N = !0);
      }
    }
    iv(t, p), x.start(zb(p, x, A, t.shouldReduceMotion && _c.has(p) ? { type: !1 } : I, t, N));
    const L = x.animation;
    L && h.push(L);
  }
  return a && Promise.all(h).then(() => {
    Lr.update(() => {
      a && XQ(t, a);
    });
  }), h;
}
function sv(t, e, r = {}) {
  var n;
  const i = bp(t, e, r.type === "exit" ? (n = t.presenceContext) === null || n === void 0 ? void 0 : n.custom : void 0);
  let { transition: s = t.getDefaultTransition() || {} } = i || {};
  r.transitionOverride && (s = r.transitionOverride);
  const o = i ? () => Promise.all(I7(t, i, r)) : () => Promise.resolve(), a = t.variantChildren && t.variantChildren.size ? (h = 0) => {
    const { delayChildren: d = 0, staggerChildren: p, staggerDirection: x } = s;
    return tee(t, e, d + h, p, x, r);
  } : () => Promise.resolve(), { when: u } = s;
  if (u) {
    const [h, d] = u === "beforeChildren" ? [o, a] : [a, o];
    return h().then(() => d());
  } else
    return Promise.all([o(), a(r.delay)]);
}
function tee(t, e, r = 0, n = 0, i = 1, s) {
  const o = [], a = (t.variantChildren.size - 1) * n, u = i === 1 ? (h = 0) => h * n : (h = 0) => a - h * n;
  return Array.from(t.variantChildren).sort(ree).forEach((h, d) => {
    h.notify("AnimationStart", e), o.push(sv(h, e, {
      ...s,
      delay: r + u(d)
    }).then(() => h.notify("AnimationComplete", e)));
  }), Promise.all(o);
}
function ree(t, e) {
  return t.sortNodePosition(e);
}
function nee(t, e, r = {}) {
  t.notify("AnimationStart", e);
  let n;
  if (Array.isArray(e)) {
    const i = e.map((s) => sv(t, s, r));
    n = Promise.all(i);
  } else if (typeof e == "string")
    n = sv(t, e, r);
  else {
    const i = typeof e == "function" ? bp(t, e, r.custom) : e;
    n = Promise.all(I7(t, i, r));
  }
  return n.then(() => {
    t.notify("AnimationComplete", e);
  });
}
const iee = Ib.length;
function C7(t) {
  if (!t)
    return;
  if (!t.isControllingVariants) {
    const r = t.parent ? C7(t.parent) || {} : {};
    return t.props.initial !== void 0 && (r.initial = t.props.initial), r;
  }
  const e = {};
  for (let r = 0; r < iee; r++) {
    const n = Ib[r], i = t.props[n];
    (Ml(i) || i === !1) && (e[n] = i);
  }
  return e;
}
const see = [...Mb].reverse(), oee = Mb.length;
function aee(t) {
  return (e) => Promise.all(e.map(({ animation: r, options: n }) => nee(t, r, n)));
}
function cee(t) {
  let e = aee(t), r = f_(), n = !0;
  const i = (u) => (h, d) => {
    var p;
    const x = bp(t, d, u === "exit" ? (p = t.presenceContext) === null || p === void 0 ? void 0 : p.custom : void 0);
    if (x) {
      const { transition: A, transitionEnd: I, ...N } = x;
      h = { ...h, ...N, ...I };
    }
    return h;
  };
  function s(u) {
    e = u(t);
  }
  function o(u) {
    const { props: h } = t, d = C7(t.parent) || {}, p = [], x = /* @__PURE__ */ new Set();
    let A = {}, I = 1 / 0;
    for (let L = 0; L < oee; L++) {
      const F = see[L], $ = r[F], W = h[F] !== void 0 ? h[F] : d[F], z = Ml(W), V = F === u ? $.isActive : null;
      V === !1 && (I = L);
      let te = W === d[F] && W !== h[F] && z;
      if (te && n && t.manuallyAnimateOnMount && (te = !1), $.protectedKeys = { ...A }, // If it isn't active and hasn't *just* been set as inactive
      !$.isActive && V === null || // If we didn't and don't have any defined prop for this animation type
      !W && !$.prevProp || // Or if the prop doesn't define an animation
      vp(W) || typeof W == "boolean")
        continue;
      const R = uee($.prevProp, W);
      let K = R || // If we're making this variant active, we want to always make it active
      F === u && $.isActive && !te && z || // If we removed a higher-priority variant (i is in reverse order)
      L > I && z, pe = !1;
      const _e = Array.isArray(W) ? W : [W];
      let Y = _e.reduce(i(F), {});
      V === !1 && (Y = {});
      const { prevResolvedValues: S = {} } = $, m = {
        ...S,
        ...Y
      }, f = (w) => {
        K = !0, x.has(w) && (pe = !0, x.delete(w)), $.needsAnimating[w] = !0;
        const _ = t.getValue(w);
        _ && (_.liveStyle = !1);
      };
      for (const w in m) {
        const _ = Y[w], E = S[w];
        if (A.hasOwnProperty(w))
          continue;
        let v = !1;
        J1(_) && J1(E) ? v = !HS(_, E) : v = _ !== E, v ? _ != null ? f(w) : x.add(w) : _ !== void 0 && x.has(w) ? f(w) : $.protectedKeys[w] = !0;
      }
      $.prevProp = W, $.prevResolvedValues = Y, $.isActive && (A = { ...A, ...Y }), n && t.blockInitialAnimation && (K = !1), K && (!(te && R) || pe) && p.push(..._e.map((w) => ({
        animation: w,
        options: { type: F }
      })));
    }
    if (x.size) {
      const L = {};
      x.forEach((F) => {
        const $ = t.getBaseTarget(F), W = t.getValue(F);
        W && (W.liveStyle = !0), L[F] = $ ?? null;
      }), p.push({ animation: L });
    }
    let N = !!p.length;
    return n && (h.initial === !1 || h.initial === h.animate) && !t.manuallyAnimateOnMount && (N = !1), n = !1, N ? e(p) : Promise.resolve();
  }
  function a(u, h) {
    var d;
    if (r[u].isActive === h)
      return Promise.resolve();
    (d = t.variantChildren) === null || d === void 0 || d.forEach((x) => {
      var A;
      return (A = x.animationState) === null || A === void 0 ? void 0 : A.setActive(u, h);
    }), r[u].isActive = h;
    const p = o(u);
    for (const x in r)
      r[x].protectedKeys = {};
    return p;
  }
  return {
    animateChanges: o,
    setActive: a,
    setAnimateFunction: s,
    getState: () => r,
    reset: () => {
      r = f_(), n = !0;
    }
  };
}
function uee(t, e) {
  return typeof e == "string" ? e !== t : Array.isArray(e) ? !HS(e, t) : !1;
}
function za(t = !1) {
  return {
    isActive: t,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function f_() {
  return {
    animate: za(!0),
    whileInView: za(),
    whileHover: za(),
    whileTap: za(),
    whileDrag: za(),
    whileFocus: za(),
    exit: za()
  };
}
class Ma {
  constructor(e) {
    this.isMounted = !1, this.node = e;
  }
  update() {
  }
}
class fee extends Ma {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(e) {
    super(e), e.animationState || (e.animationState = cee(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    vp(e) && (this.unmountControls = e.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(), { animate: r } = this.node.prevProps || {};
    e !== r && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var e;
    this.node.animationState.reset(), (e = this.unmountControls) === null || e === void 0 || e.call(this);
  }
}
let lee = 0;
class hee extends Ma {
  constructor() {
    super(...arguments), this.id = lee++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: e, onExitComplete: r } = this.node.presenceContext, { isPresent: n } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === n)
      return;
    const i = this.node.animationState.setActive("exit", !e);
    r && !e && i.then(() => r(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {
  }
}
const dee = {
  animation: {
    Feature: fee
  },
  exit: {
    Feature: hee
  }
}, T7 = (t) => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1;
function wp(t, e = "page") {
  return {
    point: {
      x: t[`${e}X`],
      y: t[`${e}Y`]
    }
  };
}
const pee = (t) => (e) => T7(e) && t(e, wp(e));
function Ao(t, e, r, n = { passive: !0 }) {
  return t.addEventListener(e, r, n), () => t.removeEventListener(e, r);
}
function To(t, e, r, n) {
  return Ao(t, e, pee(r), n);
}
const l_ = (t, e) => Math.abs(t - e);
function gee(t, e) {
  const r = l_(t.x, e.x), n = l_(t.y, e.y);
  return Math.sqrt(r ** 2 + n ** 2);
}
class R7 {
  constructor(e, r, { transformPagePoint: n, contextWindow: i, dragSnapToOrigin: s = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const p = Bm(this.lastMoveEventInfo, this.history), x = this.startEvent !== null, A = gee(p.offset, { x: 0, y: 0 }) >= 3;
      if (!x && !A)
        return;
      const { point: I } = p, { timestamp: N } = $n;
      this.history.push({ ...I, timestamp: N });
      const { onStart: L, onMove: F } = this.handlers;
      x || (L && L(this.lastMoveEvent, p), this.startEvent = this.lastMoveEvent), F && F(this.lastMoveEvent, p);
    }, this.handlePointerMove = (p, x) => {
      this.lastMoveEvent = p, this.lastMoveEventInfo = $m(x, this.transformPagePoint), Lr.update(this.updatePoint, !0);
    }, this.handlePointerUp = (p, x) => {
      this.end();
      const { onEnd: A, onSessionEnd: I, resumeAnimation: N } = this.handlers;
      if (this.dragSnapToOrigin && N && N(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const L = Bm(p.type === "pointercancel" ? this.lastMoveEventInfo : $m(x, this.transformPagePoint), this.history);
      this.startEvent && A && A(p, L), I && I(p, L);
    }, !T7(e))
      return;
    this.dragSnapToOrigin = s, this.handlers = r, this.transformPagePoint = n, this.contextWindow = i || window;
    const o = wp(e), a = $m(o, this.transformPagePoint), { point: u } = a, { timestamp: h } = $n;
    this.history = [{ ...u, timestamp: h }];
    const { onSessionStart: d } = r;
    d && d(e, Bm(a, this.history)), this.removeListeners = Co(To(this.contextWindow, "pointermove", this.handlePointerMove), To(this.contextWindow, "pointerup", this.handlePointerUp), To(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), ba(this.updatePoint);
  }
}
function $m(t, e) {
  return e ? { point: e(t.point) } : t;
}
function h_(t, e) {
  return { x: t.x - e.x, y: t.y - e.y };
}
function Bm({ point: t }, e) {
  return {
    point: t,
    delta: h_(t, D7(e)),
    offset: h_(t, mee(e)),
    velocity: vee(e, 0.1)
  };
}
function mee(t) {
  return t[0];
}
function D7(t) {
  return t[t.length - 1];
}
function vee(t, e) {
  if (t.length < 2)
    return { x: 0, y: 0 };
  let r = t.length - 1, n = null;
  const i = D7(t);
  for (; r >= 0 && (n = t[r], !(i.timestamp - n.timestamp > Ws(e))); )
    r--;
  if (!n)
    return { x: 0, y: 0 };
  const s = Io(i.timestamp - n.timestamp);
  if (s === 0)
    return { x: 0, y: 0 };
  const o = {
    x: (i.x - n.x) / s,
    y: (i.y - n.y) / s
  };
  return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o;
}
function O7(t) {
  let e = null;
  return () => {
    const r = () => {
      e = null;
    };
    return e === null ? (e = t, r) : !1;
  };
}
const d_ = O7("dragHorizontal"), p_ = O7("dragVertical");
function N7(t) {
  let e = !1;
  if (t === "y")
    e = p_();
  else if (t === "x")
    e = d_();
  else {
    const r = d_(), n = p_();
    r && n ? e = () => {
      r(), n();
    } : (r && r(), n && n());
  }
  return e;
}
function L7() {
  const t = N7(!0);
  return t ? (t(), !1) : !0;
}
function Qc(t) {
  return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current");
}
const k7 = 1e-4, bee = 1 - k7, yee = 1 + k7, $7 = 0.01, wee = 0 - $7, xee = 0 + $7;
function Li(t) {
  return t.max - t.min;
}
function _ee(t, e, r) {
  return Math.abs(t - e) <= r;
}
function g_(t, e, r, n = 0.5) {
  t.origin = n, t.originPoint = Qr(e.min, e.max, t.origin), t.scale = Li(r) / Li(e), t.translate = Qr(r.min, r.max, t.origin) - t.originPoint, (t.scale >= bee && t.scale <= yee || isNaN(t.scale)) && (t.scale = 1), (t.translate >= wee && t.translate <= xee || isNaN(t.translate)) && (t.translate = 0);
}
function Gf(t, e, r, n) {
  g_(t.x, e.x, r.x, n ? n.originX : void 0), g_(t.y, e.y, r.y, n ? n.originY : void 0);
}
function m_(t, e, r) {
  t.min = r.min + e.min, t.max = t.min + Li(e);
}
function Eee(t, e, r) {
  m_(t.x, e.x, r.x), m_(t.y, e.y, r.y);
}
function v_(t, e, r) {
  t.min = e.min - r.min, t.max = t.min + Li(e);
}
function Yf(t, e, r) {
  v_(t.x, e.x, r.x), v_(t.y, e.y, r.y);
}
function See(t, { min: e, max: r }, n) {
  return e !== void 0 && t < e ? t = n ? Qr(e, t, n.min) : Math.max(t, e) : r !== void 0 && t > r && (t = n ? Qr(r, t, n.max) : Math.min(t, r)), t;
}
function b_(t, e, r) {
  return {
    min: e !== void 0 ? t.min + e : void 0,
    max: r !== void 0 ? t.max + r - (t.max - t.min) : void 0
  };
}
function Aee(t, { top: e, left: r, bottom: n, right: i }) {
  return {
    x: b_(t.x, r, i),
    y: b_(t.y, e, n)
  };
}
function y_(t, e) {
  let r = e.min - t.min, n = e.max - t.max;
  return e.max - e.min < t.max - t.min && ([r, n] = [n, r]), { min: r, max: n };
}
function Pee(t, e) {
  return {
    x: y_(t.x, e.x),
    y: y_(t.y, e.y)
  };
}
function Mee(t, e) {
  let r = 0.5;
  const n = Li(t), i = Li(e);
  return i > n ? r = Pu(e.min, e.max - n, t.min) : n > i && (r = Pu(t.min, t.max - i, e.min)), ya(0, 1, r);
}
function Iee(t, e) {
  const r = {};
  return e.min !== void 0 && (r.min = e.min - t.min), e.max !== void 0 && (r.max = e.max - t.min), r;
}
const ov = 0.35;
function Cee(t = ov) {
  return t === !1 ? t = 0 : t === !0 && (t = ov), {
    x: w_(t, "left", "right"),
    y: w_(t, "top", "bottom")
  };
}
function w_(t, e, r) {
  return {
    min: x_(t, e),
    max: x_(t, r)
  };
}
function x_(t, e) {
  return typeof t == "number" ? t : t[e] || 0;
}
const __ = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), eu = () => ({
  x: __(),
  y: __()
}), E_ = () => ({ min: 0, max: 0 }), ln = () => ({
  x: E_(),
  y: E_()
});
function Xi(t) {
  return [t("x"), t("y")];
}
function B7({ top: t, left: e, right: r, bottom: n }) {
  return {
    x: { min: e, max: r },
    y: { min: t, max: n }
  };
}
function Tee({ x: t, y: e }) {
  return { top: e.min, right: t.max, bottom: e.max, left: t.min };
}
function Ree(t, e) {
  if (!e)
    return t;
  const r = e({ x: t.left, y: t.top }), n = e({ x: t.right, y: t.bottom });
  return {
    top: r.y,
    left: r.x,
    bottom: n.y,
    right: n.x
  };
}
function Fm(t) {
  return t === void 0 || t === 1;
}
function av({ scale: t, scaleX: e, scaleY: r }) {
  return !Fm(t) || !Fm(e) || !Fm(r);
}
function Wa(t) {
  return av(t) || F7(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY;
}
function F7(t) {
  return S_(t.x) || S_(t.y);
}
function S_(t) {
  return t && t !== "0%";
}
function w0(t, e, r) {
  const n = t - r, i = e * n;
  return r + i;
}
function A_(t, e, r, n, i) {
  return i !== void 0 && (t = w0(t, i, n)), w0(t, r, n) + e;
}
function cv(t, e = 0, r = 1, n, i) {
  t.min = A_(t.min, e, r, n, i), t.max = A_(t.max, e, r, n, i);
}
function U7(t, { x: e, y: r }) {
  cv(t.x, e.translate, e.scale, e.originPoint), cv(t.y, r.translate, r.scale, r.originPoint);
}
const P_ = 0.999999999999, M_ = 1.0000000000001;
function Dee(t, e, r, n = !1) {
  const i = r.length;
  if (!i)
    return;
  e.x = e.y = 1;
  let s, o;
  for (let a = 0; a < i; a++) {
    s = r[a], o = s.projectionDelta;
    const { visualElement: u } = s.options;
    u && u.props.style && u.props.style.display === "contents" || (n && s.options.layoutScroll && s.scroll && s !== s.root && ru(t, {
      x: -s.scroll.offset.x,
      y: -s.scroll.offset.y
    }), o && (e.x *= o.x.scale, e.y *= o.y.scale, U7(t, o)), n && Wa(s.latestValues) && ru(t, s.latestValues));
  }
  e.x < M_ && e.x > P_ && (e.x = 1), e.y < M_ && e.y > P_ && (e.y = 1);
}
function tu(t, e) {
  t.min = t.min + e, t.max = t.max + e;
}
function I_(t, e, r, n, i = 0.5) {
  const s = Qr(t.min, t.max, i);
  cv(t, e, r, s, n);
}
function ru(t, e) {
  I_(t.x, e.x, e.scaleX, e.scale, e.originX), I_(t.y, e.y, e.scaleY, e.scale, e.originY);
}
function j7(t, e) {
  return B7(Ree(t.getBoundingClientRect(), e));
}
function Oee(t, e, r) {
  const n = j7(t, r), { scroll: i } = e;
  return i && (tu(n.x, i.offset.x), tu(n.y, i.offset.y)), n;
}
const q7 = ({ current: t }) => t ? t.ownerDocument.defaultView : null, Nee = /* @__PURE__ */ new WeakMap();
class Lee {
  constructor(e) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = ln(), this.visualElement = e;
  }
  start(e, { snapToCursor: r = !1 } = {}) {
    const { presenceContext: n } = this.visualElement;
    if (n && n.isPresent === !1)
      return;
    const i = (d) => {
      const { dragSnapToOrigin: p } = this.getProps();
      p ? this.pauseAnimation() : this.stopAnimation(), r && this.snapToCursor(wp(d, "page").point);
    }, s = (d, p) => {
      const { drag: x, dragPropagation: A, onDragStart: I } = this.getProps();
      if (x && !A && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = N7(x), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Xi((L) => {
        let F = this.getAxisMotionValue(L).get() || 0;
        if (Ks.test(F)) {
          const { projection: $ } = this.visualElement;
          if ($ && $.layout) {
            const W = $.layout.layoutBox[L];
            W && (F = Li(W) * (parseFloat(F) / 100));
          }
        }
        this.originPoint[L] = F;
      }), I && Lr.postRender(() => I(d, p)), iv(this.visualElement, "transform");
      const { animationState: N } = this.visualElement;
      N && N.setActive("whileDrag", !0);
    }, o = (d, p) => {
      const { dragPropagation: x, dragDirectionLock: A, onDirectionLock: I, onDrag: N } = this.getProps();
      if (!x && !this.openGlobalLock)
        return;
      const { offset: L } = p;
      if (A && this.currentDirection === null) {
        this.currentDirection = kee(L), this.currentDirection !== null && I && I(this.currentDirection);
        return;
      }
      this.updateAxis("x", p.point, L), this.updateAxis("y", p.point, L), this.visualElement.render(), N && N(d, p);
    }, a = (d, p) => this.stop(d, p), u = () => Xi((d) => {
      var p;
      return this.getAnimationState(d) === "paused" && ((p = this.getAxisMotionValue(d).animation) === null || p === void 0 ? void 0 : p.play());
    }), { dragSnapToOrigin: h } = this.getProps();
    this.panSession = new R7(e, {
      onSessionStart: i,
      onStart: s,
      onMove: o,
      onSessionEnd: a,
      resumeAnimation: u
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: h,
      contextWindow: q7(this.visualElement)
    });
  }
  stop(e, r) {
    const n = this.isDragging;
    if (this.cancel(), !n)
      return;
    const { velocity: i } = r;
    this.startAnimation(i);
    const { onDragEnd: s } = this.getProps();
    s && Lr.postRender(() => s(e, r));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: r } = this.visualElement;
    e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: n } = this.getProps();
    !n && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), r && r.setActive("whileDrag", !1);
  }
  updateAxis(e, r, n) {
    const { drag: i } = this.getProps();
    if (!n || !md(e, i, this.currentDirection))
      return;
    const s = this.getAxisMotionValue(e);
    let o = this.originPoint[e] + n[e];
    this.constraints && this.constraints[e] && (o = See(o, this.constraints[e], this.elastic[e])), s.set(o);
  }
  resolveConstraints() {
    var e;
    const { dragConstraints: r, dragElastic: n } = this.getProps(), i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout, s = this.constraints;
    r && Qc(r) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : r && i ? this.constraints = Aee(i.layoutBox, r) : this.constraints = !1, this.elastic = Cee(n), s !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && Xi((o) => {
      this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = Iee(i.layoutBox[o], this.constraints[o]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: r } = this.getProps();
    if (!e || !Qc(e))
      return !1;
    const n = e.current;
    Bo(n !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: i } = this.visualElement;
    if (!i || !i.layout)
      return !1;
    const s = Oee(n, i.root, this.visualElement.getTransformPagePoint());
    let o = Pee(i.layout.layoutBox, s);
    if (r) {
      const a = r(Tee(o));
      this.hasMutatedConstraints = !!a, a && (o = B7(a));
    }
    return o;
  }
  startAnimation(e) {
    const { drag: r, dragMomentum: n, dragElastic: i, dragTransition: s, dragSnapToOrigin: o, onDragTransitionEnd: a } = this.getProps(), u = this.constraints || {}, h = Xi((d) => {
      if (!md(d, r, this.currentDirection))
        return;
      let p = u && u[d] || {};
      o && (p = { min: 0, max: 0 });
      const x = i ? 200 : 1e6, A = i ? 40 : 1e7, I = {
        type: "inertia",
        velocity: n ? e[d] : 0,
        bounceStiffness: x,
        bounceDamping: A,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...s,
        ...p
      };
      return this.startAxisValueAnimation(d, I);
    });
    return Promise.all(h).then(a);
  }
  startAxisValueAnimation(e, r) {
    const n = this.getAxisMotionValue(e);
    return iv(this.visualElement, e), n.start(zb(e, n, 0, r, this.visualElement, !1));
  }
  stopAnimation() {
    Xi((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    Xi((e) => {
      var r;
      return (r = this.getAxisMotionValue(e).animation) === null || r === void 0 ? void 0 : r.pause();
    });
  }
  getAnimationState(e) {
    var r;
    return (r = this.getAxisMotionValue(e).animation) === null || r === void 0 ? void 0 : r.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(e) {
    const r = `_drag${e.toUpperCase()}`, n = this.visualElement.getProps(), i = n[r];
    return i || this.visualElement.getValue(e, (n.initial ? n.initial[e] : void 0) || 0);
  }
  snapToCursor(e) {
    Xi((r) => {
      const { drag: n } = this.getProps();
      if (!md(r, n, this.currentDirection))
        return;
      const { projection: i } = this.visualElement, s = this.getAxisMotionValue(r);
      if (i && i.layout) {
        const { min: o, max: a } = i.layout.layoutBox[r];
        s.set(e[r] - Qr(o, a, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: e, dragConstraints: r } = this.getProps(), { projection: n } = this.visualElement;
    if (!Qc(r) || !n || !this.constraints)
      return;
    this.stopAnimation();
    const i = { x: 0, y: 0 };
    Xi((o) => {
      const a = this.getAxisMotionValue(o);
      if (a && this.constraints !== !1) {
        const u = a.get();
        i[o] = Mee({ min: u, max: u }, this.constraints[o]);
      }
    });
    const { transformTemplate: s } = this.visualElement.getProps();
    this.visualElement.current.style.transform = s ? s({}, "") : "none", n.root && n.root.updateScroll(), n.updateLayout(), this.resolveConstraints(), Xi((o) => {
      if (!md(o, e, null))
        return;
      const a = this.getAxisMotionValue(o), { min: u, max: h } = this.constraints[o];
      a.set(Qr(u, h, i[o]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    Nee.set(this.visualElement, this);
    const e = this.visualElement.current, r = To(e, "pointerdown", (u) => {
      const { drag: h, dragListener: d = !0 } = this.getProps();
      h && d && this.start(u);
    }), n = () => {
      const { dragConstraints: u } = this.getProps();
      Qc(u) && u.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: i } = this.visualElement, s = i.addEventListener("measure", n);
    i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), Lr.read(n);
    const o = Ao(window, "resize", () => this.scalePositionWithinConstraints()), a = i.addEventListener("didUpdate", ({ delta: u, hasLayoutChanged: h }) => {
      this.isDragging && h && (Xi((d) => {
        const p = this.getAxisMotionValue(d);
        p && (this.originPoint[d] += u[d].translate, p.set(p.get() + u[d].translate));
      }), this.visualElement.render());
    });
    return () => {
      o(), r(), s(), a && a();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(), { drag: r = !1, dragDirectionLock: n = !1, dragPropagation: i = !1, dragConstraints: s = !1, dragElastic: o = ov, dragMomentum: a = !0 } = e;
    return {
      ...e,
      drag: r,
      dragDirectionLock: n,
      dragPropagation: i,
      dragConstraints: s,
      dragElastic: o,
      dragMomentum: a
    };
  }
}
function md(t, e, r) {
  return (e === !0 || e === t) && (r === null || r === t);
}
function kee(t, e = 10) {
  let r = null;
  return Math.abs(t.y) > e ? r = "y" : Math.abs(t.x) > e && (r = "x"), r;
}
class $ee extends Ma {
  constructor(e) {
    super(e), this.removeGroupControls = Un, this.removeListeners = Un, this.controls = new Lee(e);
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Un;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const C_ = (t) => (e, r) => {
  t && Lr.postRender(() => t(e, r));
};
class Bee extends Ma {
  constructor() {
    super(...arguments), this.removePointerDownListener = Un;
  }
  onPointerDown(e) {
    this.session = new R7(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: q7(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: e, onPanStart: r, onPan: n, onPanEnd: i } = this.node.getProps();
    return {
      onSessionStart: C_(e),
      onStart: C_(r),
      onMove: n,
      onEnd: (s, o) => {
        delete this.session, i && Lr.postRender(() => i(s, o));
      }
    };
  }
  mount() {
    this.removePointerDownListener = To(this.node.current, "pointerdown", (e) => this.onPointerDown(e));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const xp = hc(null);
function Fee() {
  const t = Fn(xp);
  if (t === null)
    return [!0, null];
  const { isPresent: e, onExitComplete: r, register: n } = t, i = mv();
  si(() => n(i), []);
  const s = vv(() => r && r(i), [i, r]);
  return !e && r ? [!1, s] : [!0];
}
const Gb = hc({}), z7 = hc({}), Fd = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function T_(t, e) {
  return e.max === e.min ? 0 : t / (e.max - e.min) * 100;
}
const Rf = {
  correct: (t, e) => {
    if (!e.target)
      return t;
    if (typeof t == "string")
      if (Vt.test(t))
        t = parseFloat(t);
      else
        return t;
    const r = T_(t, e.target.x), n = T_(t, e.target.y);
    return `${r}% ${n}%`;
  }
}, Uee = {
  correct: (t, { treeScale: e, projectionDelta: r }) => {
    const n = t, i = wa.parse(t);
    if (i.length > 5)
      return n;
    const s = wa.createTransformer(t), o = typeof i[0] != "number" ? 1 : 0, a = r.x.scale * e.x, u = r.y.scale * e.y;
    i[0 + o] /= a, i[1 + o] /= u;
    const h = Qr(a, u, 0.5);
    return typeof i[2 + o] == "number" && (i[2 + o] /= h), typeof i[3 + o] == "number" && (i[3 + o] /= h), s(i);
  }
}, x0 = {};
function jee(t) {
  Object.assign(x0, t);
}
const { schedule: Yb } = WS(queueMicrotask, !1);
class qee extends xR {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: e, layoutGroup: r, switchLayoutGroup: n, layoutId: i } = this.props, { projection: s } = e;
    jee(zee), s && (r.group && r.group.add(s), n && n.register && i && n.register(s), s.root.didUpdate(), s.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), s.setOptions({
      ...s.options,
      onExitComplete: () => this.safeToRemove()
    })), Fd.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(e) {
    const { layoutDependency: r, visualElement: n, drag: i, isPresent: s } = this.props, o = n.projection;
    return o && (o.isPresent = s, i || e.layoutDependency !== r || r === void 0 ? o.willUpdate() : this.safeToRemove(), e.isPresent !== s && (s ? o.promote() : o.relegate() || Lr.postRender(() => {
      const a = o.getStack();
      (!a || !a.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e && (e.root.didUpdate(), Yb.postRender(() => {
      !e.currentAnimation && e.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: e, layoutGroup: r, switchLayoutGroup: n } = this.props, { projection: i } = e;
    i && (i.scheduleCheckAfterUnmount(), r && r.group && r.group.remove(i), n && n.deregister && n.deregister(i));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function H7(t) {
  const [e, r] = Fee(), n = Fn(Gb);
  return ve.jsx(qee, { ...t, layoutGroup: n, switchLayoutGroup: Fn(z7), isPresent: e, safeToRemove: r });
}
const zee = {
  borderRadius: {
    ...Rf,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: Rf,
  borderTopRightRadius: Rf,
  borderBottomLeftRadius: Rf,
  borderBottomRightRadius: Rf,
  boxShadow: Uee
}, W7 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], Hee = W7.length, R_ = (t) => typeof t == "string" ? parseFloat(t) : t, D_ = (t) => typeof t == "number" || Vt.test(t);
function Wee(t, e, r, n, i, s) {
  i ? (t.opacity = Qr(
    0,
    // TODO Reinstate this if only child
    r.opacity !== void 0 ? r.opacity : 1,
    Kee(n)
  ), t.opacityExit = Qr(e.opacity !== void 0 ? e.opacity : 1, 0, Vee(n))) : s && (t.opacity = Qr(e.opacity !== void 0 ? e.opacity : 1, r.opacity !== void 0 ? r.opacity : 1, n));
  for (let o = 0; o < Hee; o++) {
    const a = `border${W7[o]}Radius`;
    let u = O_(e, a), h = O_(r, a);
    if (u === void 0 && h === void 0)
      continue;
    u || (u = 0), h || (h = 0), u === 0 || h === 0 || D_(u) === D_(h) ? (t[a] = Math.max(Qr(R_(u), R_(h), n), 0), (Ks.test(h) || Ks.test(u)) && (t[a] += "%")) : t[a] = h;
  }
  (e.rotate || r.rotate) && (t.rotate = Qr(e.rotate || 0, r.rotate || 0, n));
}
function O_(t, e) {
  return t[e] !== void 0 ? t[e] : t.borderRadius;
}
const Kee = /* @__PURE__ */ K7(0, 0.5, ZS), Vee = /* @__PURE__ */ K7(0.5, 0.95, Un);
function K7(t, e, r) {
  return (n) => n < t ? 0 : n > e ? 1 : r(Pu(t, e, n));
}
function N_(t, e) {
  t.min = e.min, t.max = e.max;
}
function Yi(t, e) {
  N_(t.x, e.x), N_(t.y, e.y);
}
function L_(t, e) {
  t.translate = e.translate, t.scale = e.scale, t.originPoint = e.originPoint, t.origin = e.origin;
}
function k_(t, e, r, n, i) {
  return t -= e, t = w0(t, 1 / r, n), i !== void 0 && (t = w0(t, 1 / i, n)), t;
}
function Gee(t, e = 0, r = 1, n = 0.5, i, s = t, o = t) {
  if (Ks.test(e) && (e = parseFloat(e), e = Qr(o.min, o.max, e / 100) - o.min), typeof e != "number")
    return;
  let a = Qr(s.min, s.max, n);
  t === s && (a -= e), t.min = k_(t.min, e, r, a, i), t.max = k_(t.max, e, r, a, i);
}
function $_(t, e, [r, n, i], s, o) {
  Gee(t, e[r], e[n], e[i], e.scale, s, o);
}
const Yee = ["x", "scaleX", "originX"], Jee = ["y", "scaleY", "originY"];
function B_(t, e, r, n) {
  $_(t.x, e, Yee, r ? r.x : void 0, n ? n.x : void 0), $_(t.y, e, Jee, r ? r.y : void 0, n ? n.y : void 0);
}
function F_(t) {
  return t.translate === 0 && t.scale === 1;
}
function V7(t) {
  return F_(t.x) && F_(t.y);
}
function U_(t, e) {
  return t.min === e.min && t.max === e.max;
}
function Xee(t, e) {
  return U_(t.x, e.x) && U_(t.y, e.y);
}
function j_(t, e) {
  return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max);
}
function G7(t, e) {
  return j_(t.x, e.x) && j_(t.y, e.y);
}
function q_(t) {
  return Li(t.x) / Li(t.y);
}
function z_(t, e) {
  return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint;
}
class Zee {
  constructor() {
    this.members = [];
  }
  add(e) {
    Hb(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (Wb(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
      const r = this.members[this.members.length - 1];
      r && this.promote(r);
    }
  }
  relegate(e) {
    const r = this.members.findIndex((i) => e === i);
    if (r === 0)
      return !1;
    let n;
    for (let i = r; i >= 0; i--) {
      const s = this.members[i];
      if (s.isPresent !== !1) {
        n = s;
        break;
      }
    }
    return n ? (this.promote(n), !0) : !1;
  }
  promote(e, r) {
    const n = this.lead;
    if (e !== n && (this.prevLead = n, this.lead = e, e.show(), n)) {
      n.instance && n.scheduleRender(), e.scheduleRender(), e.resumeFrom = n, r && (e.resumeFrom.preserveOpacity = !0), n.snapshot && (e.snapshot = n.snapshot, e.snapshot.latestValues = n.animationValues || n.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: i } = e.options;
      i === !1 && n.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: r, resumingFrom: n } = e;
      r.onExitComplete && r.onExitComplete(), n && n.options.onExitComplete && n.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function Qee(t, e, r) {
  let n = "";
  const i = t.x.translate / e.x, s = t.y.translate / e.y, o = (r == null ? void 0 : r.z) || 0;
  if ((i || s || o) && (n = `translate3d(${i}px, ${s}px, ${o}px) `), (e.x !== 1 || e.y !== 1) && (n += `scale(${1 / e.x}, ${1 / e.y}) `), r) {
    const { transformPerspective: h, rotate: d, rotateX: p, rotateY: x, skewX: A, skewY: I } = r;
    h && (n = `perspective(${h}px) ${n}`), d && (n += `rotate(${d}deg) `), p && (n += `rotateX(${p}deg) `), x && (n += `rotateY(${x}deg) `), A && (n += `skewX(${A}deg) `), I && (n += `skewY(${I}deg) `);
  }
  const a = t.x.scale * e.x, u = t.y.scale * e.y;
  return (a !== 1 || u !== 1) && (n += `scale(${a}, ${u})`), n || "none";
}
const ete = (t, e) => t.depth - e.depth;
class tte {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(e) {
    Hb(this.children, e), this.isDirty = !0;
  }
  remove(e) {
    Wb(this.children, e), this.isDirty = !0;
  }
  forEach(e) {
    this.isDirty && this.children.sort(ete), this.isDirty = !1, this.children.forEach(e);
  }
}
function Ud(t) {
  const e = Jn(t) ? t.get() : t;
  return KQ(e) ? e.toValue() : e;
}
function rte(t, e) {
  const r = Vs.now(), n = ({ timestamp: i }) => {
    const s = i - r;
    s >= e && (ba(n), t(s - e));
  };
  return Lr.read(n, !0), () => ba(n);
}
function nte(t) {
  return t instanceof SVGElement && t.tagName !== "svg";
}
function ite(t, e, r) {
  const n = Jn(t) ? t : Tl(t);
  return n.start(zb("", n, e, r)), n.animation;
}
const Ka = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
}, Ff = typeof window < "u" && window.MotionDebug !== void 0, Um = ["", "X", "Y", "Z"], ste = { visibility: "hidden" }, H_ = 1e3;
let ote = 0;
function jm(t, e, r, n) {
  const { latestValues: i } = e;
  i[t] && (r[t] = i[t], e.setStaticValue(t, 0), n && (n[t] = 0));
}
function Y7(t) {
  if (t.hasCheckedOptimisedAppear = !0, t.root === t)
    return;
  const { visualElement: e } = t.options;
  if (!e)
    return;
  const r = M7(e);
  if (window.MotionHasOptimisedAnimation(r, "transform")) {
    const { layout: i, layoutId: s } = t.options;
    window.MotionCancelOptimisedAnimation(r, "transform", Lr, !(i || s));
  }
  const { parent: n } = t;
  n && !n.hasCheckedOptimisedAppear && Y7(n);
}
function J7({ attachResizeListener: t, defaultParent: e, measureScroll: r, checkIsScrollRoot: n, resetTransform: i }) {
  return class {
    constructor(o = {}, a = e == null ? void 0 : e()) {
      this.id = ote++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, Ff && (Ka.totalNodes = Ka.resolvedTargetDeltas = Ka.recalculatedProjection = 0), this.nodes.forEach(ute), this.nodes.forEach(pte), this.nodes.forEach(gte), this.nodes.forEach(fte), Ff && window.MotionDebug.record(Ka);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = o, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
      for (let u = 0; u < this.path.length; u++)
        this.path[u].shouldResetTransform = !0;
      this.root === this && (this.nodes = new tte());
    }
    addEventListener(o, a) {
      return this.eventHandlers.has(o) || this.eventHandlers.set(o, new Kb()), this.eventHandlers.get(o).add(a);
    }
    notifyListeners(o, ...a) {
      const u = this.eventHandlers.get(o);
      u && u.notify(...a);
    }
    hasListeners(o) {
      return this.eventHandlers.has(o);
    }
    /**
     * Lifecycles
     */
    mount(o, a = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = nte(o), this.instance = o;
      const { layoutId: u, layout: h, visualElement: d } = this.options;
      if (d && !d.current && d.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (h || u) && (this.isLayoutDirty = !0), t) {
        let p;
        const x = () => this.root.updateBlockedByResize = !1;
        t(o, () => {
          this.root.updateBlockedByResize = !0, p && p(), p = rte(x, 250), Fd.hasAnimatedSinceResize && (Fd.hasAnimatedSinceResize = !1, this.nodes.forEach(K_));
        });
      }
      u && this.root.registerSharedNode(u, this), this.options.animate !== !1 && d && (u || h) && this.addEventListener("didUpdate", ({ delta: p, hasLayoutChanged: x, hasRelativeTargetChanged: A, layout: I }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const N = this.options.transition || d.getDefaultTransition() || wte, { onLayoutAnimationStart: L, onLayoutAnimationComplete: F } = d.getProps(), $ = !this.targetLayout || !G7(this.targetLayout, I) || A, W = !x && A;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || W || x && ($ || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(p, W);
          const z = {
            ...Cb(N, "layout"),
            onPlay: L,
            onComplete: F
          };
          (d.shouldReduceMotion || this.options.layoutRoot) && (z.delay = 0, z.type = !1), this.startAnimation(z);
        } else
          x || K_(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = I;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const o = this.getStack();
      o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, ba(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(mte), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: o } = this.options;
      return o && o.getProps().transformTemplate;
    }
    willUpdate(o = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && Y7(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let d = 0; d < this.path.length; d++) {
        const p = this.path[d];
        p.shouldResetTransform = !0, p.updateScroll("snapshot"), p.options.layoutRoot && p.willUpdate(!1);
      }
      const { layoutId: a, layout: u } = this.options;
      if (a === void 0 && !u)
        return;
      const h = this.getTransformTemplate();
      this.prevTransformTemplateValue = h ? h(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(W_);
        return;
      }
      this.isUpdating || this.nodes.forEach(hte), this.isUpdating = !1, this.nodes.forEach(dte), this.nodes.forEach(ate), this.nodes.forEach(cte), this.clearAllSnapshots();
      const a = Vs.now();
      $n.delta = ya(0, 1e3 / 60, a - $n.timestamp), $n.timestamp = a, $n.isProcessing = !0, Dm.update.process($n), Dm.preRender.process($n), Dm.render.process($n), $n.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, Yb.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(lte), this.sharedNodes.forEach(vte);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Lr.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      Lr.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let u = 0; u < this.path.length; u++)
          this.path[u].updateScroll();
      const o = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = ln(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0);
    }
    updateScroll(o = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a) {
        const u = n(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: o,
          isRoot: u,
          offset: r(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : u
        };
      }
    }
    resetTransform() {
      if (!i)
        return;
      const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !V7(this.projectionDelta), u = this.getTransformTemplate(), h = u ? u(this.latestValues, "") : void 0, d = h !== this.prevTransformTemplateValue;
      o && (a || Wa(this.latestValues) || d) && (i(this.instance, h), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(o = !0) {
      const a = this.measurePageBox();
      let u = this.removeElementScroll(a);
      return o && (u = this.removeTransform(u)), xte(u), {
        animationId: this.root.animationId,
        measuredBox: a,
        layoutBox: u,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var o;
      const { visualElement: a } = this.options;
      if (!a)
        return ln();
      const u = a.measureViewportBox();
      if (!(((o = this.scroll) === null || o === void 0 ? void 0 : o.wasRoot) || this.path.some(_te))) {
        const { scroll: d } = this.root;
        d && (tu(u.x, d.offset.x), tu(u.y, d.offset.y));
      }
      return u;
    }
    removeElementScroll(o) {
      var a;
      const u = ln();
      if (Yi(u, o), !((a = this.scroll) === null || a === void 0) && a.wasRoot)
        return u;
      for (let h = 0; h < this.path.length; h++) {
        const d = this.path[h], { scroll: p, options: x } = d;
        d !== this.root && p && x.layoutScroll && (p.wasRoot && Yi(u, o), tu(u.x, p.offset.x), tu(u.y, p.offset.y));
      }
      return u;
    }
    applyTransform(o, a = !1) {
      const u = ln();
      Yi(u, o);
      for (let h = 0; h < this.path.length; h++) {
        const d = this.path[h];
        !a && d.options.layoutScroll && d.scroll && d !== d.root && ru(u, {
          x: -d.scroll.offset.x,
          y: -d.scroll.offset.y
        }), Wa(d.latestValues) && ru(u, d.latestValues);
      }
      return Wa(this.latestValues) && ru(u, this.latestValues), u;
    }
    removeTransform(o) {
      const a = ln();
      Yi(a, o);
      for (let u = 0; u < this.path.length; u++) {
        const h = this.path[u];
        if (!h.instance || !Wa(h.latestValues))
          continue;
        av(h.latestValues) && h.updateSnapshot();
        const d = ln(), p = h.measurePageBox();
        Yi(d, p), B_(a, h.latestValues, h.snapshot ? h.snapshot.layoutBox : void 0, d);
      }
      return Wa(this.latestValues) && B_(a, this.latestValues), a;
    }
    setTargetDelta(o) {
      this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(o) {
      this.options = {
        ...this.options,
        ...o,
        crossfade: o.crossfade !== void 0 ? o.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== $n.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(o = !1) {
      var a;
      const u = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = u.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = u.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = u.isSharedProjectionDirty);
      const h = !!this.resumingFrom || this !== u;
      if (!(o || h && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: p, layoutId: x } = this.options;
      if (!(!this.layout || !(p || x))) {
        if (this.resolvedRelativeTargetAt = $n.timestamp, !this.targetDelta && !this.relativeTarget) {
          const A = this.getClosestProjectingParent();
          A && A.layout && this.animationProgress !== 1 ? (this.relativeParent = A, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ln(), this.relativeTargetOrigin = ln(), Yf(this.relativeTargetOrigin, this.layout.layoutBox, A.layout.layoutBox), Yi(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = ln(), this.targetWithTransforms = ln()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), Eee(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Yi(this.target, this.layout.layoutBox), U7(this.target, this.targetDelta)) : Yi(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const A = this.getClosestProjectingParent();
            A && !!A.resumingFrom == !!this.resumingFrom && !A.options.layoutScroll && A.target && this.animationProgress !== 1 ? (this.relativeParent = A, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ln(), this.relativeTargetOrigin = ln(), Yf(this.relativeTargetOrigin, this.target, A.target), Yi(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          Ff && Ka.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || av(this.parent.latestValues) || F7(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var o;
      const a = this.getLead(), u = !!this.resumingFrom || this !== a;
      let h = !0;
      if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (h = !1), u && (this.isSharedProjectionDirty || this.isTransformDirty) && (h = !1), this.resolvedRelativeTargetAt === $n.timestamp && (h = !1), h)
        return;
      const { layout: d, layoutId: p } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(d || p))
        return;
      Yi(this.layoutCorrected, this.layout.layoutBox);
      const x = this.treeScale.x, A = this.treeScale.y;
      Dee(this.layoutCorrected, this.treeScale, this.path, u), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = ln());
      const { target: I } = a;
      if (!I) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (L_(this.prevProjectionDelta.x, this.projectionDelta.x), L_(this.prevProjectionDelta.y, this.projectionDelta.y)), Gf(this.projectionDelta, this.layoutCorrected, I, this.latestValues), (this.treeScale.x !== x || this.treeScale.y !== A || !z_(this.projectionDelta.x, this.prevProjectionDelta.x) || !z_(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", I)), Ff && Ka.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(o = !0) {
      var a;
      if ((a = this.options.visualElement) === null || a === void 0 || a.scheduleRender(), o) {
        const u = this.getStack();
        u && u.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = eu(), this.projectionDelta = eu(), this.projectionDeltaWithTransform = eu();
    }
    setAnimationOrigin(o, a = !1) {
      const u = this.snapshot, h = u ? u.latestValues : {}, d = { ...this.latestValues }, p = eu();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
      const x = ln(), A = u ? u.source : void 0, I = this.layout ? this.layout.source : void 0, N = A !== I, L = this.getStack(), F = !L || L.members.length <= 1, $ = !!(N && !F && this.options.crossfade === !0 && !this.path.some(yte));
      this.animationProgress = 0;
      let W;
      this.mixTargetDelta = (z) => {
        const V = z / 1e3;
        V_(p.x, o.x, V), V_(p.y, o.y, V), this.setTargetDelta(p), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Yf(x, this.layout.layoutBox, this.relativeParent.layout.layoutBox), bte(this.relativeTarget, this.relativeTargetOrigin, x, V), W && Xee(this.relativeTarget, W) && (this.isProjectionDirty = !1), W || (W = ln()), Yi(W, this.relativeTarget)), N && (this.animationValues = d, Wee(d, h, this.latestValues, V, $, F)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = V;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(o) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (ba(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Lr.update(() => {
        Fd.hasAnimatedSinceResize = !0, this.currentAnimation = ite(0, H_, {
          ...o,
          onUpdate: (a) => {
            this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a);
          },
          onComplete: () => {
            o.onComplete && o.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const o = this.getStack();
      o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(H_), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const o = this.getLead();
      let { targetWithTransforms: a, target: u, layout: h, latestValues: d } = o;
      if (!(!a || !u || !h)) {
        if (this !== o && this.layout && h && X7(this.options.animationType, this.layout.layoutBox, h.layoutBox)) {
          u = this.target || ln();
          const p = Li(this.layout.layoutBox.x);
          u.x.min = o.target.x.min, u.x.max = u.x.min + p;
          const x = Li(this.layout.layoutBox.y);
          u.y.min = o.target.y.min, u.y.max = u.y.min + x;
        }
        Yi(a, u), ru(a, d), Gf(this.projectionDeltaWithTransform, this.layoutCorrected, a, d);
      }
    }
    registerSharedNode(o, a) {
      this.sharedNodes.has(o) || this.sharedNodes.set(o, new Zee()), this.sharedNodes.get(o).add(a);
      const h = a.options.initialPromotionConfig;
      a.promote({
        transition: h ? h.transition : void 0,
        preserveFollowOpacity: h && h.shouldPreserveFollowOpacity ? h.shouldPreserveFollowOpacity(a) : void 0
      });
    }
    isLead() {
      const o = this.getStack();
      return o ? o.lead === this : !0;
    }
    getLead() {
      var o;
      const { layoutId: a } = this.options;
      return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this;
    }
    getPrevLead() {
      var o;
      const { layoutId: a } = this.options;
      return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0;
    }
    getStack() {
      const { layoutId: o } = this.options;
      if (o)
        return this.root.sharedNodes.get(o);
    }
    promote({ needsReset: o, transition: a, preserveFollowOpacity: u } = {}) {
      const h = this.getStack();
      h && h.promote(this, u), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a });
    }
    relegate() {
      const o = this.getStack();
      return o ? o.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: o } = this.options;
      if (!o)
        return;
      let a = !1;
      const { latestValues: u } = o;
      if ((u.z || u.rotate || u.rotateX || u.rotateY || u.rotateZ || u.skewX || u.skewY) && (a = !0), !a)
        return;
      const h = {};
      u.z && jm("z", o, h, this.animationValues);
      for (let d = 0; d < Um.length; d++)
        jm(`rotate${Um[d]}`, o, h, this.animationValues), jm(`skew${Um[d]}`, o, h, this.animationValues);
      o.render();
      for (const d in h)
        o.setStaticValue(d, h[d]), this.animationValues && (this.animationValues[d] = h[d]);
      o.scheduleRender();
    }
    getProjectionStyles(o) {
      var a, u;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return ste;
      const h = {
        visibility: ""
      }, d = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, h.opacity = "", h.pointerEvents = Ud(o == null ? void 0 : o.pointerEvents) || "", h.transform = d ? d(this.latestValues, "") : "none", h;
      const p = this.getLead();
      if (!this.projectionDelta || !this.layout || !p.target) {
        const N = {};
        return this.options.layoutId && (N.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, N.pointerEvents = Ud(o == null ? void 0 : o.pointerEvents) || ""), this.hasProjected && !Wa(this.latestValues) && (N.transform = d ? d({}, "") : "none", this.hasProjected = !1), N;
      }
      const x = p.animationValues || p.latestValues;
      this.applyTransformsToTarget(), h.transform = Qee(this.projectionDeltaWithTransform, this.treeScale, x), d && (h.transform = d(x, h.transform));
      const { x: A, y: I } = this.projectionDelta;
      h.transformOrigin = `${A.origin * 100}% ${I.origin * 100}% 0`, p.animationValues ? h.opacity = p === this ? (u = (a = x.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && u !== void 0 ? u : 1 : this.preserveOpacity ? this.latestValues.opacity : x.opacityExit : h.opacity = p === this ? x.opacity !== void 0 ? x.opacity : "" : x.opacityExit !== void 0 ? x.opacityExit : 0;
      for (const N in x0) {
        if (x[N] === void 0)
          continue;
        const { correct: L, applyTo: F } = x0[N], $ = h.transform === "none" ? x[N] : L(x[N], p);
        if (F) {
          const W = F.length;
          for (let z = 0; z < W; z++)
            h[F[z]] = $;
        } else
          h[N] = $;
      }
      return this.options.layoutId && (h.pointerEvents = p === this ? Ud(o == null ? void 0 : o.pointerEvents) || "" : "none"), h;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((o) => {
        var a;
        return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop();
      }), this.root.nodes.forEach(W_), this.root.sharedNodes.clear();
    }
  };
}
function ate(t) {
  t.updateLayout();
}
function cte(t) {
  var e;
  const r = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot;
  if (t.isLead() && t.layout && r && t.hasListeners("didUpdate")) {
    const { layoutBox: n, measuredBox: i } = t.layout, { animationType: s } = t.options, o = r.source !== t.layout.source;
    s === "size" ? Xi((p) => {
      const x = o ? r.measuredBox[p] : r.layoutBox[p], A = Li(x);
      x.min = n[p].min, x.max = x.min + A;
    }) : X7(s, r.layoutBox, n) && Xi((p) => {
      const x = o ? r.measuredBox[p] : r.layoutBox[p], A = Li(n[p]);
      x.max = x.min + A, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[p].max = t.relativeTarget[p].min + A);
    });
    const a = eu();
    Gf(a, n, r.layoutBox);
    const u = eu();
    o ? Gf(u, t.applyTransform(i, !0), r.measuredBox) : Gf(u, n, r.layoutBox);
    const h = !V7(a);
    let d = !1;
    if (!t.resumeFrom) {
      const p = t.getClosestProjectingParent();
      if (p && !p.resumeFrom) {
        const { snapshot: x, layout: A } = p;
        if (x && A) {
          const I = ln();
          Yf(I, r.layoutBox, x.layoutBox);
          const N = ln();
          Yf(N, n, A.layoutBox), G7(I, N) || (d = !0), p.options.layoutRoot && (t.relativeTarget = N, t.relativeTargetOrigin = I, t.relativeParent = p);
        }
      }
    }
    t.notifyListeners("didUpdate", {
      layout: n,
      snapshot: r,
      delta: u,
      layoutDelta: a,
      hasLayoutChanged: h,
      hasRelativeTargetChanged: d
    });
  } else if (t.isLead()) {
    const { onExitComplete: n } = t.options;
    n && n();
  }
  t.options.transition = void 0;
}
function ute(t) {
  Ff && Ka.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty));
}
function fte(t) {
  t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1;
}
function lte(t) {
  t.clearSnapshot();
}
function W_(t) {
  t.clearMeasurements();
}
function hte(t) {
  t.isLayoutDirty = !1;
}
function dte(t) {
  const { visualElement: e } = t.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform();
}
function K_(t) {
  t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0;
}
function pte(t) {
  t.resolveTargetDelta();
}
function gte(t) {
  t.calcProjection();
}
function mte(t) {
  t.resetSkewAndRotation();
}
function vte(t) {
  t.removeLeadSnapshot();
}
function V_(t, e, r) {
  t.translate = Qr(e.translate, 0, r), t.scale = Qr(e.scale, 1, r), t.origin = e.origin, t.originPoint = e.originPoint;
}
function G_(t, e, r, n) {
  t.min = Qr(e.min, r.min, n), t.max = Qr(e.max, r.max, n);
}
function bte(t, e, r, n) {
  G_(t.x, e.x, r.x, n), G_(t.y, e.y, r.y, n);
}
function yte(t) {
  return t.animationValues && t.animationValues.opacityExit !== void 0;
}
const wte = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, Y_ = (t) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), J_ = Y_("applewebkit/") && !Y_("chrome/") ? Math.round : Un;
function X_(t) {
  t.min = J_(t.min), t.max = J_(t.max);
}
function xte(t) {
  X_(t.x), X_(t.y);
}
function X7(t, e, r) {
  return t === "position" || t === "preserve-aspect" && !_ee(q_(e), q_(r), 0.2);
}
function _te(t) {
  var e;
  return t !== t.root && ((e = t.scroll) === null || e === void 0 ? void 0 : e.wasRoot);
}
const Ete = J7({
  attachResizeListener: (t, e) => Ao(t, "resize", e),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), qm = {
  current: void 0
}, Z7 = J7({
  measureScroll: (t) => ({
    x: t.scrollLeft,
    y: t.scrollTop
  }),
  defaultParent: () => {
    if (!qm.current) {
      const t = new Ete({});
      t.mount(window), t.setOptions({ layoutScroll: !0 }), qm.current = t;
    }
    return qm.current;
  },
  resetTransform: (t, e) => {
    t.style.transform = e !== void 0 ? e : "none";
  },
  checkIsScrollRoot: (t) => window.getComputedStyle(t).position === "fixed"
}), Ste = {
  pan: {
    Feature: Bee
  },
  drag: {
    Feature: $ee,
    ProjectionNode: Z7,
    MeasureLayout: H7
  }
};
function Z_(t, e) {
  const r = e ? "pointerenter" : "pointerleave", n = e ? "onHoverStart" : "onHoverEnd", i = (s, o) => {
    if (s.pointerType === "touch" || L7())
      return;
    const a = t.getProps();
    t.animationState && a.whileHover && t.animationState.setActive("whileHover", e);
    const u = a[n];
    u && Lr.postRender(() => u(s, o));
  };
  return To(t.current, r, i, {
    passive: !t.getProps()[n]
  });
}
class Ate extends Ma {
  mount() {
    this.unmount = Co(Z_(this.node, !0), Z_(this.node, !1));
  }
  unmount() {
  }
}
class Pte extends Ma {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Co(Ao(this.node.current, "focus", () => this.onFocus()), Ao(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const Q7 = (t, e) => e ? t === e ? !0 : Q7(t, e.parentElement) : !1;
function zm(t, e) {
  if (!e)
    return;
  const r = new PointerEvent("pointer" + t);
  e(r, wp(r));
}
class Mte extends Ma {
  constructor() {
    super(...arguments), this.removeStartListeners = Un, this.removeEndListeners = Un, this.removeAccessibleListeners = Un, this.startPointerPress = (e, r) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const n = this.node.getProps(), s = To(window, "pointerup", (a, u) => {
        if (!this.checkPressEnd())
          return;
        const { onTap: h, onTapCancel: d, globalTapTarget: p } = this.node.getProps(), x = !p && !Q7(this.node.current, a.target) ? d : h;
        x && Lr.update(() => x(a, u));
      }, {
        passive: !(n.onTap || n.onPointerUp)
      }), o = To(window, "pointercancel", (a, u) => this.cancelPress(a, u), {
        passive: !(n.onTapCancel || n.onPointerCancel)
      });
      this.removeEndListeners = Co(s, o), this.startPress(e, r);
    }, this.startAccessiblePress = () => {
      const e = (s) => {
        if (s.key !== "Enter" || this.isPressing)
          return;
        const o = (a) => {
          a.key !== "Enter" || !this.checkPressEnd() || zm("up", (u, h) => {
            const { onTap: d } = this.node.getProps();
            d && Lr.postRender(() => d(u, h));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = Ao(this.node.current, "keyup", o), zm("down", (a, u) => {
          this.startPress(a, u);
        });
      }, r = Ao(this.node.current, "keydown", e), n = () => {
        this.isPressing && zm("cancel", (s, o) => this.cancelPress(s, o));
      }, i = Ao(this.node.current, "blur", n);
      this.removeAccessibleListeners = Co(r, i);
    };
  }
  startPress(e, r) {
    this.isPressing = !0;
    const { onTapStart: n, whileTap: i } = this.node.getProps();
    i && this.node.animationState && this.node.animationState.setActive("whileTap", !0), n && Lr.postRender(() => n(e, r));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !L7();
  }
  cancelPress(e, r) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel: n } = this.node.getProps();
    n && Lr.postRender(() => n(e, r));
  }
  mount() {
    const e = this.node.getProps(), r = To(e.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
      passive: !(e.onTapStart || e.onPointerStart)
    }), n = Ao(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = Co(r, n);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const uv = /* @__PURE__ */ new WeakMap(), Hm = /* @__PURE__ */ new WeakMap(), Ite = (t) => {
  const e = uv.get(t.target);
  e && e(t);
}, Cte = (t) => {
  t.forEach(Ite);
};
function Tte({ root: t, ...e }) {
  const r = t || document;
  Hm.has(r) || Hm.set(r, {});
  const n = Hm.get(r), i = JSON.stringify(e);
  return n[i] || (n[i] = new IntersectionObserver(Cte, { root: t, ...e })), n[i];
}
function Rte(t, e, r) {
  const n = Tte(e);
  return uv.set(t, r), n.observe(t), () => {
    uv.delete(t), n.unobserve(t);
  };
}
const Dte = {
  some: 0,
  all: 1
};
class Ote extends Ma {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(), { root: r, margin: n, amount: i = "some", once: s } = e, o = {
      root: r ? r.current : void 0,
      rootMargin: n,
      threshold: typeof i == "number" ? i : Dte[i]
    }, a = (u) => {
      const { isIntersecting: h } = u;
      if (this.isInView === h || (this.isInView = h, s && !h && this.hasEnteredView))
        return;
      h && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", h);
      const { onViewportEnter: d, onViewportLeave: p } = this.node.getProps(), x = h ? d : p;
      x && x(u);
    };
    return Rte(this.node.current, o, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: e, prevProps: r } = this.node;
    ["amount", "margin", "root"].some(Nte(e, r)) && this.startObserver();
  }
  unmount() {
  }
}
function Nte({ viewport: t = {} }, { viewport: e = {} } = {}) {
  return (r) => t[r] !== e[r];
}
const Lte = {
  inView: {
    Feature: Ote
  },
  tap: {
    Feature: Mte
  },
  focus: {
    Feature: Pte
  },
  hover: {
    Feature: Ate
  }
}, kte = {
  layout: {
    ProjectionNode: Z7,
    MeasureLayout: H7
  }
}, Jb = hc({
  transformPagePoint: (t) => t,
  isStatic: !1,
  reducedMotion: "never"
}), _p = hc({}), Xb = typeof window < "u", e9 = Xb ? _R : si, t9 = hc({ strict: !1 });
function $te(t, e, r, n, i) {
  var s, o;
  const { visualElement: a } = Fn(_p), u = Fn(t9), h = Fn(xp), d = Fn(Jb).reducedMotion, p = bi();
  n = n || u.renderer, !p.current && n && (p.current = n(t, {
    visualState: e,
    parent: a,
    props: r,
    presenceContext: h,
    blockInitialAnimation: h ? h.initial === !1 : !1,
    reducedMotionConfig: d
  }));
  const x = p.current, A = Fn(z7);
  x && !x.projection && i && (x.type === "html" || x.type === "svg") && Bte(p.current, r, i, A);
  const I = bi(!1);
  m5(() => {
    x && I.current && x.update(r, h);
  });
  const N = r[P7], L = bi(!!N && !(!((s = window.MotionHandoffIsComplete) === null || s === void 0) && s.call(window, N)) && ((o = window.MotionHasOptimisedAnimation) === null || o === void 0 ? void 0 : o.call(window, N)));
  return e9(() => {
    x && (I.current = !0, window.MotionIsMounted = !0, x.updateFeatures(), Yb.render(x.render), L.current && x.animationState && x.animationState.animateChanges());
  }), si(() => {
    x && (!L.current && x.animationState && x.animationState.animateChanges(), L.current && (queueMicrotask(() => {
      var F;
      (F = window.MotionHandoffMarkAsComplete) === null || F === void 0 || F.call(window, N);
    }), L.current = !1));
  }), x;
}
function Bte(t, e, r, n) {
  const { layoutId: i, layout: s, drag: o, dragConstraints: a, layoutScroll: u, layoutRoot: h } = e;
  t.projection = new r(t.latestValues, e["data-framer-portal-id"] ? void 0 : r9(t.parent)), t.projection.setOptions({
    layoutId: i,
    layout: s,
    alwaysMeasureLayout: !!o || a && Qc(a),
    visualElement: t,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof s == "string" ? s : "both",
    initialPromotionConfig: n,
    layoutScroll: u,
    layoutRoot: h
  });
}
function r9(t) {
  if (t)
    return t.options.allowProjection !== !1 ? t.projection : r9(t.parent);
}
function Fte(t, e, r) {
  return vv(
    (n) => {
      n && t.mount && t.mount(n), e && (n ? e.mount(n) : e.unmount()), r && (typeof r == "function" ? r(n) : Qc(r) && (r.current = n));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [e]
  );
}
function Ep(t) {
  return vp(t.animate) || Ib.some((e) => Ml(t[e]));
}
function n9(t) {
  return !!(Ep(t) || t.variants);
}
function Ute(t, e) {
  if (Ep(t)) {
    const { initial: r, animate: n } = t;
    return {
      initial: r === !1 || Ml(r) ? r : void 0,
      animate: Ml(n) ? n : void 0
    };
  }
  return t.inherit !== !1 ? e : {};
}
function jte(t) {
  const { initial: e, animate: r } = Ute(t, Fn(_p));
  return Oi(() => ({ initial: e, animate: r }), [Q_(e), Q_(r)]);
}
function Q_(t) {
  return Array.isArray(t) ? t.join(" ") : t;
}
const e5 = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, Mu = {};
for (const t in e5)
  Mu[t] = {
    isEnabled: (e) => e5[t].some((r) => !!e[r])
  };
function qte(t) {
  for (const e in t)
    Mu[e] = {
      ...Mu[e],
      ...t[e]
    };
}
const zte = Symbol.for("motionComponentSymbol");
function Hte({ preloadedFeatures: t, createVisualElement: e, useRender: r, useVisualState: n, Component: i }) {
  t && qte(t);
  function s(a, u) {
    let h;
    const d = {
      ...Fn(Jb),
      ...a,
      layoutId: Wte(a)
    }, { isStatic: p } = d, x = jte(a), A = n(a, p);
    if (!p && Xb) {
      Kte(d, t);
      const I = Vte(d);
      h = I.MeasureLayout, x.visualElement = $te(i, A, d, e, I.ProjectionNode);
    }
    return ve.jsxs(_p.Provider, { value: x, children: [h && x.visualElement ? ve.jsx(h, { visualElement: x.visualElement, ...d }) : null, r(i, a, Fte(A, x.visualElement, u), A, p, x.visualElement)] });
  }
  const o = gv(s);
  return o[zte] = i, o;
}
function Wte({ layoutId: t }) {
  const e = Fn(Gb).id;
  return e && t !== void 0 ? e + "-" + t : t;
}
function Kte(t, e) {
  const r = Fn(t9).strict;
  if (process.env.NODE_ENV !== "production" && e && r) {
    const n = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    t.ignoreStrict ? Hu(!1, n) : Bo(!1, n);
  }
}
function Vte(t) {
  const { drag: e, layout: r } = Mu;
  if (!e && !r)
    return {};
  const n = { ...e, ...r };
  return {
    MeasureLayout: e != null && e.isEnabled(t) || r != null && r.isEnabled(t) ? n.MeasureLayout : void 0,
    ProjectionNode: n.ProjectionNode
  };
}
const Gte = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function Zb(t) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof t != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    t.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(Gte.indexOf(t) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(t))
    )
  );
}
function i9(t, { style: e, vars: r }, n, i) {
  Object.assign(t.style, e, i && i.getProjectionStyles(n));
  for (const s in r)
    t.style.setProperty(s, r[s]);
}
const s9 = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function o9(t, e, r, n) {
  i9(t, e, void 0, n);
  for (const i in e.attrs)
    t.setAttribute(s9.has(i) ? i : Vb(i), e.attrs[i]);
}
function a9(t, { layout: e, layoutId: r }) {
  return _c.has(t) || t.startsWith("origin") || (e || r !== void 0) && (!!x0[t] || t === "opacity");
}
function Qb(t, e, r) {
  var n;
  const { style: i } = t, s = {};
  for (const o in i)
    (Jn(i[o]) || e.style && Jn(e.style[o]) || a9(o, t) || ((n = r == null ? void 0 : r.getValue(o)) === null || n === void 0 ? void 0 : n.liveStyle) !== void 0) && (s[o] = i[o]);
  return s;
}
function c9(t, e, r) {
  const n = Qb(t, e, r);
  for (const i in t)
    if (Jn(t[i]) || Jn(e[i])) {
      const s = oh.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
      n[s] = t[i];
    }
  return n;
}
function ey(t) {
  const e = bi(null);
  return e.current === null && (e.current = t()), e.current;
}
function Yte({ scrapeMotionValuesFromProps: t, createRenderState: e, onMount: r }, n, i, s) {
  const o = {
    latestValues: Jte(n, i, s, t),
    renderState: e()
  };
  return r && (o.mount = (a) => r(n, a, o)), o;
}
const u9 = (t) => (e, r) => {
  const n = Fn(_p), i = Fn(xp), s = () => Yte(t, e, n, i);
  return r ? s() : ey(s);
};
function Jte(t, e, r, n) {
  const i = {}, s = n(t, {});
  for (const x in s)
    i[x] = Ud(s[x]);
  let { initial: o, animate: a } = t;
  const u = Ep(t), h = n9(t);
  e && h && !u && t.inherit !== !1 && (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate));
  let d = r ? r.initial === !1 : !1;
  d = d || o === !1;
  const p = d ? a : o;
  if (p && typeof p != "boolean" && !vp(p)) {
    const x = Array.isArray(p) ? p : [p];
    for (let A = 0; A < x.length; A++) {
      const I = Pb(t, x[A]);
      if (I) {
        const { transitionEnd: N, transition: L, ...F } = I;
        for (const $ in F) {
          let W = F[$];
          if (Array.isArray(W)) {
            const z = d ? W.length - 1 : 0;
            W = W[z];
          }
          W !== null && (i[$] = W);
        }
        for (const $ in N)
          i[$] = N[$];
      }
    }
  }
  return i;
}
const ty = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
}), f9 = () => ({
  ...ty(),
  attrs: {}
}), l9 = (t, e) => e && typeof t == "number" ? e.transform(t) : t, Xte = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, Zte = oh.length;
function Qte(t, e, r) {
  let n = "", i = !0;
  for (let s = 0; s < Zte; s++) {
    const o = oh[s], a = t[o];
    if (a === void 0)
      continue;
    let u = !0;
    if (typeof a == "number" ? u = a === (o.startsWith("scale") ? 1 : 0) : u = parseFloat(a) === 0, !u || r) {
      const h = l9(a, kb[o]);
      if (!u) {
        i = !1;
        const d = Xte[o] || o;
        n += `${d}(${h}) `;
      }
      r && (e[o] = h);
    }
  }
  return n = n.trim(), r ? n = r(e, i ? "" : n) : i && (n = "none"), n;
}
function ry(t, e, r) {
  const { style: n, vars: i, transformOrigin: s } = t;
  let o = !1, a = !1;
  for (const u in e) {
    const h = e[u];
    if (_c.has(u)) {
      o = !0;
      continue;
    } else if (n7(u)) {
      i[u] = h;
      continue;
    } else {
      const d = l9(h, kb[u]);
      u.startsWith("origin") ? (a = !0, s[u] = d) : n[u] = d;
    }
  }
  if (e.transform || (o || r ? n.transform = Qte(e, t.transform, r) : n.transform && (n.transform = "none")), a) {
    const { originX: u = "50%", originY: h = "50%", originZ: d = 0 } = s;
    n.transformOrigin = `${u} ${h} ${d}`;
  }
}
function t5(t, e, r) {
  return typeof t == "string" ? t : Vt.transform(e + r * t);
}
function ere(t, e, r) {
  const n = t5(e, t.x, t.width), i = t5(r, t.y, t.height);
  return `${n} ${i}`;
}
const tre = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, rre = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function nre(t, e, r = 1, n = 0, i = !0) {
  t.pathLength = 1;
  const s = i ? tre : rre;
  t[s.offset] = Vt.transform(-n);
  const o = Vt.transform(e), a = Vt.transform(r);
  t[s.array] = `${o} ${a}`;
}
function ny(t, {
  attrX: e,
  attrY: r,
  attrScale: n,
  originX: i,
  originY: s,
  pathLength: o,
  pathSpacing: a = 1,
  pathOffset: u = 0,
  // This is object creation, which we try to avoid per-frame.
  ...h
}, d, p) {
  if (ry(t, h, p), d) {
    t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
    return;
  }
  t.attrs = t.style, t.style = {};
  const { attrs: x, style: A, dimensions: I } = t;
  x.transform && (I && (A.transform = x.transform), delete x.transform), I && (i !== void 0 || s !== void 0 || A.transform) && (A.transformOrigin = ere(I, i !== void 0 ? i : 0.5, s !== void 0 ? s : 0.5)), e !== void 0 && (x.x = e), r !== void 0 && (x.y = r), n !== void 0 && (x.scale = n), o !== void 0 && nre(x, o, a, u, !1);
}
const iy = (t) => typeof t == "string" && t.toLowerCase() === "svg", ire = {
  useVisualState: u9({
    scrapeMotionValuesFromProps: c9,
    createRenderState: f9,
    onMount: (t, e, { renderState: r, latestValues: n }) => {
      Lr.read(() => {
        try {
          r.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect();
        } catch {
          r.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      }), Lr.render(() => {
        ny(r, n, iy(e.tagName), t.transformTemplate), o9(e, r);
      });
    }
  })
}, sre = {
  useVisualState: u9({
    scrapeMotionValuesFromProps: Qb,
    createRenderState: ty
  })
};
function h9(t, e, r) {
  for (const n in e)
    !Jn(e[n]) && !a9(n, r) && (t[n] = e[n]);
}
function ore({ transformTemplate: t }, e) {
  return Oi(() => {
    const r = ty();
    return ry(r, e, t), Object.assign({}, r.vars, r.style);
  }, [e]);
}
function are(t, e) {
  const r = t.style || {}, n = {};
  return h9(n, r, t), Object.assign(n, ore(t, e)), n;
}
function cre(t, e) {
  const r = {}, n = are(t, e);
  return t.drag && t.dragListener !== !1 && (r.draggable = !1, n.userSelect = n.WebkitUserSelect = n.WebkitTouchCallout = "none", n.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (r.tabIndex = 0), r.style = n, r;
}
const ure = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function _0(t) {
  return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || ure.has(t);
}
let d9 = (t) => !_0(t);
function fre(t) {
  t && (d9 = (e) => e.startsWith("on") ? !_0(e) : t(e));
}
try {
  fre(require("@emotion/is-prop-valid").default);
} catch {
}
function lre(t, e, r) {
  const n = {};
  for (const i in t)
    i === "values" && typeof t.values == "object" || (d9(i) || r === !0 && _0(i) || !e && !_0(i) || // If trying to use native HTML drag events, forward drag listeners
    t.draggable && i.startsWith("onDrag")) && (n[i] = t[i]);
  return n;
}
function hre(t, e, r, n) {
  const i = Oi(() => {
    const s = f9();
    return ny(s, e, iy(n), t.transformTemplate), {
      ...s.attrs,
      style: { ...s.style }
    };
  }, [e]);
  if (t.style) {
    const s = {};
    h9(s, t.style, t), i.style = { ...s, ...i.style };
  }
  return i;
}
function dre(t = !1) {
  return (r, n, i, { latestValues: s }, o) => {
    const u = (Zb(r) ? hre : cre)(n, s, o, r), h = lre(n, typeof r == "string", t), d = r !== v5 ? { ...h, ...u, ref: i } : {}, { children: p } = n, x = Oi(() => Jn(p) ? p.get() : p, [p]);
    return jd(r, {
      ...d,
      children: x
    });
  };
}
function pre(t, e) {
  return function(n, { forwardMotionProps: i } = { forwardMotionProps: !1 }) {
    const o = {
      ...Zb(n) ? ire : sre,
      preloadedFeatures: t,
      useRender: dre(i),
      createVisualElement: e,
      Component: n
    };
    return Hte(o);
  };
}
const fv = { current: null }, p9 = { current: !1 };
function gre() {
  if (p9.current = !0, !!Xb)
    if (window.matchMedia) {
      const t = window.matchMedia("(prefers-reduced-motion)"), e = () => fv.current = t.matches;
      t.addListener(e), e();
    } else
      fv.current = !1;
}
function mre(t, e, r) {
  for (const n in e) {
    const i = e[n], s = r[n];
    if (Jn(i))
      t.addValue(n, i), process.env.NODE_ENV === "development" && mp(i.version === "11.11.17", `Attempting to mix Motion versions ${i.version} with 11.11.17 may not work as expected.`);
    else if (Jn(s))
      t.addValue(n, Tl(i, { owner: t }));
    else if (s !== i)
      if (t.hasValue(n)) {
        const o = t.getValue(n);
        o.liveStyle === !0 ? o.jump(i) : o.hasAnimated || o.set(i);
      } else {
        const o = t.getStaticValue(n);
        t.addValue(n, Tl(o !== void 0 ? o : i, { owner: t }));
      }
  }
  for (const n in r)
    e[n] === void 0 && t.removeValue(n);
  return e;
}
const r5 = /* @__PURE__ */ new WeakMap(), vre = [...o7, Gn, wa], bre = (t) => vre.find(s7(t)), n5 = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class yre {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(e, r, n) {
    return {};
  }
  constructor({ parent: e, props: r, presenceContext: n, reducedMotionConfig: i, blockInitialAnimation: s, visualState: o }, a = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = Ob, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const x = Vs.now();
      this.renderScheduledAt < x && (this.renderScheduledAt = x, Lr.render(this.render, !1, !0));
    };
    const { latestValues: u, renderState: h } = o;
    this.latestValues = u, this.baseTarget = { ...u }, this.initialValues = r.initial ? { ...u } : {}, this.renderState = h, this.parent = e, this.props = r, this.presenceContext = n, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = i, this.options = a, this.blockInitialAnimation = !!s, this.isControllingVariants = Ep(r), this.isVariantNode = n9(r), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(e && e.current);
    const { willChange: d, ...p } = this.scrapeMotionValuesFromProps(r, {}, this);
    for (const x in p) {
      const A = p[x];
      u[x] !== void 0 && Jn(A) && A.set(u[x], !1);
    }
  }
  mount(e) {
    this.current = e, r5.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((r, n) => this.bindToMotionValue(n, r)), p9.current || gre(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : fv.current, process.env.NODE_ENV !== "production" && mp(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    r5.delete(this.current), this.projection && this.projection.unmount(), ba(this.notifyUpdate), ba(this.render), this.valueSubscriptions.forEach((e) => e()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const e in this.events)
      this.events[e].clear();
    for (const e in this.features) {
      const r = this.features[e];
      r && (r.unmount(), r.isMounted = !1);
    }
    this.current = null;
  }
  bindToMotionValue(e, r) {
    this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
    const n = _c.has(e), i = r.on("change", (a) => {
      this.latestValues[e] = a, this.props.onUpdate && Lr.preRender(this.notifyUpdate), n && this.projection && (this.projection.isTransformDirty = !0);
    }), s = r.on("renderRequest", this.scheduleRender);
    let o;
    window.MotionCheckAppearSync && (o = window.MotionCheckAppearSync(this, e, r)), this.valueSubscriptions.set(e, () => {
      i(), s(), o && o(), r.owner && r.stop();
    });
  }
  sortNodePosition(e) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current);
  }
  updateFeatures() {
    let e = "animation";
    for (e in Mu) {
      const r = Mu[e];
      if (!r)
        continue;
      const { isEnabled: n, Feature: i } = r;
      if (!this.features[e] && i && n(this.props) && (this.features[e] = new i(this)), this.features[e]) {
        const s = this.features[e];
        s.isMounted ? s.update() : (s.mount(), s.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : ln();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, r) {
    this.latestValues[e] = r;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(e, r) {
    (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = r;
    for (let n = 0; n < n5.length; n++) {
      const i = n5[n];
      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
      const s = "on" + i, o = e[s];
      o && (this.propEventSubscriptions[i] = this.on(i, o));
    }
    this.prevMotionValues = mre(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(e) {
    const r = this.getClosestVariantNode();
    if (r)
      return r.variantChildren && r.variantChildren.add(e), () => r.variantChildren.delete(e);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(e, r) {
    const n = this.values.get(e);
    r !== n && (n && this.removeValue(e), this.bindToMotionValue(e, r), this.values.set(e, r), this.latestValues[e] = r.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(e) {
    this.values.delete(e);
    const r = this.valueSubscriptions.get(e);
    r && (r(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, r) {
    if (this.props.values && this.props.values[e])
      return this.props.values[e];
    let n = this.values.get(e);
    return n === void 0 && r !== void 0 && (n = Tl(r === null ? void 0 : r, { owner: this }), this.addValue(e, n)), n;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(e, r) {
    var n;
    let i = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (n = this.getBaseTargetFromProps(this.props, e)) !== null && n !== void 0 ? n : this.readValueFromInstance(this.current, e, this.options);
    return i != null && (typeof i == "string" && (t7(i) || e7(i)) ? i = parseFloat(i) : !bre(i) && wa.test(r) && (i = p7(e, r)), this.setBaseTarget(e, Jn(i) ? i.get() : i)), Jn(i) ? i.get() : i;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(e, r) {
    this.baseTarget[e] = r;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(e) {
    var r;
    const { initial: n } = this.props;
    let i;
    if (typeof n == "string" || typeof n == "object") {
      const o = Pb(this.props, n, (r = this.presenceContext) === null || r === void 0 ? void 0 : r.custom);
      o && (i = o[e]);
    }
    if (n && i !== void 0)
      return i;
    const s = this.getBaseTargetFromProps(this.props, e);
    return s !== void 0 && !Jn(s) ? s : this.initialValues[e] !== void 0 && i === void 0 ? void 0 : this.baseTarget[e];
  }
  on(e, r) {
    return this.events[e] || (this.events[e] = new Kb()), this.events[e].add(r);
  }
  notify(e, ...r) {
    this.events[e] && this.events[e].notify(...r);
  }
}
class g9 extends yre {
  constructor() {
    super(...arguments), this.KeyframeResolver = g7;
  }
  sortInstanceNodePosition(e, r) {
    return e.compareDocumentPosition(r) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, r) {
    return e.style ? e.style[r] : void 0;
  }
  removeValueFromRenderState(e, { vars: r, style: n }) {
    delete r[e], delete n[e];
  }
}
function wre(t) {
  return window.getComputedStyle(t);
}
class xre extends g9 {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = i9;
  }
  readValueFromInstance(e, r) {
    if (_c.has(r)) {
      const n = $b(r);
      return n && n.default || 0;
    } else {
      const n = wre(e), i = (n7(r) ? n.getPropertyValue(r) : n[r]) || 0;
      return typeof i == "string" ? i.trim() : i;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: r }) {
    return j7(e, r);
  }
  build(e, r, n) {
    ry(e, r, n.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, r, n) {
    return Qb(e, r, n);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    Jn(e) && (this.childSubscription = e.on("change", (r) => {
      this.current && (this.current.textContent = `${r}`);
    }));
  }
}
class _re extends g9 {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = ln;
  }
  getBaseTargetFromProps(e, r) {
    return e[r];
  }
  readValueFromInstance(e, r) {
    if (_c.has(r)) {
      const n = $b(r);
      return n && n.default || 0;
    }
    return r = s9.has(r) ? r : Vb(r), e.getAttribute(r);
  }
  scrapeMotionValuesFromProps(e, r, n) {
    return c9(e, r, n);
  }
  build(e, r, n) {
    ny(e, r, this.isSVGTag, n.transformTemplate);
  }
  renderInstance(e, r, n, i) {
    o9(e, r, n, i);
  }
  mount(e) {
    this.isSVGTag = iy(e.tagName), super.mount(e);
  }
}
const Ere = (t, e) => Zb(t) ? new _re(e) : new xre(e, {
  allowProjection: t !== v5
}), Sre = /* @__PURE__ */ pre({
  ...dee,
  ...Lte,
  ...Ste,
  ...kte
}, Ere), Are = /* @__PURE__ */ iZ(Sre);
class Pre extends Gt.Component {
  getSnapshotBeforeUpdate(e) {
    const r = this.props.childRef.current;
    if (r && e.isPresent && !this.props.isPresent) {
      const n = this.props.sizeRef.current;
      n.height = r.offsetHeight || 0, n.width = r.offsetWidth || 0, n.top = r.offsetTop, n.left = r.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function Mre({ children: t, isPresent: e }) {
  const r = mv(), n = bi(null), i = bi({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), { nonce: s } = Fn(Jb);
  return m5(() => {
    const { width: o, height: a, top: u, left: h } = i.current;
    if (e || !n.current || !o || !a)
      return;
    n.current.dataset.motionPopId = r;
    const d = document.createElement("style");
    return s && (d.nonce = s), document.head.appendChild(d), d.sheet && d.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${o}px !important;
            height: ${a}px !important;
            top: ${u}px !important;
            left: ${h}px !important;
          }
        `), () => {
      document.head.removeChild(d);
    };
  }, [e]), ve.jsx(Pre, { isPresent: e, childRef: n, sizeRef: i, children: Gt.cloneElement(t, { ref: n }) });
}
const Ire = ({ children: t, initial: e, isPresent: r, onExitComplete: n, custom: i, presenceAffectsLayout: s, mode: o }) => {
  const a = ey(Cre), u = mv(), h = vv((p) => {
    a.set(p, !0);
    for (const x of a.values())
      if (!x)
        return;
    n && n();
  }, [a, n]), d = Oi(
    () => ({
      id: u,
      initial: e,
      isPresent: r,
      custom: i,
      onExitComplete: h,
      register: (p) => (a.set(p, !1), () => a.delete(p))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    s ? [Math.random(), h] : [r, h]
  );
  return Oi(() => {
    a.forEach((p, x) => a.set(x, !1));
  }, [r]), Gt.useEffect(() => {
    !r && !a.size && n && n();
  }, [r]), o === "popLayout" && (t = ve.jsx(Mre, { isPresent: r, children: t })), ve.jsx(xp.Provider, { value: d, children: t });
};
function Cre() {
  return /* @__PURE__ */ new Map();
}
const vd = (t) => t.key || "";
function i5(t) {
  const e = [];
  return ER.forEach(t, (r) => {
    SR(r) && e.push(r);
  }), e;
}
const Tre = ({ children: t, exitBeforeEnter: e, custom: r, initial: n = !0, onExitComplete: i, presenceAffectsLayout: s = !0, mode: o = "sync" }) => {
  Bo(!e, "Replace exitBeforeEnter with mode='wait'");
  const a = Oi(() => i5(t), [t]), u = a.map(vd), h = bi(!0), d = bi(a), p = ey(() => /* @__PURE__ */ new Map()), [x, A] = Er(a), [I, N] = Er(a);
  e9(() => {
    h.current = !1, d.current = a;
    for (let $ = 0; $ < I.length; $++) {
      const W = vd(I[$]);
      u.includes(W) ? p.delete(W) : p.get(W) !== !0 && p.set(W, !1);
    }
  }, [I, u.length, u.join("-")]);
  const L = [];
  if (a !== x) {
    let $ = [...a];
    for (let W = 0; W < I.length; W++) {
      const z = I[W], V = vd(z);
      u.includes(V) || ($.splice(W, 0, z), L.push(z));
    }
    o === "wait" && L.length && ($ = L), N(i5($)), A(a);
    return;
  }
  process.env.NODE_ENV !== "production" && o === "wait" && I.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
  const { forceRender: F } = Fn(Gb);
  return ve.jsx(ve.Fragment, { children: I.map(($) => {
    const W = vd($), z = a === I || u.includes(W), V = () => {
      if (p.has(W))
        p.set(W, !0);
      else
        return;
      let te = !0;
      p.forEach((R) => {
        R || (te = !1);
      }), te && (F == null || F(), N(d.current), i && i());
    };
    return ve.jsx(Ire, { isPresent: z, initial: !h.current || n ? void 0 : !1, custom: z ? void 0 : r, presenceAffectsLayout: s, mode: o, onExitComplete: z ? void 0 : V, children: $ }, W);
  }) });
}, Ec = (t) => /* @__PURE__ */ ve.jsx(Tre, { children: /* @__PURE__ */ ve.jsx(
  Are.div,
  {
    initial: { x: 0, opacity: 0 },
    animate: { x: 0, opacity: 1 },
    exit: { x: 30, opacity: 0 },
    transition: { duration: 0.3 },
    className: t.className,
    children: t.children
  }
) });
function sy(t) {
  const { icon: e, title: r, extra: n, onClick: i } = t;
  function s() {
    i && i();
  }
  return /* @__PURE__ */ ve.jsxs(
    "div",
    {
      className: "xc-rounded-lg xc-group xc-flex xc-cursor-pointer xc-items-center xc-gap-2 xc-border xc-border-gray-100 xc-px-4 xc-py-2 xc-transition-all xc-hover:shadow-lg",
      onClick: s,
      children: [
        e,
        r,
        /* @__PURE__ */ ve.jsxs("div", { className: "xc-relative xc-ml-auto xc-h-6", children: [
          /* @__PURE__ */ ve.jsx("div", { className: "xc-relative xc-left-0 xc-opacity-100 xc-transition-all xc-group-hover:left-2 xc-group-hover:opacity-0", children: n }),
          /* @__PURE__ */ ve.jsx("div", { className: "xc-absolute xc-right-2 xc-top-0 xc-text-gray-400 xc-opacity-0 xc-transition-all xc-group-hover:right-0 xc-group-hover:opacity-100", children: /* @__PURE__ */ ve.jsx(XX, {}) })
        ] })
      ]
    }
  );
}
function Rre(t) {
  return t.connected ? /* @__PURE__ */ ve.jsxs("div", { className: "xc-flex xc-items-center xc-gap-2 xc-rounded-full xc-py-1 xc-text-xs xc-text-gray-500", children: [
    /* @__PURE__ */ ve.jsx("div", { className: "xc-bg-green xc-h-1 xc-w-1 xc-rounded-full" }),
    "connected"
  ] }) : t.lastUsed ? /* @__PURE__ */ ve.jsxs("div", { className: "xc-flex xc-items-center xc-gap-2 xc-rounded-full xc-py-1 xc-text-xs xc-text-gray-500", children: [
    /* @__PURE__ */ ve.jsx("div", { className: "xc-h-1 xc-w-1 xc-rounded-full xc-bg-[#009E8C]" }),
    "Last Used"
  ] }) : t.installed ? /* @__PURE__ */ ve.jsxs("div", { className: "xc-flex xc-items-center xc-gap-2 xc-rounded-full xc-py-1 xc-text-xs xc-text-gray-500", children: [
    /* @__PURE__ */ ve.jsx("div", { className: "xc-h-1 xc-w-1 xc-rounded-full xc-bg-[#2596FF]" }),
    "Installed"
  ] }) : null;
}
function m9(t) {
  var o, a;
  const { wallet: e, onClick: r } = t, n = /* @__PURE__ */ ve.jsx("img", { className: "xc-rounded-md xc-h-5 xc-w-5", src: (o = e.config) == null ? void 0 : o.image }), i = ((a = e.config) == null ? void 0 : a.name) || "", s = Oi(() => Rre(e), [e]);
  return /* @__PURE__ */ ve.jsx(sy, { icon: n, title: i, extra: s, onClick: () => r(e) });
}
function v9(t) {
  return /* @__PURE__ */ ve.jsxs("div", { className: "xc-flex xc-items-center xc-gap-2", children: [
    /* @__PURE__ */ ve.jsx("hr", { className: "xc-flex-1 xc-border-gray-200" }),
    /* @__PURE__ */ ve.jsx("div", { className: "xc-shrink-0", children: t.children }),
    /* @__PURE__ */ ve.jsx("hr", { className: "xc-flex-1 xc-border-gray-200" })
  ] });
}
const Dre = "https://s.xny.ai/xny-connect/wallet-icons.svg?ver=2#codatta-black", Ore = "https://s.xny.ai/xny-connect/wallet-icons.svg#ton";
function Nre(t) {
  const { onClick: e } = t;
  function r() {
    e && e();
  }
  return /* @__PURE__ */ ve.jsx(v9, { children: /* @__PURE__ */ ve.jsxs("div", { className: "xc-flex xc-items-center xc-gap-2 xc-cursor-pointer", onClick: r, children: [
    /* @__PURE__ */ ve.jsx("span", { className: "xc-text-sm", children: "View more wallets" }),
    /* @__PURE__ */ ve.jsx(qS, { size: 16 })
  ] }) });
}
function Lre(t) {
  const [e, r] = Er(""), { featuredWallets: n } = xc(), { onEmailConfirm: i, onSelectWallet: s, onSelectMoreWallets: o, onSelectTonConnect: a, config: u } = t, h = Oi(() => {
    const A = /[\u4e00-\u9fff]|[\u3400-\u4dbf]|[\u{20000}-\u{2a6df}]|[\u{2a700}-\u{2b73f}]|[\u{2b740}-\u{2b81f}]|[\u{2b820}-\u{2ceaf}]|[\uf900-\ufaff]|[\u3300-\u33ff]|[\ufe30-\ufe4f]/gu, I = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return !A.test(e) && I.test(e);
  }, [e]);
  function d(A) {
    s(A);
  }
  function p(A) {
    r(A.target.value);
  }
  async function x() {
    i(e);
  }
  return /* @__PURE__ */ ve.jsxs(Ec, { children: [
    /* @__PURE__ */ ve.jsxs("div", { className: "xc-mb-8", children: [
      /* @__PURE__ */ ve.jsx("img", { className: "xc-mb-3 xc-h-8", src: Dre, alt: "" }),
      /* @__PURE__ */ ve.jsxs("h1", { className: "xc-text-lg xc-font-bold", children: [
        u.title || "Log in to codatta",
        " "
      ] })
    ] }),
    u.showEmailSignIn && /* @__PURE__ */ ve.jsxs("div", { className: "xc-mb-4", children: [
      /* @__PURE__ */ ve.jsx("input", { className: "xc-w-full xc-border xc-h-10 xc-rounded-lg xc-px-3 xc-mb-3", placeholder: "Enter your email", type: "email", onChange: p }),
      /* @__PURE__ */ ve.jsx("button", { disabled: !h, className: "xc-bg-[rgb(135,93,255)] xc-text-white xc-w-full xc-rounded-lg xc-py-2 disabled:xc-opacity-45", onClick: x, children: "Continue" })
    ] }),
    /* @__PURE__ */ ve.jsxs("div", { children: [
      /* @__PURE__ */ ve.jsx("div", { className: "xc-mb-4", children: /* @__PURE__ */ ve.jsxs(v9, { children: [
        " ",
        /* @__PURE__ */ ve.jsx("span", { className: "xc-text-sm", children: "OR" })
      ] }) }),
      /* @__PURE__ */ ve.jsxs("div", { className: "xc-mb-4 xc-flex xc-max-h-[309px] xc-flex-col xc-gap-4 xc-overflow-scroll", children: [
        n && n.map((A) => /* @__PURE__ */ ve.jsx(
          m9,
          {
            wallet: A,
            onClick: d
          },
          `feature-${A.key}`
        )),
        u.showTonConnect && /* @__PURE__ */ ve.jsx(
          sy,
          {
            icon: /* @__PURE__ */ ve.jsx("img", { className: "xc-h-5 xc-w-5", src: Ore }),
            title: "TON Connect",
            onClick: a
          }
        )
      ] }),
      u.showMoreWallets && /* @__PURE__ */ ve.jsx(Nre, { onClick: o })
    ] })
  ] });
}
function uh(t) {
  const { title: e } = t;
  return /* @__PURE__ */ ve.jsxs("div", { className: "xc-flex xc-items-center xc-gap-2", children: [
    /* @__PURE__ */ ve.jsx(JX, { onClick: t.onBack, size: 20, className: "xc-cursor-pointer" }),
    /* @__PURE__ */ ve.jsx("span", { children: e })
  ] });
}
var kre = Object.defineProperty, $re = Object.defineProperties, Bre = Object.getOwnPropertyDescriptors, E0 = Object.getOwnPropertySymbols, b9 = Object.prototype.hasOwnProperty, y9 = Object.prototype.propertyIsEnumerable, s5 = (t, e, r) => e in t ? kre(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Fre = (t, e) => {
  for (var r in e || (e = {})) b9.call(e, r) && s5(t, r, e[r]);
  if (E0) for (var r of E0(e)) y9.call(e, r) && s5(t, r, e[r]);
  return t;
}, Ure = (t, e) => $re(t, Bre(e)), jre = (t, e) => {
  var r = {};
  for (var n in t) b9.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && E0) for (var n of E0(t)) e.indexOf(n) < 0 && y9.call(t, n) && (r[n] = t[n]);
  return r;
};
function qre(t) {
  let e = setTimeout(t, 0), r = setTimeout(t, 10), n = setTimeout(t, 50);
  return [e, r, n];
}
function zre(t) {
  let e = Gt.useRef();
  return Gt.useEffect(() => {
    e.current = t;
  }), e.current;
}
var Hre = 18, w9 = 40, Wre = `${w9}px`, Kre = ["[data-lastpass-icon-root]", "com-1password-button", "[data-dashlanecreated]", '[style$="2147483647 !important;"]'].join(",");
function Vre({ containerRef: t, inputRef: e, pushPasswordManagerStrategy: r, isFocused: n }) {
  let [i, s] = Gt.useState(!1), [o, a] = Gt.useState(!1), [u, h] = Gt.useState(!1), d = Gt.useMemo(() => r === "none" ? !1 : (r === "increase-width" || r === "experimental-no-flickering") && i && o, [i, o, r]), p = Gt.useCallback(() => {
    let x = t.current, A = e.current;
    if (!x || !A || u || r === "none") return;
    let I = x, N = I.getBoundingClientRect().left + I.offsetWidth, L = I.getBoundingClientRect().top + I.offsetHeight / 2, F = N - Hre, $ = L;
    document.querySelectorAll(Kre).length === 0 && document.elementFromPoint(F, $) === x || (s(!0), h(!0));
  }, [t, e, u, r]);
  return Gt.useEffect(() => {
    let x = t.current;
    if (!x || r === "none") return;
    function A() {
      let N = window.innerWidth - x.getBoundingClientRect().right;
      a(N >= w9);
    }
    A();
    let I = setInterval(A, 1e3);
    return () => {
      clearInterval(I);
    };
  }, [t, r]), Gt.useEffect(() => {
    let x = n || document.activeElement === e.current;
    if (r === "none" || !x) return;
    let A = setTimeout(p, 0), I = setTimeout(p, 2e3), N = setTimeout(p, 5e3), L = setTimeout(() => {
      h(!0);
    }, 6e3);
    return () => {
      clearTimeout(A), clearTimeout(I), clearTimeout(N), clearTimeout(L);
    };
  }, [e, n, r, p]), { hasPWMBadge: i, willPushPWMBadge: d, PWM_BADGE_SPACE_WIDTH: Wre };
}
var x9 = Gt.createContext({}), _9 = Gt.forwardRef((t, e) => {
  var r = t, { value: n, onChange: i, maxLength: s, textAlign: o = "left", pattern: a, placeholder: u, inputMode: h = "numeric", onComplete: d, pushPasswordManagerStrategy: p = "increase-width", pasteTransformer: x, containerClassName: A, noScriptCSSFallback: I = Gre, render: N, children: L } = r, F = jre(r, ["value", "onChange", "maxLength", "textAlign", "pattern", "placeholder", "inputMode", "onComplete", "pushPasswordManagerStrategy", "pasteTransformer", "containerClassName", "noScriptCSSFallback", "render", "children"]), $, W, z, V, te;
  let [R, K] = Gt.useState(typeof F.defaultValue == "string" ? F.defaultValue : ""), pe = n ?? R, _e = zre(pe), Y = Gt.useCallback((ie) => {
    i == null || i(ie), K(ie);
  }, [i]), S = Gt.useMemo(() => a ? typeof a == "string" ? new RegExp(a) : a : null, [a]), m = Gt.useRef(null), f = Gt.useRef(null), g = Gt.useRef({ value: pe, onChange: Y, isIOS: typeof window < "u" && ((W = ($ = window == null ? void 0 : window.CSS) == null ? void 0 : $.supports) == null ? void 0 : W.call($, "-webkit-touch-callout", "none")) }), b = Gt.useRef({ prev: [(z = m.current) == null ? void 0 : z.selectionStart, (V = m.current) == null ? void 0 : V.selectionEnd, (te = m.current) == null ? void 0 : te.selectionDirection] });
  Gt.useImperativeHandle(e, () => m.current, []), Gt.useEffect(() => {
    let ie = m.current, ce = f.current;
    if (!ie || !ce) return;
    g.current.value !== ie.value && g.current.onChange(ie.value), b.current.prev = [ie.selectionStart, ie.selectionEnd, ie.selectionDirection];
    function me() {
      if (document.activeElement !== ie) {
        P(null), ue(null);
        return;
      }
      let Ce = ie.selectionStart, $e = ie.selectionEnd, Me = ie.selectionDirection, Ne = ie.maxLength, Ke = ie.value, Le = b.current.prev, qe = -1, ze = -1, Ee;
      if (Ke.length !== 0 && Ce !== null && $e !== null) {
        let Qe = Ce === $e, tt = Ce === Ke.length && Ke.length < Ne;
        if (Qe && !tt) {
          let Ye = Ce;
          if (Ye === 0) qe = 0, ze = 1, Ee = "forward";
          else if (Ye === Ne) qe = Ye - 1, ze = Ye, Ee = "backward";
          else if (Ne > 1 && Ke.length > 1) {
            let dt = 0;
            if (Le[0] !== null && Le[1] !== null) {
              Ee = Ye < Le[1] ? "backward" : "forward";
              let lt = Le[0] === Le[1] && Le[0] < Ne;
              Ee === "backward" && !lt && (dt = -1);
            }
            qe = dt + Ye, ze = dt + Ye + 1;
          }
        }
        qe !== -1 && ze !== -1 && qe !== ze && m.current.setSelectionRange(qe, ze, Ee);
      }
      let Ze = qe !== -1 ? qe : Ce, at = ze !== -1 ? ze : $e, ke = Ee ?? Me;
      P(Ze), ue(at), b.current.prev = [Ze, at, ke];
    }
    if (document.addEventListener("selectionchange", me, { capture: !0 }), me(), document.activeElement === ie && v(!0), !document.getElementById("input-otp-style")) {
      let Ce = document.createElement("style");
      if (Ce.id = "input-otp-style", document.head.appendChild(Ce), Ce.sheet) {
        let $e = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
        Df(Ce.sheet, "[data-input-otp]::selection { background: transparent !important; color: transparent !important; }"), Df(Ce.sheet, `[data-input-otp]:autofill { ${$e} }`), Df(Ce.sheet, `[data-input-otp]:-webkit-autofill { ${$e} }`), Df(Ce.sheet, "@supports (-webkit-touch-callout: none) { [data-input-otp] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"), Df(Ce.sheet, "[data-input-otp] + * { pointer-events: all !important; }");
      }
    }
    let Pe = () => {
      ce && ce.style.setProperty("--root-height", `${ie.clientHeight}px`);
    };
    Pe();
    let De = new ResizeObserver(Pe);
    return De.observe(ie), () => {
      document.removeEventListener("selectionchange", me, { capture: !0 }), De.disconnect();
    };
  }, []);
  let [w, _] = Gt.useState(!1), [E, v] = Gt.useState(!1), [M, P] = Gt.useState(null), [B, ue] = Gt.useState(null);
  Gt.useEffect(() => {
    qre(() => {
      var ie, ce, me, Pe;
      (ie = m.current) == null || ie.dispatchEvent(new Event("input"));
      let De = (ce = m.current) == null ? void 0 : ce.selectionStart, Ce = (me = m.current) == null ? void 0 : me.selectionEnd, $e = (Pe = m.current) == null ? void 0 : Pe.selectionDirection;
      De !== null && Ce !== null && (P(De), ue(Ce), b.current.prev = [De, Ce, $e]);
    });
  }, [pe, E]), Gt.useEffect(() => {
    _e !== void 0 && pe !== _e && _e.length < s && pe.length === s && (d == null || d(pe));
  }, [s, d, _e, pe]);
  let D = Vre({ containerRef: f, inputRef: m, pushPasswordManagerStrategy: p, isFocused: E }), oe = Gt.useCallback((ie) => {
    let ce = ie.currentTarget.value.slice(0, s);
    if (ce.length > 0 && S && !S.test(ce)) {
      ie.preventDefault();
      return;
    }
    typeof _e == "string" && ce.length < _e.length && document.dispatchEvent(new Event("selectionchange")), Y(ce);
  }, [s, Y, _e, S]), Z = Gt.useCallback(() => {
    var ie;
    if (m.current) {
      let ce = Math.min(m.current.value.length, s - 1), me = m.current.value.length;
      (ie = m.current) == null || ie.setSelectionRange(ce, me), P(ce), ue(me);
    }
    v(!0);
  }, [s]), J = Gt.useCallback((ie) => {
    var ce, me;
    let Pe = m.current;
    if (!x && (!g.current.isIOS || !ie.clipboardData || !Pe)) return;
    let De = ie.clipboardData.getData("text/plain"), Ce = x ? x(De) : De;
    console.log({ _content: De, content: Ce }), ie.preventDefault();
    let $e = (ce = m.current) == null ? void 0 : ce.selectionStart, Me = (me = m.current) == null ? void 0 : me.selectionEnd, Ne = ($e !== Me ? pe.slice(0, $e) + Ce + pe.slice(Me) : pe.slice(0, $e) + Ce + pe.slice($e)).slice(0, s);
    if (Ne.length > 0 && S && !S.test(Ne)) return;
    Pe.value = Ne, Y(Ne);
    let Ke = Math.min(Ne.length, s - 1), Le = Ne.length;
    Pe.setSelectionRange(Ke, Le), P(Ke), ue(Le);
  }, [s, Y, S, pe]), Q = Gt.useMemo(() => ({ position: "relative", cursor: F.disabled ? "default" : "text", userSelect: "none", WebkitUserSelect: "none", pointerEvents: "none" }), [F.disabled]), T = Gt.useMemo(() => ({ position: "absolute", inset: 0, width: D.willPushPWMBadge ? `calc(100% + ${D.PWM_BADGE_SPACE_WIDTH})` : "100%", clipPath: D.willPushPWMBadge ? `inset(0 ${D.PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0, height: "100%", display: "flex", textAlign: o, opacity: "1", color: "transparent", pointerEvents: "all", background: "transparent", caretColor: "transparent", border: "0 solid transparent", outline: "0 solid transparent", boxShadow: "none", lineHeight: "1", letterSpacing: "-.5em", fontSize: "var(--root-height)", fontFamily: "monospace", fontVariantNumeric: "tabular-nums" }), [D.PWM_BADGE_SPACE_WIDTH, D.willPushPWMBadge, o]), X = Gt.useMemo(() => Gt.createElement("input", Ure(Fre({ autoComplete: F.autoComplete || "one-time-code" }, F), { "data-input-otp": !0, "data-input-otp-placeholder-shown": pe.length === 0 || void 0, "data-input-otp-mss": M, "data-input-otp-mse": B, inputMode: h, pattern: S == null ? void 0 : S.source, "aria-placeholder": u, style: T, maxLength: s, value: pe, ref: m, onPaste: (ie) => {
    var ce;
    J(ie), (ce = F.onPaste) == null || ce.call(F, ie);
  }, onChange: oe, onMouseOver: (ie) => {
    var ce;
    _(!0), (ce = F.onMouseOver) == null || ce.call(F, ie);
  }, onMouseLeave: (ie) => {
    var ce;
    _(!1), (ce = F.onMouseLeave) == null || ce.call(F, ie);
  }, onFocus: (ie) => {
    var ce;
    Z(), (ce = F.onFocus) == null || ce.call(F, ie);
  }, onBlur: (ie) => {
    var ce;
    v(!1), (ce = F.onBlur) == null || ce.call(F, ie);
  } })), [oe, Z, J, h, T, s, B, M, F, S == null ? void 0 : S.source, pe]), re = Gt.useMemo(() => ({ slots: Array.from({ length: s }).map((ie, ce) => {
    var me;
    let Pe = E && M !== null && B !== null && (M === B && ce === M || ce >= M && ce < B), De = pe[ce] !== void 0 ? pe[ce] : null, Ce = pe[0] !== void 0 ? null : (me = u == null ? void 0 : u[ce]) != null ? me : null;
    return { char: De, placeholderChar: Ce, isActive: Pe, hasFakeCaret: Pe && De === null };
  }), isFocused: E, isHovering: !F.disabled && w }), [E, w, s, B, M, F.disabled, pe]), de = Gt.useMemo(() => N ? N(re) : Gt.createElement(x9.Provider, { value: re }, L), [L, re, N]);
  return Gt.createElement(Gt.Fragment, null, I !== null && Gt.createElement("noscript", null, Gt.createElement("style", null, I)), Gt.createElement("div", { ref: f, "data-input-otp-container": !0, style: Q, className: A }, de, Gt.createElement("div", { style: { position: "absolute", inset: 0, pointerEvents: "none" } }, X)));
});
_9.displayName = "Input";
function Df(t, e) {
  try {
    t.insertRule(e);
  } catch {
    console.error("input-otp could not insert CSS rule:", e);
  }
}
var Gre = `
[data-input-otp] {
  --nojs-bg: white !important;
  --nojs-fg: black !important;

  background-color: var(--nojs-bg) !important;
  color: var(--nojs-fg) !important;
  caret-color: var(--nojs-fg) !important;
  letter-spacing: .25em !important;
  text-align: center !important;
  border: 1px solid var(--nojs-fg) !important;
  border-radius: 4px !important;
  width: 100% !important;
}
@media (prefers-color-scheme: dark) {
  [data-input-otp] {
    --nojs-bg: black !important;
    --nojs-fg: white !important;
  }
}`;
function E9(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number") n += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var i = t.length;
    for (e = 0; e < i; e++) t[e] && (r = E9(t[e])) && (n && (n += " "), n += r);
  } else for (r in t) t[r] && (n && (n += " "), n += r);
  return n;
}
function Yre() {
  for (var t, e, r = 0, n = "", i = arguments.length; r < i; r++) (t = arguments[r]) && (e = E9(t)) && (n && (n += " "), n += e);
  return n;
}
const Jre = Yre, oy = "-", Xre = (t) => {
  const e = Qre(t), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: n
  } = t;
  return {
    getClassGroupId: (o) => {
      const a = o.split(oy);
      return a[0] === "" && a.length !== 1 && a.shift(), S9(a, e) || Zre(o);
    },
    getConflictingClassGroupIds: (o, a) => {
      const u = r[o] || [];
      return a && n[o] ? [...u, ...n[o]] : u;
    }
  };
}, S9 = (t, e) => {
  var o;
  if (t.length === 0)
    return e.classGroupId;
  const r = t[0], n = e.nextPart.get(r), i = n ? S9(t.slice(1), n) : void 0;
  if (i)
    return i;
  if (e.validators.length === 0)
    return;
  const s = t.join(oy);
  return (o = e.validators.find(({
    validator: a
  }) => a(s))) == null ? void 0 : o.classGroupId;
}, o5 = /^\[(.+)\]$/, Zre = (t) => {
  if (o5.test(t)) {
    const e = o5.exec(t)[1], r = e == null ? void 0 : e.substring(0, e.indexOf(":"));
    if (r)
      return "arbitrary.." + r;
  }
}, Qre = (t) => {
  const {
    theme: e,
    prefix: r
  } = t, n = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return tne(Object.entries(t.classGroups), r).forEach(([s, o]) => {
    lv(o, n, s, e);
  }), n;
}, lv = (t, e, r, n) => {
  t.forEach((i) => {
    if (typeof i == "string") {
      const s = i === "" ? e : a5(e, i);
      s.classGroupId = r;
      return;
    }
    if (typeof i == "function") {
      if (ene(i)) {
        lv(i(n), e, r, n);
        return;
      }
      e.validators.push({
        validator: i,
        classGroupId: r
      });
      return;
    }
    Object.entries(i).forEach(([s, o]) => {
      lv(o, a5(e, s), r, n);
    });
  });
}, a5 = (t, e) => {
  let r = t;
  return e.split(oy).forEach((n) => {
    r.nextPart.has(n) || r.nextPart.set(n, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), r = r.nextPart.get(n);
  }), r;
}, ene = (t) => t.isThemeGetter, tne = (t, e) => e ? t.map(([r, n]) => {
  const i = n.map((s) => typeof s == "string" ? e + s : typeof s == "object" ? Object.fromEntries(Object.entries(s).map(([o, a]) => [e + o, a])) : s);
  return [r, i];
}) : t, rne = (t) => {
  if (t < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  const i = (s, o) => {
    r.set(s, o), e++, e > t && (e = 0, n = r, r = /* @__PURE__ */ new Map());
  };
  return {
    get(s) {
      let o = r.get(s);
      if (o !== void 0)
        return o;
      if ((o = n.get(s)) !== void 0)
        return i(s, o), o;
    },
    set(s, o) {
      r.has(s) ? r.set(s, o) : i(s, o);
    }
  };
}, A9 = "!", nne = (t) => {
  const {
    separator: e,
    experimentalParseClassName: r
  } = t, n = e.length === 1, i = e[0], s = e.length, o = (a) => {
    const u = [];
    let h = 0, d = 0, p;
    for (let L = 0; L < a.length; L++) {
      let F = a[L];
      if (h === 0) {
        if (F === i && (n || a.slice(L, L + s) === e)) {
          u.push(a.slice(d, L)), d = L + s;
          continue;
        }
        if (F === "/") {
          p = L;
          continue;
        }
      }
      F === "[" ? h++ : F === "]" && h--;
    }
    const x = u.length === 0 ? a : a.substring(d), A = x.startsWith(A9), I = A ? x.substring(1) : x, N = p && p > d ? p - d : void 0;
    return {
      modifiers: u,
      hasImportantModifier: A,
      baseClassName: I,
      maybePostfixModifierPosition: N
    };
  };
  return r ? (a) => r({
    className: a,
    parseClassName: o
  }) : o;
}, ine = (t) => {
  if (t.length <= 1)
    return t;
  const e = [];
  let r = [];
  return t.forEach((n) => {
    n[0] === "[" ? (e.push(...r.sort(), n), r = []) : r.push(n);
  }), e.push(...r.sort()), e;
}, sne = (t) => ({
  cache: rne(t.cacheSize),
  parseClassName: nne(t),
  ...Xre(t)
}), one = /\s+/, ane = (t, e) => {
  const {
    parseClassName: r,
    getClassGroupId: n,
    getConflictingClassGroupIds: i
  } = e, s = [], o = t.trim().split(one);
  let a = "";
  for (let u = o.length - 1; u >= 0; u -= 1) {
    const h = o[u], {
      modifiers: d,
      hasImportantModifier: p,
      baseClassName: x,
      maybePostfixModifierPosition: A
    } = r(h);
    let I = !!A, N = n(I ? x.substring(0, A) : x);
    if (!N) {
      if (!I) {
        a = h + (a.length > 0 ? " " + a : a);
        continue;
      }
      if (N = n(x), !N) {
        a = h + (a.length > 0 ? " " + a : a);
        continue;
      }
      I = !1;
    }
    const L = ine(d).join(":"), F = p ? L + A9 : L, $ = F + N;
    if (s.includes($))
      continue;
    s.push($);
    const W = i(N, I);
    for (let z = 0; z < W.length; ++z) {
      const V = W[z];
      s.push(F + V);
    }
    a = h + (a.length > 0 ? " " + a : a);
  }
  return a;
};
function cne() {
  let t = 0, e, r, n = "";
  for (; t < arguments.length; )
    (e = arguments[t++]) && (r = P9(e)) && (n && (n += " "), n += r);
  return n;
}
const P9 = (t) => {
  if (typeof t == "string")
    return t;
  let e, r = "";
  for (let n = 0; n < t.length; n++)
    t[n] && (e = P9(t[n])) && (r && (r += " "), r += e);
  return r;
};
function une(t, ...e) {
  let r, n, i, s = o;
  function o(u) {
    const h = e.reduce((d, p) => p(d), t());
    return r = sne(h), n = r.cache.get, i = r.cache.set, s = a, a(u);
  }
  function a(u) {
    const h = n(u);
    if (h)
      return h;
    const d = ane(u, r);
    return i(u, d), d;
  }
  return function() {
    return s(cne.apply(null, arguments));
  };
}
const Gr = (t) => {
  const e = (r) => r[t] || [];
  return e.isThemeGetter = !0, e;
}, M9 = /^\[(?:([a-z-]+):)?(.+)\]$/i, fne = /^\d+\/\d+$/, lne = /* @__PURE__ */ new Set(["px", "full", "screen"]), hne = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, dne = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, pne = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, gne = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, mne = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, mo = (t) => pu(t) || lne.has(t) || fne.test(t), ea = (t) => Ku(t, "length", Sne), pu = (t) => !!t && !Number.isNaN(Number(t)), Wm = (t) => Ku(t, "number", pu), Of = (t) => !!t && Number.isInteger(Number(t)), vne = (t) => t.endsWith("%") && pu(t.slice(0, -1)), cr = (t) => M9.test(t), ta = (t) => hne.test(t), bne = /* @__PURE__ */ new Set(["length", "size", "percentage"]), yne = (t) => Ku(t, bne, I9), wne = (t) => Ku(t, "position", I9), xne = /* @__PURE__ */ new Set(["image", "url"]), _ne = (t) => Ku(t, xne, Pne), Ene = (t) => Ku(t, "", Ane), Nf = () => !0, Ku = (t, e, r) => {
  const n = M9.exec(t);
  return n ? n[1] ? typeof e == "string" ? n[1] === e : e.has(n[1]) : r(n[2]) : !1;
}, Sne = (t) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  dne.test(t) && !pne.test(t)
), I9 = () => !1, Ane = (t) => gne.test(t), Pne = (t) => mne.test(t), Mne = () => {
  const t = Gr("colors"), e = Gr("spacing"), r = Gr("blur"), n = Gr("brightness"), i = Gr("borderColor"), s = Gr("borderRadius"), o = Gr("borderSpacing"), a = Gr("borderWidth"), u = Gr("contrast"), h = Gr("grayscale"), d = Gr("hueRotate"), p = Gr("invert"), x = Gr("gap"), A = Gr("gradientColorStops"), I = Gr("gradientColorStopPositions"), N = Gr("inset"), L = Gr("margin"), F = Gr("opacity"), $ = Gr("padding"), W = Gr("saturate"), z = Gr("scale"), V = Gr("sepia"), te = Gr("skew"), R = Gr("space"), K = Gr("translate"), pe = () => ["auto", "contain", "none"], _e = () => ["auto", "hidden", "clip", "visible", "scroll"], Y = () => ["auto", cr, e], S = () => [cr, e], m = () => ["", mo, ea], f = () => ["auto", pu, cr], g = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], b = () => ["solid", "dashed", "dotted", "double", "none"], w = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], _ = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], E = () => ["", "0", cr], v = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], M = () => [pu, cr];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Nf],
      spacing: [mo, ea],
      blur: ["none", "", ta, cr],
      brightness: M(),
      borderColor: [t],
      borderRadius: ["none", "", "full", ta, cr],
      borderSpacing: S(),
      borderWidth: m(),
      contrast: M(),
      grayscale: E(),
      hueRotate: M(),
      invert: E(),
      gap: S(),
      gradientColorStops: [t],
      gradientColorStopPositions: [vne, ea],
      inset: Y(),
      margin: Y(),
      opacity: M(),
      padding: S(),
      saturate: M(),
      scale: M(),
      sepia: E(),
      skew: M(),
      space: S(),
      translate: S()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", cr]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [ta]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": v()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": v()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...g(), cr]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: _e()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": _e()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": _e()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: pe()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": pe()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": pe()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [N]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [N]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [N]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [N]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [N]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [N]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [N]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [N]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [N]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Of, cr]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: Y()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", cr]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: E()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: E()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Of, cr]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Nf]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Of, cr]
        }, cr]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": f()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": f()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Nf]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Of, cr]
        }, cr]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": f()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": f()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", cr]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", cr]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [x]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [x]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [x]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ..._()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ..._(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [..._(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [$]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [$]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [$]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [$]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [$]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [$]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [$]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [$]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [$]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [L]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [L]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [L]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [L]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [L]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [L]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [L]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [L]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [L]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [R]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [R]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", cr, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [cr, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [cr, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [ta]
        }, ta]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [cr, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [cr, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [cr, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [cr, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", ta, ea]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Wm]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Nf]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", cr]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", pu, Wm]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", mo, cr]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", cr]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", cr]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [t]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [F]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [t]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [F]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...b(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", mo, ea]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", mo, cr]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [t]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: S()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", cr]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", cr]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [F]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...g(), wne]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", yne]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, _ne]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [t]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [I]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [I]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [I]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [A]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [A]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [A]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [s]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [s]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [s]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [s]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [s]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [s]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [s]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [s]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [s]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [s]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [s]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [s]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [s]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [s]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [s]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [a]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [a]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [a]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [a]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [a]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [a]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [a]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [a]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [a]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [F]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...b(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [a]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [a]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [F]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: b()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [i]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [i]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [i]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [i]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [i]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [i]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [i]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [i]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [i]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [i]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...b()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [mo, cr]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [mo, ea]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [t]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: m()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [t]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [F]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [mo, ea]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [t]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", ta, Ene]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Nf]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [F]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...w(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": w()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [r]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [n]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [u]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", ta, cr]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [h]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [d]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [p]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [W]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [V]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [r]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [n]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [u]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [h]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [d]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [p]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [F]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [W]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [V]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [o]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [o]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [o]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", cr]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: M()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", cr]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: M()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", cr]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [z]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [z]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [z]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Of, cr]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [K]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [K]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [te]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [te]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", cr]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", t]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", cr]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [t]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": S()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": S()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": S()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": S()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": S()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": S()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": S()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": S()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": S()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": S()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": S()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": S()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": S()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": S()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": S()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": S()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": S()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": S()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", cr]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [t, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [mo, ea, Wm]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [t, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, Ine = /* @__PURE__ */ une(Mne);
function S0(...t) {
  return Ine(Jre(t));
}
const C9 = Gt.forwardRef(({ className: t, containerClassName: e, ...r }, n) => /* @__PURE__ */ ve.jsx(
  _9,
  {
    ref: n,
    containerClassName: S0(
      "xc-flex xc-items-center xc-gap-2 xc-has-[:disabled]:opacity-50",
      e
    ),
    className: S0("xc-disabled:cursor-not-allowed", t),
    ...r
  }
));
C9.displayName = "InputOTP";
const T9 = Gt.forwardRef(({ className: t, ...e }, r) => /* @__PURE__ */ ve.jsx("div", { ref: r, className: S0("xc-flex xc-items-center", t), ...e }));
T9.displayName = "InputOTPGroup";
const Va = Gt.forwardRef(({ index: t, className: e, ...r }, n) => {
  const i = Gt.useContext(x9), { char: s, hasFakeCaret: o, isActive: a } = i.slots[t];
  return /* @__PURE__ */ ve.jsxs(
    "div",
    {
      ref: n,
      className: S0(
        "xc-relative xc-rounded-xl xc-mx-1 xc-text-2xl xc-flex xc-h-12 xc-w-12 xc-items-center xc-justify-center xc-border-y xc-border xc-border-input xc-transition-all",
        a && "xc-z-10 xc-ring-2 xc-ring-ring xc-ring-offset-background",
        e
      ),
      ...r,
      children: [
        s,
        o && /* @__PURE__ */ ve.jsx("div", { className: "xc-pointer-events-none xc-absolute xc-inset-0 xc-flex xc-items-center xc-justify-center", children: /* @__PURE__ */ ve.jsx("div", { className: "xc-h-4 xc-w-px xc-animate-caret-blink xc-bg-foreground xc-duration-1000" }) })
      ]
    }
  );
});
Va.displayName = "InputOTPSlot";
function Cne(t) {
  const { spinning: e, children: r } = t;
  return /* @__PURE__ */ ve.jsxs("div", { className: "xc-inline-block xc-relative", children: [
    r,
    e && /* @__PURE__ */ ve.jsx("div", { className: "xc-absolute xc-top-0 xc-left-0 xc-w-full xc-h-full xc-bg-white xc-bg-opacity-40 xc-flex xc-items-center xc-justify-center", children: /* @__PURE__ */ ve.jsx(Pl, { className: "xc-animate-spin" }) })
  ] });
}
function Tne(t) {
  const { email: e } = t, [r, n] = Er(0), [i, s] = Er(!1), [o, a] = Er(""), { config: u } = xc();
  async function h() {
    n(10);
    const x = setInterval(() => {
      n((A) => A === 0 ? (clearInterval(x), 0) : A - 1);
    }, 1e3);
  }
  async function d(x) {
    s(!0);
    try {
      await va.getEmailCode({ account_type: "email", email: x }), h();
    } catch (A) {
      a(A.message);
    }
    s(!1);
  }
  si(() => {
    e && d(e);
  }, [e]);
  async function p(x) {
    if (a(""), !(x.length < 6)) {
      s(!0);
      try {
        const A = await va.emailLogin({
          account_type: "email",
          connector: "codatta_email",
          account_enum: "C",
          email_code: x,
          email: e,
          inviter_code: u.inviderCode,
          source: {
            device: u.device,
            channel: u.channel,
            app: u.app
          },
          related_info: u.relateInfo
        });
        t.onLogin(A.data);
      } catch (A) {
        a(A.message);
      }
      s(!1);
    }
  }
  return /* @__PURE__ */ ve.jsxs(Ec, { children: [
    /* @__PURE__ */ ve.jsx("div", { className: "xc-mb-12", children: /* @__PURE__ */ ve.jsx(uh, { title: "Sign in with email", onBack: t.onBack }) }),
    /* @__PURE__ */ ve.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center xc-justify-center xc-mb-12", children: [
      /* @__PURE__ */ ve.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center xc-justify-center xc-mb-8", children: [
        /* @__PURE__ */ ve.jsx(nZ, { className: "xc-mb-4", size: 60 }),
        /* @__PURE__ */ ve.jsx("p", { className: "xc-text-lg xc-mb-1", children: "We’ve sent a verification code to" }),
        /* @__PURE__ */ ve.jsx("p", { className: "xc-font-bold", children: e })
      ] }),
      /* @__PURE__ */ ve.jsx("div", { className: "xc-mb-2 xc-h-12", children: /* @__PURE__ */ ve.jsx(Cne, { spinning: i, children: /* @__PURE__ */ ve.jsx(C9, { maxLength: 6, onChange: p, disabled: i, children: /* @__PURE__ */ ve.jsxs(T9, { children: [
        /* @__PURE__ */ ve.jsx(Va, { index: 0 }),
        /* @__PURE__ */ ve.jsx(Va, { index: 1 }),
        /* @__PURE__ */ ve.jsx(Va, { index: 2 }),
        /* @__PURE__ */ ve.jsx(Va, { index: 3 }),
        /* @__PURE__ */ ve.jsx(Va, { index: 4 }),
        /* @__PURE__ */ ve.jsx(Va, { index: 5 })
      ] }) }) }) }),
      o && /* @__PURE__ */ ve.jsx("div", { className: "xc-text-[#ff0000]", children: /* @__PURE__ */ ve.jsx("p", { children: o }) })
    ] }),
    /* @__PURE__ */ ve.jsxs("div", { className: "xc-text-center xc-text-sm xc-text-gray-400", children: [
      "Not get it? ",
      r ? `Recend in ${r}s` : /* @__PURE__ */ ve.jsx("button", { onClick: () => d(e), children: "Send again" })
    ] })
  ] });
}
var R9 = { exports: {} };
(function(t, e) {
  (function(r, n) {
    t.exports = n();
  })(gn, () => (() => {
    var r = { 873: (o, a) => {
      var u, h, d = function() {
        var p = function(f, g) {
          var b = f, w = F[g], _ = null, E = 0, v = null, M = [], P = {}, B = function(re, de) {
            _ = function(ie) {
              for (var ce = new Array(ie), me = 0; me < ie; me += 1) {
                ce[me] = new Array(ie);
                for (var Pe = 0; Pe < ie; Pe += 1) ce[me][Pe] = null;
              }
              return ce;
            }(E = 4 * b + 17), ue(0, 0), ue(E - 7, 0), ue(0, E - 7), oe(), D(), J(re, de), b >= 7 && Z(re), v == null && (v = T(b, w, M)), Q(v, de);
          }, ue = function(re, de) {
            for (var ie = -1; ie <= 7; ie += 1) if (!(re + ie <= -1 || E <= re + ie)) for (var ce = -1; ce <= 7; ce += 1) de + ce <= -1 || E <= de + ce || (_[re + ie][de + ce] = 0 <= ie && ie <= 6 && (ce == 0 || ce == 6) || 0 <= ce && ce <= 6 && (ie == 0 || ie == 6) || 2 <= ie && ie <= 4 && 2 <= ce && ce <= 4);
          }, D = function() {
            for (var re = 8; re < E - 8; re += 1) _[re][6] == null && (_[re][6] = re % 2 == 0);
            for (var de = 8; de < E - 8; de += 1) _[6][de] == null && (_[6][de] = de % 2 == 0);
          }, oe = function() {
            for (var re = $.getPatternPosition(b), de = 0; de < re.length; de += 1) for (var ie = 0; ie < re.length; ie += 1) {
              var ce = re[de], me = re[ie];
              if (_[ce][me] == null) for (var Pe = -2; Pe <= 2; Pe += 1) for (var De = -2; De <= 2; De += 1) _[ce + Pe][me + De] = Pe == -2 || Pe == 2 || De == -2 || De == 2 || Pe == 0 && De == 0;
            }
          }, Z = function(re) {
            for (var de = $.getBCHTypeNumber(b), ie = 0; ie < 18; ie += 1) {
              var ce = !re && (de >> ie & 1) == 1;
              _[Math.floor(ie / 3)][ie % 3 + E - 8 - 3] = ce;
            }
            for (ie = 0; ie < 18; ie += 1) ce = !re && (de >> ie & 1) == 1, _[ie % 3 + E - 8 - 3][Math.floor(ie / 3)] = ce;
          }, J = function(re, de) {
            for (var ie = w << 3 | de, ce = $.getBCHTypeInfo(ie), me = 0; me < 15; me += 1) {
              var Pe = !re && (ce >> me & 1) == 1;
              me < 6 ? _[me][8] = Pe : me < 8 ? _[me + 1][8] = Pe : _[E - 15 + me][8] = Pe;
            }
            for (me = 0; me < 15; me += 1) Pe = !re && (ce >> me & 1) == 1, me < 8 ? _[8][E - me - 1] = Pe : me < 9 ? _[8][15 - me - 1 + 1] = Pe : _[8][15 - me - 1] = Pe;
            _[E - 8][8] = !re;
          }, Q = function(re, de) {
            for (var ie = -1, ce = E - 1, me = 7, Pe = 0, De = $.getMaskFunction(de), Ce = E - 1; Ce > 0; Ce -= 2) for (Ce == 6 && (Ce -= 1); ; ) {
              for (var $e = 0; $e < 2; $e += 1) if (_[ce][Ce - $e] == null) {
                var Me = !1;
                Pe < re.length && (Me = (re[Pe] >>> me & 1) == 1), De(ce, Ce - $e) && (Me = !Me), _[ce][Ce - $e] = Me, (me -= 1) == -1 && (Pe += 1, me = 7);
              }
              if ((ce += ie) < 0 || E <= ce) {
                ce -= ie, ie = -ie;
                break;
              }
            }
          }, T = function(re, de, ie) {
            for (var ce = V.getRSBlocks(re, de), me = te(), Pe = 0; Pe < ie.length; Pe += 1) {
              var De = ie[Pe];
              me.put(De.getMode(), 4), me.put(De.getLength(), $.getLengthInBits(De.getMode(), re)), De.write(me);
            }
            var Ce = 0;
            for (Pe = 0; Pe < ce.length; Pe += 1) Ce += ce[Pe].dataCount;
            if (me.getLengthInBits() > 8 * Ce) throw "code length overflow. (" + me.getLengthInBits() + ">" + 8 * Ce + ")";
            for (me.getLengthInBits() + 4 <= 8 * Ce && me.put(0, 4); me.getLengthInBits() % 8 != 0; ) me.putBit(!1);
            for (; !(me.getLengthInBits() >= 8 * Ce || (me.put(236, 8), me.getLengthInBits() >= 8 * Ce)); ) me.put(17, 8);
            return function($e, Me) {
              for (var Ne = 0, Ke = 0, Le = 0, qe = new Array(Me.length), ze = new Array(Me.length), Ee = 0; Ee < Me.length; Ee += 1) {
                var Ze = Me[Ee].dataCount, at = Me[Ee].totalCount - Ze;
                Ke = Math.max(Ke, Ze), Le = Math.max(Le, at), qe[Ee] = new Array(Ze);
                for (var ke = 0; ke < qe[Ee].length; ke += 1) qe[Ee][ke] = 255 & $e.getBuffer()[ke + Ne];
                Ne += Ze;
                var Qe = $.getErrorCorrectPolynomial(at), tt = z(qe[Ee], Qe.getLength() - 1).mod(Qe);
                for (ze[Ee] = new Array(Qe.getLength() - 1), ke = 0; ke < ze[Ee].length; ke += 1) {
                  var Ye = ke + tt.getLength() - ze[Ee].length;
                  ze[Ee][ke] = Ye >= 0 ? tt.getAt(Ye) : 0;
                }
              }
              var dt = 0;
              for (ke = 0; ke < Me.length; ke += 1) dt += Me[ke].totalCount;
              var lt = new Array(dt), ct = 0;
              for (ke = 0; ke < Ke; ke += 1) for (Ee = 0; Ee < Me.length; Ee += 1) ke < qe[Ee].length && (lt[ct] = qe[Ee][ke], ct += 1);
              for (ke = 0; ke < Le; ke += 1) for (Ee = 0; Ee < Me.length; Ee += 1) ke < ze[Ee].length && (lt[ct] = ze[Ee][ke], ct += 1);
              return lt;
            }(me, ce);
          };
          P.addData = function(re, de) {
            var ie = null;
            switch (de = de || "Byte") {
              case "Numeric":
                ie = R(re);
                break;
              case "Alphanumeric":
                ie = K(re);
                break;
              case "Byte":
                ie = pe(re);
                break;
              case "Kanji":
                ie = _e(re);
                break;
              default:
                throw "mode:" + de;
            }
            M.push(ie), v = null;
          }, P.isDark = function(re, de) {
            if (re < 0 || E <= re || de < 0 || E <= de) throw re + "," + de;
            return _[re][de];
          }, P.getModuleCount = function() {
            return E;
          }, P.make = function() {
            if (b < 1) {
              for (var re = 1; re < 40; re++) {
                for (var de = V.getRSBlocks(re, w), ie = te(), ce = 0; ce < M.length; ce++) {
                  var me = M[ce];
                  ie.put(me.getMode(), 4), ie.put(me.getLength(), $.getLengthInBits(me.getMode(), re)), me.write(ie);
                }
                var Pe = 0;
                for (ce = 0; ce < de.length; ce++) Pe += de[ce].dataCount;
                if (ie.getLengthInBits() <= 8 * Pe) break;
              }
              b = re;
            }
            B(!1, function() {
              for (var De = 0, Ce = 0, $e = 0; $e < 8; $e += 1) {
                B(!0, $e);
                var Me = $.getLostPoint(P);
                ($e == 0 || De > Me) && (De = Me, Ce = $e);
              }
              return Ce;
            }());
          }, P.createTableTag = function(re, de) {
            re = re || 2;
            var ie = "";
            ie += '<table style="', ie += " border-width: 0px; border-style: none;", ie += " border-collapse: collapse;", ie += " padding: 0px; margin: " + (de = de === void 0 ? 4 * re : de) + "px;", ie += '">', ie += "<tbody>";
            for (var ce = 0; ce < P.getModuleCount(); ce += 1) {
              ie += "<tr>";
              for (var me = 0; me < P.getModuleCount(); me += 1) ie += '<td style="', ie += " border-width: 0px; border-style: none;", ie += " border-collapse: collapse;", ie += " padding: 0px; margin: 0px;", ie += " width: " + re + "px;", ie += " height: " + re + "px;", ie += " background-color: ", ie += P.isDark(ce, me) ? "#000000" : "#ffffff", ie += ";", ie += '"/>';
              ie += "</tr>";
            }
            return (ie += "</tbody>") + "</table>";
          }, P.createSvgTag = function(re, de, ie, ce) {
            var me = {};
            typeof arguments[0] == "object" && (re = (me = arguments[0]).cellSize, de = me.margin, ie = me.alt, ce = me.title), re = re || 2, de = de === void 0 ? 4 * re : de, (ie = typeof ie == "string" ? { text: ie } : ie || {}).text = ie.text || null, ie.id = ie.text ? ie.id || "qrcode-description" : null, (ce = typeof ce == "string" ? { text: ce } : ce || {}).text = ce.text || null, ce.id = ce.text ? ce.id || "qrcode-title" : null;
            var Pe, De, Ce, $e, Me = P.getModuleCount() * re + 2 * de, Ne = "";
            for ($e = "l" + re + ",0 0," + re + " -" + re + ",0 0,-" + re + "z ", Ne += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"', Ne += me.scalable ? "" : ' width="' + Me + 'px" height="' + Me + 'px"', Ne += ' viewBox="0 0 ' + Me + " " + Me + '" ', Ne += ' preserveAspectRatio="xMinYMin meet"', Ne += ce.text || ie.text ? ' role="img" aria-labelledby="' + X([ce.id, ie.id].join(" ").trim()) + '"' : "", Ne += ">", Ne += ce.text ? '<title id="' + X(ce.id) + '">' + X(ce.text) + "</title>" : "", Ne += ie.text ? '<description id="' + X(ie.id) + '">' + X(ie.text) + "</description>" : "", Ne += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>', Ne += '<path d="', De = 0; De < P.getModuleCount(); De += 1) for (Ce = De * re + de, Pe = 0; Pe < P.getModuleCount(); Pe += 1) P.isDark(De, Pe) && (Ne += "M" + (Pe * re + de) + "," + Ce + $e);
            return (Ne += '" stroke="transparent" fill="black"/>') + "</svg>";
          }, P.createDataURL = function(re, de) {
            re = re || 2, de = de === void 0 ? 4 * re : de;
            var ie = P.getModuleCount() * re + 2 * de, ce = de, me = ie - de;
            return m(ie, ie, function(Pe, De) {
              if (ce <= Pe && Pe < me && ce <= De && De < me) {
                var Ce = Math.floor((Pe - ce) / re), $e = Math.floor((De - ce) / re);
                return P.isDark($e, Ce) ? 0 : 1;
              }
              return 1;
            });
          }, P.createImgTag = function(re, de, ie) {
            re = re || 2, de = de === void 0 ? 4 * re : de;
            var ce = P.getModuleCount() * re + 2 * de, me = "";
            return me += "<img", me += ' src="', me += P.createDataURL(re, de), me += '"', me += ' width="', me += ce, me += '"', me += ' height="', me += ce, me += '"', ie && (me += ' alt="', me += X(ie), me += '"'), me + "/>";
          };
          var X = function(re) {
            for (var de = "", ie = 0; ie < re.length; ie += 1) {
              var ce = re.charAt(ie);
              switch (ce) {
                case "<":
                  de += "&lt;";
                  break;
                case ">":
                  de += "&gt;";
                  break;
                case "&":
                  de += "&amp;";
                  break;
                case '"':
                  de += "&quot;";
                  break;
                default:
                  de += ce;
              }
            }
            return de;
          };
          return P.createASCII = function(re, de) {
            if ((re = re || 1) < 2) return function(qe) {
              qe = qe === void 0 ? 2 : qe;
              var ze, Ee, Ze, at, ke, Qe = 1 * P.getModuleCount() + 2 * qe, tt = qe, Ye = Qe - qe, dt = { "██": "█", "█ ": "▀", " █": "▄", "  ": " " }, lt = { "██": "▀", "█ ": "▀", " █": " ", "  ": " " }, ct = "";
              for (ze = 0; ze < Qe; ze += 2) {
                for (Ze = Math.floor((ze - tt) / 1), at = Math.floor((ze + 1 - tt) / 1), Ee = 0; Ee < Qe; Ee += 1) ke = "█", tt <= Ee && Ee < Ye && tt <= ze && ze < Ye && P.isDark(Ze, Math.floor((Ee - tt) / 1)) && (ke = " "), tt <= Ee && Ee < Ye && tt <= ze + 1 && ze + 1 < Ye && P.isDark(at, Math.floor((Ee - tt) / 1)) ? ke += " " : ke += "█", ct += qe < 1 && ze + 1 >= Ye ? lt[ke] : dt[ke];
                ct += `
`;
              }
              return Qe % 2 && qe > 0 ? ct.substring(0, ct.length - Qe - 1) + Array(Qe + 1).join("▀") : ct.substring(0, ct.length - 1);
            }(de);
            re -= 1, de = de === void 0 ? 2 * re : de;
            var ie, ce, me, Pe, De = P.getModuleCount() * re + 2 * de, Ce = de, $e = De - de, Me = Array(re + 1).join("██"), Ne = Array(re + 1).join("  "), Ke = "", Le = "";
            for (ie = 0; ie < De; ie += 1) {
              for (me = Math.floor((ie - Ce) / re), Le = "", ce = 0; ce < De; ce += 1) Pe = 1, Ce <= ce && ce < $e && Ce <= ie && ie < $e && P.isDark(me, Math.floor((ce - Ce) / re)) && (Pe = 0), Le += Pe ? Me : Ne;
              for (me = 0; me < re; me += 1) Ke += Le + `
`;
            }
            return Ke.substring(0, Ke.length - 1);
          }, P.renderTo2dContext = function(re, de) {
            de = de || 2;
            for (var ie = P.getModuleCount(), ce = 0; ce < ie; ce++) for (var me = 0; me < ie; me++) re.fillStyle = P.isDark(ce, me) ? "black" : "white", re.fillRect(ce * de, me * de, de, de);
          }, P;
        };
        p.stringToBytes = (p.stringToBytesFuncs = { default: function(f) {
          for (var g = [], b = 0; b < f.length; b += 1) {
            var w = f.charCodeAt(b);
            g.push(255 & w);
          }
          return g;
        } }).default, p.createStringToBytes = function(f, g) {
          var b = function() {
            for (var _ = S(f), E = function() {
              var D = _.read();
              if (D == -1) throw "eof";
              return D;
            }, v = 0, M = {}; ; ) {
              var P = _.read();
              if (P == -1) break;
              var B = E(), ue = E() << 8 | E();
              M[String.fromCharCode(P << 8 | B)] = ue, v += 1;
            }
            if (v != g) throw v + " != " + g;
            return M;
          }(), w = 63;
          return function(_) {
            for (var E = [], v = 0; v < _.length; v += 1) {
              var M = _.charCodeAt(v);
              if (M < 128) E.push(M);
              else {
                var P = b[_.charAt(v)];
                typeof P == "number" ? (255 & P) == P ? E.push(P) : (E.push(P >>> 8), E.push(255 & P)) : E.push(w);
              }
            }
            return E;
          };
        };
        var x, A, I, N, L, F = { L: 1, M: 0, Q: 3, H: 2 }, $ = (x = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], A = 1335, I = 7973, L = function(f) {
          for (var g = 0; f != 0; ) g += 1, f >>>= 1;
          return g;
        }, (N = {}).getBCHTypeInfo = function(f) {
          for (var g = f << 10; L(g) - L(A) >= 0; ) g ^= A << L(g) - L(A);
          return 21522 ^ (f << 10 | g);
        }, N.getBCHTypeNumber = function(f) {
          for (var g = f << 12; L(g) - L(I) >= 0; ) g ^= I << L(g) - L(I);
          return f << 12 | g;
        }, N.getPatternPosition = function(f) {
          return x[f - 1];
        }, N.getMaskFunction = function(f) {
          switch (f) {
            case 0:
              return function(g, b) {
                return (g + b) % 2 == 0;
              };
            case 1:
              return function(g, b) {
                return g % 2 == 0;
              };
            case 2:
              return function(g, b) {
                return b % 3 == 0;
              };
            case 3:
              return function(g, b) {
                return (g + b) % 3 == 0;
              };
            case 4:
              return function(g, b) {
                return (Math.floor(g / 2) + Math.floor(b / 3)) % 2 == 0;
              };
            case 5:
              return function(g, b) {
                return g * b % 2 + g * b % 3 == 0;
              };
            case 6:
              return function(g, b) {
                return (g * b % 2 + g * b % 3) % 2 == 0;
              };
            case 7:
              return function(g, b) {
                return (g * b % 3 + (g + b) % 2) % 2 == 0;
              };
            default:
              throw "bad maskPattern:" + f;
          }
        }, N.getErrorCorrectPolynomial = function(f) {
          for (var g = z([1], 0), b = 0; b < f; b += 1) g = g.multiply(z([1, W.gexp(b)], 0));
          return g;
        }, N.getLengthInBits = function(f, g) {
          if (1 <= g && g < 10) switch (f) {
            case 1:
              return 10;
            case 2:
              return 9;
            case 4:
            case 8:
              return 8;
            default:
              throw "mode:" + f;
          }
          else if (g < 27) switch (f) {
            case 1:
              return 12;
            case 2:
              return 11;
            case 4:
              return 16;
            case 8:
              return 10;
            default:
              throw "mode:" + f;
          }
          else {
            if (!(g < 41)) throw "type:" + g;
            switch (f) {
              case 1:
                return 14;
              case 2:
                return 13;
              case 4:
                return 16;
              case 8:
                return 12;
              default:
                throw "mode:" + f;
            }
          }
        }, N.getLostPoint = function(f) {
          for (var g = f.getModuleCount(), b = 0, w = 0; w < g; w += 1) for (var _ = 0; _ < g; _ += 1) {
            for (var E = 0, v = f.isDark(w, _), M = -1; M <= 1; M += 1) if (!(w + M < 0 || g <= w + M)) for (var P = -1; P <= 1; P += 1) _ + P < 0 || g <= _ + P || M == 0 && P == 0 || v == f.isDark(w + M, _ + P) && (E += 1);
            E > 5 && (b += 3 + E - 5);
          }
          for (w = 0; w < g - 1; w += 1) for (_ = 0; _ < g - 1; _ += 1) {
            var B = 0;
            f.isDark(w, _) && (B += 1), f.isDark(w + 1, _) && (B += 1), f.isDark(w, _ + 1) && (B += 1), f.isDark(w + 1, _ + 1) && (B += 1), B != 0 && B != 4 || (b += 3);
          }
          for (w = 0; w < g; w += 1) for (_ = 0; _ < g - 6; _ += 1) f.isDark(w, _) && !f.isDark(w, _ + 1) && f.isDark(w, _ + 2) && f.isDark(w, _ + 3) && f.isDark(w, _ + 4) && !f.isDark(w, _ + 5) && f.isDark(w, _ + 6) && (b += 40);
          for (_ = 0; _ < g; _ += 1) for (w = 0; w < g - 6; w += 1) f.isDark(w, _) && !f.isDark(w + 1, _) && f.isDark(w + 2, _) && f.isDark(w + 3, _) && f.isDark(w + 4, _) && !f.isDark(w + 5, _) && f.isDark(w + 6, _) && (b += 40);
          var ue = 0;
          for (_ = 0; _ < g; _ += 1) for (w = 0; w < g; w += 1) f.isDark(w, _) && (ue += 1);
          return b + Math.abs(100 * ue / g / g - 50) / 5 * 10;
        }, N), W = function() {
          for (var f = new Array(256), g = new Array(256), b = 0; b < 8; b += 1) f[b] = 1 << b;
          for (b = 8; b < 256; b += 1) f[b] = f[b - 4] ^ f[b - 5] ^ f[b - 6] ^ f[b - 8];
          for (b = 0; b < 255; b += 1) g[f[b]] = b;
          return { glog: function(w) {
            if (w < 1) throw "glog(" + w + ")";
            return g[w];
          }, gexp: function(w) {
            for (; w < 0; ) w += 255;
            for (; w >= 256; ) w -= 255;
            return f[w];
          } };
        }();
        function z(f, g) {
          if (f.length === void 0) throw f.length + "/" + g;
          var b = function() {
            for (var _ = 0; _ < f.length && f[_] == 0; ) _ += 1;
            for (var E = new Array(f.length - _ + g), v = 0; v < f.length - _; v += 1) E[v] = f[v + _];
            return E;
          }(), w = { getAt: function(_) {
            return b[_];
          }, getLength: function() {
            return b.length;
          }, multiply: function(_) {
            for (var E = new Array(w.getLength() + _.getLength() - 1), v = 0; v < w.getLength(); v += 1) for (var M = 0; M < _.getLength(); M += 1) E[v + M] ^= W.gexp(W.glog(w.getAt(v)) + W.glog(_.getAt(M)));
            return z(E, 0);
          }, mod: function(_) {
            if (w.getLength() - _.getLength() < 0) return w;
            for (var E = W.glog(w.getAt(0)) - W.glog(_.getAt(0)), v = new Array(w.getLength()), M = 0; M < w.getLength(); M += 1) v[M] = w.getAt(M);
            for (M = 0; M < _.getLength(); M += 1) v[M] ^= W.gexp(W.glog(_.getAt(M)) + E);
            return z(v, 0).mod(_);
          } };
          return w;
        }
        var V = /* @__PURE__ */ function() {
          var f = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]], g = function(w, _) {
            var E = {};
            return E.totalCount = w, E.dataCount = _, E;
          }, b = { getRSBlocks: function(w, _) {
            var E = function(Z, J) {
              switch (J) {
                case F.L:
                  return f[4 * (Z - 1) + 0];
                case F.M:
                  return f[4 * (Z - 1) + 1];
                case F.Q:
                  return f[4 * (Z - 1) + 2];
                case F.H:
                  return f[4 * (Z - 1) + 3];
                default:
                  return;
              }
            }(w, _);
            if (E === void 0) throw "bad rs block @ typeNumber:" + w + "/errorCorrectionLevel:" + _;
            for (var v = E.length / 3, M = [], P = 0; P < v; P += 1) for (var B = E[3 * P + 0], ue = E[3 * P + 1], D = E[3 * P + 2], oe = 0; oe < B; oe += 1) M.push(g(ue, D));
            return M;
          } };
          return b;
        }(), te = function() {
          var f = [], g = 0, b = { getBuffer: function() {
            return f;
          }, getAt: function(w) {
            var _ = Math.floor(w / 8);
            return (f[_] >>> 7 - w % 8 & 1) == 1;
          }, put: function(w, _) {
            for (var E = 0; E < _; E += 1) b.putBit((w >>> _ - E - 1 & 1) == 1);
          }, getLengthInBits: function() {
            return g;
          }, putBit: function(w) {
            var _ = Math.floor(g / 8);
            f.length <= _ && f.push(0), w && (f[_] |= 128 >>> g % 8), g += 1;
          } };
          return b;
        }, R = function(f) {
          var g = f, b = { getMode: function() {
            return 1;
          }, getLength: function(E) {
            return g.length;
          }, write: function(E) {
            for (var v = g, M = 0; M + 2 < v.length; ) E.put(w(v.substring(M, M + 3)), 10), M += 3;
            M < v.length && (v.length - M == 1 ? E.put(w(v.substring(M, M + 1)), 4) : v.length - M == 2 && E.put(w(v.substring(M, M + 2)), 7));
          } }, w = function(E) {
            for (var v = 0, M = 0; M < E.length; M += 1) v = 10 * v + _(E.charAt(M));
            return v;
          }, _ = function(E) {
            if ("0" <= E && E <= "9") return E.charCodeAt(0) - 48;
            throw "illegal char :" + E;
          };
          return b;
        }, K = function(f) {
          var g = f, b = { getMode: function() {
            return 2;
          }, getLength: function(_) {
            return g.length;
          }, write: function(_) {
            for (var E = g, v = 0; v + 1 < E.length; ) _.put(45 * w(E.charAt(v)) + w(E.charAt(v + 1)), 11), v += 2;
            v < E.length && _.put(w(E.charAt(v)), 6);
          } }, w = function(_) {
            if ("0" <= _ && _ <= "9") return _.charCodeAt(0) - 48;
            if ("A" <= _ && _ <= "Z") return _.charCodeAt(0) - 65 + 10;
            switch (_) {
              case " ":
                return 36;
              case "$":
                return 37;
              case "%":
                return 38;
              case "*":
                return 39;
              case "+":
                return 40;
              case "-":
                return 41;
              case ".":
                return 42;
              case "/":
                return 43;
              case ":":
                return 44;
              default:
                throw "illegal char :" + _;
            }
          };
          return b;
        }, pe = function(f) {
          var g = p.stringToBytes(f);
          return { getMode: function() {
            return 4;
          }, getLength: function(b) {
            return g.length;
          }, write: function(b) {
            for (var w = 0; w < g.length; w += 1) b.put(g[w], 8);
          } };
        }, _e = function(f) {
          var g = p.stringToBytesFuncs.SJIS;
          if (!g) throw "sjis not supported.";
          (function() {
            var _ = g("友");
            if (_.length != 2 || (_[0] << 8 | _[1]) != 38726) throw "sjis not supported.";
          })();
          var b = g(f), w = { getMode: function() {
            return 8;
          }, getLength: function(_) {
            return ~~(b.length / 2);
          }, write: function(_) {
            for (var E = b, v = 0; v + 1 < E.length; ) {
              var M = (255 & E[v]) << 8 | 255 & E[v + 1];
              if (33088 <= M && M <= 40956) M -= 33088;
              else {
                if (!(57408 <= M && M <= 60351)) throw "illegal char at " + (v + 1) + "/" + M;
                M -= 49472;
              }
              M = 192 * (M >>> 8 & 255) + (255 & M), _.put(M, 13), v += 2;
            }
            if (v < E.length) throw "illegal char at " + (v + 1);
          } };
          return w;
        }, Y = function() {
          var f = [], g = { writeByte: function(b) {
            f.push(255 & b);
          }, writeShort: function(b) {
            g.writeByte(b), g.writeByte(b >>> 8);
          }, writeBytes: function(b, w, _) {
            w = w || 0, _ = _ || b.length;
            for (var E = 0; E < _; E += 1) g.writeByte(b[E + w]);
          }, writeString: function(b) {
            for (var w = 0; w < b.length; w += 1) g.writeByte(b.charCodeAt(w));
          }, toByteArray: function() {
            return f;
          }, toString: function() {
            var b = "";
            b += "[";
            for (var w = 0; w < f.length; w += 1) w > 0 && (b += ","), b += f[w];
            return b + "]";
          } };
          return g;
        }, S = function(f) {
          var g = f, b = 0, w = 0, _ = 0, E = { read: function() {
            for (; _ < 8; ) {
              if (b >= g.length) {
                if (_ == 0) return -1;
                throw "unexpected end of file./" + _;
              }
              var M = g.charAt(b);
              if (b += 1, M == "=") return _ = 0, -1;
              M.match(/^\s$/) || (w = w << 6 | v(M.charCodeAt(0)), _ += 6);
            }
            var P = w >>> _ - 8 & 255;
            return _ -= 8, P;
          } }, v = function(M) {
            if (65 <= M && M <= 90) return M - 65;
            if (97 <= M && M <= 122) return M - 97 + 26;
            if (48 <= M && M <= 57) return M - 48 + 52;
            if (M == 43) return 62;
            if (M == 47) return 63;
            throw "c:" + M;
          };
          return E;
        }, m = function(f, g, b) {
          for (var w = function(ue, D) {
            var oe = ue, Z = D, J = new Array(ue * D), Q = { setPixel: function(re, de, ie) {
              J[de * oe + re] = ie;
            }, write: function(re) {
              re.writeString("GIF87a"), re.writeShort(oe), re.writeShort(Z), re.writeByte(128), re.writeByte(0), re.writeByte(0), re.writeByte(0), re.writeByte(0), re.writeByte(0), re.writeByte(255), re.writeByte(255), re.writeByte(255), re.writeString(","), re.writeShort(0), re.writeShort(0), re.writeShort(oe), re.writeShort(Z), re.writeByte(0);
              var de = T(2);
              re.writeByte(2);
              for (var ie = 0; de.length - ie > 255; ) re.writeByte(255), re.writeBytes(de, ie, 255), ie += 255;
              re.writeByte(de.length - ie), re.writeBytes(de, ie, de.length - ie), re.writeByte(0), re.writeString(";");
            } }, T = function(re) {
              for (var de = 1 << re, ie = 1 + (1 << re), ce = re + 1, me = X(), Pe = 0; Pe < de; Pe += 1) me.add(String.fromCharCode(Pe));
              me.add(String.fromCharCode(de)), me.add(String.fromCharCode(ie));
              var De, Ce, $e, Me = Y(), Ne = (De = Me, Ce = 0, $e = 0, { write: function(ze, Ee) {
                if (ze >>> Ee) throw "length over";
                for (; Ce + Ee >= 8; ) De.writeByte(255 & (ze << Ce | $e)), Ee -= 8 - Ce, ze >>>= 8 - Ce, $e = 0, Ce = 0;
                $e |= ze << Ce, Ce += Ee;
              }, flush: function() {
                Ce > 0 && De.writeByte($e);
              } });
              Ne.write(de, ce);
              var Ke = 0, Le = String.fromCharCode(J[Ke]);
              for (Ke += 1; Ke < J.length; ) {
                var qe = String.fromCharCode(J[Ke]);
                Ke += 1, me.contains(Le + qe) ? Le += qe : (Ne.write(me.indexOf(Le), ce), me.size() < 4095 && (me.size() == 1 << ce && (ce += 1), me.add(Le + qe)), Le = qe);
              }
              return Ne.write(me.indexOf(Le), ce), Ne.write(ie, ce), Ne.flush(), Me.toByteArray();
            }, X = function() {
              var re = {}, de = 0, ie = { add: function(ce) {
                if (ie.contains(ce)) throw "dup key:" + ce;
                re[ce] = de, de += 1;
              }, size: function() {
                return de;
              }, indexOf: function(ce) {
                return re[ce];
              }, contains: function(ce) {
                return re[ce] !== void 0;
              } };
              return ie;
            };
            return Q;
          }(f, g), _ = 0; _ < g; _ += 1) for (var E = 0; E < f; E += 1) w.setPixel(E, _, b(E, _));
          var v = Y();
          w.write(v);
          for (var M = function() {
            var ue = 0, D = 0, oe = 0, Z = "", J = {}, Q = function(X) {
              Z += String.fromCharCode(T(63 & X));
            }, T = function(X) {
              if (!(X < 0)) {
                if (X < 26) return 65 + X;
                if (X < 52) return X - 26 + 97;
                if (X < 62) return X - 52 + 48;
                if (X == 62) return 43;
                if (X == 63) return 47;
              }
              throw "n:" + X;
            };
            return J.writeByte = function(X) {
              for (ue = ue << 8 | 255 & X, D += 8, oe += 1; D >= 6; ) Q(ue >>> D - 6), D -= 6;
            }, J.flush = function() {
              if (D > 0 && (Q(ue << 6 - D), ue = 0, D = 0), oe % 3 != 0) for (var X = 3 - oe % 3, re = 0; re < X; re += 1) Z += "=";
            }, J.toString = function() {
              return Z;
            }, J;
          }(), P = v.toByteArray(), B = 0; B < P.length; B += 1) M.writeByte(P[B]);
          return M.flush(), "data:image/gif;base64," + M;
        };
        return p;
      }();
      d.stringToBytesFuncs["UTF-8"] = function(p) {
        return function(x) {
          for (var A = [], I = 0; I < x.length; I++) {
            var N = x.charCodeAt(I);
            N < 128 ? A.push(N) : N < 2048 ? A.push(192 | N >> 6, 128 | 63 & N) : N < 55296 || N >= 57344 ? A.push(224 | N >> 12, 128 | N >> 6 & 63, 128 | 63 & N) : (I++, N = 65536 + ((1023 & N) << 10 | 1023 & x.charCodeAt(I)), A.push(240 | N >> 18, 128 | N >> 12 & 63, 128 | N >> 6 & 63, 128 | 63 & N));
          }
          return A;
        }(p);
      }, (h = typeof (u = function() {
        return d;
      }) == "function" ? u.apply(a, []) : u) === void 0 || (o.exports = h);
    } }, n = {};
    function i(o) {
      var a = n[o];
      if (a !== void 0) return a.exports;
      var u = n[o] = { exports: {} };
      return r[o](u, u.exports, i), u.exports;
    }
    i.n = (o) => {
      var a = o && o.__esModule ? () => o.default : () => o;
      return i.d(a, { a }), a;
    }, i.d = (o, a) => {
      for (var u in a) i.o(a, u) && !i.o(o, u) && Object.defineProperty(o, u, { enumerable: !0, get: a[u] });
    }, i.o = (o, a) => Object.prototype.hasOwnProperty.call(o, a);
    var s = {};
    return (() => {
      i.d(s, { default: () => Y });
      const o = (S) => !!S && typeof S == "object" && !Array.isArray(S);
      function a(S, ...m) {
        if (!m.length) return S;
        const f = m.shift();
        return f !== void 0 && o(S) && o(f) ? (S = Object.assign({}, S), Object.keys(f).forEach((g) => {
          const b = S[g], w = f[g];
          Array.isArray(b) && Array.isArray(w) ? S[g] = w : o(b) && o(w) ? S[g] = a(Object.assign({}, b), w) : S[g] = w;
        }), a(S, ...m)) : S;
      }
      function u(S, m) {
        const f = document.createElement("a");
        f.download = m, f.href = S, document.body.appendChild(f), f.click(), document.body.removeChild(f);
      }
      const h = { L: 0.07, M: 0.15, Q: 0.25, H: 0.3 };
      class d {
        constructor({ svg: m, type: f, window: g }) {
          this._svg = m, this._type = f, this._window = g;
        }
        draw(m, f, g, b) {
          let w;
          switch (this._type) {
            case "dots":
              w = this._drawDot;
              break;
            case "classy":
              w = this._drawClassy;
              break;
            case "classy-rounded":
              w = this._drawClassyRounded;
              break;
            case "rounded":
              w = this._drawRounded;
              break;
            case "extra-rounded":
              w = this._drawExtraRounded;
              break;
            default:
              w = this._drawSquare;
          }
          w.call(this, { x: m, y: f, size: g, getNeighbor: b });
        }
        _rotateFigure({ x: m, y: f, size: g, rotation: b = 0, draw: w }) {
          var _;
          const E = m + g / 2, v = f + g / 2;
          w(), (_ = this._element) === null || _ === void 0 || _.setAttribute("transform", `rotate(${180 * b / Math.PI},${E},${v})`);
        }
        _basicDot(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "circle"), this._element.setAttribute("cx", String(g + f / 2)), this._element.setAttribute("cy", String(b + f / 2)), this._element.setAttribute("r", String(f / 2));
          } }));
        }
        _basicSquare(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect"), this._element.setAttribute("x", String(g)), this._element.setAttribute("y", String(b)), this._element.setAttribute("width", String(f)), this._element.setAttribute("height", String(f));
          } }));
        }
        _basicSideRounded(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${g} ${b}v ${f}h ` + f / 2 + `a ${f / 2} ${f / 2}, 0, 0, 0, 0 ${-f}`);
          } }));
        }
        _basicCornerRounded(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${g} ${b}v ${f}h ${f}v ` + -f / 2 + `a ${f / 2} ${f / 2}, 0, 0, 0, ${-f / 2} ${-f / 2}`);
          } }));
        }
        _basicCornerExtraRounded(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${g} ${b}v ${f}h ${f}a ${f} ${f}, 0, 0, 0, ${-f} ${-f}`);
          } }));
        }
        _basicCornersRounded(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${g} ${b}v ` + f / 2 + `a ${f / 2} ${f / 2}, 0, 0, 0, ${f / 2} ${f / 2}h ` + f / 2 + "v " + -f / 2 + `a ${f / 2} ${f / 2}, 0, 0, 0, ${-f / 2} ${-f / 2}`);
          } }));
        }
        _drawDot({ x: m, y: f, size: g }) {
          this._basicDot({ x: m, y: f, size: g, rotation: 0 });
        }
        _drawSquare({ x: m, y: f, size: g }) {
          this._basicSquare({ x: m, y: f, size: g, rotation: 0 });
        }
        _drawRounded({ x: m, y: f, size: g, getNeighbor: b }) {
          const w = b ? +b(-1, 0) : 0, _ = b ? +b(1, 0) : 0, E = b ? +b(0, -1) : 0, v = b ? +b(0, 1) : 0, M = w + _ + E + v;
          if (M !== 0) if (M > 2 || w && _ || E && v) this._basicSquare({ x: m, y: f, size: g, rotation: 0 });
          else {
            if (M === 2) {
              let P = 0;
              return w && E ? P = Math.PI / 2 : E && _ ? P = Math.PI : _ && v && (P = -Math.PI / 2), void this._basicCornerRounded({ x: m, y: f, size: g, rotation: P });
            }
            if (M === 1) {
              let P = 0;
              return E ? P = Math.PI / 2 : _ ? P = Math.PI : v && (P = -Math.PI / 2), void this._basicSideRounded({ x: m, y: f, size: g, rotation: P });
            }
          }
          else this._basicDot({ x: m, y: f, size: g, rotation: 0 });
        }
        _drawExtraRounded({ x: m, y: f, size: g, getNeighbor: b }) {
          const w = b ? +b(-1, 0) : 0, _ = b ? +b(1, 0) : 0, E = b ? +b(0, -1) : 0, v = b ? +b(0, 1) : 0, M = w + _ + E + v;
          if (M !== 0) if (M > 2 || w && _ || E && v) this._basicSquare({ x: m, y: f, size: g, rotation: 0 });
          else {
            if (M === 2) {
              let P = 0;
              return w && E ? P = Math.PI / 2 : E && _ ? P = Math.PI : _ && v && (P = -Math.PI / 2), void this._basicCornerExtraRounded({ x: m, y: f, size: g, rotation: P });
            }
            if (M === 1) {
              let P = 0;
              return E ? P = Math.PI / 2 : _ ? P = Math.PI : v && (P = -Math.PI / 2), void this._basicSideRounded({ x: m, y: f, size: g, rotation: P });
            }
          }
          else this._basicDot({ x: m, y: f, size: g, rotation: 0 });
        }
        _drawClassy({ x: m, y: f, size: g, getNeighbor: b }) {
          const w = b ? +b(-1, 0) : 0, _ = b ? +b(1, 0) : 0, E = b ? +b(0, -1) : 0, v = b ? +b(0, 1) : 0;
          w + _ + E + v !== 0 ? w || E ? _ || v ? this._basicSquare({ x: m, y: f, size: g, rotation: 0 }) : this._basicCornerRounded({ x: m, y: f, size: g, rotation: Math.PI / 2 }) : this._basicCornerRounded({ x: m, y: f, size: g, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: m, y: f, size: g, rotation: Math.PI / 2 });
        }
        _drawClassyRounded({ x: m, y: f, size: g, getNeighbor: b }) {
          const w = b ? +b(-1, 0) : 0, _ = b ? +b(1, 0) : 0, E = b ? +b(0, -1) : 0, v = b ? +b(0, 1) : 0;
          w + _ + E + v !== 0 ? w || E ? _ || v ? this._basicSquare({ x: m, y: f, size: g, rotation: 0 }) : this._basicCornerExtraRounded({ x: m, y: f, size: g, rotation: Math.PI / 2 }) : this._basicCornerExtraRounded({ x: m, y: f, size: g, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: m, y: f, size: g, rotation: Math.PI / 2 });
        }
      }
      class p {
        constructor({ svg: m, type: f, window: g }) {
          this._svg = m, this._type = f, this._window = g;
        }
        draw(m, f, g, b) {
          let w;
          switch (this._type) {
            case "square":
              w = this._drawSquare;
              break;
            case "extra-rounded":
              w = this._drawExtraRounded;
              break;
            default:
              w = this._drawDot;
          }
          w.call(this, { x: m, y: f, size: g, rotation: b });
        }
        _rotateFigure({ x: m, y: f, size: g, rotation: b = 0, draw: w }) {
          var _;
          const E = m + g / 2, v = f + g / 2;
          w(), (_ = this._element) === null || _ === void 0 || _.setAttribute("transform", `rotate(${180 * b / Math.PI},${E},${v})`);
        }
        _basicDot(m) {
          const { size: f, x: g, y: b } = m, w = f / 7;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${g + f / 2} ${b}a ${f / 2} ${f / 2} 0 1 0 0.1 0zm 0 ${w}a ${f / 2 - w} ${f / 2 - w} 0 1 1 -0.1 0Z`);
          } }));
        }
        _basicSquare(m) {
          const { size: f, x: g, y: b } = m, w = f / 7;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${g} ${b}v ${f}h ${f}v ` + -f + `zM ${g + w} ${b + w}h ` + (f - 2 * w) + "v " + (f - 2 * w) + "h " + (2 * w - f) + "z");
          } }));
        }
        _basicExtraRounded(m) {
          const { size: f, x: g, y: b } = m, w = f / 7;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${g} ${b + 2.5 * w}v ` + 2 * w + `a ${2.5 * w} ${2.5 * w}, 0, 0, 0, ${2.5 * w} ${2.5 * w}h ` + 2 * w + `a ${2.5 * w} ${2.5 * w}, 0, 0, 0, ${2.5 * w} ${2.5 * -w}v ` + -2 * w + `a ${2.5 * w} ${2.5 * w}, 0, 0, 0, ${2.5 * -w} ${2.5 * -w}h ` + -2 * w + `a ${2.5 * w} ${2.5 * w}, 0, 0, 0, ${2.5 * -w} ${2.5 * w}M ${g + 2.5 * w} ${b + w}h ` + 2 * w + `a ${1.5 * w} ${1.5 * w}, 0, 0, 1, ${1.5 * w} ${1.5 * w}v ` + 2 * w + `a ${1.5 * w} ${1.5 * w}, 0, 0, 1, ${1.5 * -w} ${1.5 * w}h ` + -2 * w + `a ${1.5 * w} ${1.5 * w}, 0, 0, 1, ${1.5 * -w} ${1.5 * -w}v ` + -2 * w + `a ${1.5 * w} ${1.5 * w}, 0, 0, 1, ${1.5 * w} ${1.5 * -w}`);
          } }));
        }
        _drawDot({ x: m, y: f, size: g, rotation: b }) {
          this._basicDot({ x: m, y: f, size: g, rotation: b });
        }
        _drawSquare({ x: m, y: f, size: g, rotation: b }) {
          this._basicSquare({ x: m, y: f, size: g, rotation: b });
        }
        _drawExtraRounded({ x: m, y: f, size: g, rotation: b }) {
          this._basicExtraRounded({ x: m, y: f, size: g, rotation: b });
        }
      }
      class x {
        constructor({ svg: m, type: f, window: g }) {
          this._svg = m, this._type = f, this._window = g;
        }
        draw(m, f, g, b) {
          let w;
          w = this._type === "square" ? this._drawSquare : this._drawDot, w.call(this, { x: m, y: f, size: g, rotation: b });
        }
        _rotateFigure({ x: m, y: f, size: g, rotation: b = 0, draw: w }) {
          var _;
          const E = m + g / 2, v = f + g / 2;
          w(), (_ = this._element) === null || _ === void 0 || _.setAttribute("transform", `rotate(${180 * b / Math.PI},${E},${v})`);
        }
        _basicDot(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "circle"), this._element.setAttribute("cx", String(g + f / 2)), this._element.setAttribute("cy", String(b + f / 2)), this._element.setAttribute("r", String(f / 2));
          } }));
        }
        _basicSquare(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect"), this._element.setAttribute("x", String(g)), this._element.setAttribute("y", String(b)), this._element.setAttribute("width", String(f)), this._element.setAttribute("height", String(f));
          } }));
        }
        _drawDot({ x: m, y: f, size: g, rotation: b }) {
          this._basicDot({ x: m, y: f, size: g, rotation: b });
        }
        _drawSquare({ x: m, y: f, size: g, rotation: b }) {
          this._basicSquare({ x: m, y: f, size: g, rotation: b });
        }
      }
      const A = "circle", I = [[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]], N = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]];
      class L {
        constructor(m, f) {
          this._roundSize = (g) => this._options.dotsOptions.roundSize ? Math.floor(g) : g, this._window = f, this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._element.setAttribute("width", String(m.width)), this._element.setAttribute("height", String(m.height)), this._element.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), m.dotsOptions.roundSize || this._element.setAttribute("shape-rendering", "crispEdges"), this._element.setAttribute("viewBox", `0 0 ${m.width} ${m.height}`), this._defs = this._window.document.createElementNS("http://www.w3.org/2000/svg", "defs"), this._element.appendChild(this._defs), this._imageUri = m.image, this._instanceId = L.instanceCount++, this._options = m;
        }
        get width() {
          return this._options.width;
        }
        get height() {
          return this._options.height;
        }
        getElement() {
          return this._element;
        }
        async drawQR(m) {
          const f = m.getModuleCount(), g = Math.min(this._options.width, this._options.height) - 2 * this._options.margin, b = this._options.shape === A ? g / Math.sqrt(2) : g, w = this._roundSize(b / f);
          let _ = { hideXDots: 0, hideYDots: 0, width: 0, height: 0 };
          if (this._qr = m, this._options.image) {
            if (await this.loadImage(), !this._image) return;
            const { imageOptions: E, qrOptions: v } = this._options, M = E.imageSize * h[v.errorCorrectionLevel], P = Math.floor(M * f * f);
            _ = function({ originalHeight: B, originalWidth: ue, maxHiddenDots: D, maxHiddenAxisDots: oe, dotSize: Z }) {
              const J = { x: 0, y: 0 }, Q = { x: 0, y: 0 };
              if (B <= 0 || ue <= 0 || D <= 0 || Z <= 0) return { height: 0, width: 0, hideYDots: 0, hideXDots: 0 };
              const T = B / ue;
              return J.x = Math.floor(Math.sqrt(D / T)), J.x <= 0 && (J.x = 1), oe && oe < J.x && (J.x = oe), J.x % 2 == 0 && J.x--, Q.x = J.x * Z, J.y = 1 + 2 * Math.ceil((J.x * T - 1) / 2), Q.y = Math.round(Q.x * T), (J.y * J.x > D || oe && oe < J.y) && (oe && oe < J.y ? (J.y = oe, J.y % 2 == 0 && J.x--) : J.y -= 2, Q.y = J.y * Z, J.x = 1 + 2 * Math.ceil((J.y / T - 1) / 2), Q.x = Math.round(Q.y / T)), { height: Q.y, width: Q.x, hideYDots: J.y, hideXDots: J.x };
            }({ originalWidth: this._image.width, originalHeight: this._image.height, maxHiddenDots: P, maxHiddenAxisDots: f - 14, dotSize: w });
          }
          this.drawBackground(), this.drawDots((E, v) => {
            var M, P, B, ue, D, oe;
            return !(this._options.imageOptions.hideBackgroundDots && E >= (f - _.hideYDots) / 2 && E < (f + _.hideYDots) / 2 && v >= (f - _.hideXDots) / 2 && v < (f + _.hideXDots) / 2 || !((M = I[E]) === null || M === void 0) && M[v] || !((P = I[E - f + 7]) === null || P === void 0) && P[v] || !((B = I[E]) === null || B === void 0) && B[v - f + 7] || !((ue = N[E]) === null || ue === void 0) && ue[v] || !((D = N[E - f + 7]) === null || D === void 0) && D[v] || !((oe = N[E]) === null || oe === void 0) && oe[v - f + 7]);
          }), this.drawCorners(), this._options.image && await this.drawImage({ width: _.width, height: _.height, count: f, dotSize: w });
        }
        drawBackground() {
          var m, f, g;
          const b = this._element, w = this._options;
          if (b) {
            const _ = (m = w.backgroundOptions) === null || m === void 0 ? void 0 : m.gradient, E = (f = w.backgroundOptions) === null || f === void 0 ? void 0 : f.color;
            let v = w.height, M = w.width;
            if (_ || E) {
              const P = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
              this._backgroundClipPath = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._backgroundClipPath.setAttribute("id", `clip-path-background-color-${this._instanceId}`), this._defs.appendChild(this._backgroundClipPath), !((g = w.backgroundOptions) === null || g === void 0) && g.round && (v = M = Math.min(w.width, w.height), P.setAttribute("rx", String(v / 2 * w.backgroundOptions.round))), P.setAttribute("x", String(this._roundSize((w.width - M) / 2))), P.setAttribute("y", String(this._roundSize((w.height - v) / 2))), P.setAttribute("width", String(M)), P.setAttribute("height", String(v)), this._backgroundClipPath.appendChild(P), this._createColor({ options: _, color: E, additionalRotation: 0, x: 0, y: 0, height: w.height, width: w.width, name: `background-color-${this._instanceId}` });
            }
          }
        }
        drawDots(m) {
          var f, g;
          if (!this._qr) throw "QR code is not defined";
          const b = this._options, w = this._qr.getModuleCount();
          if (w > b.width || w > b.height) throw "The canvas is too small.";
          const _ = Math.min(b.width, b.height) - 2 * b.margin, E = b.shape === A ? _ / Math.sqrt(2) : _, v = this._roundSize(E / w), M = this._roundSize((b.width - w * v) / 2), P = this._roundSize((b.height - w * v) / 2), B = new d({ svg: this._element, type: b.dotsOptions.type, window: this._window });
          this._dotsClipPath = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._dotsClipPath.setAttribute("id", `clip-path-dot-color-${this._instanceId}`), this._defs.appendChild(this._dotsClipPath), this._createColor({ options: (f = b.dotsOptions) === null || f === void 0 ? void 0 : f.gradient, color: b.dotsOptions.color, additionalRotation: 0, x: 0, y: 0, height: b.height, width: b.width, name: `dot-color-${this._instanceId}` });
          for (let ue = 0; ue < w; ue++) for (let D = 0; D < w; D++) m && !m(ue, D) || !((g = this._qr) === null || g === void 0) && g.isDark(ue, D) && (B.draw(M + D * v, P + ue * v, v, (oe, Z) => !(D + oe < 0 || ue + Z < 0 || D + oe >= w || ue + Z >= w) && !(m && !m(ue + Z, D + oe)) && !!this._qr && this._qr.isDark(ue + Z, D + oe)), B._element && this._dotsClipPath && this._dotsClipPath.appendChild(B._element));
          if (b.shape === A) {
            const ue = this._roundSize((_ / v - w) / 2), D = w + 2 * ue, oe = M - ue * v, Z = P - ue * v, J = [], Q = this._roundSize(D / 2);
            for (let T = 0; T < D; T++) {
              J[T] = [];
              for (let X = 0; X < D; X++) T >= ue - 1 && T <= D - ue && X >= ue - 1 && X <= D - ue || Math.sqrt((T - Q) * (T - Q) + (X - Q) * (X - Q)) > Q ? J[T][X] = 0 : J[T][X] = this._qr.isDark(X - 2 * ue < 0 ? X : X >= w ? X - 2 * ue : X - ue, T - 2 * ue < 0 ? T : T >= w ? T - 2 * ue : T - ue) ? 1 : 0;
            }
            for (let T = 0; T < D; T++) for (let X = 0; X < D; X++) J[T][X] && (B.draw(oe + X * v, Z + T * v, v, (re, de) => {
              var ie;
              return !!(!((ie = J[T + de]) === null || ie === void 0) && ie[X + re]);
            }), B._element && this._dotsClipPath && this._dotsClipPath.appendChild(B._element));
          }
        }
        drawCorners() {
          if (!this._qr) throw "QR code is not defined";
          const m = this._element, f = this._options;
          if (!m) throw "Element code is not defined";
          const g = this._qr.getModuleCount(), b = Math.min(f.width, f.height) - 2 * f.margin, w = f.shape === A ? b / Math.sqrt(2) : b, _ = this._roundSize(w / g), E = 7 * _, v = 3 * _, M = this._roundSize((f.width - g * _) / 2), P = this._roundSize((f.height - g * _) / 2);
          [[0, 0, 0], [1, 0, Math.PI / 2], [0, 1, -Math.PI / 2]].forEach(([B, ue, D]) => {
            var oe, Z, J, Q, T, X, re, de, ie, ce, me, Pe;
            const De = M + B * _ * (g - 7), Ce = P + ue * _ * (g - 7);
            let $e = this._dotsClipPath, Me = this._dotsClipPath;
            if ((!((oe = f.cornersSquareOptions) === null || oe === void 0) && oe.gradient || !((Z = f.cornersSquareOptions) === null || Z === void 0) && Z.color) && ($e = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), $e.setAttribute("id", `clip-path-corners-square-color-${B}-${ue}-${this._instanceId}`), this._defs.appendChild($e), this._cornersSquareClipPath = this._cornersDotClipPath = Me = $e, this._createColor({ options: (J = f.cornersSquareOptions) === null || J === void 0 ? void 0 : J.gradient, color: (Q = f.cornersSquareOptions) === null || Q === void 0 ? void 0 : Q.color, additionalRotation: D, x: De, y: Ce, height: E, width: E, name: `corners-square-color-${B}-${ue}-${this._instanceId}` })), (T = f.cornersSquareOptions) === null || T === void 0 ? void 0 : T.type) {
              const Ne = new p({ svg: this._element, type: f.cornersSquareOptions.type, window: this._window });
              Ne.draw(De, Ce, E, D), Ne._element && $e && $e.appendChild(Ne._element);
            } else {
              const Ne = new d({ svg: this._element, type: f.dotsOptions.type, window: this._window });
              for (let Ke = 0; Ke < I.length; Ke++) for (let Le = 0; Le < I[Ke].length; Le++) !((X = I[Ke]) === null || X === void 0) && X[Le] && (Ne.draw(De + Le * _, Ce + Ke * _, _, (qe, ze) => {
                var Ee;
                return !!(!((Ee = I[Ke + ze]) === null || Ee === void 0) && Ee[Le + qe]);
              }), Ne._element && $e && $e.appendChild(Ne._element));
            }
            if ((!((re = f.cornersDotOptions) === null || re === void 0) && re.gradient || !((de = f.cornersDotOptions) === null || de === void 0) && de.color) && (Me = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), Me.setAttribute("id", `clip-path-corners-dot-color-${B}-${ue}-${this._instanceId}`), this._defs.appendChild(Me), this._cornersDotClipPath = Me, this._createColor({ options: (ie = f.cornersDotOptions) === null || ie === void 0 ? void 0 : ie.gradient, color: (ce = f.cornersDotOptions) === null || ce === void 0 ? void 0 : ce.color, additionalRotation: D, x: De + 2 * _, y: Ce + 2 * _, height: v, width: v, name: `corners-dot-color-${B}-${ue}-${this._instanceId}` })), (me = f.cornersDotOptions) === null || me === void 0 ? void 0 : me.type) {
              const Ne = new x({ svg: this._element, type: f.cornersDotOptions.type, window: this._window });
              Ne.draw(De + 2 * _, Ce + 2 * _, v, D), Ne._element && Me && Me.appendChild(Ne._element);
            } else {
              const Ne = new d({ svg: this._element, type: f.dotsOptions.type, window: this._window });
              for (let Ke = 0; Ke < N.length; Ke++) for (let Le = 0; Le < N[Ke].length; Le++) !((Pe = N[Ke]) === null || Pe === void 0) && Pe[Le] && (Ne.draw(De + Le * _, Ce + Ke * _, _, (qe, ze) => {
                var Ee;
                return !!(!((Ee = N[Ke + ze]) === null || Ee === void 0) && Ee[Le + qe]);
              }), Ne._element && Me && Me.appendChild(Ne._element));
            }
          });
        }
        loadImage() {
          return new Promise((m, f) => {
            var g;
            const b = this._options;
            if (!b.image) return f("Image is not defined");
            if (!((g = b.nodeCanvas) === null || g === void 0) && g.loadImage) b.nodeCanvas.loadImage(b.image).then((w) => {
              var _, E;
              if (this._image = w, this._options.imageOptions.saveAsBlob) {
                const v = (_ = b.nodeCanvas) === null || _ === void 0 ? void 0 : _.createCanvas(this._image.width, this._image.height);
                (E = v == null ? void 0 : v.getContext("2d")) === null || E === void 0 || E.drawImage(w, 0, 0), this._imageUri = v == null ? void 0 : v.toDataURL();
              }
              m();
            }).catch(f);
            else {
              const w = new this._window.Image();
              typeof b.imageOptions.crossOrigin == "string" && (w.crossOrigin = b.imageOptions.crossOrigin), this._image = w, w.onload = async () => {
                this._options.imageOptions.saveAsBlob && (this._imageUri = await async function(_, E) {
                  return new Promise((v) => {
                    const M = new E.XMLHttpRequest();
                    M.onload = function() {
                      const P = new E.FileReader();
                      P.onloadend = function() {
                        v(P.result);
                      }, P.readAsDataURL(M.response);
                    }, M.open("GET", _), M.responseType = "blob", M.send();
                  });
                }(b.image || "", this._window)), m();
              }, w.src = b.image;
            }
          });
        }
        async drawImage({ width: m, height: f, count: g, dotSize: b }) {
          const w = this._options, _ = this._roundSize((w.width - g * b) / 2), E = this._roundSize((w.height - g * b) / 2), v = _ + this._roundSize(w.imageOptions.margin + (g * b - m) / 2), M = E + this._roundSize(w.imageOptions.margin + (g * b - f) / 2), P = m - 2 * w.imageOptions.margin, B = f - 2 * w.imageOptions.margin, ue = this._window.document.createElementNS("http://www.w3.org/2000/svg", "image");
          ue.setAttribute("href", this._imageUri || ""), ue.setAttribute("x", String(v)), ue.setAttribute("y", String(M)), ue.setAttribute("width", `${P}px`), ue.setAttribute("height", `${B}px`), this._element.appendChild(ue);
        }
        _createColor({ options: m, color: f, additionalRotation: g, x: b, y: w, height: _, width: E, name: v }) {
          const M = E > _ ? E : _, P = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
          if (P.setAttribute("x", String(b)), P.setAttribute("y", String(w)), P.setAttribute("height", String(_)), P.setAttribute("width", String(E)), P.setAttribute("clip-path", `url('#clip-path-${v}')`), m) {
            let B;
            if (m.type === "radial") B = this._window.document.createElementNS("http://www.w3.org/2000/svg", "radialGradient"), B.setAttribute("id", v), B.setAttribute("gradientUnits", "userSpaceOnUse"), B.setAttribute("fx", String(b + E / 2)), B.setAttribute("fy", String(w + _ / 2)), B.setAttribute("cx", String(b + E / 2)), B.setAttribute("cy", String(w + _ / 2)), B.setAttribute("r", String(M / 2));
            else {
              const ue = ((m.rotation || 0) + g) % (2 * Math.PI), D = (ue + 2 * Math.PI) % (2 * Math.PI);
              let oe = b + E / 2, Z = w + _ / 2, J = b + E / 2, Q = w + _ / 2;
              D >= 0 && D <= 0.25 * Math.PI || D > 1.75 * Math.PI && D <= 2 * Math.PI ? (oe -= E / 2, Z -= _ / 2 * Math.tan(ue), J += E / 2, Q += _ / 2 * Math.tan(ue)) : D > 0.25 * Math.PI && D <= 0.75 * Math.PI ? (Z -= _ / 2, oe -= E / 2 / Math.tan(ue), Q += _ / 2, J += E / 2 / Math.tan(ue)) : D > 0.75 * Math.PI && D <= 1.25 * Math.PI ? (oe += E / 2, Z += _ / 2 * Math.tan(ue), J -= E / 2, Q -= _ / 2 * Math.tan(ue)) : D > 1.25 * Math.PI && D <= 1.75 * Math.PI && (Z += _ / 2, oe += E / 2 / Math.tan(ue), Q -= _ / 2, J -= E / 2 / Math.tan(ue)), B = this._window.document.createElementNS("http://www.w3.org/2000/svg", "linearGradient"), B.setAttribute("id", v), B.setAttribute("gradientUnits", "userSpaceOnUse"), B.setAttribute("x1", String(Math.round(oe))), B.setAttribute("y1", String(Math.round(Z))), B.setAttribute("x2", String(Math.round(J))), B.setAttribute("y2", String(Math.round(Q)));
            }
            m.colorStops.forEach(({ offset: ue, color: D }) => {
              const oe = this._window.document.createElementNS("http://www.w3.org/2000/svg", "stop");
              oe.setAttribute("offset", 100 * ue + "%"), oe.setAttribute("stop-color", D), B.appendChild(oe);
            }), P.setAttribute("fill", `url('#${v}')`), this._defs.appendChild(B);
          } else f && P.setAttribute("fill", f);
          this._element.appendChild(P);
        }
      }
      L.instanceCount = 0;
      const F = L, $ = "canvas", W = {};
      for (let S = 0; S <= 40; S++) W[S] = S;
      const z = { type: $, shape: "square", width: 300, height: 300, data: "", margin: 0, qrOptions: { typeNumber: W[0], mode: void 0, errorCorrectionLevel: "Q" }, imageOptions: { saveAsBlob: !0, hideBackgroundDots: !0, imageSize: 0.4, crossOrigin: void 0, margin: 0 }, dotsOptions: { type: "square", color: "#000", roundSize: !0 }, backgroundOptions: { round: 0, color: "#fff" } };
      function V(S) {
        const m = Object.assign({}, S);
        if (!m.colorStops || !m.colorStops.length) throw "Field 'colorStops' is required in gradient";
        return m.rotation ? m.rotation = Number(m.rotation) : m.rotation = 0, m.colorStops = m.colorStops.map((f) => Object.assign(Object.assign({}, f), { offset: Number(f.offset) })), m;
      }
      function te(S) {
        const m = Object.assign({}, S);
        return m.width = Number(m.width), m.height = Number(m.height), m.margin = Number(m.margin), m.imageOptions = Object.assign(Object.assign({}, m.imageOptions), { hideBackgroundDots: !!m.imageOptions.hideBackgroundDots, imageSize: Number(m.imageOptions.imageSize), margin: Number(m.imageOptions.margin) }), m.margin > Math.min(m.width, m.height) && (m.margin = Math.min(m.width, m.height)), m.dotsOptions = Object.assign({}, m.dotsOptions), m.dotsOptions.gradient && (m.dotsOptions.gradient = V(m.dotsOptions.gradient)), m.cornersSquareOptions && (m.cornersSquareOptions = Object.assign({}, m.cornersSquareOptions), m.cornersSquareOptions.gradient && (m.cornersSquareOptions.gradient = V(m.cornersSquareOptions.gradient))), m.cornersDotOptions && (m.cornersDotOptions = Object.assign({}, m.cornersDotOptions), m.cornersDotOptions.gradient && (m.cornersDotOptions.gradient = V(m.cornersDotOptions.gradient))), m.backgroundOptions && (m.backgroundOptions = Object.assign({}, m.backgroundOptions), m.backgroundOptions.gradient && (m.backgroundOptions.gradient = V(m.backgroundOptions.gradient))), m;
      }
      var R = i(873), K = i.n(R);
      function pe(S) {
        if (!S) throw new Error("Extension must be defined");
        S[0] === "." && (S = S.substring(1));
        const m = { bmp: "image/bmp", gif: "image/gif", ico: "image/vnd.microsoft.icon", jpeg: "image/jpeg", jpg: "image/jpeg", png: "image/png", svg: "image/svg+xml", tif: "image/tiff", tiff: "image/tiff", webp: "image/webp", pdf: "application/pdf" }[S.toLowerCase()];
        if (!m) throw new Error(`Extension "${S}" is not supported`);
        return m;
      }
      class _e {
        constructor(m) {
          m != null && m.jsdom ? this._window = new m.jsdom("", { resources: "usable" }).window : this._window = window, this._options = m ? te(a(z, m)) : z, this.update();
        }
        static _clearContainer(m) {
          m && (m.innerHTML = "");
        }
        _setupSvg() {
          if (!this._qr) return;
          const m = new F(this._options, this._window);
          this._svg = m.getElement(), this._svgDrawingPromise = m.drawQR(this._qr).then(() => {
            var f;
            this._svg && ((f = this._extension) === null || f === void 0 || f.call(this, m.getElement(), this._options));
          });
        }
        _setupCanvas() {
          var m, f;
          this._qr && (!((m = this._options.nodeCanvas) === null || m === void 0) && m.createCanvas ? (this._nodeCanvas = this._options.nodeCanvas.createCanvas(this._options.width, this._options.height), this._nodeCanvas.width = this._options.width, this._nodeCanvas.height = this._options.height) : (this._domCanvas = document.createElement("canvas"), this._domCanvas.width = this._options.width, this._domCanvas.height = this._options.height), this._setupSvg(), this._canvasDrawingPromise = (f = this._svgDrawingPromise) === null || f === void 0 ? void 0 : f.then(() => {
            var g;
            if (!this._svg) return;
            const b = this._svg, w = new this._window.XMLSerializer().serializeToString(b), _ = btoa(w), E = `data:${pe("svg")};base64,${_}`;
            if (!((g = this._options.nodeCanvas) === null || g === void 0) && g.loadImage) return this._options.nodeCanvas.loadImage(E).then((v) => {
              var M, P;
              v.width = this._options.width, v.height = this._options.height, (P = (M = this._nodeCanvas) === null || M === void 0 ? void 0 : M.getContext("2d")) === null || P === void 0 || P.drawImage(v, 0, 0);
            });
            {
              const v = new this._window.Image();
              return new Promise((M) => {
                v.onload = () => {
                  var P, B;
                  (B = (P = this._domCanvas) === null || P === void 0 ? void 0 : P.getContext("2d")) === null || B === void 0 || B.drawImage(v, 0, 0), M();
                }, v.src = E;
              });
            }
          }));
        }
        async _getElement(m = "png") {
          if (!this._qr) throw "QR code is empty";
          return m.toLowerCase() === "svg" ? (this._svg && this._svgDrawingPromise || this._setupSvg(), await this._svgDrawingPromise, this._svg) : ((this._domCanvas || this._nodeCanvas) && this._canvasDrawingPromise || this._setupCanvas(), await this._canvasDrawingPromise, this._domCanvas || this._nodeCanvas);
        }
        update(m) {
          _e._clearContainer(this._container), this._options = m ? te(a(this._options, m)) : this._options, this._options.data && (this._qr = K()(this._options.qrOptions.typeNumber, this._options.qrOptions.errorCorrectionLevel), this._qr.addData(this._options.data, this._options.qrOptions.mode || function(f) {
            switch (!0) {
              case /^[0-9]*$/.test(f):
                return "Numeric";
              case /^[0-9A-Z $%*+\-./:]*$/.test(f):
                return "Alphanumeric";
              default:
                return "Byte";
            }
          }(this._options.data)), this._qr.make(), this._options.type === $ ? this._setupCanvas() : this._setupSvg(), this.append(this._container));
        }
        append(m) {
          if (m) {
            if (typeof m.appendChild != "function") throw "Container should be a single DOM node";
            this._options.type === $ ? this._domCanvas && m.appendChild(this._domCanvas) : this._svg && m.appendChild(this._svg), this._container = m;
          }
        }
        applyExtension(m) {
          if (!m) throw "Extension function should be defined.";
          this._extension = m, this.update();
        }
        deleteExtension() {
          this._extension = void 0, this.update();
        }
        async getRawData(m = "png") {
          if (!this._qr) throw "QR code is empty";
          const f = await this._getElement(m), g = pe(m);
          if (!f) return null;
          if (m.toLowerCase() === "svg") {
            const b = `<?xml version="1.0" standalone="no"?>\r
${new this._window.XMLSerializer().serializeToString(f)}`;
            return typeof Blob > "u" || this._options.jsdom ? Buffer.from(b) : new Blob([b], { type: g });
          }
          return new Promise((b) => {
            const w = f;
            if ("toBuffer" in w) if (g === "image/png") b(w.toBuffer(g));
            else if (g === "image/jpeg") b(w.toBuffer(g));
            else {
              if (g !== "application/pdf") throw Error("Unsupported extension");
              b(w.toBuffer(g));
            }
            else "toBlob" in w && w.toBlob(b, g, 1);
          });
        }
        async download(m) {
          if (!this._qr) throw "QR code is empty";
          if (typeof Blob > "u") throw "Cannot download in Node.js, call getRawData instead.";
          let f = "png", g = "qr";
          typeof m == "string" ? (f = m, console.warn("Extension is deprecated as argument for 'download' method, please pass object { name: '...', extension: '...' } as argument")) : typeof m == "object" && m !== null && (m.name && (g = m.name), m.extension && (f = m.extension));
          const b = await this._getElement(f);
          if (b) if (f.toLowerCase() === "svg") {
            let w = new XMLSerializer().serializeToString(b);
            w = `<?xml version="1.0" standalone="no"?>\r
` + w, u(`data:${pe(f)};charset=utf-8,${encodeURIComponent(w)}`, `${g}.svg`);
          } else u(b.toDataURL(pe(f)), `${g}.${f}`);
        }
      }
      const Y = _e;
    })(), s.default;
  })());
})(R9);
var Rne = R9.exports;
const D9 = /* @__PURE__ */ ts(Rne);
class ra extends yt {
  constructor(e) {
    const { docsPath: r, field: n, metaMessages: i } = e;
    super(`Invalid Sign-In with Ethereum message field "${n}".`, {
      docsPath: r,
      metaMessages: i,
      name: "SiweInvalidMessageFieldError"
    });
  }
}
function c5(t) {
  if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(t) || /%[^0-9a-f]/i.test(t) || /%[0-9a-f](:?[^0-9a-f]|$)/i.test(t))
    return !1;
  const e = Dne(t), r = e[1], n = e[2], i = e[3], s = e[4], o = e[5];
  if (!(r != null && r.length && i.length >= 0))
    return !1;
  if (n != null && n.length) {
    if (!(i.length === 0 || /^\//.test(i)))
      return !1;
  } else if (/^\/\//.test(i))
    return !1;
  if (!/^[a-z][a-z0-9\+\-\.]*$/.test(r.toLowerCase()))
    return !1;
  let a = "";
  return a += `${r}:`, n != null && n.length && (a += `//${n}`), a += i, s != null && s.length && (a += `?${s}`), o != null && o.length && (a += `#${o}`), a;
}
function Dne(t) {
  return t.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
}
function O9(t) {
  const { chainId: e, domain: r, expirationTime: n, issuedAt: i = /* @__PURE__ */ new Date(), nonce: s, notBefore: o, requestId: a, resources: u, scheme: h, uri: d, version: p } = t;
  {
    if (e !== Math.floor(e))
      throw new ra({
        field: "chainId",
        metaMessages: [
          "- Chain ID must be a EIP-155 chain ID.",
          "- See https://eips.ethereum.org/EIPS/eip-155",
          "",
          `Provided value: ${e}`
        ]
      });
    if (!(One.test(r) || Nne.test(r) || Lne.test(r)))
      throw new ra({
        field: "domain",
        metaMessages: [
          "- Domain must be an RFC 3986 authority.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${r}`
        ]
      });
    if (!kne.test(s))
      throw new ra({
        field: "nonce",
        metaMessages: [
          "- Nonce must be at least 8 characters.",
          "- Nonce must be alphanumeric.",
          "",
          `Provided value: ${s}`
        ]
      });
    if (!c5(d))
      throw new ra({
        field: "uri",
        metaMessages: [
          "- URI must be a RFC 3986 URI referring to the resource that is the subject of the signing.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${d}`
        ]
      });
    if (p !== "1")
      throw new ra({
        field: "version",
        metaMessages: [
          "- Version must be '1'.",
          "",
          `Provided value: ${p}`
        ]
      });
    if (h && !$ne.test(h))
      throw new ra({
        field: "scheme",
        metaMessages: [
          "- Scheme must be an RFC 3986 URI scheme.",
          "- See https://www.rfc-editor.org/rfc/rfc3986#section-3.1",
          "",
          `Provided value: ${h}`
        ]
      });
    const F = t.statement;
    if (F != null && F.includes(`
`))
      throw new ra({
        field: "statement",
        metaMessages: [
          "- Statement must not include '\\n'.",
          "",
          `Provided value: ${F}`
        ]
      });
  }
  const x = L5(t.address), A = h ? `${h}://${r}` : r, I = t.statement ? `${t.statement}
` : "", N = `${A} wants you to sign in with your Ethereum account:
${x}

${I}`;
  let L = `URI: ${d}
Version: ${p}
Chain ID: ${e}
Nonce: ${s}
Issued At: ${i.toISOString()}`;
  if (n && (L += `
Expiration Time: ${n.toISOString()}`), o && (L += `
Not Before: ${o.toISOString()}`), a && (L += `
Request ID: ${a}`), u) {
    let F = `
Resources:`;
    for (const $ of u) {
      if (!c5($))
        throw new ra({
          field: "resources",
          metaMessages: [
            "- Every resource must be a RFC 3986 URI.",
            "- See https://www.rfc-editor.org/rfc/rfc3986",
            "",
            `Provided value: ${$}`
          ]
        });
      F += `
- ${$}`;
    }
    L += F;
  }
  return `${N}
${L}`;
}
const One = /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}(:[0-9]{1,5})?$/, Nne = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(:[0-9]{1,5})?$/, Lne = /^localhost(:[0-9]{1,5})?$/, kne = /^[a-zA-Z0-9]{8,}$/, $ne = /^([a-zA-Z][a-zA-Z0-9+-.]*)$/, Bne = {
  projectId: "7a4434fefbcc9af474fb5c995e47d286",
  metadata: {
    name: "codatta",
    description: "codatta",
    url: "https://codatta.io/",
    icons: ["https://avatars.githubusercontent.com/u/171659315"]
  }
}, Fne = {
  namespaces: {
    eip155: {
      methods: [
        "eth_sendTransaction",
        "eth_signTransaction",
        "eth_sign",
        "personal_sign",
        "eth_signTypedData",
        "wallet_addEthereumChain",
        "wallet_switchEthereumChain"
      ],
      chains: ["eip155:1"],
      events: ["chainChanged", "accountsChanged", "disconnect"],
      rpcMap: {
        1: "https://rpc.walletconnect.com?chainId=eip155:1&projectId=7a4434fefbcc9af474fb5c995e47d286"
      }
    }
  },
  skipPairing: !1
};
function Une(t, e) {
  const r = window.location.host, n = window.location.href;
  return O9({
    address: t,
    chainId: 1,
    domain: r,
    nonce: e,
    uri: n,
    version: "1"
  });
}
function jne(t) {
  var K, pe;
  const e = bi(null), { wallet: r, onGetExtension: n, onSignFinish: i } = t, [s, o] = Er(""), [a, u] = Er(!1), [h, d] = Er(""), [p, x] = Er("scan"), A = bi(), [I, N] = Er((K = r.config) == null ? void 0 : K.image), [L, F] = Er(!1), { saveLastUsedWallet: $ } = xc();
  async function W(_e) {
    var S, m, f, g;
    u(!0);
    const Y = await AG.init(Bne);
    console.log("provider", Y.session);
    try {
      if (x("scan"), Y.on("display_uri", (P) => {
        console.log("display_uri", P), o(P), u(!1), x("scan");
      }), Y.on("error", (P) => {
        console.log(P);
      }), Y.on("session_update", (P) => {
        console.log("session_update", P);
      }), !await Y.connect(Fne)) throw new Error("Walletconnect init failed");
      const w = new gl(Y);
      $(w), N(((S = w.config) == null ? void 0 : S.image) || ((m = _e.config) == null ? void 0 : m.image));
      const _ = await w.getAddress(), E = await va.getNonce({ account_type: "block_chain" }), v = Une(_, E);
      x("sign");
      const M = await w.signMessage(v);
      x("waiting"), await i(w, {
        message: v,
        nonce: E,
        signature: M,
        address: _,
        wallet_name: ((f = w.config) == null ? void 0 : f.name) || ((g = _e.config) == null ? void 0 : g.name) || ""
      });
    } catch (b) {
      d(b.details || b.message);
    }
  }
  function z() {
    var _e;
    A.current = new D9({
      width: 264,
      height: 264,
      margin: 0,
      type: "svg",
      image: (_e = r.config) == null ? void 0 : _e.image,
      qrOptions: {
        errorCorrectionLevel: "M"
      },
      dotsOptions: {
        color: "black",
        type: "rounded"
      },
      backgroundOptions: {
        color: "transparent"
      }
    }), A.current.append(e.current);
  }
  function V(_e) {
    var Y;
    console.log(A.current), (Y = A.current) == null || Y.update({
      data: _e
    });
  }
  si(() => {
    s && V(s);
  }, [s]), si(() => {
    W(r);
  }, [r]), si(() => {
    z();
  }, []);
  function te() {
    d(""), V(""), W(r);
  }
  function R() {
    F(!0), navigator.clipboard.writeText(s), setTimeout(() => {
      F(!1);
    }, 2500);
  }
  return /* @__PURE__ */ ve.jsxs("div", { children: [
    /* @__PURE__ */ ve.jsx("div", { className: "xc-text-center", children: /* @__PURE__ */ ve.jsxs("div", { className: "xc-relative xc-mx-auto xc-mb-6 xc-block xc-max-h-[272px] xc-max-w-[272px] xc-rounded-xl xc-bg-white xc-p-1", children: [
      /* @__PURE__ */ ve.jsx("div", { className: "xc-aspect-[1/1] xc-flex xc-h-full xc-w-full xc-justify-center", ref: e }),
      /* @__PURE__ */ ve.jsx("div", { className: "xc-absolute xc-left-0 xc-top-0 xc-flex xc-h-full xc-w-full xc-items-center xc-justify-center", children: a ? /* @__PURE__ */ ve.jsx(Pl, { className: "xc-h-6 xc-w-6 xc-animate-spin xc-text-black", size: 20 }) : /* @__PURE__ */ ve.jsx("img", { className: "xc-h-10 xc-w-10", src: I }) })
    ] }) }),
    /* @__PURE__ */ ve.jsxs("div", { className: "xc-m-auto xc-mb-6 xc-flex xc-max-w-[400px] xc-flex-wrap xc-items-center xc-justify-between xc-gap-3", children: [
      /* @__PURE__ */ ve.jsx(
        "button",
        {
          disabled: !s,
          onClick: R,
          className: "xc-disabled:hover-text-white xc-flex xc-min-w-[160px] xc-flex-1 xc-shrink-0 xc-items-center xc-justify-center xc-gap-2 xc-rounded-full xc-border xc-py-2 xc-text-sm xc-transition-all xc-hover:bg-white xc-hover:text-black xc-disabled:cursor-not-allowed xc-disabled:opacity-40 xc-disabled:hover:bg-transparent",
          children: L ? /* @__PURE__ */ ve.jsxs(ve.Fragment, { children: [
            " ",
            /* @__PURE__ */ ve.jsx(ZX, {}),
            " Copied!"
          ] }) : /* @__PURE__ */ ve.jsxs(ve.Fragment, { children: [
            /* @__PURE__ */ ve.jsx(rZ, {}),
            "Copy QR URL"
          ] })
        }
      ),
      ((pe = r.config) == null ? void 0 : pe.getWallet) && /* @__PURE__ */ ve.jsxs(
        "button",
        {
          className: "xc-rounded-2 xc-flex xc-min-w-[160px] xc-flex-1 xc-shrink-0 xc-items-center xc-justify-center xc-gap-2 xc-rounded-full xc-border xc-py-2 xc-text-sm xc-transition-all xc-hover:bg-white xc-hover:text-black",
          onClick: n,
          children: [
            /* @__PURE__ */ ve.jsx(QX, {}),
            "Get Extension"
          ]
        }
      )
    ] }),
    /* @__PURE__ */ ve.jsx("div", { className: "xc-text-center", children: h ? /* @__PURE__ */ ve.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center", children: [
      /* @__PURE__ */ ve.jsx("p", { className: "xc-text-danger xc-mb-2 xc-text-center", children: h }),
      /* @__PURE__ */ ve.jsx("button", { className: "xc-rounded-full xc-bg-gray-100 xc-px-6 xc-py-1", onClick: te, children: "Retry" })
    ] }) : /* @__PURE__ */ ve.jsxs(ve.Fragment, { children: [
      p === "scan" && /* @__PURE__ */ ve.jsx("p", { children: "Scan this QR code from your mobile wallet or phone's camera to connect." }),
      p === "connect" && /* @__PURE__ */ ve.jsx("p", { children: "Click connect in your wallet app" }),
      p === "sign" && /* @__PURE__ */ ve.jsx("p", { children: "Click sign-in in your wallet to confirm you own this wallet." }),
      p === "waiting" && /* @__PURE__ */ ve.jsx("div", { className: "xc-text-center", children: /* @__PURE__ */ ve.jsx(Pl, { className: "xc-inline-block xc-animate-spin" }) })
    ] }) })
  ] });
}
const qne = "Accept connection request in the wallet", zne = "Accept sign-in request in your wallet";
function Hne(t, e) {
  const r = window.location.host, n = window.location.href;
  return O9({
    address: t,
    chainId: 1,
    domain: r,
    nonce: e,
    uri: n,
    version: "1"
  });
}
function Wne(t) {
  var p;
  const [e, r] = Er(), { wallet: n, onSignFinish: i } = t, s = bi(), [o, a] = Er("connect"), { saveLastUsedWallet: u } = xc();
  async function h(x) {
    var A;
    try {
      a("connect");
      const I = await n.connect();
      if (!I || I.length === 0)
        throw new Error("Wallet connect error");
      const N = Hne(I[0], x);
      a("sign");
      const L = await n.signMessage(N);
      if (!L || L.length === 0)
        throw new Error("user sign error");
      a("waiting"), await i(n, { address: I[0], signature: L, message: N, nonce: x, wallet_name: ((A = n.config) == null ? void 0 : A.name) || "" }), u(n);
    } catch (I) {
      console.log(I.details), r(I.details || I.message);
    }
  }
  async function d() {
    try {
      r("");
      const x = await va.getNonce({ account_type: "block_chain" });
      s.current = x, h(s.current);
    } catch (x) {
      console.log(x.details), r(x.message);
    }
  }
  return si(() => {
    d();
  }, []), /* @__PURE__ */ ve.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center xc-justify-center xc-gap-4", children: [
    /* @__PURE__ */ ve.jsx("img", { className: "xc-rounded-md xc-h-16 xc-w-16", src: (p = n.config) == null ? void 0 : p.image, alt: "" }),
    e && /* @__PURE__ */ ve.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center", children: [
      /* @__PURE__ */ ve.jsx("p", { className: "xc-text-danger xc-mb-2 xc-text-center", children: e }),
      /* @__PURE__ */ ve.jsx("div", { className: "xc-flex xc-gap-2", children: /* @__PURE__ */ ve.jsx("button", { className: "xc-rounded-full xc-bg-gray-100 xc-px-6 xc-py-1", onClick: d, children: "Retry" }) })
    ] }),
    !e && /* @__PURE__ */ ve.jsxs(ve.Fragment, { children: [
      o === "connect" && /* @__PURE__ */ ve.jsx("span", { className: "xc-text-center", children: qne }),
      o === "sign" && /* @__PURE__ */ ve.jsx("span", { className: "xc-text-center", children: zne }),
      o === "waiting" && /* @__PURE__ */ ve.jsx("span", { className: "xc-text-center", children: /* @__PURE__ */ ve.jsx(Pl, { className: "xc-animate-spin" }) })
    ] })
  ] });
}
const Kc = "https://s.xny.ai/xny-connect/wallet-icons.svg", Kne = "https://itunes.apple.com/app/", Vne = "https://play.google.com/store/apps/details?id=", Gne = "https://chromewebstore.google.com/detail/", Yne = "https://chromewebstore.google.com/detail/", Jne = "https://addons.mozilla.org/en-US/firefox/addon/", Xne = "https://microsoftedge.microsoft.com/addons/detail/";
function Vc(t) {
  const { icon: e, title: r, link: n } = t;
  return /* @__PURE__ */ ve.jsxs(
    "a",
    {
      href: n,
      target: "_blank",
      className: "xc-flex xc-w-full xc-cursor-pointer xc-items-center xc-gap-2 xc-rounded-full xc-border xc-border-gray-100 xc-px-6 xc-py-3 xc-transition-all xc-hover:bg-white xc-hover:bg-opacity-5",
      children: [
        /* @__PURE__ */ ve.jsx("img", { className: "xc-rounded-1 xc-h-6 xc-w-6", src: e, alt: "" }),
        r,
        /* @__PURE__ */ ve.jsx(qS, { className: "xc-ml-auto xc-text-gray-400" })
      ]
    }
  );
}
function Zne(t) {
  const e = {
    appStoreLink: "",
    playStoreLink: "",
    chromeStoreLink: "",
    braveStoreLink: "",
    firefoxStoreLink: "",
    edgeStoreLink: ""
  };
  return t != null && t.app_store_id && (e.appStoreLink = `${Kne}${t.app_store_id}`), t != null && t.play_store_id && (e.playStoreLink = `${Vne}${t.play_store_id}`), t != null && t.chrome_store_id && (e.chromeStoreLink = `${Gne}${t.chrome_store_id}`), t != null && t.brave_store_id && (e.braveStoreLink = `${Yne}${t.brave_store_id}`), t != null && t.firefox_addon_id && (e.firefoxStoreLink = `${Jne}${t.firefox_addon_id}`), t != null && t.edge_addon_id && (e.edgeStoreLink = `${Xne}${t.edge_addon_id}`), e;
}
function Qne(t) {
  var i, s, o;
  const { wallet: e } = t, r = (i = e.config) == null ? void 0 : i.getWallet, n = Zne(r);
  return /* @__PURE__ */ ve.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center", children: [
    /* @__PURE__ */ ve.jsx("img", { className: "xc-rounded-md xc-mb-2 xc-h-12 xc-w-12", src: (s = e.config) == null ? void 0 : s.image, alt: "" }),
    /* @__PURE__ */ ve.jsxs("p", { className: "xc-text-lg xc-font-bold", children: [
      "Install ",
      (o = e.config) == null ? void 0 : o.name,
      " to connect"
    ] }),
    /* @__PURE__ */ ve.jsx("p", { className: "xc-mb-6 xc-text-sm xc-text-gray-500", children: "Select from your preferred options below:" }),
    /* @__PURE__ */ ve.jsxs("div", { className: "xc-grid xc-w-full xc-grid-cols-1 xc-gap-3", children: [
      (r == null ? void 0 : r.chrome_store_id) && /* @__PURE__ */ ve.jsx(
        Vc,
        {
          link: n.chromeStoreLink,
          icon: `${Kc}#chrome`,
          title: "Google Play Store"
        }
      ),
      (r == null ? void 0 : r.app_store_id) && /* @__PURE__ */ ve.jsx(
        Vc,
        {
          link: n.appStoreLink,
          icon: `${Kc}#apple`,
          title: "Apple App Store"
        }
      ),
      (r == null ? void 0 : r.play_store_id) && /* @__PURE__ */ ve.jsx(
        Vc,
        {
          link: n.playStoreLink,
          icon: `${Kc}#android`,
          title: "Google Play Store"
        }
      ),
      (r == null ? void 0 : r.edge_addon_id) && /* @__PURE__ */ ve.jsx(
        Vc,
        {
          link: n.edgeStoreLink,
          icon: `${Kc}#edge`,
          title: "Microsoft Edge"
        }
      ),
      (r == null ? void 0 : r.brave_store_id) && /* @__PURE__ */ ve.jsx(
        Vc,
        {
          link: n.braveStoreLink,
          icon: `${Kc}#brave`,
          title: "Brave extension"
        }
      ),
      (r == null ? void 0 : r.firefox_addon_id) && /* @__PURE__ */ ve.jsx(
        Vc,
        {
          link: n.firefoxStoreLink,
          icon: `${Kc}#firefox`,
          title: "Mozilla Firefox"
        }
      )
    ] })
  ] });
}
function eie(t) {
  const { wallet: e } = t, [r, n] = Er(e.installed ? "connect" : "qr"), { config: i } = xc();
  async function s(o, a) {
    var h;
    const u = await va.walletLogin({
      account_type: "block_chain",
      account_enum: "C",
      connector: "codatta_wallet",
      inviter_code: i.inviderCode,
      wallet_name: ((h = o.config) == null ? void 0 : h.name) || o.key,
      address: await o.getAddress(),
      chain: (await o.getChain()).toString(),
      nonce: a.nonce,
      signature: a.signature,
      message: a.message,
      source: {
        device: i.device,
        channel: i.channel,
        app: i.app
      }
    });
    await t.onLogin(u.data);
  }
  return /* @__PURE__ */ ve.jsxs(Ec, { children: [
    /* @__PURE__ */ ve.jsx("div", { className: "xc-mb-6", children: /* @__PURE__ */ ve.jsx(uh, { title: "Log in to codatta", onBack: t.onBack }) }),
    r === "qr" && /* @__PURE__ */ ve.jsx(
      jne,
      {
        wallet: e,
        onGetExtension: () => n("get-extension"),
        onSignFinish: s
      }
    ),
    r === "connect" && /* @__PURE__ */ ve.jsx(
      Wne,
      {
        onShowQrCode: () => n("qr"),
        wallet: e,
        onSignFinish: s
      }
    ),
    r === "get-extension" && /* @__PURE__ */ ve.jsx(Qne, { wallet: e })
  ] });
}
function tie(t) {
  const { wallet: e, onClick: r } = t, n = /* @__PURE__ */ ve.jsx("img", { className: "xc-rounded-md xc-h-5 xc-w-5", src: e.imageUrl }), i = e.name || "";
  return /* @__PURE__ */ ve.jsx(sy, { icon: n, title: i, onClick: () => r(e) });
}
function rie(t) {
  const { connector: e } = t, [r, n] = Er(), [i, s] = Er([]), o = Oi(() => r ? i.filter((d) => d.name.toLowerCase().includes(r.toLowerCase())) : i, [r, i]);
  function a(d) {
    n(d.target.value);
  }
  async function u() {
    const d = await e.getWallets();
    s(d), console.log(d);
  }
  si(() => {
    u();
  }, []);
  function h(d) {
    t.onSelect(d);
  }
  return /* @__PURE__ */ ve.jsxs(Ec, { children: [
    /* @__PURE__ */ ve.jsx("div", { className: "xc-mb-6", children: /* @__PURE__ */ ve.jsx(uh, { title: "Log in to codatta", onBack: t.onBack }) }),
    /* @__PURE__ */ ve.jsxs("div", { className: "xc-mb-6 xc-flex xc-gap-3 xc-px-4 xc-py-2 xc-border xc-rounded-xl xc-w-full xc-overflow-hidden xc-items-center", children: [
      /* @__PURE__ */ ve.jsx(zS, { className: "xc-shrink-0 xc-opacity-50" }),
      /* @__PURE__ */ ve.jsx("input", { type: "text", className: "xc-flex-1 xc-appearance-none xc-outline-none", onInput: a })
    ] }),
    /* @__PURE__ */ ve.jsx("div", { className: "xc-mb-4 xc-flex xc-h-[309px] xc-flex-col xc-gap-4 xc-overflow-scroll", children: o == null ? void 0 : o.map((d) => /* @__PURE__ */ ve.jsx(tie, { wallet: d, onClick: h }, d.name)) })
  ] });
}
var N9 = { exports: {} };
(function(t) {
  (function(e, r) {
    t.exports ? t.exports = r() : (e.nacl || (e.nacl = {}), e.nacl.util = r());
  })(gn, function() {
    var e = {};
    function r(n) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(n))
        throw new TypeError("invalid encoding");
    }
    return e.decodeUTF8 = function(n) {
      if (typeof n != "string") throw new TypeError("expected string");
      var i, s = unescape(encodeURIComponent(n)), o = new Uint8Array(s.length);
      for (i = 0; i < s.length; i++) o[i] = s.charCodeAt(i);
      return o;
    }, e.encodeUTF8 = function(n) {
      var i, s = [];
      for (i = 0; i < n.length; i++) s.push(String.fromCharCode(n[i]));
      return decodeURIComponent(escape(s.join("")));
    }, typeof atob > "u" ? typeof Buffer.from < "u" ? (e.encodeBase64 = function(n) {
      return Buffer.from(n).toString("base64");
    }, e.decodeBase64 = function(n) {
      return r(n), new Uint8Array(Array.prototype.slice.call(Buffer.from(n, "base64"), 0));
    }) : (e.encodeBase64 = function(n) {
      return new Buffer(n).toString("base64");
    }, e.decodeBase64 = function(n) {
      return r(n), new Uint8Array(Array.prototype.slice.call(new Buffer(n, "base64"), 0));
    }) : (e.encodeBase64 = function(n) {
      var i, s = [], o = n.length;
      for (i = 0; i < o; i++) s.push(String.fromCharCode(n[i]));
      return btoa(s.join(""));
    }, e.decodeBase64 = function(n) {
      r(n);
      var i, s = atob(n), o = new Uint8Array(s.length);
      for (i = 0; i < s.length; i++) o[i] = s.charCodeAt(i);
      return o;
    }), e;
  });
})(N9);
var nie = N9.exports;
const Rl = /* @__PURE__ */ ts(nie);
var L9 = { exports: {} };
(function(t) {
  (function(e) {
    var r = function(k) {
      var j, H = new Float64Array(16);
      if (k) for (j = 0; j < k.length; j++) H[j] = k[j];
      return H;
    }, n = function() {
      throw new Error("no PRNG");
    }, i = new Uint8Array(16), s = new Uint8Array(32);
    s[0] = 9;
    var o = r(), a = r([1]), u = r([56129, 1]), h = r([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), d = r([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), p = r([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), x = r([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), A = r([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function I(k, j, H, C) {
      k[j] = H >> 24 & 255, k[j + 1] = H >> 16 & 255, k[j + 2] = H >> 8 & 255, k[j + 3] = H & 255, k[j + 4] = C >> 24 & 255, k[j + 5] = C >> 16 & 255, k[j + 6] = C >> 8 & 255, k[j + 7] = C & 255;
    }
    function N(k, j, H, C, G) {
      var U, se = 0;
      for (U = 0; U < G; U++) se |= k[j + U] ^ H[C + U];
      return (1 & se - 1 >>> 8) - 1;
    }
    function L(k, j, H, C) {
      return N(k, j, H, C, 16);
    }
    function F(k, j, H, C) {
      return N(k, j, H, C, 32);
    }
    function $(k, j, H, C) {
      for (var G = C[0] & 255 | (C[1] & 255) << 8 | (C[2] & 255) << 16 | (C[3] & 255) << 24, U = H[0] & 255 | (H[1] & 255) << 8 | (H[2] & 255) << 16 | (H[3] & 255) << 24, se = H[4] & 255 | (H[5] & 255) << 8 | (H[6] & 255) << 16 | (H[7] & 255) << 24, he = H[8] & 255 | (H[9] & 255) << 8 | (H[10] & 255) << 16 | (H[11] & 255) << 24, xe = H[12] & 255 | (H[13] & 255) << 8 | (H[14] & 255) << 16 | (H[15] & 255) << 24, Te = C[4] & 255 | (C[5] & 255) << 8 | (C[6] & 255) << 16 | (C[7] & 255) << 24, Re = j[0] & 255 | (j[1] & 255) << 8 | (j[2] & 255) << 16 | (j[3] & 255) << 24, nt = j[4] & 255 | (j[5] & 255) << 8 | (j[6] & 255) << 16 | (j[7] & 255) << 24, Ue = j[8] & 255 | (j[9] & 255) << 8 | (j[10] & 255) << 16 | (j[11] & 255) << 24, pt = j[12] & 255 | (j[13] & 255) << 8 | (j[14] & 255) << 16 | (j[15] & 255) << 24, it = C[8] & 255 | (C[9] & 255) << 8 | (C[10] & 255) << 16 | (C[11] & 255) << 24, et = H[16] & 255 | (H[17] & 255) << 8 | (H[18] & 255) << 16 | (H[19] & 255) << 24, St = H[20] & 255 | (H[21] & 255) << 8 | (H[22] & 255) << 16 | (H[23] & 255) << 24, Tt = H[24] & 255 | (H[25] & 255) << 8 | (H[26] & 255) << 16 | (H[27] & 255) << 24, At = H[28] & 255 | (H[29] & 255) << 8 | (H[30] & 255) << 16 | (H[31] & 255) << 24, _t = C[12] & 255 | (C[13] & 255) << 8 | (C[14] & 255) << 16 | (C[15] & 255) << 24, ht = G, xt = U, st = se, bt = he, ut = xe, ot = Te, Se = Re, Ae = nt, Ve = Ue, Fe = pt, je = it, Je = et, Lt = St, zt = Tt, Xt = At, Ht = _t, le, tr = 0; tr < 20; tr += 2)
        le = ht + Lt | 0, ut ^= le << 7 | le >>> 25, le = ut + ht | 0, Ve ^= le << 9 | le >>> 23, le = Ve + ut | 0, Lt ^= le << 13 | le >>> 19, le = Lt + Ve | 0, ht ^= le << 18 | le >>> 14, le = ot + xt | 0, Fe ^= le << 7 | le >>> 25, le = Fe + ot | 0, zt ^= le << 9 | le >>> 23, le = zt + Fe | 0, xt ^= le << 13 | le >>> 19, le = xt + zt | 0, ot ^= le << 18 | le >>> 14, le = je + Se | 0, Xt ^= le << 7 | le >>> 25, le = Xt + je | 0, st ^= le << 9 | le >>> 23, le = st + Xt | 0, Se ^= le << 13 | le >>> 19, le = Se + st | 0, je ^= le << 18 | le >>> 14, le = Ht + Je | 0, bt ^= le << 7 | le >>> 25, le = bt + Ht | 0, Ae ^= le << 9 | le >>> 23, le = Ae + bt | 0, Je ^= le << 13 | le >>> 19, le = Je + Ae | 0, Ht ^= le << 18 | le >>> 14, le = ht + bt | 0, xt ^= le << 7 | le >>> 25, le = xt + ht | 0, st ^= le << 9 | le >>> 23, le = st + xt | 0, bt ^= le << 13 | le >>> 19, le = bt + st | 0, ht ^= le << 18 | le >>> 14, le = ot + ut | 0, Se ^= le << 7 | le >>> 25, le = Se + ot | 0, Ae ^= le << 9 | le >>> 23, le = Ae + Se | 0, ut ^= le << 13 | le >>> 19, le = ut + Ae | 0, ot ^= le << 18 | le >>> 14, le = je + Fe | 0, Je ^= le << 7 | le >>> 25, le = Je + je | 0, Ve ^= le << 9 | le >>> 23, le = Ve + Je | 0, Fe ^= le << 13 | le >>> 19, le = Fe + Ve | 0, je ^= le << 18 | le >>> 14, le = Ht + Xt | 0, Lt ^= le << 7 | le >>> 25, le = Lt + Ht | 0, zt ^= le << 9 | le >>> 23, le = zt + Lt | 0, Xt ^= le << 13 | le >>> 19, le = Xt + zt | 0, Ht ^= le << 18 | le >>> 14;
      ht = ht + G | 0, xt = xt + U | 0, st = st + se | 0, bt = bt + he | 0, ut = ut + xe | 0, ot = ot + Te | 0, Se = Se + Re | 0, Ae = Ae + nt | 0, Ve = Ve + Ue | 0, Fe = Fe + pt | 0, je = je + it | 0, Je = Je + et | 0, Lt = Lt + St | 0, zt = zt + Tt | 0, Xt = Xt + At | 0, Ht = Ht + _t | 0, k[0] = ht >>> 0 & 255, k[1] = ht >>> 8 & 255, k[2] = ht >>> 16 & 255, k[3] = ht >>> 24 & 255, k[4] = xt >>> 0 & 255, k[5] = xt >>> 8 & 255, k[6] = xt >>> 16 & 255, k[7] = xt >>> 24 & 255, k[8] = st >>> 0 & 255, k[9] = st >>> 8 & 255, k[10] = st >>> 16 & 255, k[11] = st >>> 24 & 255, k[12] = bt >>> 0 & 255, k[13] = bt >>> 8 & 255, k[14] = bt >>> 16 & 255, k[15] = bt >>> 24 & 255, k[16] = ut >>> 0 & 255, k[17] = ut >>> 8 & 255, k[18] = ut >>> 16 & 255, k[19] = ut >>> 24 & 255, k[20] = ot >>> 0 & 255, k[21] = ot >>> 8 & 255, k[22] = ot >>> 16 & 255, k[23] = ot >>> 24 & 255, k[24] = Se >>> 0 & 255, k[25] = Se >>> 8 & 255, k[26] = Se >>> 16 & 255, k[27] = Se >>> 24 & 255, k[28] = Ae >>> 0 & 255, k[29] = Ae >>> 8 & 255, k[30] = Ae >>> 16 & 255, k[31] = Ae >>> 24 & 255, k[32] = Ve >>> 0 & 255, k[33] = Ve >>> 8 & 255, k[34] = Ve >>> 16 & 255, k[35] = Ve >>> 24 & 255, k[36] = Fe >>> 0 & 255, k[37] = Fe >>> 8 & 255, k[38] = Fe >>> 16 & 255, k[39] = Fe >>> 24 & 255, k[40] = je >>> 0 & 255, k[41] = je >>> 8 & 255, k[42] = je >>> 16 & 255, k[43] = je >>> 24 & 255, k[44] = Je >>> 0 & 255, k[45] = Je >>> 8 & 255, k[46] = Je >>> 16 & 255, k[47] = Je >>> 24 & 255, k[48] = Lt >>> 0 & 255, k[49] = Lt >>> 8 & 255, k[50] = Lt >>> 16 & 255, k[51] = Lt >>> 24 & 255, k[52] = zt >>> 0 & 255, k[53] = zt >>> 8 & 255, k[54] = zt >>> 16 & 255, k[55] = zt >>> 24 & 255, k[56] = Xt >>> 0 & 255, k[57] = Xt >>> 8 & 255, k[58] = Xt >>> 16 & 255, k[59] = Xt >>> 24 & 255, k[60] = Ht >>> 0 & 255, k[61] = Ht >>> 8 & 255, k[62] = Ht >>> 16 & 255, k[63] = Ht >>> 24 & 255;
    }
    function W(k, j, H, C) {
      for (var G = C[0] & 255 | (C[1] & 255) << 8 | (C[2] & 255) << 16 | (C[3] & 255) << 24, U = H[0] & 255 | (H[1] & 255) << 8 | (H[2] & 255) << 16 | (H[3] & 255) << 24, se = H[4] & 255 | (H[5] & 255) << 8 | (H[6] & 255) << 16 | (H[7] & 255) << 24, he = H[8] & 255 | (H[9] & 255) << 8 | (H[10] & 255) << 16 | (H[11] & 255) << 24, xe = H[12] & 255 | (H[13] & 255) << 8 | (H[14] & 255) << 16 | (H[15] & 255) << 24, Te = C[4] & 255 | (C[5] & 255) << 8 | (C[6] & 255) << 16 | (C[7] & 255) << 24, Re = j[0] & 255 | (j[1] & 255) << 8 | (j[2] & 255) << 16 | (j[3] & 255) << 24, nt = j[4] & 255 | (j[5] & 255) << 8 | (j[6] & 255) << 16 | (j[7] & 255) << 24, Ue = j[8] & 255 | (j[9] & 255) << 8 | (j[10] & 255) << 16 | (j[11] & 255) << 24, pt = j[12] & 255 | (j[13] & 255) << 8 | (j[14] & 255) << 16 | (j[15] & 255) << 24, it = C[8] & 255 | (C[9] & 255) << 8 | (C[10] & 255) << 16 | (C[11] & 255) << 24, et = H[16] & 255 | (H[17] & 255) << 8 | (H[18] & 255) << 16 | (H[19] & 255) << 24, St = H[20] & 255 | (H[21] & 255) << 8 | (H[22] & 255) << 16 | (H[23] & 255) << 24, Tt = H[24] & 255 | (H[25] & 255) << 8 | (H[26] & 255) << 16 | (H[27] & 255) << 24, At = H[28] & 255 | (H[29] & 255) << 8 | (H[30] & 255) << 16 | (H[31] & 255) << 24, _t = C[12] & 255 | (C[13] & 255) << 8 | (C[14] & 255) << 16 | (C[15] & 255) << 24, ht = G, xt = U, st = se, bt = he, ut = xe, ot = Te, Se = Re, Ae = nt, Ve = Ue, Fe = pt, je = it, Je = et, Lt = St, zt = Tt, Xt = At, Ht = _t, le, tr = 0; tr < 20; tr += 2)
        le = ht + Lt | 0, ut ^= le << 7 | le >>> 25, le = ut + ht | 0, Ve ^= le << 9 | le >>> 23, le = Ve + ut | 0, Lt ^= le << 13 | le >>> 19, le = Lt + Ve | 0, ht ^= le << 18 | le >>> 14, le = ot + xt | 0, Fe ^= le << 7 | le >>> 25, le = Fe + ot | 0, zt ^= le << 9 | le >>> 23, le = zt + Fe | 0, xt ^= le << 13 | le >>> 19, le = xt + zt | 0, ot ^= le << 18 | le >>> 14, le = je + Se | 0, Xt ^= le << 7 | le >>> 25, le = Xt + je | 0, st ^= le << 9 | le >>> 23, le = st + Xt | 0, Se ^= le << 13 | le >>> 19, le = Se + st | 0, je ^= le << 18 | le >>> 14, le = Ht + Je | 0, bt ^= le << 7 | le >>> 25, le = bt + Ht | 0, Ae ^= le << 9 | le >>> 23, le = Ae + bt | 0, Je ^= le << 13 | le >>> 19, le = Je + Ae | 0, Ht ^= le << 18 | le >>> 14, le = ht + bt | 0, xt ^= le << 7 | le >>> 25, le = xt + ht | 0, st ^= le << 9 | le >>> 23, le = st + xt | 0, bt ^= le << 13 | le >>> 19, le = bt + st | 0, ht ^= le << 18 | le >>> 14, le = ot + ut | 0, Se ^= le << 7 | le >>> 25, le = Se + ot | 0, Ae ^= le << 9 | le >>> 23, le = Ae + Se | 0, ut ^= le << 13 | le >>> 19, le = ut + Ae | 0, ot ^= le << 18 | le >>> 14, le = je + Fe | 0, Je ^= le << 7 | le >>> 25, le = Je + je | 0, Ve ^= le << 9 | le >>> 23, le = Ve + Je | 0, Fe ^= le << 13 | le >>> 19, le = Fe + Ve | 0, je ^= le << 18 | le >>> 14, le = Ht + Xt | 0, Lt ^= le << 7 | le >>> 25, le = Lt + Ht | 0, zt ^= le << 9 | le >>> 23, le = zt + Lt | 0, Xt ^= le << 13 | le >>> 19, le = Xt + zt | 0, Ht ^= le << 18 | le >>> 14;
      k[0] = ht >>> 0 & 255, k[1] = ht >>> 8 & 255, k[2] = ht >>> 16 & 255, k[3] = ht >>> 24 & 255, k[4] = ot >>> 0 & 255, k[5] = ot >>> 8 & 255, k[6] = ot >>> 16 & 255, k[7] = ot >>> 24 & 255, k[8] = je >>> 0 & 255, k[9] = je >>> 8 & 255, k[10] = je >>> 16 & 255, k[11] = je >>> 24 & 255, k[12] = Ht >>> 0 & 255, k[13] = Ht >>> 8 & 255, k[14] = Ht >>> 16 & 255, k[15] = Ht >>> 24 & 255, k[16] = Se >>> 0 & 255, k[17] = Se >>> 8 & 255, k[18] = Se >>> 16 & 255, k[19] = Se >>> 24 & 255, k[20] = Ae >>> 0 & 255, k[21] = Ae >>> 8 & 255, k[22] = Ae >>> 16 & 255, k[23] = Ae >>> 24 & 255, k[24] = Ve >>> 0 & 255, k[25] = Ve >>> 8 & 255, k[26] = Ve >>> 16 & 255, k[27] = Ve >>> 24 & 255, k[28] = Fe >>> 0 & 255, k[29] = Fe >>> 8 & 255, k[30] = Fe >>> 16 & 255, k[31] = Fe >>> 24 & 255;
    }
    function z(k, j, H, C) {
      $(k, j, H, C);
    }
    function V(k, j, H, C) {
      W(k, j, H, C);
    }
    var te = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function R(k, j, H, C, G, U, se) {
      var he = new Uint8Array(16), xe = new Uint8Array(64), Te, Re;
      for (Re = 0; Re < 16; Re++) he[Re] = 0;
      for (Re = 0; Re < 8; Re++) he[Re] = U[Re];
      for (; G >= 64; ) {
        for (z(xe, he, se, te), Re = 0; Re < 64; Re++) k[j + Re] = H[C + Re] ^ xe[Re];
        for (Te = 1, Re = 8; Re < 16; Re++)
          Te = Te + (he[Re] & 255) | 0, he[Re] = Te & 255, Te >>>= 8;
        G -= 64, j += 64, C += 64;
      }
      if (G > 0)
        for (z(xe, he, se, te), Re = 0; Re < G; Re++) k[j + Re] = H[C + Re] ^ xe[Re];
      return 0;
    }
    function K(k, j, H, C, G) {
      var U = new Uint8Array(16), se = new Uint8Array(64), he, xe;
      for (xe = 0; xe < 16; xe++) U[xe] = 0;
      for (xe = 0; xe < 8; xe++) U[xe] = C[xe];
      for (; H >= 64; ) {
        for (z(se, U, G, te), xe = 0; xe < 64; xe++) k[j + xe] = se[xe];
        for (he = 1, xe = 8; xe < 16; xe++)
          he = he + (U[xe] & 255) | 0, U[xe] = he & 255, he >>>= 8;
        H -= 64, j += 64;
      }
      if (H > 0)
        for (z(se, U, G, te), xe = 0; xe < H; xe++) k[j + xe] = se[xe];
      return 0;
    }
    function pe(k, j, H, C, G) {
      var U = new Uint8Array(32);
      V(U, C, G, te);
      for (var se = new Uint8Array(8), he = 0; he < 8; he++) se[he] = C[he + 16];
      return K(k, j, H, se, U);
    }
    function _e(k, j, H, C, G, U, se) {
      var he = new Uint8Array(32);
      V(he, U, se, te);
      for (var xe = new Uint8Array(8), Te = 0; Te < 8; Te++) xe[Te] = U[Te + 16];
      return R(k, j, H, C, G, xe, he);
    }
    var Y = function(k) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var j, H, C, G, U, se, he, xe;
      j = k[0] & 255 | (k[1] & 255) << 8, this.r[0] = j & 8191, H = k[2] & 255 | (k[3] & 255) << 8, this.r[1] = (j >>> 13 | H << 3) & 8191, C = k[4] & 255 | (k[5] & 255) << 8, this.r[2] = (H >>> 10 | C << 6) & 7939, G = k[6] & 255 | (k[7] & 255) << 8, this.r[3] = (C >>> 7 | G << 9) & 8191, U = k[8] & 255 | (k[9] & 255) << 8, this.r[4] = (G >>> 4 | U << 12) & 255, this.r[5] = U >>> 1 & 8190, se = k[10] & 255 | (k[11] & 255) << 8, this.r[6] = (U >>> 14 | se << 2) & 8191, he = k[12] & 255 | (k[13] & 255) << 8, this.r[7] = (se >>> 11 | he << 5) & 8065, xe = k[14] & 255 | (k[15] & 255) << 8, this.r[8] = (he >>> 8 | xe << 8) & 8191, this.r[9] = xe >>> 5 & 127, this.pad[0] = k[16] & 255 | (k[17] & 255) << 8, this.pad[1] = k[18] & 255 | (k[19] & 255) << 8, this.pad[2] = k[20] & 255 | (k[21] & 255) << 8, this.pad[3] = k[22] & 255 | (k[23] & 255) << 8, this.pad[4] = k[24] & 255 | (k[25] & 255) << 8, this.pad[5] = k[26] & 255 | (k[27] & 255) << 8, this.pad[6] = k[28] & 255 | (k[29] & 255) << 8, this.pad[7] = k[30] & 255 | (k[31] & 255) << 8;
    };
    Y.prototype.blocks = function(k, j, H) {
      for (var C = this.fin ? 0 : 2048, G, U, se, he, xe, Te, Re, nt, Ue, pt, it, et, St, Tt, At, _t, ht, xt, st, bt = this.h[0], ut = this.h[1], ot = this.h[2], Se = this.h[3], Ae = this.h[4], Ve = this.h[5], Fe = this.h[6], je = this.h[7], Je = this.h[8], Lt = this.h[9], zt = this.r[0], Xt = this.r[1], Ht = this.r[2], le = this.r[3], tr = this.r[4], hr = this.r[5], dr = this.r[6], Zt = this.r[7], pr = this.r[8], fr = this.r[9]; H >= 16; )
        G = k[j + 0] & 255 | (k[j + 1] & 255) << 8, bt += G & 8191, U = k[j + 2] & 255 | (k[j + 3] & 255) << 8, ut += (G >>> 13 | U << 3) & 8191, se = k[j + 4] & 255 | (k[j + 5] & 255) << 8, ot += (U >>> 10 | se << 6) & 8191, he = k[j + 6] & 255 | (k[j + 7] & 255) << 8, Se += (se >>> 7 | he << 9) & 8191, xe = k[j + 8] & 255 | (k[j + 9] & 255) << 8, Ae += (he >>> 4 | xe << 12) & 8191, Ve += xe >>> 1 & 8191, Te = k[j + 10] & 255 | (k[j + 11] & 255) << 8, Fe += (xe >>> 14 | Te << 2) & 8191, Re = k[j + 12] & 255 | (k[j + 13] & 255) << 8, je += (Te >>> 11 | Re << 5) & 8191, nt = k[j + 14] & 255 | (k[j + 15] & 255) << 8, Je += (Re >>> 8 | nt << 8) & 8191, Lt += nt >>> 5 | C, Ue = 0, pt = Ue, pt += bt * zt, pt += ut * (5 * fr), pt += ot * (5 * pr), pt += Se * (5 * Zt), pt += Ae * (5 * dr), Ue = pt >>> 13, pt &= 8191, pt += Ve * (5 * hr), pt += Fe * (5 * tr), pt += je * (5 * le), pt += Je * (5 * Ht), pt += Lt * (5 * Xt), Ue += pt >>> 13, pt &= 8191, it = Ue, it += bt * Xt, it += ut * zt, it += ot * (5 * fr), it += Se * (5 * pr), it += Ae * (5 * Zt), Ue = it >>> 13, it &= 8191, it += Ve * (5 * dr), it += Fe * (5 * hr), it += je * (5 * tr), it += Je * (5 * le), it += Lt * (5 * Ht), Ue += it >>> 13, it &= 8191, et = Ue, et += bt * Ht, et += ut * Xt, et += ot * zt, et += Se * (5 * fr), et += Ae * (5 * pr), Ue = et >>> 13, et &= 8191, et += Ve * (5 * Zt), et += Fe * (5 * dr), et += je * (5 * hr), et += Je * (5 * tr), et += Lt * (5 * le), Ue += et >>> 13, et &= 8191, St = Ue, St += bt * le, St += ut * Ht, St += ot * Xt, St += Se * zt, St += Ae * (5 * fr), Ue = St >>> 13, St &= 8191, St += Ve * (5 * pr), St += Fe * (5 * Zt), St += je * (5 * dr), St += Je * (5 * hr), St += Lt * (5 * tr), Ue += St >>> 13, St &= 8191, Tt = Ue, Tt += bt * tr, Tt += ut * le, Tt += ot * Ht, Tt += Se * Xt, Tt += Ae * zt, Ue = Tt >>> 13, Tt &= 8191, Tt += Ve * (5 * fr), Tt += Fe * (5 * pr), Tt += je * (5 * Zt), Tt += Je * (5 * dr), Tt += Lt * (5 * hr), Ue += Tt >>> 13, Tt &= 8191, At = Ue, At += bt * hr, At += ut * tr, At += ot * le, At += Se * Ht, At += Ae * Xt, Ue = At >>> 13, At &= 8191, At += Ve * zt, At += Fe * (5 * fr), At += je * (5 * pr), At += Je * (5 * Zt), At += Lt * (5 * dr), Ue += At >>> 13, At &= 8191, _t = Ue, _t += bt * dr, _t += ut * hr, _t += ot * tr, _t += Se * le, _t += Ae * Ht, Ue = _t >>> 13, _t &= 8191, _t += Ve * Xt, _t += Fe * zt, _t += je * (5 * fr), _t += Je * (5 * pr), _t += Lt * (5 * Zt), Ue += _t >>> 13, _t &= 8191, ht = Ue, ht += bt * Zt, ht += ut * dr, ht += ot * hr, ht += Se * tr, ht += Ae * le, Ue = ht >>> 13, ht &= 8191, ht += Ve * Ht, ht += Fe * Xt, ht += je * zt, ht += Je * (5 * fr), ht += Lt * (5 * pr), Ue += ht >>> 13, ht &= 8191, xt = Ue, xt += bt * pr, xt += ut * Zt, xt += ot * dr, xt += Se * hr, xt += Ae * tr, Ue = xt >>> 13, xt &= 8191, xt += Ve * le, xt += Fe * Ht, xt += je * Xt, xt += Je * zt, xt += Lt * (5 * fr), Ue += xt >>> 13, xt &= 8191, st = Ue, st += bt * fr, st += ut * pr, st += ot * Zt, st += Se * dr, st += Ae * hr, Ue = st >>> 13, st &= 8191, st += Ve * tr, st += Fe * le, st += je * Ht, st += Je * Xt, st += Lt * zt, Ue += st >>> 13, st &= 8191, Ue = (Ue << 2) + Ue | 0, Ue = Ue + pt | 0, pt = Ue & 8191, Ue = Ue >>> 13, it += Ue, bt = pt, ut = it, ot = et, Se = St, Ae = Tt, Ve = At, Fe = _t, je = ht, Je = xt, Lt = st, j += 16, H -= 16;
      this.h[0] = bt, this.h[1] = ut, this.h[2] = ot, this.h[3] = Se, this.h[4] = Ae, this.h[5] = Ve, this.h[6] = Fe, this.h[7] = je, this.h[8] = Je, this.h[9] = Lt;
    }, Y.prototype.finish = function(k, j) {
      var H = new Uint16Array(10), C, G, U, se;
      if (this.leftover) {
        for (se = this.leftover, this.buffer[se++] = 1; se < 16; se++) this.buffer[se] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (C = this.h[1] >>> 13, this.h[1] &= 8191, se = 2; se < 10; se++)
        this.h[se] += C, C = this.h[se] >>> 13, this.h[se] &= 8191;
      for (this.h[0] += C * 5, C = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += C, C = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += C, H[0] = this.h[0] + 5, C = H[0] >>> 13, H[0] &= 8191, se = 1; se < 10; se++)
        H[se] = this.h[se] + C, C = H[se] >>> 13, H[se] &= 8191;
      for (H[9] -= 8192, G = (C ^ 1) - 1, se = 0; se < 10; se++) H[se] &= G;
      for (G = ~G, se = 0; se < 10; se++) this.h[se] = this.h[se] & G | H[se];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, U = this.h[0] + this.pad[0], this.h[0] = U & 65535, se = 1; se < 8; se++)
        U = (this.h[se] + this.pad[se] | 0) + (U >>> 16) | 0, this.h[se] = U & 65535;
      k[j + 0] = this.h[0] >>> 0 & 255, k[j + 1] = this.h[0] >>> 8 & 255, k[j + 2] = this.h[1] >>> 0 & 255, k[j + 3] = this.h[1] >>> 8 & 255, k[j + 4] = this.h[2] >>> 0 & 255, k[j + 5] = this.h[2] >>> 8 & 255, k[j + 6] = this.h[3] >>> 0 & 255, k[j + 7] = this.h[3] >>> 8 & 255, k[j + 8] = this.h[4] >>> 0 & 255, k[j + 9] = this.h[4] >>> 8 & 255, k[j + 10] = this.h[5] >>> 0 & 255, k[j + 11] = this.h[5] >>> 8 & 255, k[j + 12] = this.h[6] >>> 0 & 255, k[j + 13] = this.h[6] >>> 8 & 255, k[j + 14] = this.h[7] >>> 0 & 255, k[j + 15] = this.h[7] >>> 8 & 255;
    }, Y.prototype.update = function(k, j, H) {
      var C, G;
      if (this.leftover) {
        for (G = 16 - this.leftover, G > H && (G = H), C = 0; C < G; C++)
          this.buffer[this.leftover + C] = k[j + C];
        if (H -= G, j += G, this.leftover += G, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (H >= 16 && (G = H - H % 16, this.blocks(k, j, G), j += G, H -= G), H) {
        for (C = 0; C < H; C++)
          this.buffer[this.leftover + C] = k[j + C];
        this.leftover += H;
      }
    };
    function S(k, j, H, C, G, U) {
      var se = new Y(U);
      return se.update(H, C, G), se.finish(k, j), 0;
    }
    function m(k, j, H, C, G, U) {
      var se = new Uint8Array(16);
      return S(se, 0, H, C, G, U), L(k, j, se, 0);
    }
    function f(k, j, H, C, G) {
      var U;
      if (H < 32) return -1;
      for (_e(k, 0, j, 0, H, C, G), S(k, 16, k, 32, H - 32, k), U = 0; U < 16; U++) k[U] = 0;
      return 0;
    }
    function g(k, j, H, C, G) {
      var U, se = new Uint8Array(32);
      if (H < 32 || (pe(se, 0, 32, C, G), m(j, 16, j, 32, H - 32, se) !== 0)) return -1;
      for (_e(k, 0, j, 0, H, C, G), U = 0; U < 32; U++) k[U] = 0;
      return 0;
    }
    function b(k, j) {
      var H;
      for (H = 0; H < 16; H++) k[H] = j[H] | 0;
    }
    function w(k) {
      var j, H, C = 1;
      for (j = 0; j < 16; j++)
        H = k[j] + C + 65535, C = Math.floor(H / 65536), k[j] = H - C * 65536;
      k[0] += C - 1 + 37 * (C - 1);
    }
    function _(k, j, H) {
      for (var C, G = ~(H - 1), U = 0; U < 16; U++)
        C = G & (k[U] ^ j[U]), k[U] ^= C, j[U] ^= C;
    }
    function E(k, j) {
      var H, C, G, U = r(), se = r();
      for (H = 0; H < 16; H++) se[H] = j[H];
      for (w(se), w(se), w(se), C = 0; C < 2; C++) {
        for (U[0] = se[0] - 65517, H = 1; H < 15; H++)
          U[H] = se[H] - 65535 - (U[H - 1] >> 16 & 1), U[H - 1] &= 65535;
        U[15] = se[15] - 32767 - (U[14] >> 16 & 1), G = U[15] >> 16 & 1, U[14] &= 65535, _(se, U, 1 - G);
      }
      for (H = 0; H < 16; H++)
        k[2 * H] = se[H] & 255, k[2 * H + 1] = se[H] >> 8;
    }
    function v(k, j) {
      var H = new Uint8Array(32), C = new Uint8Array(32);
      return E(H, k), E(C, j), F(H, 0, C, 0);
    }
    function M(k) {
      var j = new Uint8Array(32);
      return E(j, k), j[0] & 1;
    }
    function P(k, j) {
      var H;
      for (H = 0; H < 16; H++) k[H] = j[2 * H] + (j[2 * H + 1] << 8);
      k[15] &= 32767;
    }
    function B(k, j, H) {
      for (var C = 0; C < 16; C++) k[C] = j[C] + H[C];
    }
    function ue(k, j, H) {
      for (var C = 0; C < 16; C++) k[C] = j[C] - H[C];
    }
    function D(k, j, H) {
      var C, G, U = 0, se = 0, he = 0, xe = 0, Te = 0, Re = 0, nt = 0, Ue = 0, pt = 0, it = 0, et = 0, St = 0, Tt = 0, At = 0, _t = 0, ht = 0, xt = 0, st = 0, bt = 0, ut = 0, ot = 0, Se = 0, Ae = 0, Ve = 0, Fe = 0, je = 0, Je = 0, Lt = 0, zt = 0, Xt = 0, Ht = 0, le = H[0], tr = H[1], hr = H[2], dr = H[3], Zt = H[4], pr = H[5], fr = H[6], Rr = H[7], gr = H[8], br = H[9], $r = H[10], Br = H[11], Ir = H[12], nn = H[13], sn = H[14], on = H[15];
      C = j[0], U += C * le, se += C * tr, he += C * hr, xe += C * dr, Te += C * Zt, Re += C * pr, nt += C * fr, Ue += C * Rr, pt += C * gr, it += C * br, et += C * $r, St += C * Br, Tt += C * Ir, At += C * nn, _t += C * sn, ht += C * on, C = j[1], se += C * le, he += C * tr, xe += C * hr, Te += C * dr, Re += C * Zt, nt += C * pr, Ue += C * fr, pt += C * Rr, it += C * gr, et += C * br, St += C * $r, Tt += C * Br, At += C * Ir, _t += C * nn, ht += C * sn, xt += C * on, C = j[2], he += C * le, xe += C * tr, Te += C * hr, Re += C * dr, nt += C * Zt, Ue += C * pr, pt += C * fr, it += C * Rr, et += C * gr, St += C * br, Tt += C * $r, At += C * Br, _t += C * Ir, ht += C * nn, xt += C * sn, st += C * on, C = j[3], xe += C * le, Te += C * tr, Re += C * hr, nt += C * dr, Ue += C * Zt, pt += C * pr, it += C * fr, et += C * Rr, St += C * gr, Tt += C * br, At += C * $r, _t += C * Br, ht += C * Ir, xt += C * nn, st += C * sn, bt += C * on, C = j[4], Te += C * le, Re += C * tr, nt += C * hr, Ue += C * dr, pt += C * Zt, it += C * pr, et += C * fr, St += C * Rr, Tt += C * gr, At += C * br, _t += C * $r, ht += C * Br, xt += C * Ir, st += C * nn, bt += C * sn, ut += C * on, C = j[5], Re += C * le, nt += C * tr, Ue += C * hr, pt += C * dr, it += C * Zt, et += C * pr, St += C * fr, Tt += C * Rr, At += C * gr, _t += C * br, ht += C * $r, xt += C * Br, st += C * Ir, bt += C * nn, ut += C * sn, ot += C * on, C = j[6], nt += C * le, Ue += C * tr, pt += C * hr, it += C * dr, et += C * Zt, St += C * pr, Tt += C * fr, At += C * Rr, _t += C * gr, ht += C * br, xt += C * $r, st += C * Br, bt += C * Ir, ut += C * nn, ot += C * sn, Se += C * on, C = j[7], Ue += C * le, pt += C * tr, it += C * hr, et += C * dr, St += C * Zt, Tt += C * pr, At += C * fr, _t += C * Rr, ht += C * gr, xt += C * br, st += C * $r, bt += C * Br, ut += C * Ir, ot += C * nn, Se += C * sn, Ae += C * on, C = j[8], pt += C * le, it += C * tr, et += C * hr, St += C * dr, Tt += C * Zt, At += C * pr, _t += C * fr, ht += C * Rr, xt += C * gr, st += C * br, bt += C * $r, ut += C * Br, ot += C * Ir, Se += C * nn, Ae += C * sn, Ve += C * on, C = j[9], it += C * le, et += C * tr, St += C * hr, Tt += C * dr, At += C * Zt, _t += C * pr, ht += C * fr, xt += C * Rr, st += C * gr, bt += C * br, ut += C * $r, ot += C * Br, Se += C * Ir, Ae += C * nn, Ve += C * sn, Fe += C * on, C = j[10], et += C * le, St += C * tr, Tt += C * hr, At += C * dr, _t += C * Zt, ht += C * pr, xt += C * fr, st += C * Rr, bt += C * gr, ut += C * br, ot += C * $r, Se += C * Br, Ae += C * Ir, Ve += C * nn, Fe += C * sn, je += C * on, C = j[11], St += C * le, Tt += C * tr, At += C * hr, _t += C * dr, ht += C * Zt, xt += C * pr, st += C * fr, bt += C * Rr, ut += C * gr, ot += C * br, Se += C * $r, Ae += C * Br, Ve += C * Ir, Fe += C * nn, je += C * sn, Je += C * on, C = j[12], Tt += C * le, At += C * tr, _t += C * hr, ht += C * dr, xt += C * Zt, st += C * pr, bt += C * fr, ut += C * Rr, ot += C * gr, Se += C * br, Ae += C * $r, Ve += C * Br, Fe += C * Ir, je += C * nn, Je += C * sn, Lt += C * on, C = j[13], At += C * le, _t += C * tr, ht += C * hr, xt += C * dr, st += C * Zt, bt += C * pr, ut += C * fr, ot += C * Rr, Se += C * gr, Ae += C * br, Ve += C * $r, Fe += C * Br, je += C * Ir, Je += C * nn, Lt += C * sn, zt += C * on, C = j[14], _t += C * le, ht += C * tr, xt += C * hr, st += C * dr, bt += C * Zt, ut += C * pr, ot += C * fr, Se += C * Rr, Ae += C * gr, Ve += C * br, Fe += C * $r, je += C * Br, Je += C * Ir, Lt += C * nn, zt += C * sn, Xt += C * on, C = j[15], ht += C * le, xt += C * tr, st += C * hr, bt += C * dr, ut += C * Zt, ot += C * pr, Se += C * fr, Ae += C * Rr, Ve += C * gr, Fe += C * br, je += C * $r, Je += C * Br, Lt += C * Ir, zt += C * nn, Xt += C * sn, Ht += C * on, U += 38 * xt, se += 38 * st, he += 38 * bt, xe += 38 * ut, Te += 38 * ot, Re += 38 * Se, nt += 38 * Ae, Ue += 38 * Ve, pt += 38 * Fe, it += 38 * je, et += 38 * Je, St += 38 * Lt, Tt += 38 * zt, At += 38 * Xt, _t += 38 * Ht, G = 1, C = U + G + 65535, G = Math.floor(C / 65536), U = C - G * 65536, C = se + G + 65535, G = Math.floor(C / 65536), se = C - G * 65536, C = he + G + 65535, G = Math.floor(C / 65536), he = C - G * 65536, C = xe + G + 65535, G = Math.floor(C / 65536), xe = C - G * 65536, C = Te + G + 65535, G = Math.floor(C / 65536), Te = C - G * 65536, C = Re + G + 65535, G = Math.floor(C / 65536), Re = C - G * 65536, C = nt + G + 65535, G = Math.floor(C / 65536), nt = C - G * 65536, C = Ue + G + 65535, G = Math.floor(C / 65536), Ue = C - G * 65536, C = pt + G + 65535, G = Math.floor(C / 65536), pt = C - G * 65536, C = it + G + 65535, G = Math.floor(C / 65536), it = C - G * 65536, C = et + G + 65535, G = Math.floor(C / 65536), et = C - G * 65536, C = St + G + 65535, G = Math.floor(C / 65536), St = C - G * 65536, C = Tt + G + 65535, G = Math.floor(C / 65536), Tt = C - G * 65536, C = At + G + 65535, G = Math.floor(C / 65536), At = C - G * 65536, C = _t + G + 65535, G = Math.floor(C / 65536), _t = C - G * 65536, C = ht + G + 65535, G = Math.floor(C / 65536), ht = C - G * 65536, U += G - 1 + 37 * (G - 1), G = 1, C = U + G + 65535, G = Math.floor(C / 65536), U = C - G * 65536, C = se + G + 65535, G = Math.floor(C / 65536), se = C - G * 65536, C = he + G + 65535, G = Math.floor(C / 65536), he = C - G * 65536, C = xe + G + 65535, G = Math.floor(C / 65536), xe = C - G * 65536, C = Te + G + 65535, G = Math.floor(C / 65536), Te = C - G * 65536, C = Re + G + 65535, G = Math.floor(C / 65536), Re = C - G * 65536, C = nt + G + 65535, G = Math.floor(C / 65536), nt = C - G * 65536, C = Ue + G + 65535, G = Math.floor(C / 65536), Ue = C - G * 65536, C = pt + G + 65535, G = Math.floor(C / 65536), pt = C - G * 65536, C = it + G + 65535, G = Math.floor(C / 65536), it = C - G * 65536, C = et + G + 65535, G = Math.floor(C / 65536), et = C - G * 65536, C = St + G + 65535, G = Math.floor(C / 65536), St = C - G * 65536, C = Tt + G + 65535, G = Math.floor(C / 65536), Tt = C - G * 65536, C = At + G + 65535, G = Math.floor(C / 65536), At = C - G * 65536, C = _t + G + 65535, G = Math.floor(C / 65536), _t = C - G * 65536, C = ht + G + 65535, G = Math.floor(C / 65536), ht = C - G * 65536, U += G - 1 + 37 * (G - 1), k[0] = U, k[1] = se, k[2] = he, k[3] = xe, k[4] = Te, k[5] = Re, k[6] = nt, k[7] = Ue, k[8] = pt, k[9] = it, k[10] = et, k[11] = St, k[12] = Tt, k[13] = At, k[14] = _t, k[15] = ht;
    }
    function oe(k, j) {
      D(k, j, j);
    }
    function Z(k, j) {
      var H = r(), C;
      for (C = 0; C < 16; C++) H[C] = j[C];
      for (C = 253; C >= 0; C--)
        oe(H, H), C !== 2 && C !== 4 && D(H, H, j);
      for (C = 0; C < 16; C++) k[C] = H[C];
    }
    function J(k, j) {
      var H = r(), C;
      for (C = 0; C < 16; C++) H[C] = j[C];
      for (C = 250; C >= 0; C--)
        oe(H, H), C !== 1 && D(H, H, j);
      for (C = 0; C < 16; C++) k[C] = H[C];
    }
    function Q(k, j, H) {
      var C = new Uint8Array(32), G = new Float64Array(80), U, se, he = r(), xe = r(), Te = r(), Re = r(), nt = r(), Ue = r();
      for (se = 0; se < 31; se++) C[se] = j[se];
      for (C[31] = j[31] & 127 | 64, C[0] &= 248, P(G, H), se = 0; se < 16; se++)
        xe[se] = G[se], Re[se] = he[se] = Te[se] = 0;
      for (he[0] = Re[0] = 1, se = 254; se >= 0; --se)
        U = C[se >>> 3] >>> (se & 7) & 1, _(he, xe, U), _(Te, Re, U), B(nt, he, Te), ue(he, he, Te), B(Te, xe, Re), ue(xe, xe, Re), oe(Re, nt), oe(Ue, he), D(he, Te, he), D(Te, xe, nt), B(nt, he, Te), ue(he, he, Te), oe(xe, he), ue(Te, Re, Ue), D(he, Te, u), B(he, he, Re), D(Te, Te, he), D(he, Re, Ue), D(Re, xe, G), oe(xe, nt), _(he, xe, U), _(Te, Re, U);
      for (se = 0; se < 16; se++)
        G[se + 16] = he[se], G[se + 32] = Te[se], G[se + 48] = xe[se], G[se + 64] = Re[se];
      var pt = G.subarray(32), it = G.subarray(16);
      return Z(pt, pt), D(it, it, pt), E(k, it), 0;
    }
    function T(k, j) {
      return Q(k, j, s);
    }
    function X(k, j) {
      return n(j, 32), T(k, j);
    }
    function re(k, j, H) {
      var C = new Uint8Array(32);
      return Q(C, H, j), V(k, i, C, te);
    }
    var de = f, ie = g;
    function ce(k, j, H, C, G, U) {
      var se = new Uint8Array(32);
      return re(se, G, U), de(k, j, H, C, se);
    }
    function me(k, j, H, C, G, U) {
      var se = new Uint8Array(32);
      return re(se, G, U), ie(k, j, H, C, se);
    }
    var Pe = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function De(k, j, H, C) {
      for (var G = new Int32Array(16), U = new Int32Array(16), se, he, xe, Te, Re, nt, Ue, pt, it, et, St, Tt, At, _t, ht, xt, st, bt, ut, ot, Se, Ae, Ve, Fe, je, Je, Lt = k[0], zt = k[1], Xt = k[2], Ht = k[3], le = k[4], tr = k[5], hr = k[6], dr = k[7], Zt = j[0], pr = j[1], fr = j[2], Rr = j[3], gr = j[4], br = j[5], $r = j[6], Br = j[7], Ir = 0; C >= 128; ) {
        for (ut = 0; ut < 16; ut++)
          ot = 8 * ut + Ir, G[ut] = H[ot + 0] << 24 | H[ot + 1] << 16 | H[ot + 2] << 8 | H[ot + 3], U[ut] = H[ot + 4] << 24 | H[ot + 5] << 16 | H[ot + 6] << 8 | H[ot + 7];
        for (ut = 0; ut < 80; ut++)
          if (se = Lt, he = zt, xe = Xt, Te = Ht, Re = le, nt = tr, Ue = hr, pt = dr, it = Zt, et = pr, St = fr, Tt = Rr, At = gr, _t = br, ht = $r, xt = Br, Se = dr, Ae = Br, Ve = Ae & 65535, Fe = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = (le >>> 14 | gr << 18) ^ (le >>> 18 | gr << 14) ^ (gr >>> 9 | le << 23), Ae = (gr >>> 14 | le << 18) ^ (gr >>> 18 | le << 14) ^ (le >>> 9 | gr << 23), Ve += Ae & 65535, Fe += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Se = le & tr ^ ~le & hr, Ae = gr & br ^ ~gr & $r, Ve += Ae & 65535, Fe += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Se = Pe[ut * 2], Ae = Pe[ut * 2 + 1], Ve += Ae & 65535, Fe += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Se = G[ut % 16], Ae = U[ut % 16], Ve += Ae & 65535, Fe += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, je += Fe >>> 16, Je += je >>> 16, st = je & 65535 | Je << 16, bt = Ve & 65535 | Fe << 16, Se = st, Ae = bt, Ve = Ae & 65535, Fe = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = (Lt >>> 28 | Zt << 4) ^ (Zt >>> 2 | Lt << 30) ^ (Zt >>> 7 | Lt << 25), Ae = (Zt >>> 28 | Lt << 4) ^ (Lt >>> 2 | Zt << 30) ^ (Lt >>> 7 | Zt << 25), Ve += Ae & 65535, Fe += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Se = Lt & zt ^ Lt & Xt ^ zt & Xt, Ae = Zt & pr ^ Zt & fr ^ pr & fr, Ve += Ae & 65535, Fe += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, je += Fe >>> 16, Je += je >>> 16, pt = je & 65535 | Je << 16, xt = Ve & 65535 | Fe << 16, Se = Te, Ae = Tt, Ve = Ae & 65535, Fe = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = st, Ae = bt, Ve += Ae & 65535, Fe += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, je += Fe >>> 16, Je += je >>> 16, Te = je & 65535 | Je << 16, Tt = Ve & 65535 | Fe << 16, zt = se, Xt = he, Ht = xe, le = Te, tr = Re, hr = nt, dr = Ue, Lt = pt, pr = it, fr = et, Rr = St, gr = Tt, br = At, $r = _t, Br = ht, Zt = xt, ut % 16 === 15)
            for (ot = 0; ot < 16; ot++)
              Se = G[ot], Ae = U[ot], Ve = Ae & 65535, Fe = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = G[(ot + 9) % 16], Ae = U[(ot + 9) % 16], Ve += Ae & 65535, Fe += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, st = G[(ot + 1) % 16], bt = U[(ot + 1) % 16], Se = (st >>> 1 | bt << 31) ^ (st >>> 8 | bt << 24) ^ st >>> 7, Ae = (bt >>> 1 | st << 31) ^ (bt >>> 8 | st << 24) ^ (bt >>> 7 | st << 25), Ve += Ae & 65535, Fe += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, st = G[(ot + 14) % 16], bt = U[(ot + 14) % 16], Se = (st >>> 19 | bt << 13) ^ (bt >>> 29 | st << 3) ^ st >>> 6, Ae = (bt >>> 19 | st << 13) ^ (st >>> 29 | bt << 3) ^ (bt >>> 6 | st << 26), Ve += Ae & 65535, Fe += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, je += Fe >>> 16, Je += je >>> 16, G[ot] = je & 65535 | Je << 16, U[ot] = Ve & 65535 | Fe << 16;
        Se = Lt, Ae = Zt, Ve = Ae & 65535, Fe = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = k[0], Ae = j[0], Ve += Ae & 65535, Fe += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, je += Fe >>> 16, Je += je >>> 16, k[0] = Lt = je & 65535 | Je << 16, j[0] = Zt = Ve & 65535 | Fe << 16, Se = zt, Ae = pr, Ve = Ae & 65535, Fe = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = k[1], Ae = j[1], Ve += Ae & 65535, Fe += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, je += Fe >>> 16, Je += je >>> 16, k[1] = zt = je & 65535 | Je << 16, j[1] = pr = Ve & 65535 | Fe << 16, Se = Xt, Ae = fr, Ve = Ae & 65535, Fe = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = k[2], Ae = j[2], Ve += Ae & 65535, Fe += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, je += Fe >>> 16, Je += je >>> 16, k[2] = Xt = je & 65535 | Je << 16, j[2] = fr = Ve & 65535 | Fe << 16, Se = Ht, Ae = Rr, Ve = Ae & 65535, Fe = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = k[3], Ae = j[3], Ve += Ae & 65535, Fe += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, je += Fe >>> 16, Je += je >>> 16, k[3] = Ht = je & 65535 | Je << 16, j[3] = Rr = Ve & 65535 | Fe << 16, Se = le, Ae = gr, Ve = Ae & 65535, Fe = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = k[4], Ae = j[4], Ve += Ae & 65535, Fe += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, je += Fe >>> 16, Je += je >>> 16, k[4] = le = je & 65535 | Je << 16, j[4] = gr = Ve & 65535 | Fe << 16, Se = tr, Ae = br, Ve = Ae & 65535, Fe = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = k[5], Ae = j[5], Ve += Ae & 65535, Fe += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, je += Fe >>> 16, Je += je >>> 16, k[5] = tr = je & 65535 | Je << 16, j[5] = br = Ve & 65535 | Fe << 16, Se = hr, Ae = $r, Ve = Ae & 65535, Fe = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = k[6], Ae = j[6], Ve += Ae & 65535, Fe += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, je += Fe >>> 16, Je += je >>> 16, k[6] = hr = je & 65535 | Je << 16, j[6] = $r = Ve & 65535 | Fe << 16, Se = dr, Ae = Br, Ve = Ae & 65535, Fe = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = k[7], Ae = j[7], Ve += Ae & 65535, Fe += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, je += Fe >>> 16, Je += je >>> 16, k[7] = dr = je & 65535 | Je << 16, j[7] = Br = Ve & 65535 | Fe << 16, Ir += 128, C -= 128;
      }
      return C;
    }
    function Ce(k, j, H) {
      var C = new Int32Array(8), G = new Int32Array(8), U = new Uint8Array(256), se, he = H;
      for (C[0] = 1779033703, C[1] = 3144134277, C[2] = 1013904242, C[3] = 2773480762, C[4] = 1359893119, C[5] = 2600822924, C[6] = 528734635, C[7] = 1541459225, G[0] = 4089235720, G[1] = 2227873595, G[2] = 4271175723, G[3] = 1595750129, G[4] = 2917565137, G[5] = 725511199, G[6] = 4215389547, G[7] = 327033209, De(C, G, j, H), H %= 128, se = 0; se < H; se++) U[se] = j[he - H + se];
      for (U[H] = 128, H = 256 - 128 * (H < 112 ? 1 : 0), U[H - 9] = 0, I(U, H - 8, he / 536870912 | 0, he << 3), De(C, G, U, H), se = 0; se < 8; se++) I(k, 8 * se, C[se], G[se]);
      return 0;
    }
    function $e(k, j) {
      var H = r(), C = r(), G = r(), U = r(), se = r(), he = r(), xe = r(), Te = r(), Re = r();
      ue(H, k[1], k[0]), ue(Re, j[1], j[0]), D(H, H, Re), B(C, k[0], k[1]), B(Re, j[0], j[1]), D(C, C, Re), D(G, k[3], j[3]), D(G, G, d), D(U, k[2], j[2]), B(U, U, U), ue(se, C, H), ue(he, U, G), B(xe, U, G), B(Te, C, H), D(k[0], se, he), D(k[1], Te, xe), D(k[2], xe, he), D(k[3], se, Te);
    }
    function Me(k, j, H) {
      var C;
      for (C = 0; C < 4; C++)
        _(k[C], j[C], H);
    }
    function Ne(k, j) {
      var H = r(), C = r(), G = r();
      Z(G, j[2]), D(H, j[0], G), D(C, j[1], G), E(k, C), k[31] ^= M(H) << 7;
    }
    function Ke(k, j, H) {
      var C, G;
      for (b(k[0], o), b(k[1], a), b(k[2], a), b(k[3], o), G = 255; G >= 0; --G)
        C = H[G / 8 | 0] >> (G & 7) & 1, Me(k, j, C), $e(j, k), $e(k, k), Me(k, j, C);
    }
    function Le(k, j) {
      var H = [r(), r(), r(), r()];
      b(H[0], p), b(H[1], x), b(H[2], a), D(H[3], p, x), Ke(k, H, j);
    }
    function qe(k, j, H) {
      var C = new Uint8Array(64), G = [r(), r(), r(), r()], U;
      for (H || n(j, 32), Ce(C, j, 32), C[0] &= 248, C[31] &= 127, C[31] |= 64, Le(G, C), Ne(k, G), U = 0; U < 32; U++) j[U + 32] = k[U];
      return 0;
    }
    var ze = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function Ee(k, j) {
      var H, C, G, U;
      for (C = 63; C >= 32; --C) {
        for (H = 0, G = C - 32, U = C - 12; G < U; ++G)
          j[G] += H - 16 * j[C] * ze[G - (C - 32)], H = Math.floor((j[G] + 128) / 256), j[G] -= H * 256;
        j[G] += H, j[C] = 0;
      }
      for (H = 0, G = 0; G < 32; G++)
        j[G] += H - (j[31] >> 4) * ze[G], H = j[G] >> 8, j[G] &= 255;
      for (G = 0; G < 32; G++) j[G] -= H * ze[G];
      for (C = 0; C < 32; C++)
        j[C + 1] += j[C] >> 8, k[C] = j[C] & 255;
    }
    function Ze(k) {
      var j = new Float64Array(64), H;
      for (H = 0; H < 64; H++) j[H] = k[H];
      for (H = 0; H < 64; H++) k[H] = 0;
      Ee(k, j);
    }
    function at(k, j, H, C) {
      var G = new Uint8Array(64), U = new Uint8Array(64), se = new Uint8Array(64), he, xe, Te = new Float64Array(64), Re = [r(), r(), r(), r()];
      Ce(G, C, 32), G[0] &= 248, G[31] &= 127, G[31] |= 64;
      var nt = H + 64;
      for (he = 0; he < H; he++) k[64 + he] = j[he];
      for (he = 0; he < 32; he++) k[32 + he] = G[32 + he];
      for (Ce(se, k.subarray(32), H + 32), Ze(se), Le(Re, se), Ne(k, Re), he = 32; he < 64; he++) k[he] = C[he];
      for (Ce(U, k, H + 64), Ze(U), he = 0; he < 64; he++) Te[he] = 0;
      for (he = 0; he < 32; he++) Te[he] = se[he];
      for (he = 0; he < 32; he++)
        for (xe = 0; xe < 32; xe++)
          Te[he + xe] += U[he] * G[xe];
      return Ee(k.subarray(32), Te), nt;
    }
    function ke(k, j) {
      var H = r(), C = r(), G = r(), U = r(), se = r(), he = r(), xe = r();
      return b(k[2], a), P(k[1], j), oe(G, k[1]), D(U, G, h), ue(G, G, k[2]), B(U, k[2], U), oe(se, U), oe(he, se), D(xe, he, se), D(H, xe, G), D(H, H, U), J(H, H), D(H, H, G), D(H, H, U), D(H, H, U), D(k[0], H, U), oe(C, k[0]), D(C, C, U), v(C, G) && D(k[0], k[0], A), oe(C, k[0]), D(C, C, U), v(C, G) ? -1 : (M(k[0]) === j[31] >> 7 && ue(k[0], o, k[0]), D(k[3], k[0], k[1]), 0);
    }
    function Qe(k, j, H, C) {
      var G, U = new Uint8Array(32), se = new Uint8Array(64), he = [r(), r(), r(), r()], xe = [r(), r(), r(), r()];
      if (H < 64 || ke(xe, C)) return -1;
      for (G = 0; G < H; G++) k[G] = j[G];
      for (G = 0; G < 32; G++) k[G + 32] = C[G];
      if (Ce(se, k, H), Ze(se), Ke(he, xe, se), Le(xe, j.subarray(32)), $e(he, xe), Ne(U, he), H -= 64, F(j, 0, U, 0)) {
        for (G = 0; G < H; G++) k[G] = 0;
        return -1;
      }
      for (G = 0; G < H; G++) k[G] = j[G + 64];
      return H;
    }
    var tt = 32, Ye = 24, dt = 32, lt = 16, ct = 32, qt = 32, Yt = 32, Et = 32, Qt = 32, Jt = Ye, Dt = dt, kt = lt, Ct = 64, gt = 32, Rt = 64, Nt = 32, vt = 64;
    e.lowlevel = {
      crypto_core_hsalsa20: V,
      crypto_stream_xor: _e,
      crypto_stream: pe,
      crypto_stream_salsa20_xor: R,
      crypto_stream_salsa20: K,
      crypto_onetimeauth: S,
      crypto_onetimeauth_verify: m,
      crypto_verify_16: L,
      crypto_verify_32: F,
      crypto_secretbox: f,
      crypto_secretbox_open: g,
      crypto_scalarmult: Q,
      crypto_scalarmult_base: T,
      crypto_box_beforenm: re,
      crypto_box_afternm: de,
      crypto_box: ce,
      crypto_box_open: me,
      crypto_box_keypair: X,
      crypto_hash: Ce,
      crypto_sign: at,
      crypto_sign_keypair: qe,
      crypto_sign_open: Qe,
      crypto_secretbox_KEYBYTES: tt,
      crypto_secretbox_NONCEBYTES: Ye,
      crypto_secretbox_ZEROBYTES: dt,
      crypto_secretbox_BOXZEROBYTES: lt,
      crypto_scalarmult_BYTES: ct,
      crypto_scalarmult_SCALARBYTES: qt,
      crypto_box_PUBLICKEYBYTES: Yt,
      crypto_box_SECRETKEYBYTES: Et,
      crypto_box_BEFORENMBYTES: Qt,
      crypto_box_NONCEBYTES: Jt,
      crypto_box_ZEROBYTES: Dt,
      crypto_box_BOXZEROBYTES: kt,
      crypto_sign_BYTES: Ct,
      crypto_sign_PUBLICKEYBYTES: gt,
      crypto_sign_SECRETKEYBYTES: Rt,
      crypto_sign_SEEDBYTES: Nt,
      crypto_hash_BYTES: vt,
      gf: r,
      D: h,
      L: ze,
      pack25519: E,
      unpack25519: P,
      M: D,
      A: B,
      S: oe,
      Z: ue,
      pow2523: J,
      add: $e,
      set25519: b,
      modL: Ee,
      scalarmult: Ke,
      scalarbase: Le
    };
    function $t(k, j) {
      if (k.length !== tt) throw new Error("bad key size");
      if (j.length !== Ye) throw new Error("bad nonce size");
    }
    function Ft(k, j) {
      if (k.length !== Yt) throw new Error("bad public key size");
      if (j.length !== Et) throw new Error("bad secret key size");
    }
    function rt() {
      for (var k = 0; k < arguments.length; k++)
        if (!(arguments[k] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function Bt(k) {
      for (var j = 0; j < k.length; j++) k[j] = 0;
    }
    e.randomBytes = function(k) {
      var j = new Uint8Array(k);
      return n(j, k), j;
    }, e.secretbox = function(k, j, H) {
      rt(k, j, H), $t(H, j);
      for (var C = new Uint8Array(dt + k.length), G = new Uint8Array(C.length), U = 0; U < k.length; U++) C[U + dt] = k[U];
      return f(G, C, C.length, j, H), G.subarray(lt);
    }, e.secretbox.open = function(k, j, H) {
      rt(k, j, H), $t(H, j);
      for (var C = new Uint8Array(lt + k.length), G = new Uint8Array(C.length), U = 0; U < k.length; U++) C[U + lt] = k[U];
      return C.length < 32 || g(G, C, C.length, j, H) !== 0 ? null : G.subarray(dt);
    }, e.secretbox.keyLength = tt, e.secretbox.nonceLength = Ye, e.secretbox.overheadLength = lt, e.scalarMult = function(k, j) {
      if (rt(k, j), k.length !== qt) throw new Error("bad n size");
      if (j.length !== ct) throw new Error("bad p size");
      var H = new Uint8Array(ct);
      return Q(H, k, j), H;
    }, e.scalarMult.base = function(k) {
      if (rt(k), k.length !== qt) throw new Error("bad n size");
      var j = new Uint8Array(ct);
      return T(j, k), j;
    }, e.scalarMult.scalarLength = qt, e.scalarMult.groupElementLength = ct, e.box = function(k, j, H, C) {
      var G = e.box.before(H, C);
      return e.secretbox(k, j, G);
    }, e.box.before = function(k, j) {
      rt(k, j), Ft(k, j);
      var H = new Uint8Array(Qt);
      return re(H, k, j), H;
    }, e.box.after = e.secretbox, e.box.open = function(k, j, H, C) {
      var G = e.box.before(H, C);
      return e.secretbox.open(k, j, G);
    }, e.box.open.after = e.secretbox.open, e.box.keyPair = function() {
      var k = new Uint8Array(Yt), j = new Uint8Array(Et);
      return X(k, j), { publicKey: k, secretKey: j };
    }, e.box.keyPair.fromSecretKey = function(k) {
      if (rt(k), k.length !== Et)
        throw new Error("bad secret key size");
      var j = new Uint8Array(Yt);
      return T(j, k), { publicKey: j, secretKey: new Uint8Array(k) };
    }, e.box.publicKeyLength = Yt, e.box.secretKeyLength = Et, e.box.sharedKeyLength = Qt, e.box.nonceLength = Jt, e.box.overheadLength = e.secretbox.overheadLength, e.sign = function(k, j) {
      if (rt(k, j), j.length !== Rt)
        throw new Error("bad secret key size");
      var H = new Uint8Array(Ct + k.length);
      return at(H, k, k.length, j), H;
    }, e.sign.open = function(k, j) {
      if (rt(k, j), j.length !== gt)
        throw new Error("bad public key size");
      var H = new Uint8Array(k.length), C = Qe(H, k, k.length, j);
      if (C < 0) return null;
      for (var G = new Uint8Array(C), U = 0; U < G.length; U++) G[U] = H[U];
      return G;
    }, e.sign.detached = function(k, j) {
      for (var H = e.sign(k, j), C = new Uint8Array(Ct), G = 0; G < C.length; G++) C[G] = H[G];
      return C;
    }, e.sign.detached.verify = function(k, j, H) {
      if (rt(k, j, H), j.length !== Ct)
        throw new Error("bad signature size");
      if (H.length !== gt)
        throw new Error("bad public key size");
      var C = new Uint8Array(Ct + k.length), G = new Uint8Array(Ct + k.length), U;
      for (U = 0; U < Ct; U++) C[U] = j[U];
      for (U = 0; U < k.length; U++) C[U + Ct] = k[U];
      return Qe(G, C, C.length, H) >= 0;
    }, e.sign.keyPair = function() {
      var k = new Uint8Array(gt), j = new Uint8Array(Rt);
      return qe(k, j), { publicKey: k, secretKey: j };
    }, e.sign.keyPair.fromSecretKey = function(k) {
      if (rt(k), k.length !== Rt)
        throw new Error("bad secret key size");
      for (var j = new Uint8Array(gt), H = 0; H < j.length; H++) j[H] = k[32 + H];
      return { publicKey: j, secretKey: new Uint8Array(k) };
    }, e.sign.keyPair.fromSeed = function(k) {
      if (rt(k), k.length !== Nt)
        throw new Error("bad seed size");
      for (var j = new Uint8Array(gt), H = new Uint8Array(Rt), C = 0; C < 32; C++) H[C] = k[C];
      return qe(j, H, !0), { publicKey: j, secretKey: H };
    }, e.sign.publicKeyLength = gt, e.sign.secretKeyLength = Rt, e.sign.seedLength = Nt, e.sign.signatureLength = Ct, e.hash = function(k) {
      rt(k);
      var j = new Uint8Array(vt);
      return Ce(j, k, k.length), j;
    }, e.hash.hashLength = vt, e.verify = function(k, j) {
      return rt(k, j), k.length === 0 || j.length === 0 || k.length !== j.length ? !1 : N(k, 0, j, 0, k.length) === 0;
    }, e.setPRNG = function(k) {
      n = k;
    }, function() {
      var k = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (k && k.getRandomValues) {
        var j = 65536;
        e.setPRNG(function(H, C) {
          var G, U = new Uint8Array(C);
          for (G = 0; G < C; G += j)
            k.getRandomValues(U.subarray(G, G + Math.min(C - G, j)));
          for (G = 0; G < C; G++) H[G] = U[G];
          Bt(U);
        });
      } else typeof S4 < "u" && (k = zl, k && k.randomBytes && e.setPRNG(function(H, C) {
        var G, U = k.randomBytes(C);
        for (G = 0; G < C; G++) H[G] = U[G];
        Bt(U);
      }));
    }();
  })(t.exports ? t.exports : self.nacl = self.nacl || {});
})(L9);
var iie = L9.exports;
const bd = /* @__PURE__ */ ts(iie);
var aa;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR", t[t.MANIFEST_NOT_FOUND_ERROR = 2] = "MANIFEST_NOT_FOUND_ERROR", t[t.MANIFEST_CONTENT_ERROR = 3] = "MANIFEST_CONTENT_ERROR", t[t.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR", t[t.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(aa || (aa = {}));
var u5;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(u5 || (u5 = {}));
var nu;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR", t[t.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR", t[t.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(nu || (nu = {}));
var f5;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR", t[t.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR", t[t.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(f5 || (f5 = {}));
var l5;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR", t[t.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(l5 || (l5 = {}));
var h5;
(function(t) {
  t.MAINNET = "-239", t.TESTNET = "-3";
})(h5 || (h5 = {}));
function sie(t, e) {
  const r = Rl.encodeBase64(t);
  return e ? encodeURIComponent(r) : r;
}
function oie(t, e) {
  return e && (t = decodeURIComponent(t)), Rl.decodeBase64(t);
}
function aie(t, e = !1) {
  let r;
  return t instanceof Uint8Array ? r = t : (typeof t != "string" && (t = JSON.stringify(t)), r = Rl.decodeUTF8(t)), sie(r, e);
}
function cie(t, e = !1) {
  const r = oie(t, e);
  return {
    toString() {
      return Rl.encodeUTF8(r);
    },
    toObject() {
      try {
        return JSON.parse(Rl.encodeUTF8(r));
      } catch {
        return null;
      }
    },
    toUint8Array() {
      return r;
    }
  };
}
const k9 = {
  encode: aie,
  decode: cie
};
function uie(t, e) {
  const r = new Uint8Array(t.length + e.length);
  return r.set(t), r.set(e, t.length), r;
}
function fie(t, e) {
  if (e >= t.length)
    throw new Error("Index is out of buffer");
  const r = t.slice(0, e), n = t.slice(e);
  return [r, n];
}
function Km(t) {
  let e = "";
  return t.forEach((r) => {
    e += ("0" + (r & 255).toString(16)).slice(-2);
  }), e;
}
function A0(t) {
  if (t.length % 2 !== 0)
    throw new Error(`Cannot convert ${t} to bytesArray`);
  const e = new Uint8Array(t.length / 2);
  for (let r = 0; r < t.length; r += 2)
    e[r / 2] = parseInt(t.slice(r, r + 2), 16);
  return e;
}
class hv {
  constructor(e) {
    this.nonceLength = 24, this.keyPair = e ? this.createKeypairFromString(e) : this.createKeypair(), this.sessionId = Km(this.keyPair.publicKey);
  }
  createKeypair() {
    return bd.box.keyPair();
  }
  createKeypairFromString(e) {
    return {
      publicKey: A0(e.publicKey),
      secretKey: A0(e.secretKey)
    };
  }
  createNonce() {
    return bd.randomBytes(this.nonceLength);
  }
  encrypt(e, r) {
    const n = new TextEncoder().encode(e), i = this.createNonce(), s = bd.box(n, i, r, this.keyPair.secretKey);
    return uie(i, s);
  }
  decrypt(e, r) {
    const [n, i] = fie(e, this.nonceLength), s = bd.box.open(i, n, r, this.keyPair.secretKey);
    if (!s)
      throw new Error(`Decryption error: 
 message: ${e.toString()} 
 sender pubkey: ${r.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`);
    return new TextDecoder().decode(s);
  }
  stringifyKeypair() {
    return {
      publicKey: Km(this.keyPair.publicKey),
      secretKey: Km(this.keyPair.secretKey)
    };
  }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function lie(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
  return r;
}
function Mt(t, e, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function a(d) {
      try {
        h(n.next(d));
      } catch (p) {
        o(p);
      }
    }
    function u(d) {
      try {
        h(n.throw(d));
      } catch (p) {
        o(p);
      }
    }
    function h(d) {
      d.done ? s(d.value) : i(d.value).then(a, u);
    }
    h((n = n.apply(t, [])).next());
  });
}
class Ut extends Error {
  constructor(e, r) {
    super(e, r), this.message = `${Ut.prefix} ${this.constructor.name}${this.info ? ": " + this.info : ""}${e ? `
` + e : ""}`, Object.setPrototypeOf(this, Ut.prototype);
  }
  get info() {
    return "";
  }
}
Ut.prefix = "[TON_CONNECT_SDK_ERROR]";
class ay extends Ut {
  get info() {
    return "Passed DappMetadata is in incorrect format.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, ay.prototype);
  }
}
class Sp extends Ut {
  get info() {
    return "Passed `tonconnect-manifest.json` contains errors. Check format of your manifest. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Sp.prototype);
  }
}
class Ap extends Ut {
  get info() {
    return "Manifest not found. Make sure you added `tonconnect-manifest.json` to the root of your app or passed correct manifestUrl. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Ap.prototype);
  }
}
class cy extends Ut {
  get info() {
    return "Wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, cy.prototype);
  }
}
class P0 extends Ut {
  get info() {
    return "Send transaction or other protocol methods called while wallet is not connected.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, P0.prototype);
  }
}
function hie(t) {
  return "jsBridgeKey" in t;
}
class Pp extends Ut {
  get info() {
    return "User rejects the action in the wallet.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Pp.prototype);
  }
}
class Mp extends Ut {
  get info() {
    return "Request to the wallet contains errors.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Mp.prototype);
  }
}
class Ip extends Ut {
  get info() {
    return "App tries to send rpc request to the injected wallet while not connected.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Ip.prototype);
  }
}
class uy extends Ut {
  get info() {
    return "There is an attempt to connect to the injected wallet while it is not exists in the webpage.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, uy.prototype);
  }
}
class fy extends Ut {
  get info() {
    return "An error occurred while fetching the wallets list.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, fy.prototype);
  }
}
class xa extends Ut {
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, xa.prototype);
  }
}
const d5 = {
  [aa.UNKNOWN_ERROR]: xa,
  [aa.USER_REJECTS_ERROR]: Pp,
  [aa.BAD_REQUEST_ERROR]: Mp,
  [aa.UNKNOWN_APP_ERROR]: Ip,
  [aa.MANIFEST_NOT_FOUND_ERROR]: Ap,
  [aa.MANIFEST_CONTENT_ERROR]: Sp
};
class die {
  parseError(e) {
    let r = xa;
    return e.code in d5 && (r = d5[e.code] || xa), new r(e.message);
  }
}
const pie = new die();
class gie {
  isError(e) {
    return "error" in e;
  }
}
const p5 = {
  [nu.UNKNOWN_ERROR]: xa,
  [nu.USER_REJECTS_ERROR]: Pp,
  [nu.BAD_REQUEST_ERROR]: Mp,
  [nu.UNKNOWN_APP_ERROR]: Ip
};
class mie extends gie {
  convertToRpcRequest(e) {
    return {
      method: "sendTransaction",
      params: [JSON.stringify(e)]
    };
  }
  parseAndThrowError(e) {
    let r = xa;
    throw e.error.code in p5 && (r = p5[e.error.code] || xa), new r(e.error.message);
  }
  convertFromRpcResponse(e) {
    return {
      boc: e.result
    };
  }
}
const yd = new mie();
class vie {
  constructor(e, r) {
    this.storage = e, this.storeKey = "ton-connect-storage_http-bridge-gateway::" + r;
  }
  storeLastEventId(e) {
    return Mt(this, void 0, void 0, function* () {
      return this.storage.setItem(this.storeKey, e);
    });
  }
  removeLastEventId() {
    return Mt(this, void 0, void 0, function* () {
      return this.storage.removeItem(this.storeKey);
    });
  }
  getLastEventId() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.storage.getItem(this.storeKey);
      return e || null;
    });
  }
}
function bie(t) {
  return t.slice(-1) === "/" ? t.slice(0, -1) : t;
}
function $9(t, e) {
  return bie(t) + "/" + e;
}
function yie(t) {
  if (!t)
    return !1;
  const e = new URL(t);
  return e.protocol === "tg:" || e.hostname === "t.me";
}
function wie(t) {
  return t.replaceAll(".", "%2E").replaceAll("-", "%2D").replaceAll("_", "%5F").replaceAll("&", "-").replaceAll("=", "__").replaceAll("%", "--");
}
function B9(t, e) {
  return Mt(this, void 0, void 0, function* () {
    return new Promise((r, n) => {
      var i, s;
      if (!((i = void 0) === null || i === void 0) && i.aborted) {
        n(new Ut("Delay aborted"));
        return;
      }
      const o = setTimeout(() => r(), t);
      (s = void 0) === null || s === void 0 || s.addEventListener("abort", () => {
        clearTimeout(o), n(new Ut("Delay aborted"));
      });
    });
  });
}
function xs(t) {
  const e = new AbortController();
  return t != null && t.aborted ? e.abort() : t == null || t.addEventListener("abort", () => e.abort(), { once: !0 }), e;
}
function Jf(t, e) {
  var r, n;
  return Mt(this, void 0, void 0, function* () {
    const i = (r = e == null ? void 0 : e.attempts) !== null && r !== void 0 ? r : 10, s = (n = e == null ? void 0 : e.delayMs) !== null && n !== void 0 ? n : 200, o = xs(e == null ? void 0 : e.signal);
    if (typeof t != "function")
      throw new Ut(`Expected a function, got ${typeof t}`);
    let a = 0, u;
    for (; a < i; ) {
      if (o.signal.aborted)
        throw new Ut(`Aborted after attempts ${a}`);
      try {
        return yield t({ signal: o.signal });
      } catch (h) {
        u = h, a++, a < i && (yield B9(s));
      }
    }
    throw u;
  });
}
function Sn(...t) {
  try {
    console.debug("[TON_CONNECT_SDK]", ...t);
  } catch {
  }
}
function Ro(...t) {
  try {
    console.error("[TON_CONNECT_SDK]", ...t);
  } catch {
  }
}
function xie(...t) {
  try {
    console.warn("[TON_CONNECT_SDK]", ...t);
  } catch {
  }
}
function _ie(t, e) {
  let r = null, n = null, i = null, s = null, o = null;
  const a = (p, ...x) => Mt(this, void 0, void 0, function* () {
    if (s = p ?? null, o == null || o.abort(), o = xs(p), o.signal.aborted)
      throw new Ut("Resource creation was aborted");
    n = x ?? null;
    const A = t(o.signal, ...x);
    i = A;
    const I = yield A;
    if (i !== A && I !== r)
      throw yield e(I), new Ut("Resource creation was aborted by a new resource creation");
    return r = I, r;
  });
  return {
    create: a,
    current: () => r ?? null,
    dispose: () => Mt(this, void 0, void 0, function* () {
      try {
        const p = r;
        r = null;
        const x = i;
        i = null;
        try {
          o == null || o.abort();
        } catch {
        }
        yield Promise.allSettled([
          p ? e(p) : Promise.resolve(),
          x ? e(yield x) : Promise.resolve()
        ]);
      } catch {
      }
    }),
    recreate: (p) => Mt(this, void 0, void 0, function* () {
      const x = r, A = i, I = n, N = s;
      if (yield B9(p), x === r && A === i && I === n && N === s)
        return yield a(s, ...I ?? []);
      throw new Ut("Resource recreation was aborted by a new resource creation");
    })
  };
}
function Eie(t, e) {
  const r = e == null ? void 0 : e.timeout, n = e == null ? void 0 : e.signal, i = xs(n);
  return new Promise((s, o) => Mt(this, void 0, void 0, function* () {
    if (i.signal.aborted) {
      o(new Ut("Operation aborted"));
      return;
    }
    let a;
    typeof r < "u" && (a = setTimeout(() => {
      i.abort(), o(new Ut(`Timeout after ${r}ms`));
    }, r)), i.signal.addEventListener("abort", () => {
      clearTimeout(a), o(new Ut("Operation aborted"));
    }, { once: !0 });
    const u = { timeout: r, abort: i.signal };
    yield t((...h) => {
      clearTimeout(a), s(...h);
    }, () => {
      clearTimeout(a), o();
    }, u);
  }));
}
class Vm {
  constructor(e, r, n, i, s) {
    this.bridgeUrl = r, this.sessionId = n, this.listener = i, this.errorsListener = s, this.ssePath = "events", this.postPath = "message", this.heartbeatMessage = "heartbeat", this.defaultTtl = 300, this.defaultReconnectDelay = 2e3, this.defaultResendDelay = 5e3, this.eventSource = _ie((o, a) => Mt(this, void 0, void 0, function* () {
      const u = {
        bridgeUrl: this.bridgeUrl,
        ssePath: this.ssePath,
        sessionId: this.sessionId,
        bridgeGatewayStorage: this.bridgeGatewayStorage,
        errorHandler: this.errorsHandler.bind(this),
        messageHandler: this.messagesHandler.bind(this),
        signal: o,
        openingDeadlineMS: a
      };
      return yield Sie(u);
    }), (o) => Mt(this, void 0, void 0, function* () {
      o.close();
    })), this.bridgeGatewayStorage = new vie(e, r);
  }
  get isReady() {
    const e = this.eventSource.current();
    return (e == null ? void 0 : e.readyState) === EventSource.OPEN;
  }
  get isClosed() {
    const e = this.eventSource.current();
    return (e == null ? void 0 : e.readyState) !== EventSource.OPEN;
  }
  get isConnecting() {
    const e = this.eventSource.current();
    return (e == null ? void 0 : e.readyState) === EventSource.CONNECTING;
  }
  registerSession(e) {
    return Mt(this, void 0, void 0, function* () {
      yield this.eventSource.create(e == null ? void 0 : e.signal, e == null ? void 0 : e.openingDeadlineMS);
    });
  }
  send(e, r, n, i) {
    var s;
    return Mt(this, void 0, void 0, function* () {
      const o = {};
      typeof i == "number" ? o.ttl = i : (o.ttl = i == null ? void 0 : i.ttl, o.signal = i == null ? void 0 : i.signal, o.attempts = i == null ? void 0 : i.attempts);
      const a = new URL($9(this.bridgeUrl, this.postPath));
      a.searchParams.append("client_id", this.sessionId), a.searchParams.append("to", r), a.searchParams.append("ttl", ((o == null ? void 0 : o.ttl) || this.defaultTtl).toString()), a.searchParams.append("topic", n);
      const u = k9.encode(e);
      yield Jf((h) => Mt(this, void 0, void 0, function* () {
        const d = yield this.post(a, u, h.signal);
        if (!d.ok)
          throw new Ut(`Bridge send failed, status ${d.status}`);
      }), {
        attempts: (s = o == null ? void 0 : o.attempts) !== null && s !== void 0 ? s : Number.MAX_SAFE_INTEGER,
        delayMs: this.defaultResendDelay,
        signal: o == null ? void 0 : o.signal
      });
    });
  }
  pause() {
    this.eventSource.dispose().catch((e) => Ro(`Bridge pause failed, ${e}`));
  }
  unPause() {
    return Mt(this, void 0, void 0, function* () {
      yield this.eventSource.recreate(0);
    });
  }
  close() {
    return Mt(this, void 0, void 0, function* () {
      yield this.eventSource.dispose().catch((e) => Ro(`Bridge close failed, ${e}`));
    });
  }
  setListener(e) {
    this.listener = e;
  }
  setErrorsListener(e) {
    this.errorsListener = e;
  }
  post(e, r, n) {
    return Mt(this, void 0, void 0, function* () {
      const i = yield fetch(e, {
        method: "post",
        body: r,
        signal: n
      });
      if (!i.ok)
        throw new Ut(`Bridge send failed, status ${i.status}`);
      return i;
    });
  }
  errorsHandler(e, r) {
    return Mt(this, void 0, void 0, function* () {
      if (this.isConnecting)
        throw e.close(), new Ut("Bridge error, failed to connect");
      if (this.isReady) {
        try {
          this.errorsListener(r);
        } catch {
        }
        return;
      }
      if (this.isClosed)
        return e.close(), Sn(`Bridge reconnecting, ${this.defaultReconnectDelay}ms delay`), yield this.eventSource.recreate(this.defaultReconnectDelay);
      throw new Ut("Bridge error, unknown state");
    });
  }
  messagesHandler(e) {
    return Mt(this, void 0, void 0, function* () {
      if (e.data === this.heartbeatMessage || (yield this.bridgeGatewayStorage.storeLastEventId(e.lastEventId), this.isClosed))
        return;
      let r;
      try {
        r = JSON.parse(e.data);
      } catch (n) {
        throw new Ut(`Bridge message parse failed, message ${n.data}`);
      }
      this.listener(r);
    });
  }
}
function Sie(t) {
  return Mt(this, void 0, void 0, function* () {
    return yield Eie((e, r, n) => Mt(this, void 0, void 0, function* () {
      var i;
      const o = xs(n.signal).signal;
      if (o.aborted) {
        r(new Ut("Bridge connection aborted"));
        return;
      }
      const a = new URL($9(t.bridgeUrl, t.ssePath));
      a.searchParams.append("client_id", t.sessionId);
      const u = yield t.bridgeGatewayStorage.getLastEventId();
      if (u && a.searchParams.append("last_event_id", u), o.aborted) {
        r(new Ut("Bridge connection aborted"));
        return;
      }
      const h = new EventSource(a.toString());
      h.onerror = (d) => Mt(this, void 0, void 0, function* () {
        if (o.aborted) {
          h.close(), r(new Ut("Bridge connection aborted"));
          return;
        }
        try {
          const p = yield t.errorHandler(h, d);
          p !== h && h.close(), p && p !== h && e(p);
        } catch (p) {
          h.close(), r(p);
        }
      }), h.onopen = () => {
        if (o.aborted) {
          h.close(), r(new Ut("Bridge connection aborted"));
          return;
        }
        e(h);
      }, h.onmessage = (d) => {
        if (o.aborted) {
          h.close(), r(new Ut("Bridge connection aborted"));
          return;
        }
        t.messageHandler(d);
      }, (i = t.signal) === null || i === void 0 || i.addEventListener("abort", () => {
        h.close(), r(new Ut("Bridge connection aborted"));
      });
    }), { timeout: t.openingDeadlineMS, signal: t.signal });
  });
}
function Xf(t) {
  return !("connectEvent" in t);
}
class Dl {
  constructor(e) {
    this.storage = e, this.storeKey = "ton-connect-storage_bridge-connection";
  }
  storeConnection(e) {
    return Mt(this, void 0, void 0, function* () {
      if (e.type === "injected")
        return this.storage.setItem(this.storeKey, JSON.stringify(e));
      if (!Xf(e)) {
        const n = {
          sessionKeyPair: e.session.sessionCrypto.stringifyKeypair(),
          walletPublicKey: e.session.walletPublicKey,
          bridgeUrl: e.session.bridgeUrl
        }, i = {
          type: "http",
          connectEvent: e.connectEvent,
          session: n,
          lastWalletEventId: e.lastWalletEventId,
          nextRpcRequestId: e.nextRpcRequestId
        };
        return this.storage.setItem(this.storeKey, JSON.stringify(i));
      }
      const r = {
        type: "http",
        connectionSource: e.connectionSource,
        sessionCrypto: e.sessionCrypto.stringifyKeypair()
      };
      return this.storage.setItem(this.storeKey, JSON.stringify(r));
    });
  }
  removeConnection() {
    return Mt(this, void 0, void 0, function* () {
      return this.storage.removeItem(this.storeKey);
    });
  }
  getConnection() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.storage.getItem(this.storeKey);
      if (!e)
        return null;
      const r = JSON.parse(e);
      if (r.type === "injected")
        return r;
      if ("connectEvent" in r) {
        const n = new hv(r.session.sessionKeyPair);
        return {
          type: "http",
          connectEvent: r.connectEvent,
          lastWalletEventId: r.lastWalletEventId,
          nextRpcRequestId: r.nextRpcRequestId,
          session: {
            sessionCrypto: n,
            bridgeUrl: r.session.bridgeUrl,
            walletPublicKey: r.session.walletPublicKey
          }
        };
      }
      return {
        type: "http",
        sessionCrypto: new hv(r.sessionCrypto),
        connectionSource: r.connectionSource
      };
    });
  }
  getHttpConnection() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (!e)
        throw new Ut("Trying to read HTTP connection source while nothing is stored");
      if (e.type === "injected")
        throw new Ut("Trying to read HTTP connection source while injected connection is stored");
      return e;
    });
  }
  getHttpPendingConnection() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (!e)
        throw new Ut("Trying to read HTTP connection source while nothing is stored");
      if (e.type === "injected")
        throw new Ut("Trying to read HTTP connection source while injected connection is stored");
      if (!Xf(e))
        throw new Ut("Trying to read HTTP-pending connection while http connection is stored");
      return e;
    });
  }
  getInjectedConnection() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (!e)
        throw new Ut("Trying to read Injected bridge connection source while nothing is stored");
      if ((e == null ? void 0 : e.type) === "http")
        throw new Ut("Trying to read Injected bridge connection source while HTTP connection is stored");
      return e;
    });
  }
  storedConnectionType() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.storage.getItem(this.storeKey);
      return e ? JSON.parse(e).type : null;
    });
  }
  storeLastWalletEventId(e) {
    return Mt(this, void 0, void 0, function* () {
      const r = yield this.getConnection();
      if (r && r.type === "http" && !Xf(r))
        return r.lastWalletEventId = e, this.storeConnection(r);
    });
  }
  getLastWalletEventId() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (e && "lastWalletEventId" in e)
        return e.lastWalletEventId;
    });
  }
  increaseNextRpcRequestId() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (e && "nextRpcRequestId" in e) {
        const r = e.nextRpcRequestId || 0;
        return e.nextRpcRequestId = r + 1, this.storeConnection(e);
      }
    });
  }
  getNextRpcRequestId() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      return e && "nextRpcRequestId" in e && e.nextRpcRequestId || 0;
    });
  }
}
const F9 = 2;
class Ol {
  constructor(e, r) {
    this.storage = e, this.walletConnectionSource = r, this.type = "http", this.standardUniversalLink = "tc://", this.pendingRequests = /* @__PURE__ */ new Map(), this.session = null, this.gateway = null, this.pendingGateways = [], this.listeners = [], this.defaultOpeningDeadlineMS = 12e3, this.defaultRetryTimeoutMS = 2e3, this.connectionStorage = new Dl(e);
  }
  static fromStorage(e) {
    return Mt(this, void 0, void 0, function* () {
      const n = yield new Dl(e).getHttpConnection();
      return Xf(n) ? new Ol(e, n.connectionSource) : new Ol(e, { bridgeUrl: n.session.bridgeUrl });
    });
  }
  connect(e, r) {
    var n;
    const i = xs(r == null ? void 0 : r.signal);
    (n = this.abortController) === null || n === void 0 || n.abort(), this.abortController = i, this.closeGateways();
    const s = new hv();
    this.session = {
      sessionCrypto: s,
      bridgeUrl: "bridgeUrl" in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
    }, this.connectionStorage.storeConnection({
      type: "http",
      connectionSource: this.walletConnectionSource,
      sessionCrypto: s
    }).then(() => Mt(this, void 0, void 0, function* () {
      i.signal.aborted || (yield Jf((a) => {
        var u;
        return this.openGateways(s, {
          openingDeadlineMS: (u = r == null ? void 0 : r.openingDeadlineMS) !== null && u !== void 0 ? u : this.defaultOpeningDeadlineMS,
          signal: a == null ? void 0 : a.signal
        });
      }, {
        attempts: Number.MAX_SAFE_INTEGER,
        delayMs: this.defaultRetryTimeoutMS,
        signal: i.signal
      }));
    }));
    const o = "universalLink" in this.walletConnectionSource && this.walletConnectionSource.universalLink ? this.walletConnectionSource.universalLink : this.standardUniversalLink;
    return this.generateUniversalLink(o, e);
  }
  restoreConnection(e) {
    var r, n;
    return Mt(this, void 0, void 0, function* () {
      const i = xs(e == null ? void 0 : e.signal);
      if ((r = this.abortController) === null || r === void 0 || r.abort(), this.abortController = i, i.signal.aborted)
        return;
      this.closeGateways();
      const s = yield this.connectionStorage.getHttpConnection();
      if (!s || i.signal.aborted)
        return;
      const o = (n = e == null ? void 0 : e.openingDeadlineMS) !== null && n !== void 0 ? n : this.defaultOpeningDeadlineMS;
      if (Xf(s))
        return this.session = {
          sessionCrypto: s.sessionCrypto,
          bridgeUrl: "bridgeUrl" in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
        }, yield this.openGateways(s.sessionCrypto, {
          openingDeadlineMS: o,
          signal: i == null ? void 0 : i.signal
        });
      if (Array.isArray(this.walletConnectionSource))
        throw new Ut("Internal error. Connection source is array while WalletConnectionSourceHTTP was expected.");
      if (this.session = s.session, this.gateway && (Sn("Gateway is already opened, closing previous gateway"), yield this.gateway.close()), this.gateway = new Vm(this.storage, this.walletConnectionSource.bridgeUrl, s.session.sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this)), !i.signal.aborted) {
        this.listeners.forEach((a) => a(s.connectEvent));
        try {
          yield Jf((a) => this.gateway.registerSession({
            openingDeadlineMS: o,
            signal: a.signal
          }), {
            attempts: Number.MAX_SAFE_INTEGER,
            delayMs: this.defaultRetryTimeoutMS,
            signal: i.signal
          });
        } catch {
          yield this.disconnect({ signal: i.signal });
          return;
        }
      }
    });
  }
  sendRequest(e, r) {
    const n = {};
    return typeof r == "function" ? n.onRequestSent = r : (n.onRequestSent = r == null ? void 0 : r.onRequestSent, n.signal = r == null ? void 0 : r.signal, n.attempts = r == null ? void 0 : r.attempts), new Promise((i, s) => Mt(this, void 0, void 0, function* () {
      var o;
      if (!this.gateway || !this.session || !("walletPublicKey" in this.session))
        throw new Ut("Trying to send bridge request without session");
      const a = (yield this.connectionStorage.getNextRpcRequestId()).toString();
      yield this.connectionStorage.increaseNextRpcRequestId(), Sn("Send http-bridge request:", Object.assign(Object.assign({}, e), { id: a }));
      const u = this.session.sessionCrypto.encrypt(JSON.stringify(Object.assign(Object.assign({}, e), { id: a })), A0(this.session.walletPublicKey));
      try {
        yield this.gateway.send(u, this.session.walletPublicKey, e.method, { attempts: n == null ? void 0 : n.attempts, signal: n == null ? void 0 : n.signal }), (o = n == null ? void 0 : n.onRequestSent) === null || o === void 0 || o.call(n), this.pendingRequests.set(a.toString(), i);
      } catch (h) {
        s(h);
      }
    }));
  }
  closeConnection() {
    this.closeGateways(), this.listeners = [], this.session = null, this.gateway = null;
  }
  disconnect(e) {
    return Mt(this, void 0, void 0, function* () {
      return new Promise((r) => Mt(this, void 0, void 0, function* () {
        let n = !1, i = null;
        const s = () => {
          n || (n = !0, this.removeBridgeAndSession().then(r));
        };
        try {
          this.closeGateways();
          const o = xs(e == null ? void 0 : e.signal);
          i = setTimeout(() => {
            o.abort();
          }, this.defaultOpeningDeadlineMS), yield this.sendRequest({ method: "disconnect", params: [] }, {
            onRequestSent: s,
            signal: o.signal,
            attempts: 1
          });
        } catch (o) {
          Sn("Disconnect error:", o), n || this.removeBridgeAndSession().then(r);
        } finally {
          i && clearTimeout(i), s();
        }
      }));
    });
  }
  listen(e) {
    return this.listeners.push(e), () => this.listeners = this.listeners.filter((r) => r !== e);
  }
  pause() {
    var e;
    (e = this.gateway) === null || e === void 0 || e.pause(), this.pendingGateways.forEach((r) => r.pause());
  }
  unPause() {
    return Mt(this, void 0, void 0, function* () {
      const e = this.pendingGateways.map((r) => r.unPause());
      this.gateway && e.push(this.gateway.unPause()), yield Promise.all(e);
    });
  }
  pendingGatewaysListener(e, r, n) {
    return Mt(this, void 0, void 0, function* () {
      if (!this.pendingGateways.includes(e)) {
        yield e.close();
        return;
      }
      return this.closeGateways({ except: e }), this.gateway && (Sn("Gateway is already opened, closing previous gateway"), yield this.gateway.close()), this.session.bridgeUrl = r, this.gateway = e, this.gateway.setErrorsListener(this.gatewayErrorsListener.bind(this)), this.gateway.setListener(this.gatewayListener.bind(this)), this.gatewayListener(n);
    });
  }
  gatewayListener(e) {
    return Mt(this, void 0, void 0, function* () {
      const r = JSON.parse(this.session.sessionCrypto.decrypt(k9.decode(e.message).toUint8Array(), A0(e.from)));
      if (Sn("Wallet message received:", r), !("event" in r)) {
        const i = r.id.toString(), s = this.pendingRequests.get(i);
        if (!s) {
          Sn(`Response id ${i} doesn't match any request's id`);
          return;
        }
        s(r), this.pendingRequests.delete(i);
        return;
      }
      if (r.id !== void 0) {
        const i = yield this.connectionStorage.getLastWalletEventId();
        if (i !== void 0 && r.id <= i) {
          Ro(`Received event id (=${r.id}) must be greater than stored last wallet event id (=${i}) `);
          return;
        }
        r.event !== "connect" && (yield this.connectionStorage.storeLastWalletEventId(r.id));
      }
      const n = this.listeners;
      r.event === "connect" && (yield this.updateSession(r, e.from)), r.event === "disconnect" && (Sn("Removing bridge and session: received disconnect event"), yield this.removeBridgeAndSession()), n.forEach((i) => i(r));
    });
  }
  gatewayErrorsListener(e) {
    return Mt(this, void 0, void 0, function* () {
      throw new Ut(`Bridge error ${JSON.stringify(e)}`);
    });
  }
  updateSession(e, r) {
    return Mt(this, void 0, void 0, function* () {
      this.session = Object.assign(Object.assign({}, this.session), { walletPublicKey: r });
      const n = e.payload.items.find((s) => s.name === "ton_addr"), i = Object.assign(Object.assign({}, e), { payload: Object.assign(Object.assign({}, e.payload), { items: [n] }) });
      yield this.connectionStorage.storeConnection({
        type: "http",
        session: this.session,
        lastWalletEventId: e.id,
        connectEvent: i,
        nextRpcRequestId: 0
      });
    });
  }
  removeBridgeAndSession() {
    return Mt(this, void 0, void 0, function* () {
      this.closeConnection(), yield this.connectionStorage.removeConnection();
    });
  }
  generateUniversalLink(e, r) {
    return yie(e) ? this.generateTGUniversalLink(e, r) : this.generateRegularUniversalLink(e, r);
  }
  generateRegularUniversalLink(e, r) {
    const n = new URL(e);
    return n.searchParams.append("v", F9.toString()), n.searchParams.append("id", this.session.sessionCrypto.sessionId), n.searchParams.append("r", JSON.stringify(r)), n.toString();
  }
  generateTGUniversalLink(e, r) {
    const i = this.generateRegularUniversalLink("about:blank", r).split("?")[1], s = "tonconnect-" + wie(i), o = this.convertToDirectLink(e), a = new URL(o);
    return a.searchParams.append("startapp", s), a.toString();
  }
  // TODO: Remove this method after all dApps and the wallets-list.json have been updated
  convertToDirectLink(e) {
    const r = new URL(e);
    return r.searchParams.has("attach") && (r.searchParams.delete("attach"), r.pathname += "/start"), r.toString();
  }
  openGateways(e, r) {
    return Mt(this, void 0, void 0, function* () {
      if (Array.isArray(this.walletConnectionSource)) {
        this.pendingGateways.map((n) => n.close().catch()), this.pendingGateways = this.walletConnectionSource.map((n) => {
          const i = new Vm(this.storage, n.bridgeUrl, e.sessionId, () => {
          }, () => {
          });
          return i.setListener((s) => this.pendingGatewaysListener(i, n.bridgeUrl, s)), i;
        }), yield Promise.allSettled(this.pendingGateways.map((n) => Jf((i) => {
          var s;
          return this.pendingGateways.some((o) => o === n) ? n.registerSession({
            openingDeadlineMS: (s = r == null ? void 0 : r.openingDeadlineMS) !== null && s !== void 0 ? s : this.defaultOpeningDeadlineMS,
            signal: i.signal
          }) : n.close();
        }, {
          attempts: Number.MAX_SAFE_INTEGER,
          delayMs: this.defaultRetryTimeoutMS,
          signal: r == null ? void 0 : r.signal
        })));
        return;
      } else
        return this.gateway && (Sn("Gateway is already opened, closing previous gateway"), yield this.gateway.close()), this.gateway = new Vm(this.storage, this.walletConnectionSource.bridgeUrl, e.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this)), yield this.gateway.registerSession({
          openingDeadlineMS: r == null ? void 0 : r.openingDeadlineMS,
          signal: r == null ? void 0 : r.signal
        });
    });
  }
  closeGateways(e) {
    var r;
    (r = this.gateway) === null || r === void 0 || r.close(), this.pendingGateways.filter((n) => n !== (e == null ? void 0 : e.except)).forEach((n) => n.close()), this.pendingGateways = [];
  }
}
function g5(t, e) {
  return U9(t, [e]);
}
function U9(t, e) {
  return !t || typeof t != "object" ? !1 : e.every((r) => r in t);
}
function Aie(t) {
  try {
    return !g5(t, "tonconnect") || !g5(t.tonconnect, "walletInfo") ? !1 : U9(t.tonconnect.walletInfo, [
      "name",
      "app_name",
      "image",
      "about_url",
      "platforms"
    ]);
  } catch {
    return !1;
  }
}
class iu {
  constructor() {
    this.storage = {};
  }
  static getInstance() {
    return iu.instance || (iu.instance = new iu()), iu.instance;
  }
  get length() {
    return Object.keys(this.storage).length;
  }
  clear() {
    this.storage = {};
  }
  getItem(e) {
    var r;
    return (r = this.storage[e]) !== null && r !== void 0 ? r : null;
  }
  key(e) {
    var r;
    const n = Object.keys(this.storage);
    return e < 0 || e >= n.length ? null : (r = n[e]) !== null && r !== void 0 ? r : null;
  }
  removeItem(e) {
    delete this.storage[e];
  }
  setItem(e, r) {
    this.storage[e] = r;
  }
}
function Cp() {
  if (!(typeof window > "u"))
    return window;
}
function Pie() {
  const t = Cp();
  if (!t)
    return [];
  try {
    return Object.keys(t);
  } catch {
    return [];
  }
}
function Mie() {
  if (!(typeof document > "u"))
    return document;
}
function Iie() {
  var t;
  const e = (t = Cp()) === null || t === void 0 ? void 0 : t.location.origin;
  return e ? e + "/tonconnect-manifest.json" : "";
}
function Cie() {
  if (Tie())
    return localStorage;
  if (Rie())
    throw new Ut("`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector");
  return iu.getInstance();
}
function Tie() {
  try {
    return typeof localStorage < "u";
  } catch {
    return !1;
  }
}
function Rie() {
  return typeof process < "u" && process.versions != null && process.versions.node != null;
}
class mi {
  constructor(e, r) {
    this.injectedWalletKey = r, this.type = "injected", this.unsubscribeCallback = null, this.listenSubscriptions = !1, this.listeners = [];
    const n = mi.window;
    if (!mi.isWindowContainsWallet(n, r))
      throw new uy();
    this.connectionStorage = new Dl(e), this.injectedWallet = n[r].tonconnect;
  }
  static fromStorage(e) {
    return Mt(this, void 0, void 0, function* () {
      const n = yield new Dl(e).getInjectedConnection();
      return new mi(e, n.jsBridgeKey);
    });
  }
  static isWalletInjected(e) {
    return mi.isWindowContainsWallet(this.window, e);
  }
  static isInsideWalletBrowser(e) {
    return mi.isWindowContainsWallet(this.window, e) ? this.window[e].tonconnect.isWalletBrowser : !1;
  }
  static getCurrentlyInjectedWallets() {
    return this.window ? Pie().filter(([n, i]) => Aie(i)).map(([n, i]) => ({
      name: i.tonconnect.walletInfo.name,
      appName: i.tonconnect.walletInfo.app_name,
      aboutUrl: i.tonconnect.walletInfo.about_url,
      imageUrl: i.tonconnect.walletInfo.image,
      tondns: i.tonconnect.walletInfo.tondns,
      jsBridgeKey: n,
      injected: !0,
      embedded: i.tonconnect.isWalletBrowser,
      platforms: i.tonconnect.walletInfo.platforms
    })) : [];
  }
  static isWindowContainsWallet(e, r) {
    return !!e && r in e && typeof e[r] == "object" && "tonconnect" in e[r];
  }
  connect(e) {
    this._connect(F9, e);
  }
  restoreConnection() {
    return Mt(this, void 0, void 0, function* () {
      try {
        Sn("Injected Provider restoring connection...");
        const e = yield this.injectedWallet.restoreConnection();
        Sn("Injected Provider restoring connection response", e), e.event === "connect" ? (this.makeSubscriptions(), this.listeners.forEach((r) => r(e))) : yield this.connectionStorage.removeConnection();
      } catch (e) {
        yield this.connectionStorage.removeConnection(), console.error(e);
      }
    });
  }
  closeConnection() {
    this.listenSubscriptions && this.injectedWallet.disconnect(), this.closeAllListeners();
  }
  disconnect() {
    return Mt(this, void 0, void 0, function* () {
      return new Promise((e) => {
        const r = () => {
          this.closeAllListeners(), this.connectionStorage.removeConnection().then(e);
        };
        try {
          this.injectedWallet.disconnect(), r();
        } catch (n) {
          Sn(n), this.sendRequest({
            method: "disconnect",
            params: []
          }, r);
        }
      });
    });
  }
  closeAllListeners() {
    var e;
    this.listenSubscriptions = !1, this.listeners = [], (e = this.unsubscribeCallback) === null || e === void 0 || e.call(this);
  }
  listen(e) {
    return this.listeners.push(e), () => this.listeners = this.listeners.filter((r) => r !== e);
  }
  sendRequest(e, r) {
    var n;
    return Mt(this, void 0, void 0, function* () {
      const i = {};
      typeof r == "function" ? i.onRequestSent = r : (i.onRequestSent = r == null ? void 0 : r.onRequestSent, i.signal = r == null ? void 0 : r.signal);
      const s = (yield this.connectionStorage.getNextRpcRequestId()).toString();
      yield this.connectionStorage.increaseNextRpcRequestId(), Sn("Send injected-bridge request:", Object.assign(Object.assign({}, e), { id: s }));
      const o = this.injectedWallet.send(Object.assign(Object.assign({}, e), { id: s }));
      return o.then((a) => Sn("Wallet message received:", a)), (n = i == null ? void 0 : i.onRequestSent) === null || n === void 0 || n.call(i), o;
    });
  }
  _connect(e, r) {
    return Mt(this, void 0, void 0, function* () {
      try {
        Sn(`Injected Provider connect request: protocolVersion: ${e}, message:`, r);
        const n = yield this.injectedWallet.connect(e, r);
        Sn("Injected Provider connect response:", n), n.event === "connect" && (yield this.updateSession(), this.makeSubscriptions()), this.listeners.forEach((i) => i(n));
      } catch (n) {
        Sn("Injected Provider connect error:", n);
        const i = {
          event: "connect_error",
          payload: {
            code: 0,
            message: n == null ? void 0 : n.toString()
          }
        };
        this.listeners.forEach((s) => s(i));
      }
    });
  }
  makeSubscriptions() {
    this.listenSubscriptions = !0, this.unsubscribeCallback = this.injectedWallet.listen((e) => {
      Sn("Wallet message received:", e), this.listenSubscriptions && this.listeners.forEach((r) => r(e)), e.event === "disconnect" && this.disconnect();
    });
  }
  updateSession() {
    return this.connectionStorage.storeConnection({
      type: "injected",
      jsBridgeKey: this.injectedWalletKey,
      nextRpcRequestId: 0
    });
  }
}
mi.window = Cp();
class Die {
  constructor() {
    this.localStorage = Cie();
  }
  getItem(e) {
    return Mt(this, void 0, void 0, function* () {
      return this.localStorage.getItem(e);
    });
  }
  removeItem(e) {
    return Mt(this, void 0, void 0, function* () {
      this.localStorage.removeItem(e);
    });
  }
  setItem(e, r) {
    return Mt(this, void 0, void 0, function* () {
      this.localStorage.setItem(e, r);
    });
  }
}
function j9(t) {
  return Nie(t) && t.injected;
}
function Oie(t) {
  return j9(t) && t.embedded;
}
function Nie(t) {
  return "jsBridgeKey" in t;
}
const Lie = [
  {
    app_name: "telegram-wallet",
    name: "Wallet",
    image: "https://wallet.tg/images/logo-288.png",
    about_url: "https://wallet.tg/",
    universal_url: "https://t.me/wallet?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://bridge.ton.space/bridge"
      }
    ],
    platforms: ["ios", "android", "macos", "windows", "linux"]
  },
  {
    app_name: "tonkeeper",
    name: "Tonkeeper",
    image: "https://tonkeeper.com/assets/tonconnect-icon.png",
    tondns: "tonkeeper.ton",
    about_url: "https://tonkeeper.com",
    universal_url: "https://app.tonkeeper.com/ton-connect",
    deepLink: "tonkeeper-tc://",
    bridge: [
      {
        type: "sse",
        url: "https://bridge.tonapi.io/bridge"
      },
      {
        type: "js",
        key: "tonkeeper"
      }
    ],
    platforms: ["ios", "android", "chrome", "firefox", "macos"]
  },
  {
    app_name: "mytonwallet",
    name: "MyTonWallet",
    image: "https://static.mytonwallet.io/icon-256.png",
    about_url: "https://mytonwallet.io",
    universal_url: "https://connect.mytonwallet.org",
    bridge: [
      {
        type: "js",
        key: "mytonwallet"
      },
      {
        type: "sse",
        url: "https://tonconnectbridge.mytonwallet.org/bridge/"
      }
    ],
    platforms: ["chrome", "windows", "macos", "linux", "ios", "android", "firefox"]
  },
  {
    app_name: "openmask",
    name: "OpenMask",
    image: "https://raw.githubusercontent.com/OpenProduct/openmask-extension/main/public/openmask-logo-288.png",
    about_url: "https://www.openmask.app/",
    bridge: [
      {
        type: "js",
        key: "openmask"
      }
    ],
    platforms: ["chrome"]
  },
  {
    app_name: "tonhub",
    name: "Tonhub",
    image: "https://tonhub.com/tonconnect_logo.png",
    about_url: "https://tonhub.com",
    universal_url: "https://tonhub.com/ton-connect",
    bridge: [
      {
        type: "js",
        key: "tonhub"
      },
      {
        type: "sse",
        url: "https://connect.tonhubapi.com/tonconnect"
      }
    ],
    platforms: ["ios", "android"]
  },
  {
    app_name: "dewallet",
    name: "DeWallet",
    image: "https://raw.githubusercontent.com/delab-team/manifests-images/main/WalletAvatar.png",
    about_url: "https://delabwallet.com",
    universal_url: "https://t.me/dewallet?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://sse-bridge.delab.team/bridge"
      }
    ],
    platforms: ["ios", "android"]
  },
  {
    app_name: "xtonwallet",
    name: "XTONWallet",
    image: "https://xtonwallet.com/assets/img/icon-256-back.png",
    about_url: "https://xtonwallet.com",
    bridge: [
      {
        type: "js",
        key: "xtonwallet"
      }
    ],
    platforms: ["chrome", "firefox"]
  },
  {
    app_name: "tonwallet",
    name: "TON Wallet",
    image: "https://wallet.ton.org/assets/ui/qr-logo.png",
    about_url: "https://chrome.google.com/webstore/detail/ton-wallet/nphplpgoakhhjchkkhmiggakijnkhfnd",
    bridge: [
      {
        type: "js",
        key: "tonwallet"
      }
    ],
    platforms: ["chrome"]
  },
  {
    app_name: "bitgetTonWallet",
    name: "Bitget Wallet",
    image: "https://raw.githubusercontent.com/bitkeepwallet/download/main/logo/png/bitget_wallet_logo_0_gas_fee.png",
    about_url: "https://web3.bitget.com",
    deepLink: "bitkeep://",
    bridge: [
      {
        type: "js",
        key: "bitgetTonWallet"
      },
      {
        type: "sse",
        url: "https://bridge.tonapi.io/bridge"
      }
    ],
    platforms: ["ios", "android", "chrome"],
    universal_url: "https://bkcode.vip/ton-connect"
  },
  {
    app_name: "safepalwallet",
    name: "SafePal",
    image: "https://s.pvcliping.com/web/public_image/SafePal_x288.png",
    tondns: "",
    about_url: "https://www.safepal.com",
    universal_url: "https://link.safepal.io/ton-connect",
    deepLink: "safepal-tc://",
    bridge: [
      {
        type: "sse",
        url: "https://ton-bridge.safepal.com/tonbridge/v1/bridge"
      },
      {
        type: "js",
        key: "safepalwallet"
      }
    ],
    platforms: ["ios", "android", "chrome", "firefox"]
  },
  {
    app_name: "okxTonWallet",
    name: "OKX Wallet",
    image: "https://static.okx.com/cdn/assets/imgs/247/58E63FEA47A2B7D7.png",
    about_url: "https://www.okx.com/web3",
    universal_url: "https://www.okx.com/download?appendQuery=true&deeplink=okx://web3/wallet/tonconnect",
    bridge: [
      {
        type: "js",
        key: "okxTonWallet"
      },
      {
        type: "sse",
        url: "https://www.okx.com/tonbridge/discover/rpc/bridge"
      }
    ],
    platforms: ["chrome", "safari", "firefox", "ios", "android"]
  },
  {
    app_name: "okxTonWalletTr",
    name: "OKX TR Wallet",
    image: "https://static.okx.com/cdn/assets/imgs/247/587A8296F0BB640F.png",
    about_url: "https://tr.okx.com/web3",
    universal_url: "https://tr.okx.com/download?appendQuery=true&deeplink=okxtr://web3/wallet/tonconnect",
    bridge: [
      {
        type: "js",
        key: "okxTonWallet"
      },
      {
        type: "sse",
        url: "https://www.okx.com/tonbridge/discover/rpc/bridge"
      }
    ],
    platforms: ["chrome", "safari", "firefox", "ios", "android"]
  }
];
class dv {
  constructor(e) {
    this.walletsListCache = null, this.walletsListCacheCreationTimestamp = null, this.walletsListSource = "https://raw.githubusercontent.com/ton-blockchain/wallets-list/main/wallets-v2.json", e != null && e.walletsListSource && (this.walletsListSource = e.walletsListSource), e != null && e.cacheTTLMs && (this.cacheTTLMs = e.cacheTTLMs);
  }
  getWallets() {
    return Mt(this, void 0, void 0, function* () {
      return this.cacheTTLMs && this.walletsListCacheCreationTimestamp && Date.now() > this.walletsListCacheCreationTimestamp + this.cacheTTLMs && (this.walletsListCache = null), this.walletsListCache || (this.walletsListCache = this.fetchWalletsList(), this.walletsListCache.then(() => {
        this.walletsListCacheCreationTimestamp = Date.now();
      }).catch(() => {
        this.walletsListCache = null, this.walletsListCacheCreationTimestamp = null;
      })), this.walletsListCache;
    });
  }
  getEmbeddedWallet() {
    return Mt(this, void 0, void 0, function* () {
      const r = (yield this.getWallets()).filter(Oie);
      return r.length !== 1 ? null : r[0];
    });
  }
  fetchWalletsList() {
    return Mt(this, void 0, void 0, function* () {
      let e = [];
      try {
        if (e = yield (yield fetch(this.walletsListSource)).json(), !Array.isArray(e))
          throw new fy("Wrong wallets list format, wallets list must be an array.");
        const i = e.filter((s) => !this.isCorrectWalletConfigDTO(s));
        i.length && (Ro(`Wallet(s) ${i.map((s) => s.name).join(", ")} config format is wrong. They were removed from the wallets list.`), e = e.filter((s) => this.isCorrectWalletConfigDTO(s)));
      } catch (n) {
        Ro(n), e = Lie;
      }
      let r = [];
      try {
        r = mi.getCurrentlyInjectedWallets();
      } catch (n) {
        Ro(n);
      }
      return this.mergeWalletsLists(this.walletConfigDTOListToWalletConfigList(e), r);
    });
  }
  walletConfigDTOListToWalletConfigList(e) {
    return e.map((r) => {
      const i = {
        name: r.name,
        appName: r.app_name,
        imageUrl: r.image,
        aboutUrl: r.about_url,
        tondns: r.tondns,
        platforms: r.platforms
      };
      return r.bridge.forEach((s) => {
        if (s.type === "sse" && (i.bridgeUrl = s.url, i.universalLink = r.universal_url, i.deepLink = r.deepLink), s.type === "js") {
          const o = s.key;
          i.jsBridgeKey = o, i.injected = mi.isWalletInjected(o), i.embedded = mi.isInsideWalletBrowser(o);
        }
      }), i;
    });
  }
  mergeWalletsLists(e, r) {
    return [...new Set(e.concat(r).map((i) => i.name)).values()].map((i) => {
      const s = e.find((a) => a.name === i), o = r.find((a) => a.name === i);
      return Object.assign(Object.assign({}, s && Object.assign({}, s)), o && Object.assign({}, o));
    });
  }
  // eslint-disable-next-line complexity
  isCorrectWalletConfigDTO(e) {
    if (!e || typeof e != "object")
      return !1;
    const r = "name" in e, n = "app_name" in e, i = "image" in e, s = "about_url" in e, o = "platforms" in e;
    if (!r || !i || !s || !o || !n || !e.platforms || !Array.isArray(e.platforms) || !e.platforms.length || !("bridge" in e) || !Array.isArray(e.bridge) || !e.bridge.length)
      return !1;
    const a = e.bridge;
    if (a.some((d) => !d || typeof d != "object" || !("type" in d)))
      return !1;
    const u = a.find((d) => d.type === "sse");
    if (u && (!("url" in u) || !u.url || !e.universal_url))
      return !1;
    const h = a.find((d) => d.type === "js");
    return !(h && (!("key" in h) || !h.key));
  }
}
class M0 extends Ut {
  get info() {
    return "Wallet doesn't support requested feature method.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, M0.prototype);
  }
}
function kie(t, e) {
  const r = t.includes("SendTransaction"), n = t.find((i) => i && typeof i == "object" && i.name === "SendTransaction");
  if (!r && !n)
    throw new M0("Wallet doesn't support SendTransaction feature.");
  if (n && n.maxMessages !== void 0) {
    if (n.maxMessages < e.requiredMessagesNumber)
      throw new M0(`Wallet is not able to handle such SendTransaction request. Max support messages number is ${n.maxMessages}, but ${e.requiredMessagesNumber} is required.`);
    return;
  }
  xie("Connected wallet didn't provide information about max allowed messages in the SendTransaction request. Request may be rejected by the wallet.");
}
function $ie() {
  return {
    type: "request-version"
  };
}
function Bie(t) {
  return {
    type: "response-version",
    version: t
  };
}
function Vu(t) {
  return {
    ton_connect_sdk_lib: t.ton_connect_sdk_lib,
    ton_connect_ui_lib: t.ton_connect_ui_lib
  };
}
function Gu(t, e) {
  var r, n, i, s, o, a, u, h;
  const p = ((r = e == null ? void 0 : e.connectItems) === null || r === void 0 ? void 0 : r.tonProof) && "proof" in e.connectItems.tonProof ? "ton_proof" : "ton_addr";
  return {
    wallet_address: (i = (n = e == null ? void 0 : e.account) === null || n === void 0 ? void 0 : n.address) !== null && i !== void 0 ? i : null,
    wallet_type: (s = e == null ? void 0 : e.device.appName) !== null && s !== void 0 ? s : null,
    wallet_version: (o = e == null ? void 0 : e.device.appVersion) !== null && o !== void 0 ? o : null,
    auth_type: p,
    custom_data: Object.assign({ chain_id: (u = (a = e == null ? void 0 : e.account) === null || a === void 0 ? void 0 : a.chain) !== null && u !== void 0 ? u : null, provider: (h = e == null ? void 0 : e.provider) !== null && h !== void 0 ? h : null }, Vu(t))
  };
}
function Fie(t) {
  return {
    type: "connection-started",
    custom_data: Vu(t)
  };
}
function Uie(t, e) {
  return Object.assign({ type: "connection-completed", is_success: !0 }, Gu(t, e));
}
function jie(t, e, r) {
  return {
    type: "connection-error",
    is_success: !1,
    error_message: e,
    error_code: r ?? null,
    custom_data: Vu(t)
  };
}
function qie(t) {
  return {
    type: "connection-restoring-started",
    custom_data: Vu(t)
  };
}
function zie(t, e) {
  return Object.assign({ type: "connection-restoring-completed", is_success: !0 }, Gu(t, e));
}
function Hie(t, e) {
  return {
    type: "connection-restoring-error",
    is_success: !1,
    error_message: e,
    custom_data: Vu(t)
  };
}
function ly(t, e) {
  var r, n, i, s;
  return {
    valid_until: (r = String(e.validUntil)) !== null && r !== void 0 ? r : null,
    from: (s = (n = e.from) !== null && n !== void 0 ? n : (i = t == null ? void 0 : t.account) === null || i === void 0 ? void 0 : i.address) !== null && s !== void 0 ? s : null,
    messages: e.messages.map((o) => {
      var a, u;
      return {
        address: (a = o.address) !== null && a !== void 0 ? a : null,
        amount: (u = o.amount) !== null && u !== void 0 ? u : null
      };
    })
  };
}
function Wie(t, e, r) {
  return Object.assign(Object.assign({ type: "transaction-sent-for-signature" }, Gu(t, e)), ly(e, r));
}
function Kie(t, e, r, n) {
  return Object.assign(Object.assign({ type: "transaction-signed", is_success: !0, signed_transaction: n.boc }, Gu(t, e)), ly(e, r));
}
function Vie(t, e, r, n, i) {
  return Object.assign(Object.assign({ type: "transaction-signing-failed", is_success: !1, error_message: n, error_code: i ?? null }, Gu(t, e)), ly(e, r));
}
function Gie(t, e, r) {
  return Object.assign({ type: "disconnection", scope: r }, Gu(t, e));
}
class Yie {
  constructor() {
    this.window = Cp();
  }
  /**
   * Dispatches an event with the given name and details to the browser window.
   * @param eventName - The name of the event to dispatch.
   * @param eventDetails - The details of the event to dispatch.
   * @returns A promise that resolves when the event has been dispatched.
   */
  dispatchEvent(e, r) {
    var n;
    return Mt(this, void 0, void 0, function* () {
      const i = new CustomEvent(e, { detail: r });
      (n = this.window) === null || n === void 0 || n.dispatchEvent(i);
    });
  }
  /**
   * Adds an event listener to the browser window.
   * @param eventName - The name of the event to listen for.
   * @param listener - The listener to add.
   * @param options - The options for the listener.
   * @returns A function that removes the listener.
   */
  addEventListener(e, r, n) {
    var i;
    return Mt(this, void 0, void 0, function* () {
      return (i = this.window) === null || i === void 0 || i.addEventListener(e, r, n), () => {
        var s;
        return (s = this.window) === null || s === void 0 ? void 0 : s.removeEventListener(e, r);
      };
    });
  }
}
class Jie {
  constructor(e) {
    var r;
    this.eventPrefix = "ton-connect-", this.tonConnectUiVersion = null, this.eventDispatcher = (r = e == null ? void 0 : e.eventDispatcher) !== null && r !== void 0 ? r : new Yie(), this.tonConnectSdkVersion = e.tonConnectSdkVersion, this.init().catch();
  }
  /**
   * Version of the library.
   */
  get version() {
    return Vu({
      ton_connect_sdk_lib: this.tonConnectSdkVersion,
      ton_connect_ui_lib: this.tonConnectUiVersion
    });
  }
  /**
   * Called once when the tracker is created and request version other libraries.
   */
  init() {
    return Mt(this, void 0, void 0, function* () {
      try {
        yield this.setRequestVersionHandler(), this.tonConnectUiVersion = yield this.requestTonConnectUiVersion();
      } catch {
      }
    });
  }
  /**
   * Set request version handler.
   * @private
   */
  setRequestVersionHandler() {
    return Mt(this, void 0, void 0, function* () {
      yield this.eventDispatcher.addEventListener("ton-connect-request-version", () => Mt(this, void 0, void 0, function* () {
        yield this.eventDispatcher.dispatchEvent("ton-connect-response-version", Bie(this.tonConnectSdkVersion));
      }));
    });
  }
  /**
   * Request TonConnect UI version.
   * @private
   */
  requestTonConnectUiVersion() {
    return Mt(this, void 0, void 0, function* () {
      return new Promise((e, r) => Mt(this, void 0, void 0, function* () {
        try {
          yield this.eventDispatcher.addEventListener("ton-connect-ui-response-version", (n) => {
            e(n.detail.version);
          }, { once: !0 }), yield this.eventDispatcher.dispatchEvent("ton-connect-ui-request-version", $ie());
        } catch (n) {
          r(n);
        }
      }));
    });
  }
  /**
   * Emit user action event to the window.
   * @param eventDetails
   * @private
   */
  dispatchUserActionEvent(e) {
    try {
      this.eventDispatcher.dispatchEvent(`${this.eventPrefix}${e.type}`, e).catch();
    } catch {
    }
  }
  /**
   * Track connection init event.
   * @param args
   */
  trackConnectionStarted(...e) {
    try {
      const r = Fie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection success event.
   * @param args
   */
  trackConnectionCompleted(...e) {
    try {
      const r = Uie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection error event.
   * @param args
   */
  trackConnectionError(...e) {
    try {
      const r = jie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection restoring init event.
   * @param args
   */
  trackConnectionRestoringStarted(...e) {
    try {
      const r = qie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection restoring success event.
   * @param args
   */
  trackConnectionRestoringCompleted(...e) {
    try {
      const r = zie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection restoring error event.
   * @param args
   */
  trackConnectionRestoringError(...e) {
    try {
      const r = Hie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track disconnect event.
   * @param args
   */
  trackDisconnection(...e) {
    try {
      const r = Gie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track transaction init event.
   * @param args
   */
  trackTransactionSentForSignature(...e) {
    try {
      const r = Wie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track transaction signed event.
   * @param args
   */
  trackTransactionSigned(...e) {
    try {
      const r = Kie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track transaction error event.
   * @param args
   */
  trackTransactionSigningFailed(...e) {
    try {
      const r = Vie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
}
const Xie = "3.0.5";
class Tp {
  constructor(e) {
    if (this.walletsList = new dv(), this._wallet = null, this.provider = null, this.statusChangeSubscriptions = [], this.statusChangeErrorSubscriptions = [], this.dappSettings = {
      manifestUrl: (e == null ? void 0 : e.manifestUrl) || Iie(),
      storage: (e == null ? void 0 : e.storage) || new Die()
    }, this.walletsList = new dv({
      walletsListSource: e == null ? void 0 : e.walletsListSource,
      cacheTTLMs: e == null ? void 0 : e.walletsListCacheTTLMs
    }), this.tracker = new Jie({
      eventDispatcher: e == null ? void 0 : e.eventDispatcher,
      tonConnectSdkVersion: Xie
    }), !this.dappSettings.manifestUrl)
      throw new ay("Dapp tonconnect-manifest.json must be specified if window.location.origin is undefined. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest");
    this.bridgeConnectionStorage = new Dl(this.dappSettings.storage), e != null && e.disableAutoPauseConnection || this.addWindowFocusAndBlurSubscriptions();
  }
  /**
   * Returns available wallets list.
   */
  static getWallets() {
    return this.walletsList.getWallets();
  }
  /**
   * Shows if the wallet is connected right now.
   */
  get connected() {
    return this._wallet !== null;
  }
  /**
   * Current connected account or null if no account is connected.
   */
  get account() {
    var e;
    return ((e = this._wallet) === null || e === void 0 ? void 0 : e.account) || null;
  }
  /**
   * Current connected wallet or null if no account is connected.
   */
  get wallet() {
    return this._wallet;
  }
  set wallet(e) {
    this._wallet = e, this.statusChangeSubscriptions.forEach((r) => r(this._wallet));
  }
  /**
   * Returns available wallets list.
   */
  getWallets() {
    return this.walletsList.getWallets();
  }
  /**
   * Allows to subscribe to connection status changes and handle connection errors.
   * @param callback will be called after connections status changes with actual wallet or null.
   * @param errorsHandler (optional) will be called with some instance of TonConnectError when connect error is received.
   * @returns unsubscribe callback.
   */
  onStatusChange(e, r) {
    return this.statusChangeSubscriptions.push(e), r && this.statusChangeErrorSubscriptions.push(r), () => {
      this.statusChangeSubscriptions = this.statusChangeSubscriptions.filter((n) => n !== e), r && (this.statusChangeErrorSubscriptions = this.statusChangeErrorSubscriptions.filter((n) => n !== r));
    };
  }
  connect(e, r) {
    var n, i;
    const s = {};
    if (typeof r == "object" && "tonProof" in r && (s.request = r), typeof r == "object" && ("openingDeadlineMS" in r || "signal" in r || "request" in r) && (s.request = r == null ? void 0 : r.request, s.openingDeadlineMS = r == null ? void 0 : r.openingDeadlineMS, s.signal = r == null ? void 0 : r.signal), this.connected)
      throw new cy();
    const o = xs(s == null ? void 0 : s.signal);
    if ((n = this.abortController) === null || n === void 0 || n.abort(), this.abortController = o, o.signal.aborted)
      throw new Ut("Connection was aborted");
    return (i = this.provider) === null || i === void 0 || i.closeConnection(), this.provider = this.createProvider(e), o.signal.addEventListener("abort", () => {
      var a;
      (a = this.provider) === null || a === void 0 || a.closeConnection(), this.provider = null;
    }), this.tracker.trackConnectionStarted(), this.provider.connect(this.createConnectRequest(s == null ? void 0 : s.request), {
      openingDeadlineMS: s == null ? void 0 : s.openingDeadlineMS,
      signal: o.signal
    });
  }
  /**
   * Try to restore existing session and reconnect to the corresponding wallet. Call it immediately when your app is loaded.
   */
  restoreConnection(e) {
    var r, n;
    return Mt(this, void 0, void 0, function* () {
      this.tracker.trackConnectionRestoringStarted();
      const i = xs(e == null ? void 0 : e.signal);
      if ((r = this.abortController) === null || r === void 0 || r.abort(), this.abortController = i, i.signal.aborted) {
        this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
        return;
      }
      const [s, o] = yield Promise.all([
        this.bridgeConnectionStorage.storedConnectionType(),
        this.walletsList.getEmbeddedWallet()
      ]);
      if (i.signal.aborted) {
        this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
        return;
      }
      let a = null;
      try {
        switch (s) {
          case "http":
            a = yield Ol.fromStorage(this.dappSettings.storage);
            break;
          case "injected":
            a = yield mi.fromStorage(this.dappSettings.storage);
            break;
          default:
            if (o)
              a = this.createProvider(o);
            else
              return;
        }
      } catch {
        this.tracker.trackConnectionRestoringError("Provider is not restored"), yield this.bridgeConnectionStorage.removeConnection(), a == null || a.closeConnection(), a = null;
        return;
      }
      if (i.signal.aborted) {
        a == null || a.closeConnection(), this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
        return;
      }
      if (!a) {
        Ro("Provider is not restored"), this.tracker.trackConnectionRestoringError("Provider is not restored");
        return;
      }
      (n = this.provider) === null || n === void 0 || n.closeConnection(), this.provider = a, a.listen(this.walletEventsListener.bind(this));
      const u = () => {
        this.tracker.trackConnectionRestoringError("Connection restoring was aborted"), a == null || a.closeConnection(), a = null;
      };
      i.signal.addEventListener("abort", u);
      const h = Jf((p) => Mt(this, void 0, void 0, function* () {
        yield a == null ? void 0 : a.restoreConnection({
          openingDeadlineMS: e == null ? void 0 : e.openingDeadlineMS,
          signal: p.signal
        }), i.signal.removeEventListener("abort", u), this.connected ? this.tracker.trackConnectionRestoringCompleted(this.wallet) : this.tracker.trackConnectionRestoringError("Connection restoring failed");
      }), {
        attempts: Number.MAX_SAFE_INTEGER,
        delayMs: 2e3,
        signal: e == null ? void 0 : e.signal
      }), d = new Promise(
        (p) => setTimeout(() => p(), 12e3)
        // connection deadline
      );
      return Promise.race([h, d]);
    });
  }
  sendTransaction(e, r) {
    return Mt(this, void 0, void 0, function* () {
      const n = {};
      typeof r == "function" ? n.onRequestSent = r : (n.onRequestSent = r == null ? void 0 : r.onRequestSent, n.signal = r == null ? void 0 : r.signal);
      const i = xs(n == null ? void 0 : n.signal);
      if (i.signal.aborted)
        throw new Ut("Transaction sending was aborted");
      this.checkConnection(), kie(this.wallet.device.features, {
        requiredMessagesNumber: e.messages.length
      }), this.tracker.trackTransactionSentForSignature(this.wallet, e);
      const { validUntil: s } = e, o = lie(e, ["validUntil"]), a = e.from || this.account.address, u = e.network || this.account.chain, h = yield this.provider.sendRequest(yd.convertToRpcRequest(Object.assign(Object.assign({}, o), {
        valid_until: s,
        from: a,
        network: u
      })), { onRequestSent: n.onRequestSent, signal: i.signal });
      if (yd.isError(h))
        return this.tracker.trackTransactionSigningFailed(this.wallet, e, h.error.message, h.error.code), yd.parseAndThrowError(h);
      const d = yd.convertFromRpcResponse(h);
      return this.tracker.trackTransactionSigned(this.wallet, e, d), d;
    });
  }
  /**
   * Disconnect form thw connected wallet and drop current session.
   */
  disconnect(e) {
    var r;
    return Mt(this, void 0, void 0, function* () {
      if (!this.connected)
        throw new P0();
      const n = xs(e == null ? void 0 : e.signal), i = this.abortController;
      if (this.abortController = n, n.signal.aborted)
        throw new Ut("Disconnect was aborted");
      this.onWalletDisconnected("dapp"), yield (r = this.provider) === null || r === void 0 ? void 0 : r.disconnect({
        signal: n.signal
      }), i == null || i.abort();
    });
  }
  /**
   * Pause bridge HTTP connection. Might be helpful, if you want to pause connections while browser tab is unfocused,
   * or if you use SDK with NodeJS and want to save server resources.
   */
  pauseConnection() {
    var e;
    ((e = this.provider) === null || e === void 0 ? void 0 : e.type) === "http" && this.provider.pause();
  }
  /**
   * Unpause bridge HTTP connection if it is paused.
   */
  unPauseConnection() {
    var e;
    return ((e = this.provider) === null || e === void 0 ? void 0 : e.type) !== "http" ? Promise.resolve() : this.provider.unPause();
  }
  addWindowFocusAndBlurSubscriptions() {
    const e = Mie();
    if (e)
      try {
        e.addEventListener("visibilitychange", () => {
          e.hidden ? this.pauseConnection() : this.unPauseConnection().catch();
        });
      } catch (r) {
        Ro("Cannot subscribe to the document.visibilitychange: ", r);
      }
  }
  createProvider(e) {
    let r;
    return !Array.isArray(e) && hie(e) ? r = new mi(this.dappSettings.storage, e.jsBridgeKey) : r = new Ol(this.dappSettings.storage, e), r.listen(this.walletEventsListener.bind(this)), r;
  }
  walletEventsListener(e) {
    switch (e.event) {
      case "connect":
        this.onWalletConnected(e.payload);
        break;
      case "connect_error":
        this.onWalletConnectError(e.payload);
        break;
      case "disconnect":
        this.onWalletDisconnected("wallet");
    }
  }
  onWalletConnected(e) {
    const r = e.items.find((s) => s.name === "ton_addr"), n = e.items.find((s) => s.name === "ton_proof");
    if (!r)
      throw new Ut("ton_addr connection item was not found");
    const i = {
      device: e.device,
      provider: this.provider.type,
      account: {
        address: r.address,
        chain: r.network,
        walletStateInit: r.walletStateInit,
        publicKey: r.publicKey
      }
    };
    n && (i.connectItems = {
      tonProof: n
    }), this.wallet = i, this.tracker.trackConnectionCompleted(i);
  }
  onWalletConnectError(e) {
    const r = pie.parseError(e);
    if (this.statusChangeErrorSubscriptions.forEach((n) => n(r)), Sn(r), this.tracker.trackConnectionError(e.message, e.code), r instanceof Ap || r instanceof Sp)
      throw Ro(r), r;
  }
  onWalletDisconnected(e) {
    this.tracker.trackDisconnection(this.wallet, e), this.wallet = null;
  }
  checkConnection() {
    if (!this.connected)
      throw new P0();
  }
  createConnectRequest(e) {
    const r = [
      {
        name: "ton_addr"
      }
    ];
    return e != null && e.tonProof && r.push({
      name: "ton_proof",
      payload: e.tonProof
    }), {
      manifestUrl: this.dappSettings.manifestUrl,
      items: r
    };
  }
}
Tp.walletsList = new dv();
Tp.isWalletInjected = (t) => mi.isWalletInjected(t);
Tp.isInsideWalletBrowser = (t) => mi.isInsideWalletBrowser(t);
for (let t = 0; t <= 255; t++) {
  let e = t.toString(16);
  e.length < 2 && (e = "0" + e);
}
function Gm(t) {
  const { children: e, onClick: r } = t;
  return /* @__PURE__ */ ve.jsx("button", { onClick: r, className: "xc-border xc-px-4 xc-py-2 xc-rounded-full xc-text-sm xc-flex xc-gap-2 xc-items-center", children: e });
}
function Zie(t) {
  const { wallet: e, connector: r } = t, n = bi(null), i = bi(), [s, o] = Er(), [a, u] = Er(), [h, d] = Er("connect"), [p, x] = Er(!1), [A, I] = Er();
  function N(R) {
    var K;
    (K = i.current) == null || K.update({
      data: R
    });
  }
  async function L() {
    try {
      x(!0), o("");
      const R = await va.getNonce({ account_type: "block_chain" });
      if ("universalLink" in e && e.universalLink) {
        const K = r.connect({
          universalLink: e.universalLink,
          bridgeUrl: e.bridgeUrl
        }, {
          request: { tonProof: R }
        });
        if (!K) return;
        I(K), N(K), u(R);
      }
    } catch (R) {
      o(R.message);
    }
    x(!1);
  }
  function F() {
    i.current = new D9({
      width: 264,
      height: 264,
      margin: 0,
      type: "svg",
      qrOptions: {
        errorCorrectionLevel: "M"
      },
      dotsOptions: {
        color: "black",
        type: "rounded"
      },
      backgroundOptions: {
        color: "transparent"
      }
    }), i.current.append(n.current);
  }
  function $() {
    r.connect(e, {
      request: { tonProof: a }
    });
  }
  function W() {
    if ("deepLink" in e) {
      if (!e.deepLink || !A) return;
      const R = new URL(A), K = `${e.deepLink}${R.search}`;
      window.open(K);
    }
  }
  function z() {
    "universalLink" in e && e.universalLink && /t.me/.test(e.universalLink) && window.open(A);
  }
  const V = Oi(() => !!("deepLink" in e && e.deepLink), [e]), te = Oi(() => !!("universalLink" in e && e.universalLink && /t.me/.test(e.universalLink)), [e]);
  return si(() => {
    F(), L();
  }, []), /* @__PURE__ */ ve.jsxs(Ec, { children: [
    /* @__PURE__ */ ve.jsx("div", { className: "xc-mb-6", children: /* @__PURE__ */ ve.jsx(uh, { title: "Log in to codatta", onBack: t.onBack }) }),
    /* @__PURE__ */ ve.jsxs("div", { className: "xc-text-center xc-mb-6", children: [
      /* @__PURE__ */ ve.jsxs("div", { className: "xc-w-[264px] xc-aspect-square xc-mx-auto xc-flex xc-items-center xc-justify-center", children: [
        /* @__PURE__ */ ve.jsx("div", { ref: n }),
        p && /* @__PURE__ */ ve.jsx(Pl, { className: "xc-animate-spin" })
      ] }),
      /* @__PURE__ */ ve.jsx("p", { className: "xc-text-center", children: "Scan the QR code below with your phone's camera. " })
    ] }),
    /* @__PURE__ */ ve.jsxs("div", { className: "xc-flex xc-justify-center xc-gap-2", children: [
      j9(e) && /* @__PURE__ */ ve.jsxs(Gm, { onClick: $, children: [
        /* @__PURE__ */ ve.jsx(eZ, { className: "xc-opacity-80" }),
        "Extension"
      ] }),
      V && /* @__PURE__ */ ve.jsxs(Gm, { onClick: W, children: [
        /* @__PURE__ */ ve.jsx(tZ, { className: "xc-opacity-80" }),
        "Desktop"
      ] }),
      te && /* @__PURE__ */ ve.jsx(Gm, { onClick: z, children: "Telegram Mini App" })
    ] })
  ] });
}
function Qie(t) {
  const [e, r] = Er(""), [n, i] = Er(), [s, o] = Er(), { config: a } = xc();
  async function u(d) {
    var x, A;
    if (!d || !((x = d.connectItems) != null && x.tonProof)) return;
    const p = await va.tonLogin({
      account_type: "block_chain",
      connector: "codatta_ton",
      account_enum: "C",
      wallet_name: d == null ? void 0 : d.device.appName,
      inviter_code: "1",
      address: d.account.address,
      chain: d.account.chain,
      connect_info: [
        { name: "ton_addr", network: d.account.chain, ...d.account },
        (A = d.connectItems) == null ? void 0 : A.tonProof
      ],
      source: {
        device: a.device,
        channel: a.channel,
        app: a.app
      },
      related_info: a.relateInfo
    });
    t.onLogin(p.data);
  }
  si(() => {
    const d = new Tp({
      manifestUrl: "https://static.codatta.io/static/tonconnect-manifest.json"
    }), p = d.onStatusChange(u);
    return o(d), r("select"), p;
  }, []);
  function h(d) {
    r("connect"), i(d);
  }
  return /* @__PURE__ */ ve.jsxs(Ec, { children: [
    e === "select" && /* @__PURE__ */ ve.jsx(
      rie,
      {
        connector: s,
        onSelect: h,
        onBack: t.onBack
      }
    ),
    e === "connect" && /* @__PURE__ */ ve.jsx(
      Zie,
      {
        connector: s,
        wallet: n,
        onBack: t.onBack
      }
    )
  ] });
}
function ese(t) {
  const { children: e, className: r } = t, n = bi(null), [i, s] = pv.useState(0);
  function o() {
    var a;
    try {
      const u = ((a = n.current) == null ? void 0 : a.children) || [];
      let h = 0;
      for (let d = 0; d < u.length; d++)
        h += u[d].offsetHeight;
      s(h);
    } catch (u) {
      console.error(u);
    }
  }
  return si(() => {
    const a = new MutationObserver(o);
    return a.observe(n.current, { childList: !0, subtree: !0 }), () => a.disconnect();
  }, []), si(() => {
    console.log("maxHeight", i);
  }, [i]), /* @__PURE__ */ ve.jsx(
    "div",
    {
      ref: n,
      className: r,
      style: {
        transition: "all 0.2s ease-in-out",
        overflow: "hidden",
        height: i
      },
      children: e
    }
  );
}
function tse() {
  return /* @__PURE__ */ ve.jsxs("svg", { width: "121", height: "120", viewBox: "0 0 121 120", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ ve.jsx("rect", { x: "0.5", width: "120", height: "120", rx: "60", fill: "#404049" }),
    /* @__PURE__ */ ve.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M52.8709 61.106C52.8208 61.4482 52.7948 61.7979 52.7948 62.1535C52.7948 66.2529 56.2445 69.5761 60.5 69.5761C64.7554 69.5761 68.2052 66.2529 68.2052 62.1535C68.2052 61.7979 68.1792 61.4482 68.129 61.106H86.826V77.6174C86.826 78.6422 85.9636 79.473 84.8997 79.473H36.1002C35.0364 79.473 34.174 78.6422 34.174 77.6174V61.106H52.8709Z", fill: "#252532" }),
    /* @__PURE__ */ ve.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M69.061 60.9416C69.061 65.6697 65.2281 69.5026 60.5 69.5026C55.7719 69.5026 51.939 65.6697 51.939 60.9416C51.939 60.7884 51.943 60.6362 51.951 60.485H33.5L39.7959 41.8696C40.0673 41.0671 40.8202 40.527 41.6674 40.527H79.3326C80.1798 40.527 80.9327 41.0671 81.2041 41.8696L87.5 60.485H69.049C69.057 60.6362 69.061 60.7884 69.061 60.9416Z", fill: "#252532" }),
    /* @__PURE__ */ ve.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M67.8081 61.5708C67.8081 65.2243 64.5361 68.8446 60.4999 68.8446C56.4637 68.8446 53.1918 65.2243 53.1918 61.5708C53.1918 61.4524 53.1952 60.6762 53.202 60.5594H39.4268L44.8013 47.4919C45.033 46.8717 45.6757 46.4543 46.3989 46.4543H74.601C75.3242 46.4543 75.9669 46.8717 76.1986 47.4919L81.5731 60.5594H67.7979C67.8046 60.6762 67.8081 61.4524 67.8081 61.5708Z", fill: "#404049" }),
    /* @__PURE__ */ ve.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M34.3232 60.6199V78.063C34.3232 78.6995 34.8392 79.2155 35.4757 79.2155H85.5245C86.1609 79.2155 86.6769 78.6995 86.6769 78.063V60.6199L80.4244 42.1328C80.2661 41.6647 79.8269 41.3496 79.3327 41.3496H41.6674C41.1733 41.3496 40.7341 41.6647 40.5758 42.1328L34.3232 60.6199Z", stroke: "#77777D", "stroke-width": "2" }),
    /* @__PURE__ */ ve.jsx("path", { d: "M34.817 60.2823C37.4094 60.2823 48.1095 60.2823 51.1124 60.2823C52.348 60.2823 52.348 61.1507 52.348 61.5994C52.348 65.9638 55.9675 69.5019 60.4323 69.5019C64.8971 69.5019 68.5165 65.9638 68.5165 61.5994C68.5165 61.1507 68.5165 60.2823 69.7521 60.2823H86.1829", stroke: "#77777D", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" })
  ] });
}
function rse(t) {
  const { wallets: e } = xc(), [r, n] = Er(), i = Oi(() => r ? e.filter((a) => a.key.toLowerCase().includes(r.toLowerCase())) : e, [r]);
  function s(a) {
    t.onSelectWallet(a);
  }
  function o(a) {
    n(a.target.value);
  }
  return /* @__PURE__ */ ve.jsxs(Ec, { children: [
    /* @__PURE__ */ ve.jsx("div", { className: "xc-mb-6", children: /* @__PURE__ */ ve.jsx(uh, { title: "Log in to codatta", onBack: t.onBack }) }),
    /* @__PURE__ */ ve.jsxs("div", { className: "xc-mb-6 xc-flex xc-gap-3 xc-px-4 xc-py-2 xc-border xc-rounded-xl xc-w-full xc-overflow-hidden xc-items-center", children: [
      /* @__PURE__ */ ve.jsx(zS, { className: "xc-shrink-0 xc-opacity-50" }),
      /* @__PURE__ */ ve.jsx("input", { type: "text", className: "xc-flex-1 xc-appearance-none xc-outline-none", onInput: o })
    ] }),
    /* @__PURE__ */ ve.jsx("div", { className: "xc-mb-4 xc-flex xc-h-[309px] xc-flex-col xc-gap-4 xc-overflow-scroll ", children: i.length ? i.map((a) => /* @__PURE__ */ ve.jsx(
      m9,
      {
        wallet: a,
        onClick: s
      },
      `feature-${a.key}`
    )) : /* @__PURE__ */ ve.jsx(tse, {}) })
  ] });
}
function foe(t) {
  const { onLogin: e } = t, [r, n] = Er(""), [i, s] = Er(null), [o, a] = Er("");
  function u(x) {
    s(x), n("evm-wallet");
  }
  function h(x) {
    n("email"), a(x);
  }
  async function d(x) {
    await e(x);
  }
  function p() {
    n("ton-wallet");
  }
  return si(() => {
    n("index");
  }, []), /* @__PURE__ */ ve.jsxs(ese, { className: "xc-rounded-2xl xc-transition-height xc-box-content xc-w-full xc-min-w-[277px] xc-max-w-[420px] xc-p-6 xc-border ", children: [
    r === "evm-wallet" && /* @__PURE__ */ ve.jsx(
      eie,
      {
        onBack: () => n("index"),
        onLogin: d,
        wallet: i
      }
    ),
    r === "ton-wallet" && /* @__PURE__ */ ve.jsx(
      Qie,
      {
        onBack: () => n("index"),
        onLogin: d
      }
    ),
    r === "email" && /* @__PURE__ */ ve.jsx(Tne, { email: o, onBack: () => n("index"), onLogin: d }),
    r === "index" && /* @__PURE__ */ ve.jsx(
      Lre,
      {
        onEmailConfirm: h,
        onSelectWallet: u,
        onSelectMoreWallets: () => {
          n("all-wallet");
        },
        onSelectTonConnect: p,
        config: {
          showEmailSignIn: !0,
          showFeaturedWallets: !0,
          showInstalledWallets: !0,
          showMoreWallets: !0,
          showTonConnect: !0
        }
      }
    ),
    r === "all-wallet" && /* @__PURE__ */ ve.jsx(
      rse,
      {
        onBack: () => n("index"),
        onSelectWallet: u
      }
    )
  ] });
}
export {
  coe as C,
  P5 as H,
  KX as a,
  Nl as b,
  ose as c,
  foe as d,
  Hd as e,
  sse as h,
  ase as r,
  t4 as s,
  C0 as t,
  xc as u
};
