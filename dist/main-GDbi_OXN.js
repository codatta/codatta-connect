var ER = Object.defineProperty;
var SR = (t, e, r) => e in t ? ER(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var Rs = (t, e, r) => SR(t, typeof e != "symbol" ? e + "" : e, r);
import * as Gt from "react";
import pv, { createContext as Sa, useContext as Tn, useState as fr, useEffect as Xn, forwardRef as gv, createElement as jd, useId as mv, useCallback as vv, Component as AR, useLayoutEffect as PR, useRef as bi, useInsertionEffect as v5, useMemo as Oi, Fragment as b5, Children as MR, isValidElement as IR } from "react";
var gn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ts(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function bv(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(t, n);
    Object.defineProperty(r, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[n];
      }
    });
  }), r;
}
var Ym = { exports: {} }, pf = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h2;
function CR() {
  if (h2) return pf;
  h2 = 1;
  var t = pv, e = Symbol.for("react.element"), r = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(a, u, l) {
    var d, p = {}, w = null, P = null;
    l !== void 0 && (w = "" + l), u.key !== void 0 && (w = "" + u.key), u.ref !== void 0 && (P = u.ref);
    for (d in u) n.call(u, d) && !s.hasOwnProperty(d) && (p[d] = u[d]);
    if (a && a.defaultProps) for (d in u = a.defaultProps, u) p[d] === void 0 && (p[d] = u[d]);
    return { $$typeof: e, type: a, key: w, ref: P, props: p, _owner: i.current };
  }
  return pf.Fragment = r, pf.jsx = o, pf.jsxs = o, pf;
}
var gf = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var d2;
function TR() {
  return d2 || (d2 = 1, process.env.NODE_ENV !== "production" && function() {
    var t = pv, e = Symbol.for("react.element"), r = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), a = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), w = Symbol.for("react.lazy"), P = Symbol.for("react.offscreen"), A = Symbol.iterator, N = "@@iterator";
    function L(U) {
      if (U === null || typeof U != "object")
        return null;
      var se = A && U[A] || U[N];
      return typeof se == "function" ? se : null;
    }
    var F = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function $(U) {
      {
        for (var se = arguments.length, he = new Array(se > 1 ? se - 1 : 0), xe = 1; xe < se; xe++)
          he[xe - 1] = arguments[xe];
        K("error", U, he);
      }
    }
    function K(U, se, he) {
      {
        var xe = F.ReactDebugCurrentFrame, Te = xe.getStackAddendum();
        Te !== "" && (se += "%s", he = he.concat([Te]));
        var Re = he.map(function(nt) {
          return String(nt);
        });
        Re.unshift("Warning: " + se), Function.prototype.apply.call(console[U], console, Re);
      }
    }
    var H = !1, V = !1, te = !1, R = !1, W = !1, pe;
    pe = Symbol.for("react.module.reference");
    function Ee(U) {
      return !!(typeof U == "string" || typeof U == "function" || U === n || U === s || W || U === i || U === l || U === d || R || U === P || H || V || te || typeof U == "object" && U !== null && (U.$$typeof === w || U.$$typeof === p || U.$$typeof === o || U.$$typeof === a || U.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      U.$$typeof === pe || U.getModuleId !== void 0));
    }
    function Y(U, se, he) {
      var xe = U.displayName;
      if (xe)
        return xe;
      var Te = se.displayName || se.name || "";
      return Te !== "" ? he + "(" + Te + ")" : he;
    }
    function S(U) {
      return U.displayName || "Context";
    }
    function m(U) {
      if (U == null)
        return null;
      if (typeof U.tag == "number" && $("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof U == "function")
        return U.displayName || U.name || null;
      if (typeof U == "string")
        return U;
      switch (U) {
        case n:
          return "Fragment";
        case r:
          return "Portal";
        case s:
          return "Profiler";
        case i:
          return "StrictMode";
        case l:
          return "Suspense";
        case d:
          return "SuspenseList";
      }
      if (typeof U == "object")
        switch (U.$$typeof) {
          case a:
            var se = U;
            return S(se) + ".Consumer";
          case o:
            var he = U;
            return S(he._context) + ".Provider";
          case u:
            return Y(U, U.render, "ForwardRef");
          case p:
            var xe = U.displayName || null;
            return xe !== null ? xe : m(U.type) || "Memo";
          case w: {
            var Te = U, Re = Te._payload, nt = Te._init;
            try {
              return m(nt(Re));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var f = Object.assign, g = 0, b, x, _, E, v, M, I;
    function B() {
    }
    B.__reactDisabledLog = !0;
    function ce() {
      {
        if (g === 0) {
          b = console.log, x = console.info, _ = console.warn, E = console.error, v = console.group, M = console.groupCollapsed, I = console.groupEnd;
          var U = {
            configurable: !0,
            enumerable: !0,
            value: B,
            writable: !0
          };
          Object.defineProperties(console, {
            info: U,
            log: U,
            warn: U,
            error: U,
            group: U,
            groupCollapsed: U,
            groupEnd: U
          });
        }
        g++;
      }
    }
    function D() {
      {
        if (g--, g === 0) {
          var U = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: f({}, U, {
              value: b
            }),
            info: f({}, U, {
              value: x
            }),
            warn: f({}, U, {
              value: _
            }),
            error: f({}, U, {
              value: E
            }),
            group: f({}, U, {
              value: v
            }),
            groupCollapsed: f({}, U, {
              value: M
            }),
            groupEnd: f({}, U, {
              value: I
            })
          });
        }
        g < 0 && $("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var oe = F.ReactCurrentDispatcher, Z;
    function J(U, se, he) {
      {
        if (Z === void 0)
          try {
            throw Error();
          } catch (Te) {
            var xe = Te.stack.trim().match(/\n( *(at )?)/);
            Z = xe && xe[1] || "";
          }
        return `
` + Z + U;
      }
    }
    var Q = !1, T;
    {
      var X = typeof WeakMap == "function" ? WeakMap : Map;
      T = new X();
    }
    function re(U, se) {
      if (!U || Q)
        return "";
      {
        var he = T.get(U);
        if (he !== void 0)
          return he;
      }
      var xe;
      Q = !0;
      var Te = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Re;
      Re = oe.current, oe.current = null, ce();
      try {
        if (se) {
          var nt = function() {
            throw Error();
          };
          if (Object.defineProperty(nt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(nt, []);
            } catch (_t) {
              xe = _t;
            }
            Reflect.construct(U, [], nt);
          } else {
            try {
              nt.call();
            } catch (_t) {
              xe = _t;
            }
            U.call(nt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (_t) {
            xe = _t;
          }
          U();
        }
      } catch (_t) {
        if (_t && xe && typeof _t.stack == "string") {
          for (var Ue = _t.stack.split(`
`), pt = xe.stack.split(`
`), it = Ue.length - 1, et = pt.length - 1; it >= 1 && et >= 0 && Ue[it] !== pt[et]; )
            et--;
          for (; it >= 1 && et >= 0; it--, et--)
            if (Ue[it] !== pt[et]) {
              if (it !== 1 || et !== 1)
                do
                  if (it--, et--, et < 0 || Ue[it] !== pt[et]) {
                    var St = `
` + Ue[it].replace(" at new ", " at ");
                    return U.displayName && St.includes("<anonymous>") && (St = St.replace("<anonymous>", U.displayName)), typeof U == "function" && T.set(U, St), St;
                  }
                while (it >= 1 && et >= 0);
              break;
            }
        }
      } finally {
        Q = !1, oe.current = Re, D(), Error.prepareStackTrace = Te;
      }
      var Tt = U ? U.displayName || U.name : "", At = Tt ? J(Tt) : "";
      return typeof U == "function" && T.set(U, At), At;
    }
    function de(U, se, he) {
      return re(U, !1);
    }
    function ie(U) {
      var se = U.prototype;
      return !!(se && se.isReactComponent);
    }
    function ue(U, se, he) {
      if (U == null)
        return "";
      if (typeof U == "function")
        return re(U, ie(U));
      if (typeof U == "string")
        return J(U);
      switch (U) {
        case l:
          return J("Suspense");
        case d:
          return J("SuspenseList");
      }
      if (typeof U == "object")
        switch (U.$$typeof) {
          case u:
            return de(U.render);
          case p:
            return ue(U.type, se, he);
          case w: {
            var xe = U, Te = xe._payload, Re = xe._init;
            try {
              return ue(Re(Te), se, he);
            } catch {
            }
          }
        }
      return "";
    }
    var ve = Object.prototype.hasOwnProperty, Pe = {}, De = F.ReactDebugCurrentFrame;
    function Ce(U) {
      if (U) {
        var se = U._owner, he = ue(U.type, U._source, se ? se.type : null);
        De.setExtraStackFrame(he);
      } else
        De.setExtraStackFrame(null);
    }
    function $e(U, se, he, xe, Te) {
      {
        var Re = Function.call.bind(ve);
        for (var nt in U)
          if (Re(U, nt)) {
            var Ue = void 0;
            try {
              if (typeof U[nt] != "function") {
                var pt = Error((xe || "React class") + ": " + he + " type `" + nt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof U[nt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw pt.name = "Invariant Violation", pt;
              }
              Ue = U[nt](se, nt, xe, he, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (it) {
              Ue = it;
            }
            Ue && !(Ue instanceof Error) && (Ce(Te), $("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", xe || "React class", he, nt, typeof Ue), Ce(null)), Ue instanceof Error && !(Ue.message in Pe) && (Pe[Ue.message] = !0, Ce(Te), $("Failed %s type: %s", he, Ue.message), Ce(null));
          }
      }
    }
    var Me = Array.isArray;
    function Ne(U) {
      return Me(U);
    }
    function Ke(U) {
      {
        var se = typeof Symbol == "function" && Symbol.toStringTag, he = se && U[Symbol.toStringTag] || U.constructor.name || "Object";
        return he;
      }
    }
    function Le(U) {
      try {
        return qe(U), !1;
      } catch {
        return !0;
      }
    }
    function qe(U) {
      return "" + U;
    }
    function ze(U) {
      if (Le(U))
        return $("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ke(U)), qe(U);
    }
    var _e = F.ReactCurrentOwner, Ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, at, ke, Qe;
    Qe = {};
    function tt(U) {
      if (ve.call(U, "ref")) {
        var se = Object.getOwnPropertyDescriptor(U, "ref").get;
        if (se && se.isReactWarning)
          return !1;
      }
      return U.ref !== void 0;
    }
    function Ye(U) {
      if (ve.call(U, "key")) {
        var se = Object.getOwnPropertyDescriptor(U, "key").get;
        if (se && se.isReactWarning)
          return !1;
      }
      return U.key !== void 0;
    }
    function dt(U, se) {
      if (typeof U.ref == "string" && _e.current && se && _e.current.stateNode !== se) {
        var he = m(_e.current.type);
        Qe[he] || ($('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', m(_e.current.type), U.ref), Qe[he] = !0);
      }
    }
    function lt(U, se) {
      {
        var he = function() {
          at || (at = !0, $("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", se));
        };
        he.isReactWarning = !0, Object.defineProperty(U, "key", {
          get: he,
          configurable: !0
        });
      }
    }
    function ct(U, se) {
      {
        var he = function() {
          ke || (ke = !0, $("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", se));
        };
        he.isReactWarning = !0, Object.defineProperty(U, "ref", {
          get: he,
          configurable: !0
        });
      }
    }
    var qt = function(U, se, he, xe, Te, Re, nt) {
      var Ue = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: U,
        key: se,
        ref: he,
        props: nt,
        // Record the component responsible for creating this element.
        _owner: Re
      };
      return Ue._store = {}, Object.defineProperty(Ue._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ue, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: xe
      }), Object.defineProperty(Ue, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Te
      }), Object.freeze && (Object.freeze(Ue.props), Object.freeze(Ue)), Ue;
    };
    function Yt(U, se, he, xe, Te) {
      {
        var Re, nt = {}, Ue = null, pt = null;
        he !== void 0 && (ze(he), Ue = "" + he), Ye(se) && (ze(se.key), Ue = "" + se.key), tt(se) && (pt = se.ref, dt(se, Te));
        for (Re in se)
          ve.call(se, Re) && !Ze.hasOwnProperty(Re) && (nt[Re] = se[Re]);
        if (U && U.defaultProps) {
          var it = U.defaultProps;
          for (Re in it)
            nt[Re] === void 0 && (nt[Re] = it[Re]);
        }
        if (Ue || pt) {
          var et = typeof U == "function" ? U.displayName || U.name || "Unknown" : U;
          Ue && lt(nt, et), pt && ct(nt, et);
        }
        return qt(U, Ue, pt, Te, xe, _e.current, nt);
      }
    }
    var Et = F.ReactCurrentOwner, Qt = F.ReactDebugCurrentFrame;
    function Jt(U) {
      if (U) {
        var se = U._owner, he = ue(U.type, U._source, se ? se.type : null);
        Qt.setExtraStackFrame(he);
      } else
        Qt.setExtraStackFrame(null);
    }
    var Dt;
    Dt = !1;
    function kt(U) {
      return typeof U == "object" && U !== null && U.$$typeof === e;
    }
    function Ct() {
      {
        if (Et.current) {
          var U = m(Et.current.type);
          if (U)
            return `

Check the render method of \`` + U + "`.";
        }
        return "";
      }
    }
    function gt(U) {
      return "";
    }
    var Rt = {};
    function Nt(U) {
      {
        var se = Ct();
        if (!se) {
          var he = typeof U == "string" ? U : U.displayName || U.name;
          he && (se = `

Check the top-level render call using <` + he + ">.");
        }
        return se;
      }
    }
    function vt(U, se) {
      {
        if (!U._store || U._store.validated || U.key != null)
          return;
        U._store.validated = !0;
        var he = Nt(se);
        if (Rt[he])
          return;
        Rt[he] = !0;
        var xe = "";
        U && U._owner && U._owner !== Et.current && (xe = " It was passed a child from " + m(U._owner.type) + "."), Jt(U), $('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', he, xe), Jt(null);
      }
    }
    function $t(U, se) {
      {
        if (typeof U != "object")
          return;
        if (Ne(U))
          for (var he = 0; he < U.length; he++) {
            var xe = U[he];
            kt(xe) && vt(xe, se);
          }
        else if (kt(U))
          U._store && (U._store.validated = !0);
        else if (U) {
          var Te = L(U);
          if (typeof Te == "function" && Te !== U.entries)
            for (var Re = Te.call(U), nt; !(nt = Re.next()).done; )
              kt(nt.value) && vt(nt.value, se);
        }
      }
    }
    function Bt(U) {
      {
        var se = U.type;
        if (se == null || typeof se == "string")
          return;
        var he;
        if (typeof se == "function")
          he = se.propTypes;
        else if (typeof se == "object" && (se.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        se.$$typeof === p))
          he = se.propTypes;
        else
          return;
        if (he) {
          var xe = m(se);
          $e(he, U.props, "prop", xe, U);
        } else if (se.PropTypes !== void 0 && !Dt) {
          Dt = !0;
          var Te = m(se);
          $("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Te || "Unknown");
        }
        typeof se.getDefaultProps == "function" && !se.getDefaultProps.isReactClassApproved && $("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function rt(U) {
      {
        for (var se = Object.keys(U.props), he = 0; he < se.length; he++) {
          var xe = se[he];
          if (xe !== "children" && xe !== "key") {
            Jt(U), $("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", xe), Jt(null);
            break;
          }
        }
        U.ref !== null && (Jt(U), $("Invalid attribute `ref` supplied to `React.Fragment`."), Jt(null));
      }
    }
    var Ft = {};
    function k(U, se, he, xe, Te, Re) {
      {
        var nt = Ee(U);
        if (!nt) {
          var Ue = "";
          (U === void 0 || typeof U == "object" && U !== null && Object.keys(U).length === 0) && (Ue += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var pt = gt();
          pt ? Ue += pt : Ue += Ct();
          var it;
          U === null ? it = "null" : Ne(U) ? it = "array" : U !== void 0 && U.$$typeof === e ? (it = "<" + (m(U.type) || "Unknown") + " />", Ue = " Did you accidentally export a JSX literal instead of a component?") : it = typeof U, $("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", it, Ue);
        }
        var et = Yt(U, se, he, Te, Re);
        if (et == null)
          return et;
        if (nt) {
          var St = se.children;
          if (St !== void 0)
            if (xe)
              if (Ne(St)) {
                for (var Tt = 0; Tt < St.length; Tt++)
                  $t(St[Tt], U);
                Object.freeze && Object.freeze(St);
              } else
                $("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              $t(St, U);
        }
        if (ve.call(se, "key")) {
          var At = m(U), _t = Object.keys(se).filter(function(st) {
            return st !== "key";
          }), ht = _t.length > 0 ? "{key: someKey, " + _t.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Ft[At + ht]) {
            var xt = _t.length > 0 ? "{" + _t.join(": ..., ") + ": ...}" : "{}";
            $(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ht, At, xt, At), Ft[At + ht] = !0;
          }
        }
        return U === n ? rt(et) : Bt(et), et;
      }
    }
    function j(U, se, he) {
      return k(U, se, he, !0);
    }
    function z(U, se, he) {
      return k(U, se, he, !1);
    }
    var C = z, G = j;
    gf.Fragment = n, gf.jsx = C, gf.jsxs = G;
  }()), gf;
}
process.env.NODE_ENV === "production" ? Ym.exports = CR() : Ym.exports = TR();
var me = Ym.exports;
const Ds = "https://static.codatta.io/codatta-connect/wallet-icons.svg?v=2", RR = [
  {
    featured: !0,
    name: "MetaMask",
    rdns: "io.metamask",
    image: `${Ds}#metamask`,
    getWallet: {
      chrome_store_id: "nkbihfbeogaeaoehlefnkodbefgpgknn",
      brave_store_id: "nkbihfbeogaeaoehlefnkodbefgpgknn",
      edge_addon_id: "ejbalbakoplchlghecdalmeeeajnimhm",
      firefox_addon_id: "ether-metamask",
      play_store_id: "io.metamask",
      app_store_id: "id1438144202"
    },
    deep_link: "metamask://wc",
    universal_link: "https://metamask.app.link/wc"
  },
  {
    featured: !0,
    name: "OKX Wallet",
    rdns: "com.okex.wallet",
    image: `${Ds}#okx`,
    getWallet: {
      chrome_store_id: "mcohilncbfahbmgdjkbpemcciiolgcge",
      brave_store_id: "mcohilncbfahbmgdjkbpemcciiolgcge",
      edge_addon_id: "pbpjkcldjiffchgbbndmhojiacbgflha",
      play_store_id: "com.okinc.okex.gp",
      app_store_id: "id1327268470"
    },
    deep_link: "okex://main/wc",
    universal_link: "okex://main/wc"
  },
  {
    featured: !0,
    name: "WalletConnect",
    image: `${Ds}#walletconnect`
  },
  {
    featured: !1,
    name: "Coinbase Wallet",
    image: `${Ds}#coinbase`
  },
  {
    featured: !1,
    name: "GateWallet",
    rdns: "io.gate.wallet",
    image: `${Ds}#6e528abf-7a7d-47bd-d84d-481f169b1200`,
    getWallet: {
      chrome_store_id: "cpmkedoipcpimgecpmgpldfpohjplkpp",
      brave_store_id: "cpmkedoipcpimgecpmgpldfpohjplkpp",
      play_store_id: "com.gateio.gateio",
      app_store_id: "id1294998195",
      mac_app_store_id: "id1609559473"
    },
    deep_link: "https://www.gate.io/mobileapp",
    universal_link: "https://www.gate.io/mobileapp"
  },
  {
    featured: !1,
    name: "Onekey",
    rdns: "so.onekey.app.wallet",
    image: `${Ds}#onekey`,
    getWallet: {
      chrome_store_id: "jnmbobjmhlngoefaiojfljckilhhlhcj",
      brave_store_id: "jnmbobjmhlngoefaiojfljckilhhlhcj",
      play_store_id: "so.onekey.app.wallet",
      app_store_id: "id1609559473"
    },
    deep_link: "onekey-wallet://",
    universal_link: "onekey://wc"
  },
  {
    featured: !1,
    name: "Infinity Wallet",
    image: `${Ds}#9f259366-0bcd-4817-0af9-f78773e41900`,
    desktop_link: "infinity://wc"
  },
  {
    name: "Rabby Wallet",
    rdns: "io.rabby",
    featured: !1,
    image: `${Ds}#rabby`,
    getWallet: {
      chrome_store_id: "acmacodkjbdgmoleebolmdjonilkdbch",
      brave_store_id: "acmacodkjbdgmoleebolmdjonilkdbch",
      play_store_id: "com.debank.rabbymobile",
      app_store_id: "id6474381673"
    }
  },
  {
    name: "Binance Web3 Wallet",
    featured: !1,
    image: `${Ds}#ebac7b39-688c-41e3-7912-a4fefba74600`,
    getWallet: {
      play_store_id: "com.binance.dev",
      app_store_id: "id1436799971"
    }
  },
  {
    name: "Rainbow Wallet",
    rdns: "me.rainbow",
    featured: !1,
    image: `${Ds}#rainbow`,
    getWallet: {
      chrome_store_id: "opfgelmcmbiajamepnmloijbpoleiama",
      edge_addon_id: "cpojfbodiccabbabgimdeohkkpjfpbnf",
      firefox_addon_id: "rainbow-extension",
      app_store_id: "id1457119021",
      play_store_id: "me.rainbow"
    }
  }
];
function DR(t, e) {
  const r = t.exec(e);
  return r == null ? void 0 : r.groups;
}
const p2 = /^tuple(?<array>(\[(\d*)\])*)$/;
function Jm(t) {
  let e = t.type;
  if (p2.test(t.type) && "components" in t) {
    e = "(";
    const r = t.components.length;
    for (let i = 0; i < r; i++) {
      const s = t.components[i];
      e += Jm(s), i < r - 1 && (e += ", ");
    }
    const n = DR(p2, t.type);
    return e += `)${(n == null ? void 0 : n.array) ?? ""}`, Jm({
      ...t,
      type: e
    });
  }
  return "indexed" in t && t.indexed && (e = `${e} indexed`), t.name ? `${e} ${t.name}` : e;
}
function mf(t) {
  let e = "";
  const r = t.length;
  for (let n = 0; n < r; n++) {
    const i = t[n];
    e += Jm(i), n !== r - 1 && (e += ", ");
  }
  return e;
}
function OR(t) {
  return t.type === "function" ? `function ${t.name}(${mf(t.inputs)})${t.stateMutability && t.stateMutability !== "nonpayable" ? ` ${t.stateMutability}` : ""}${t.outputs.length ? ` returns (${mf(t.outputs)})` : ""}` : t.type === "event" ? `event ${t.name}(${mf(t.inputs)})` : t.type === "error" ? `error ${t.name}(${mf(t.inputs)})` : t.type === "constructor" ? `constructor(${mf(t.inputs)})${t.stateMutability === "payable" ? " payable" : ""}` : t.type === "fallback" ? "fallback()" : "receive() external payable";
}
function vi(t, e, r) {
  const n = t[e.name];
  if (typeof n == "function")
    return n;
  const i = t[r];
  return typeof i == "function" ? i : (s) => e(t, s);
}
function mu(t, { includeName: e = !1 } = {}) {
  if (t.type !== "function" && t.type !== "event" && t.type !== "error")
    throw new WR(t.type);
  return `${t.name}(${yv(t.inputs, { includeName: e })})`;
}
function yv(t, { includeName: e = !1 } = {}) {
  return t ? t.map((r) => NR(r, { includeName: e })).join(e ? ", " : ",") : "";
}
function NR(t, { includeName: e }) {
  return t.type.startsWith("tuple") ? `(${yv(t.components, { includeName: e })})${t.type.slice(5)}` : t.type + (e && t.name ? ` ${t.name}` : "");
}
function ma(t, { strict: e = !0 } = {}) {
  return !t || typeof t != "string" ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(t) : t.startsWith("0x");
}
function An(t) {
  return ma(t, { strict: !1 }) ? Math.ceil((t.length - 2) / 2) : t.length;
}
const y5 = "2.21.45";
let vf = {
  getDocsUrl: ({ docsBaseUrl: t, docsPath: e = "", docsSlug: r }) => e ? `${t ?? "https://viem.sh"}${e}${r ? `#${r}` : ""}` : void 0,
  version: `viem@${y5}`
};
class yt extends Error {
  constructor(e, r = {}) {
    var a;
    const n = (() => {
      var u;
      return r.cause instanceof yt ? r.cause.details : (u = r.cause) != null && u.message ? r.cause.message : r.details;
    })(), i = r.cause instanceof yt && r.cause.docsPath || r.docsPath, s = (a = vf.getDocsUrl) == null ? void 0 : a.call(vf, { ...r, docsPath: i }), o = [
      e || "An error occurred.",
      "",
      ...r.metaMessages ? [...r.metaMessages, ""] : [],
      ...s ? [`Docs: ${s}`] : [],
      ...n ? [`Details: ${n}`] : [],
      ...vf.version ? [`Version: ${vf.version}`] : []
    ].join(`
`);
    super(o, r.cause ? { cause: r.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = n, this.docsPath = i, this.metaMessages = r.metaMessages, this.name = r.name ?? this.name, this.shortMessage = e, this.version = y5;
  }
  walk(e) {
    return w5(this, e);
  }
}
function w5(t, e) {
  return e != null && e(t) ? t : t && typeof t == "object" && "cause" in t && t.cause !== void 0 ? w5(t.cause, e) : e ? null : t;
}
class LR extends yt {
  constructor({ docsPath: e }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join(`
`), {
      docsPath: e,
      name: "AbiConstructorNotFoundError"
    });
  }
}
class g2 extends yt {
  constructor({ docsPath: e }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join(`
`), {
      docsPath: e,
      name: "AbiConstructorParamsNotFoundError"
    });
  }
}
class kR extends yt {
  constructor({ data: e, params: r, size: n }) {
    super([`Data size of ${n} bytes is too small for given parameters.`].join(`
`), {
      metaMessages: [
        `Params: (${yv(r, { includeName: !0 })})`,
        `Data:   ${e} (${n} bytes)`
      ],
      name: "AbiDecodingDataSizeTooSmallError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = e, this.params = r, this.size = n;
  }
}
class wv extends yt {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.', {
      name: "AbiDecodingZeroDataError"
    });
  }
}
class $R extends yt {
  constructor({ expectedLength: e, givenLength: r, type: n }) {
    super([
      `ABI encoding array length mismatch for type ${n}.`,
      `Expected length: ${e}`,
      `Given length: ${r}`
    ].join(`
`), { name: "AbiEncodingArrayLengthMismatchError" });
  }
}
class FR extends yt {
  constructor({ expectedSize: e, value: r }) {
    super(`Size of bytes "${r}" (bytes${An(r)}) does not match expected size (bytes${e}).`, { name: "AbiEncodingBytesSizeMismatchError" });
  }
}
class BR extends yt {
  constructor({ expectedLength: e, givenLength: r }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${e}`,
      `Given length (values): ${r}`
    ].join(`
`), { name: "AbiEncodingLengthMismatchError" });
  }
}
class x5 extends yt {
  constructor(e, { docsPath: r }) {
    super([
      `Encoded error signature "${e}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${e}.`
    ].join(`
`), {
      docsPath: r,
      name: "AbiErrorSignatureNotFoundError"
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.signature = e;
  }
}
class m2 extends yt {
  constructor(e, { docsPath: r } = {}) {
    super([
      `Function ${e ? `"${e}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: r,
      name: "AbiFunctionNotFoundError"
    });
  }
}
class UR extends yt {
  constructor(e, r) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${e.type}\` in \`${mu(e.abiItem)}\`, and`,
        `\`${r.type}\` in \`${mu(r.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ],
      name: "AbiItemAmbiguityError"
    });
  }
}
class jR extends yt {
  constructor({ expectedSize: e, givenSize: r }) {
    super(`Expected bytes${e}, got bytes${r}.`, {
      name: "BytesSizeMismatchError"
    });
  }
}
class qR extends yt {
  constructor(e, { docsPath: r }) {
    super([
      `Type "${e}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: r, name: "InvalidAbiEncodingType" });
  }
}
class zR extends yt {
  constructor(e, { docsPath: r }) {
    super([
      `Type "${e}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: r, name: "InvalidAbiDecodingType" });
  }
}
class HR extends yt {
  constructor(e) {
    super([`Value "${e}" is not a valid array.`].join(`
`), {
      name: "InvalidArrayError"
    });
  }
}
class WR extends yt {
  constructor(e) {
    super([
      `"${e}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join(`
`), { name: "InvalidDefinitionTypeError" });
  }
}
class _5 extends yt {
  constructor({ offset: e, position: r, size: n }) {
    super(`Slice ${r === "start" ? "starting" : "ending"} at offset "${e}" is out-of-bounds (size: ${n}).`, { name: "SliceOffsetOutOfBoundsError" });
  }
}
class E5 extends yt {
  constructor({ size: e, targetSize: r, type: n }) {
    super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${e}) exceeds padding size (${r}).`, { name: "SizeExceedsPaddingSizeError" });
  }
}
class v2 extends yt {
  constructor({ size: e, targetSize: r, type: n }) {
    super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} is expected to be ${r} ${n} long, but is ${e} ${n} long.`, { name: "InvalidBytesLengthError" });
  }
}
function Cu(t, { dir: e, size: r = 32 } = {}) {
  return typeof t == "string" ? ga(t, { dir: e, size: r }) : KR(t, { dir: e, size: r });
}
function ga(t, { dir: e, size: r = 32 } = {}) {
  if (r === null)
    return t;
  const n = t.replace("0x", "");
  if (n.length > r * 2)
    throw new E5({
      size: Math.ceil(n.length / 2),
      targetSize: r,
      type: "hex"
    });
  return `0x${n[e === "right" ? "padEnd" : "padStart"](r * 2, "0")}`;
}
function KR(t, { dir: e, size: r = 32 } = {}) {
  if (r === null)
    return t;
  if (t.length > r)
    throw new E5({
      size: t.length,
      targetSize: r,
      type: "bytes"
    });
  const n = new Uint8Array(r);
  for (let i = 0; i < r; i++) {
    const s = e === "right";
    n[s ? i : r - i - 1] = t[s ? i : t.length - i - 1];
  }
  return n;
}
class VR extends yt {
  constructor({ max: e, min: r, signed: n, size: i, value: s }) {
    super(`Number "${s}" is not in safe ${i ? `${i * 8}-bit ${n ? "signed" : "unsigned"} ` : ""}integer range ${e ? `(${r} to ${e})` : `(above ${r})`}`, { name: "IntegerOutOfRangeError" });
  }
}
class GR extends yt {
  constructor(e) {
    super(`Bytes value "${e}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
      name: "InvalidBytesBooleanError"
    });
  }
}
class YR extends yt {
  constructor({ givenSize: e, maxSize: r }) {
    super(`Size cannot exceed ${r} bytes. Given size: ${e} bytes.`, { name: "SizeOverflowError" });
  }
}
function xv(t, { dir: e = "left" } = {}) {
  let r = typeof t == "string" ? t.replace("0x", "") : t, n = 0;
  for (let i = 0; i < r.length - 1 && r[e === "left" ? i : r.length - i - 1].toString() === "0"; i++)
    n++;
  return r = e === "left" ? r.slice(n) : r.slice(0, r.length - n), typeof t == "string" ? (r.length === 1 && e === "right" && (r = `${r}0`), `0x${r.length % 2 === 1 ? `0${r}` : r}`) : r;
}
function eo(t, { size: e }) {
  if (An(t) > e)
    throw new YR({
      givenSize: An(t),
      maxSize: e
    });
}
function Qf(t, e = {}) {
  const { signed: r } = e;
  e.size && eo(t, { size: e.size });
  const n = BigInt(t);
  if (!r)
    return n;
  const i = (t.length - 2) / 2, s = (1n << BigInt(i) * 8n - 1n) - 1n;
  return n <= s ? n : n - BigInt(`0x${"f".padStart(i * 2, "f")}`) - 1n;
}
function vu(t, e = {}) {
  return Number(Qf(t, e));
}
const JR = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function qd(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint" ? Mr(t, e) : typeof t == "string" ? M0(t, e) : typeof t == "boolean" ? S5(t, e) : wi(t, e);
}
function S5(t, e = {}) {
  const r = `0x${Number(t)}`;
  return typeof e.size == "number" ? (eo(r, { size: e.size }), Cu(r, { size: e.size })) : r;
}
function wi(t, e = {}) {
  let r = "";
  for (let i = 0; i < t.length; i++)
    r += JR[t[i]];
  const n = `0x${r}`;
  return typeof e.size == "number" ? (eo(n, { size: e.size }), Cu(n, { dir: "right", size: e.size })) : n;
}
function Mr(t, e = {}) {
  const { signed: r, size: n } = e, i = BigInt(t);
  let s;
  n ? r ? s = (1n << BigInt(n) * 8n - 1n) - 1n : s = 2n ** (BigInt(n) * 8n) - 1n : typeof t == "number" && (s = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof s == "bigint" && r ? -s - 1n : 0;
  if (s && i > s || i < o) {
    const u = typeof t == "bigint" ? "n" : "";
    throw new VR({
      max: s ? `${s}${u}` : void 0,
      min: `${o}${u}`,
      signed: r,
      size: n,
      value: `${t}${u}`
    });
  }
  const a = `0x${(r && i < 0 ? (1n << BigInt(n * 8)) + BigInt(i) : i).toString(16)}`;
  return n ? Cu(a, { size: n }) : a;
}
const XR = /* @__PURE__ */ new TextEncoder();
function M0(t, e = {}) {
  const r = XR.encode(t);
  return wi(r, e);
}
const ZR = /* @__PURE__ */ new TextEncoder();
function _v(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint" ? eD(t, e) : typeof t == "boolean" ? QR(t, e) : ma(t) ? No(t, e) : A5(t, e);
}
function QR(t, e = {}) {
  const r = new Uint8Array(1);
  return r[0] = Number(t), typeof e.size == "number" ? (eo(r, { size: e.size }), Cu(r, { size: e.size })) : r;
}
const po = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function b2(t) {
  if (t >= po.zero && t <= po.nine)
    return t - po.zero;
  if (t >= po.A && t <= po.F)
    return t - (po.A - 10);
  if (t >= po.a && t <= po.f)
    return t - (po.a - 10);
}
function No(t, e = {}) {
  let r = t;
  e.size && (eo(r, { size: e.size }), r = Cu(r, { dir: "right", size: e.size }));
  let n = r.slice(2);
  n.length % 2 && (n = `0${n}`);
  const i = n.length / 2, s = new Uint8Array(i);
  for (let o = 0, a = 0; o < i; o++) {
    const u = b2(n.charCodeAt(a++)), l = b2(n.charCodeAt(a++));
    if (u === void 0 || l === void 0)
      throw new yt(`Invalid byte sequence ("${n[a - 2]}${n[a - 1]}" in "${n}").`);
    s[o] = u * 16 + l;
  }
  return s;
}
function eD(t, e) {
  const r = Mr(t, e);
  return No(r);
}
function A5(t, e = {}) {
  const r = ZR.encode(t);
  return typeof e.size == "number" ? (eo(r, { size: e.size }), Cu(r, { dir: "right", size: e.size })) : r;
}
function zd(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error(`positive integer expected, not ${t}`);
}
function tD(t) {
  return t instanceof Uint8Array || t != null && typeof t == "object" && t.constructor.name === "Uint8Array";
}
function Nl(t, ...e) {
  if (!tD(t))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error(`Uint8Array expected of length ${e}, not of length=${t.length}`);
}
function cse(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  zd(t.outputLen), zd(t.blockLen);
}
function Hd(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function P5(t, e) {
  Nl(t);
  const r = e.outputLen;
  if (t.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const td = /* @__PURE__ */ BigInt(2 ** 32 - 1), y2 = /* @__PURE__ */ BigInt(32);
function rD(t, e = !1) {
  return e ? { h: Number(t & td), l: Number(t >> y2 & td) } : { h: Number(t >> y2 & td) | 0, l: Number(t & td) | 0 };
}
function nD(t, e = !1) {
  let r = new Uint32Array(t.length), n = new Uint32Array(t.length);
  for (let i = 0; i < t.length; i++) {
    const { h: s, l: o } = rD(t[i], e);
    [r[i], n[i]] = [s, o];
  }
  return [r, n];
}
const iD = (t, e, r) => t << r | e >>> 32 - r, sD = (t, e, r) => e << r | t >>> 32 - r, oD = (t, e, r) => e << r - 32 | t >>> 64 - r, aD = (t, e, r) => t << r - 32 | e >>> 64 - r, jc = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const cD = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)), Fg = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), Os = (t, e) => t << 32 - e | t >>> e, w2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, uD = (t) => t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
function x2(t) {
  for (let e = 0; e < t.length; e++)
    t[e] = uD(t[e]);
}
const fD = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function lD(t) {
  Nl(t);
  let e = "";
  for (let r = 0; r < t.length; r++)
    e += fD[t[r]];
  return e;
}
function hD(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new Uint8Array(new TextEncoder().encode(t));
}
function I0(t) {
  return typeof t == "string" && (t = hD(t)), Nl(t), t;
}
function use(...t) {
  let e = 0;
  for (let n = 0; n < t.length; n++) {
    const i = t[n];
    Nl(i), e += i.length;
  }
  const r = new Uint8Array(e);
  for (let n = 0, i = 0; n < t.length; n++) {
    const s = t[n];
    r.set(s, i), i += s.length;
  }
  return r;
}
class M5 {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function I5(t) {
  const e = (n) => t().update(I0(n)).digest(), r = t();
  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e;
}
function dD(t) {
  const e = (n, i) => t(i).update(I0(n)).digest(), r = t({});
  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = (n) => t(n), e;
}
function fse(t = 32) {
  if (jc && typeof jc.getRandomValues == "function")
    return jc.getRandomValues(new Uint8Array(t));
  if (jc && typeof jc.randomBytes == "function")
    return jc.randomBytes(t);
  throw new Error("crypto.getRandomValues must be defined");
}
const C5 = [], T5 = [], R5 = [], pD = /* @__PURE__ */ BigInt(0), bf = /* @__PURE__ */ BigInt(1), gD = /* @__PURE__ */ BigInt(2), mD = /* @__PURE__ */ BigInt(7), vD = /* @__PURE__ */ BigInt(256), bD = /* @__PURE__ */ BigInt(113);
for (let t = 0, e = bf, r = 1, n = 0; t < 24; t++) {
  [r, n] = [n, (2 * r + 3 * n) % 5], C5.push(2 * (5 * n + r)), T5.push((t + 1) * (t + 2) / 2 % 64);
  let i = pD;
  for (let s = 0; s < 7; s++)
    e = (e << bf ^ (e >> mD) * bD) % vD, e & gD && (i ^= bf << (bf << /* @__PURE__ */ BigInt(s)) - bf);
  R5.push(i);
}
const [yD, wD] = /* @__PURE__ */ nD(R5, !0), _2 = (t, e, r) => r > 32 ? oD(t, e, r) : iD(t, e, r), E2 = (t, e, r) => r > 32 ? aD(t, e, r) : sD(t, e, r);
function D5(t, e = 24) {
  const r = new Uint32Array(10);
  for (let n = 24 - e; n < 24; n++) {
    for (let o = 0; o < 10; o++)
      r[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10, u = (o + 2) % 10, l = r[u], d = r[u + 1], p = _2(l, d, 1) ^ r[a], w = E2(l, d, 1) ^ r[a + 1];
      for (let P = 0; P < 50; P += 10)
        t[o + P] ^= p, t[o + P + 1] ^= w;
    }
    let i = t[2], s = t[3];
    for (let o = 0; o < 24; o++) {
      const a = T5[o], u = _2(i, s, a), l = E2(i, s, a), d = C5[o];
      i = t[d], s = t[d + 1], t[d] = u, t[d + 1] = l;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++)
        r[a] = t[o + a];
      for (let a = 0; a < 10; a++)
        t[o + a] ^= ~r[(a + 2) % 10] & r[(a + 4) % 10];
    }
    t[0] ^= yD[n], t[1] ^= wD[n];
  }
  r.fill(0);
}
class Ll extends M5 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, r, n, i = !1, s = 24) {
    if (super(), this.blockLen = e, this.suffix = r, this.outputLen = n, this.enableXOF = i, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, zd(n), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = cD(this.state);
  }
  keccak() {
    w2 || x2(this.state32), D5(this.state32, this.rounds), w2 || x2(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Hd(this);
    const { blockLen: r, state: n } = this;
    e = I0(e);
    const i = e.length;
    for (let s = 0; s < i; ) {
      const o = Math.min(r - this.pos, i - s);
      for (let a = 0; a < o; a++)
        n[this.pos++] ^= e[s++];
      this.pos === r && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: r, pos: n, blockLen: i } = this;
    e[n] ^= r, r & 128 && n === i - 1 && this.keccak(), e[i - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Hd(this, !1), Nl(e), this.finish();
    const r = this.state, { blockLen: n } = this;
    for (let i = 0, s = e.length; i < s; ) {
      this.posOut >= n && this.keccak();
      const o = Math.min(n - this.posOut, s - i);
      e.set(r.subarray(this.posOut, this.posOut + o), i), this.posOut += o, i += o;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return zd(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (P5(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: r, suffix: n, outputLen: i, rounds: s, enableXOF: o } = this;
    return e || (e = new Ll(r, n, i, o, s)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = s, e.suffix = n, e.outputLen = i, e.enableXOF = o, e.destroyed = this.destroyed, e;
  }
}
const Aa = (t, e, r) => I5(() => new Ll(e, t, r)), xD = /* @__PURE__ */ Aa(6, 144, 224 / 8), _D = /* @__PURE__ */ Aa(6, 136, 256 / 8), ED = /* @__PURE__ */ Aa(6, 104, 384 / 8), SD = /* @__PURE__ */ Aa(6, 72, 512 / 8), AD = /* @__PURE__ */ Aa(1, 144, 224 / 8), O5 = /* @__PURE__ */ Aa(1, 136, 256 / 8), PD = /* @__PURE__ */ Aa(1, 104, 384 / 8), MD = /* @__PURE__ */ Aa(1, 72, 512 / 8), N5 = (t, e, r) => dD((n = {}) => new Ll(e, t, n.dkLen === void 0 ? r : n.dkLen, !0)), ID = /* @__PURE__ */ N5(31, 168, 128 / 8), CD = /* @__PURE__ */ N5(31, 136, 256 / 8), TD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Keccak: Ll,
  keccakP: D5,
  keccak_224: AD,
  keccak_256: O5,
  keccak_384: PD,
  keccak_512: MD,
  sha3_224: xD,
  sha3_256: _D,
  sha3_384: ED,
  sha3_512: SD,
  shake128: ID,
  shake256: CD
}, Symbol.toStringTag, { value: "Module" }));
function kl(t, e) {
  const r = e || "hex", n = O5(ma(t, { strict: !1 }) ? _v(t) : t);
  return r === "bytes" ? n : qd(n);
}
const RD = (t) => kl(_v(t));
function DD(t) {
  return RD(t);
}
function OD(t) {
  let e = !0, r = "", n = 0, i = "", s = !1;
  for (let o = 0; o < t.length; o++) {
    const a = t[o];
    if (["(", ")", ","].includes(a) && (e = !0), a === "(" && n++, a === ")" && n--, !!e) {
      if (n === 0) {
        if (a === " " && ["event", "function", ""].includes(i))
          i = "";
        else if (i += a, a === ")") {
          s = !0;
          break;
        }
        continue;
      }
      if (a === " ") {
        t[o - 1] !== "," && r !== "," && r !== ",(" && (r = "", e = !1);
        continue;
      }
      i += a, r += a;
    }
  }
  if (!s)
    throw new yt("Unable to normalize signature.");
  return i;
}
const ND = (t) => {
  const e = typeof t == "string" ? t : OR(t);
  return OD(e);
};
function L5(t) {
  return DD(ND(t));
}
const LD = L5;
class bu extends yt {
  constructor({ address: e }) {
    super(`Address "${e}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
}
class C0 extends Map {
  constructor(e) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = e;
  }
  get(e) {
    const r = super.get(e);
    return super.has(e) && r !== void 0 && (this.delete(e), super.set(e, r)), r;
  }
  set(e, r) {
    if (super.set(e, r), this.maxSize && this.size > this.maxSize) {
      const n = this.keys().next().value;
      n && this.delete(n);
    }
    return this;
  }
}
const Bg = /* @__PURE__ */ new C0(8192);
function $l(t, e) {
  if (Bg.has(`${t}.${e}`))
    return Bg.get(`${t}.${e}`);
  const r = t.substring(2).toLowerCase(), n = kl(A5(r), "bytes"), i = r.split("");
  for (let o = 0; o < 40; o += 2)
    n[o >> 1] >> 4 >= 8 && i[o] && (i[o] = i[o].toUpperCase()), (n[o >> 1] & 15) >= 8 && i[o + 1] && (i[o + 1] = i[o + 1].toUpperCase());
  const s = `0x${i.join("")}`;
  return Bg.set(`${t}.${e}`, s), s;
}
function k5(t, e) {
  if (!Lo(t, { strict: !1 }))
    throw new bu({ address: t });
  return $l(t, e);
}
const kD = /^0x[a-fA-F0-9]{40}$/, Ug = /* @__PURE__ */ new C0(8192);
function Lo(t, e) {
  const { strict: r = !0 } = e ?? {}, n = `${t}.${r}`;
  if (Ug.has(n))
    return Ug.get(n);
  const i = kD.test(t) ? t.toLowerCase() === t ? !0 : r ? $l(t) === t : !0 : !1;
  return Ug.set(n, i), i;
}
function yu(t) {
  return typeof t[0] == "string" ? T0(t) : $D(t);
}
function $D(t) {
  let e = 0;
  for (const i of t)
    e += i.length;
  const r = new Uint8Array(e);
  let n = 0;
  for (const i of t)
    r.set(i, n), n += i.length;
  return r;
}
function T0(t) {
  return `0x${t.reduce((e, r) => e + r.replace("0x", ""), "")}`;
}
function Wd(t, e, r, { strict: n } = {}) {
  return ma(t, { strict: !1 }) ? FD(t, e, r, {
    strict: n
  }) : B5(t, e, r, {
    strict: n
  });
}
function $5(t, e) {
  if (typeof e == "number" && e > 0 && e > An(t) - 1)
    throw new _5({
      offset: e,
      position: "start",
      size: An(t)
    });
}
function F5(t, e, r) {
  if (typeof e == "number" && typeof r == "number" && An(t) !== r - e)
    throw new _5({
      offset: r,
      position: "end",
      size: An(t)
    });
}
function B5(t, e, r, { strict: n } = {}) {
  $5(t, e);
  const i = t.slice(e, r);
  return n && F5(i, e, r), i;
}
function FD(t, e, r, { strict: n } = {}) {
  $5(t, e);
  const i = `0x${t.replace("0x", "").slice((e ?? 0) * 2, (r ?? t.length) * 2)}`;
  return n && F5(i, e, r), i;
}
function U5(t, e) {
  if (t.length !== e.length)
    throw new BR({
      expectedLength: t.length,
      givenLength: e.length
    });
  const r = BD({
    params: t,
    values: e
  }), n = Sv(r);
  return n.length === 0 ? "0x" : n;
}
function BD({ params: t, values: e }) {
  const r = [];
  for (let n = 0; n < t.length; n++)
    r.push(Ev({ param: t[n], value: e[n] }));
  return r;
}
function Ev({ param: t, value: e }) {
  const r = Av(t.type);
  if (r) {
    const [n, i] = r;
    return jD(e, { length: n, param: { ...t, type: i } });
  }
  if (t.type === "tuple")
    return KD(e, {
      param: t
    });
  if (t.type === "address")
    return UD(e);
  if (t.type === "bool")
    return zD(e);
  if (t.type.startsWith("uint") || t.type.startsWith("int")) {
    const n = t.type.startsWith("int");
    return HD(e, { signed: n });
  }
  if (t.type.startsWith("bytes"))
    return qD(e, { param: t });
  if (t.type === "string")
    return WD(e);
  throw new qR(t.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function Sv(t) {
  let e = 0;
  for (let s = 0; s < t.length; s++) {
    const { dynamic: o, encoded: a } = t[s];
    o ? e += 32 : e += An(a);
  }
  const r = [], n = [];
  let i = 0;
  for (let s = 0; s < t.length; s++) {
    const { dynamic: o, encoded: a } = t[s];
    o ? (r.push(Mr(e + i, { size: 32 })), n.push(a), i += An(a)) : r.push(a);
  }
  return yu([...r, ...n]);
}
function UD(t) {
  if (!Lo(t))
    throw new bu({ address: t });
  return { dynamic: !1, encoded: ga(t.toLowerCase()) };
}
function jD(t, { length: e, param: r }) {
  const n = e === null;
  if (!Array.isArray(t))
    throw new HR(t);
  if (!n && t.length !== e)
    throw new $R({
      expectedLength: e,
      givenLength: t.length,
      type: `${r.type}[${e}]`
    });
  let i = !1;
  const s = [];
  for (let o = 0; o < t.length; o++) {
    const a = Ev({ param: r, value: t[o] });
    a.dynamic && (i = !0), s.push(a);
  }
  if (n || i) {
    const o = Sv(s);
    if (n) {
      const a = Mr(s.length, { size: 32 });
      return {
        dynamic: !0,
        encoded: s.length > 0 ? yu([a, o]) : a
      };
    }
    if (i)
      return { dynamic: !0, encoded: o };
  }
  return {
    dynamic: !1,
    encoded: yu(s.map(({ encoded: o }) => o))
  };
}
function qD(t, { param: e }) {
  const [, r] = e.type.split("bytes"), n = An(t);
  if (!r) {
    let i = t;
    return n % 32 !== 0 && (i = ga(i, {
      dir: "right",
      size: Math.ceil((t.length - 2) / 2 / 32) * 32
    })), {
      dynamic: !0,
      encoded: yu([ga(Mr(n, { size: 32 })), i])
    };
  }
  if (n !== Number.parseInt(r))
    throw new FR({
      expectedSize: Number.parseInt(r),
      value: t
    });
  return { dynamic: !1, encoded: ga(t, { dir: "right" }) };
}
function zD(t) {
  if (typeof t != "boolean")
    throw new yt(`Invalid boolean value: "${t}" (type: ${typeof t}). Expected: \`true\` or \`false\`.`);
  return { dynamic: !1, encoded: ga(S5(t)) };
}
function HD(t, { signed: e }) {
  return {
    dynamic: !1,
    encoded: Mr(t, {
      size: 32,
      signed: e
    })
  };
}
function WD(t) {
  const e = M0(t), r = Math.ceil(An(e) / 32), n = [];
  for (let i = 0; i < r; i++)
    n.push(ga(Wd(e, i * 32, (i + 1) * 32), {
      dir: "right"
    }));
  return {
    dynamic: !0,
    encoded: yu([
      ga(Mr(An(e), { size: 32 })),
      ...n
    ])
  };
}
function KD(t, { param: e }) {
  let r = !1;
  const n = [];
  for (let i = 0; i < e.components.length; i++) {
    const s = e.components[i], o = Array.isArray(t) ? i : s.name, a = Ev({
      param: s,
      value: t[o]
    });
    n.push(a), a.dynamic && (r = !0);
  }
  return {
    dynamic: r,
    encoded: r ? Sv(n) : yu(n.map(({ encoded: i }) => i))
  };
}
function Av(t) {
  const e = t.match(/^(.*)\[(\d+)?\]$/);
  return e ? (
    // Return `null` if the array is dynamic.
    [e[2] ? Number(e[2]) : null, e[1]]
  ) : void 0;
}
const Pv = (t) => Wd(L5(t), 0, 4);
function j5(t) {
  const { abi: e, args: r = [], name: n } = t, i = ma(n, { strict: !1 }), s = e.filter((a) => i ? a.type === "function" ? Pv(a) === n : a.type === "event" ? LD(a) === n : !1 : "name" in a && a.name === n);
  if (s.length === 0)
    return;
  if (s.length === 1)
    return s[0];
  let o;
  for (const a of s) {
    if (!("inputs" in a))
      continue;
    if (!r || r.length === 0) {
      if (!a.inputs || a.inputs.length === 0)
        return a;
      continue;
    }
    if (!a.inputs || a.inputs.length === 0 || a.inputs.length !== r.length)
      continue;
    if (r.every((l, d) => {
      const p = "inputs" in a && a.inputs[d];
      return p ? Xm(l, p) : !1;
    })) {
      if (o && "inputs" in o && o.inputs) {
        const l = q5(a.inputs, o.inputs, r);
        if (l)
          throw new UR({
            abiItem: a,
            type: l[0]
          }, {
            abiItem: o,
            type: l[1]
          });
      }
      o = a;
    }
  }
  return o || s[0];
}
function Xm(t, e) {
  const r = typeof t, n = e.type;
  switch (n) {
    case "address":
      return Lo(t, { strict: !1 });
    case "bool":
      return r === "boolean";
    case "function":
      return r === "string";
    case "string":
      return r === "string";
    default:
      return n === "tuple" && "components" in e ? Object.values(e.components).every((i, s) => Xm(Object.values(t)[s], i)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(n) ? r === "number" || r === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(n) ? r === "string" || t instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(n) ? Array.isArray(t) && t.every((i) => Xm(i, {
        ...e,
        // Pop off `[]` or `[M]` from end of type
        type: n.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1;
  }
}
function q5(t, e, r) {
  for (const n in t) {
    const i = t[n], s = e[n];
    if (i.type === "tuple" && s.type === "tuple" && "components" in i && "components" in s)
      return q5(i.components, s.components, r[n]);
    const o = [i.type, s.type];
    if (o.includes("address") && o.includes("bytes20") ? !0 : o.includes("address") && o.includes("string") ? Lo(r[n], { strict: !1 }) : o.includes("address") && o.includes("bytes") ? Lo(r[n], { strict: !1 }) : !1)
      return o;
  }
}
function jo(t) {
  return typeof t == "string" ? { address: t, type: "json-rpc" } : t;
}
const S2 = "/docs/contract/encodeFunctionData";
function VD(t) {
  const { abi: e, args: r, functionName: n } = t;
  let i = e[0];
  if (n) {
    const s = j5({
      abi: e,
      args: r,
      name: n
    });
    if (!s)
      throw new m2(n, { docsPath: S2 });
    i = s;
  }
  if (i.type !== "function")
    throw new m2(void 0, { docsPath: S2 });
  return {
    abi: [i],
    functionName: Pv(mu(i))
  };
}
function GD(t) {
  const { args: e } = t, { abi: r, functionName: n } = (() => {
    var a;
    return t.abi.length === 1 && ((a = t.functionName) != null && a.startsWith("0x")) ? t : VD(t);
  })(), i = r[0], s = n, o = "inputs" in i && i.inputs ? U5(i.inputs, e ?? []) : void 0;
  return T0([s, o ?? "0x"]);
}
const YD = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
}, JD = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
}, XD = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
class A2 extends yt {
  constructor({ offset: e }) {
    super(`Offset \`${e}\` cannot be negative.`, {
      name: "NegativeOffsetError"
    });
  }
}
class ZD extends yt {
  constructor({ length: e, position: r }) {
    super(`Position \`${r}\` is out of bounds (\`0 < position < ${e}\`).`, { name: "PositionOutOfBoundsError" });
  }
}
class QD extends yt {
  constructor({ count: e, limit: r }) {
    super(`Recursive read limit of \`${r}\` exceeded (recursive read count: \`${e}\`).`, { name: "RecursiveReadLimitExceededError" });
  }
}
const eO = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new QD({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(t) {
    if (t < 0 || t > this.bytes.length - 1)
      throw new ZD({
        length: this.bytes.length,
        position: t
      });
  },
  decrementPosition(t) {
    if (t < 0)
      throw new A2({ offset: t });
    const e = this.position - t;
    this.assertPosition(e), this.position = e;
  },
  getReadCount(t) {
    return this.positionReadCount.get(t || this.position) || 0;
  },
  incrementPosition(t) {
    if (t < 0)
      throw new A2({ offset: t });
    const e = this.position + t;
    this.assertPosition(e), this.position = e;
  },
  inspectByte(t) {
    const e = t ?? this.position;
    return this.assertPosition(e), this.bytes[e];
  },
  inspectBytes(t, e) {
    const r = e ?? this.position;
    return this.assertPosition(r + t - 1), this.bytes.subarray(r, r + t);
  },
  inspectUint8(t) {
    const e = t ?? this.position;
    return this.assertPosition(e), this.bytes[e];
  },
  inspectUint16(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 1), this.dataView.getUint16(e);
  },
  inspectUint24(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 2), (this.dataView.getUint16(e) << 8) + this.dataView.getUint8(e + 2);
  },
  inspectUint32(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 3), this.dataView.getUint32(e);
  },
  pushByte(t) {
    this.assertPosition(this.position), this.bytes[this.position] = t, this.position++;
  },
  pushBytes(t) {
    this.assertPosition(this.position + t.length - 1), this.bytes.set(t, this.position), this.position += t.length;
  },
  pushUint8(t) {
    this.assertPosition(this.position), this.bytes[this.position] = t, this.position++;
  },
  pushUint16(t) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, t), this.position += 2;
  },
  pushUint24(t) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, t >> 8), this.dataView.setUint8(this.position + 2, t & 255), this.position += 3;
  },
  pushUint32(t) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, t), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectByte();
    return this.position++, t;
  },
  readBytes(t, e) {
    this.assertReadLimit(), this._touch();
    const r = this.inspectBytes(t);
    return this.position += e ?? t, r;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint8();
    return this.position += 1, t;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint16();
    return this.position += 2, t;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint24();
    return this.position += 3, t;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint32();
    return this.position += 4, t;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(t) {
    const e = this.position;
    return this.assertPosition(t), this.position = t, () => this.position = e;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const t = this.getReadCount();
    this.positionReadCount.set(this.position, t + 1), t > 0 && this.recursiveReadCount++;
  }
};
function Mv(t, { recursiveReadLimit: e = 8192 } = {}) {
  const r = Object.create(eO);
  return r.bytes = t, r.dataView = new DataView(t.buffer, t.byteOffset, t.byteLength), r.positionReadCount = /* @__PURE__ */ new Map(), r.recursiveReadLimit = e, r;
}
function tO(t, e = {}) {
  typeof e.size < "u" && eo(t, { size: e.size });
  const r = wi(t, e);
  return Qf(r, e);
}
function rO(t, e = {}) {
  let r = t;
  if (typeof e.size < "u" && (eo(r, { size: e.size }), r = xv(r)), r.length > 1 || r[0] > 1)
    throw new GR(r);
  return !!r[0];
}
function Mo(t, e = {}) {
  typeof e.size < "u" && eo(t, { size: e.size });
  const r = wi(t, e);
  return vu(r, e);
}
function nO(t, e = {}) {
  let r = t;
  return typeof e.size < "u" && (eo(r, { size: e.size }), r = xv(r, { dir: "right" })), new TextDecoder().decode(r);
}
function iO(t, e) {
  const r = typeof e == "string" ? No(e) : e, n = Mv(r);
  if (An(r) === 0 && t.length > 0)
    throw new wv();
  if (An(e) && An(e) < 32)
    throw new kR({
      data: typeof e == "string" ? e : wi(e),
      params: t,
      size: An(e)
    });
  let i = 0;
  const s = [];
  for (let o = 0; o < t.length; ++o) {
    const a = t[o];
    n.setPosition(i);
    const [u, l] = ou(n, a, {
      staticPosition: 0
    });
    i += l, s.push(u);
  }
  return s;
}
function ou(t, e, { staticPosition: r }) {
  const n = Av(e.type);
  if (n) {
    const [i, s] = n;
    return oO(t, { ...e, type: s }, { length: i, staticPosition: r });
  }
  if (e.type === "tuple")
    return fO(t, e, { staticPosition: r });
  if (e.type === "address")
    return sO(t);
  if (e.type === "bool")
    return aO(t);
  if (e.type.startsWith("bytes"))
    return cO(t, e, { staticPosition: r });
  if (e.type.startsWith("uint") || e.type.startsWith("int"))
    return uO(t, e);
  if (e.type === "string")
    return lO(t, { staticPosition: r });
  throw new zR(e.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
const P2 = 32, Zm = 32;
function sO(t) {
  const e = t.readBytes(32);
  return [$l(wi(B5(e, -20))), 32];
}
function oO(t, e, { length: r, staticPosition: n }) {
  if (!r) {
    const o = Mo(t.readBytes(Zm)), a = n + o, u = a + P2;
    t.setPosition(a);
    const l = Mo(t.readBytes(P2)), d = el(e);
    let p = 0;
    const w = [];
    for (let P = 0; P < l; ++P) {
      t.setPosition(u + (d ? P * 32 : p));
      const [A, N] = ou(t, e, {
        staticPosition: u
      });
      p += N, w.push(A);
    }
    return t.setPosition(n + 32), [w, 32];
  }
  if (el(e)) {
    const o = Mo(t.readBytes(Zm)), a = n + o, u = [];
    for (let l = 0; l < r; ++l) {
      t.setPosition(a + l * 32);
      const [d] = ou(t, e, {
        staticPosition: a
      });
      u.push(d);
    }
    return t.setPosition(n + 32), [u, 32];
  }
  let i = 0;
  const s = [];
  for (let o = 0; o < r; ++o) {
    const [a, u] = ou(t, e, {
      staticPosition: n + i
    });
    i += u, s.push(a);
  }
  return [s, i];
}
function aO(t) {
  return [rO(t.readBytes(32), { size: 32 }), 32];
}
function cO(t, e, { staticPosition: r }) {
  const [n, i] = e.type.split("bytes");
  if (!i) {
    const o = Mo(t.readBytes(32));
    t.setPosition(r + o);
    const a = Mo(t.readBytes(32));
    if (a === 0)
      return t.setPosition(r + 32), ["0x", 32];
    const u = t.readBytes(a);
    return t.setPosition(r + 32), [wi(u), 32];
  }
  return [wi(t.readBytes(Number.parseInt(i), 32)), 32];
}
function uO(t, e) {
  const r = e.type.startsWith("int"), n = Number.parseInt(e.type.split("int")[1] || "256"), i = t.readBytes(32);
  return [
    n > 48 ? tO(i, { signed: r }) : Mo(i, { signed: r }),
    32
  ];
}
function fO(t, e, { staticPosition: r }) {
  const n = e.components.length === 0 || e.components.some(({ name: o }) => !o), i = n ? [] : {};
  let s = 0;
  if (el(e)) {
    const o = Mo(t.readBytes(Zm)), a = r + o;
    for (let u = 0; u < e.components.length; ++u) {
      const l = e.components[u];
      t.setPosition(a + s);
      const [d, p] = ou(t, l, {
        staticPosition: a
      });
      s += p, i[n ? u : l == null ? void 0 : l.name] = d;
    }
    return t.setPosition(r + 32), [i, 32];
  }
  for (let o = 0; o < e.components.length; ++o) {
    const a = e.components[o], [u, l] = ou(t, a, {
      staticPosition: r
    });
    i[n ? o : a == null ? void 0 : a.name] = u, s += l;
  }
  return [i, s];
}
function lO(t, { staticPosition: e }) {
  const r = Mo(t.readBytes(32)), n = e + r;
  t.setPosition(n);
  const i = Mo(t.readBytes(32));
  if (i === 0)
    return t.setPosition(e + 32), ["", 32];
  const s = t.readBytes(i, 32), o = nO(xv(s));
  return t.setPosition(e + 32), [o, 32];
}
function el(t) {
  var n;
  const { type: e } = t;
  if (e === "string" || e === "bytes" || e.endsWith("[]"))
    return !0;
  if (e === "tuple")
    return (n = t.components) == null ? void 0 : n.some(el);
  const r = Av(t.type);
  return !!(r && el({ ...t, type: r[1] }));
}
function hO(t) {
  const { abi: e, data: r } = t, n = Wd(r, 0, 4);
  if (n === "0x")
    throw new wv();
  const s = [...e || [], JD, XD].find((o) => o.type === "error" && n === Pv(mu(o)));
  if (!s)
    throw new x5(n, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem: s,
    args: "inputs" in s && s.inputs && s.inputs.length > 0 ? iO(s.inputs, Wd(r, 4)) : void 0,
    errorName: s.name
  };
}
const Tu = (t, e, r) => JSON.stringify(t, (n, i) => typeof i == "bigint" ? i.toString() : i, r);
function z5({ abiItem: t, args: e, includeFunctionName: r = !0, includeName: n = !1 }) {
  if ("name" in t && "inputs" in t && t.inputs)
    return `${r ? t.name : ""}(${t.inputs.map((i, s) => `${n && i.name ? `${i.name}: ` : ""}${typeof e[s] == "object" ? Tu(e[s]) : e[s]}`).join(", ")})`;
}
const dO = {
  gwei: 9,
  wei: 18
}, pO = {
  ether: -9,
  wei: 9
};
function H5(t, e) {
  let r = t.toString();
  const n = r.startsWith("-");
  n && (r = r.slice(1)), r = r.padStart(e, "0");
  let [i, s] = [
    r.slice(0, r.length - e),
    r.slice(r.length - e)
  ];
  return s = s.replace(/(0+)$/, ""), `${n ? "-" : ""}${i || "0"}${s ? `.${s}` : ""}`;
}
function W5(t, e = "wei") {
  return H5(t, dO[e]);
}
function _s(t, e = "wei") {
  return H5(t, pO[e]);
}
class gO extends yt {
  constructor({ address: e }) {
    super(`State for account "${e}" is set multiple times.`, {
      name: "AccountStateConflictError"
    });
  }
}
class mO extends yt {
  constructor() {
    super("state and stateDiff are set on the same account.", {
      name: "StateAssignmentConflictError"
    });
  }
}
function R0(t) {
  const e = Object.entries(t).map(([n, i]) => i === void 0 || i === !1 ? null : [n, i]).filter(Boolean), r = e.reduce((n, [i]) => Math.max(n, i.length), 0);
  return e.map(([n, i]) => `  ${`${n}:`.padEnd(r + 1)}  ${i}`).join(`
`);
}
class vO extends yt {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join(`
`), { name: "FeeConflictError" });
  }
}
class bO extends yt {
  constructor({ transaction: e }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        R0(e),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- an EIP-7702 Transaction with `authorizationList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ],
      name: "InvalidSerializableTransactionError"
    });
  }
}
class yO extends yt {
  constructor(e, { account: r, docsPath: n, chain: i, data: s, gas: o, gasPrice: a, maxFeePerGas: u, maxPriorityFeePerGas: l, nonce: d, to: p, value: w }) {
    var A;
    const P = R0({
      chain: i && `${i == null ? void 0 : i.name} (id: ${i == null ? void 0 : i.id})`,
      from: r == null ? void 0 : r.address,
      to: p,
      value: typeof w < "u" && `${W5(w)} ${((A = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : A.symbol) || "ETH"}`,
      data: s,
      gas: o,
      gasPrice: typeof a < "u" && `${_s(a)} gwei`,
      maxFeePerGas: typeof u < "u" && `${_s(u)} gwei`,
      maxPriorityFeePerGas: typeof l < "u" && `${_s(l)} gwei`,
      nonce: d
    });
    super(e.shortMessage, {
      cause: e,
      docsPath: n,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        "Request Arguments:",
        P
      ].filter(Boolean),
      name: "TransactionExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = e;
  }
}
const wO = (t) => t, K5 = (t) => t;
class xO extends yt {
  constructor(e, { abi: r, args: n, contractAddress: i, docsPath: s, functionName: o, sender: a }) {
    const u = j5({ abi: r, args: n, name: o }), l = u ? z5({
      abiItem: u,
      args: n,
      includeFunctionName: !1,
      includeName: !1
    }) : void 0, d = u ? mu(u, { includeName: !0 }) : void 0, p = R0({
      address: i && wO(i),
      function: d,
      args: l && l !== "()" && `${[...Array((o == null ? void 0 : o.length) ?? 0).keys()].map(() => " ").join("")}${l}`,
      sender: a
    });
    super(e.shortMessage || `An unknown error occurred while executing the contract function "${o}".`, {
      cause: e,
      docsPath: s,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        p && "Contract Call:",
        p
      ].filter(Boolean),
      name: "ContractFunctionExecutionError"
    }), Object.defineProperty(this, "abi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "args", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "contractAddress", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "formattedArgs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "functionName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sender", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abi = r, this.args = n, this.cause = e, this.contractAddress = i, this.functionName = o, this.sender = a;
  }
}
class _O extends yt {
  constructor({ abi: e, data: r, functionName: n, message: i }) {
    let s, o, a, u;
    if (r && r !== "0x")
      try {
        o = hO({ abi: e, data: r });
        const { abiItem: d, errorName: p, args: w } = o;
        if (p === "Error")
          u = w[0];
        else if (p === "Panic") {
          const [P] = w;
          u = YD[P];
        } else {
          const P = d ? mu(d, { includeName: !0 }) : void 0, A = d && w ? z5({
            abiItem: d,
            args: w,
            includeFunctionName: !1,
            includeName: !1
          }) : void 0;
          a = [
            P ? `Error: ${P}` : "",
            A && A !== "()" ? `       ${[...Array((p == null ? void 0 : p.length) ?? 0).keys()].map(() => " ").join("")}${A}` : ""
          ];
        }
      } catch (d) {
        s = d;
      }
    else i && (u = i);
    let l;
    s instanceof x5 && (l = s.signature, a = [
      `Unable to decode signature "${l}" as it was not found on the provided ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${l}.`
    ]), super(u && u !== "execution reverted" || l ? [
      `The contract function "${n}" reverted with the following ${l ? "signature" : "reason"}:`,
      u || l
    ].join(`
`) : `The contract function "${n}" reverted.`, {
      cause: s,
      metaMessages: a,
      name: "ContractFunctionRevertedError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reason", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = o, this.reason = u, this.signature = l;
  }
}
class EO extends yt {
  constructor({ functionName: e }) {
    super(`The contract function "${e}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${e}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ],
      name: "ContractFunctionZeroDataError"
    });
  }
}
class SO extends yt {
  constructor({ data: e, message: r }) {
    super(r || "", { name: "RawContractError" }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = e;
  }
}
class V5 extends yt {
  constructor({ body: e, cause: r, details: n, headers: i, status: s, url: o }) {
    super("HTTP request failed.", {
      cause: r,
      details: n,
      metaMessages: [
        s && `Status: ${s}`,
        `URL: ${K5(o)}`,
        e && `Request body: ${Tu(e)}`
      ].filter(Boolean),
      name: "HttpRequestError"
    }), Object.defineProperty(this, "body", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "url", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.body = e, this.headers = i, this.status = s, this.url = o;
  }
}
class AO extends yt {
  constructor({ body: e, error: r, url: n }) {
    super("RPC Request failed.", {
      cause: r,
      details: r.message,
      metaMessages: [`URL: ${K5(n)}`, `Request body: ${Tu(e)}`],
      name: "RpcRequestError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.code = r.code;
  }
}
const PO = -1;
class Ei extends yt {
  constructor(e, { code: r, docsPath: n, metaMessages: i, name: s, shortMessage: o }) {
    super(o, {
      cause: e,
      docsPath: n,
      metaMessages: i || (e == null ? void 0 : e.metaMessages),
      name: s || "RpcError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = s || e.name, this.code = e instanceof AO ? e.code : r ?? PO;
  }
}
class Ru extends Ei {
  constructor(e, r) {
    super(e, r), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = r.data;
  }
}
class tl extends Ei {
  constructor(e) {
    super(e, {
      code: tl.code,
      name: "ParseRpcError",
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    });
  }
}
Object.defineProperty(tl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32700
});
class rl extends Ei {
  constructor(e) {
    super(e, {
      code: rl.code,
      name: "InvalidRequestRpcError",
      shortMessage: "JSON is not a valid request object."
    });
  }
}
Object.defineProperty(rl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32600
});
class nl extends Ei {
  constructor(e, { method: r } = {}) {
    super(e, {
      code: nl.code,
      name: "MethodNotFoundRpcError",
      shortMessage: `The method${r ? ` "${r}"` : ""} does not exist / is not available.`
    });
  }
}
Object.defineProperty(nl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32601
});
class il extends Ei {
  constructor(e) {
    super(e, {
      code: il.code,
      name: "InvalidParamsRpcError",
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    });
  }
}
Object.defineProperty(il, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602
});
class cc extends Ei {
  constructor(e) {
    super(e, {
      code: cc.code,
      name: "InternalRpcError",
      shortMessage: "An internal error was received."
    });
  }
}
Object.defineProperty(cc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603
});
class sl extends Ei {
  constructor(e) {
    super(e, {
      code: sl.code,
      name: "InvalidInputRpcError",
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    });
  }
}
Object.defineProperty(sl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32e3
});
class ol extends Ei {
  constructor(e) {
    super(e, {
      code: ol.code,
      name: "ResourceNotFoundRpcError",
      shortMessage: "Requested resource not found."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty(ol, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32001
});
class al extends Ei {
  constructor(e) {
    super(e, {
      code: al.code,
      name: "ResourceUnavailableRpcError",
      shortMessage: "Requested resource not available."
    });
  }
}
Object.defineProperty(al, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32002
});
class cl extends Ei {
  constructor(e) {
    super(e, {
      code: cl.code,
      name: "TransactionRejectedRpcError",
      shortMessage: "Transaction creation failed."
    });
  }
}
Object.defineProperty(cl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32003
});
class ul extends Ei {
  constructor(e, { method: r } = {}) {
    super(e, {
      code: ul.code,
      name: "MethodNotSupportedRpcError",
      shortMessage: `Method${r ? ` "${r}"` : ""} is not implemented.`
    });
  }
}
Object.defineProperty(ul, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32004
});
class wu extends Ei {
  constructor(e) {
    super(e, {
      code: wu.code,
      name: "LimitExceededRpcError",
      shortMessage: "Request exceeds defined limit."
    });
  }
}
Object.defineProperty(wu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32005
});
class fl extends Ei {
  constructor(e) {
    super(e, {
      code: fl.code,
      name: "JsonRpcVersionUnsupportedError",
      shortMessage: "Version of JSON-RPC protocol is not supported."
    });
  }
}
Object.defineProperty(fl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32006
});
class au extends Ru {
  constructor(e) {
    super(e, {
      code: au.code,
      name: "UserRejectedRequestError",
      shortMessage: "User rejected the request."
    });
  }
}
Object.defineProperty(au, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4001
});
class ll extends Ru {
  constructor(e) {
    super(e, {
      code: ll.code,
      name: "UnauthorizedProviderError",
      shortMessage: "The requested method and/or account has not been authorized by the user."
    });
  }
}
Object.defineProperty(ll, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4100
});
class hl extends Ru {
  constructor(e, { method: r } = {}) {
    super(e, {
      code: hl.code,
      name: "UnsupportedProviderMethodError",
      shortMessage: `The Provider does not support the requested method${r ? ` " ${r}"` : ""}.`
    });
  }
}
Object.defineProperty(hl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4200
});
class dl extends Ru {
  constructor(e) {
    super(e, {
      code: dl.code,
      name: "ProviderDisconnectedError",
      shortMessage: "The Provider is disconnected from all chains."
    });
  }
}
Object.defineProperty(dl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4900
});
class pl extends Ru {
  constructor(e) {
    super(e, {
      code: pl.code,
      name: "ChainDisconnectedError",
      shortMessage: "The Provider is not connected to the requested chain."
    });
  }
}
Object.defineProperty(pl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4901
});
class gl extends Ru {
  constructor(e) {
    super(e, {
      code: gl.code,
      name: "SwitchChainError",
      shortMessage: "An error occurred when attempting to switch chain."
    });
  }
}
Object.defineProperty(gl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4902
});
class MO extends Ei {
  constructor(e) {
    super(e, {
      name: "UnknownRpcError",
      shortMessage: "An unknown RPC error occurred."
    });
  }
}
const IO = 3;
function CO(t, { abi: e, address: r, args: n, docsPath: i, functionName: s, sender: o }) {
  const { code: a, data: u, message: l, shortMessage: d } = t instanceof SO ? t : t instanceof yt ? t.walk((w) => "data" in w) || t.walk() : {}, p = t instanceof wv ? new EO({ functionName: s }) : [IO, cc.code].includes(a) && (u || l || d) ? new _O({
    abi: e,
    data: typeof u == "object" ? u.data : u,
    functionName: s,
    message: d ?? l
  }) : t;
  return new xO(p, {
    abi: e,
    args: n,
    contractAddress: r,
    docsPath: i,
    functionName: s,
    sender: o
  });
}
function TO(t) {
  const e = kl(`0x${t.substring(4)}`).substring(26);
  return $l(`0x${e}`);
}
async function RO({ hash: t, signature: e }) {
  const r = ma(t) ? t : qd(t), { secp256k1: n } = await import("./secp256k1-D3zK91Tb.js");
  return `0x${(() => {
    if (typeof e == "object" && "r" in e && "s" in e) {
      const { r: l, s: d, v: p, yParity: w } = e, P = Number(w ?? p), A = M2(P);
      return new n.Signature(Qf(l), Qf(d)).addRecoveryBit(A);
    }
    const o = ma(e) ? e : qd(e), a = vu(`0x${o.slice(130)}`), u = M2(a);
    return n.Signature.fromCompact(o.substring(2, 130)).addRecoveryBit(u);
  })().recoverPublicKey(r.substring(2)).toHex(!1)}`;
}
function M2(t) {
  if (t === 0 || t === 1)
    return t;
  if (t === 27)
    return 0;
  if (t === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}
async function DO({ hash: t, signature: e }) {
  return TO(await RO({ hash: t, signature: e }));
}
function OO(t, e = "hex") {
  const r = G5(t), n = Mv(new Uint8Array(r.length));
  return r.encode(n), e === "hex" ? wi(n.bytes) : n.bytes;
}
function G5(t) {
  return Array.isArray(t) ? NO(t.map((e) => G5(e))) : LO(t);
}
function NO(t) {
  const e = t.reduce((i, s) => i + s.length, 0), r = Y5(e);
  return {
    length: e <= 55 ? 1 + e : 1 + r + e,
    encode(i) {
      e <= 55 ? i.pushByte(192 + e) : (i.pushByte(247 + r), r === 1 ? i.pushUint8(e) : r === 2 ? i.pushUint16(e) : r === 3 ? i.pushUint24(e) : i.pushUint32(e));
      for (const { encode: s } of t)
        s(i);
    }
  };
}
function LO(t) {
  const e = typeof t == "string" ? No(t) : t, r = Y5(e.length);
  return {
    length: e.length === 1 && e[0] < 128 ? 1 : e.length <= 55 ? 1 + e.length : 1 + r + e.length,
    encode(i) {
      e.length === 1 && e[0] < 128 ? i.pushBytes(e) : e.length <= 55 ? (i.pushByte(128 + e.length), i.pushBytes(e)) : (i.pushByte(183 + r), r === 1 ? i.pushUint8(e.length) : r === 2 ? i.pushUint16(e.length) : r === 3 ? i.pushUint24(e.length) : i.pushUint32(e.length), i.pushBytes(e));
    }
  };
}
function Y5(t) {
  if (t < 2 ** 8)
    return 1;
  if (t < 2 ** 16)
    return 2;
  if (t < 2 ** 24)
    return 3;
  if (t < 2 ** 32)
    return 4;
  throw new yt("Length is too large.");
}
function kO(t) {
  const { chainId: e, contractAddress: r, nonce: n, to: i } = t, s = kl(T0([
    "0x05",
    OO([
      e ? Mr(e) : "0x",
      r,
      n ? Mr(n) : "0x"
    ])
  ]));
  return i === "bytes" ? No(s) : s;
}
async function J5(t) {
  const { authorization: e, signature: r } = t;
  return DO({
    hash: kO(e),
    signature: r ?? e
  });
}
class $O extends yt {
  constructor(e, { account: r, docsPath: n, chain: i, data: s, gas: o, gasPrice: a, maxFeePerGas: u, maxPriorityFeePerGas: l, nonce: d, to: p, value: w }) {
    var A;
    const P = R0({
      from: r == null ? void 0 : r.address,
      to: p,
      value: typeof w < "u" && `${W5(w)} ${((A = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : A.symbol) || "ETH"}`,
      data: s,
      gas: o,
      gasPrice: typeof a < "u" && `${_s(a)} gwei`,
      maxFeePerGas: typeof u < "u" && `${_s(u)} gwei`,
      maxPriorityFeePerGas: typeof l < "u" && `${_s(l)} gwei`,
      nonce: d
    });
    super(e.shortMessage, {
      cause: e,
      docsPath: n,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        P
      ].filter(Boolean),
      name: "EstimateGasExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = e;
  }
}
class Xc extends yt {
  constructor({ cause: e, message: r } = {}) {
    var i;
    const n = (i = r == null ? void 0 : r.replace("execution reverted: ", "")) == null ? void 0 : i.replace("execution reverted", "");
    super(`Execution reverted ${n ? `with reason: ${n}` : "for an unknown reason"}.`, {
      cause: e,
      name: "ExecutionRevertedError"
    });
  }
}
Object.defineProperty(Xc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3
});
Object.defineProperty(Xc, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class Kd extends yt {
  constructor({ cause: e, maxFeePerGas: r } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${r ? ` = ${_s(r)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: e,
      name: "FeeCapTooHighError"
    });
  }
}
Object.defineProperty(Kd, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class Qm extends yt {
  constructor({ cause: e, maxFeePerGas: r } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${r ? ` = ${_s(r)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause: e,
      name: "FeeCapTooLowError"
    });
  }
}
Object.defineProperty(Qm, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class e1 extends yt {
  constructor({ cause: e, nonce: r } = {}) {
    super(`Nonce provided for the transaction ${r ? `(${r}) ` : ""}is higher than the next one expected.`, { cause: e, name: "NonceTooHighError" });
  }
}
Object.defineProperty(e1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/
});
class t1 extends yt {
  constructor({ cause: e, nonce: r } = {}) {
    super([
      `Nonce provided for the transaction ${r ? `(${r}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join(`
`), { cause: e, name: "NonceTooLowError" });
  }
}
Object.defineProperty(t1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/
});
class r1 extends yt {
  constructor({ cause: e, nonce: r } = {}) {
    super(`Nonce provided for the transaction ${r ? `(${r}) ` : ""}exceeds the maximum allowed nonce.`, { cause: e, name: "NonceMaxValueError" });
  }
}
Object.defineProperty(r1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/
});
class n1 extends yt {
  constructor({ cause: e } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join(`
`), {
      cause: e,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ],
      name: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(n1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds|exceeds transaction sender account balance/
});
class i1 extends yt {
  constructor({ cause: e, gas: r } = {}) {
    super(`The amount of gas ${r ? `(${r}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause: e,
      name: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(i1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/
});
class s1 extends yt {
  constructor({ cause: e, gas: r } = {}) {
    super(`The amount of gas ${r ? `(${r}) ` : ""}provided for the transaction is too low.`, {
      cause: e,
      name: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(s1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/
});
class o1 extends yt {
  constructor({ cause: e }) {
    super("The transaction type is not supported for this chain.", {
      cause: e,
      name: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(o1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/
});
class Vd extends yt {
  constructor({ cause: e, maxPriorityFeePerGas: r, maxFeePerGas: n } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${r ? ` = ${_s(r)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${n ? ` = ${_s(n)} gwei` : ""}).`
    ].join(`
`), {
      cause: e,
      name: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(Vd, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class Iv extends yt {
  constructor({ cause: e }) {
    super(`An error occurred while executing: ${e == null ? void 0 : e.shortMessage}`, {
      cause: e,
      name: "UnknownNodeError"
    });
  }
}
function X5(t, e) {
  const r = (t.details || "").toLowerCase(), n = t instanceof yt ? t.walk((i) => (i == null ? void 0 : i.code) === Xc.code) : t;
  return n instanceof yt ? new Xc({
    cause: t,
    message: n.details
  }) : Xc.nodeMessage.test(r) ? new Xc({
    cause: t,
    message: t.details
  }) : Kd.nodeMessage.test(r) ? new Kd({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas
  }) : Qm.nodeMessage.test(r) ? new Qm({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas
  }) : e1.nodeMessage.test(r) ? new e1({ cause: t, nonce: e == null ? void 0 : e.nonce }) : t1.nodeMessage.test(r) ? new t1({ cause: t, nonce: e == null ? void 0 : e.nonce }) : r1.nodeMessage.test(r) ? new r1({ cause: t, nonce: e == null ? void 0 : e.nonce }) : n1.nodeMessage.test(r) ? new n1({ cause: t }) : i1.nodeMessage.test(r) ? new i1({ cause: t, gas: e == null ? void 0 : e.gas }) : s1.nodeMessage.test(r) ? new s1({ cause: t, gas: e == null ? void 0 : e.gas }) : o1.nodeMessage.test(r) ? new o1({ cause: t }) : Vd.nodeMessage.test(r) ? new Vd({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas,
    maxPriorityFeePerGas: e == null ? void 0 : e.maxPriorityFeePerGas
  }) : new Iv({
    cause: t
  });
}
function FO(t, { docsPath: e, ...r }) {
  const n = (() => {
    const i = X5(t, r);
    return i instanceof Iv ? t : i;
  })();
  return new $O(n, {
    docsPath: e,
    ...r
  });
}
function Z5(t, { format: e }) {
  if (!e)
    return {};
  const r = {};
  function n(s) {
    const o = Object.keys(s);
    for (const a of o)
      a in t && (r[a] = t[a]), s[a] && typeof s[a] == "object" && !Array.isArray(s[a]) && n(s[a]);
  }
  const i = e(t || {});
  return n(i), r;
}
const BO = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
function Cv(t) {
  const e = {};
  return typeof t.authorizationList < "u" && (e.authorizationList = UO(t.authorizationList)), typeof t.accessList < "u" && (e.accessList = t.accessList), typeof t.blobVersionedHashes < "u" && (e.blobVersionedHashes = t.blobVersionedHashes), typeof t.blobs < "u" && (typeof t.blobs[0] != "string" ? e.blobs = t.blobs.map((r) => wi(r)) : e.blobs = t.blobs), typeof t.data < "u" && (e.data = t.data), typeof t.from < "u" && (e.from = t.from), typeof t.gas < "u" && (e.gas = Mr(t.gas)), typeof t.gasPrice < "u" && (e.gasPrice = Mr(t.gasPrice)), typeof t.maxFeePerBlobGas < "u" && (e.maxFeePerBlobGas = Mr(t.maxFeePerBlobGas)), typeof t.maxFeePerGas < "u" && (e.maxFeePerGas = Mr(t.maxFeePerGas)), typeof t.maxPriorityFeePerGas < "u" && (e.maxPriorityFeePerGas = Mr(t.maxPriorityFeePerGas)), typeof t.nonce < "u" && (e.nonce = Mr(t.nonce)), typeof t.to < "u" && (e.to = t.to), typeof t.type < "u" && (e.type = BO[t.type]), typeof t.value < "u" && (e.value = Mr(t.value)), e;
}
function UO(t) {
  return t.map((e) => ({
    address: e.contractAddress,
    r: e.r,
    s: e.s,
    chainId: Mr(e.chainId),
    nonce: Mr(e.nonce),
    ...typeof e.yParity < "u" ? { yParity: Mr(e.yParity) } : {},
    ...typeof e.v < "u" && typeof e.yParity > "u" ? { v: Mr(e.v) } : {}
  }));
}
function I2(t) {
  if (!(!t || t.length === 0))
    return t.reduce((e, { slot: r, value: n }) => {
      if (r.length !== 66)
        throw new v2({
          size: r.length,
          targetSize: 66,
          type: "hex"
        });
      if (n.length !== 66)
        throw new v2({
          size: n.length,
          targetSize: 66,
          type: "hex"
        });
      return e[r] = n, e;
    }, {});
}
function jO(t) {
  const { balance: e, nonce: r, state: n, stateDiff: i, code: s } = t, o = {};
  if (s !== void 0 && (o.code = s), e !== void 0 && (o.balance = Mr(e)), r !== void 0 && (o.nonce = Mr(r)), n !== void 0 && (o.state = I2(n)), i !== void 0) {
    if (o.state)
      throw new mO();
    o.stateDiff = I2(i);
  }
  return o;
}
function qO(t) {
  if (!t)
    return;
  const e = {};
  for (const { address: r, ...n } of t) {
    if (!Lo(r, { strict: !1 }))
      throw new bu({ address: r });
    if (e[r])
      throw new gO({ address: r });
    e[r] = jO(n);
  }
  return e;
}
const zO = 2n ** 256n - 1n;
function D0(t) {
  const { account: e, gasPrice: r, maxFeePerGas: n, maxPriorityFeePerGas: i, to: s } = t, o = e ? jo(e) : void 0;
  if (o && !Lo(o.address))
    throw new bu({ address: o.address });
  if (s && !Lo(s))
    throw new bu({ address: s });
  if (typeof r < "u" && (typeof n < "u" || typeof i < "u"))
    throw new vO();
  if (n && n > zO)
    throw new Kd({ maxFeePerGas: n });
  if (i && n && i > n)
    throw new Vd({ maxFeePerGas: n, maxPriorityFeePerGas: i });
}
class HO extends yt {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError"
    });
  }
}
class Tv extends yt {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError"
    });
  }
}
class WO extends yt {
  constructor({ maxPriorityFeePerGas: e }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${_s(e)} gwei).`, { name: "MaxFeePerGasTooLowError" });
  }
}
class KO extends yt {
  constructor({ blockHash: e, blockNumber: r }) {
    let n = "Block";
    e && (n = `Block at hash "${e}"`), r && (n = `Block at number "${r}"`), super(`${n} could not be found.`, { name: "BlockNotFoundError" });
  }
}
const VO = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function GO(t) {
  const e = {
    ...t,
    blockHash: t.blockHash ? t.blockHash : null,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    chainId: t.chainId ? vu(t.chainId) : void 0,
    gas: t.gas ? BigInt(t.gas) : void 0,
    gasPrice: t.gasPrice ? BigInt(t.gasPrice) : void 0,
    maxFeePerBlobGas: t.maxFeePerBlobGas ? BigInt(t.maxFeePerBlobGas) : void 0,
    maxFeePerGas: t.maxFeePerGas ? BigInt(t.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: t.maxPriorityFeePerGas ? BigInt(t.maxPriorityFeePerGas) : void 0,
    nonce: t.nonce ? vu(t.nonce) : void 0,
    to: t.to ? t.to : null,
    transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
    type: t.type ? VO[t.type] : void 0,
    typeHex: t.type ? t.type : void 0,
    value: t.value ? BigInt(t.value) : void 0,
    v: t.v ? BigInt(t.v) : void 0
  };
  return t.authorizationList && (e.authorizationList = YO(t.authorizationList)), e.yParity = (() => {
    if (t.yParity)
      return Number(t.yParity);
    if (typeof e.v == "bigint") {
      if (e.v === 0n || e.v === 27n)
        return 0;
      if (e.v === 1n || e.v === 28n)
        return 1;
      if (e.v >= 35n)
        return e.v % 2n === 0n ? 1 : 0;
    }
  })(), e.type === "legacy" && (delete e.accessList, delete e.maxFeePerBlobGas, delete e.maxFeePerGas, delete e.maxPriorityFeePerGas, delete e.yParity), e.type === "eip2930" && (delete e.maxFeePerBlobGas, delete e.maxFeePerGas, delete e.maxPriorityFeePerGas), e.type === "eip1559" && delete e.maxFeePerBlobGas, e;
}
function YO(t) {
  return t.map((e) => ({
    contractAddress: e.address,
    chainId: Number(e.chainId),
    nonce: Number(e.nonce),
    r: e.r,
    s: e.s,
    yParity: Number(e.yParity)
  }));
}
function JO(t) {
  const e = (t.transactions ?? []).map((r) => typeof r == "string" ? r : GO(r));
  return {
    ...t,
    baseFeePerGas: t.baseFeePerGas ? BigInt(t.baseFeePerGas) : null,
    blobGasUsed: t.blobGasUsed ? BigInt(t.blobGasUsed) : void 0,
    difficulty: t.difficulty ? BigInt(t.difficulty) : void 0,
    excessBlobGas: t.excessBlobGas ? BigInt(t.excessBlobGas) : void 0,
    gasLimit: t.gasLimit ? BigInt(t.gasLimit) : void 0,
    gasUsed: t.gasUsed ? BigInt(t.gasUsed) : void 0,
    hash: t.hash ? t.hash : null,
    logsBloom: t.logsBloom ? t.logsBloom : null,
    nonce: t.nonce ? t.nonce : null,
    number: t.number ? BigInt(t.number) : null,
    size: t.size ? BigInt(t.size) : void 0,
    timestamp: t.timestamp ? BigInt(t.timestamp) : void 0,
    transactions: e,
    totalDifficulty: t.totalDifficulty ? BigInt(t.totalDifficulty) : null
  };
}
async function Gd(t, { blockHash: e, blockNumber: r, blockTag: n, includeTransactions: i } = {}) {
  var d, p, w;
  const s = n ?? "latest", o = i ?? !1, a = r !== void 0 ? Mr(r) : void 0;
  let u = null;
  if (e ? u = await t.request({
    method: "eth_getBlockByHash",
    params: [e, o]
  }, { dedupe: !0 }) : u = await t.request({
    method: "eth_getBlockByNumber",
    params: [a || s, o]
  }, { dedupe: !!a }), !u)
    throw new KO({ blockHash: e, blockNumber: r });
  return (((w = (p = (d = t.chain) == null ? void 0 : d.formatters) == null ? void 0 : p.block) == null ? void 0 : w.format) || JO)(u);
}
async function Q5(t) {
  const e = await t.request({
    method: "eth_gasPrice"
  });
  return BigInt(e);
}
async function XO(t, e) {
  var s, o;
  const { block: r, chain: n = t.chain, request: i } = e || {};
  try {
    const a = ((s = n == null ? void 0 : n.fees) == null ? void 0 : s.maxPriorityFeePerGas) ?? ((o = n == null ? void 0 : n.fees) == null ? void 0 : o.defaultPriorityFee);
    if (typeof a == "function") {
      const l = r || await vi(t, Gd, "getBlock")({}), d = await a({
        block: l,
        client: t,
        request: i
      });
      if (d === null)
        throw new Error();
      return d;
    }
    if (typeof a < "u")
      return a;
    const u = await t.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return Qf(u);
  } catch {
    const [a, u] = await Promise.all([
      r ? Promise.resolve(r) : vi(t, Gd, "getBlock")({}),
      vi(t, Q5, "getGasPrice")({})
    ]);
    if (typeof a.baseFeePerGas != "bigint")
      throw new Tv();
    const l = u - a.baseFeePerGas;
    return l < 0n ? 0n : l;
  }
}
async function C2(t, e) {
  var w, P;
  const { block: r, chain: n = t.chain, request: i, type: s = "eip1559" } = e || {}, o = await (async () => {
    var A, N;
    return typeof ((A = n == null ? void 0 : n.fees) == null ? void 0 : A.baseFeeMultiplier) == "function" ? n.fees.baseFeeMultiplier({
      block: r,
      client: t,
      request: i
    }) : ((N = n == null ? void 0 : n.fees) == null ? void 0 : N.baseFeeMultiplier) ?? 1.2;
  })();
  if (o < 1)
    throw new HO();
  const u = 10 ** (((w = o.toString().split(".")[1]) == null ? void 0 : w.length) ?? 0), l = (A) => A * BigInt(Math.ceil(o * u)) / BigInt(u), d = r || await vi(t, Gd, "getBlock")({});
  if (typeof ((P = n == null ? void 0 : n.fees) == null ? void 0 : P.estimateFeesPerGas) == "function") {
    const A = await n.fees.estimateFeesPerGas({
      block: r,
      client: t,
      multiply: l,
      request: i,
      type: s
    });
    if (A !== null)
      return A;
  }
  if (s === "eip1559") {
    if (typeof d.baseFeePerGas != "bigint")
      throw new Tv();
    const A = typeof (i == null ? void 0 : i.maxPriorityFeePerGas) == "bigint" ? i.maxPriorityFeePerGas : await XO(t, {
      block: d,
      chain: n,
      request: i
    }), N = l(d.baseFeePerGas);
    return {
      maxFeePerGas: (i == null ? void 0 : i.maxFeePerGas) ?? N + A,
      maxPriorityFeePerGas: A
    };
  }
  return {
    gasPrice: (i == null ? void 0 : i.gasPrice) ?? l(await vi(t, Q5, "getGasPrice")({}))
  };
}
async function ZO(t, { address: e, blockTag: r = "latest", blockNumber: n }) {
  const i = await t.request({
    method: "eth_getTransactionCount",
    params: [e, n ? Mr(n) : r]
  }, { dedupe: !!n });
  return vu(i);
}
function e4(t) {
  const { kzg: e } = t, r = t.to ?? (typeof t.blobs[0] == "string" ? "hex" : "bytes"), n = typeof t.blobs[0] == "string" ? t.blobs.map((s) => No(s)) : t.blobs, i = [];
  for (const s of n)
    i.push(Uint8Array.from(e.blobToKzgCommitment(s)));
  return r === "bytes" ? i : i.map((s) => wi(s));
}
function t4(t) {
  const { kzg: e } = t, r = t.to ?? (typeof t.blobs[0] == "string" ? "hex" : "bytes"), n = typeof t.blobs[0] == "string" ? t.blobs.map((o) => No(o)) : t.blobs, i = typeof t.commitments[0] == "string" ? t.commitments.map((o) => No(o)) : t.commitments, s = [];
  for (let o = 0; o < n.length; o++) {
    const a = n[o], u = i[o];
    s.push(Uint8Array.from(e.computeBlobKzgProof(a, u)));
  }
  return r === "bytes" ? s : s.map((o) => wi(o));
}
function QO(t, e, r, n) {
  if (typeof t.setBigUint64 == "function")
    return t.setBigUint64(e, r, n);
  const i = BigInt(32), s = BigInt(4294967295), o = Number(r >> i & s), a = Number(r & s), u = n ? 4 : 0, l = n ? 0 : 4;
  t.setUint32(e + u, o, n), t.setUint32(e + l, a, n);
}
const eN = (t, e, r) => t & e ^ ~t & r, tN = (t, e, r) => t & e ^ t & r ^ e & r;
class rN extends M5 {
  constructor(e, r, n, i) {
    super(), this.blockLen = e, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = Fg(this.buffer);
  }
  update(e) {
    Hd(this);
    const { view: r, buffer: n, blockLen: i } = this;
    e = I0(e);
    const s = e.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const u = Fg(e);
        for (; i <= s - o; o += i)
          this.process(u, o);
        continue;
      }
      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Hd(this), P5(e, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    r[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(n, 0), o = 0);
    for (let p = o; p < i; p++)
      r[p] = 0;
    QO(n, i - 8, BigInt(this.length * 8), s), this.process(n, 0);
    const a = Fg(e), u = this.outputLen;
    if (u % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = u / 4, d = this.get();
    if (l > d.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let p = 0; p < l; p++)
      a.setUint32(4 * p, d[p], s);
  }
  digest() {
    const { buffer: e, outputLen: r } = this;
    this.digestInto(e);
    const n = e.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: s, destroyed: o, pos: a } = this;
    return e.length = i, e.pos = a, e.finished = s, e.destroyed = o, i % r && e.buffer.set(n), e;
  }
}
const nN = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Zo = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Qo = /* @__PURE__ */ new Uint32Array(64);
let iN = class extends rN {
  constructor() {
    super(64, 32, 8, !1), this.A = Zo[0] | 0, this.B = Zo[1] | 0, this.C = Zo[2] | 0, this.D = Zo[3] | 0, this.E = Zo[4] | 0, this.F = Zo[5] | 0, this.G = Zo[6] | 0, this.H = Zo[7] | 0;
  }
  get() {
    const { A: e, B: r, C: n, D: i, E: s, F: o, G: a, H: u } = this;
    return [e, r, n, i, s, o, a, u];
  }
  // prettier-ignore
  set(e, r, n, i, s, o, a, u) {
    this.A = e | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = u | 0;
  }
  process(e, r) {
    for (let p = 0; p < 16; p++, r += 4)
      Qo[p] = e.getUint32(r, !1);
    for (let p = 16; p < 64; p++) {
      const w = Qo[p - 15], P = Qo[p - 2], A = Os(w, 7) ^ Os(w, 18) ^ w >>> 3, N = Os(P, 17) ^ Os(P, 19) ^ P >>> 10;
      Qo[p] = N + Qo[p - 7] + A + Qo[p - 16] | 0;
    }
    let { A: n, B: i, C: s, D: o, E: a, F: u, G: l, H: d } = this;
    for (let p = 0; p < 64; p++) {
      const w = Os(a, 6) ^ Os(a, 11) ^ Os(a, 25), P = d + w + eN(a, u, l) + nN[p] + Qo[p] | 0, N = (Os(n, 2) ^ Os(n, 13) ^ Os(n, 22)) + tN(n, i, s) | 0;
      d = l, l = u, u = a, a = o + P | 0, o = s, s = i, i = n, n = P + N | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, l = l + this.G | 0, d = d + this.H | 0, this.set(n, i, s, o, a, u, l, d);
  }
  roundClean() {
    Qo.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const r4 = /* @__PURE__ */ I5(() => new iN());
function sN(t, e) {
  return r4(ma(t, { strict: !1 }) ? _v(t) : t);
}
function oN(t) {
  const { commitment: e, version: r = 1 } = t, n = t.to ?? (typeof e == "string" ? "hex" : "bytes"), i = sN(e);
  return i.set([r], 0), n === "bytes" ? i : wi(i);
}
function aN(t) {
  const { commitments: e, version: r } = t, n = t.to ?? (typeof e[0] == "string" ? "hex" : "bytes"), i = [];
  for (const s of e)
    i.push(oN({
      commitment: s,
      to: n,
      version: r
    }));
  return i;
}
const T2 = 6, n4 = 32, Rv = 4096, i4 = n4 * Rv, R2 = i4 * T2 - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * Rv * T2;
class cN extends yt {
  constructor({ maxSize: e, size: r }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${e} bytes`, `Given: ${r} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
}
class uN extends yt {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}
function fN(t) {
  const e = t.to ?? (typeof t.data == "string" ? "hex" : "bytes"), r = typeof t.data == "string" ? No(t.data) : t.data, n = An(r);
  if (!n)
    throw new uN();
  if (n > R2)
    throw new cN({
      maxSize: R2,
      size: n
    });
  const i = [];
  let s = !0, o = 0;
  for (; s; ) {
    const a = Mv(new Uint8Array(i4));
    let u = 0;
    for (; u < Rv; ) {
      const l = r.slice(o, o + (n4 - 1));
      if (a.pushByte(0), a.pushBytes(l), l.length < 31) {
        a.pushByte(128), s = !1;
        break;
      }
      u++, o += 31;
    }
    i.push(a);
  }
  return e === "bytes" ? i.map((a) => a.bytes) : i.map((a) => wi(a.bytes));
}
function lN(t) {
  const { data: e, kzg: r, to: n } = t, i = t.blobs ?? fN({ data: e, to: n }), s = t.commitments ?? e4({ blobs: i, kzg: r, to: n }), o = t.proofs ?? t4({ blobs: i, commitments: s, kzg: r, to: n }), a = [];
  for (let u = 0; u < i.length; u++)
    a.push({
      blob: i[u],
      commitment: s[u],
      proof: o[u]
    });
  return a;
}
function hN(t) {
  if (t.type)
    return t.type;
  if (typeof t.authorizationList < "u")
    return "eip7702";
  if (typeof t.blobs < "u" || typeof t.blobVersionedHashes < "u" || typeof t.maxFeePerBlobGas < "u" || typeof t.sidecars < "u")
    return "eip4844";
  if (typeof t.maxFeePerGas < "u" || typeof t.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof t.gasPrice < "u")
    return typeof t.accessList < "u" ? "eip2930" : "legacy";
  throw new bO({ transaction: t });
}
async function O0(t) {
  const e = await t.request({
    method: "eth_chainId"
  }, { dedupe: !0 });
  return vu(e);
}
const s4 = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];
async function Dv(t, e) {
  const { account: r = t.account, blobs: n, chain: i, gas: s, kzg: o, nonce: a, nonceManager: u, parameters: l = s4, type: d } = e, p = r && jo(r), w = { ...e, ...p ? { from: p == null ? void 0 : p.address } : {} };
  let P;
  async function A() {
    return P || (P = await vi(t, Gd, "getBlock")({ blockTag: "latest" }), P);
  }
  let N;
  async function L() {
    return N || (i ? i.id : typeof e.chainId < "u" ? e.chainId : (N = await vi(t, O0, "getChainId")({}), N));
  }
  if ((l.includes("blobVersionedHashes") || l.includes("sidecars")) && n && o) {
    const F = e4({ blobs: n, kzg: o });
    if (l.includes("blobVersionedHashes")) {
      const $ = aN({
        commitments: F,
        to: "hex"
      });
      w.blobVersionedHashes = $;
    }
    if (l.includes("sidecars")) {
      const $ = t4({ blobs: n, commitments: F, kzg: o }), K = lN({
        blobs: n,
        commitments: F,
        proofs: $,
        to: "hex"
      });
      w.sidecars = K;
    }
  }
  if (l.includes("chainId") && (w.chainId = await L()), l.includes("nonce") && typeof a > "u" && p)
    if (u) {
      const F = await L();
      w.nonce = await u.consume({
        address: p.address,
        chainId: F,
        client: t
      });
    } else
      w.nonce = await vi(t, ZO, "getTransactionCount")({
        address: p.address,
        blockTag: "pending"
      });
  if ((l.includes("fees") || l.includes("type")) && typeof d > "u")
    try {
      w.type = hN(w);
    } catch {
      const F = await A();
      w.type = typeof (F == null ? void 0 : F.baseFeePerGas) == "bigint" ? "eip1559" : "legacy";
    }
  if (l.includes("fees"))
    if (w.type !== "legacy" && w.type !== "eip2930") {
      if (typeof w.maxFeePerGas > "u" || typeof w.maxPriorityFeePerGas > "u") {
        const F = await A(), { maxFeePerGas: $, maxPriorityFeePerGas: K } = await C2(t, {
          block: F,
          chain: i,
          request: w
        });
        if (typeof e.maxPriorityFeePerGas > "u" && e.maxFeePerGas && e.maxFeePerGas < K)
          throw new WO({
            maxPriorityFeePerGas: K
          });
        w.maxPriorityFeePerGas = K, w.maxFeePerGas = $;
      }
    } else {
      if (typeof e.maxFeePerGas < "u" || typeof e.maxPriorityFeePerGas < "u")
        throw new Tv();
      const F = await A(), { gasPrice: $ } = await C2(t, {
        block: F,
        chain: i,
        request: w,
        type: "legacy"
      });
      w.gasPrice = $;
    }
  return l.includes("gas") && typeof s > "u" && (w.gas = await vi(t, pN, "estimateGas")({
    ...w,
    account: p && { address: p.address, type: "json-rpc" }
  })), D0(w), delete w.parameters, w;
}
async function dN(t, { address: e, blockNumber: r, blockTag: n = "latest" }) {
  const i = r ? Mr(r) : void 0, s = await t.request({
    method: "eth_getBalance",
    params: [e, i || n]
  });
  return BigInt(s);
}
async function pN(t, e) {
  var i, s, o;
  const { account: r = t.account } = e, n = r ? jo(r) : void 0;
  try {
    let f = function(b) {
      const { block: x, request: _, rpcStateOverride: E } = b;
      return t.request({
        method: "eth_estimateGas",
        params: E ? [_, x ?? "latest", E] : x ? [_, x] : [_]
      });
    };
    const { accessList: a, authorizationList: u, blobs: l, blobVersionedHashes: d, blockNumber: p, blockTag: w, data: P, gas: A, gasPrice: N, maxFeePerBlobGas: L, maxFeePerGas: F, maxPriorityFeePerGas: $, nonce: K, value: H, stateOverride: V, ...te } = await Dv(t, {
      ...e,
      parameters: (
        // Some RPC Providers do not compute versioned hashes from blobs. We will need
        // to compute them.
        (n == null ? void 0 : n.type) === "local" ? void 0 : ["blobVersionedHashes"]
      )
    }), W = (p ? Mr(p) : void 0) || w, pe = qO(V), Ee = await (async () => {
      if (te.to)
        return te.to;
      if (u && u.length > 0)
        return await J5({
          authorization: u[0]
        }).catch(() => {
          throw new yt("`to` is required. Could not infer from `authorizationList`");
        });
    })();
    D0(e);
    const Y = (o = (s = (i = t.chain) == null ? void 0 : i.formatters) == null ? void 0 : s.transactionRequest) == null ? void 0 : o.format, m = (Y || Cv)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...Z5(te, { format: Y }),
      from: n == null ? void 0 : n.address,
      accessList: a,
      authorizationList: u,
      blobs: l,
      blobVersionedHashes: d,
      data: P,
      gas: A,
      gasPrice: N,
      maxFeePerBlobGas: L,
      maxFeePerGas: F,
      maxPriorityFeePerGas: $,
      nonce: K,
      to: Ee,
      value: H
    });
    let g = BigInt(await f({ block: W, request: m, rpcStateOverride: pe }));
    if (u) {
      const b = await dN(t, { address: m.from }), x = await Promise.all(u.map(async (_) => {
        const { contractAddress: E } = _, v = await f({
          block: W,
          request: {
            authorizationList: void 0,
            data: P,
            from: n == null ? void 0 : n.address,
            to: E,
            value: Mr(b)
          },
          rpcStateOverride: pe
        }).catch(() => 100000n);
        return 2n * BigInt(v);
      }));
      g += x.reduce((_, E) => _ + E, 0n);
    }
    return g;
  } catch (a) {
    throw FO(a, {
      ...e,
      account: n,
      chain: t.chain
    });
  }
}
class gN extends yt {
  constructor({ chain: e, currentChainId: r }) {
    super(`The current chain of the wallet (id: ${r}) does not match the target chain for the transaction (id: ${e.id}  ${e.name}).`, {
      metaMessages: [
        `Current Chain ID:  ${r}`,
        `Expected Chain ID: ${e.id}  ${e.name}`
      ],
      name: "ChainMismatchError"
    });
  }
}
class mN extends yt {
  constructor() {
    super([
      "No chain was provided to the request.",
      "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
    ].join(`
`), {
      name: "ChainNotFoundError"
    });
  }
}
const jg = "/docs/contract/encodeDeployData";
function vN(t) {
  const { abi: e, args: r, bytecode: n } = t;
  if (!r || r.length === 0)
    return n;
  const i = e.find((o) => "type" in o && o.type === "constructor");
  if (!i)
    throw new LR({ docsPath: jg });
  if (!("inputs" in i))
    throw new g2({ docsPath: jg });
  if (!i.inputs || i.inputs.length === 0)
    throw new g2({ docsPath: jg });
  const s = U5(i.inputs, r);
  return T0([n, s]);
}
async function bN(t) {
  return new Promise((e) => setTimeout(e, t));
}
class Fl extends yt {
  constructor({ docsPath: e } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join(`
`), {
      docsPath: e,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
}
class qg extends yt {
  constructor({ docsPath: e, metaMessages: r, type: n }) {
    super(`Account type "${n}" is not supported.`, {
      docsPath: e,
      metaMessages: r,
      name: "AccountTypeNotSupportedError"
    });
  }
}
function o4({ chain: t, currentChainId: e }) {
  if (!t)
    throw new mN();
  if (e !== t.id)
    throw new gN({ chain: t, currentChainId: e });
}
function yN(t, { docsPath: e, ...r }) {
  const n = (() => {
    const i = X5(t, r);
    return i instanceof Iv ? t : i;
  })();
  return new yO(n, {
    docsPath: e,
    ...r
  });
}
async function a4(t, { serializedTransaction: e }) {
  return t.request({
    method: "eth_sendRawTransaction",
    params: [e]
  }, { retryCount: 0 });
}
const zg = new C0(128);
async function Ov(t, e) {
  var F, $, K, H;
  const { account: r = t.account, chain: n = t.chain, accessList: i, authorizationList: s, blobs: o, data: a, gas: u, gasPrice: l, maxFeePerBlobGas: d, maxFeePerGas: p, maxPriorityFeePerGas: w, nonce: P, value: A, ...N } = e;
  if (typeof r > "u")
    throw new Fl({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const L = r ? jo(r) : null;
  try {
    D0(e);
    const V = await (async () => {
      if (e.to)
        return e.to;
      if (s && s.length > 0)
        return await J5({
          authorization: s[0]
        }).catch(() => {
          throw new yt("`to` is required. Could not infer from `authorizationList`.");
        });
    })();
    if ((L == null ? void 0 : L.type) === "json-rpc" || L === null) {
      let te;
      n !== null && (te = await vi(t, O0, "getChainId")({}), o4({
        currentChainId: te,
        chain: n
      }));
      const R = (K = ($ = (F = t.chain) == null ? void 0 : F.formatters) == null ? void 0 : $.transactionRequest) == null ? void 0 : K.format, pe = (R || Cv)({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...Z5(N, { format: R }),
        accessList: i,
        authorizationList: s,
        blobs: o,
        chainId: te,
        data: a,
        from: L == null ? void 0 : L.address,
        gas: u,
        gasPrice: l,
        maxFeePerBlobGas: d,
        maxFeePerGas: p,
        maxPriorityFeePerGas: w,
        nonce: P,
        to: V,
        value: A
      }), Ee = zg.get(t.uid), Y = Ee ? "wallet_sendTransaction" : "eth_sendTransaction";
      try {
        return await t.request({
          method: Y,
          params: [pe]
        }, { retryCount: 0 });
      } catch (S) {
        if (Ee === !1)
          throw S;
        const m = S;
        if (m.name === "InvalidInputRpcError" || m.name === "InvalidParamsRpcError" || m.name === "MethodNotFoundRpcError" || m.name === "MethodNotSupportedRpcError")
          return await t.request({
            method: "wallet_sendTransaction",
            params: [pe]
          }, { retryCount: 0 }).then((f) => (zg.set(t.uid, !0), f)).catch((f) => {
            const g = f;
            throw g.name === "MethodNotFoundRpcError" || g.name === "MethodNotSupportedRpcError" ? (zg.set(t.uid, !1), m) : g;
          });
        throw m;
      }
    }
    if ((L == null ? void 0 : L.type) === "local") {
      const te = await vi(t, Dv, "prepareTransactionRequest")({
        account: L,
        accessList: i,
        authorizationList: s,
        blobs: o,
        chain: n,
        data: a,
        gas: u,
        gasPrice: l,
        maxFeePerBlobGas: d,
        maxFeePerGas: p,
        maxPriorityFeePerGas: w,
        nonce: P,
        nonceManager: L.nonceManager,
        parameters: [...s4, "sidecars"],
        value: A,
        ...N,
        to: V
      }), R = (H = n == null ? void 0 : n.serializers) == null ? void 0 : H.transaction, W = await L.signTransaction(te, {
        serializer: R
      });
      return await vi(t, a4, "sendRawTransaction")({
        serializedTransaction: W
      });
    }
    throw (L == null ? void 0 : L.type) === "smart" ? new qg({
      metaMessages: [
        "Consider using the `sendUserOperation` Action instead."
      ],
      docsPath: "/docs/actions/bundler/sendUserOperation",
      type: "smart"
    }) : new qg({
      docsPath: "/docs/actions/wallet/sendTransaction",
      type: L == null ? void 0 : L.type
    });
  } catch (V) {
    throw V instanceof qg ? V : yN(V, {
      ...e,
      account: L,
      chain: e.chain || void 0
    });
  }
}
async function wN(t, e) {
  const { abi: r, account: n = t.account, address: i, args: s, dataSuffix: o, functionName: a, ...u } = e;
  if (typeof n > "u")
    throw new Fl({
      docsPath: "/docs/contract/writeContract"
    });
  const l = n ? jo(n) : null, d = GD({
    abi: r,
    args: s,
    functionName: a
  });
  try {
    return await vi(t, Ov, "sendTransaction")({
      data: `${d}${o ? o.replace("0x", "") : ""}`,
      to: i,
      account: l,
      ...u
    });
  } catch (p) {
    throw CO(p, {
      abi: r,
      address: i,
      args: s,
      docsPath: "/docs/contract/writeContract",
      functionName: a,
      sender: l == null ? void 0 : l.address
    });
  }
}
async function xN(t, { chain: e }) {
  const { id: r, name: n, nativeCurrency: i, rpcUrls: s, blockExplorers: o } = e;
  await t.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: Mr(r),
        chainName: n,
        nativeCurrency: i,
        rpcUrls: s.default.http,
        blockExplorerUrls: o ? Object.values(o).map(({ url: a }) => a) : void 0
      }
    ]
  }, { dedupe: !0, retryCount: 0 });
}
const a1 = 256;
let rd = a1, nd;
function c4(t = 11) {
  if (!nd || rd + t > a1 * 2) {
    nd = "", rd = 0;
    for (let e = 0; e < a1; e++)
      nd += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return nd.substring(rd, rd++ + t);
}
function _N(t) {
  const { batch: e, cacheTime: r = t.pollingInterval ?? 4e3, ccipRead: n, key: i = "base", name: s = "Base Client", pollingInterval: o = 4e3, type: a = "base" } = t, u = t.chain, l = t.account ? jo(t.account) : void 0, { config: d, request: p, value: w } = t.transport({
    chain: u,
    pollingInterval: o
  }), P = { ...d, ...w }, A = {
    account: l,
    batch: e,
    cacheTime: r,
    ccipRead: n,
    chain: u,
    key: i,
    name: s,
    pollingInterval: o,
    request: p,
    transport: P,
    type: a,
    uid: c4()
  };
  function N(L) {
    return (F) => {
      const $ = F(L);
      for (const H in A)
        delete $[H];
      const K = { ...L, ...$ };
      return Object.assign(K, { extend: N(K) });
    };
  }
  return Object.assign(A, { extend: N(A) });
}
const id = /* @__PURE__ */ new C0(8192);
function EN(t, { enabled: e = !0, id: r }) {
  if (!e || !r)
    return t();
  if (id.get(r))
    return id.get(r);
  const n = t().finally(() => id.delete(r));
  return id.set(r, n), n;
}
function SN(t, { delay: e = 100, retryCount: r = 2, shouldRetry: n = () => !0 } = {}) {
  return new Promise((i, s) => {
    const o = async ({ count: a = 0 } = {}) => {
      const u = async ({ error: l }) => {
        const d = typeof e == "function" ? e({ count: a, error: l }) : e;
        d && await bN(d), o({ count: a + 1 });
      };
      try {
        const l = await t();
        i(l);
      } catch (l) {
        if (a < r && await n({ count: a, error: l }))
          return u({ error: l });
        s(l);
      }
    };
    o();
  });
}
function AN(t, e = {}) {
  return async (r, n = {}) => {
    const { dedupe: i = !1, retryDelay: s = 150, retryCount: o = 3, uid: a } = {
      ...e,
      ...n
    }, u = i ? kl(M0(`${a}.${Tu(r)}`)) : void 0;
    return EN(() => SN(async () => {
      try {
        return await t(r);
      } catch (l) {
        const d = l;
        switch (d.code) {
          case tl.code:
            throw new tl(d);
          case rl.code:
            throw new rl(d);
          case nl.code:
            throw new nl(d, { method: r.method });
          case il.code:
            throw new il(d);
          case cc.code:
            throw new cc(d);
          case sl.code:
            throw new sl(d);
          case ol.code:
            throw new ol(d);
          case al.code:
            throw new al(d);
          case cl.code:
            throw new cl(d);
          case ul.code:
            throw new ul(d, {
              method: r.method
            });
          case wu.code:
            throw new wu(d);
          case fl.code:
            throw new fl(d);
          case au.code:
            throw new au(d);
          case ll.code:
            throw new ll(d);
          case hl.code:
            throw new hl(d);
          case dl.code:
            throw new dl(d);
          case pl.code:
            throw new pl(d);
          case gl.code:
            throw new gl(d);
          case 5e3:
            throw new au(d);
          default:
            throw l instanceof yt ? l : new MO(d);
        }
      }
    }, {
      delay: ({ count: l, error: d }) => {
        var p;
        if (d && d instanceof V5) {
          const w = (p = d == null ? void 0 : d.headers) == null ? void 0 : p.get("Retry-After");
          if (w != null && w.match(/\d/))
            return Number.parseInt(w) * 1e3;
        }
        return ~~(1 << l) * s;
      },
      retryCount: o,
      shouldRetry: ({ error: l }) => PN(l)
    }), { enabled: i, id: u });
  };
}
function PN(t) {
  return "code" in t && typeof t.code == "number" ? t.code === -1 || t.code === wu.code || t.code === cc.code : t instanceof V5 && t.status ? t.status === 403 || t.status === 408 || t.status === 413 || t.status === 429 || t.status === 500 || t.status === 502 || t.status === 503 || t.status === 504 : !0;
}
function MN({ key: t, name: e, request: r, retryCount: n = 3, retryDelay: i = 150, timeout: s, type: o }, a) {
  const u = c4();
  return {
    config: {
      key: t,
      name: e,
      request: r,
      retryCount: n,
      retryDelay: i,
      timeout: s,
      type: o
    },
    request: AN(r, { retryCount: n, retryDelay: i, uid: u }),
    value: a
  };
}
function IN(t, e = {}) {
  const { key: r = "custom", name: n = "Custom Provider", retryDelay: i } = e;
  return ({ retryCount: s }) => MN({
    key: r,
    name: n,
    request: t.request.bind(t),
    retryCount: e.retryCount ?? s,
    retryDelay: i,
    type: "custom"
  });
}
const CN = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, TN = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
class RN extends yt {
  constructor({ domain: e }) {
    super(`Invalid domain "${Tu(e)}".`, {
      metaMessages: ["Must be a valid EIP-712 domain."]
    });
  }
}
class DN extends yt {
  constructor({ primaryType: e, types: r }) {
    super(`Invalid primary type \`${e}\` must be one of \`${JSON.stringify(Object.keys(r))}\`.`, {
      docsPath: "/api/glossary/Errors#typeddatainvalidprimarytypeerror",
      metaMessages: ["Check that the primary type is a key in `types`."]
    });
  }
}
class ON extends yt {
  constructor({ type: e }) {
    super(`Struct type "${e}" is invalid.`, {
      metaMessages: ["Struct type must not be a Solidity type."],
      name: "InvalidStructTypeError"
    });
  }
}
function NN(t) {
  const { domain: e, message: r, primaryType: n, types: i } = t, s = (u, l) => {
    const d = { ...l };
    for (const p of u) {
      const { name: w, type: P } = p;
      P === "address" && (d[w] = d[w].toLowerCase());
    }
    return d;
  }, o = i.EIP712Domain ? e ? s(i.EIP712Domain, e) : {} : {}, a = (() => {
    if (n !== "EIP712Domain")
      return s(i[n], r);
  })();
  return Tu({ domain: o, message: a, primaryType: n, types: i });
}
function LN(t) {
  const { domain: e, message: r, primaryType: n, types: i } = t, s = (o, a) => {
    for (const u of o) {
      const { name: l, type: d } = u, p = a[l], w = d.match(TN);
      if (w && (typeof p == "number" || typeof p == "bigint")) {
        const [N, L, F] = w;
        Mr(p, {
          signed: L === "int",
          size: Number.parseInt(F) / 8
        });
      }
      if (d === "address" && typeof p == "string" && !Lo(p))
        throw new bu({ address: p });
      const P = d.match(CN);
      if (P) {
        const [N, L] = P;
        if (L && An(p) !== Number.parseInt(L))
          throw new jR({
            expectedSize: Number.parseInt(L),
            givenSize: An(p)
          });
      }
      const A = i[d];
      A && ($N(d), s(A, p));
    }
  };
  if (i.EIP712Domain && e) {
    if (typeof e != "object")
      throw new RN({ domain: e });
    s(i.EIP712Domain, e);
  }
  if (n !== "EIP712Domain")
    if (i[n])
      s(i[n], r);
    else
      throw new DN({ primaryType: n, types: i });
}
function kN({ domain: t }) {
  return [
    typeof (t == null ? void 0 : t.name) == "string" && { name: "name", type: "string" },
    (t == null ? void 0 : t.version) && { name: "version", type: "string" },
    typeof (t == null ? void 0 : t.chainId) == "number" && {
      name: "chainId",
      type: "uint256"
    },
    (t == null ? void 0 : t.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (t == null ? void 0 : t.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
function $N(t) {
  if (t === "address" || t === "bool" || t === "string" || t.startsWith("bytes") || t.startsWith("uint") || t.startsWith("int"))
    throw new ON({ type: t });
}
function FN(t, e) {
  const { abi: r, args: n, bytecode: i, ...s } = e, o = vN({ abi: r, args: n, bytecode: i });
  return Ov(t, {
    ...s,
    data: o
  });
}
async function BN(t) {
  var r;
  return ((r = t.account) == null ? void 0 : r.type) === "local" ? [t.account.address] : (await t.request({ method: "eth_accounts" }, { dedupe: !0 })).map((n) => $l(n));
}
async function UN(t) {
  return await t.request({ method: "wallet_getPermissions" }, { dedupe: !0 });
}
async function jN(t) {
  return (await t.request({ method: "eth_requestAccounts" }, { dedupe: !0, retryCount: 0 })).map((r) => k5(r));
}
async function qN(t, e) {
  return t.request({
    method: "wallet_requestPermissions",
    params: [e]
  }, { retryCount: 0 });
}
async function zN(t, { account: e = t.account, message: r }) {
  if (!e)
    throw new Fl({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const n = jo(e);
  if (n.signMessage)
    return n.signMessage({ message: r });
  const i = typeof r == "string" ? M0(r) : r.raw instanceof Uint8Array ? qd(r.raw) : r.raw;
  return t.request({
    method: "personal_sign",
    params: [i, n.address]
  }, { retryCount: 0 });
}
async function HN(t, e) {
  var l, d, p, w;
  const { account: r = t.account, chain: n = t.chain, ...i } = e;
  if (!r)
    throw new Fl({
      docsPath: "/docs/actions/wallet/signTransaction"
    });
  const s = jo(r);
  D0({
    account: s,
    ...e
  });
  const o = await vi(t, O0, "getChainId")({});
  n !== null && o4({
    currentChainId: o,
    chain: n
  });
  const a = (n == null ? void 0 : n.formatters) || ((l = t.chain) == null ? void 0 : l.formatters), u = ((d = a == null ? void 0 : a.transactionRequest) == null ? void 0 : d.format) || Cv;
  return s.signTransaction ? s.signTransaction({
    ...i,
    chainId: o
  }, { serializer: (w = (p = t.chain) == null ? void 0 : p.serializers) == null ? void 0 : w.transaction }) : await t.request({
    method: "eth_signTransaction",
    params: [
      {
        ...u(i),
        chainId: Mr(o),
        from: s.address
      }
    ]
  }, { retryCount: 0 });
}
async function WN(t, e) {
  const { account: r = t.account, domain: n, message: i, primaryType: s } = e;
  if (!r)
    throw new Fl({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const o = jo(r), a = {
    EIP712Domain: kN({ domain: n }),
    ...e.types
  };
  if (LN({ domain: n, message: i, primaryType: s, types: a }), o.signTypedData)
    return o.signTypedData({ domain: n, message: i, primaryType: s, types: a });
  const u = NN({ domain: n, message: i, primaryType: s, types: a });
  return t.request({
    method: "eth_signTypedData_v4",
    params: [o.address, u]
  }, { retryCount: 0 });
}
async function KN(t, { id: e }) {
  await t.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: Mr(e)
      }
    ]
  }, { retryCount: 0 });
}
async function VN(t, e) {
  return await t.request({
    method: "wallet_watchAsset",
    params: e
  }, { retryCount: 0 });
}
function GN(t) {
  return {
    addChain: (e) => xN(t, e),
    deployContract: (e) => FN(t, e),
    getAddresses: () => BN(t),
    getChainId: () => O0(t),
    getPermissions: () => UN(t),
    prepareTransactionRequest: (e) => Dv(t, e),
    requestAddresses: () => jN(t),
    requestPermissions: (e) => qN(t, e),
    sendRawTransaction: (e) => a4(t, e),
    sendTransaction: (e) => Ov(t, e),
    signMessage: (e) => zN(t, e),
    signTransaction: (e) => HN(t, e),
    signTypedData: (e) => WN(t, e),
    switchChain: (e) => KN(t, e),
    watchAsset: (e) => VN(t, e),
    writeContract: (e) => wN(t, e)
  };
}
function YN(t) {
  const { key: e = "wallet", name: r = "Wallet Client", transport: n } = t;
  return _N({
    ...t,
    key: e,
    name: r,
    transport: n,
    type: "walletClient"
  }).extend(GN);
}
class ml {
  constructor(e) {
    Rs(this, "_key");
    Rs(this, "_config", null);
    Rs(this, "_provider", null);
    Rs(this, "_connected", !1);
    Rs(this, "_address", null);
    Rs(this, "_fatured", !1);
    Rs(this, "_installed", !1);
    Rs(this, "lastUsed", !1);
    var r;
    if ("name" in e && "image" in e)
      this._key = e.name, this._config = e, this._fatured = e.featured;
    else if ("session" in e) {
      if (!e.session) throw new Error("session is null");
      this._key = (r = e.session) == null ? void 0 : r.peer.metadata.name, this._provider = e, this._config = {
        name: e.session.peer.metadata.name,
        image: e.session.peer.metadata.icons[0],
        featured: !1
      };
    } else if ("info" in e)
      console.log(e.info, "installed"), this._key = e.info.name, this._provider = e.provider, this._installed = !0, this._config = {
        name: e.info.name,
        image: e.info.icon,
        featured: !1
      }, this.testConnect();
    else
      throw new Error("unknown params");
  }
  get address() {
    return this._address;
  }
  get connected() {
    return this._connected;
  }
  get featured() {
    return this._fatured;
  }
  get key() {
    return this._key;
  }
  get installed() {
    return this._installed;
  }
  get client() {
    return this._provider ? YN({ transport: IN(this._provider) }) : null;
  }
  get config() {
    return this._config;
  }
  static fromWalletConfig(e) {
    return new ml(e);
  }
  EIP6963Detected(e) {
    this._provider = e.provider, this._installed = !0, this._provider.on("disconnect", this.disconnect), this._provider.on("accountsChanged", (r) => {
      this._address = r[0], this._connected = !0;
    }), this.testConnect();
  }
  setUniversalProvider(e) {
    this._provider = e, this.testConnect();
  }
  async testConnect() {
    var r;
    const e = await ((r = this.client) == null ? void 0 : r.getAddresses());
    e && e.length > 0 ? (this._address = e[0], this._connected = !0) : (this._address = null, this._connected = !1);
  }
  async connect() {
    var r;
    const e = await ((r = this.client) == null ? void 0 : r.request({ method: "eth_requestAccounts", params: void 0 }));
    if (!e) throw new Error("connect failed");
    return e;
  }
  async getAddress() {
    var r;
    const e = await ((r = this.client) == null ? void 0 : r.getAddresses());
    if (!e) throw new Error("get address failed");
    return e[0];
  }
  async getChain() {
    var r;
    const e = await ((r = this.client) == null ? void 0 : r.getChainId());
    if (!e) throw new Error("get chain failed");
    return e;
  }
  async signMessage(e, r) {
    var i;
    return await ((i = this.client) == null ? void 0 : i.signMessage({ message: e, account: r }));
  }
  async disconnect() {
    this._provider && "session" in this._provider && await this._provider.disconnect(), this._connected = !1, this._address = null;
  }
}
var Nv = { exports: {} }, cu = typeof Reflect == "object" ? Reflect : null, D2 = cu && typeof cu.apply == "function" ? cu.apply : function(e, r, n) {
  return Function.prototype.apply.call(e, r, n);
}, wd;
cu && typeof cu.ownKeys == "function" ? wd = cu.ownKeys : Object.getOwnPropertySymbols ? wd = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : wd = function(e) {
  return Object.getOwnPropertyNames(e);
};
function JN(t) {
  console && console.warn && console.warn(t);
}
var u4 = Number.isNaN || function(e) {
  return e !== e;
};
function kr() {
  kr.init.call(this);
}
Nv.exports = kr;
Nv.exports.once = eL;
kr.EventEmitter = kr;
kr.prototype._events = void 0;
kr.prototype._eventsCount = 0;
kr.prototype._maxListeners = void 0;
var O2 = 10;
function N0(t) {
  if (typeof t != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
}
Object.defineProperty(kr, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return O2;
  },
  set: function(t) {
    if (typeof t != "number" || t < 0 || u4(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    O2 = t;
  }
});
kr.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
kr.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || u4(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function f4(t) {
  return t._maxListeners === void 0 ? kr.defaultMaxListeners : t._maxListeners;
}
kr.prototype.getMaxListeners = function() {
  return f4(this);
};
kr.prototype.emit = function(e) {
  for (var r = [], n = 1; n < arguments.length; n++) r.push(arguments[n]);
  var i = e === "error", s = this._events;
  if (s !== void 0)
    i = i && s.error === void 0;
  else if (!i)
    return !1;
  if (i) {
    var o;
    if (r.length > 0 && (o = r[0]), o instanceof Error)
      throw o;
    var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
    throw a.context = o, a;
  }
  var u = s[e];
  if (u === void 0)
    return !1;
  if (typeof u == "function")
    D2(u, this, r);
  else
    for (var l = u.length, d = g4(u, l), n = 0; n < l; ++n)
      D2(d[n], this, r);
  return !0;
};
function l4(t, e, r, n) {
  var i, s, o;
  if (N0(r), s = t._events, s === void 0 ? (s = t._events = /* @__PURE__ */ Object.create(null), t._eventsCount = 0) : (s.newListener !== void 0 && (t.emit(
    "newListener",
    e,
    r.listener ? r.listener : r
  ), s = t._events), o = s[e]), o === void 0)
    o = s[e] = r, ++t._eventsCount;
  else if (typeof o == "function" ? o = s[e] = n ? [r, o] : [o, r] : n ? o.unshift(r) : o.push(r), i = f4(t), i > 0 && o.length > i && !o.warned) {
    o.warned = !0;
    var a = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a.name = "MaxListenersExceededWarning", a.emitter = t, a.type = e, a.count = o.length, JN(a);
  }
  return t;
}
kr.prototype.addListener = function(e, r) {
  return l4(this, e, r, !1);
};
kr.prototype.on = kr.prototype.addListener;
kr.prototype.prependListener = function(e, r) {
  return l4(this, e, r, !0);
};
function XN() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function h4(t, e, r) {
  var n = { fired: !1, wrapFn: void 0, target: t, type: e, listener: r }, i = XN.bind(n);
  return i.listener = r, n.wrapFn = i, i;
}
kr.prototype.once = function(e, r) {
  return N0(r), this.on(e, h4(this, e, r)), this;
};
kr.prototype.prependOnceListener = function(e, r) {
  return N0(r), this.prependListener(e, h4(this, e, r)), this;
};
kr.prototype.removeListener = function(e, r) {
  var n, i, s, o, a;
  if (N0(r), i = this._events, i === void 0)
    return this;
  if (n = i[e], n === void 0)
    return this;
  if (n === r || n.listener === r)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || r));
  else if (typeof n != "function") {
    for (s = -1, o = n.length - 1; o >= 0; o--)
      if (n[o] === r || n[o].listener === r) {
        a = n[o].listener, s = o;
        break;
      }
    if (s < 0)
      return this;
    s === 0 ? n.shift() : ZN(n, s), n.length === 1 && (i[e] = n[0]), i.removeListener !== void 0 && this.emit("removeListener", e, a || r);
  }
  return this;
};
kr.prototype.off = kr.prototype.removeListener;
kr.prototype.removeAllListeners = function(e) {
  var r, n, i;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[e]), this;
  if (arguments.length === 0) {
    var s = Object.keys(n), o;
    for (i = 0; i < s.length; ++i)
      o = s[i], o !== "removeListener" && this.removeAllListeners(o);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r = n[e], typeof r == "function")
    this.removeListener(e, r);
  else if (r !== void 0)
    for (i = r.length - 1; i >= 0; i--)
      this.removeListener(e, r[i]);
  return this;
};
function d4(t, e, r) {
  var n = t._events;
  if (n === void 0)
    return [];
  var i = n[e];
  return i === void 0 ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? QN(i) : g4(i, i.length);
}
kr.prototype.listeners = function(e) {
  return d4(this, e, !0);
};
kr.prototype.rawListeners = function(e) {
  return d4(this, e, !1);
};
kr.listenerCount = function(t, e) {
  return typeof t.listenerCount == "function" ? t.listenerCount(e) : p4.call(t, e);
};
kr.prototype.listenerCount = p4;
function p4(t) {
  var e = this._events;
  if (e !== void 0) {
    var r = e[t];
    if (typeof r == "function")
      return 1;
    if (r !== void 0)
      return r.length;
  }
  return 0;
}
kr.prototype.eventNames = function() {
  return this._eventsCount > 0 ? wd(this._events) : [];
};
function g4(t, e) {
  for (var r = new Array(e), n = 0; n < e; ++n)
    r[n] = t[n];
  return r;
}
function ZN(t, e) {
  for (; e + 1 < t.length; e++)
    t[e] = t[e + 1];
  t.pop();
}
function QN(t) {
  for (var e = new Array(t.length), r = 0; r < e.length; ++r)
    e[r] = t[r].listener || t[r];
  return e;
}
function eL(t, e) {
  return new Promise(function(r, n) {
    function i(o) {
      t.removeListener(e, s), n(o);
    }
    function s() {
      typeof t.removeListener == "function" && t.removeListener("error", i), r([].slice.call(arguments));
    }
    m4(t, e, s, { once: !0 }), e !== "error" && tL(t, i, { once: !0 });
  });
}
function tL(t, e, r) {
  typeof t.on == "function" && m4(t, "error", e, r);
}
function m4(t, e, r, n) {
  if (typeof t.on == "function")
    n.once ? t.once(e, r) : t.on(e, r);
  else if (typeof t.addEventListener == "function")
    t.addEventListener(e, function i(s) {
      n.once && t.removeEventListener(e, i), r(s);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
}
var rs = Nv.exports;
const Lv = /* @__PURE__ */ ts(rs);
var mt = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var c1 = function(t, e) {
  return c1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var i in n) n.hasOwnProperty(i) && (r[i] = n[i]);
  }, c1(t, e);
};
function rL(t, e) {
  c1(t, e);
  function r() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
}
var u1 = function() {
  return u1 = Object.assign || function(e) {
    for (var r, n = 1, i = arguments.length; n < i; n++) {
      r = arguments[n];
      for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (e[s] = r[s]);
    }
    return e;
  }, u1.apply(this, arguments);
};
function nL(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
  return r;
}
function iL(t, e, r, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, r) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, r, n);
  else for (var a = t.length - 1; a >= 0; a--) (o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, r, s) : o(e, r)) || s);
  return i > 3 && s && Object.defineProperty(e, r, s), s;
}
function sL(t, e) {
  return function(r, n) {
    e(r, n, t);
  };
}
function oL(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(t, e);
}
function aL(t, e, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function a(d) {
      try {
        l(n.next(d));
      } catch (p) {
        o(p);
      }
    }
    function u(d) {
      try {
        l(n.throw(d));
      } catch (p) {
        o(p);
      }
    }
    function l(d) {
      d.done ? s(d.value) : i(d.value).then(a, u);
    }
    l((n = n.apply(t, e || [])).next());
  });
}
function cL(t, e) {
  var r = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(l) {
    return function(d) {
      return u([l, d]);
    };
  }
  function u(l) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; r; ) try {
      if (n = 1, i && (s = l[0] & 2 ? i.return : l[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, l[1])).done) return s;
      switch (i = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
        case 0:
        case 1:
          s = l;
          break;
        case 4:
          return r.label++, { value: l[1], done: !1 };
        case 5:
          r.label++, i = l[1], l = [0];
          continue;
        case 7:
          l = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            r = 0;
            continue;
          }
          if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
            r.label = l[1];
            break;
          }
          if (l[0] === 6 && r.label < s[1]) {
            r.label = s[1], s = l;
            break;
          }
          if (s && r.label < s[2]) {
            r.label = s[2], r.ops.push(l);
            break;
          }
          s[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      l = e.call(t, r);
    } catch (d) {
      l = [6, d], i = 0;
    } finally {
      n = s = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function uL(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}
function fL(t, e) {
  for (var r in t) r !== "default" && !e.hasOwnProperty(r) && (e[r] = t[r]);
}
function f1(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], n = 0;
  if (r) return r.call(t);
  if (t && typeof t.length == "number") return {
    next: function() {
      return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function v4(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r) return t;
  var n = r.call(t), i, s = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) s.push(i.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (o) throw o.error;
    }
  }
  return s;
}
function lL() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(v4(arguments[e]));
  return t;
}
function hL() {
  for (var t = 0, e = 0, r = arguments.length; e < r; e++) t += arguments[e].length;
  for (var n = Array(t), i = 0, e = 0; e < r; e++)
    for (var s = arguments[e], o = 0, a = s.length; o < a; o++, i++)
      n[i] = s[o];
  return n;
}
function vl(t) {
  return this instanceof vl ? (this.v = t, this) : new vl(t);
}
function dL(t, e, r) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = r.apply(t, e || []), i, s = [];
  return i = {}, o("next"), o("throw"), o("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function o(w) {
    n[w] && (i[w] = function(P) {
      return new Promise(function(A, N) {
        s.push([w, P, A, N]) > 1 || a(w, P);
      });
    });
  }
  function a(w, P) {
    try {
      u(n[w](P));
    } catch (A) {
      p(s[0][3], A);
    }
  }
  function u(w) {
    w.value instanceof vl ? Promise.resolve(w.value.v).then(l, d) : p(s[0][2], w);
  }
  function l(w) {
    a("next", w);
  }
  function d(w) {
    a("throw", w);
  }
  function p(w, P) {
    w(P), s.shift(), s.length && a(s[0][0], s[0][1]);
  }
}
function pL(t) {
  var e, r;
  return e = {}, n("next"), n("throw", function(i) {
    throw i;
  }), n("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function n(i, s) {
    e[i] = t[i] ? function(o) {
      return (r = !r) ? { value: vl(t[i](o)), done: i === "return" } : s ? s(o) : o;
    } : s;
  }
}
function gL(t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], r;
  return e ? e.call(t) : (t = typeof f1 == "function" ? f1(t) : t[Symbol.iterator](), r = {}, n("next"), n("throw"), n("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function n(s) {
    r[s] = t[s] && function(o) {
      return new Promise(function(a, u) {
        o = t[s](o), i(a, u, o.done, o.value);
      });
    };
  }
  function i(s, o, a, u) {
    Promise.resolve(u).then(function(l) {
      s({ value: l, done: a });
    }, o);
  }
}
function mL(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : t.raw = e, t;
}
function vL(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
  return e.default = t, e;
}
function bL(t) {
  return t && t.__esModule ? t : { default: t };
}
function yL(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function wL(t, e, r) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, r), r;
}
const xL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return u1;
  },
  __asyncDelegator: pL,
  __asyncGenerator: dL,
  __asyncValues: gL,
  __await: vl,
  __awaiter: aL,
  __classPrivateFieldGet: yL,
  __classPrivateFieldSet: wL,
  __createBinding: uL,
  __decorate: iL,
  __exportStar: fL,
  __extends: rL,
  __generator: cL,
  __importDefault: bL,
  __importStar: vL,
  __makeTemplateObject: mL,
  __metadata: oL,
  __param: sL,
  __read: v4,
  __rest: nL,
  __spread: lL,
  __spreadArrays: hL,
  __values: f1
}, Symbol.toStringTag, { value: "Module" })), Bl = /* @__PURE__ */ bv(xL);
var Hg = {}, yf = {}, N2;
function _L() {
  if (N2) return yf;
  N2 = 1, Object.defineProperty(yf, "__esModule", { value: !0 }), yf.delay = void 0;
  function t(e) {
    return new Promise((r) => {
      setTimeout(() => {
        r(!0);
      }, e);
    });
  }
  return yf.delay = t, yf;
}
var ja = {}, Wg = {}, qa = {}, L2;
function EL() {
  return L2 || (L2 = 1, Object.defineProperty(qa, "__esModule", { value: !0 }), qa.ONE_THOUSAND = qa.ONE_HUNDRED = void 0, qa.ONE_HUNDRED = 100, qa.ONE_THOUSAND = 1e3), qa;
}
var Kg = {}, k2;
function SL() {
  return k2 || (k2 = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ONE_YEAR = t.FOUR_WEEKS = t.THREE_WEEKS = t.TWO_WEEKS = t.ONE_WEEK = t.THIRTY_DAYS = t.SEVEN_DAYS = t.FIVE_DAYS = t.THREE_DAYS = t.ONE_DAY = t.TWENTY_FOUR_HOURS = t.TWELVE_HOURS = t.SIX_HOURS = t.THREE_HOURS = t.ONE_HOUR = t.SIXTY_MINUTES = t.THIRTY_MINUTES = t.TEN_MINUTES = t.FIVE_MINUTES = t.ONE_MINUTE = t.SIXTY_SECONDS = t.THIRTY_SECONDS = t.TEN_SECONDS = t.FIVE_SECONDS = t.ONE_SECOND = void 0, t.ONE_SECOND = 1, t.FIVE_SECONDS = 5, t.TEN_SECONDS = 10, t.THIRTY_SECONDS = 30, t.SIXTY_SECONDS = 60, t.ONE_MINUTE = t.SIXTY_SECONDS, t.FIVE_MINUTES = t.ONE_MINUTE * 5, t.TEN_MINUTES = t.ONE_MINUTE * 10, t.THIRTY_MINUTES = t.ONE_MINUTE * 30, t.SIXTY_MINUTES = t.ONE_MINUTE * 60, t.ONE_HOUR = t.SIXTY_MINUTES, t.THREE_HOURS = t.ONE_HOUR * 3, t.SIX_HOURS = t.ONE_HOUR * 6, t.TWELVE_HOURS = t.ONE_HOUR * 12, t.TWENTY_FOUR_HOURS = t.ONE_HOUR * 24, t.ONE_DAY = t.TWENTY_FOUR_HOURS, t.THREE_DAYS = t.ONE_DAY * 3, t.FIVE_DAYS = t.ONE_DAY * 5, t.SEVEN_DAYS = t.ONE_DAY * 7, t.THIRTY_DAYS = t.ONE_DAY * 30, t.ONE_WEEK = t.SEVEN_DAYS, t.TWO_WEEKS = t.ONE_WEEK * 2, t.THREE_WEEKS = t.ONE_WEEK * 3, t.FOUR_WEEKS = t.ONE_WEEK * 4, t.ONE_YEAR = t.ONE_DAY * 365;
  }(Kg)), Kg;
}
var $2;
function b4() {
  return $2 || ($2 = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const e = Bl;
    e.__exportStar(EL(), t), e.__exportStar(SL(), t);
  }(Wg)), Wg;
}
var F2;
function AL() {
  if (F2) return ja;
  F2 = 1, Object.defineProperty(ja, "__esModule", { value: !0 }), ja.fromMiliseconds = ja.toMiliseconds = void 0;
  const t = b4();
  function e(n) {
    return n * t.ONE_THOUSAND;
  }
  ja.toMiliseconds = e;
  function r(n) {
    return Math.floor(n / t.ONE_THOUSAND);
  }
  return ja.fromMiliseconds = r, ja;
}
var B2;
function PL() {
  return B2 || (B2 = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const e = Bl;
    e.__exportStar(_L(), t), e.__exportStar(AL(), t);
  }(Hg)), Hg;
}
var qc = {}, U2;
function ML() {
  if (U2) return qc;
  U2 = 1, Object.defineProperty(qc, "__esModule", { value: !0 }), qc.Watch = void 0;
  class t {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(r) {
      if (this.timestamps.has(r))
        throw new Error(`Watch already started for label: ${r}`);
      this.timestamps.set(r, { started: Date.now() });
    }
    stop(r) {
      const n = this.get(r);
      if (typeof n.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${r}`);
      const i = Date.now() - n.started;
      this.timestamps.set(r, { started: n.started, elapsed: i });
    }
    get(r) {
      const n = this.timestamps.get(r);
      if (typeof n > "u")
        throw new Error(`No timestamp found for label: ${r}`);
      return n;
    }
    elapsed(r) {
      const n = this.get(r);
      return n.elapsed || Date.now() - n.started;
    }
  }
  return qc.Watch = t, qc.default = t, qc;
}
var Vg = {}, wf = {}, j2;
function IL() {
  if (j2) return wf;
  j2 = 1, Object.defineProperty(wf, "__esModule", { value: !0 }), wf.IWatch = void 0;
  class t {
  }
  return wf.IWatch = t, wf;
}
var q2;
function CL() {
  return q2 || (q2 = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), Bl.__exportStar(IL(), t);
  }(Vg)), Vg;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = Bl;
  e.__exportStar(PL(), t), e.__exportStar(ML(), t), e.__exportStar(CL(), t), e.__exportStar(b4(), t);
})(mt);
class mc {
}
let TL = class extends mc {
  constructor(e) {
    super();
  }
};
const z2 = mt.FIVE_SECONDS, Du = { pulse: "heartbeat_pulse" };
let RL = class y4 extends TL {
  constructor(e) {
    super(e), this.events = new rs.EventEmitter(), this.interval = z2, this.interval = (e == null ? void 0 : e.interval) || z2;
  }
  static async init(e) {
    const r = new y4(e);
    return await r.init(), r;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), mt.toMiliseconds(this.interval));
  }
  pulse() {
    this.events.emit(Du.pulse);
  }
};
const DL = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, OL = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, NL = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function LL(t, e) {
  if (t === "__proto__" || t === "constructor" && e && typeof e == "object" && "prototype" in e) {
    kL(t);
    return;
  }
  return e;
}
function kL(t) {
  console.warn(`[destr] Dropping "${t}" key to prevent prototype pollution.`);
}
function sd(t, e = {}) {
  if (typeof t != "string")
    return t;
  const r = t.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    t[0] === '"' && t.endsWith('"') && !t.includes("\\")
  )
    return r.slice(1, -1);
  if (r.length <= 9) {
    const n = r.toLowerCase();
    if (n === "true")
      return !0;
    if (n === "false")
      return !1;
    if (n === "undefined")
      return;
    if (n === "null")
      return null;
    if (n === "nan")
      return Number.NaN;
    if (n === "infinity")
      return Number.POSITIVE_INFINITY;
    if (n === "-infinity")
      return Number.NEGATIVE_INFINITY;
  }
  if (!NL.test(t)) {
    if (e.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return t;
  }
  try {
    if (DL.test(t) || OL.test(t)) {
      if (e.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(t, LL);
    }
    return JSON.parse(t);
  } catch (n) {
    if (e.strict)
      throw n;
    return t;
  }
}
function $L(t) {
  return !t || typeof t.then != "function" ? Promise.resolve(t) : t;
}
function Cn(t, ...e) {
  try {
    return $L(t(...e));
  } catch (r) {
    return Promise.reject(r);
  }
}
function FL(t) {
  const e = typeof t;
  return t === null || e !== "object" && e !== "function";
}
function BL(t) {
  const e = Object.getPrototypeOf(t);
  return !e || e.isPrototypeOf(Object);
}
function xd(t) {
  if (FL(t))
    return String(t);
  if (BL(t) || Array.isArray(t))
    return JSON.stringify(t);
  if (typeof t.toJSON == "function")
    return xd(t.toJSON());
  throw new Error("[unstorage] Cannot stringify value!");
}
function w4() {
  if (typeof Buffer > "u")
    throw new TypeError("[unstorage] Buffer is not supported!");
}
const l1 = "base64:";
function UL(t) {
  if (typeof t == "string")
    return t;
  w4();
  const e = Buffer.from(t).toString("base64");
  return l1 + e;
}
function jL(t) {
  return typeof t != "string" || !t.startsWith(l1) ? t : (w4(), Buffer.from(t.slice(l1.length), "base64"));
}
function di(t) {
  return t ? t.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : "";
}
function qL(...t) {
  return di(t.join(":"));
}
function od(t) {
  return t = di(t), t ? t + ":" : "";
}
const zL = "memory", HL = () => {
  const t = /* @__PURE__ */ new Map();
  return {
    name: zL,
    getInstance: () => t,
    hasItem(e) {
      return t.has(e);
    },
    getItem(e) {
      return t.get(e) ?? null;
    },
    getItemRaw(e) {
      return t.get(e) ?? null;
    },
    setItem(e, r) {
      t.set(e, r);
    },
    setItemRaw(e, r) {
      t.set(e, r);
    },
    removeItem(e) {
      t.delete(e);
    },
    getKeys() {
      return [...t.keys()];
    },
    clear() {
      t.clear();
    },
    dispose() {
      t.clear();
    }
  };
};
function WL(t = {}) {
  const e = {
    mounts: { "": t.driver || HL() },
    mountpoints: [""],
    watching: !1,
    watchListeners: [],
    unwatch: {}
  }, r = (l) => {
    for (const d of e.mountpoints)
      if (l.startsWith(d))
        return {
          base: d,
          relativeKey: l.slice(d.length),
          driver: e.mounts[d]
        };
    return {
      base: "",
      relativeKey: l,
      driver: e.mounts[""]
    };
  }, n = (l, d) => e.mountpoints.filter(
    (p) => p.startsWith(l) || d && l.startsWith(p)
  ).map((p) => ({
    relativeBase: l.length > p.length ? l.slice(p.length) : void 0,
    mountpoint: p,
    driver: e.mounts[p]
  })), i = (l, d) => {
    if (e.watching) {
      d = di(d);
      for (const p of e.watchListeners)
        p(l, d);
    }
  }, s = async () => {
    if (!e.watching) {
      e.watching = !0;
      for (const l in e.mounts)
        e.unwatch[l] = await H2(
          e.mounts[l],
          i,
          l
        );
    }
  }, o = async () => {
    if (e.watching) {
      for (const l in e.unwatch)
        await e.unwatch[l]();
      e.unwatch = {}, e.watching = !1;
    }
  }, a = (l, d, p) => {
    const w = /* @__PURE__ */ new Map(), P = (A) => {
      let N = w.get(A.base);
      return N || (N = {
        driver: A.driver,
        base: A.base,
        items: []
      }, w.set(A.base, N)), N;
    };
    for (const A of l) {
      const N = typeof A == "string", L = di(N ? A : A.key), F = N ? void 0 : A.value, $ = N || !A.options ? d : { ...d, ...A.options }, K = r(L);
      P(K).items.push({
        key: L,
        value: F,
        relativeKey: K.relativeKey,
        options: $
      });
    }
    return Promise.all([...w.values()].map((A) => p(A))).then(
      (A) => A.flat()
    );
  }, u = {
    // Item
    hasItem(l, d = {}) {
      l = di(l);
      const { relativeKey: p, driver: w } = r(l);
      return Cn(w.hasItem, p, d);
    },
    getItem(l, d = {}) {
      l = di(l);
      const { relativeKey: p, driver: w } = r(l);
      return Cn(w.getItem, p, d).then(
        (P) => sd(P)
      );
    },
    getItems(l, d) {
      return a(l, d, (p) => p.driver.getItems ? Cn(
        p.driver.getItems,
        p.items.map((w) => ({
          key: w.relativeKey,
          options: w.options
        })),
        d
      ).then(
        (w) => w.map((P) => ({
          key: qL(p.base, P.key),
          value: sd(P.value)
        }))
      ) : Promise.all(
        p.items.map((w) => Cn(
          p.driver.getItem,
          w.relativeKey,
          w.options
        ).then((P) => ({
          key: w.key,
          value: sd(P)
        })))
      ));
    },
    getItemRaw(l, d = {}) {
      l = di(l);
      const { relativeKey: p, driver: w } = r(l);
      return w.getItemRaw ? Cn(w.getItemRaw, p, d) : Cn(w.getItem, p, d).then(
        (P) => jL(P)
      );
    },
    async setItem(l, d, p = {}) {
      if (d === void 0)
        return u.removeItem(l);
      l = di(l);
      const { relativeKey: w, driver: P } = r(l);
      P.setItem && (await Cn(P.setItem, w, xd(d), p), P.watch || i("update", l));
    },
    async setItems(l, d) {
      await a(l, d, async (p) => {
        if (p.driver.setItems)
          return Cn(
            p.driver.setItems,
            p.items.map((w) => ({
              key: w.relativeKey,
              value: xd(w.value),
              options: w.options
            })),
            d
          );
        p.driver.setItem && await Promise.all(
          p.items.map((w) => Cn(
            p.driver.setItem,
            w.relativeKey,
            xd(w.value),
            w.options
          ))
        );
      });
    },
    async setItemRaw(l, d, p = {}) {
      if (d === void 0)
        return u.removeItem(l, p);
      l = di(l);
      const { relativeKey: w, driver: P } = r(l);
      if (P.setItemRaw)
        await Cn(P.setItemRaw, w, d, p);
      else if (P.setItem)
        await Cn(P.setItem, w, UL(d), p);
      else
        return;
      P.watch || i("update", l);
    },
    async removeItem(l, d = {}) {
      typeof d == "boolean" && (d = { removeMeta: d }), l = di(l);
      const { relativeKey: p, driver: w } = r(l);
      w.removeItem && (await Cn(w.removeItem, p, d), (d.removeMeta || d.removeMata) && await Cn(w.removeItem, p + "$", d), w.watch || i("remove", l));
    },
    // Meta
    async getMeta(l, d = {}) {
      typeof d == "boolean" && (d = { nativeOnly: d }), l = di(l);
      const { relativeKey: p, driver: w } = r(l), P = /* @__PURE__ */ Object.create(null);
      if (w.getMeta && Object.assign(P, await Cn(w.getMeta, p, d)), !d.nativeOnly) {
        const A = await Cn(
          w.getItem,
          p + "$",
          d
        ).then((N) => sd(N));
        A && typeof A == "object" && (typeof A.atime == "string" && (A.atime = new Date(A.atime)), typeof A.mtime == "string" && (A.mtime = new Date(A.mtime)), Object.assign(P, A));
      }
      return P;
    },
    setMeta(l, d, p = {}) {
      return this.setItem(l + "$", d, p);
    },
    removeMeta(l, d = {}) {
      return this.removeItem(l + "$", d);
    },
    // Keys
    async getKeys(l, d = {}) {
      l = od(l);
      const p = n(l, !0);
      let w = [];
      const P = [];
      for (const A of p) {
        const N = await Cn(
          A.driver.getKeys,
          A.relativeBase,
          d
        );
        for (const L of N) {
          const F = A.mountpoint + di(L);
          w.some(($) => F.startsWith($)) || P.push(F);
        }
        w = [
          A.mountpoint,
          ...w.filter((L) => !L.startsWith(A.mountpoint))
        ];
      }
      return l ? P.filter(
        (A) => A.startsWith(l) && A[A.length - 1] !== "$"
      ) : P.filter((A) => A[A.length - 1] !== "$");
    },
    // Utils
    async clear(l, d = {}) {
      l = od(l), await Promise.all(
        n(l, !1).map(async (p) => {
          if (p.driver.clear)
            return Cn(p.driver.clear, p.relativeBase, d);
          if (p.driver.removeItem) {
            const w = await p.driver.getKeys(p.relativeBase || "", d);
            return Promise.all(
              w.map((P) => p.driver.removeItem(P, d))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(e.mounts).map((l) => W2(l))
      );
    },
    async watch(l) {
      return await s(), e.watchListeners.push(l), async () => {
        e.watchListeners = e.watchListeners.filter(
          (d) => d !== l
        ), e.watchListeners.length === 0 && await o();
      };
    },
    async unwatch() {
      e.watchListeners = [], await o();
    },
    // Mount
    mount(l, d) {
      if (l = od(l), l && e.mounts[l])
        throw new Error(`already mounted at ${l}`);
      return l && (e.mountpoints.push(l), e.mountpoints.sort((p, w) => w.length - p.length)), e.mounts[l] = d, e.watching && Promise.resolve(H2(d, i, l)).then((p) => {
        e.unwatch[l] = p;
      }).catch(console.error), u;
    },
    async unmount(l, d = !0) {
      l = od(l), !(!l || !e.mounts[l]) && (e.watching && l in e.unwatch && (e.unwatch[l](), delete e.unwatch[l]), d && await W2(e.mounts[l]), e.mountpoints = e.mountpoints.filter((p) => p !== l), delete e.mounts[l]);
    },
    getMount(l = "") {
      l = di(l) + ":";
      const d = r(l);
      return {
        driver: d.driver,
        base: d.base
      };
    },
    getMounts(l = "", d = {}) {
      return l = di(l), n(l, d.parents).map((w) => ({
        driver: w.driver,
        base: w.mountpoint
      }));
    },
    // Aliases
    keys: (l, d = {}) => u.getKeys(l, d),
    get: (l, d = {}) => u.getItem(l, d),
    set: (l, d, p = {}) => u.setItem(l, d, p),
    has: (l, d = {}) => u.hasItem(l, d),
    del: (l, d = {}) => u.removeItem(l, d),
    remove: (l, d = {}) => u.removeItem(l, d)
  };
  return u;
}
function H2(t, e, r) {
  return t.watch ? t.watch((n, i) => e(n, r + i)) : () => {
  };
}
async function W2(t) {
  typeof t.dispose == "function" && await Cn(t.dispose);
}
function vc(t) {
  return new Promise((e, r) => {
    t.oncomplete = t.onsuccess = () => e(t.result), t.onabort = t.onerror = () => r(t.error);
  });
}
function x4(t, e) {
  const r = indexedDB.open(t);
  r.onupgradeneeded = () => r.result.createObjectStore(e);
  const n = vc(r);
  return (i, s) => n.then((o) => s(o.transaction(e, i).objectStore(e)));
}
let Gg;
function Ul() {
  return Gg || (Gg = x4("keyval-store", "keyval")), Gg;
}
function K2(t, e = Ul()) {
  return e("readonly", (r) => vc(r.get(t)));
}
function KL(t, e, r = Ul()) {
  return r("readwrite", (n) => (n.put(e, t), vc(n.transaction)));
}
function VL(t, e = Ul()) {
  return e("readwrite", (r) => (r.delete(t), vc(r.transaction)));
}
function GL(t = Ul()) {
  return t("readwrite", (e) => (e.clear(), vc(e.transaction)));
}
function YL(t, e) {
  return t.openCursor().onsuccess = function() {
    this.result && (e(this.result), this.result.continue());
  }, vc(t.transaction);
}
function JL(t = Ul()) {
  return t("readonly", (e) => {
    if (e.getAllKeys)
      return vc(e.getAllKeys());
    const r = [];
    return YL(e, (n) => r.push(n.key)).then(() => r);
  });
}
const XL = (t) => JSON.stringify(t, (e, r) => typeof r == "bigint" ? r.toString() + "n" : r), ZL = (t) => {
  const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, r = t.replace(e, '$1"$2n"$3');
  return JSON.parse(r, (n, i) => typeof i == "string" && i.match(/^\d+n$/) ? BigInt(i.substring(0, i.length - 1)) : i);
};
function uc(t) {
  if (typeof t != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof t}`);
  try {
    return ZL(t);
  } catch {
    return t;
  }
}
function ko(t) {
  return typeof t == "string" ? t : XL(t) || "";
}
const QL = "idb-keyval";
var ek = (t = {}) => {
  const e = t.base && t.base.length > 0 ? `${t.base}:` : "", r = (i) => e + i;
  let n;
  return t.dbName && t.storeName && (n = x4(t.dbName, t.storeName)), { name: QL, options: t, async hasItem(i) {
    return !(typeof await K2(r(i), n) > "u");
  }, async getItem(i) {
    return await K2(r(i), n) ?? null;
  }, setItem(i, s) {
    return KL(r(i), s, n);
  }, removeItem(i) {
    return VL(r(i), n);
  }, getKeys() {
    return JL(n);
  }, clear() {
    return GL(n);
  } };
};
const tk = "WALLET_CONNECT_V2_INDEXED_DB", rk = "keyvaluestorage";
let nk = class {
  constructor() {
    this.indexedDb = WL({ driver: ek({ dbName: tk, storeName: rk }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((e) => [e.key, e.value]);
  }
  async getItem(e) {
    const r = await this.indexedDb.getItem(e);
    if (r !== null) return r;
  }
  async setItem(e, r) {
    await this.indexedDb.setItem(e, ko(r));
  }
  async removeItem(e) {
    await this.indexedDb.removeItem(e);
  }
};
var Yg = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, _d = { exports: {} };
(function() {
  let t;
  function e() {
  }
  t = e, t.prototype.getItem = function(r) {
    return this.hasOwnProperty(r) ? String(this[r]) : null;
  }, t.prototype.setItem = function(r, n) {
    this[r] = String(n);
  }, t.prototype.removeItem = function(r) {
    delete this[r];
  }, t.prototype.clear = function() {
    const r = this;
    Object.keys(r).forEach(function(n) {
      r[n] = void 0, delete r[n];
    });
  }, t.prototype.key = function(r) {
    return r = r || 0, Object.keys(this)[r];
  }, t.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof Yg < "u" && Yg.localStorage ? _d.exports = Yg.localStorage : typeof window < "u" && window.localStorage ? _d.exports = window.localStorage : _d.exports = new e();
})();
function ik(t) {
  var e;
  return [t[0], uc((e = t[1]) != null ? e : "")];
}
let sk = class {
  constructor() {
    this.localStorage = _d.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(ik);
  }
  async getItem(e) {
    const r = this.localStorage.getItem(e);
    if (r !== null) return uc(r);
  }
  async setItem(e, r) {
    this.localStorage.setItem(e, ko(r));
  }
  async removeItem(e) {
    this.localStorage.removeItem(e);
  }
};
const ok = "wc_storage_version", V2 = 1, ak = async (t, e, r) => {
  const n = ok, i = await e.getItem(n);
  if (i && i >= V2) {
    r(e);
    return;
  }
  const s = await t.getKeys();
  if (!s.length) {
    r(e);
    return;
  }
  const o = [];
  for (; s.length; ) {
    const a = s.shift();
    if (!a) continue;
    const u = a.toLowerCase();
    if (u.includes("wc@") || u.includes("walletconnect") || u.includes("wc_") || u.includes("wallet_connect")) {
      const l = await t.getItem(a);
      await e.setItem(a, l), o.push(a);
    }
  }
  await e.setItem(n, V2), r(e), ck(t, o);
}, ck = async (t, e) => {
  e.length && e.forEach(async (r) => {
    await t.removeItem(r);
  });
};
let uk = class {
  constructor() {
    this.initialized = !1, this.setInitialized = (r) => {
      this.storage = r, this.initialized = !0;
    };
    const e = new sk();
    this.storage = e;
    try {
      const r = new nk();
      ak(e, r, this.setInitialized);
    } catch {
      this.initialized = !0;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(e) {
    return await this.initialize(), this.storage.getItem(e);
  }
  async setItem(e, r) {
    return await this.initialize(), this.storage.setItem(e, r);
  }
  async removeItem(e) {
    return await this.initialize(), this.storage.removeItem(e);
  }
  async initialize() {
    this.initialized || await new Promise((e) => {
      const r = setInterval(() => {
        this.initialized && (clearInterval(r), e());
      }, 20);
    });
  }
};
function fk(t) {
  try {
    return JSON.stringify(t);
  } catch {
    return '"[Circular]"';
  }
}
var lk = hk;
function hk(t, e, r) {
  var n = r && r.stringify || fk, i = 1;
  if (typeof t == "object" && t !== null) {
    var s = e.length + i;
    if (s === 1) return t;
    var o = new Array(s);
    o[0] = n(t);
    for (var a = 1; a < s; a++)
      o[a] = n(e[a]);
    return o.join(" ");
  }
  if (typeof t != "string")
    return t;
  var u = e.length;
  if (u === 0) return t;
  for (var l = "", d = 1 - i, p = -1, w = t && t.length || 0, P = 0; P < w; ) {
    if (t.charCodeAt(P) === 37 && P + 1 < w) {
      switch (p = p > -1 ? p : 0, t.charCodeAt(P + 1)) {
        case 100:
        case 102:
          if (d >= u || e[d] == null) break;
          p < P && (l += t.slice(p, P)), l += Number(e[d]), p = P + 2, P++;
          break;
        case 105:
          if (d >= u || e[d] == null) break;
          p < P && (l += t.slice(p, P)), l += Math.floor(Number(e[d])), p = P + 2, P++;
          break;
        case 79:
        case 111:
        case 106:
          if (d >= u || e[d] === void 0) break;
          p < P && (l += t.slice(p, P));
          var A = typeof e[d];
          if (A === "string") {
            l += "'" + e[d] + "'", p = P + 2, P++;
            break;
          }
          if (A === "function") {
            l += e[d].name || "<anonymous>", p = P + 2, P++;
            break;
          }
          l += n(e[d]), p = P + 2, P++;
          break;
        case 115:
          if (d >= u)
            break;
          p < P && (l += t.slice(p, P)), l += String(e[d]), p = P + 2, P++;
          break;
        case 37:
          p < P && (l += t.slice(p, P)), l += "%", p = P + 2, P++, d--;
          break;
      }
      ++d;
    }
    ++P;
  }
  return p === -1 ? t : (p < w && (l += t.slice(p)), l);
}
const G2 = lk;
var Yc = $o;
const bl = _k().console || {}, dk = {
  mapHttpRequest: ad,
  mapHttpResponse: ad,
  wrapRequestSerializer: Jg,
  wrapResponseSerializer: Jg,
  wrapErrorSerializer: Jg,
  req: ad,
  res: ad,
  err: bk
};
function pk(t, e) {
  return Array.isArray(t) ? t.filter(function(n) {
    return n !== "!stdSerializers.err";
  }) : t === !0 ? Object.keys(e) : !1;
}
function $o(t) {
  t = t || {}, t.browser = t.browser || {};
  const e = t.browser.transmit;
  if (e && typeof e.send != "function")
    throw Error("pino: transmit option must have a send function");
  const r = t.browser.write || bl;
  t.browser.write && (t.browser.asObject = !0);
  const n = t.serializers || {}, i = pk(t.browser.serialize, n);
  let s = t.browser.serialize;
  Array.isArray(t.browser.serialize) && t.browser.serialize.indexOf("!stdSerializers.err") > -1 && (s = !1);
  const o = ["error", "fatal", "warn", "info", "debug", "trace"];
  typeof r == "function" && (r.error = r.fatal = r.warn = r.info = r.debug = r.trace = r), t.enabled === !1 && (t.level = "silent");
  const a = t.level || "info", u = Object.create(r);
  u.log || (u.log = yl), Object.defineProperty(u, "levelVal", {
    get: d
  }), Object.defineProperty(u, "level", {
    get: p,
    set: w
  });
  const l = {
    transmit: e,
    serialize: i,
    asObject: t.browser.asObject,
    levels: o,
    timestamp: yk(t)
  };
  u.levels = $o.levels, u.level = a, u.setMaxListeners = u.getMaxListeners = u.emit = u.addListener = u.on = u.prependListener = u.once = u.prependOnceListener = u.removeListener = u.removeAllListeners = u.listeners = u.listenerCount = u.eventNames = u.write = u.flush = yl, u.serializers = n, u._serialize = i, u._stdErrSerialize = s, u.child = P, e && (u._logEvent = h1());
  function d() {
    return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
  }
  function p() {
    return this._level;
  }
  function w(A) {
    if (A !== "silent" && !this.levels.values[A])
      throw Error("unknown level " + A);
    this._level = A, zc(l, u, "error", "log"), zc(l, u, "fatal", "error"), zc(l, u, "warn", "error"), zc(l, u, "info", "log"), zc(l, u, "debug", "log"), zc(l, u, "trace", "log");
  }
  function P(A, N) {
    if (!A)
      throw new Error("missing bindings for child Pino");
    N = N || {}, i && A.serializers && (N.serializers = A.serializers);
    const L = N.serializers;
    if (i && L) {
      var F = Object.assign({}, n, L), $ = t.browser.serialize === !0 ? Object.keys(F) : i;
      delete A.serializers, L0([A], $, F, this._stdErrSerialize);
    }
    function K(H) {
      this._childLevel = (H._childLevel | 0) + 1, this.error = Hc(H, A, "error"), this.fatal = Hc(H, A, "fatal"), this.warn = Hc(H, A, "warn"), this.info = Hc(H, A, "info"), this.debug = Hc(H, A, "debug"), this.trace = Hc(H, A, "trace"), F && (this.serializers = F, this._serialize = $), e && (this._logEvent = h1(
        [].concat(H._logEvent.bindings, A)
      ));
    }
    return K.prototype = this, new K(this);
  }
  return u;
}
$o.levels = {
  values: {
    fatal: 60,
    error: 50,
    warn: 40,
    info: 30,
    debug: 20,
    trace: 10
  },
  labels: {
    10: "trace",
    20: "debug",
    30: "info",
    40: "warn",
    50: "error",
    60: "fatal"
  }
};
$o.stdSerializers = dk;
$o.stdTimeFunctions = Object.assign({}, { nullTime: _4, epochTime: E4, unixTime: wk, isoTime: xk });
function zc(t, e, r, n) {
  const i = Object.getPrototypeOf(e);
  e[r] = e.levelVal > e.levels.values[r] ? yl : i[r] ? i[r] : bl[r] || bl[n] || yl, gk(t, e, r);
}
function gk(t, e, r) {
  !t.transmit && e[r] === yl || (e[r] = /* @__PURE__ */ function(n) {
    return function() {
      const s = t.timestamp(), o = new Array(arguments.length), a = Object.getPrototypeOf && Object.getPrototypeOf(this) === bl ? bl : this;
      for (var u = 0; u < o.length; u++) o[u] = arguments[u];
      if (t.serialize && !t.asObject && L0(o, this._serialize, this.serializers, this._stdErrSerialize), t.asObject ? n.call(a, mk(this, r, o, s)) : n.apply(a, o), t.transmit) {
        const l = t.transmit.level || e.level, d = $o.levels.values[l], p = $o.levels.values[r];
        if (p < d) return;
        vk(this, {
          ts: s,
          methodLevel: r,
          methodValue: p,
          send: t.transmit.send,
          val: e.levelVal
        }, o);
      }
    };
  }(e[r]));
}
function mk(t, e, r, n) {
  t._serialize && L0(r, t._serialize, t.serializers, t._stdErrSerialize);
  const i = r.slice();
  let s = i[0];
  const o = {};
  n && (o.time = n), o.level = $o.levels.values[e];
  let a = (t._childLevel | 0) + 1;
  if (a < 1 && (a = 1), s !== null && typeof s == "object") {
    for (; a-- && typeof i[0] == "object"; )
      Object.assign(o, i.shift());
    s = i.length ? G2(i.shift(), i) : void 0;
  } else typeof s == "string" && (s = G2(i.shift(), i));
  return s !== void 0 && (o.msg = s), o;
}
function L0(t, e, r, n) {
  for (const i in t)
    if (n && t[i] instanceof Error)
      t[i] = $o.stdSerializers.err(t[i]);
    else if (typeof t[i] == "object" && !Array.isArray(t[i]))
      for (const s in t[i])
        e && e.indexOf(s) > -1 && s in r && (t[i][s] = r[s](t[i][s]));
}
function Hc(t, e, r) {
  return function() {
    const n = new Array(1 + arguments.length);
    n[0] = e;
    for (var i = 1; i < n.length; i++)
      n[i] = arguments[i - 1];
    return t[r].apply(this, n);
  };
}
function vk(t, e, r) {
  const n = e.send, i = e.ts, s = e.methodLevel, o = e.methodValue, a = e.val, u = t._logEvent.bindings;
  L0(
    r,
    t._serialize || Object.keys(t.serializers),
    t.serializers,
    t._stdErrSerialize === void 0 ? !0 : t._stdErrSerialize
  ), t._logEvent.ts = i, t._logEvent.messages = r.filter(function(l) {
    return u.indexOf(l) === -1;
  }), t._logEvent.level.label = s, t._logEvent.level.value = o, n(s, t._logEvent, a), t._logEvent = h1(u);
}
function h1(t) {
  return {
    ts: 0,
    messages: [],
    bindings: t || [],
    level: { label: "", value: 0 }
  };
}
function bk(t) {
  const e = {
    type: t.constructor.name,
    msg: t.message,
    stack: t.stack
  };
  for (const r in t)
    e[r] === void 0 && (e[r] = t[r]);
  return e;
}
function yk(t) {
  return typeof t.timestamp == "function" ? t.timestamp : t.timestamp === !1 ? _4 : E4;
}
function ad() {
  return {};
}
function Jg(t) {
  return t;
}
function yl() {
}
function _4() {
  return !1;
}
function E4() {
  return Date.now();
}
function wk() {
  return Math.round(Date.now() / 1e3);
}
function xk() {
  return new Date(Date.now()).toISOString();
}
function _k() {
  function t(e) {
    return typeof e < "u" && e;
  }
  try {
    return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
      get: function() {
        return delete Object.prototype.globalThis, this.globalThis = this;
      },
      configurable: !0
    }), globalThis;
  } catch {
    return t(self) || t(window) || t(this) || {};
  }
}
const jl = /* @__PURE__ */ ts(Yc), Ek = { level: "info" }, ql = "custom_context", kv = 1e3 * 1024;
let Sk = class {
  constructor(e) {
    this.nodeValue = e, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
}, Y2 = class {
  constructor(e) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e, this.sizeInBytes = 0;
  }
  append(e) {
    const r = new Sk(e);
    if (r.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${r.size}`);
    for (; this.size + r.size > this.maxSizeInBytes; ) this.shift();
    this.head ? (this.tail && (this.tail.next = r), this.tail = r) : (this.head = r, this.tail = r), this.lengthInNodes++, this.sizeInBytes += r.size;
  }
  shift() {
    if (!this.head) return;
    const e = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e.size;
  }
  toArray() {
    const e = [];
    let r = this.head;
    for (; r !== null; ) e.push(r.value), r = r.next;
    return e;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e = this.head;
    return { next: () => {
      if (!e) return { done: !0, value: null };
      const r = e.value;
      return e = e.next, { done: !1, value: r };
    } };
  }
}, S4 = class {
  constructor(e, r = kv) {
    this.level = e ?? "error", this.levelValue = Yc.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = r, this.logs = new Y2(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(e, r) {
    r === Yc.levels.values.error ? console.error(e) : r === Yc.levels.values.warn ? console.warn(e) : r === Yc.levels.values.debug ? console.debug(e) : r === Yc.levels.values.trace ? console.trace(e) : console.log(e);
  }
  appendToLogs(e) {
    this.logs.append(ko({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: e }));
    const r = typeof e == "string" ? JSON.parse(e).level : e.level;
    r >= this.levelValue && this.forwardToConsole(e, r);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new Y2(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(e) {
    const r = this.getLogArray();
    return r.push(ko({ extraMetadata: e })), new Blob(r, { type: "application/json" });
  }
}, Ak = class {
  constructor(e, r = kv) {
    this.baseChunkLogger = new S4(e, r);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
  downloadLogsBlobInBrowser(e) {
    const r = URL.createObjectURL(this.logsToBlob(e)), n = document.createElement("a");
    n.href = r, n.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(n), n.click(), document.body.removeChild(n), URL.revokeObjectURL(r);
  }
}, Pk = class {
  constructor(e, r = kv) {
    this.baseChunkLogger = new S4(e, r);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
};
var Mk = Object.defineProperty, Ik = Object.defineProperties, Ck = Object.getOwnPropertyDescriptors, J2 = Object.getOwnPropertySymbols, Tk = Object.prototype.hasOwnProperty, Rk = Object.prototype.propertyIsEnumerable, X2 = (t, e, r) => e in t ? Mk(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Yd = (t, e) => {
  for (var r in e || (e = {})) Tk.call(e, r) && X2(t, r, e[r]);
  if (J2) for (var r of J2(e)) Rk.call(e, r) && X2(t, r, e[r]);
  return t;
}, Jd = (t, e) => Ik(t, Ck(e));
function k0(t) {
  return Jd(Yd({}, t), { level: (t == null ? void 0 : t.level) || Ek.level });
}
function Dk(t, e = ql) {
  return t[e] || "";
}
function Ok(t, e, r = ql) {
  return t[r] = e, t;
}
function Si(t, e = ql) {
  let r = "";
  return typeof t.bindings > "u" ? r = Dk(t, e) : r = t.bindings().context || "", r;
}
function Nk(t, e, r = ql) {
  const n = Si(t, r);
  return n.trim() ? `${n}/${e}` : e;
}
function ai(t, e, r = ql) {
  const n = Nk(t, e, r), i = t.child({ context: n });
  return Ok(i, n, r);
}
function Lk(t) {
  var e, r;
  const n = new Ak((e = t.opts) == null ? void 0 : e.level, t.maxSizeInBytes);
  return { logger: jl(Jd(Yd({}, t.opts), { level: "trace", browser: Jd(Yd({}, (r = t.opts) == null ? void 0 : r.browser), { write: (i) => n.write(i) }) })), chunkLoggerController: n };
}
function kk(t) {
  var e;
  const r = new Pk((e = t.opts) == null ? void 0 : e.level, t.maxSizeInBytes);
  return { logger: jl(Jd(Yd({}, t.opts), { level: "trace" }), r), chunkLoggerController: r };
}
function $k(t) {
  return typeof t.loggerOverride < "u" && typeof t.loggerOverride != "string" ? { logger: t.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? Lk(t) : kk(t);
}
let Fk = class extends mc {
  constructor(e) {
    super(), this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, Bk = class extends mc {
  constructor(e, r) {
    super(), this.core = e, this.logger = r, this.records = /* @__PURE__ */ new Map();
  }
}, Uk = class {
  constructor(e, r) {
    this.logger = e, this.core = r;
  }
}, jk = class extends mc {
  constructor(e, r) {
    super(), this.relayer = e, this.logger = r;
  }
}, qk = class extends mc {
  constructor(e) {
    super();
  }
}, zk = class {
  constructor(e, r, n, i) {
    this.core = e, this.logger = r, this.name = n;
  }
}, Hk = class extends mc {
  constructor(e, r) {
    super(), this.relayer = e, this.logger = r;
  }
}, Wk = class extends mc {
  constructor(e, r) {
    super(), this.core = e, this.logger = r;
  }
}, Kk = class {
  constructor(e, r, n) {
    this.core = e, this.logger = r, this.store = n;
  }
}, Vk = class {
  constructor(e, r) {
    this.projectId = e, this.logger = r;
  }
}, Gk = class {
  constructor(e, r, n) {
    this.core = e, this.logger = r, this.telemetryEnabled = n;
  }
}, Yk = class {
  constructor(e) {
    this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, Jk = class {
  constructor(e) {
    this.client = e;
  }
};
var $v = {}, Pa = {}, $0 = {}, F0 = {};
Object.defineProperty(F0, "__esModule", { value: !0 });
F0.BrowserRandomSource = void 0;
const Z2 = 65536;
class Xk {
  constructor() {
    this.isAvailable = !1, this.isInstantiated = !1;
    const e = typeof self < "u" ? self.crypto || self.msCrypto : null;
    e && e.getRandomValues !== void 0 && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Browser random byte generator is not available.");
    const r = new Uint8Array(e);
    for (let n = 0; n < r.length; n += Z2)
      this._crypto.getRandomValues(r.subarray(n, n + Math.min(r.length - n, Z2)));
    return r;
  }
}
F0.BrowserRandomSource = Xk;
function A4(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var B0 = {}, ki = {};
Object.defineProperty(ki, "__esModule", { value: !0 });
function Zk(t) {
  for (var e = 0; e < t.length; e++)
    t[e] = 0;
  return t;
}
ki.wipe = Zk;
const Qk = {}, e$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Qk
}, Symbol.toStringTag, { value: "Module" })), zl = /* @__PURE__ */ bv(e$);
Object.defineProperty(B0, "__esModule", { value: !0 });
B0.NodeRandomSource = void 0;
const t$ = ki;
class r$ {
  constructor() {
    if (this.isAvailable = !1, this.isInstantiated = !1, typeof A4 < "u") {
      const e = zl;
      e && e.randomBytes && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
    }
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Node.js random byte generator is not available.");
    let r = this._crypto.randomBytes(e);
    if (r.length !== e)
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    const n = new Uint8Array(e);
    for (let i = 0; i < n.length; i++)
      n[i] = r[i];
    return (0, t$.wipe)(r), n;
  }
}
B0.NodeRandomSource = r$;
Object.defineProperty($0, "__esModule", { value: !0 });
$0.SystemRandomSource = void 0;
const n$ = F0, i$ = B0;
class s$ {
  constructor() {
    if (this.isAvailable = !1, this.name = "", this._source = new n$.BrowserRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Browser";
      return;
    }
    if (this._source = new i$.NodeRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Node";
      return;
    }
  }
  randomBytes(e) {
    if (!this.isAvailable)
      throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(e);
  }
}
$0.SystemRandomSource = s$;
var or = {}, P4 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(a, u) {
    var l = a >>> 16 & 65535, d = a & 65535, p = u >>> 16 & 65535, w = u & 65535;
    return d * w + (l * w + d * p << 16 >>> 0) | 0;
  }
  t.mul = Math.imul || e;
  function r(a, u) {
    return a + u | 0;
  }
  t.add = r;
  function n(a, u) {
    return a - u | 0;
  }
  t.sub = n;
  function i(a, u) {
    return a << u | a >>> 32 - u;
  }
  t.rotl = i;
  function s(a, u) {
    return a << 32 - u | a >>> u;
  }
  t.rotr = s;
  function o(a) {
    return typeof a == "number" && isFinite(a) && Math.floor(a) === a;
  }
  t.isInteger = Number.isInteger || o, t.MAX_SAFE_INTEGER = 9007199254740991, t.isSafeInteger = function(a) {
    return t.isInteger(a) && a >= -t.MAX_SAFE_INTEGER && a <= t.MAX_SAFE_INTEGER;
  };
})(P4);
Object.defineProperty(or, "__esModule", { value: !0 });
var M4 = P4;
function o$(t, e) {
  return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) << 16 >> 16;
}
or.readInt16BE = o$;
function a$(t, e) {
  return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) >>> 0;
}
or.readUint16BE = a$;
function c$(t, e) {
  return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) << 16 >> 16;
}
or.readInt16LE = c$;
function u$(t, e) {
  return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) >>> 0;
}
or.readUint16LE = u$;
function I4(t, e, r) {
  return e === void 0 && (e = new Uint8Array(2)), r === void 0 && (r = 0), e[r + 0] = t >>> 8, e[r + 1] = t >>> 0, e;
}
or.writeUint16BE = I4;
or.writeInt16BE = I4;
function C4(t, e, r) {
  return e === void 0 && (e = new Uint8Array(2)), r === void 0 && (r = 0), e[r + 0] = t >>> 0, e[r + 1] = t >>> 8, e;
}
or.writeUint16LE = C4;
or.writeInt16LE = C4;
function d1(t, e) {
  return e === void 0 && (e = 0), t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3];
}
or.readInt32BE = d1;
function p1(t, e) {
  return e === void 0 && (e = 0), (t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]) >>> 0;
}
or.readUint32BE = p1;
function g1(t, e) {
  return e === void 0 && (e = 0), t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e];
}
or.readInt32LE = g1;
function m1(t, e) {
  return e === void 0 && (e = 0), (t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e]) >>> 0;
}
or.readUint32LE = m1;
function Xd(t, e, r) {
  return e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0), e[r + 0] = t >>> 24, e[r + 1] = t >>> 16, e[r + 2] = t >>> 8, e[r + 3] = t >>> 0, e;
}
or.writeUint32BE = Xd;
or.writeInt32BE = Xd;
function Zd(t, e, r) {
  return e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0), e[r + 0] = t >>> 0, e[r + 1] = t >>> 8, e[r + 2] = t >>> 16, e[r + 3] = t >>> 24, e;
}
or.writeUint32LE = Zd;
or.writeInt32LE = Zd;
function f$(t, e) {
  e === void 0 && (e = 0);
  var r = d1(t, e), n = d1(t, e + 4);
  return r * 4294967296 + n - (n >> 31) * 4294967296;
}
or.readInt64BE = f$;
function l$(t, e) {
  e === void 0 && (e = 0);
  var r = p1(t, e), n = p1(t, e + 4);
  return r * 4294967296 + n;
}
or.readUint64BE = l$;
function h$(t, e) {
  e === void 0 && (e = 0);
  var r = g1(t, e), n = g1(t, e + 4);
  return n * 4294967296 + r - (r >> 31) * 4294967296;
}
or.readInt64LE = h$;
function d$(t, e) {
  e === void 0 && (e = 0);
  var r = m1(t, e), n = m1(t, e + 4);
  return n * 4294967296 + r;
}
or.readUint64LE = d$;
function T4(t, e, r) {
  return e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0), Xd(t / 4294967296 >>> 0, e, r), Xd(t >>> 0, e, r + 4), e;
}
or.writeUint64BE = T4;
or.writeInt64BE = T4;
function R4(t, e, r) {
  return e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0), Zd(t >>> 0, e, r), Zd(t / 4294967296 >>> 0, e, r + 4), e;
}
or.writeUint64LE = R4;
or.writeInt64LE = R4;
function p$(t, e, r) {
  if (r === void 0 && (r = 0), t % 8 !== 0)
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (t / 8 > e.length - r)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var n = 0, i = 1, s = t / 8 + r - 1; s >= r; s--)
    n += e[s] * i, i *= 256;
  return n;
}
or.readUintBE = p$;
function g$(t, e, r) {
  if (r === void 0 && (r = 0), t % 8 !== 0)
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (t / 8 > e.length - r)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var n = 0, i = 1, s = r; s < r + t / 8; s++)
    n += e[s] * i, i *= 256;
  return n;
}
or.readUintLE = g$;
function m$(t, e, r, n) {
  if (r === void 0 && (r = new Uint8Array(t / 8)), n === void 0 && (n = 0), t % 8 !== 0)
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!M4.isSafeInteger(e))
    throw new Error("writeUintBE value must be an integer");
  for (var i = 1, s = t / 8 + n - 1; s >= n; s--)
    r[s] = e / i & 255, i *= 256;
  return r;
}
or.writeUintBE = m$;
function v$(t, e, r, n) {
  if (r === void 0 && (r = new Uint8Array(t / 8)), n === void 0 && (n = 0), t % 8 !== 0)
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!M4.isSafeInteger(e))
    throw new Error("writeUintLE value must be an integer");
  for (var i = 1, s = n; s < n + t / 8; s++)
    r[s] = e / i & 255, i *= 256;
  return r;
}
or.writeUintLE = v$;
function b$(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat32(e);
}
or.readFloat32BE = b$;
function y$(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat32(e, !0);
}
or.readFloat32LE = y$;
function w$(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat64(e);
}
or.readFloat64BE = w$;
function x$(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat64(e, !0);
}
or.readFloat64LE = x$;
function _$(t, e, r) {
  e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat32(r, t), e;
}
or.writeFloat32BE = _$;
function E$(t, e, r) {
  e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat32(r, t, !0), e;
}
or.writeFloat32LE = E$;
function S$(t, e, r) {
  e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat64(r, t), e;
}
or.writeFloat64BE = S$;
function A$(t, e, r) {
  e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat64(r, t, !0), e;
}
or.writeFloat64LE = A$;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.randomStringForEntropy = t.randomString = t.randomUint32 = t.randomBytes = t.defaultRandomSource = void 0;
  const e = $0, r = or, n = ki;
  t.defaultRandomSource = new e.SystemRandomSource();
  function i(l, d = t.defaultRandomSource) {
    return d.randomBytes(l);
  }
  t.randomBytes = i;
  function s(l = t.defaultRandomSource) {
    const d = i(4, l), p = (0, r.readUint32LE)(d);
    return (0, n.wipe)(d), p;
  }
  t.randomUint32 = s;
  const o = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function a(l, d = o, p = t.defaultRandomSource) {
    if (d.length < 2)
      throw new Error("randomString charset is too short");
    if (d.length > 256)
      throw new Error("randomString charset is too long");
    let w = "";
    const P = d.length, A = 256 - 256 % P;
    for (; l > 0; ) {
      const N = i(Math.ceil(l * 256 / A), p);
      for (let L = 0; L < N.length && l > 0; L++) {
        const F = N[L];
        F < A && (w += d.charAt(F % P), l--);
      }
      (0, n.wipe)(N);
    }
    return w;
  }
  t.randomString = a;
  function u(l, d = o, p = t.defaultRandomSource) {
    const w = Math.ceil(l / (Math.log(d.length) / Math.LN2));
    return a(w, d, p);
  }
  t.randomStringForEntropy = u;
})(Pa);
var D4 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = or, r = ki;
  t.DIGEST_LENGTH = 64, t.BLOCK_SIZE = 128;
  var n = (
    /** @class */
    function() {
      function a() {
        this.digestLength = t.DIGEST_LENGTH, this.blockSize = t.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return a.prototype._initState = function() {
        this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209;
      }, a.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, a.prototype.clean = function() {
        r.wipe(this._buffer), r.wipe(this._tempHi), r.wipe(this._tempLo), this.reset();
      }, a.prototype.update = function(u, l) {
        if (l === void 0 && (l = u.length), this._finished)
          throw new Error("SHA512: can't update because hash was finished.");
        var d = 0;
        if (this._bytesHashed += l, this._bufferLength > 0) {
          for (; this._bufferLength < t.BLOCK_SIZE && l > 0; )
            this._buffer[this._bufferLength++] = u[d++], l--;
          this._bufferLength === this.blockSize && (s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (l >= this.blockSize && (d = s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, u, d, l), l %= this.blockSize); l > 0; )
          this._buffer[this._bufferLength++] = u[d++], l--;
        return this;
      }, a.prototype.finish = function(u) {
        if (!this._finished) {
          var l = this._bytesHashed, d = this._bufferLength, p = l / 536870912 | 0, w = l << 3, P = l % 128 < 112 ? 128 : 256;
          this._buffer[d] = 128;
          for (var A = d + 1; A < P - 8; A++)
            this._buffer[A] = 0;
          e.writeUint32BE(p, this._buffer, P - 8), e.writeUint32BE(w, this._buffer, P - 4), s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, P), this._finished = !0;
        }
        for (var A = 0; A < this.digestLength / 8; A++)
          e.writeUint32BE(this._stateHi[A], u, A * 8), e.writeUint32BE(this._stateLo[A], u, A * 8 + 4);
        return this;
      }, a.prototype.digest = function() {
        var u = new Uint8Array(this.digestLength);
        return this.finish(u), u;
      }, a.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, a.prototype.restoreState = function(u) {
        return this._stateHi.set(u.stateHi), this._stateLo.set(u.stateLo), this._bufferLength = u.bufferLength, u.buffer && this._buffer.set(u.buffer), this._bytesHashed = u.bytesHashed, this._finished = !1, this;
      }, a.prototype.cleanSavedState = function(u) {
        r.wipe(u.stateHi), r.wipe(u.stateLo), u.buffer && r.wipe(u.buffer), u.bufferLength = 0, u.bytesHashed = 0;
      }, a;
    }()
  );
  t.SHA512 = n;
  var i = new Int32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  function s(a, u, l, d, p, w, P) {
    for (var A = l[0], N = l[1], L = l[2], F = l[3], $ = l[4], K = l[5], H = l[6], V = l[7], te = d[0], R = d[1], W = d[2], pe = d[3], Ee = d[4], Y = d[5], S = d[6], m = d[7], f, g, b, x, _, E, v, M; P >= 128; ) {
      for (var I = 0; I < 16; I++) {
        var B = 8 * I + w;
        a[I] = e.readUint32BE(p, B), u[I] = e.readUint32BE(p, B + 4);
      }
      for (var I = 0; I < 80; I++) {
        var ce = A, D = N, oe = L, Z = F, J = $, Q = K, T = H, X = V, re = te, de = R, ie = W, ue = pe, ve = Ee, Pe = Y, De = S, Ce = m;
        if (f = V, g = m, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = ($ >>> 14 | Ee << 18) ^ ($ >>> 18 | Ee << 14) ^ (Ee >>> 9 | $ << 23), g = (Ee >>> 14 | $ << 18) ^ (Ee >>> 18 | $ << 14) ^ ($ >>> 9 | Ee << 23), _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, f = $ & K ^ ~$ & H, g = Ee & Y ^ ~Ee & S, _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, f = i[I * 2], g = i[I * 2 + 1], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, f = a[I % 16], g = u[I % 16], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, b = v & 65535 | M << 16, x = _ & 65535 | E << 16, f = b, g = x, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = (A >>> 28 | te << 4) ^ (te >>> 2 | A << 30) ^ (te >>> 7 | A << 25), g = (te >>> 28 | A << 4) ^ (A >>> 2 | te << 30) ^ (A >>> 7 | te << 25), _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, f = A & N ^ A & L ^ N & L, g = te & R ^ te & W ^ R & W, _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, X = v & 65535 | M << 16, Ce = _ & 65535 | E << 16, f = Z, g = ue, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = b, g = x, _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, Z = v & 65535 | M << 16, ue = _ & 65535 | E << 16, N = ce, L = D, F = oe, $ = Z, K = J, H = Q, V = T, A = X, R = re, W = de, pe = ie, Ee = ue, Y = ve, S = Pe, m = De, te = Ce, I % 16 === 15)
          for (var B = 0; B < 16; B++)
            f = a[B], g = u[B], _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = a[(B + 9) % 16], g = u[(B + 9) % 16], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, b = a[(B + 1) % 16], x = u[(B + 1) % 16], f = (b >>> 1 | x << 31) ^ (b >>> 8 | x << 24) ^ b >>> 7, g = (x >>> 1 | b << 31) ^ (x >>> 8 | b << 24) ^ (x >>> 7 | b << 25), _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, b = a[(B + 14) % 16], x = u[(B + 14) % 16], f = (b >>> 19 | x << 13) ^ (x >>> 29 | b << 3) ^ b >>> 6, g = (x >>> 19 | b << 13) ^ (b >>> 29 | x << 3) ^ (x >>> 6 | b << 26), _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, a[B] = v & 65535 | M << 16, u[B] = _ & 65535 | E << 16;
      }
      f = A, g = te, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = l[0], g = d[0], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, l[0] = A = v & 65535 | M << 16, d[0] = te = _ & 65535 | E << 16, f = N, g = R, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = l[1], g = d[1], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, l[1] = N = v & 65535 | M << 16, d[1] = R = _ & 65535 | E << 16, f = L, g = W, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = l[2], g = d[2], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, l[2] = L = v & 65535 | M << 16, d[2] = W = _ & 65535 | E << 16, f = F, g = pe, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = l[3], g = d[3], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, l[3] = F = v & 65535 | M << 16, d[3] = pe = _ & 65535 | E << 16, f = $, g = Ee, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = l[4], g = d[4], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, l[4] = $ = v & 65535 | M << 16, d[4] = Ee = _ & 65535 | E << 16, f = K, g = Y, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = l[5], g = d[5], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, l[5] = K = v & 65535 | M << 16, d[5] = Y = _ & 65535 | E << 16, f = H, g = S, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = l[6], g = d[6], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, l[6] = H = v & 65535 | M << 16, d[6] = S = _ & 65535 | E << 16, f = V, g = m, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = l[7], g = d[7], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, l[7] = V = v & 65535 | M << 16, d[7] = m = _ & 65535 | E << 16, w += 128, P -= 128;
    }
    return w;
  }
  function o(a) {
    var u = new n();
    u.update(a);
    var l = u.digest();
    return u.clean(), l;
  }
  t.hash = o;
})(D4);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.convertSecretKeyToX25519 = t.convertPublicKeyToX25519 = t.verify = t.sign = t.extractPublicKeyFromSecretKey = t.generateKeyPair = t.generateKeyPairFromSeed = t.SEED_LENGTH = t.SECRET_KEY_LENGTH = t.PUBLIC_KEY_LENGTH = t.SIGNATURE_LENGTH = void 0;
  const e = Pa, r = D4, n = ki;
  t.SIGNATURE_LENGTH = 64, t.PUBLIC_KEY_LENGTH = 32, t.SECRET_KEY_LENGTH = 64, t.SEED_LENGTH = 32;
  function i(Z) {
    const J = new Float64Array(16);
    if (Z)
      for (let Q = 0; Q < Z.length; Q++)
        J[Q] = Z[Q];
    return J;
  }
  const s = new Uint8Array(32);
  s[0] = 9;
  const o = i(), a = i([1]), u = i([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]), l = i([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]), d = i([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]), p = i([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]), w = i([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function P(Z, J) {
    for (let Q = 0; Q < 16; Q++)
      Z[Q] = J[Q] | 0;
  }
  function A(Z) {
    let J = 1;
    for (let Q = 0; Q < 16; Q++) {
      let T = Z[Q] + J + 65535;
      J = Math.floor(T / 65536), Z[Q] = T - J * 65536;
    }
    Z[0] += J - 1 + 37 * (J - 1);
  }
  function N(Z, J, Q) {
    const T = ~(Q - 1);
    for (let X = 0; X < 16; X++) {
      const re = T & (Z[X] ^ J[X]);
      Z[X] ^= re, J[X] ^= re;
    }
  }
  function L(Z, J) {
    const Q = i(), T = i();
    for (let X = 0; X < 16; X++)
      T[X] = J[X];
    A(T), A(T), A(T);
    for (let X = 0; X < 2; X++) {
      Q[0] = T[0] - 65517;
      for (let de = 1; de < 15; de++)
        Q[de] = T[de] - 65535 - (Q[de - 1] >> 16 & 1), Q[de - 1] &= 65535;
      Q[15] = T[15] - 32767 - (Q[14] >> 16 & 1);
      const re = Q[15] >> 16 & 1;
      Q[14] &= 65535, N(T, Q, 1 - re);
    }
    for (let X = 0; X < 16; X++)
      Z[2 * X] = T[X] & 255, Z[2 * X + 1] = T[X] >> 8;
  }
  function F(Z, J) {
    let Q = 0;
    for (let T = 0; T < 32; T++)
      Q |= Z[T] ^ J[T];
    return (1 & Q - 1 >>> 8) - 1;
  }
  function $(Z, J) {
    const Q = new Uint8Array(32), T = new Uint8Array(32);
    return L(Q, Z), L(T, J), F(Q, T);
  }
  function K(Z) {
    const J = new Uint8Array(32);
    return L(J, Z), J[0] & 1;
  }
  function H(Z, J) {
    for (let Q = 0; Q < 16; Q++)
      Z[Q] = J[2 * Q] + (J[2 * Q + 1] << 8);
    Z[15] &= 32767;
  }
  function V(Z, J, Q) {
    for (let T = 0; T < 16; T++)
      Z[T] = J[T] + Q[T];
  }
  function te(Z, J, Q) {
    for (let T = 0; T < 16; T++)
      Z[T] = J[T] - Q[T];
  }
  function R(Z, J, Q) {
    let T, X, re = 0, de = 0, ie = 0, ue = 0, ve = 0, Pe = 0, De = 0, Ce = 0, $e = 0, Me = 0, Ne = 0, Ke = 0, Le = 0, qe = 0, ze = 0, _e = 0, Ze = 0, at = 0, ke = 0, Qe = 0, tt = 0, Ye = 0, dt = 0, lt = 0, ct = 0, qt = 0, Yt = 0, Et = 0, Qt = 0, Jt = 0, Dt = 0, kt = Q[0], Ct = Q[1], gt = Q[2], Rt = Q[3], Nt = Q[4], vt = Q[5], $t = Q[6], Bt = Q[7], rt = Q[8], Ft = Q[9], k = Q[10], j = Q[11], z = Q[12], C = Q[13], G = Q[14], U = Q[15];
    T = J[0], re += T * kt, de += T * Ct, ie += T * gt, ue += T * Rt, ve += T * Nt, Pe += T * vt, De += T * $t, Ce += T * Bt, $e += T * rt, Me += T * Ft, Ne += T * k, Ke += T * j, Le += T * z, qe += T * C, ze += T * G, _e += T * U, T = J[1], de += T * kt, ie += T * Ct, ue += T * gt, ve += T * Rt, Pe += T * Nt, De += T * vt, Ce += T * $t, $e += T * Bt, Me += T * rt, Ne += T * Ft, Ke += T * k, Le += T * j, qe += T * z, ze += T * C, _e += T * G, Ze += T * U, T = J[2], ie += T * kt, ue += T * Ct, ve += T * gt, Pe += T * Rt, De += T * Nt, Ce += T * vt, $e += T * $t, Me += T * Bt, Ne += T * rt, Ke += T * Ft, Le += T * k, qe += T * j, ze += T * z, _e += T * C, Ze += T * G, at += T * U, T = J[3], ue += T * kt, ve += T * Ct, Pe += T * gt, De += T * Rt, Ce += T * Nt, $e += T * vt, Me += T * $t, Ne += T * Bt, Ke += T * rt, Le += T * Ft, qe += T * k, ze += T * j, _e += T * z, Ze += T * C, at += T * G, ke += T * U, T = J[4], ve += T * kt, Pe += T * Ct, De += T * gt, Ce += T * Rt, $e += T * Nt, Me += T * vt, Ne += T * $t, Ke += T * Bt, Le += T * rt, qe += T * Ft, ze += T * k, _e += T * j, Ze += T * z, at += T * C, ke += T * G, Qe += T * U, T = J[5], Pe += T * kt, De += T * Ct, Ce += T * gt, $e += T * Rt, Me += T * Nt, Ne += T * vt, Ke += T * $t, Le += T * Bt, qe += T * rt, ze += T * Ft, _e += T * k, Ze += T * j, at += T * z, ke += T * C, Qe += T * G, tt += T * U, T = J[6], De += T * kt, Ce += T * Ct, $e += T * gt, Me += T * Rt, Ne += T * Nt, Ke += T * vt, Le += T * $t, qe += T * Bt, ze += T * rt, _e += T * Ft, Ze += T * k, at += T * j, ke += T * z, Qe += T * C, tt += T * G, Ye += T * U, T = J[7], Ce += T * kt, $e += T * Ct, Me += T * gt, Ne += T * Rt, Ke += T * Nt, Le += T * vt, qe += T * $t, ze += T * Bt, _e += T * rt, Ze += T * Ft, at += T * k, ke += T * j, Qe += T * z, tt += T * C, Ye += T * G, dt += T * U, T = J[8], $e += T * kt, Me += T * Ct, Ne += T * gt, Ke += T * Rt, Le += T * Nt, qe += T * vt, ze += T * $t, _e += T * Bt, Ze += T * rt, at += T * Ft, ke += T * k, Qe += T * j, tt += T * z, Ye += T * C, dt += T * G, lt += T * U, T = J[9], Me += T * kt, Ne += T * Ct, Ke += T * gt, Le += T * Rt, qe += T * Nt, ze += T * vt, _e += T * $t, Ze += T * Bt, at += T * rt, ke += T * Ft, Qe += T * k, tt += T * j, Ye += T * z, dt += T * C, lt += T * G, ct += T * U, T = J[10], Ne += T * kt, Ke += T * Ct, Le += T * gt, qe += T * Rt, ze += T * Nt, _e += T * vt, Ze += T * $t, at += T * Bt, ke += T * rt, Qe += T * Ft, tt += T * k, Ye += T * j, dt += T * z, lt += T * C, ct += T * G, qt += T * U, T = J[11], Ke += T * kt, Le += T * Ct, qe += T * gt, ze += T * Rt, _e += T * Nt, Ze += T * vt, at += T * $t, ke += T * Bt, Qe += T * rt, tt += T * Ft, Ye += T * k, dt += T * j, lt += T * z, ct += T * C, qt += T * G, Yt += T * U, T = J[12], Le += T * kt, qe += T * Ct, ze += T * gt, _e += T * Rt, Ze += T * Nt, at += T * vt, ke += T * $t, Qe += T * Bt, tt += T * rt, Ye += T * Ft, dt += T * k, lt += T * j, ct += T * z, qt += T * C, Yt += T * G, Et += T * U, T = J[13], qe += T * kt, ze += T * Ct, _e += T * gt, Ze += T * Rt, at += T * Nt, ke += T * vt, Qe += T * $t, tt += T * Bt, Ye += T * rt, dt += T * Ft, lt += T * k, ct += T * j, qt += T * z, Yt += T * C, Et += T * G, Qt += T * U, T = J[14], ze += T * kt, _e += T * Ct, Ze += T * gt, at += T * Rt, ke += T * Nt, Qe += T * vt, tt += T * $t, Ye += T * Bt, dt += T * rt, lt += T * Ft, ct += T * k, qt += T * j, Yt += T * z, Et += T * C, Qt += T * G, Jt += T * U, T = J[15], _e += T * kt, Ze += T * Ct, at += T * gt, ke += T * Rt, Qe += T * Nt, tt += T * vt, Ye += T * $t, dt += T * Bt, lt += T * rt, ct += T * Ft, qt += T * k, Yt += T * j, Et += T * z, Qt += T * C, Jt += T * G, Dt += T * U, re += 38 * Ze, de += 38 * at, ie += 38 * ke, ue += 38 * Qe, ve += 38 * tt, Pe += 38 * Ye, De += 38 * dt, Ce += 38 * lt, $e += 38 * ct, Me += 38 * qt, Ne += 38 * Yt, Ke += 38 * Et, Le += 38 * Qt, qe += 38 * Jt, ze += 38 * Dt, X = 1, T = re + X + 65535, X = Math.floor(T / 65536), re = T - X * 65536, T = de + X + 65535, X = Math.floor(T / 65536), de = T - X * 65536, T = ie + X + 65535, X = Math.floor(T / 65536), ie = T - X * 65536, T = ue + X + 65535, X = Math.floor(T / 65536), ue = T - X * 65536, T = ve + X + 65535, X = Math.floor(T / 65536), ve = T - X * 65536, T = Pe + X + 65535, X = Math.floor(T / 65536), Pe = T - X * 65536, T = De + X + 65535, X = Math.floor(T / 65536), De = T - X * 65536, T = Ce + X + 65535, X = Math.floor(T / 65536), Ce = T - X * 65536, T = $e + X + 65535, X = Math.floor(T / 65536), $e = T - X * 65536, T = Me + X + 65535, X = Math.floor(T / 65536), Me = T - X * 65536, T = Ne + X + 65535, X = Math.floor(T / 65536), Ne = T - X * 65536, T = Ke + X + 65535, X = Math.floor(T / 65536), Ke = T - X * 65536, T = Le + X + 65535, X = Math.floor(T / 65536), Le = T - X * 65536, T = qe + X + 65535, X = Math.floor(T / 65536), qe = T - X * 65536, T = ze + X + 65535, X = Math.floor(T / 65536), ze = T - X * 65536, T = _e + X + 65535, X = Math.floor(T / 65536), _e = T - X * 65536, re += X - 1 + 37 * (X - 1), X = 1, T = re + X + 65535, X = Math.floor(T / 65536), re = T - X * 65536, T = de + X + 65535, X = Math.floor(T / 65536), de = T - X * 65536, T = ie + X + 65535, X = Math.floor(T / 65536), ie = T - X * 65536, T = ue + X + 65535, X = Math.floor(T / 65536), ue = T - X * 65536, T = ve + X + 65535, X = Math.floor(T / 65536), ve = T - X * 65536, T = Pe + X + 65535, X = Math.floor(T / 65536), Pe = T - X * 65536, T = De + X + 65535, X = Math.floor(T / 65536), De = T - X * 65536, T = Ce + X + 65535, X = Math.floor(T / 65536), Ce = T - X * 65536, T = $e + X + 65535, X = Math.floor(T / 65536), $e = T - X * 65536, T = Me + X + 65535, X = Math.floor(T / 65536), Me = T - X * 65536, T = Ne + X + 65535, X = Math.floor(T / 65536), Ne = T - X * 65536, T = Ke + X + 65535, X = Math.floor(T / 65536), Ke = T - X * 65536, T = Le + X + 65535, X = Math.floor(T / 65536), Le = T - X * 65536, T = qe + X + 65535, X = Math.floor(T / 65536), qe = T - X * 65536, T = ze + X + 65535, X = Math.floor(T / 65536), ze = T - X * 65536, T = _e + X + 65535, X = Math.floor(T / 65536), _e = T - X * 65536, re += X - 1 + 37 * (X - 1), Z[0] = re, Z[1] = de, Z[2] = ie, Z[3] = ue, Z[4] = ve, Z[5] = Pe, Z[6] = De, Z[7] = Ce, Z[8] = $e, Z[9] = Me, Z[10] = Ne, Z[11] = Ke, Z[12] = Le, Z[13] = qe, Z[14] = ze, Z[15] = _e;
  }
  function W(Z, J) {
    R(Z, J, J);
  }
  function pe(Z, J) {
    const Q = i();
    let T;
    for (T = 0; T < 16; T++)
      Q[T] = J[T];
    for (T = 253; T >= 0; T--)
      W(Q, Q), T !== 2 && T !== 4 && R(Q, Q, J);
    for (T = 0; T < 16; T++)
      Z[T] = Q[T];
  }
  function Ee(Z, J) {
    const Q = i();
    let T;
    for (T = 0; T < 16; T++)
      Q[T] = J[T];
    for (T = 250; T >= 0; T--)
      W(Q, Q), T !== 1 && R(Q, Q, J);
    for (T = 0; T < 16; T++)
      Z[T] = Q[T];
  }
  function Y(Z, J) {
    const Q = i(), T = i(), X = i(), re = i(), de = i(), ie = i(), ue = i(), ve = i(), Pe = i();
    te(Q, Z[1], Z[0]), te(Pe, J[1], J[0]), R(Q, Q, Pe), V(T, Z[0], Z[1]), V(Pe, J[0], J[1]), R(T, T, Pe), R(X, Z[3], J[3]), R(X, X, l), R(re, Z[2], J[2]), V(re, re, re), te(de, T, Q), te(ie, re, X), V(ue, re, X), V(ve, T, Q), R(Z[0], de, ie), R(Z[1], ve, ue), R(Z[2], ue, ie), R(Z[3], de, ve);
  }
  function S(Z, J, Q) {
    for (let T = 0; T < 4; T++)
      N(Z[T], J[T], Q);
  }
  function m(Z, J) {
    const Q = i(), T = i(), X = i();
    pe(X, J[2]), R(Q, J[0], X), R(T, J[1], X), L(Z, T), Z[31] ^= K(Q) << 7;
  }
  function f(Z, J, Q) {
    P(Z[0], o), P(Z[1], a), P(Z[2], a), P(Z[3], o);
    for (let T = 255; T >= 0; --T) {
      const X = Q[T / 8 | 0] >> (T & 7) & 1;
      S(Z, J, X), Y(J, Z), Y(Z, Z), S(Z, J, X);
    }
  }
  function g(Z, J) {
    const Q = [i(), i(), i(), i()];
    P(Q[0], d), P(Q[1], p), P(Q[2], a), R(Q[3], d, p), f(Z, Q, J);
  }
  function b(Z) {
    if (Z.length !== t.SEED_LENGTH)
      throw new Error(`ed25519: seed must be ${t.SEED_LENGTH} bytes`);
    const J = (0, r.hash)(Z);
    J[0] &= 248, J[31] &= 127, J[31] |= 64;
    const Q = new Uint8Array(32), T = [i(), i(), i(), i()];
    g(T, J), m(Q, T);
    const X = new Uint8Array(64);
    return X.set(Z), X.set(Q, 32), {
      publicKey: Q,
      secretKey: X
    };
  }
  t.generateKeyPairFromSeed = b;
  function x(Z) {
    const J = (0, e.randomBytes)(32, Z), Q = b(J);
    return (0, n.wipe)(J), Q;
  }
  t.generateKeyPair = x;
  function _(Z) {
    if (Z.length !== t.SECRET_KEY_LENGTH)
      throw new Error(`ed25519: secret key must be ${t.SECRET_KEY_LENGTH} bytes`);
    return new Uint8Array(Z.subarray(32));
  }
  t.extractPublicKeyFromSecretKey = _;
  const E = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function v(Z, J) {
    let Q, T, X, re;
    for (T = 63; T >= 32; --T) {
      for (Q = 0, X = T - 32, re = T - 12; X < re; ++X)
        J[X] += Q - 16 * J[T] * E[X - (T - 32)], Q = Math.floor((J[X] + 128) / 256), J[X] -= Q * 256;
      J[X] += Q, J[T] = 0;
    }
    for (Q = 0, X = 0; X < 32; X++)
      J[X] += Q - (J[31] >> 4) * E[X], Q = J[X] >> 8, J[X] &= 255;
    for (X = 0; X < 32; X++)
      J[X] -= Q * E[X];
    for (T = 0; T < 32; T++)
      J[T + 1] += J[T] >> 8, Z[T] = J[T] & 255;
  }
  function M(Z) {
    const J = new Float64Array(64);
    for (let Q = 0; Q < 64; Q++)
      J[Q] = Z[Q];
    for (let Q = 0; Q < 64; Q++)
      Z[Q] = 0;
    v(Z, J);
  }
  function I(Z, J) {
    const Q = new Float64Array(64), T = [i(), i(), i(), i()], X = (0, r.hash)(Z.subarray(0, 32));
    X[0] &= 248, X[31] &= 127, X[31] |= 64;
    const re = new Uint8Array(64);
    re.set(X.subarray(32), 32);
    const de = new r.SHA512();
    de.update(re.subarray(32)), de.update(J);
    const ie = de.digest();
    de.clean(), M(ie), g(T, ie), m(re, T), de.reset(), de.update(re.subarray(0, 32)), de.update(Z.subarray(32)), de.update(J);
    const ue = de.digest();
    M(ue);
    for (let ve = 0; ve < 32; ve++)
      Q[ve] = ie[ve];
    for (let ve = 0; ve < 32; ve++)
      for (let Pe = 0; Pe < 32; Pe++)
        Q[ve + Pe] += ue[ve] * X[Pe];
    return v(re.subarray(32), Q), re;
  }
  t.sign = I;
  function B(Z, J) {
    const Q = i(), T = i(), X = i(), re = i(), de = i(), ie = i(), ue = i();
    return P(Z[2], a), H(Z[1], J), W(X, Z[1]), R(re, X, u), te(X, X, Z[2]), V(re, Z[2], re), W(de, re), W(ie, de), R(ue, ie, de), R(Q, ue, X), R(Q, Q, re), Ee(Q, Q), R(Q, Q, X), R(Q, Q, re), R(Q, Q, re), R(Z[0], Q, re), W(T, Z[0]), R(T, T, re), $(T, X) && R(Z[0], Z[0], w), W(T, Z[0]), R(T, T, re), $(T, X) ? -1 : (K(Z[0]) === J[31] >> 7 && te(Z[0], o, Z[0]), R(Z[3], Z[0], Z[1]), 0);
  }
  function ce(Z, J, Q) {
    const T = new Uint8Array(32), X = [i(), i(), i(), i()], re = [i(), i(), i(), i()];
    if (Q.length !== t.SIGNATURE_LENGTH)
      throw new Error(`ed25519: signature must be ${t.SIGNATURE_LENGTH} bytes`);
    if (B(re, Z))
      return !1;
    const de = new r.SHA512();
    de.update(Q.subarray(0, 32)), de.update(Z), de.update(J);
    const ie = de.digest();
    return M(ie), f(X, re, ie), g(re, Q.subarray(32)), Y(X, re), m(T, X), !F(Q, T);
  }
  t.verify = ce;
  function D(Z) {
    let J = [i(), i(), i(), i()];
    if (B(J, Z))
      throw new Error("Ed25519: invalid public key");
    let Q = i(), T = i(), X = J[1];
    V(Q, a, X), te(T, a, X), pe(T, T), R(Q, Q, T);
    let re = new Uint8Array(32);
    return L(re, Q), re;
  }
  t.convertPublicKeyToX25519 = D;
  function oe(Z) {
    const J = (0, r.hash)(Z.subarray(0, 32));
    J[0] &= 248, J[31] &= 127, J[31] |= 64;
    const Q = new Uint8Array(J.subarray(0, 32));
    return (0, n.wipe)(J), Q;
  }
  t.convertSecretKeyToX25519 = oe;
})($v);
const P$ = "EdDSA", M$ = "JWT", Qd = ".", U0 = "base64url", O4 = "utf8", N4 = "utf8", I$ = ":", C$ = "did", T$ = "key", Q2 = "base58btc", R$ = "z", D$ = "K36", O$ = 32;
function L4(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(t) : new Uint8Array(t);
}
function Ed(t, e) {
  e || (e = t.reduce((i, s) => i + s.length, 0));
  const r = L4(e);
  let n = 0;
  for (const i of t)
    r.set(i, n), n += i.length;
  return r;
}
function N$(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++)
    r[n] = 255;
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i), o = s.charCodeAt(0);
    if (r[o] !== 255)
      throw new TypeError(s + " is ambiguous");
    r[o] = i;
  }
  var a = t.length, u = t.charAt(0), l = Math.log(a) / Math.log(256), d = Math.log(256) / Math.log(a);
  function p(A) {
    if (A instanceof Uint8Array || (ArrayBuffer.isView(A) ? A = new Uint8Array(A.buffer, A.byteOffset, A.byteLength) : Array.isArray(A) && (A = Uint8Array.from(A))), !(A instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (A.length === 0)
      return "";
    for (var N = 0, L = 0, F = 0, $ = A.length; F !== $ && A[F] === 0; )
      F++, N++;
    for (var K = ($ - F) * d + 1 >>> 0, H = new Uint8Array(K); F !== $; ) {
      for (var V = A[F], te = 0, R = K - 1; (V !== 0 || te < L) && R !== -1; R--, te++)
        V += 256 * H[R] >>> 0, H[R] = V % a >>> 0, V = V / a >>> 0;
      if (V !== 0)
        throw new Error("Non-zero carry");
      L = te, F++;
    }
    for (var W = K - L; W !== K && H[W] === 0; )
      W++;
    for (var pe = u.repeat(N); W < K; ++W)
      pe += t.charAt(H[W]);
    return pe;
  }
  function w(A) {
    if (typeof A != "string")
      throw new TypeError("Expected String");
    if (A.length === 0)
      return new Uint8Array();
    var N = 0;
    if (A[N] !== " ") {
      for (var L = 0, F = 0; A[N] === u; )
        L++, N++;
      for (var $ = (A.length - N) * l + 1 >>> 0, K = new Uint8Array($); A[N]; ) {
        var H = r[A.charCodeAt(N)];
        if (H === 255)
          return;
        for (var V = 0, te = $ - 1; (H !== 0 || V < F) && te !== -1; te--, V++)
          H += a * K[te] >>> 0, K[te] = H % 256 >>> 0, H = H / 256 >>> 0;
        if (H !== 0)
          throw new Error("Non-zero carry");
        F = V, N++;
      }
      if (A[N] !== " ") {
        for (var R = $ - F; R !== $ && K[R] === 0; )
          R++;
        for (var W = new Uint8Array(L + ($ - R)), pe = L; R !== $; )
          W[pe++] = K[R++];
        return W;
      }
    }
  }
  function P(A) {
    var N = w(A);
    if (N)
      return N;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: p,
    decodeUnsafe: w,
    decode: P
  };
}
var L$ = N$, k$ = L$;
const $$ = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, F$ = (t) => new TextEncoder().encode(t), B$ = (t) => new TextDecoder().decode(t);
class U$ {
  constructor(e, r, n) {
    this.name = e, this.prefix = r, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class j$ {
  constructor(e, r, n) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return k4(this, e);
  }
}
class q$ {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return k4(this, e);
  }
  decode(e) {
    const r = e[0], n = this.decoders[r];
    if (n)
      return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const k4 = (t, e) => new q$({
  ...t.decoders || { [t.prefix]: t },
  ...e.decoders || { [e.prefix]: e }
});
class z$ {
  constructor(e, r, n, i) {
    this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = i, this.encoder = new U$(e, r, n), this.decoder = new j$(e, r, i);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const j0 = ({ name: t, prefix: e, encode: r, decode: n }) => new z$(t, e, r, n), Hl = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: n, decode: i } = k$(r, e);
  return j0({
    prefix: t,
    name: e,
    encode: n,
    decode: (s) => $$(i(s))
  });
}, H$ = (t, e, r, n) => {
  const i = {};
  for (let d = 0; d < e.length; ++d)
    i[e[d]] = d;
  let s = t.length;
  for (; t[s - 1] === "="; )
    --s;
  const o = new Uint8Array(s * r / 8 | 0);
  let a = 0, u = 0, l = 0;
  for (let d = 0; d < s; ++d) {
    const p = i[t[d]];
    if (p === void 0)
      throw new SyntaxError(`Non-${n} character`);
    u = u << r | p, a += r, a >= 8 && (a -= 8, o[l++] = 255 & u >> a);
  }
  if (a >= r || 255 & u << 8 - a)
    throw new SyntaxError("Unexpected end of data");
  return o;
}, W$ = (t, e, r) => {
  const n = e[e.length - 1] === "=", i = (1 << r) - 1;
  let s = "", o = 0, a = 0;
  for (let u = 0; u < t.length; ++u)
    for (a = a << 8 | t[u], o += 8; o > r; )
      o -= r, s += e[i & a >> o];
  if (o && (s += e[i & a << r - o]), n)
    for (; s.length * r & 7; )
      s += "=";
  return s;
}, jn = ({ name: t, prefix: e, bitsPerChar: r, alphabet: n }) => j0({
  prefix: e,
  name: t,
  encode(i) {
    return W$(i, n, r);
  },
  decode(i) {
    return H$(i, n, r, t);
  }
}), K$ = j0({
  prefix: "\0",
  name: "identity",
  encode: (t) => B$(t),
  decode: (t) => F$(t)
}), V$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: K$
}, Symbol.toStringTag, { value: "Module" })), G$ = jn({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), Y$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: G$
}, Symbol.toStringTag, { value: "Module" })), J$ = jn({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), X$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: J$
}, Symbol.toStringTag, { value: "Module" })), Z$ = Hl({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), Q$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: Z$
}, Symbol.toStringTag, { value: "Module" })), eF = jn({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), tF = jn({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), rF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: eF,
  base16upper: tF
}, Symbol.toStringTag, { value: "Module" })), nF = jn({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), iF = jn({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), sF = jn({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), oF = jn({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), aF = jn({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), cF = jn({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), uF = jn({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), fF = jn({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), lF = jn({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), hF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: nF,
  base32hex: aF,
  base32hexpad: uF,
  base32hexpadupper: fF,
  base32hexupper: cF,
  base32pad: sF,
  base32padupper: oF,
  base32upper: iF,
  base32z: lF
}, Symbol.toStringTag, { value: "Module" })), dF = Hl({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), pF = Hl({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), gF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: dF,
  base36upper: pF
}, Symbol.toStringTag, { value: "Module" })), mF = Hl({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), vF = Hl({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), bF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: mF,
  base58flickr: vF
}, Symbol.toStringTag, { value: "Module" })), yF = jn({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), wF = jn({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), xF = jn({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), _F = jn({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), EF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: yF,
  base64pad: wF,
  base64url: xF,
  base64urlpad: _F
}, Symbol.toStringTag, { value: "Module" })), $4 = Array.from(""), SF = $4.reduce((t, e, r) => (t[r] = e, t), []), AF = $4.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function PF(t) {
  return t.reduce((e, r) => (e += SF[r], e), "");
}
function MF(t) {
  const e = [];
  for (const r of t) {
    const n = AF[r.codePointAt(0)];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const IF = j0({
  prefix: "",
  name: "base256emoji",
  encode: PF,
  decode: MF
}), CF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: IF
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const ex = {
  ...V$,
  ...Y$,
  ...X$,
  ...Q$,
  ...rF,
  ...hF,
  ...gF,
  ...bF,
  ...EF,
  ...CF
};
function F4(t, e, r, n) {
  return {
    name: t,
    prefix: e,
    encoder: {
      name: t,
      prefix: e,
      encode: r
    },
    decoder: { decode: n }
  };
}
const tx = F4("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), Xg = F4("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = L4(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = t.charCodeAt(r);
  return e;
}), B4 = {
  utf8: tx,
  "utf-8": tx,
  hex: ex.base16,
  latin1: Xg,
  ascii: Xg,
  binary: Xg,
  ...ex
};
function Dn(t, e = "utf8") {
  const r = B4[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8") : r.encoder.encode(t).substring(1);
}
function Rn(t, e = "utf8") {
  const r = B4[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t, "utf8") : r.decoder.decode(`${r.prefix}${t}`);
}
function rx(t) {
  return uc(Dn(Rn(t, U0), O4));
}
function e0(t) {
  return Dn(Rn(ko(t), O4), U0);
}
function U4(t) {
  const e = Rn(D$, Q2), r = R$ + Dn(Ed([e, t]), Q2);
  return [C$, T$, r].join(I$);
}
function TF(t) {
  return Dn(t, U0);
}
function RF(t) {
  return Rn(t, U0);
}
function DF(t) {
  return Rn([e0(t.header), e0(t.payload)].join(Qd), N4);
}
function OF(t) {
  return [
    e0(t.header),
    e0(t.payload),
    TF(t.signature)
  ].join(Qd);
}
function v1(t) {
  const e = t.split(Qd), r = rx(e[0]), n = rx(e[1]), i = RF(e[2]), s = Rn(e.slice(0, 2).join(Qd), N4);
  return { header: r, payload: n, signature: i, data: s };
}
function nx(t = Pa.randomBytes(O$)) {
  return $v.generateKeyPairFromSeed(t);
}
async function NF(t, e, r, n, i = mt.fromMiliseconds(Date.now())) {
  const s = { alg: P$, typ: M$ }, o = U4(n.publicKey), a = i + r, u = { iss: o, sub: t, aud: e, iat: i, exp: a }, l = DF({ header: s, payload: u }), d = $v.sign(n.secretKey, l);
  return OF({ header: s, payload: u, signature: d });
}
var ix = function(t, e, r) {
  if (r || arguments.length === 2) for (var n = 0, i = e.length, s; n < i; n++)
    (s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
  return t.concat(s || Array.prototype.slice.call(e));
}, LF = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e, r, n) {
      this.name = e, this.version = r, this.os = n, this.type = "browser";
    }
    return t;
  }()
), kF = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e) {
      this.version = e, this.type = "node", this.name = "node", this.os = process.platform;
    }
    return t;
  }()
), $F = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e, r, n, i) {
      this.name = e, this.version = r, this.os = n, this.bot = i, this.type = "bot-device";
    }
    return t;
  }()
), FF = (
  /** @class */
  /* @__PURE__ */ function() {
    function t() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return t;
  }()
), BF = (
  /** @class */
  /* @__PURE__ */ function() {
    function t() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return t;
  }()
), UF = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, jF = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, sx = 3, qF = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", UF]
], ox = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function zF(t) {
  return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new BF() : typeof navigator < "u" ? WF(navigator.userAgent) : VF();
}
function HF(t) {
  return t !== "" && qF.reduce(function(e, r) {
    var n = r[0], i = r[1];
    if (e)
      return e;
    var s = i.exec(t);
    return !!s && [n, s];
  }, !1);
}
function WF(t) {
  var e = HF(t);
  if (!e)
    return null;
  var r = e[0], n = e[1];
  if (r === "searchbot")
    return new FF();
  var i = n[1] && n[1].split(".").join("_").split("_").slice(0, 3);
  i ? i.length < sx && (i = ix(ix([], i, !0), GF(sx - i.length), !0)) : i = [];
  var s = i.join("."), o = KF(t), a = jF.exec(t);
  return a && a[1] ? new $F(r, s, o, a[1]) : new LF(r, s, o);
}
function KF(t) {
  for (var e = 0, r = ox.length; e < r; e++) {
    var n = ox[e], i = n[0], s = n[1], o = s.exec(t);
    if (o)
      return i;
  }
  return null;
}
function VF() {
  var t = typeof process < "u" && process.version;
  return t ? new kF(process.version.slice(1)) : null;
}
function GF(t) {
  for (var e = [], r = 0; r < t; r++)
    e.push("0");
  return e;
}
var Hr = {};
Object.defineProperty(Hr, "__esModule", { value: !0 });
Hr.getLocalStorage = Hr.getLocalStorageOrThrow = Hr.getCrypto = Hr.getCryptoOrThrow = j4 = Hr.getLocation = Hr.getLocationOrThrow = Fv = Hr.getNavigator = Hr.getNavigatorOrThrow = Wl = Hr.getDocument = Hr.getDocumentOrThrow = Hr.getFromWindowOrThrow = Hr.getFromWindow = void 0;
function bc(t) {
  let e;
  return typeof window < "u" && typeof window[t] < "u" && (e = window[t]), e;
}
Hr.getFromWindow = bc;
function Ou(t) {
  const e = bc(t);
  if (!e)
    throw new Error(`${t} is not defined in Window`);
  return e;
}
Hr.getFromWindowOrThrow = Ou;
function YF() {
  return Ou("document");
}
Hr.getDocumentOrThrow = YF;
function JF() {
  return bc("document");
}
var Wl = Hr.getDocument = JF;
function XF() {
  return Ou("navigator");
}
Hr.getNavigatorOrThrow = XF;
function ZF() {
  return bc("navigator");
}
var Fv = Hr.getNavigator = ZF;
function QF() {
  return Ou("location");
}
Hr.getLocationOrThrow = QF;
function eB() {
  return bc("location");
}
var j4 = Hr.getLocation = eB;
function tB() {
  return Ou("crypto");
}
Hr.getCryptoOrThrow = tB;
function rB() {
  return bc("crypto");
}
Hr.getCrypto = rB;
function nB() {
  return Ou("localStorage");
}
Hr.getLocalStorageOrThrow = nB;
function iB() {
  return bc("localStorage");
}
Hr.getLocalStorage = iB;
var Bv = {};
Object.defineProperty(Bv, "__esModule", { value: !0 });
var q4 = Bv.getWindowMetadata = void 0;
const ax = Hr;
function sB() {
  let t, e;
  try {
    t = ax.getDocumentOrThrow(), e = ax.getLocationOrThrow();
  } catch {
    return null;
  }
  function r() {
    const p = t.getElementsByTagName("link"), w = [];
    for (let P = 0; P < p.length; P++) {
      const A = p[P], N = A.getAttribute("rel");
      if (N && N.toLowerCase().indexOf("icon") > -1) {
        const L = A.getAttribute("href");
        if (L)
          if (L.toLowerCase().indexOf("https:") === -1 && L.toLowerCase().indexOf("http:") === -1 && L.indexOf("//") !== 0) {
            let F = e.protocol + "//" + e.host;
            if (L.indexOf("/") === 0)
              F += L;
            else {
              const $ = e.pathname.split("/");
              $.pop();
              const K = $.join("/");
              F += K + "/" + L;
            }
            w.push(F);
          } else if (L.indexOf("//") === 0) {
            const F = e.protocol + L;
            w.push(F);
          } else
            w.push(L);
      }
    }
    return w;
  }
  function n(...p) {
    const w = t.getElementsByTagName("meta");
    for (let P = 0; P < w.length; P++) {
      const A = w[P], N = ["itemprop", "property", "name"].map((L) => A.getAttribute(L)).filter((L) => L ? p.includes(L) : !1);
      if (N.length && N) {
        const L = A.getAttribute("content");
        if (L)
          return L;
      }
    }
    return "";
  }
  function i() {
    let p = n("name", "og:site_name", "og:title", "twitter:title");
    return p || (p = t.title), p;
  }
  function s() {
    return n("description", "og:description", "twitter:description", "keywords");
  }
  const o = i(), a = s(), u = e.origin, l = r();
  return {
    description: a,
    url: u,
    icons: l,
    name: o
  };
}
q4 = Bv.getWindowMetadata = sB;
var wl = {}, oB = (t) => encodeURIComponent(t).replace(/[!'()*]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`), z4 = "%[a-f0-9]{2}", cx = new RegExp("(" + z4 + ")|([^%]+?)", "gi"), ux = new RegExp("(" + z4 + ")+", "gi");
function b1(t, e) {
  try {
    return [decodeURIComponent(t.join(""))];
  } catch {
  }
  if (t.length === 1)
    return t;
  e = e || 1;
  var r = t.slice(0, e), n = t.slice(e);
  return Array.prototype.concat.call([], b1(r), b1(n));
}
function aB(t) {
  try {
    return decodeURIComponent(t);
  } catch {
    for (var e = t.match(cx) || [], r = 1; r < e.length; r++)
      t = b1(e, r).join(""), e = t.match(cx) || [];
    return t;
  }
}
function cB(t) {
  for (var e = {
    "%FE%FF": "",
    "%FF%FE": ""
  }, r = ux.exec(t); r; ) {
    try {
      e[r[0]] = decodeURIComponent(r[0]);
    } catch {
      var n = aB(r[0]);
      n !== r[0] && (e[r[0]] = n);
    }
    r = ux.exec(t);
  }
  e["%C2"] = "";
  for (var i = Object.keys(e), s = 0; s < i.length; s++) {
    var o = i[s];
    t = t.replace(new RegExp(o, "g"), e[o]);
  }
  return t;
}
var uB = function(t) {
  if (typeof t != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof t + "`");
  try {
    return t = t.replace(/\+/g, " "), decodeURIComponent(t);
  } catch {
    return cB(t);
  }
}, fB = (t, e) => {
  if (!(typeof t == "string" && typeof e == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (e === "")
    return [t];
  const r = t.indexOf(e);
  return r === -1 ? [t] : [
    t.slice(0, r),
    t.slice(r + e.length)
  ];
}, lB = function(t, e) {
  for (var r = {}, n = Object.keys(t), i = Array.isArray(e), s = 0; s < n.length; s++) {
    var o = n[s], a = t[o];
    (i ? e.indexOf(o) !== -1 : e(o, a, t)) && (r[o] = a);
  }
  return r;
};
(function(t) {
  const e = oB, r = uB, n = fB, i = lB, s = ($) => $ == null, o = Symbol("encodeFragmentIdentifier");
  function a($) {
    switch ($.arrayFormat) {
      case "index":
        return (K) => (H, V) => {
          const te = H.length;
          return V === void 0 || $.skipNull && V === null || $.skipEmptyString && V === "" ? H : V === null ? [...H, [d(K, $), "[", te, "]"].join("")] : [
            ...H,
            [d(K, $), "[", d(te, $), "]=", d(V, $)].join("")
          ];
        };
      case "bracket":
        return (K) => (H, V) => V === void 0 || $.skipNull && V === null || $.skipEmptyString && V === "" ? H : V === null ? [...H, [d(K, $), "[]"].join("")] : [...H, [d(K, $), "[]=", d(V, $)].join("")];
      case "colon-list-separator":
        return (K) => (H, V) => V === void 0 || $.skipNull && V === null || $.skipEmptyString && V === "" ? H : V === null ? [...H, [d(K, $), ":list="].join("")] : [...H, [d(K, $), ":list=", d(V, $)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const K = $.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (H) => (V, te) => te === void 0 || $.skipNull && te === null || $.skipEmptyString && te === "" ? V : (te = te === null ? "" : te, V.length === 0 ? [[d(H, $), K, d(te, $)].join("")] : [[V, d(te, $)].join($.arrayFormatSeparator)]);
      }
      default:
        return (K) => (H, V) => V === void 0 || $.skipNull && V === null || $.skipEmptyString && V === "" ? H : V === null ? [...H, d(K, $)] : [...H, [d(K, $), "=", d(V, $)].join("")];
    }
  }
  function u($) {
    let K;
    switch ($.arrayFormat) {
      case "index":
        return (H, V, te) => {
          if (K = /\[(\d*)\]$/.exec(H), H = H.replace(/\[\d*\]$/, ""), !K) {
            te[H] = V;
            return;
          }
          te[H] === void 0 && (te[H] = {}), te[H][K[1]] = V;
        };
      case "bracket":
        return (H, V, te) => {
          if (K = /(\[\])$/.exec(H), H = H.replace(/\[\]$/, ""), !K) {
            te[H] = V;
            return;
          }
          if (te[H] === void 0) {
            te[H] = [V];
            return;
          }
          te[H] = [].concat(te[H], V);
        };
      case "colon-list-separator":
        return (H, V, te) => {
          if (K = /(:list)$/.exec(H), H = H.replace(/:list$/, ""), !K) {
            te[H] = V;
            return;
          }
          if (te[H] === void 0) {
            te[H] = [V];
            return;
          }
          te[H] = [].concat(te[H], V);
        };
      case "comma":
      case "separator":
        return (H, V, te) => {
          const R = typeof V == "string" && V.includes($.arrayFormatSeparator), W = typeof V == "string" && !R && p(V, $).includes($.arrayFormatSeparator);
          V = W ? p(V, $) : V;
          const pe = R || W ? V.split($.arrayFormatSeparator).map((Ee) => p(Ee, $)) : V === null ? V : p(V, $);
          te[H] = pe;
        };
      case "bracket-separator":
        return (H, V, te) => {
          const R = /(\[\])$/.test(H);
          if (H = H.replace(/\[\]$/, ""), !R) {
            te[H] = V && p(V, $);
            return;
          }
          const W = V === null ? [] : V.split($.arrayFormatSeparator).map((pe) => p(pe, $));
          if (te[H] === void 0) {
            te[H] = W;
            return;
          }
          te[H] = [].concat(te[H], W);
        };
      default:
        return (H, V, te) => {
          if (te[H] === void 0) {
            te[H] = V;
            return;
          }
          te[H] = [].concat(te[H], V);
        };
    }
  }
  function l($) {
    if (typeof $ != "string" || $.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function d($, K) {
    return K.encode ? K.strict ? e($) : encodeURIComponent($) : $;
  }
  function p($, K) {
    return K.decode ? r($) : $;
  }
  function w($) {
    return Array.isArray($) ? $.sort() : typeof $ == "object" ? w(Object.keys($)).sort((K, H) => Number(K) - Number(H)).map((K) => $[K]) : $;
  }
  function P($) {
    const K = $.indexOf("#");
    return K !== -1 && ($ = $.slice(0, K)), $;
  }
  function A($) {
    let K = "";
    const H = $.indexOf("#");
    return H !== -1 && (K = $.slice(H)), K;
  }
  function N($) {
    $ = P($);
    const K = $.indexOf("?");
    return K === -1 ? "" : $.slice(K + 1);
  }
  function L($, K) {
    return K.parseNumbers && !Number.isNaN(Number($)) && typeof $ == "string" && $.trim() !== "" ? $ = Number($) : K.parseBooleans && $ !== null && ($.toLowerCase() === "true" || $.toLowerCase() === "false") && ($ = $.toLowerCase() === "true"), $;
  }
  function F($, K) {
    K = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, K), l(K.arrayFormatSeparator);
    const H = u(K), V = /* @__PURE__ */ Object.create(null);
    if (typeof $ != "string" || ($ = $.trim().replace(/^[?#&]/, ""), !$))
      return V;
    for (const te of $.split("&")) {
      if (te === "")
        continue;
      let [R, W] = n(K.decode ? te.replace(/\+/g, " ") : te, "=");
      W = W === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(K.arrayFormat) ? W : p(W, K), H(p(R, K), W, V);
    }
    for (const te of Object.keys(V)) {
      const R = V[te];
      if (typeof R == "object" && R !== null)
        for (const W of Object.keys(R))
          R[W] = L(R[W], K);
      else
        V[te] = L(R, K);
    }
    return K.sort === !1 ? V : (K.sort === !0 ? Object.keys(V).sort() : Object.keys(V).sort(K.sort)).reduce((te, R) => {
      const W = V[R];
      return W && typeof W == "object" && !Array.isArray(W) ? te[R] = w(W) : te[R] = W, te;
    }, /* @__PURE__ */ Object.create(null));
  }
  t.extract = N, t.parse = F, t.stringify = ($, K) => {
    if (!$)
      return "";
    K = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, K), l(K.arrayFormatSeparator);
    const H = (W) => K.skipNull && s($[W]) || K.skipEmptyString && $[W] === "", V = a(K), te = {};
    for (const W of Object.keys($))
      H(W) || (te[W] = $[W]);
    const R = Object.keys(te);
    return K.sort !== !1 && R.sort(K.sort), R.map((W) => {
      const pe = $[W];
      return pe === void 0 ? "" : pe === null ? d(W, K) : Array.isArray(pe) ? pe.length === 0 && K.arrayFormat === "bracket-separator" ? d(W, K) + "[]" : pe.reduce(V(W), []).join("&") : d(W, K) + "=" + d(pe, K);
    }).filter((W) => W.length > 0).join("&");
  }, t.parseUrl = ($, K) => {
    K = Object.assign({
      decode: !0
    }, K);
    const [H, V] = n($, "#");
    return Object.assign(
      {
        url: H.split("?")[0] || "",
        query: F(N($), K)
      },
      K && K.parseFragmentIdentifier && V ? { fragmentIdentifier: p(V, K) } : {}
    );
  }, t.stringifyUrl = ($, K) => {
    K = Object.assign({
      encode: !0,
      strict: !0,
      [o]: !0
    }, K);
    const H = P($.url).split("?")[0] || "", V = t.extract($.url), te = t.parse(V, { sort: !1 }), R = Object.assign(te, $.query);
    let W = t.stringify(R, K);
    W && (W = `?${W}`);
    let pe = A($.url);
    return $.fragmentIdentifier && (pe = `#${K[o] ? d($.fragmentIdentifier, K) : $.fragmentIdentifier}`), `${H}${W}${pe}`;
  }, t.pick = ($, K, H) => {
    H = Object.assign({
      parseFragmentIdentifier: !0,
      [o]: !1
    }, H);
    const { url: V, query: te, fragmentIdentifier: R } = t.parseUrl($, H);
    return t.stringifyUrl({
      url: V,
      query: i(te, K),
      fragmentIdentifier: R
    }, H);
  }, t.exclude = ($, K, H) => {
    const V = Array.isArray(K) ? (te) => !K.includes(te) : (te, R) => !K(te, R);
    return t.pick($, V, H);
  };
})(wl);
var H4 = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(t) {
  (function() {
    var e = "input is invalid type", r = "finalize already called", n = typeof window == "object", i = n ? window : {};
    i.JS_SHA3_NO_WINDOW && (n = !1);
    var s = !n && typeof self == "object", o = !i.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    o ? i = gn : s && (i = self);
    var a = !i.JS_SHA3_NO_COMMON_JS && !0 && t.exports, u = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", l = "0123456789abcdef".split(""), d = [31, 7936, 2031616, 520093696], p = [4, 1024, 262144, 67108864], w = [1, 256, 65536, 16777216], P = [6, 1536, 393216, 100663296], A = [0, 8, 16, 24], N = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ], L = [224, 256, 384, 512], F = [128, 256], $ = ["hex", "buffer", "arrayBuffer", "array", "digest"], K = {
      128: 168,
      256: 136
    };
    (i.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(D) {
      return Object.prototype.toString.call(D) === "[object Array]";
    }), u && (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(D) {
      return typeof D == "object" && D.buffer && D.buffer.constructor === ArrayBuffer;
    });
    for (var H = function(D, oe, Z) {
      return function(J) {
        return new I(D, oe, D).update(J)[Z]();
      };
    }, V = function(D, oe, Z) {
      return function(J, Q) {
        return new I(D, oe, Q).update(J)[Z]();
      };
    }, te = function(D, oe, Z) {
      return function(J, Q, T, X) {
        return f["cshake" + D].update(J, Q, T, X)[Z]();
      };
    }, R = function(D, oe, Z) {
      return function(J, Q, T, X) {
        return f["kmac" + D].update(J, Q, T, X)[Z]();
      };
    }, W = function(D, oe, Z, J) {
      for (var Q = 0; Q < $.length; ++Q) {
        var T = $[Q];
        D[T] = oe(Z, J, T);
      }
      return D;
    }, pe = function(D, oe) {
      var Z = H(D, oe, "hex");
      return Z.create = function() {
        return new I(D, oe, D);
      }, Z.update = function(J) {
        return Z.create().update(J);
      }, W(Z, H, D, oe);
    }, Ee = function(D, oe) {
      var Z = V(D, oe, "hex");
      return Z.create = function(J) {
        return new I(D, oe, J);
      }, Z.update = function(J, Q) {
        return Z.create(Q).update(J);
      }, W(Z, V, D, oe);
    }, Y = function(D, oe) {
      var Z = K[D], J = te(D, oe, "hex");
      return J.create = function(Q, T, X) {
        return !T && !X ? f["shake" + D].create(Q) : new I(D, oe, Q).bytepad([T, X], Z);
      }, J.update = function(Q, T, X, re) {
        return J.create(T, X, re).update(Q);
      }, W(J, te, D, oe);
    }, S = function(D, oe) {
      var Z = K[D], J = R(D, oe, "hex");
      return J.create = function(Q, T, X) {
        return new B(D, oe, T).bytepad(["KMAC", X], Z).bytepad([Q], Z);
      }, J.update = function(Q, T, X, re) {
        return J.create(Q, X, re).update(T);
      }, W(J, R, D, oe);
    }, m = [
      { name: "keccak", padding: w, bits: L, createMethod: pe },
      { name: "sha3", padding: P, bits: L, createMethod: pe },
      { name: "shake", padding: d, bits: F, createMethod: Ee },
      { name: "cshake", padding: p, bits: F, createMethod: Y },
      { name: "kmac", padding: p, bits: F, createMethod: S }
    ], f = {}, g = [], b = 0; b < m.length; ++b)
      for (var x = m[b], _ = x.bits, E = 0; E < _.length; ++E) {
        var v = x.name + "_" + _[E];
        if (g.push(v), f[v] = x.createMethod(_[E], x.padding), x.name !== "sha3") {
          var M = x.name + _[E];
          g.push(M), f[M] = f[v];
        }
      }
    function I(D, oe, Z) {
      this.blocks = [], this.s = [], this.padding = oe, this.outputBits = Z, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (D << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = Z >> 5, this.extraBytes = (Z & 31) >> 3;
      for (var J = 0; J < 50; ++J)
        this.s[J] = 0;
    }
    I.prototype.update = function(D) {
      if (this.finalized)
        throw new Error(r);
      var oe, Z = typeof D;
      if (Z !== "string") {
        if (Z === "object") {
          if (D === null)
            throw new Error(e);
          if (u && D.constructor === ArrayBuffer)
            D = new Uint8Array(D);
          else if (!Array.isArray(D) && (!u || !ArrayBuffer.isView(D)))
            throw new Error(e);
        } else
          throw new Error(e);
        oe = !0;
      }
      for (var J = this.blocks, Q = this.byteCount, T = D.length, X = this.blockCount, re = 0, de = this.s, ie, ue; re < T; ) {
        if (this.reset)
          for (this.reset = !1, J[0] = this.block, ie = 1; ie < X + 1; ++ie)
            J[ie] = 0;
        if (oe)
          for (ie = this.start; re < T && ie < Q; ++re)
            J[ie >> 2] |= D[re] << A[ie++ & 3];
        else
          for (ie = this.start; re < T && ie < Q; ++re)
            ue = D.charCodeAt(re), ue < 128 ? J[ie >> 2] |= ue << A[ie++ & 3] : ue < 2048 ? (J[ie >> 2] |= (192 | ue >> 6) << A[ie++ & 3], J[ie >> 2] |= (128 | ue & 63) << A[ie++ & 3]) : ue < 55296 || ue >= 57344 ? (J[ie >> 2] |= (224 | ue >> 12) << A[ie++ & 3], J[ie >> 2] |= (128 | ue >> 6 & 63) << A[ie++ & 3], J[ie >> 2] |= (128 | ue & 63) << A[ie++ & 3]) : (ue = 65536 + ((ue & 1023) << 10 | D.charCodeAt(++re) & 1023), J[ie >> 2] |= (240 | ue >> 18) << A[ie++ & 3], J[ie >> 2] |= (128 | ue >> 12 & 63) << A[ie++ & 3], J[ie >> 2] |= (128 | ue >> 6 & 63) << A[ie++ & 3], J[ie >> 2] |= (128 | ue & 63) << A[ie++ & 3]);
        if (this.lastByteIndex = ie, ie >= Q) {
          for (this.start = ie - Q, this.block = J[X], ie = 0; ie < X; ++ie)
            de[ie] ^= J[ie];
          ce(de), this.reset = !0;
        } else
          this.start = ie;
      }
      return this;
    }, I.prototype.encode = function(D, oe) {
      var Z = D & 255, J = 1, Q = [Z];
      for (D = D >> 8, Z = D & 255; Z > 0; )
        Q.unshift(Z), D = D >> 8, Z = D & 255, ++J;
      return oe ? Q.push(J) : Q.unshift(J), this.update(Q), Q.length;
    }, I.prototype.encodeString = function(D) {
      var oe, Z = typeof D;
      if (Z !== "string") {
        if (Z === "object") {
          if (D === null)
            throw new Error(e);
          if (u && D.constructor === ArrayBuffer)
            D = new Uint8Array(D);
          else if (!Array.isArray(D) && (!u || !ArrayBuffer.isView(D)))
            throw new Error(e);
        } else
          throw new Error(e);
        oe = !0;
      }
      var J = 0, Q = D.length;
      if (oe)
        J = Q;
      else
        for (var T = 0; T < D.length; ++T) {
          var X = D.charCodeAt(T);
          X < 128 ? J += 1 : X < 2048 ? J += 2 : X < 55296 || X >= 57344 ? J += 3 : (X = 65536 + ((X & 1023) << 10 | D.charCodeAt(++T) & 1023), J += 4);
        }
      return J += this.encode(J * 8), this.update(D), J;
    }, I.prototype.bytepad = function(D, oe) {
      for (var Z = this.encode(oe), J = 0; J < D.length; ++J)
        Z += this.encodeString(D[J]);
      var Q = oe - Z % oe, T = [];
      return T.length = Q, this.update(T), this;
    }, I.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var D = this.blocks, oe = this.lastByteIndex, Z = this.blockCount, J = this.s;
        if (D[oe >> 2] |= this.padding[oe & 3], this.lastByteIndex === this.byteCount)
          for (D[0] = D[Z], oe = 1; oe < Z + 1; ++oe)
            D[oe] = 0;
        for (D[Z - 1] |= 2147483648, oe = 0; oe < Z; ++oe)
          J[oe] ^= D[oe];
        ce(J);
      }
    }, I.prototype.toString = I.prototype.hex = function() {
      this.finalize();
      for (var D = this.blockCount, oe = this.s, Z = this.outputBlocks, J = this.extraBytes, Q = 0, T = 0, X = "", re; T < Z; ) {
        for (Q = 0; Q < D && T < Z; ++Q, ++T)
          re = oe[Q], X += l[re >> 4 & 15] + l[re & 15] + l[re >> 12 & 15] + l[re >> 8 & 15] + l[re >> 20 & 15] + l[re >> 16 & 15] + l[re >> 28 & 15] + l[re >> 24 & 15];
        T % D === 0 && (ce(oe), Q = 0);
      }
      return J && (re = oe[Q], X += l[re >> 4 & 15] + l[re & 15], J > 1 && (X += l[re >> 12 & 15] + l[re >> 8 & 15]), J > 2 && (X += l[re >> 20 & 15] + l[re >> 16 & 15])), X;
    }, I.prototype.arrayBuffer = function() {
      this.finalize();
      var D = this.blockCount, oe = this.s, Z = this.outputBlocks, J = this.extraBytes, Q = 0, T = 0, X = this.outputBits >> 3, re;
      J ? re = new ArrayBuffer(Z + 1 << 2) : re = new ArrayBuffer(X);
      for (var de = new Uint32Array(re); T < Z; ) {
        for (Q = 0; Q < D && T < Z; ++Q, ++T)
          de[T] = oe[Q];
        T % D === 0 && ce(oe);
      }
      return J && (de[Q] = oe[Q], re = re.slice(0, X)), re;
    }, I.prototype.buffer = I.prototype.arrayBuffer, I.prototype.digest = I.prototype.array = function() {
      this.finalize();
      for (var D = this.blockCount, oe = this.s, Z = this.outputBlocks, J = this.extraBytes, Q = 0, T = 0, X = [], re, de; T < Z; ) {
        for (Q = 0; Q < D && T < Z; ++Q, ++T)
          re = T << 2, de = oe[Q], X[re] = de & 255, X[re + 1] = de >> 8 & 255, X[re + 2] = de >> 16 & 255, X[re + 3] = de >> 24 & 255;
        T % D === 0 && ce(oe);
      }
      return J && (re = T << 2, de = oe[Q], X[re] = de & 255, J > 1 && (X[re + 1] = de >> 8 & 255), J > 2 && (X[re + 2] = de >> 16 & 255)), X;
    };
    function B(D, oe, Z) {
      I.call(this, D, oe, Z);
    }
    B.prototype = new I(), B.prototype.finalize = function() {
      return this.encode(this.outputBits, !0), I.prototype.finalize.call(this);
    };
    var ce = function(D) {
      var oe, Z, J, Q, T, X, re, de, ie, ue, ve, Pe, De, Ce, $e, Me, Ne, Ke, Le, qe, ze, _e, Ze, at, ke, Qe, tt, Ye, dt, lt, ct, qt, Yt, Et, Qt, Jt, Dt, kt, Ct, gt, Rt, Nt, vt, $t, Bt, rt, Ft, k, j, z, C, G, U, se, he, xe, Te, Re, nt, Ue, pt, it, et;
      for (J = 0; J < 48; J += 2)
        Q = D[0] ^ D[10] ^ D[20] ^ D[30] ^ D[40], T = D[1] ^ D[11] ^ D[21] ^ D[31] ^ D[41], X = D[2] ^ D[12] ^ D[22] ^ D[32] ^ D[42], re = D[3] ^ D[13] ^ D[23] ^ D[33] ^ D[43], de = D[4] ^ D[14] ^ D[24] ^ D[34] ^ D[44], ie = D[5] ^ D[15] ^ D[25] ^ D[35] ^ D[45], ue = D[6] ^ D[16] ^ D[26] ^ D[36] ^ D[46], ve = D[7] ^ D[17] ^ D[27] ^ D[37] ^ D[47], Pe = D[8] ^ D[18] ^ D[28] ^ D[38] ^ D[48], De = D[9] ^ D[19] ^ D[29] ^ D[39] ^ D[49], oe = Pe ^ (X << 1 | re >>> 31), Z = De ^ (re << 1 | X >>> 31), D[0] ^= oe, D[1] ^= Z, D[10] ^= oe, D[11] ^= Z, D[20] ^= oe, D[21] ^= Z, D[30] ^= oe, D[31] ^= Z, D[40] ^= oe, D[41] ^= Z, oe = Q ^ (de << 1 | ie >>> 31), Z = T ^ (ie << 1 | de >>> 31), D[2] ^= oe, D[3] ^= Z, D[12] ^= oe, D[13] ^= Z, D[22] ^= oe, D[23] ^= Z, D[32] ^= oe, D[33] ^= Z, D[42] ^= oe, D[43] ^= Z, oe = X ^ (ue << 1 | ve >>> 31), Z = re ^ (ve << 1 | ue >>> 31), D[4] ^= oe, D[5] ^= Z, D[14] ^= oe, D[15] ^= Z, D[24] ^= oe, D[25] ^= Z, D[34] ^= oe, D[35] ^= Z, D[44] ^= oe, D[45] ^= Z, oe = de ^ (Pe << 1 | De >>> 31), Z = ie ^ (De << 1 | Pe >>> 31), D[6] ^= oe, D[7] ^= Z, D[16] ^= oe, D[17] ^= Z, D[26] ^= oe, D[27] ^= Z, D[36] ^= oe, D[37] ^= Z, D[46] ^= oe, D[47] ^= Z, oe = ue ^ (Q << 1 | T >>> 31), Z = ve ^ (T << 1 | Q >>> 31), D[8] ^= oe, D[9] ^= Z, D[18] ^= oe, D[19] ^= Z, D[28] ^= oe, D[29] ^= Z, D[38] ^= oe, D[39] ^= Z, D[48] ^= oe, D[49] ^= Z, Ce = D[0], $e = D[1], rt = D[11] << 4 | D[10] >>> 28, Ft = D[10] << 4 | D[11] >>> 28, Ye = D[20] << 3 | D[21] >>> 29, dt = D[21] << 3 | D[20] >>> 29, Ue = D[31] << 9 | D[30] >>> 23, pt = D[30] << 9 | D[31] >>> 23, Nt = D[40] << 18 | D[41] >>> 14, vt = D[41] << 18 | D[40] >>> 14, Et = D[2] << 1 | D[3] >>> 31, Qt = D[3] << 1 | D[2] >>> 31, Me = D[13] << 12 | D[12] >>> 20, Ne = D[12] << 12 | D[13] >>> 20, k = D[22] << 10 | D[23] >>> 22, j = D[23] << 10 | D[22] >>> 22, lt = D[33] << 13 | D[32] >>> 19, ct = D[32] << 13 | D[33] >>> 19, it = D[42] << 2 | D[43] >>> 30, et = D[43] << 2 | D[42] >>> 30, se = D[5] << 30 | D[4] >>> 2, he = D[4] << 30 | D[5] >>> 2, Jt = D[14] << 6 | D[15] >>> 26, Dt = D[15] << 6 | D[14] >>> 26, Ke = D[25] << 11 | D[24] >>> 21, Le = D[24] << 11 | D[25] >>> 21, z = D[34] << 15 | D[35] >>> 17, C = D[35] << 15 | D[34] >>> 17, qt = D[45] << 29 | D[44] >>> 3, Yt = D[44] << 29 | D[45] >>> 3, at = D[6] << 28 | D[7] >>> 4, ke = D[7] << 28 | D[6] >>> 4, xe = D[17] << 23 | D[16] >>> 9, Te = D[16] << 23 | D[17] >>> 9, kt = D[26] << 25 | D[27] >>> 7, Ct = D[27] << 25 | D[26] >>> 7, qe = D[36] << 21 | D[37] >>> 11, ze = D[37] << 21 | D[36] >>> 11, G = D[47] << 24 | D[46] >>> 8, U = D[46] << 24 | D[47] >>> 8, $t = D[8] << 27 | D[9] >>> 5, Bt = D[9] << 27 | D[8] >>> 5, Qe = D[18] << 20 | D[19] >>> 12, tt = D[19] << 20 | D[18] >>> 12, Re = D[29] << 7 | D[28] >>> 25, nt = D[28] << 7 | D[29] >>> 25, gt = D[38] << 8 | D[39] >>> 24, Rt = D[39] << 8 | D[38] >>> 24, _e = D[48] << 14 | D[49] >>> 18, Ze = D[49] << 14 | D[48] >>> 18, D[0] = Ce ^ ~Me & Ke, D[1] = $e ^ ~Ne & Le, D[10] = at ^ ~Qe & Ye, D[11] = ke ^ ~tt & dt, D[20] = Et ^ ~Jt & kt, D[21] = Qt ^ ~Dt & Ct, D[30] = $t ^ ~rt & k, D[31] = Bt ^ ~Ft & j, D[40] = se ^ ~xe & Re, D[41] = he ^ ~Te & nt, D[2] = Me ^ ~Ke & qe, D[3] = Ne ^ ~Le & ze, D[12] = Qe ^ ~Ye & lt, D[13] = tt ^ ~dt & ct, D[22] = Jt ^ ~kt & gt, D[23] = Dt ^ ~Ct & Rt, D[32] = rt ^ ~k & z, D[33] = Ft ^ ~j & C, D[42] = xe ^ ~Re & Ue, D[43] = Te ^ ~nt & pt, D[4] = Ke ^ ~qe & _e, D[5] = Le ^ ~ze & Ze, D[14] = Ye ^ ~lt & qt, D[15] = dt ^ ~ct & Yt, D[24] = kt ^ ~gt & Nt, D[25] = Ct ^ ~Rt & vt, D[34] = k ^ ~z & G, D[35] = j ^ ~C & U, D[44] = Re ^ ~Ue & it, D[45] = nt ^ ~pt & et, D[6] = qe ^ ~_e & Ce, D[7] = ze ^ ~Ze & $e, D[16] = lt ^ ~qt & at, D[17] = ct ^ ~Yt & ke, D[26] = gt ^ ~Nt & Et, D[27] = Rt ^ ~vt & Qt, D[36] = z ^ ~G & $t, D[37] = C ^ ~U & Bt, D[46] = Ue ^ ~it & se, D[47] = pt ^ ~et & he, D[8] = _e ^ ~Ce & Me, D[9] = Ze ^ ~$e & Ne, D[18] = qt ^ ~at & Qe, D[19] = Yt ^ ~ke & tt, D[28] = Nt ^ ~Et & Jt, D[29] = vt ^ ~Qt & Dt, D[38] = G ^ ~$t & rt, D[39] = U ^ ~Bt & Ft, D[48] = it ^ ~se & xe, D[49] = et ^ ~he & Te, D[0] ^= N[J], D[1] ^= N[J + 1];
    };
    if (a)
      t.exports = f;
    else
      for (b = 0; b < g.length; ++b)
        i[g[b]] = f[g[b]];
  })();
})(H4);
var hB = H4.exports;
const dB = /* @__PURE__ */ ts(hB), pB = "logger/5.7.0";
let fx = !1, lx = !1;
const Sd = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let hx = Sd.default, Zg = null;
function gB() {
  try {
    const t = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((e) => {
      try {
        if ("test".normalize(e) !== "test")
          throw new Error("bad normalize");
      } catch {
        t.push(e);
      }
    }), t.length)
      throw new Error("missing " + t.join(", "));
    if ("".normalize("NFD") !== "e")
      throw new Error("broken implementation");
  } catch (t) {
    return t.message;
  }
  return null;
}
const dx = gB();
var y1;
(function(t) {
  t.DEBUG = "DEBUG", t.INFO = "INFO", t.WARNING = "WARNING", t.ERROR = "ERROR", t.OFF = "OFF";
})(y1 || (y1 = {}));
var ys;
(function(t) {
  t.UNKNOWN_ERROR = "UNKNOWN_ERROR", t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", t.NETWORK_ERROR = "NETWORK_ERROR", t.SERVER_ERROR = "SERVER_ERROR", t.TIMEOUT = "TIMEOUT", t.BUFFER_OVERRUN = "BUFFER_OVERRUN", t.NUMERIC_FAULT = "NUMERIC_FAULT", t.MISSING_NEW = "MISSING_NEW", t.INVALID_ARGUMENT = "INVALID_ARGUMENT", t.MISSING_ARGUMENT = "MISSING_ARGUMENT", t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", t.CALL_EXCEPTION = "CALL_EXCEPTION", t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", t.NONCE_EXPIRED = "NONCE_EXPIRED", t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", t.ACTION_REJECTED = "ACTION_REJECTED";
})(ys || (ys = {}));
const px = "0123456789abcdef";
class Yr {
  constructor(e) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: e,
      writable: !1
    });
  }
  _log(e, r) {
    const n = e.toLowerCase();
    Sd[n] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(hx > Sd[n]) && console.log.apply(console, r);
  }
  debug(...e) {
    this._log(Yr.levels.DEBUG, e);
  }
  info(...e) {
    this._log(Yr.levels.INFO, e);
  }
  warn(...e) {
    this._log(Yr.levels.WARNING, e);
  }
  makeError(e, r, n) {
    if (lx)
      return this.makeError("censored error", r, {});
    r || (r = Yr.errors.UNKNOWN_ERROR), n || (n = {});
    const i = [];
    Object.keys(n).forEach((u) => {
      const l = n[u];
      try {
        if (l instanceof Uint8Array) {
          let d = "";
          for (let p = 0; p < l.length; p++)
            d += px[l[p] >> 4], d += px[l[p] & 15];
          i.push(u + "=Uint8Array(0x" + d + ")");
        } else
          i.push(u + "=" + JSON.stringify(l));
      } catch {
        i.push(u + "=" + JSON.stringify(n[u].toString()));
      }
    }), i.push(`code=${r}`), i.push(`version=${this.version}`);
    const s = e;
    let o = "";
    switch (r) {
      case ys.NUMERIC_FAULT: {
        o = "NUMERIC_FAULT";
        const u = e;
        switch (u) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            o += "-" + u;
            break;
          case "negative-power":
          case "negative-width":
            o += "-unsupported";
            break;
          case "unbound-bitwise-result":
            o += "-unbound-result";
            break;
        }
        break;
      }
      case ys.CALL_EXCEPTION:
      case ys.INSUFFICIENT_FUNDS:
      case ys.MISSING_NEW:
      case ys.NONCE_EXPIRED:
      case ys.REPLACEMENT_UNDERPRICED:
      case ys.TRANSACTION_REPLACED:
      case ys.UNPREDICTABLE_GAS_LIMIT:
        o = r;
        break;
    }
    o && (e += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), i.length && (e += " (" + i.join(", ") + ")");
    const a = new Error(e);
    return a.reason = s, a.code = r, Object.keys(n).forEach(function(u) {
      a[u] = n[u];
    }), a;
  }
  throwError(e, r, n) {
    throw this.makeError(e, r, n);
  }
  throwArgumentError(e, r, n) {
    return this.throwError(e, Yr.errors.INVALID_ARGUMENT, {
      argument: r,
      value: n
    });
  }
  assert(e, r, n, i) {
    e || this.throwError(r, n, i);
  }
  assertArgument(e, r, n, i) {
    e || this.throwArgumentError(r, n, i);
  }
  checkNormalize(e) {
    dx && this.throwError("platform missing String.prototype.normalize", Yr.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: dx
    });
  }
  checkSafeUint53(e, r) {
    typeof e == "number" && (r == null && (r = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(r, Yr.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: e
    }), e % 1 && this.throwError(r, Yr.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: e
    }));
  }
  checkArgumentCount(e, r, n) {
    n ? n = ": " + n : n = "", e < r && this.throwError("missing argument" + n, Yr.errors.MISSING_ARGUMENT, {
      count: e,
      expectedCount: r
    }), e > r && this.throwError("too many arguments" + n, Yr.errors.UNEXPECTED_ARGUMENT, {
      count: e,
      expectedCount: r
    });
  }
  checkNew(e, r) {
    (e === Object || e == null) && this.throwError("missing new", Yr.errors.MISSING_NEW, { name: r.name });
  }
  checkAbstract(e, r) {
    e === r ? this.throwError("cannot instantiate abstract class " + JSON.stringify(r.name) + " directly; use a sub-class", Yr.errors.UNSUPPORTED_OPERATION, { name: e.name, operation: "new" }) : (e === Object || e == null) && this.throwError("missing new", Yr.errors.MISSING_NEW, { name: r.name });
  }
  static globalLogger() {
    return Zg || (Zg = new Yr(pB)), Zg;
  }
  static setCensorship(e, r) {
    if (!e && r && this.globalLogger().throwError("cannot permanently disable censorship", Yr.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), fx) {
      if (!e)
        return;
      this.globalLogger().throwError("error censorship permanent", Yr.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    lx = !!e, fx = !!r;
  }
  static setLogLevel(e) {
    const r = Sd[e.toLowerCase()];
    if (r == null) {
      Yr.globalLogger().warn("invalid log level - " + e);
      return;
    }
    hx = r;
  }
  static from(e) {
    return new Yr(e);
  }
}
Yr.errors = ys;
Yr.levels = y1;
const mB = "bytes/5.7.0", hn = new Yr(mB);
function W4(t) {
  return !!t.toHexString;
}
function uu(t) {
  return t.slice || (t.slice = function() {
    const e = Array.prototype.slice.call(arguments);
    return uu(new Uint8Array(Array.prototype.slice.apply(t, e)));
  }), t;
}
function vB(t) {
  return qs(t) && !(t.length % 2) || Uv(t);
}
function gx(t) {
  return typeof t == "number" && t == t && t % 1 === 0;
}
function Uv(t) {
  if (t == null)
    return !1;
  if (t.constructor === Uint8Array)
    return !0;
  if (typeof t == "string" || !gx(t.length) || t.length < 0)
    return !1;
  for (let e = 0; e < t.length; e++) {
    const r = t[e];
    if (!gx(r) || r < 0 || r >= 256)
      return !1;
  }
  return !0;
}
function wn(t, e) {
  if (e || (e = {}), typeof t == "number") {
    hn.checkSafeUint53(t, "invalid arrayify value");
    const r = [];
    for (; t; )
      r.unshift(t & 255), t = parseInt(String(t / 256));
    return r.length === 0 && r.push(0), uu(new Uint8Array(r));
  }
  if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), W4(t) && (t = t.toHexString()), qs(t)) {
    let r = t.substring(2);
    r.length % 2 && (e.hexPad === "left" ? r = "0" + r : e.hexPad === "right" ? r += "0" : hn.throwArgumentError("hex data is odd-length", "value", t));
    const n = [];
    for (let i = 0; i < r.length; i += 2)
      n.push(parseInt(r.substring(i, i + 2), 16));
    return uu(new Uint8Array(n));
  }
  return Uv(t) ? uu(new Uint8Array(t)) : hn.throwArgumentError("invalid arrayify value", "value", t);
}
function bB(t) {
  const e = t.map((i) => wn(i)), r = e.reduce((i, s) => i + s.length, 0), n = new Uint8Array(r);
  return e.reduce((i, s) => (n.set(s, i), i + s.length), 0), uu(n);
}
function yB(t, e) {
  t = wn(t), t.length > e && hn.throwArgumentError("value out of range", "value", arguments[0]);
  const r = new Uint8Array(e);
  return r.set(t, e - t.length), uu(r);
}
function qs(t, e) {
  return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e);
}
const Qg = "0123456789abcdef";
function Ti(t, e) {
  if (e || (e = {}), typeof t == "number") {
    hn.checkSafeUint53(t, "invalid hexlify value");
    let r = "";
    for (; t; )
      r = Qg[t & 15] + r, t = Math.floor(t / 16);
    return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00";
  }
  if (typeof t == "bigint")
    return t = t.toString(16), t.length % 2 ? "0x0" + t : "0x" + t;
  if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), W4(t))
    return t.toHexString();
  if (qs(t))
    return t.length % 2 && (e.hexPad === "left" ? t = "0x0" + t.substring(2) : e.hexPad === "right" ? t += "0" : hn.throwArgumentError("hex data is odd-length", "value", t)), t.toLowerCase();
  if (Uv(t)) {
    let r = "0x";
    for (let n = 0; n < t.length; n++) {
      let i = t[n];
      r += Qg[(i & 240) >> 4] + Qg[i & 15];
    }
    return r;
  }
  return hn.throwArgumentError("invalid hexlify value", "value", t);
}
function wB(t) {
  if (typeof t != "string")
    t = Ti(t);
  else if (!qs(t) || t.length % 2)
    return null;
  return (t.length - 2) / 2;
}
function mx(t, e, r) {
  return typeof t != "string" ? t = Ti(t) : (!qs(t) || t.length % 2) && hn.throwArgumentError("invalid hexData", "value", t), e = 2 + 2 * e, "0x" + t.substring(e);
}
function fu(t, e) {
  for (typeof t != "string" ? t = Ti(t) : qs(t) || hn.throwArgumentError("invalid hex string", "value", t), t.length > 2 * e + 2 && hn.throwArgumentError("value out of range", "value", arguments[1]); t.length < 2 * e + 2; )
    t = "0x0" + t.substring(2);
  return t;
}
function K4(t) {
  const e = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (vB(t)) {
    let r = wn(t);
    r.length === 64 ? (e.v = 27 + (r[32] >> 7), r[32] &= 127, e.r = Ti(r.slice(0, 32)), e.s = Ti(r.slice(32, 64))) : r.length === 65 ? (e.r = Ti(r.slice(0, 32)), e.s = Ti(r.slice(32, 64)), e.v = r[64]) : hn.throwArgumentError("invalid signature string", "signature", t), e.v < 27 && (e.v === 0 || e.v === 1 ? e.v += 27 : hn.throwArgumentError("signature invalid v byte", "signature", t)), e.recoveryParam = 1 - e.v % 2, e.recoveryParam && (r[32] |= 128), e._vs = Ti(r.slice(32, 64));
  } else {
    if (e.r = t.r, e.s = t.s, e.v = t.v, e.recoveryParam = t.recoveryParam, e._vs = t._vs, e._vs != null) {
      const i = yB(wn(e._vs), 32);
      e._vs = Ti(i);
      const s = i[0] >= 128 ? 1 : 0;
      e.recoveryParam == null ? e.recoveryParam = s : e.recoveryParam !== s && hn.throwArgumentError("signature recoveryParam mismatch _vs", "signature", t), i[0] &= 127;
      const o = Ti(i);
      e.s == null ? e.s = o : e.s !== o && hn.throwArgumentError("signature v mismatch _vs", "signature", t);
    }
    if (e.recoveryParam == null)
      e.v == null ? hn.throwArgumentError("signature missing v and recoveryParam", "signature", t) : e.v === 0 || e.v === 1 ? e.recoveryParam = e.v : e.recoveryParam = 1 - e.v % 2;
    else if (e.v == null)
      e.v = 27 + e.recoveryParam;
    else {
      const i = e.v === 0 || e.v === 1 ? e.v : 1 - e.v % 2;
      e.recoveryParam !== i && hn.throwArgumentError("signature recoveryParam mismatch v", "signature", t);
    }
    e.r == null || !qs(e.r) ? hn.throwArgumentError("signature missing or invalid r", "signature", t) : e.r = fu(e.r, 32), e.s == null || !qs(e.s) ? hn.throwArgumentError("signature missing or invalid s", "signature", t) : e.s = fu(e.s, 32);
    const r = wn(e.s);
    r[0] >= 128 && hn.throwArgumentError("signature s out of range", "signature", t), e.recoveryParam && (r[0] |= 128);
    const n = Ti(r);
    e._vs && (qs(e._vs) || hn.throwArgumentError("signature invalid _vs", "signature", t), e._vs = fu(e._vs, 32)), e._vs == null ? e._vs = n : e._vs !== n && hn.throwArgumentError("signature _vs mismatch v and s", "signature", t);
  }
  return e.yParityAndS = e._vs, e.compact = e.r + e.yParityAndS.substring(2), e;
}
function jv(t) {
  return "0x" + dB.keccak_256(wn(t));
}
var qv = { exports: {} };
qv.exports;
(function(t) {
  (function(e, r) {
    function n(m, f) {
      if (!m) throw new Error(f || "Assertion failed");
    }
    function i(m, f) {
      m.super_ = f;
      var g = function() {
      };
      g.prototype = f.prototype, m.prototype = new g(), m.prototype.constructor = m;
    }
    function s(m, f, g) {
      if (s.isBN(m))
        return m;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, m !== null && ((f === "le" || f === "be") && (g = f, f = 10), this._init(m || 0, f || 10, g || "be"));
    }
    typeof e == "object" ? e.exports = s : r.BN = s, s.BN = s, s.wordSize = 26;
    var o;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = zl.Buffer;
    } catch {
    }
    s.isBN = function(f) {
      return f instanceof s ? !0 : f !== null && typeof f == "object" && f.constructor.wordSize === s.wordSize && Array.isArray(f.words);
    }, s.max = function(f, g) {
      return f.cmp(g) > 0 ? f : g;
    }, s.min = function(f, g) {
      return f.cmp(g) < 0 ? f : g;
    }, s.prototype._init = function(f, g, b) {
      if (typeof f == "number")
        return this._initNumber(f, g, b);
      if (typeof f == "object")
        return this._initArray(f, g, b);
      g === "hex" && (g = 16), n(g === (g | 0) && g >= 2 && g <= 36), f = f.toString().replace(/\s+/g, "");
      var x = 0;
      f[0] === "-" && (x++, this.negative = 1), x < f.length && (g === 16 ? this._parseHex(f, x, b) : (this._parseBase(f, g, x), b === "le" && this._initArray(this.toArray(), g, b)));
    }, s.prototype._initNumber = function(f, g, b) {
      f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [f & 67108863], this.length = 1) : f < 4503599627370496 ? (this.words = [
        f & 67108863,
        f / 67108864 & 67108863
      ], this.length = 2) : (n(f < 9007199254740992), this.words = [
        f & 67108863,
        f / 67108864 & 67108863,
        1
      ], this.length = 3), b === "le" && this._initArray(this.toArray(), g, b);
    }, s.prototype._initArray = function(f, g, b) {
      if (n(typeof f.length == "number"), f.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        this.words[x] = 0;
      var _, E, v = 0;
      if (b === "be")
        for (x = f.length - 1, _ = 0; x >= 0; x -= 3)
          E = f[x] | f[x - 1] << 8 | f[x - 2] << 16, this.words[_] |= E << v & 67108863, this.words[_ + 1] = E >>> 26 - v & 67108863, v += 24, v >= 26 && (v -= 26, _++);
      else if (b === "le")
        for (x = 0, _ = 0; x < f.length; x += 3)
          E = f[x] | f[x + 1] << 8 | f[x + 2] << 16, this.words[_] |= E << v & 67108863, this.words[_ + 1] = E >>> 26 - v & 67108863, v += 24, v >= 26 && (v -= 26, _++);
      return this._strip();
    };
    function a(m, f) {
      var g = m.charCodeAt(f);
      if (g >= 48 && g <= 57)
        return g - 48;
      if (g >= 65 && g <= 70)
        return g - 55;
      if (g >= 97 && g <= 102)
        return g - 87;
      n(!1, "Invalid character in " + m);
    }
    function u(m, f, g) {
      var b = a(m, g);
      return g - 1 >= f && (b |= a(m, g - 1) << 4), b;
    }
    s.prototype._parseHex = function(f, g, b) {
      this.length = Math.ceil((f.length - g) / 6), this.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        this.words[x] = 0;
      var _ = 0, E = 0, v;
      if (b === "be")
        for (x = f.length - 1; x >= g; x -= 2)
          v = u(f, g, x) << _, this.words[E] |= v & 67108863, _ >= 18 ? (_ -= 18, E += 1, this.words[E] |= v >>> 26) : _ += 8;
      else {
        var M = f.length - g;
        for (x = M % 2 === 0 ? g + 1 : g; x < f.length; x += 2)
          v = u(f, g, x) << _, this.words[E] |= v & 67108863, _ >= 18 ? (_ -= 18, E += 1, this.words[E] |= v >>> 26) : _ += 8;
      }
      this._strip();
    };
    function l(m, f, g, b) {
      for (var x = 0, _ = 0, E = Math.min(m.length, g), v = f; v < E; v++) {
        var M = m.charCodeAt(v) - 48;
        x *= b, M >= 49 ? _ = M - 49 + 10 : M >= 17 ? _ = M - 17 + 10 : _ = M, n(M >= 0 && _ < b, "Invalid character"), x += _;
      }
      return x;
    }
    s.prototype._parseBase = function(f, g, b) {
      this.words = [0], this.length = 1;
      for (var x = 0, _ = 1; _ <= 67108863; _ *= g)
        x++;
      x--, _ = _ / g | 0;
      for (var E = f.length - b, v = E % x, M = Math.min(E, E - v) + b, I = 0, B = b; B < M; B += x)
        I = l(f, B, B + x, g), this.imuln(_), this.words[0] + I < 67108864 ? this.words[0] += I : this._iaddn(I);
      if (v !== 0) {
        var ce = 1;
        for (I = l(f, B, f.length, g), B = 0; B < v; B++)
          ce *= g;
        this.imuln(ce), this.words[0] + I < 67108864 ? this.words[0] += I : this._iaddn(I);
      }
      this._strip();
    }, s.prototype.copy = function(f) {
      f.words = new Array(this.length);
      for (var g = 0; g < this.length; g++)
        f.words[g] = this.words[g];
      f.length = this.length, f.negative = this.negative, f.red = this.red;
    };
    function d(m, f) {
      m.words = f.words, m.length = f.length, m.negative = f.negative, m.red = f.red;
    }
    if (s.prototype._move = function(f) {
      d(f, this);
    }, s.prototype.clone = function() {
      var f = new s(null);
      return this.copy(f), f;
    }, s.prototype._expand = function(f) {
      for (; this.length < f; )
        this.words[this.length++] = 0;
      return this;
    }, s.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, s.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        s.prototype[Symbol.for("nodejs.util.inspect.custom")] = p;
      } catch {
        s.prototype.inspect = p;
      }
    else
      s.prototype.inspect = p;
    function p() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var w = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], P = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], A = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    s.prototype.toString = function(f, g) {
      f = f || 10, g = g | 0 || 1;
      var b;
      if (f === 16 || f === "hex") {
        b = "";
        for (var x = 0, _ = 0, E = 0; E < this.length; E++) {
          var v = this.words[E], M = ((v << x | _) & 16777215).toString(16);
          _ = v >>> 24 - x & 16777215, x += 2, x >= 26 && (x -= 26, E--), _ !== 0 || E !== this.length - 1 ? b = w[6 - M.length] + M + b : b = M + b;
        }
        for (_ !== 0 && (b = _.toString(16) + b); b.length % g !== 0; )
          b = "0" + b;
        return this.negative !== 0 && (b = "-" + b), b;
      }
      if (f === (f | 0) && f >= 2 && f <= 36) {
        var I = P[f], B = A[f];
        b = "";
        var ce = this.clone();
        for (ce.negative = 0; !ce.isZero(); ) {
          var D = ce.modrn(B).toString(f);
          ce = ce.idivn(B), ce.isZero() ? b = D + b : b = w[I - D.length] + D + b;
        }
        for (this.isZero() && (b = "0" + b); b.length % g !== 0; )
          b = "0" + b;
        return this.negative !== 0 && (b = "-" + b), b;
      }
      n(!1, "Base should be between 2 and 36");
    }, s.prototype.toNumber = function() {
      var f = this.words[0];
      return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f : f;
    }, s.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, o && (s.prototype.toBuffer = function(f, g) {
      return this.toArrayLike(o, f, g);
    }), s.prototype.toArray = function(f, g) {
      return this.toArrayLike(Array, f, g);
    };
    var N = function(f, g) {
      return f.allocUnsafe ? f.allocUnsafe(g) : new f(g);
    };
    s.prototype.toArrayLike = function(f, g, b) {
      this._strip();
      var x = this.byteLength(), _ = b || Math.max(1, x);
      n(x <= _, "byte array longer than desired length"), n(_ > 0, "Requested array length <= 0");
      var E = N(f, _), v = g === "le" ? "LE" : "BE";
      return this["_toArrayLike" + v](E, x), E;
    }, s.prototype._toArrayLikeLE = function(f, g) {
      for (var b = 0, x = 0, _ = 0, E = 0; _ < this.length; _++) {
        var v = this.words[_] << E | x;
        f[b++] = v & 255, b < f.length && (f[b++] = v >> 8 & 255), b < f.length && (f[b++] = v >> 16 & 255), E === 6 ? (b < f.length && (f[b++] = v >> 24 & 255), x = 0, E = 0) : (x = v >>> 24, E += 2);
      }
      if (b < f.length)
        for (f[b++] = x; b < f.length; )
          f[b++] = 0;
    }, s.prototype._toArrayLikeBE = function(f, g) {
      for (var b = f.length - 1, x = 0, _ = 0, E = 0; _ < this.length; _++) {
        var v = this.words[_] << E | x;
        f[b--] = v & 255, b >= 0 && (f[b--] = v >> 8 & 255), b >= 0 && (f[b--] = v >> 16 & 255), E === 6 ? (b >= 0 && (f[b--] = v >> 24 & 255), x = 0, E = 0) : (x = v >>> 24, E += 2);
      }
      if (b >= 0)
        for (f[b--] = x; b >= 0; )
          f[b--] = 0;
    }, Math.clz32 ? s.prototype._countBits = function(f) {
      return 32 - Math.clz32(f);
    } : s.prototype._countBits = function(f) {
      var g = f, b = 0;
      return g >= 4096 && (b += 13, g >>>= 13), g >= 64 && (b += 7, g >>>= 7), g >= 8 && (b += 4, g >>>= 4), g >= 2 && (b += 2, g >>>= 2), b + g;
    }, s.prototype._zeroBits = function(f) {
      if (f === 0) return 26;
      var g = f, b = 0;
      return g & 8191 || (b += 13, g >>>= 13), g & 127 || (b += 7, g >>>= 7), g & 15 || (b += 4, g >>>= 4), g & 3 || (b += 2, g >>>= 2), g & 1 || b++, b;
    }, s.prototype.bitLength = function() {
      var f = this.words[this.length - 1], g = this._countBits(f);
      return (this.length - 1) * 26 + g;
    };
    function L(m) {
      for (var f = new Array(m.bitLength()), g = 0; g < f.length; g++) {
        var b = g / 26 | 0, x = g % 26;
        f[g] = m.words[b] >>> x & 1;
      }
      return f;
    }
    s.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var f = 0, g = 0; g < this.length; g++) {
        var b = this._zeroBits(this.words[g]);
        if (f += b, b !== 26) break;
      }
      return f;
    }, s.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, s.prototype.toTwos = function(f) {
      return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone();
    }, s.prototype.fromTwos = function(f) {
      return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone();
    }, s.prototype.isNeg = function() {
      return this.negative !== 0;
    }, s.prototype.neg = function() {
      return this.clone().ineg();
    }, s.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, s.prototype.iuor = function(f) {
      for (; this.length < f.length; )
        this.words[this.length++] = 0;
      for (var g = 0; g < f.length; g++)
        this.words[g] = this.words[g] | f.words[g];
      return this._strip();
    }, s.prototype.ior = function(f) {
      return n((this.negative | f.negative) === 0), this.iuor(f);
    }, s.prototype.or = function(f) {
      return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this);
    }, s.prototype.uor = function(f) {
      return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this);
    }, s.prototype.iuand = function(f) {
      var g;
      this.length > f.length ? g = f : g = this;
      for (var b = 0; b < g.length; b++)
        this.words[b] = this.words[b] & f.words[b];
      return this.length = g.length, this._strip();
    }, s.prototype.iand = function(f) {
      return n((this.negative | f.negative) === 0), this.iuand(f);
    }, s.prototype.and = function(f) {
      return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this);
    }, s.prototype.uand = function(f) {
      return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this);
    }, s.prototype.iuxor = function(f) {
      var g, b;
      this.length > f.length ? (g = this, b = f) : (g = f, b = this);
      for (var x = 0; x < b.length; x++)
        this.words[x] = g.words[x] ^ b.words[x];
      if (this !== g)
        for (; x < g.length; x++)
          this.words[x] = g.words[x];
      return this.length = g.length, this._strip();
    }, s.prototype.ixor = function(f) {
      return n((this.negative | f.negative) === 0), this.iuxor(f);
    }, s.prototype.xor = function(f) {
      return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this);
    }, s.prototype.uxor = function(f) {
      return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this);
    }, s.prototype.inotn = function(f) {
      n(typeof f == "number" && f >= 0);
      var g = Math.ceil(f / 26) | 0, b = f % 26;
      this._expand(g), b > 0 && g--;
      for (var x = 0; x < g; x++)
        this.words[x] = ~this.words[x] & 67108863;
      return b > 0 && (this.words[x] = ~this.words[x] & 67108863 >> 26 - b), this._strip();
    }, s.prototype.notn = function(f) {
      return this.clone().inotn(f);
    }, s.prototype.setn = function(f, g) {
      n(typeof f == "number" && f >= 0);
      var b = f / 26 | 0, x = f % 26;
      return this._expand(b + 1), g ? this.words[b] = this.words[b] | 1 << x : this.words[b] = this.words[b] & ~(1 << x), this._strip();
    }, s.prototype.iadd = function(f) {
      var g;
      if (this.negative !== 0 && f.negative === 0)
        return this.negative = 0, g = this.isub(f), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && f.negative !== 0)
        return f.negative = 0, g = this.isub(f), f.negative = 1, g._normSign();
      var b, x;
      this.length > f.length ? (b = this, x = f) : (b = f, x = this);
      for (var _ = 0, E = 0; E < x.length; E++)
        g = (b.words[E] | 0) + (x.words[E] | 0) + _, this.words[E] = g & 67108863, _ = g >>> 26;
      for (; _ !== 0 && E < b.length; E++)
        g = (b.words[E] | 0) + _, this.words[E] = g & 67108863, _ = g >>> 26;
      if (this.length = b.length, _ !== 0)
        this.words[this.length] = _, this.length++;
      else if (b !== this)
        for (; E < b.length; E++)
          this.words[E] = b.words[E];
      return this;
    }, s.prototype.add = function(f) {
      var g;
      return f.negative !== 0 && this.negative === 0 ? (f.negative = 0, g = this.sub(f), f.negative ^= 1, g) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0, g = f.sub(this), this.negative = 1, g) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this);
    }, s.prototype.isub = function(f) {
      if (f.negative !== 0) {
        f.negative = 0;
        var g = this.iadd(f);
        return f.negative = 1, g._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
      var b = this.cmp(f);
      if (b === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var x, _;
      b > 0 ? (x = this, _ = f) : (x = f, _ = this);
      for (var E = 0, v = 0; v < _.length; v++)
        g = (x.words[v] | 0) - (_.words[v] | 0) + E, E = g >> 26, this.words[v] = g & 67108863;
      for (; E !== 0 && v < x.length; v++)
        g = (x.words[v] | 0) + E, E = g >> 26, this.words[v] = g & 67108863;
      if (E === 0 && v < x.length && x !== this)
        for (; v < x.length; v++)
          this.words[v] = x.words[v];
      return this.length = Math.max(this.length, v), x !== this && (this.negative = 1), this._strip();
    }, s.prototype.sub = function(f) {
      return this.clone().isub(f);
    };
    function F(m, f, g) {
      g.negative = f.negative ^ m.negative;
      var b = m.length + f.length | 0;
      g.length = b, b = b - 1 | 0;
      var x = m.words[0] | 0, _ = f.words[0] | 0, E = x * _, v = E & 67108863, M = E / 67108864 | 0;
      g.words[0] = v;
      for (var I = 1; I < b; I++) {
        for (var B = M >>> 26, ce = M & 67108863, D = Math.min(I, f.length - 1), oe = Math.max(0, I - m.length + 1); oe <= D; oe++) {
          var Z = I - oe | 0;
          x = m.words[Z] | 0, _ = f.words[oe] | 0, E = x * _ + ce, B += E / 67108864 | 0, ce = E & 67108863;
        }
        g.words[I] = ce | 0, M = B | 0;
      }
      return M !== 0 ? g.words[I] = M | 0 : g.length--, g._strip();
    }
    var $ = function(f, g, b) {
      var x = f.words, _ = g.words, E = b.words, v = 0, M, I, B, ce = x[0] | 0, D = ce & 8191, oe = ce >>> 13, Z = x[1] | 0, J = Z & 8191, Q = Z >>> 13, T = x[2] | 0, X = T & 8191, re = T >>> 13, de = x[3] | 0, ie = de & 8191, ue = de >>> 13, ve = x[4] | 0, Pe = ve & 8191, De = ve >>> 13, Ce = x[5] | 0, $e = Ce & 8191, Me = Ce >>> 13, Ne = x[6] | 0, Ke = Ne & 8191, Le = Ne >>> 13, qe = x[7] | 0, ze = qe & 8191, _e = qe >>> 13, Ze = x[8] | 0, at = Ze & 8191, ke = Ze >>> 13, Qe = x[9] | 0, tt = Qe & 8191, Ye = Qe >>> 13, dt = _[0] | 0, lt = dt & 8191, ct = dt >>> 13, qt = _[1] | 0, Yt = qt & 8191, Et = qt >>> 13, Qt = _[2] | 0, Jt = Qt & 8191, Dt = Qt >>> 13, kt = _[3] | 0, Ct = kt & 8191, gt = kt >>> 13, Rt = _[4] | 0, Nt = Rt & 8191, vt = Rt >>> 13, $t = _[5] | 0, Bt = $t & 8191, rt = $t >>> 13, Ft = _[6] | 0, k = Ft & 8191, j = Ft >>> 13, z = _[7] | 0, C = z & 8191, G = z >>> 13, U = _[8] | 0, se = U & 8191, he = U >>> 13, xe = _[9] | 0, Te = xe & 8191, Re = xe >>> 13;
      b.negative = f.negative ^ g.negative, b.length = 19, M = Math.imul(D, lt), I = Math.imul(D, ct), I = I + Math.imul(oe, lt) | 0, B = Math.imul(oe, ct);
      var nt = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (B + (I >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, M = Math.imul(J, lt), I = Math.imul(J, ct), I = I + Math.imul(Q, lt) | 0, B = Math.imul(Q, ct), M = M + Math.imul(D, Yt) | 0, I = I + Math.imul(D, Et) | 0, I = I + Math.imul(oe, Yt) | 0, B = B + Math.imul(oe, Et) | 0;
      var Ue = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (B + (I >>> 13) | 0) + (Ue >>> 26) | 0, Ue &= 67108863, M = Math.imul(X, lt), I = Math.imul(X, ct), I = I + Math.imul(re, lt) | 0, B = Math.imul(re, ct), M = M + Math.imul(J, Yt) | 0, I = I + Math.imul(J, Et) | 0, I = I + Math.imul(Q, Yt) | 0, B = B + Math.imul(Q, Et) | 0, M = M + Math.imul(D, Jt) | 0, I = I + Math.imul(D, Dt) | 0, I = I + Math.imul(oe, Jt) | 0, B = B + Math.imul(oe, Dt) | 0;
      var pt = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (B + (I >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, M = Math.imul(ie, lt), I = Math.imul(ie, ct), I = I + Math.imul(ue, lt) | 0, B = Math.imul(ue, ct), M = M + Math.imul(X, Yt) | 0, I = I + Math.imul(X, Et) | 0, I = I + Math.imul(re, Yt) | 0, B = B + Math.imul(re, Et) | 0, M = M + Math.imul(J, Jt) | 0, I = I + Math.imul(J, Dt) | 0, I = I + Math.imul(Q, Jt) | 0, B = B + Math.imul(Q, Dt) | 0, M = M + Math.imul(D, Ct) | 0, I = I + Math.imul(D, gt) | 0, I = I + Math.imul(oe, Ct) | 0, B = B + Math.imul(oe, gt) | 0;
      var it = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (B + (I >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, M = Math.imul(Pe, lt), I = Math.imul(Pe, ct), I = I + Math.imul(De, lt) | 0, B = Math.imul(De, ct), M = M + Math.imul(ie, Yt) | 0, I = I + Math.imul(ie, Et) | 0, I = I + Math.imul(ue, Yt) | 0, B = B + Math.imul(ue, Et) | 0, M = M + Math.imul(X, Jt) | 0, I = I + Math.imul(X, Dt) | 0, I = I + Math.imul(re, Jt) | 0, B = B + Math.imul(re, Dt) | 0, M = M + Math.imul(J, Ct) | 0, I = I + Math.imul(J, gt) | 0, I = I + Math.imul(Q, Ct) | 0, B = B + Math.imul(Q, gt) | 0, M = M + Math.imul(D, Nt) | 0, I = I + Math.imul(D, vt) | 0, I = I + Math.imul(oe, Nt) | 0, B = B + Math.imul(oe, vt) | 0;
      var et = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (B + (I >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, M = Math.imul($e, lt), I = Math.imul($e, ct), I = I + Math.imul(Me, lt) | 0, B = Math.imul(Me, ct), M = M + Math.imul(Pe, Yt) | 0, I = I + Math.imul(Pe, Et) | 0, I = I + Math.imul(De, Yt) | 0, B = B + Math.imul(De, Et) | 0, M = M + Math.imul(ie, Jt) | 0, I = I + Math.imul(ie, Dt) | 0, I = I + Math.imul(ue, Jt) | 0, B = B + Math.imul(ue, Dt) | 0, M = M + Math.imul(X, Ct) | 0, I = I + Math.imul(X, gt) | 0, I = I + Math.imul(re, Ct) | 0, B = B + Math.imul(re, gt) | 0, M = M + Math.imul(J, Nt) | 0, I = I + Math.imul(J, vt) | 0, I = I + Math.imul(Q, Nt) | 0, B = B + Math.imul(Q, vt) | 0, M = M + Math.imul(D, Bt) | 0, I = I + Math.imul(D, rt) | 0, I = I + Math.imul(oe, Bt) | 0, B = B + Math.imul(oe, rt) | 0;
      var St = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (B + (I >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, M = Math.imul(Ke, lt), I = Math.imul(Ke, ct), I = I + Math.imul(Le, lt) | 0, B = Math.imul(Le, ct), M = M + Math.imul($e, Yt) | 0, I = I + Math.imul($e, Et) | 0, I = I + Math.imul(Me, Yt) | 0, B = B + Math.imul(Me, Et) | 0, M = M + Math.imul(Pe, Jt) | 0, I = I + Math.imul(Pe, Dt) | 0, I = I + Math.imul(De, Jt) | 0, B = B + Math.imul(De, Dt) | 0, M = M + Math.imul(ie, Ct) | 0, I = I + Math.imul(ie, gt) | 0, I = I + Math.imul(ue, Ct) | 0, B = B + Math.imul(ue, gt) | 0, M = M + Math.imul(X, Nt) | 0, I = I + Math.imul(X, vt) | 0, I = I + Math.imul(re, Nt) | 0, B = B + Math.imul(re, vt) | 0, M = M + Math.imul(J, Bt) | 0, I = I + Math.imul(J, rt) | 0, I = I + Math.imul(Q, Bt) | 0, B = B + Math.imul(Q, rt) | 0, M = M + Math.imul(D, k) | 0, I = I + Math.imul(D, j) | 0, I = I + Math.imul(oe, k) | 0, B = B + Math.imul(oe, j) | 0;
      var Tt = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (B + (I >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, M = Math.imul(ze, lt), I = Math.imul(ze, ct), I = I + Math.imul(_e, lt) | 0, B = Math.imul(_e, ct), M = M + Math.imul(Ke, Yt) | 0, I = I + Math.imul(Ke, Et) | 0, I = I + Math.imul(Le, Yt) | 0, B = B + Math.imul(Le, Et) | 0, M = M + Math.imul($e, Jt) | 0, I = I + Math.imul($e, Dt) | 0, I = I + Math.imul(Me, Jt) | 0, B = B + Math.imul(Me, Dt) | 0, M = M + Math.imul(Pe, Ct) | 0, I = I + Math.imul(Pe, gt) | 0, I = I + Math.imul(De, Ct) | 0, B = B + Math.imul(De, gt) | 0, M = M + Math.imul(ie, Nt) | 0, I = I + Math.imul(ie, vt) | 0, I = I + Math.imul(ue, Nt) | 0, B = B + Math.imul(ue, vt) | 0, M = M + Math.imul(X, Bt) | 0, I = I + Math.imul(X, rt) | 0, I = I + Math.imul(re, Bt) | 0, B = B + Math.imul(re, rt) | 0, M = M + Math.imul(J, k) | 0, I = I + Math.imul(J, j) | 0, I = I + Math.imul(Q, k) | 0, B = B + Math.imul(Q, j) | 0, M = M + Math.imul(D, C) | 0, I = I + Math.imul(D, G) | 0, I = I + Math.imul(oe, C) | 0, B = B + Math.imul(oe, G) | 0;
      var At = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (B + (I >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, M = Math.imul(at, lt), I = Math.imul(at, ct), I = I + Math.imul(ke, lt) | 0, B = Math.imul(ke, ct), M = M + Math.imul(ze, Yt) | 0, I = I + Math.imul(ze, Et) | 0, I = I + Math.imul(_e, Yt) | 0, B = B + Math.imul(_e, Et) | 0, M = M + Math.imul(Ke, Jt) | 0, I = I + Math.imul(Ke, Dt) | 0, I = I + Math.imul(Le, Jt) | 0, B = B + Math.imul(Le, Dt) | 0, M = M + Math.imul($e, Ct) | 0, I = I + Math.imul($e, gt) | 0, I = I + Math.imul(Me, Ct) | 0, B = B + Math.imul(Me, gt) | 0, M = M + Math.imul(Pe, Nt) | 0, I = I + Math.imul(Pe, vt) | 0, I = I + Math.imul(De, Nt) | 0, B = B + Math.imul(De, vt) | 0, M = M + Math.imul(ie, Bt) | 0, I = I + Math.imul(ie, rt) | 0, I = I + Math.imul(ue, Bt) | 0, B = B + Math.imul(ue, rt) | 0, M = M + Math.imul(X, k) | 0, I = I + Math.imul(X, j) | 0, I = I + Math.imul(re, k) | 0, B = B + Math.imul(re, j) | 0, M = M + Math.imul(J, C) | 0, I = I + Math.imul(J, G) | 0, I = I + Math.imul(Q, C) | 0, B = B + Math.imul(Q, G) | 0, M = M + Math.imul(D, se) | 0, I = I + Math.imul(D, he) | 0, I = I + Math.imul(oe, se) | 0, B = B + Math.imul(oe, he) | 0;
      var _t = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (B + (I >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, M = Math.imul(tt, lt), I = Math.imul(tt, ct), I = I + Math.imul(Ye, lt) | 0, B = Math.imul(Ye, ct), M = M + Math.imul(at, Yt) | 0, I = I + Math.imul(at, Et) | 0, I = I + Math.imul(ke, Yt) | 0, B = B + Math.imul(ke, Et) | 0, M = M + Math.imul(ze, Jt) | 0, I = I + Math.imul(ze, Dt) | 0, I = I + Math.imul(_e, Jt) | 0, B = B + Math.imul(_e, Dt) | 0, M = M + Math.imul(Ke, Ct) | 0, I = I + Math.imul(Ke, gt) | 0, I = I + Math.imul(Le, Ct) | 0, B = B + Math.imul(Le, gt) | 0, M = M + Math.imul($e, Nt) | 0, I = I + Math.imul($e, vt) | 0, I = I + Math.imul(Me, Nt) | 0, B = B + Math.imul(Me, vt) | 0, M = M + Math.imul(Pe, Bt) | 0, I = I + Math.imul(Pe, rt) | 0, I = I + Math.imul(De, Bt) | 0, B = B + Math.imul(De, rt) | 0, M = M + Math.imul(ie, k) | 0, I = I + Math.imul(ie, j) | 0, I = I + Math.imul(ue, k) | 0, B = B + Math.imul(ue, j) | 0, M = M + Math.imul(X, C) | 0, I = I + Math.imul(X, G) | 0, I = I + Math.imul(re, C) | 0, B = B + Math.imul(re, G) | 0, M = M + Math.imul(J, se) | 0, I = I + Math.imul(J, he) | 0, I = I + Math.imul(Q, se) | 0, B = B + Math.imul(Q, he) | 0, M = M + Math.imul(D, Te) | 0, I = I + Math.imul(D, Re) | 0, I = I + Math.imul(oe, Te) | 0, B = B + Math.imul(oe, Re) | 0;
      var ht = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (B + (I >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, M = Math.imul(tt, Yt), I = Math.imul(tt, Et), I = I + Math.imul(Ye, Yt) | 0, B = Math.imul(Ye, Et), M = M + Math.imul(at, Jt) | 0, I = I + Math.imul(at, Dt) | 0, I = I + Math.imul(ke, Jt) | 0, B = B + Math.imul(ke, Dt) | 0, M = M + Math.imul(ze, Ct) | 0, I = I + Math.imul(ze, gt) | 0, I = I + Math.imul(_e, Ct) | 0, B = B + Math.imul(_e, gt) | 0, M = M + Math.imul(Ke, Nt) | 0, I = I + Math.imul(Ke, vt) | 0, I = I + Math.imul(Le, Nt) | 0, B = B + Math.imul(Le, vt) | 0, M = M + Math.imul($e, Bt) | 0, I = I + Math.imul($e, rt) | 0, I = I + Math.imul(Me, Bt) | 0, B = B + Math.imul(Me, rt) | 0, M = M + Math.imul(Pe, k) | 0, I = I + Math.imul(Pe, j) | 0, I = I + Math.imul(De, k) | 0, B = B + Math.imul(De, j) | 0, M = M + Math.imul(ie, C) | 0, I = I + Math.imul(ie, G) | 0, I = I + Math.imul(ue, C) | 0, B = B + Math.imul(ue, G) | 0, M = M + Math.imul(X, se) | 0, I = I + Math.imul(X, he) | 0, I = I + Math.imul(re, se) | 0, B = B + Math.imul(re, he) | 0, M = M + Math.imul(J, Te) | 0, I = I + Math.imul(J, Re) | 0, I = I + Math.imul(Q, Te) | 0, B = B + Math.imul(Q, Re) | 0;
      var xt = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (B + (I >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, M = Math.imul(tt, Jt), I = Math.imul(tt, Dt), I = I + Math.imul(Ye, Jt) | 0, B = Math.imul(Ye, Dt), M = M + Math.imul(at, Ct) | 0, I = I + Math.imul(at, gt) | 0, I = I + Math.imul(ke, Ct) | 0, B = B + Math.imul(ke, gt) | 0, M = M + Math.imul(ze, Nt) | 0, I = I + Math.imul(ze, vt) | 0, I = I + Math.imul(_e, Nt) | 0, B = B + Math.imul(_e, vt) | 0, M = M + Math.imul(Ke, Bt) | 0, I = I + Math.imul(Ke, rt) | 0, I = I + Math.imul(Le, Bt) | 0, B = B + Math.imul(Le, rt) | 0, M = M + Math.imul($e, k) | 0, I = I + Math.imul($e, j) | 0, I = I + Math.imul(Me, k) | 0, B = B + Math.imul(Me, j) | 0, M = M + Math.imul(Pe, C) | 0, I = I + Math.imul(Pe, G) | 0, I = I + Math.imul(De, C) | 0, B = B + Math.imul(De, G) | 0, M = M + Math.imul(ie, se) | 0, I = I + Math.imul(ie, he) | 0, I = I + Math.imul(ue, se) | 0, B = B + Math.imul(ue, he) | 0, M = M + Math.imul(X, Te) | 0, I = I + Math.imul(X, Re) | 0, I = I + Math.imul(re, Te) | 0, B = B + Math.imul(re, Re) | 0;
      var st = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (B + (I >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, M = Math.imul(tt, Ct), I = Math.imul(tt, gt), I = I + Math.imul(Ye, Ct) | 0, B = Math.imul(Ye, gt), M = M + Math.imul(at, Nt) | 0, I = I + Math.imul(at, vt) | 0, I = I + Math.imul(ke, Nt) | 0, B = B + Math.imul(ke, vt) | 0, M = M + Math.imul(ze, Bt) | 0, I = I + Math.imul(ze, rt) | 0, I = I + Math.imul(_e, Bt) | 0, B = B + Math.imul(_e, rt) | 0, M = M + Math.imul(Ke, k) | 0, I = I + Math.imul(Ke, j) | 0, I = I + Math.imul(Le, k) | 0, B = B + Math.imul(Le, j) | 0, M = M + Math.imul($e, C) | 0, I = I + Math.imul($e, G) | 0, I = I + Math.imul(Me, C) | 0, B = B + Math.imul(Me, G) | 0, M = M + Math.imul(Pe, se) | 0, I = I + Math.imul(Pe, he) | 0, I = I + Math.imul(De, se) | 0, B = B + Math.imul(De, he) | 0, M = M + Math.imul(ie, Te) | 0, I = I + Math.imul(ie, Re) | 0, I = I + Math.imul(ue, Te) | 0, B = B + Math.imul(ue, Re) | 0;
      var bt = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (B + (I >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, M = Math.imul(tt, Nt), I = Math.imul(tt, vt), I = I + Math.imul(Ye, Nt) | 0, B = Math.imul(Ye, vt), M = M + Math.imul(at, Bt) | 0, I = I + Math.imul(at, rt) | 0, I = I + Math.imul(ke, Bt) | 0, B = B + Math.imul(ke, rt) | 0, M = M + Math.imul(ze, k) | 0, I = I + Math.imul(ze, j) | 0, I = I + Math.imul(_e, k) | 0, B = B + Math.imul(_e, j) | 0, M = M + Math.imul(Ke, C) | 0, I = I + Math.imul(Ke, G) | 0, I = I + Math.imul(Le, C) | 0, B = B + Math.imul(Le, G) | 0, M = M + Math.imul($e, se) | 0, I = I + Math.imul($e, he) | 0, I = I + Math.imul(Me, se) | 0, B = B + Math.imul(Me, he) | 0, M = M + Math.imul(Pe, Te) | 0, I = I + Math.imul(Pe, Re) | 0, I = I + Math.imul(De, Te) | 0, B = B + Math.imul(De, Re) | 0;
      var ut = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (B + (I >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, M = Math.imul(tt, Bt), I = Math.imul(tt, rt), I = I + Math.imul(Ye, Bt) | 0, B = Math.imul(Ye, rt), M = M + Math.imul(at, k) | 0, I = I + Math.imul(at, j) | 0, I = I + Math.imul(ke, k) | 0, B = B + Math.imul(ke, j) | 0, M = M + Math.imul(ze, C) | 0, I = I + Math.imul(ze, G) | 0, I = I + Math.imul(_e, C) | 0, B = B + Math.imul(_e, G) | 0, M = M + Math.imul(Ke, se) | 0, I = I + Math.imul(Ke, he) | 0, I = I + Math.imul(Le, se) | 0, B = B + Math.imul(Le, he) | 0, M = M + Math.imul($e, Te) | 0, I = I + Math.imul($e, Re) | 0, I = I + Math.imul(Me, Te) | 0, B = B + Math.imul(Me, Re) | 0;
      var ot = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (B + (I >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, M = Math.imul(tt, k), I = Math.imul(tt, j), I = I + Math.imul(Ye, k) | 0, B = Math.imul(Ye, j), M = M + Math.imul(at, C) | 0, I = I + Math.imul(at, G) | 0, I = I + Math.imul(ke, C) | 0, B = B + Math.imul(ke, G) | 0, M = M + Math.imul(ze, se) | 0, I = I + Math.imul(ze, he) | 0, I = I + Math.imul(_e, se) | 0, B = B + Math.imul(_e, he) | 0, M = M + Math.imul(Ke, Te) | 0, I = I + Math.imul(Ke, Re) | 0, I = I + Math.imul(Le, Te) | 0, B = B + Math.imul(Le, Re) | 0;
      var Se = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (B + (I >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, M = Math.imul(tt, C), I = Math.imul(tt, G), I = I + Math.imul(Ye, C) | 0, B = Math.imul(Ye, G), M = M + Math.imul(at, se) | 0, I = I + Math.imul(at, he) | 0, I = I + Math.imul(ke, se) | 0, B = B + Math.imul(ke, he) | 0, M = M + Math.imul(ze, Te) | 0, I = I + Math.imul(ze, Re) | 0, I = I + Math.imul(_e, Te) | 0, B = B + Math.imul(_e, Re) | 0;
      var Ae = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (B + (I >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, M = Math.imul(tt, se), I = Math.imul(tt, he), I = I + Math.imul(Ye, se) | 0, B = Math.imul(Ye, he), M = M + Math.imul(at, Te) | 0, I = I + Math.imul(at, Re) | 0, I = I + Math.imul(ke, Te) | 0, B = B + Math.imul(ke, Re) | 0;
      var Ve = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (B + (I >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, M = Math.imul(tt, Te), I = Math.imul(tt, Re), I = I + Math.imul(Ye, Te) | 0, B = Math.imul(Ye, Re);
      var Be = (v + M | 0) + ((I & 8191) << 13) | 0;
      return v = (B + (I >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, E[0] = nt, E[1] = Ue, E[2] = pt, E[3] = it, E[4] = et, E[5] = St, E[6] = Tt, E[7] = At, E[8] = _t, E[9] = ht, E[10] = xt, E[11] = st, E[12] = bt, E[13] = ut, E[14] = ot, E[15] = Se, E[16] = Ae, E[17] = Ve, E[18] = Be, v !== 0 && (E[19] = v, b.length++), b;
    };
    Math.imul || ($ = F);
    function K(m, f, g) {
      g.negative = f.negative ^ m.negative, g.length = m.length + f.length;
      for (var b = 0, x = 0, _ = 0; _ < g.length - 1; _++) {
        var E = x;
        x = 0;
        for (var v = b & 67108863, M = Math.min(_, f.length - 1), I = Math.max(0, _ - m.length + 1); I <= M; I++) {
          var B = _ - I, ce = m.words[B] | 0, D = f.words[I] | 0, oe = ce * D, Z = oe & 67108863;
          E = E + (oe / 67108864 | 0) | 0, Z = Z + v | 0, v = Z & 67108863, E = E + (Z >>> 26) | 0, x += E >>> 26, E &= 67108863;
        }
        g.words[_] = v, b = E, E = x;
      }
      return b !== 0 ? g.words[_] = b : g.length--, g._strip();
    }
    function H(m, f, g) {
      return K(m, f, g);
    }
    s.prototype.mulTo = function(f, g) {
      var b, x = this.length + f.length;
      return this.length === 10 && f.length === 10 ? b = $(this, f, g) : x < 63 ? b = F(this, f, g) : x < 1024 ? b = K(this, f, g) : b = H(this, f, g), b;
    }, s.prototype.mul = function(f) {
      var g = new s(null);
      return g.words = new Array(this.length + f.length), this.mulTo(f, g);
    }, s.prototype.mulf = function(f) {
      var g = new s(null);
      return g.words = new Array(this.length + f.length), H(this, f, g);
    }, s.prototype.imul = function(f) {
      return this.clone().mulTo(f, this);
    }, s.prototype.imuln = function(f) {
      var g = f < 0;
      g && (f = -f), n(typeof f == "number"), n(f < 67108864);
      for (var b = 0, x = 0; x < this.length; x++) {
        var _ = (this.words[x] | 0) * f, E = (_ & 67108863) + (b & 67108863);
        b >>= 26, b += _ / 67108864 | 0, b += E >>> 26, this.words[x] = E & 67108863;
      }
      return b !== 0 && (this.words[x] = b, this.length++), g ? this.ineg() : this;
    }, s.prototype.muln = function(f) {
      return this.clone().imuln(f);
    }, s.prototype.sqr = function() {
      return this.mul(this);
    }, s.prototype.isqr = function() {
      return this.imul(this.clone());
    }, s.prototype.pow = function(f) {
      var g = L(f);
      if (g.length === 0) return new s(1);
      for (var b = this, x = 0; x < g.length && g[x] === 0; x++, b = b.sqr())
        ;
      if (++x < g.length)
        for (var _ = b.sqr(); x < g.length; x++, _ = _.sqr())
          g[x] !== 0 && (b = b.mul(_));
      return b;
    }, s.prototype.iushln = function(f) {
      n(typeof f == "number" && f >= 0);
      var g = f % 26, b = (f - g) / 26, x = 67108863 >>> 26 - g << 26 - g, _;
      if (g !== 0) {
        var E = 0;
        for (_ = 0; _ < this.length; _++) {
          var v = this.words[_] & x, M = (this.words[_] | 0) - v << g;
          this.words[_] = M | E, E = v >>> 26 - g;
        }
        E && (this.words[_] = E, this.length++);
      }
      if (b !== 0) {
        for (_ = this.length - 1; _ >= 0; _--)
          this.words[_ + b] = this.words[_];
        for (_ = 0; _ < b; _++)
          this.words[_] = 0;
        this.length += b;
      }
      return this._strip();
    }, s.prototype.ishln = function(f) {
      return n(this.negative === 0), this.iushln(f);
    }, s.prototype.iushrn = function(f, g, b) {
      n(typeof f == "number" && f >= 0);
      var x;
      g ? x = (g - g % 26) / 26 : x = 0;
      var _ = f % 26, E = Math.min((f - _) / 26, this.length), v = 67108863 ^ 67108863 >>> _ << _, M = b;
      if (x -= E, x = Math.max(0, x), M) {
        for (var I = 0; I < E; I++)
          M.words[I] = this.words[I];
        M.length = E;
      }
      if (E !== 0) if (this.length > E)
        for (this.length -= E, I = 0; I < this.length; I++)
          this.words[I] = this.words[I + E];
      else
        this.words[0] = 0, this.length = 1;
      var B = 0;
      for (I = this.length - 1; I >= 0 && (B !== 0 || I >= x); I--) {
        var ce = this.words[I] | 0;
        this.words[I] = B << 26 - _ | ce >>> _, B = ce & v;
      }
      return M && B !== 0 && (M.words[M.length++] = B), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, s.prototype.ishrn = function(f, g, b) {
      return n(this.negative === 0), this.iushrn(f, g, b);
    }, s.prototype.shln = function(f) {
      return this.clone().ishln(f);
    }, s.prototype.ushln = function(f) {
      return this.clone().iushln(f);
    }, s.prototype.shrn = function(f) {
      return this.clone().ishrn(f);
    }, s.prototype.ushrn = function(f) {
      return this.clone().iushrn(f);
    }, s.prototype.testn = function(f) {
      n(typeof f == "number" && f >= 0);
      var g = f % 26, b = (f - g) / 26, x = 1 << g;
      if (this.length <= b) return !1;
      var _ = this.words[b];
      return !!(_ & x);
    }, s.prototype.imaskn = function(f) {
      n(typeof f == "number" && f >= 0);
      var g = f % 26, b = (f - g) / 26;
      if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= b)
        return this;
      if (g !== 0 && b++, this.length = Math.min(b, this.length), g !== 0) {
        var x = 67108863 ^ 67108863 >>> g << g;
        this.words[this.length - 1] &= x;
      }
      return this._strip();
    }, s.prototype.maskn = function(f) {
      return this.clone().imaskn(f);
    }, s.prototype.iaddn = function(f) {
      return n(typeof f == "number"), n(f < 67108864), f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f);
    }, s.prototype._iaddn = function(f) {
      this.words[0] += f;
      for (var g = 0; g < this.length && this.words[g] >= 67108864; g++)
        this.words[g] -= 67108864, g === this.length - 1 ? this.words[g + 1] = 1 : this.words[g + 1]++;
      return this.length = Math.max(this.length, g + 1), this;
    }, s.prototype.isubn = function(f) {
      if (n(typeof f == "number"), n(f < 67108864), f < 0) return this.iaddn(-f);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(f), this.negative = 1, this;
      if (this.words[0] -= f, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var g = 0; g < this.length && this.words[g] < 0; g++)
          this.words[g] += 67108864, this.words[g + 1] -= 1;
      return this._strip();
    }, s.prototype.addn = function(f) {
      return this.clone().iaddn(f);
    }, s.prototype.subn = function(f) {
      return this.clone().isubn(f);
    }, s.prototype.iabs = function() {
      return this.negative = 0, this;
    }, s.prototype.abs = function() {
      return this.clone().iabs();
    }, s.prototype._ishlnsubmul = function(f, g, b) {
      var x = f.length + b, _;
      this._expand(x);
      var E, v = 0;
      for (_ = 0; _ < f.length; _++) {
        E = (this.words[_ + b] | 0) + v;
        var M = (f.words[_] | 0) * g;
        E -= M & 67108863, v = (E >> 26) - (M / 67108864 | 0), this.words[_ + b] = E & 67108863;
      }
      for (; _ < this.length - b; _++)
        E = (this.words[_ + b] | 0) + v, v = E >> 26, this.words[_ + b] = E & 67108863;
      if (v === 0) return this._strip();
      for (n(v === -1), v = 0, _ = 0; _ < this.length; _++)
        E = -(this.words[_] | 0) + v, v = E >> 26, this.words[_] = E & 67108863;
      return this.negative = 1, this._strip();
    }, s.prototype._wordDiv = function(f, g) {
      var b = this.length - f.length, x = this.clone(), _ = f, E = _.words[_.length - 1] | 0, v = this._countBits(E);
      b = 26 - v, b !== 0 && (_ = _.ushln(b), x.iushln(b), E = _.words[_.length - 1] | 0);
      var M = x.length - _.length, I;
      if (g !== "mod") {
        I = new s(null), I.length = M + 1, I.words = new Array(I.length);
        for (var B = 0; B < I.length; B++)
          I.words[B] = 0;
      }
      var ce = x.clone()._ishlnsubmul(_, 1, M);
      ce.negative === 0 && (x = ce, I && (I.words[M] = 1));
      for (var D = M - 1; D >= 0; D--) {
        var oe = (x.words[_.length + D] | 0) * 67108864 + (x.words[_.length + D - 1] | 0);
        for (oe = Math.min(oe / E | 0, 67108863), x._ishlnsubmul(_, oe, D); x.negative !== 0; )
          oe--, x.negative = 0, x._ishlnsubmul(_, 1, D), x.isZero() || (x.negative ^= 1);
        I && (I.words[D] = oe);
      }
      return I && I._strip(), x._strip(), g !== "div" && b !== 0 && x.iushrn(b), {
        div: I || null,
        mod: x
      };
    }, s.prototype.divmod = function(f, g, b) {
      if (n(!f.isZero()), this.isZero())
        return {
          div: new s(0),
          mod: new s(0)
        };
      var x, _, E;
      return this.negative !== 0 && f.negative === 0 ? (E = this.neg().divmod(f, g), g !== "mod" && (x = E.div.neg()), g !== "div" && (_ = E.mod.neg(), b && _.negative !== 0 && _.iadd(f)), {
        div: x,
        mod: _
      }) : this.negative === 0 && f.negative !== 0 ? (E = this.divmod(f.neg(), g), g !== "mod" && (x = E.div.neg()), {
        div: x,
        mod: E.mod
      }) : this.negative & f.negative ? (E = this.neg().divmod(f.neg(), g), g !== "div" && (_ = E.mod.neg(), b && _.negative !== 0 && _.isub(f)), {
        div: E.div,
        mod: _
      }) : f.length > this.length || this.cmp(f) < 0 ? {
        div: new s(0),
        mod: this
      } : f.length === 1 ? g === "div" ? {
        div: this.divn(f.words[0]),
        mod: null
      } : g === "mod" ? {
        div: null,
        mod: new s(this.modrn(f.words[0]))
      } : {
        div: this.divn(f.words[0]),
        mod: new s(this.modrn(f.words[0]))
      } : this._wordDiv(f, g);
    }, s.prototype.div = function(f) {
      return this.divmod(f, "div", !1).div;
    }, s.prototype.mod = function(f) {
      return this.divmod(f, "mod", !1).mod;
    }, s.prototype.umod = function(f) {
      return this.divmod(f, "mod", !0).mod;
    }, s.prototype.divRound = function(f) {
      var g = this.divmod(f);
      if (g.mod.isZero()) return g.div;
      var b = g.div.negative !== 0 ? g.mod.isub(f) : g.mod, x = f.ushrn(1), _ = f.andln(1), E = b.cmp(x);
      return E < 0 || _ === 1 && E === 0 ? g.div : g.div.negative !== 0 ? g.div.isubn(1) : g.div.iaddn(1);
    }, s.prototype.modrn = function(f) {
      var g = f < 0;
      g && (f = -f), n(f <= 67108863);
      for (var b = (1 << 26) % f, x = 0, _ = this.length - 1; _ >= 0; _--)
        x = (b * x + (this.words[_] | 0)) % f;
      return g ? -x : x;
    }, s.prototype.modn = function(f) {
      return this.modrn(f);
    }, s.prototype.idivn = function(f) {
      var g = f < 0;
      g && (f = -f), n(f <= 67108863);
      for (var b = 0, x = this.length - 1; x >= 0; x--) {
        var _ = (this.words[x] | 0) + b * 67108864;
        this.words[x] = _ / f | 0, b = _ % f;
      }
      return this._strip(), g ? this.ineg() : this;
    }, s.prototype.divn = function(f) {
      return this.clone().idivn(f);
    }, s.prototype.egcd = function(f) {
      n(f.negative === 0), n(!f.isZero());
      var g = this, b = f.clone();
      g.negative !== 0 ? g = g.umod(f) : g = g.clone();
      for (var x = new s(1), _ = new s(0), E = new s(0), v = new s(1), M = 0; g.isEven() && b.isEven(); )
        g.iushrn(1), b.iushrn(1), ++M;
      for (var I = b.clone(), B = g.clone(); !g.isZero(); ) {
        for (var ce = 0, D = 1; !(g.words[0] & D) && ce < 26; ++ce, D <<= 1) ;
        if (ce > 0)
          for (g.iushrn(ce); ce-- > 0; )
            (x.isOdd() || _.isOdd()) && (x.iadd(I), _.isub(B)), x.iushrn(1), _.iushrn(1);
        for (var oe = 0, Z = 1; !(b.words[0] & Z) && oe < 26; ++oe, Z <<= 1) ;
        if (oe > 0)
          for (b.iushrn(oe); oe-- > 0; )
            (E.isOdd() || v.isOdd()) && (E.iadd(I), v.isub(B)), E.iushrn(1), v.iushrn(1);
        g.cmp(b) >= 0 ? (g.isub(b), x.isub(E), _.isub(v)) : (b.isub(g), E.isub(x), v.isub(_));
      }
      return {
        a: E,
        b: v,
        gcd: b.iushln(M)
      };
    }, s.prototype._invmp = function(f) {
      n(f.negative === 0), n(!f.isZero());
      var g = this, b = f.clone();
      g.negative !== 0 ? g = g.umod(f) : g = g.clone();
      for (var x = new s(1), _ = new s(0), E = b.clone(); g.cmpn(1) > 0 && b.cmpn(1) > 0; ) {
        for (var v = 0, M = 1; !(g.words[0] & M) && v < 26; ++v, M <<= 1) ;
        if (v > 0)
          for (g.iushrn(v); v-- > 0; )
            x.isOdd() && x.iadd(E), x.iushrn(1);
        for (var I = 0, B = 1; !(b.words[0] & B) && I < 26; ++I, B <<= 1) ;
        if (I > 0)
          for (b.iushrn(I); I-- > 0; )
            _.isOdd() && _.iadd(E), _.iushrn(1);
        g.cmp(b) >= 0 ? (g.isub(b), x.isub(_)) : (b.isub(g), _.isub(x));
      }
      var ce;
      return g.cmpn(1) === 0 ? ce = x : ce = _, ce.cmpn(0) < 0 && ce.iadd(f), ce;
    }, s.prototype.gcd = function(f) {
      if (this.isZero()) return f.abs();
      if (f.isZero()) return this.abs();
      var g = this.clone(), b = f.clone();
      g.negative = 0, b.negative = 0;
      for (var x = 0; g.isEven() && b.isEven(); x++)
        g.iushrn(1), b.iushrn(1);
      do {
        for (; g.isEven(); )
          g.iushrn(1);
        for (; b.isEven(); )
          b.iushrn(1);
        var _ = g.cmp(b);
        if (_ < 0) {
          var E = g;
          g = b, b = E;
        } else if (_ === 0 || b.cmpn(1) === 0)
          break;
        g.isub(b);
      } while (!0);
      return b.iushln(x);
    }, s.prototype.invm = function(f) {
      return this.egcd(f).a.umod(f);
    }, s.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, s.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, s.prototype.andln = function(f) {
      return this.words[0] & f;
    }, s.prototype.bincn = function(f) {
      n(typeof f == "number");
      var g = f % 26, b = (f - g) / 26, x = 1 << g;
      if (this.length <= b)
        return this._expand(b + 1), this.words[b] |= x, this;
      for (var _ = x, E = b; _ !== 0 && E < this.length; E++) {
        var v = this.words[E] | 0;
        v += _, _ = v >>> 26, v &= 67108863, this.words[E] = v;
      }
      return _ !== 0 && (this.words[E] = _, this.length++), this;
    }, s.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, s.prototype.cmpn = function(f) {
      var g = f < 0;
      if (this.negative !== 0 && !g) return -1;
      if (this.negative === 0 && g) return 1;
      this._strip();
      var b;
      if (this.length > 1)
        b = 1;
      else {
        g && (f = -f), n(f <= 67108863, "Number is too big");
        var x = this.words[0] | 0;
        b = x === f ? 0 : x < f ? -1 : 1;
      }
      return this.negative !== 0 ? -b | 0 : b;
    }, s.prototype.cmp = function(f) {
      if (this.negative !== 0 && f.negative === 0) return -1;
      if (this.negative === 0 && f.negative !== 0) return 1;
      var g = this.ucmp(f);
      return this.negative !== 0 ? -g | 0 : g;
    }, s.prototype.ucmp = function(f) {
      if (this.length > f.length) return 1;
      if (this.length < f.length) return -1;
      for (var g = 0, b = this.length - 1; b >= 0; b--) {
        var x = this.words[b] | 0, _ = f.words[b] | 0;
        if (x !== _) {
          x < _ ? g = -1 : x > _ && (g = 1);
          break;
        }
      }
      return g;
    }, s.prototype.gtn = function(f) {
      return this.cmpn(f) === 1;
    }, s.prototype.gt = function(f) {
      return this.cmp(f) === 1;
    }, s.prototype.gten = function(f) {
      return this.cmpn(f) >= 0;
    }, s.prototype.gte = function(f) {
      return this.cmp(f) >= 0;
    }, s.prototype.ltn = function(f) {
      return this.cmpn(f) === -1;
    }, s.prototype.lt = function(f) {
      return this.cmp(f) === -1;
    }, s.prototype.lten = function(f) {
      return this.cmpn(f) <= 0;
    }, s.prototype.lte = function(f) {
      return this.cmp(f) <= 0;
    }, s.prototype.eqn = function(f) {
      return this.cmpn(f) === 0;
    }, s.prototype.eq = function(f) {
      return this.cmp(f) === 0;
    }, s.red = function(f) {
      return new Y(f);
    }, s.prototype.toRed = function(f) {
      return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), f.convertTo(this)._forceRed(f);
    }, s.prototype.fromRed = function() {
      return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, s.prototype._forceRed = function(f) {
      return this.red = f, this;
    }, s.prototype.forceRed = function(f) {
      return n(!this.red, "Already a number in reduction context"), this._forceRed(f);
    }, s.prototype.redAdd = function(f) {
      return n(this.red, "redAdd works only with red numbers"), this.red.add(this, f);
    }, s.prototype.redIAdd = function(f) {
      return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f);
    }, s.prototype.redSub = function(f) {
      return n(this.red, "redSub works only with red numbers"), this.red.sub(this, f);
    }, s.prototype.redISub = function(f) {
      return n(this.red, "redISub works only with red numbers"), this.red.isub(this, f);
    }, s.prototype.redShl = function(f) {
      return n(this.red, "redShl works only with red numbers"), this.red.shl(this, f);
    }, s.prototype.redMul = function(f) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f);
    }, s.prototype.redIMul = function(f) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f);
    }, s.prototype.redSqr = function() {
      return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, s.prototype.redISqr = function() {
      return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, s.prototype.redSqrt = function() {
      return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, s.prototype.redInvm = function() {
      return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, s.prototype.redNeg = function() {
      return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, s.prototype.redPow = function(f) {
      return n(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f);
    };
    var V = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function te(m, f) {
      this.name = m, this.p = new s(f, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    te.prototype._tmp = function() {
      var f = new s(null);
      return f.words = new Array(Math.ceil(this.n / 13)), f;
    }, te.prototype.ireduce = function(f) {
      var g = f, b;
      do
        this.split(g, this.tmp), g = this.imulK(g), g = g.iadd(this.tmp), b = g.bitLength();
      while (b > this.n);
      var x = b < this.n ? -1 : g.ucmp(this.p);
      return x === 0 ? (g.words[0] = 0, g.length = 1) : x > 0 ? g.isub(this.p) : g.strip !== void 0 ? g.strip() : g._strip(), g;
    }, te.prototype.split = function(f, g) {
      f.iushrn(this.n, 0, g);
    }, te.prototype.imulK = function(f) {
      return f.imul(this.k);
    };
    function R() {
      te.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(R, te), R.prototype.split = function(f, g) {
      for (var b = 4194303, x = Math.min(f.length, 9), _ = 0; _ < x; _++)
        g.words[_] = f.words[_];
      if (g.length = x, f.length <= 9) {
        f.words[0] = 0, f.length = 1;
        return;
      }
      var E = f.words[9];
      for (g.words[g.length++] = E & b, _ = 10; _ < f.length; _++) {
        var v = f.words[_] | 0;
        f.words[_ - 10] = (v & b) << 4 | E >>> 22, E = v;
      }
      E >>>= 22, f.words[_ - 10] = E, E === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9;
    }, R.prototype.imulK = function(f) {
      f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
      for (var g = 0, b = 0; b < f.length; b++) {
        var x = f.words[b] | 0;
        g += x * 977, f.words[b] = g & 67108863, g = x * 64 + (g / 67108864 | 0);
      }
      return f.words[f.length - 1] === 0 && (f.length--, f.words[f.length - 1] === 0 && f.length--), f;
    };
    function W() {
      te.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(W, te);
    function pe() {
      te.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(pe, te);
    function Ee() {
      te.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(Ee, te), Ee.prototype.imulK = function(f) {
      for (var g = 0, b = 0; b < f.length; b++) {
        var x = (f.words[b] | 0) * 19 + g, _ = x & 67108863;
        x >>>= 26, f.words[b] = _, g = x;
      }
      return g !== 0 && (f.words[f.length++] = g), f;
    }, s._prime = function(f) {
      if (V[f]) return V[f];
      var g;
      if (f === "k256")
        g = new R();
      else if (f === "p224")
        g = new W();
      else if (f === "p192")
        g = new pe();
      else if (f === "p25519")
        g = new Ee();
      else
        throw new Error("Unknown prime " + f);
      return V[f] = g, g;
    };
    function Y(m) {
      if (typeof m == "string") {
        var f = s._prime(m);
        this.m = f.p, this.prime = f;
      } else
        n(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null;
    }
    Y.prototype._verify1 = function(f) {
      n(f.negative === 0, "red works only with positives"), n(f.red, "red works only with red numbers");
    }, Y.prototype._verify2 = function(f, g) {
      n((f.negative | g.negative) === 0, "red works only with positives"), n(
        f.red && f.red === g.red,
        "red works only with red numbers"
      );
    }, Y.prototype.imod = function(f) {
      return this.prime ? this.prime.ireduce(f)._forceRed(this) : (d(f, f.umod(this.m)._forceRed(this)), f);
    }, Y.prototype.neg = function(f) {
      return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this);
    }, Y.prototype.add = function(f, g) {
      this._verify2(f, g);
      var b = f.add(g);
      return b.cmp(this.m) >= 0 && b.isub(this.m), b._forceRed(this);
    }, Y.prototype.iadd = function(f, g) {
      this._verify2(f, g);
      var b = f.iadd(g);
      return b.cmp(this.m) >= 0 && b.isub(this.m), b;
    }, Y.prototype.sub = function(f, g) {
      this._verify2(f, g);
      var b = f.sub(g);
      return b.cmpn(0) < 0 && b.iadd(this.m), b._forceRed(this);
    }, Y.prototype.isub = function(f, g) {
      this._verify2(f, g);
      var b = f.isub(g);
      return b.cmpn(0) < 0 && b.iadd(this.m), b;
    }, Y.prototype.shl = function(f, g) {
      return this._verify1(f), this.imod(f.ushln(g));
    }, Y.prototype.imul = function(f, g) {
      return this._verify2(f, g), this.imod(f.imul(g));
    }, Y.prototype.mul = function(f, g) {
      return this._verify2(f, g), this.imod(f.mul(g));
    }, Y.prototype.isqr = function(f) {
      return this.imul(f, f.clone());
    }, Y.prototype.sqr = function(f) {
      return this.mul(f, f);
    }, Y.prototype.sqrt = function(f) {
      if (f.isZero()) return f.clone();
      var g = this.m.andln(3);
      if (n(g % 2 === 1), g === 3) {
        var b = this.m.add(new s(1)).iushrn(2);
        return this.pow(f, b);
      }
      for (var x = this.m.subn(1), _ = 0; !x.isZero() && x.andln(1) === 0; )
        _++, x.iushrn(1);
      n(!x.isZero());
      var E = new s(1).toRed(this), v = E.redNeg(), M = this.m.subn(1).iushrn(1), I = this.m.bitLength();
      for (I = new s(2 * I * I).toRed(this); this.pow(I, M).cmp(v) !== 0; )
        I.redIAdd(v);
      for (var B = this.pow(I, x), ce = this.pow(f, x.addn(1).iushrn(1)), D = this.pow(f, x), oe = _; D.cmp(E) !== 0; ) {
        for (var Z = D, J = 0; Z.cmp(E) !== 0; J++)
          Z = Z.redSqr();
        n(J < oe);
        var Q = this.pow(B, new s(1).iushln(oe - J - 1));
        ce = ce.redMul(Q), B = Q.redSqr(), D = D.redMul(B), oe = J;
      }
      return ce;
    }, Y.prototype.invm = function(f) {
      var g = f._invmp(this.m);
      return g.negative !== 0 ? (g.negative = 0, this.imod(g).redNeg()) : this.imod(g);
    }, Y.prototype.pow = function(f, g) {
      if (g.isZero()) return new s(1).toRed(this);
      if (g.cmpn(1) === 0) return f.clone();
      var b = 4, x = new Array(1 << b);
      x[0] = new s(1).toRed(this), x[1] = f;
      for (var _ = 2; _ < x.length; _++)
        x[_] = this.mul(x[_ - 1], f);
      var E = x[0], v = 0, M = 0, I = g.bitLength() % 26;
      for (I === 0 && (I = 26), _ = g.length - 1; _ >= 0; _--) {
        for (var B = g.words[_], ce = I - 1; ce >= 0; ce--) {
          var D = B >> ce & 1;
          if (E !== x[0] && (E = this.sqr(E)), D === 0 && v === 0) {
            M = 0;
            continue;
          }
          v <<= 1, v |= D, M++, !(M !== b && (_ !== 0 || ce !== 0)) && (E = this.mul(E, x[v]), M = 0, v = 0);
        }
        I = 26;
      }
      return E;
    }, Y.prototype.convertTo = function(f) {
      var g = f.umod(this.m);
      return g === f ? g.clone() : g;
    }, Y.prototype.convertFrom = function(f) {
      var g = f.clone();
      return g.red = null, g;
    }, s.mont = function(f) {
      return new S(f);
    };
    function S(m) {
      Y.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(S, Y), S.prototype.convertTo = function(f) {
      return this.imod(f.ushln(this.shift));
    }, S.prototype.convertFrom = function(f) {
      var g = this.imod(f.mul(this.rinv));
      return g.red = null, g;
    }, S.prototype.imul = function(f, g) {
      if (f.isZero() || g.isZero())
        return f.words[0] = 0, f.length = 1, f;
      var b = f.imul(g), x = b.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), _ = b.isub(x).iushrn(this.shift), E = _;
      return _.cmp(this.m) >= 0 ? E = _.isub(this.m) : _.cmpn(0) < 0 && (E = _.iadd(this.m)), E._forceRed(this);
    }, S.prototype.mul = function(f, g) {
      if (f.isZero() || g.isZero()) return new s(0)._forceRed(this);
      var b = f.mul(g), x = b.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), _ = b.isub(x).iushrn(this.shift), E = _;
      return _.cmp(this.m) >= 0 ? E = _.isub(this.m) : _.cmpn(0) < 0 && (E = _.iadd(this.m)), E._forceRed(this);
    }, S.prototype.invm = function(f) {
      var g = this.imod(f._invmp(this.m).mul(this.r2));
      return g._forceRed(this);
    };
  })(t, gn);
})(qv);
var xB = qv.exports;
const ir = /* @__PURE__ */ ts(xB);
var _B = ir.BN;
function EB(t) {
  return new _B(t, 36).toString(16);
}
const SB = "strings/5.7.0", AB = new Yr(SB);
var t0;
(function(t) {
  t.current = "", t.NFC = "NFC", t.NFD = "NFD", t.NFKC = "NFKC", t.NFKD = "NFKD";
})(t0 || (t0 = {}));
var vx;
(function(t) {
  t.UNEXPECTED_CONTINUE = "unexpected continuation byte", t.BAD_PREFIX = "bad codepoint prefix", t.OVERRUN = "string overrun", t.MISSING_CONTINUE = "missing continuation byte", t.OUT_OF_RANGE = "out of UTF-8 range", t.UTF16_SURROGATE = "UTF-16 surrogate", t.OVERLONG = "overlong representation";
})(vx || (vx = {}));
function em(t, e = t0.current) {
  e != t0.current && (AB.checkNormalize(), t = t.normalize(e));
  let r = [];
  for (let n = 0; n < t.length; n++) {
    const i = t.charCodeAt(n);
    if (i < 128)
      r.push(i);
    else if (i < 2048)
      r.push(i >> 6 | 192), r.push(i & 63 | 128);
    else if ((i & 64512) == 55296) {
      n++;
      const s = t.charCodeAt(n);
      if (n >= t.length || (s & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const o = 65536 + ((i & 1023) << 10) + (s & 1023);
      r.push(o >> 18 | 240), r.push(o >> 12 & 63 | 128), r.push(o >> 6 & 63 | 128), r.push(o & 63 | 128);
    } else
      r.push(i >> 12 | 224), r.push(i >> 6 & 63 | 128), r.push(i & 63 | 128);
  }
  return wn(r);
}
const PB = `Ethereum Signed Message:
`;
function V4(t) {
  return typeof t == "string" && (t = em(t)), jv(bB([
    em(PB),
    em(String(t.length)),
    t
  ]));
}
const MB = "address/5.7.0", kf = new Yr(MB);
function bx(t) {
  qs(t, 20) || kf.throwArgumentError("invalid address", "address", t), t = t.toLowerCase();
  const e = t.substring(2).split(""), r = new Uint8Array(40);
  for (let i = 0; i < 40; i++)
    r[i] = e[i].charCodeAt(0);
  const n = wn(jv(r));
  for (let i = 0; i < 40; i += 2)
    n[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (n[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
  return "0x" + e.join("");
}
const IB = 9007199254740991;
function CB(t) {
  return Math.log10 ? Math.log10(t) : Math.log(t) / Math.LN10;
}
const zv = {};
for (let t = 0; t < 10; t++)
  zv[String(t)] = String(t);
for (let t = 0; t < 26; t++)
  zv[String.fromCharCode(65 + t)] = String(10 + t);
const yx = Math.floor(CB(IB));
function TB(t) {
  t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
  let e = t.split("").map((n) => zv[n]).join("");
  for (; e.length >= yx; ) {
    let n = e.substring(0, yx);
    e = parseInt(n, 10) % 97 + e.substring(n.length);
  }
  let r = String(98 - parseInt(e, 10) % 97);
  for (; r.length < 2; )
    r = "0" + r;
  return r;
}
function RB(t) {
  let e = null;
  if (typeof t != "string" && kf.throwArgumentError("invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/))
    t.substring(0, 2) !== "0x" && (t = "0x" + t), e = bx(t), t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== t && kf.throwArgumentError("bad address checksum", "address", t);
  else if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (t.substring(2, 4) !== TB(t) && kf.throwArgumentError("bad icap checksum", "address", t), e = EB(t.substring(4)); e.length < 40; )
      e = "0" + e;
    e = bx("0x" + e);
  } else
    kf.throwArgumentError("invalid address", "address", t);
  return e;
}
function xf(t, e, r) {
  Object.defineProperty(t, e, {
    enumerable: !0,
    value: r,
    writable: !1
  });
}
var Kl = {}, xr = {}, yc = G4;
function G4(t, e) {
  if (!t)
    throw new Error(e || "Assertion failed");
}
G4.equal = function(e, r, n) {
  if (e != r)
    throw new Error(n || "Assertion failed: " + e + " != " + r);
};
var w1 = { exports: {} };
typeof Object.create == "function" ? w1.exports = function(e, r) {
  r && (e.super_ = r, e.prototype = Object.create(r.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : w1.exports = function(e, r) {
  if (r) {
    e.super_ = r;
    var n = function() {
    };
    n.prototype = r.prototype, e.prototype = new n(), e.prototype.constructor = e;
  }
};
var q0 = w1.exports, DB = yc, OB = q0;
xr.inherits = OB;
function NB(t, e) {
  return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? !1 : (t.charCodeAt(e + 1) & 64512) === 56320;
}
function LB(t, e) {
  if (Array.isArray(t))
    return t.slice();
  if (!t)
    return [];
  var r = [];
  if (typeof t == "string")
    if (e) {
      if (e === "hex")
        for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), i = 0; i < t.length; i += 2)
          r.push(parseInt(t[i] + t[i + 1], 16));
    } else for (var n = 0, i = 0; i < t.length; i++) {
      var s = t.charCodeAt(i);
      s < 128 ? r[n++] = s : s < 2048 ? (r[n++] = s >> 6 | 192, r[n++] = s & 63 | 128) : NB(t, i) ? (s = 65536 + ((s & 1023) << 10) + (t.charCodeAt(++i) & 1023), r[n++] = s >> 18 | 240, r[n++] = s >> 12 & 63 | 128, r[n++] = s >> 6 & 63 | 128, r[n++] = s & 63 | 128) : (r[n++] = s >> 12 | 224, r[n++] = s >> 6 & 63 | 128, r[n++] = s & 63 | 128);
    }
  else
    for (i = 0; i < t.length; i++)
      r[i] = t[i] | 0;
  return r;
}
xr.toArray = LB;
function kB(t) {
  for (var e = "", r = 0; r < t.length; r++)
    e += J4(t[r].toString(16));
  return e;
}
xr.toHex = kB;
function Y4(t) {
  var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
  return e >>> 0;
}
xr.htonl = Y4;
function $B(t, e) {
  for (var r = "", n = 0; n < t.length; n++) {
    var i = t[n];
    e === "little" && (i = Y4(i)), r += X4(i.toString(16));
  }
  return r;
}
xr.toHex32 = $B;
function J4(t) {
  return t.length === 1 ? "0" + t : t;
}
xr.zero2 = J4;
function X4(t) {
  return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
}
xr.zero8 = X4;
function FB(t, e, r, n) {
  var i = r - e;
  DB(i % 4 === 0);
  for (var s = new Array(i / 4), o = 0, a = e; o < s.length; o++, a += 4) {
    var u;
    n === "big" ? u = t[a] << 24 | t[a + 1] << 16 | t[a + 2] << 8 | t[a + 3] : u = t[a + 3] << 24 | t[a + 2] << 16 | t[a + 1] << 8 | t[a], s[o] = u >>> 0;
  }
  return s;
}
xr.join32 = FB;
function BB(t, e) {
  for (var r = new Array(t.length * 4), n = 0, i = 0; n < t.length; n++, i += 4) {
    var s = t[n];
    e === "big" ? (r[i] = s >>> 24, r[i + 1] = s >>> 16 & 255, r[i + 2] = s >>> 8 & 255, r[i + 3] = s & 255) : (r[i + 3] = s >>> 24, r[i + 2] = s >>> 16 & 255, r[i + 1] = s >>> 8 & 255, r[i] = s & 255);
  }
  return r;
}
xr.split32 = BB;
function UB(t, e) {
  return t >>> e | t << 32 - e;
}
xr.rotr32 = UB;
function jB(t, e) {
  return t << e | t >>> 32 - e;
}
xr.rotl32 = jB;
function qB(t, e) {
  return t + e >>> 0;
}
xr.sum32 = qB;
function zB(t, e, r) {
  return t + e + r >>> 0;
}
xr.sum32_3 = zB;
function HB(t, e, r, n) {
  return t + e + r + n >>> 0;
}
xr.sum32_4 = HB;
function WB(t, e, r, n, i) {
  return t + e + r + n + i >>> 0;
}
xr.sum32_5 = WB;
function KB(t, e, r, n) {
  var i = t[e], s = t[e + 1], o = n + s >>> 0, a = (o < n ? 1 : 0) + r + i;
  t[e] = a >>> 0, t[e + 1] = o;
}
xr.sum64 = KB;
function VB(t, e, r, n) {
  var i = e + n >>> 0, s = (i < e ? 1 : 0) + t + r;
  return s >>> 0;
}
xr.sum64_hi = VB;
function GB(t, e, r, n) {
  var i = e + n;
  return i >>> 0;
}
xr.sum64_lo = GB;
function YB(t, e, r, n, i, s, o, a) {
  var u = 0, l = e;
  l = l + n >>> 0, u += l < e ? 1 : 0, l = l + s >>> 0, u += l < s ? 1 : 0, l = l + a >>> 0, u += l < a ? 1 : 0;
  var d = t + r + i + o + u;
  return d >>> 0;
}
xr.sum64_4_hi = YB;
function JB(t, e, r, n, i, s, o, a) {
  var u = e + n + s + a;
  return u >>> 0;
}
xr.sum64_4_lo = JB;
function XB(t, e, r, n, i, s, o, a, u, l) {
  var d = 0, p = e;
  p = p + n >>> 0, d += p < e ? 1 : 0, p = p + s >>> 0, d += p < s ? 1 : 0, p = p + a >>> 0, d += p < a ? 1 : 0, p = p + l >>> 0, d += p < l ? 1 : 0;
  var w = t + r + i + o + u + d;
  return w >>> 0;
}
xr.sum64_5_hi = XB;
function ZB(t, e, r, n, i, s, o, a, u, l) {
  var d = e + n + s + a + l;
  return d >>> 0;
}
xr.sum64_5_lo = ZB;
function QB(t, e, r) {
  var n = e << 32 - r | t >>> r;
  return n >>> 0;
}
xr.rotr64_hi = QB;
function eU(t, e, r) {
  var n = t << 32 - r | e >>> r;
  return n >>> 0;
}
xr.rotr64_lo = eU;
function tU(t, e, r) {
  return t >>> r;
}
xr.shr64_hi = tU;
function rU(t, e, r) {
  var n = t << 32 - r | e >>> r;
  return n >>> 0;
}
xr.shr64_lo = rU;
var Nu = {}, wx = xr, nU = yc;
function z0() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
Nu.BlockHash = z0;
z0.prototype.update = function(e, r) {
  if (e = wx.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
    e = this.pending;
    var n = e.length % this._delta8;
    this.pending = e.slice(e.length - n, e.length), this.pending.length === 0 && (this.pending = null), e = wx.join32(e, 0, e.length - n, this.endian);
    for (var i = 0; i < e.length; i += this._delta32)
      this._update(e, i, i + this._delta32);
  }
  return this;
};
z0.prototype.digest = function(e) {
  return this.update(this._pad()), nU(this.pending === null), this._digest(e);
};
z0.prototype._pad = function() {
  var e = this.pendingTotal, r = this._delta8, n = r - (e + this.padLength) % r, i = new Array(n + this.padLength);
  i[0] = 128;
  for (var s = 1; s < n; s++)
    i[s] = 0;
  if (e <<= 3, this.endian === "big") {
    for (var o = 8; o < this.padLength; o++)
      i[s++] = 0;
    i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = e >>> 24 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 8 & 255, i[s++] = e & 255;
  } else
    for (i[s++] = e & 255, i[s++] = e >>> 8 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 24 & 255, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, o = 8; o < this.padLength; o++)
      i[s++] = 0;
  return i;
};
var Lu = {}, to = {}, iU = xr, zs = iU.rotr32;
function sU(t, e, r, n) {
  if (t === 0)
    return Z4(e, r, n);
  if (t === 1 || t === 3)
    return e8(e, r, n);
  if (t === 2)
    return Q4(e, r, n);
}
to.ft_1 = sU;
function Z4(t, e, r) {
  return t & e ^ ~t & r;
}
to.ch32 = Z4;
function Q4(t, e, r) {
  return t & e ^ t & r ^ e & r;
}
to.maj32 = Q4;
function e8(t, e, r) {
  return t ^ e ^ r;
}
to.p32 = e8;
function oU(t) {
  return zs(t, 2) ^ zs(t, 13) ^ zs(t, 22);
}
to.s0_256 = oU;
function aU(t) {
  return zs(t, 6) ^ zs(t, 11) ^ zs(t, 25);
}
to.s1_256 = aU;
function cU(t) {
  return zs(t, 7) ^ zs(t, 18) ^ t >>> 3;
}
to.g0_256 = cU;
function uU(t) {
  return zs(t, 17) ^ zs(t, 19) ^ t >>> 10;
}
to.g1_256 = uU;
var xu = xr, fU = Nu, lU = to, tm = xu.rotl32, _f = xu.sum32, hU = xu.sum32_5, dU = lU.ft_1, t8 = fU.BlockHash, pU = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function Ys() {
  if (!(this instanceof Ys))
    return new Ys();
  t8.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
xu.inherits(Ys, t8);
var gU = Ys;
Ys.blockSize = 512;
Ys.outSize = 160;
Ys.hmacStrength = 80;
Ys.padLength = 64;
Ys.prototype._update = function(e, r) {
  for (var n = this.W, i = 0; i < 16; i++)
    n[i] = e[r + i];
  for (; i < n.length; i++)
    n[i] = tm(n[i - 3] ^ n[i - 8] ^ n[i - 14] ^ n[i - 16], 1);
  var s = this.h[0], o = this.h[1], a = this.h[2], u = this.h[3], l = this.h[4];
  for (i = 0; i < n.length; i++) {
    var d = ~~(i / 20), p = hU(tm(s, 5), dU(d, o, a, u), l, n[i], pU[d]);
    l = u, u = a, a = tm(o, 30), o = s, s = p;
  }
  this.h[0] = _f(this.h[0], s), this.h[1] = _f(this.h[1], o), this.h[2] = _f(this.h[2], a), this.h[3] = _f(this.h[3], u), this.h[4] = _f(this.h[4], l);
};
Ys.prototype._digest = function(e) {
  return e === "hex" ? xu.toHex32(this.h, "big") : xu.split32(this.h, "big");
};
var _u = xr, mU = Nu, ku = to, vU = yc, ps = _u.sum32, bU = _u.sum32_4, yU = _u.sum32_5, wU = ku.ch32, xU = ku.maj32, _U = ku.s0_256, EU = ku.s1_256, SU = ku.g0_256, AU = ku.g1_256, r8 = mU.BlockHash, PU = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function Js() {
  if (!(this instanceof Js))
    return new Js();
  r8.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = PU, this.W = new Array(64);
}
_u.inherits(Js, r8);
var n8 = Js;
Js.blockSize = 512;
Js.outSize = 256;
Js.hmacStrength = 192;
Js.padLength = 64;
Js.prototype._update = function(e, r) {
  for (var n = this.W, i = 0; i < 16; i++)
    n[i] = e[r + i];
  for (; i < n.length; i++)
    n[i] = bU(AU(n[i - 2]), n[i - 7], SU(n[i - 15]), n[i - 16]);
  var s = this.h[0], o = this.h[1], a = this.h[2], u = this.h[3], l = this.h[4], d = this.h[5], p = this.h[6], w = this.h[7];
  for (vU(this.k.length === n.length), i = 0; i < n.length; i++) {
    var P = yU(w, EU(l), wU(l, d, p), this.k[i], n[i]), A = ps(_U(s), xU(s, o, a));
    w = p, p = d, d = l, l = ps(u, P), u = a, a = o, o = s, s = ps(P, A);
  }
  this.h[0] = ps(this.h[0], s), this.h[1] = ps(this.h[1], o), this.h[2] = ps(this.h[2], a), this.h[3] = ps(this.h[3], u), this.h[4] = ps(this.h[4], l), this.h[5] = ps(this.h[5], d), this.h[6] = ps(this.h[6], p), this.h[7] = ps(this.h[7], w);
};
Js.prototype._digest = function(e) {
  return e === "hex" ? _u.toHex32(this.h, "big") : _u.split32(this.h, "big");
};
var x1 = xr, i8 = n8;
function Fo() {
  if (!(this instanceof Fo))
    return new Fo();
  i8.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
x1.inherits(Fo, i8);
var MU = Fo;
Fo.blockSize = 512;
Fo.outSize = 224;
Fo.hmacStrength = 192;
Fo.padLength = 64;
Fo.prototype._digest = function(e) {
  return e === "hex" ? x1.toHex32(this.h.slice(0, 7), "big") : x1.split32(this.h.slice(0, 7), "big");
};
var xi = xr, IU = Nu, CU = yc, Hs = xi.rotr64_hi, Ws = xi.rotr64_lo, s8 = xi.shr64_hi, o8 = xi.shr64_lo, ea = xi.sum64, rm = xi.sum64_hi, nm = xi.sum64_lo, TU = xi.sum64_4_hi, RU = xi.sum64_4_lo, DU = xi.sum64_5_hi, OU = xi.sum64_5_lo, a8 = IU.BlockHash, NU = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function Es() {
  if (!(this instanceof Es))
    return new Es();
  a8.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = NU, this.W = new Array(160);
}
xi.inherits(Es, a8);
var c8 = Es;
Es.blockSize = 1024;
Es.outSize = 512;
Es.hmacStrength = 192;
Es.padLength = 128;
Es.prototype._prepareBlock = function(e, r) {
  for (var n = this.W, i = 0; i < 32; i++)
    n[i] = e[r + i];
  for (; i < n.length; i += 2) {
    var s = WU(n[i - 4], n[i - 3]), o = KU(n[i - 4], n[i - 3]), a = n[i - 14], u = n[i - 13], l = zU(n[i - 30], n[i - 29]), d = HU(n[i - 30], n[i - 29]), p = n[i - 32], w = n[i - 31];
    n[i] = TU(
      s,
      o,
      a,
      u,
      l,
      d,
      p,
      w
    ), n[i + 1] = RU(
      s,
      o,
      a,
      u,
      l,
      d,
      p,
      w
    );
  }
};
Es.prototype._update = function(e, r) {
  this._prepareBlock(e, r);
  var n = this.W, i = this.h[0], s = this.h[1], o = this.h[2], a = this.h[3], u = this.h[4], l = this.h[5], d = this.h[6], p = this.h[7], w = this.h[8], P = this.h[9], A = this.h[10], N = this.h[11], L = this.h[12], F = this.h[13], $ = this.h[14], K = this.h[15];
  CU(this.k.length === n.length);
  for (var H = 0; H < n.length; H += 2) {
    var V = $, te = K, R = jU(w, P), W = qU(w, P), pe = LU(w, P, A, N, L), Ee = kU(w, P, A, N, L, F), Y = this.k[H], S = this.k[H + 1], m = n[H], f = n[H + 1], g = DU(
      V,
      te,
      R,
      W,
      pe,
      Ee,
      Y,
      S,
      m,
      f
    ), b = OU(
      V,
      te,
      R,
      W,
      pe,
      Ee,
      Y,
      S,
      m,
      f
    );
    V = BU(i, s), te = UU(i, s), R = $U(i, s, o, a, u), W = FU(i, s, o, a, u, l);
    var x = rm(V, te, R, W), _ = nm(V, te, R, W);
    $ = L, K = F, L = A, F = N, A = w, N = P, w = rm(d, p, g, b), P = nm(p, p, g, b), d = u, p = l, u = o, l = a, o = i, a = s, i = rm(g, b, x, _), s = nm(g, b, x, _);
  }
  ea(this.h, 0, i, s), ea(this.h, 2, o, a), ea(this.h, 4, u, l), ea(this.h, 6, d, p), ea(this.h, 8, w, P), ea(this.h, 10, A, N), ea(this.h, 12, L, F), ea(this.h, 14, $, K);
};
Es.prototype._digest = function(e) {
  return e === "hex" ? xi.toHex32(this.h, "big") : xi.split32(this.h, "big");
};
function LU(t, e, r, n, i) {
  var s = t & r ^ ~t & i;
  return s < 0 && (s += 4294967296), s;
}
function kU(t, e, r, n, i, s) {
  var o = e & n ^ ~e & s;
  return o < 0 && (o += 4294967296), o;
}
function $U(t, e, r, n, i) {
  var s = t & r ^ t & i ^ r & i;
  return s < 0 && (s += 4294967296), s;
}
function FU(t, e, r, n, i, s) {
  var o = e & n ^ e & s ^ n & s;
  return o < 0 && (o += 4294967296), o;
}
function BU(t, e) {
  var r = Hs(t, e, 28), n = Hs(e, t, 2), i = Hs(e, t, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function UU(t, e) {
  var r = Ws(t, e, 28), n = Ws(e, t, 2), i = Ws(e, t, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function jU(t, e) {
  var r = Hs(t, e, 14), n = Hs(t, e, 18), i = Hs(e, t, 9), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function qU(t, e) {
  var r = Ws(t, e, 14), n = Ws(t, e, 18), i = Ws(e, t, 9), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function zU(t, e) {
  var r = Hs(t, e, 1), n = Hs(t, e, 8), i = s8(t, e, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function HU(t, e) {
  var r = Ws(t, e, 1), n = Ws(t, e, 8), i = o8(t, e, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function WU(t, e) {
  var r = Hs(t, e, 19), n = Hs(e, t, 29), i = s8(t, e, 6), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function KU(t, e) {
  var r = Ws(t, e, 19), n = Ws(e, t, 29), i = o8(t, e, 6), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
var _1 = xr, u8 = c8;
function Bo() {
  if (!(this instanceof Bo))
    return new Bo();
  u8.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
_1.inherits(Bo, u8);
var VU = Bo;
Bo.blockSize = 1024;
Bo.outSize = 384;
Bo.hmacStrength = 192;
Bo.padLength = 128;
Bo.prototype._digest = function(e) {
  return e === "hex" ? _1.toHex32(this.h.slice(0, 12), "big") : _1.split32(this.h.slice(0, 12), "big");
};
Lu.sha1 = gU;
Lu.sha224 = MU;
Lu.sha256 = n8;
Lu.sha384 = VU;
Lu.sha512 = c8;
var f8 = {}, fc = xr, GU = Nu, cd = fc.rotl32, xx = fc.sum32, Ef = fc.sum32_3, _x = fc.sum32_4, l8 = GU.BlockHash;
function Xs() {
  if (!(this instanceof Xs))
    return new Xs();
  l8.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
fc.inherits(Xs, l8);
f8.ripemd160 = Xs;
Xs.blockSize = 512;
Xs.outSize = 160;
Xs.hmacStrength = 192;
Xs.padLength = 64;
Xs.prototype._update = function(e, r) {
  for (var n = this.h[0], i = this.h[1], s = this.h[2], o = this.h[3], a = this.h[4], u = n, l = i, d = s, p = o, w = a, P = 0; P < 80; P++) {
    var A = xx(
      cd(
        _x(n, Ex(P, i, s, o), e[XU[P] + r], YU(P)),
        QU[P]
      ),
      a
    );
    n = a, a = o, o = cd(s, 10), s = i, i = A, A = xx(
      cd(
        _x(u, Ex(79 - P, l, d, p), e[ZU[P] + r], JU(P)),
        ej[P]
      ),
      w
    ), u = w, w = p, p = cd(d, 10), d = l, l = A;
  }
  A = Ef(this.h[1], s, p), this.h[1] = Ef(this.h[2], o, w), this.h[2] = Ef(this.h[3], a, u), this.h[3] = Ef(this.h[4], n, l), this.h[4] = Ef(this.h[0], i, d), this.h[0] = A;
};
Xs.prototype._digest = function(e) {
  return e === "hex" ? fc.toHex32(this.h, "little") : fc.split32(this.h, "little");
};
function Ex(t, e, r, n) {
  return t <= 15 ? e ^ r ^ n : t <= 31 ? e & r | ~e & n : t <= 47 ? (e | ~r) ^ n : t <= 63 ? e & n | r & ~n : e ^ (r | ~n);
}
function YU(t) {
  return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
}
function JU(t) {
  return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
}
var XU = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], ZU = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], QU = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], ej = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], tj = xr, rj = yc;
function Eu(t, e, r) {
  if (!(this instanceof Eu))
    return new Eu(t, e, r);
  this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(tj.toArray(e, r));
}
var nj = Eu;
Eu.prototype._init = function(e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), rj(e.length <= this.blockSize);
  for (var r = e.length; r < this.blockSize; r++)
    e.push(0);
  for (r = 0; r < e.length; r++)
    e[r] ^= 54;
  for (this.inner = new this.Hash().update(e), r = 0; r < e.length; r++)
    e[r] ^= 106;
  this.outer = new this.Hash().update(e);
};
Eu.prototype.update = function(e, r) {
  return this.inner.update(e, r), this;
};
Eu.prototype.digest = function(e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function(t) {
  var e = t;
  e.utils = xr, e.common = Nu, e.sha = Lu, e.ripemd = f8, e.hmac = nj, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160;
})(Kl);
const bo = /* @__PURE__ */ ts(Kl);
function $u(t, e, r) {
  return r = {
    path: e,
    exports: {},
    require: function(n, i) {
      return ij(n, i ?? r.path);
    }
  }, t(r, r.exports), r.exports;
}
function ij() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var Hv = h8;
function h8(t, e) {
  if (!t)
    throw new Error(e || "Assertion failed");
}
h8.equal = function(e, r, n) {
  if (e != r)
    throw new Error(n || "Assertion failed: " + e + " != " + r);
};
var ws = $u(function(t, e) {
  var r = e;
  function n(o, a) {
    if (Array.isArray(o))
      return o.slice();
    if (!o)
      return [];
    var u = [];
    if (typeof o != "string") {
      for (var l = 0; l < o.length; l++)
        u[l] = o[l] | 0;
      return u;
    }
    if (a === "hex") {
      o = o.replace(/[^a-z0-9]+/ig, ""), o.length % 2 !== 0 && (o = "0" + o);
      for (var l = 0; l < o.length; l += 2)
        u.push(parseInt(o[l] + o[l + 1], 16));
    } else
      for (var l = 0; l < o.length; l++) {
        var d = o.charCodeAt(l), p = d >> 8, w = d & 255;
        p ? u.push(p, w) : u.push(w);
      }
    return u;
  }
  r.toArray = n;
  function i(o) {
    return o.length === 1 ? "0" + o : o;
  }
  r.zero2 = i;
  function s(o) {
    for (var a = "", u = 0; u < o.length; u++)
      a += i(o[u].toString(16));
    return a;
  }
  r.toHex = s, r.encode = function(a, u) {
    return u === "hex" ? s(a) : a;
  };
}), $i = $u(function(t, e) {
  var r = e;
  r.assert = Hv, r.toArray = ws.toArray, r.zero2 = ws.zero2, r.toHex = ws.toHex, r.encode = ws.encode;
  function n(u, l, d) {
    var p = new Array(Math.max(u.bitLength(), d) + 1);
    p.fill(0);
    for (var w = 1 << l + 1, P = u.clone(), A = 0; A < p.length; A++) {
      var N, L = P.andln(w - 1);
      P.isOdd() ? (L > (w >> 1) - 1 ? N = (w >> 1) - L : N = L, P.isubn(N)) : N = 0, p[A] = N, P.iushrn(1);
    }
    return p;
  }
  r.getNAF = n;
  function i(u, l) {
    var d = [
      [],
      []
    ];
    u = u.clone(), l = l.clone();
    for (var p = 0, w = 0, P; u.cmpn(-p) > 0 || l.cmpn(-w) > 0; ) {
      var A = u.andln(3) + p & 3, N = l.andln(3) + w & 3;
      A === 3 && (A = -1), N === 3 && (N = -1);
      var L;
      A & 1 ? (P = u.andln(7) + p & 7, (P === 3 || P === 5) && N === 2 ? L = -A : L = A) : L = 0, d[0].push(L);
      var F;
      N & 1 ? (P = l.andln(7) + w & 7, (P === 3 || P === 5) && A === 2 ? F = -N : F = N) : F = 0, d[1].push(F), 2 * p === L + 1 && (p = 1 - p), 2 * w === F + 1 && (w = 1 - w), u.iushrn(1), l.iushrn(1);
    }
    return d;
  }
  r.getJSF = i;
  function s(u, l, d) {
    var p = "_" + l;
    u.prototype[l] = function() {
      return this[p] !== void 0 ? this[p] : this[p] = d.call(this);
    };
  }
  r.cachedProperty = s;
  function o(u) {
    return typeof u == "string" ? r.toArray(u, "hex") : u;
  }
  r.parseBytes = o;
  function a(u) {
    return new ir(u, "hex", "le");
  }
  r.intFromLE = a;
}), r0 = $i.getNAF, sj = $i.getJSF, n0 = $i.assert;
function Ma(t, e) {
  this.type = t, this.p = new ir(e.p, 16), this.red = e.prime ? ir.red(e.prime) : ir.mont(this.p), this.zero = new ir(0).toRed(this.red), this.one = new ir(1).toRed(this.red), this.two = new ir(2).toRed(this.red), this.n = e.n && new ir(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var r = this.n && this.p.div(this.n);
  !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var wc = Ma;
Ma.prototype.point = function() {
  throw new Error("Not implemented");
};
Ma.prototype.validate = function() {
  throw new Error("Not implemented");
};
Ma.prototype._fixedNafMul = function(e, r) {
  n0(e.precomputed);
  var n = e._getDoubles(), i = r0(r, 1, this._bitLength), s = (1 << n.step + 1) - (n.step % 2 === 0 ? 2 : 1);
  s /= 3;
  var o = [], a, u;
  for (a = 0; a < i.length; a += n.step) {
    u = 0;
    for (var l = a + n.step - 1; l >= a; l--)
      u = (u << 1) + i[l];
    o.push(u);
  }
  for (var d = this.jpoint(null, null, null), p = this.jpoint(null, null, null), w = s; w > 0; w--) {
    for (a = 0; a < o.length; a++)
      u = o[a], u === w ? p = p.mixedAdd(n.points[a]) : u === -w && (p = p.mixedAdd(n.points[a].neg()));
    d = d.add(p);
  }
  return d.toP();
};
Ma.prototype._wnafMul = function(e, r) {
  var n = 4, i = e._getNAFPoints(n);
  n = i.wnd;
  for (var s = i.points, o = r0(r, n, this._bitLength), a = this.jpoint(null, null, null), u = o.length - 1; u >= 0; u--) {
    for (var l = 0; u >= 0 && o[u] === 0; u--)
      l++;
    if (u >= 0 && l++, a = a.dblp(l), u < 0)
      break;
    var d = o[u];
    n0(d !== 0), e.type === "affine" ? d > 0 ? a = a.mixedAdd(s[d - 1 >> 1]) : a = a.mixedAdd(s[-d - 1 >> 1].neg()) : d > 0 ? a = a.add(s[d - 1 >> 1]) : a = a.add(s[-d - 1 >> 1].neg());
  }
  return e.type === "affine" ? a.toP() : a;
};
Ma.prototype._wnafMulAdd = function(e, r, n, i, s) {
  var o = this._wnafT1, a = this._wnafT2, u = this._wnafT3, l = 0, d, p, w;
  for (d = 0; d < i; d++) {
    w = r[d];
    var P = w._getNAFPoints(e);
    o[d] = P.wnd, a[d] = P.points;
  }
  for (d = i - 1; d >= 1; d -= 2) {
    var A = d - 1, N = d;
    if (o[A] !== 1 || o[N] !== 1) {
      u[A] = r0(n[A], o[A], this._bitLength), u[N] = r0(n[N], o[N], this._bitLength), l = Math.max(u[A].length, l), l = Math.max(u[N].length, l);
      continue;
    }
    var L = [
      r[A],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      r[N]
      /* 7 */
    ];
    r[A].y.cmp(r[N].y) === 0 ? (L[1] = r[A].add(r[N]), L[2] = r[A].toJ().mixedAdd(r[N].neg())) : r[A].y.cmp(r[N].y.redNeg()) === 0 ? (L[1] = r[A].toJ().mixedAdd(r[N]), L[2] = r[A].add(r[N].neg())) : (L[1] = r[A].toJ().mixedAdd(r[N]), L[2] = r[A].toJ().mixedAdd(r[N].neg()));
    var F = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], $ = sj(n[A], n[N]);
    for (l = Math.max($[0].length, l), u[A] = new Array(l), u[N] = new Array(l), p = 0; p < l; p++) {
      var K = $[0][p] | 0, H = $[1][p] | 0;
      u[A][p] = F[(K + 1) * 3 + (H + 1)], u[N][p] = 0, a[A] = L;
    }
  }
  var V = this.jpoint(null, null, null), te = this._wnafT4;
  for (d = l; d >= 0; d--) {
    for (var R = 0; d >= 0; ) {
      var W = !0;
      for (p = 0; p < i; p++)
        te[p] = u[p][d] | 0, te[p] !== 0 && (W = !1);
      if (!W)
        break;
      R++, d--;
    }
    if (d >= 0 && R++, V = V.dblp(R), d < 0)
      break;
    for (p = 0; p < i; p++) {
      var pe = te[p];
      pe !== 0 && (pe > 0 ? w = a[p][pe - 1 >> 1] : pe < 0 && (w = a[p][-pe - 1 >> 1].neg()), w.type === "affine" ? V = V.mixedAdd(w) : V = V.add(w));
    }
  }
  for (d = 0; d < i; d++)
    a[d] = null;
  return s ? V : V.toP();
};
function ns(t, e) {
  this.curve = t, this.type = e, this.precomputed = null;
}
Ma.BasePoint = ns;
ns.prototype.eq = function() {
  throw new Error("Not implemented");
};
ns.prototype.validate = function() {
  return this.curve.validate(this);
};
Ma.prototype.decodePoint = function(e, r) {
  e = $i.toArray(e, r);
  var n = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * n) {
    e[0] === 6 ? n0(e[e.length - 1] % 2 === 0) : e[0] === 7 && n0(e[e.length - 1] % 2 === 1);
    var i = this.point(
      e.slice(1, 1 + n),
      e.slice(1 + n, 1 + 2 * n)
    );
    return i;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n)
    return this.pointFromX(e.slice(1, 1 + n), e[0] === 3);
  throw new Error("Unknown point format");
};
ns.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
ns.prototype._encode = function(e) {
  var r = this.curve.p.byteLength(), n = this.getX().toArray("be", r);
  return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", r));
};
ns.prototype.encode = function(e, r) {
  return $i.encode(this._encode(r), e);
};
ns.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var r = {
    doubles: null,
    naf: null,
    beta: null
  };
  return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
};
ns.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var r = this.precomputed.doubles;
  return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : !1;
};
ns.prototype._getDoubles = function(e, r) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var n = [this], i = this, s = 0; s < r; s += e) {
    for (var o = 0; o < e; o++)
      i = i.dbl();
    n.push(i);
  }
  return {
    step: e,
    points: n
  };
};
ns.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var r = [this], n = (1 << e) - 1, i = n === 1 ? null : this.dbl(), s = 1; s < n; s++)
    r[s] = r[s - 1].add(i);
  return {
    wnd: e,
    points: r
  };
};
ns.prototype._getBeta = function() {
  return null;
};
ns.prototype.dblp = function(e) {
  for (var r = this, n = 0; n < e; n++)
    r = r.dbl();
  return r;
};
var Wv = $u(function(t) {
  typeof Object.create == "function" ? t.exports = function(r, n) {
    n && (r.super_ = n, r.prototype = Object.create(n.prototype, {
      constructor: {
        value: r,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : t.exports = function(r, n) {
    if (n) {
      r.super_ = n;
      var i = function() {
      };
      i.prototype = n.prototype, r.prototype = new i(), r.prototype.constructor = r;
    }
  };
}), oj = $i.assert;
function is(t) {
  wc.call(this, "short", t), this.a = new ir(t.a, 16).toRed(this.red), this.b = new ir(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
Wv(is, wc);
var aj = is;
is.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var r, n;
    if (e.beta)
      r = new ir(e.beta, 16).toRed(this.red);
    else {
      var i = this._getEndoRoots(this.p);
      r = i[0].cmp(i[1]) < 0 ? i[0] : i[1], r = r.toRed(this.red);
    }
    if (e.lambda)
      n = new ir(e.lambda, 16);
    else {
      var s = this._getEndoRoots(this.n);
      this.g.mul(s[0]).x.cmp(this.g.x.redMul(r)) === 0 ? n = s[0] : (n = s[1], oj(this.g.mul(n).x.cmp(this.g.x.redMul(r)) === 0));
    }
    var o;
    return e.basis ? o = e.basis.map(function(a) {
      return {
        a: new ir(a.a, 16),
        b: new ir(a.b, 16)
      };
    }) : o = this._getEndoBasis(n), {
      beta: r,
      lambda: n,
      basis: o
    };
  }
};
is.prototype._getEndoRoots = function(e) {
  var r = e === this.p ? this.red : ir.mont(e), n = new ir(2).toRed(r).redInvm(), i = n.redNeg(), s = new ir(3).toRed(r).redNeg().redSqrt().redMul(n), o = i.redAdd(s).fromRed(), a = i.redSub(s).fromRed();
  return [o, a];
};
is.prototype._getEndoBasis = function(e) {
  for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), n = e, i = this.n.clone(), s = new ir(1), o = new ir(0), a = new ir(0), u = new ir(1), l, d, p, w, P, A, N, L = 0, F, $; n.cmpn(0) !== 0; ) {
    var K = i.div(n);
    F = i.sub(K.mul(n)), $ = a.sub(K.mul(s));
    var H = u.sub(K.mul(o));
    if (!p && F.cmp(r) < 0)
      l = N.neg(), d = s, p = F.neg(), w = $;
    else if (p && ++L === 2)
      break;
    N = F, i = n, n = F, a = s, s = $, u = o, o = H;
  }
  P = F.neg(), A = $;
  var V = p.sqr().add(w.sqr()), te = P.sqr().add(A.sqr());
  return te.cmp(V) >= 0 && (P = l, A = d), p.negative && (p = p.neg(), w = w.neg()), P.negative && (P = P.neg(), A = A.neg()), [
    { a: p, b: w },
    { a: P, b: A }
  ];
};
is.prototype._endoSplit = function(e) {
  var r = this.endo.basis, n = r[0], i = r[1], s = i.b.mul(e).divRound(this.n), o = n.b.neg().mul(e).divRound(this.n), a = s.mul(n.a), u = o.mul(i.a), l = s.mul(n.b), d = o.mul(i.b), p = e.sub(a).sub(u), w = l.add(d).neg();
  return { k1: p, k2: w };
};
is.prototype.pointFromX = function(e, r) {
  e = new ir(e, 16), e.red || (e = e.toRed(this.red));
  var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), i = n.redSqrt();
  if (i.redSqr().redSub(n).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var s = i.fromRed().isOdd();
  return (r && !s || !r && s) && (i = i.redNeg()), this.point(e, i);
};
is.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var r = e.x, n = e.y, i = this.a.redMul(r), s = r.redSqr().redMul(r).redIAdd(i).redIAdd(this.b);
  return n.redSqr().redISub(s).cmpn(0) === 0;
};
is.prototype._endoWnafMulAdd = function(e, r, n) {
  for (var i = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < e.length; o++) {
    var a = this._endoSplit(r[o]), u = e[o], l = u._getBeta();
    a.k1.negative && (a.k1.ineg(), u = u.neg(!0)), a.k2.negative && (a.k2.ineg(), l = l.neg(!0)), i[o * 2] = u, i[o * 2 + 1] = l, s[o * 2] = a.k1, s[o * 2 + 1] = a.k2;
  }
  for (var d = this._wnafMulAdd(1, i, s, o * 2, n), p = 0; p < o * 2; p++)
    i[p] = null, s[p] = null;
  return d;
};
function Ln(t, e, r, n) {
  wc.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new ir(e, 16), this.y = new ir(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
Wv(Ln, wc.BasePoint);
is.prototype.point = function(e, r, n) {
  return new Ln(this, e, r, n);
};
is.prototype.pointFromJSON = function(e, r) {
  return Ln.fromJSON(this, e, r);
};
Ln.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var n = this.curve, i = function(s) {
        return n.point(s.x.redMul(n.endo.beta), s.y);
      };
      e.beta = r, r.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(i)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(i)
        }
      };
    }
    return r;
  }
};
Ln.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Ln.fromJSON = function(e, r, n) {
  typeof r == "string" && (r = JSON.parse(r));
  var i = e.point(r[0], r[1], n);
  if (!r[2])
    return i;
  function s(a) {
    return e.point(a[0], a[1], n);
  }
  var o = r[2];
  return i.precomputed = {
    beta: null,
    doubles: o.doubles && {
      step: o.doubles.step,
      points: [i].concat(o.doubles.points.map(s))
    },
    naf: o.naf && {
      wnd: o.naf.wnd,
      points: [i].concat(o.naf.points.map(s))
    }
  }, i;
};
Ln.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Ln.prototype.isInfinity = function() {
  return this.inf;
};
Ln.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var r = this.y.redSub(e.y);
  r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
  var n = r.redSqr().redISub(this.x).redISub(e.x), i = r.redMul(this.x.redSub(n)).redISub(this.y);
  return this.curve.point(n, i);
};
Ln.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var r = this.curve.a, n = this.x.redSqr(), i = e.redInvm(), s = n.redAdd(n).redIAdd(n).redIAdd(r).redMul(i), o = s.redSqr().redISub(this.x.redAdd(this.x)), a = s.redMul(this.x.redSub(o)).redISub(this.y);
  return this.curve.point(o, a);
};
Ln.prototype.getX = function() {
  return this.x.fromRed();
};
Ln.prototype.getY = function() {
  return this.y.fromRed();
};
Ln.prototype.mul = function(e) {
  return e = new ir(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
Ln.prototype.mulAdd = function(e, r, n) {
  var i = [this, r], s = [e, n];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2);
};
Ln.prototype.jmulAdd = function(e, r, n) {
  var i = [this, r], s = [e, n];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, !0) : this.curve._wnafMulAdd(1, i, s, 2, !0);
};
Ln.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
Ln.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var r = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var n = this.precomputed, i = function(s) {
      return s.neg();
    };
    r.precomputed = {
      naf: n.naf && {
        wnd: n.naf.wnd,
        points: n.naf.points.map(i)
      },
      doubles: n.doubles && {
        step: n.doubles.step,
        points: n.doubles.points.map(i)
      }
    };
  }
  return r;
};
Ln.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function qn(t, e, r, n) {
  wc.BasePoint.call(this, t, "jacobian"), e === null && r === null && n === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new ir(0)) : (this.x = new ir(e, 16), this.y = new ir(r, 16), this.z = new ir(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
Wv(qn, wc.BasePoint);
is.prototype.jpoint = function(e, r, n) {
  return new qn(this, e, r, n);
};
qn.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), r = e.redSqr(), n = this.x.redMul(r), i = this.y.redMul(r).redMul(e);
  return this.curve.point(n, i);
};
qn.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
qn.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var r = e.z.redSqr(), n = this.z.redSqr(), i = this.x.redMul(r), s = e.x.redMul(n), o = this.y.redMul(r.redMul(e.z)), a = e.y.redMul(n.redMul(this.z)), u = i.redSub(s), l = o.redSub(a);
  if (u.cmpn(0) === 0)
    return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var d = u.redSqr(), p = d.redMul(u), w = i.redMul(d), P = l.redSqr().redIAdd(p).redISub(w).redISub(w), A = l.redMul(w.redISub(P)).redISub(o.redMul(p)), N = this.z.redMul(e.z).redMul(u);
  return this.curve.jpoint(P, A, N);
};
qn.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var r = this.z.redSqr(), n = this.x, i = e.x.redMul(r), s = this.y, o = e.y.redMul(r).redMul(this.z), a = n.redSub(i), u = s.redSub(o);
  if (a.cmpn(0) === 0)
    return u.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var l = a.redSqr(), d = l.redMul(a), p = n.redMul(l), w = u.redSqr().redIAdd(d).redISub(p).redISub(p), P = u.redMul(p.redISub(w)).redISub(s.redMul(d)), A = this.z.redMul(a);
  return this.curve.jpoint(w, P, A);
};
qn.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var r;
  if (this.curve.zeroA || this.curve.threeA) {
    var n = this;
    for (r = 0; r < e; r++)
      n = n.dbl();
    return n;
  }
  var i = this.curve.a, s = this.curve.tinv, o = this.x, a = this.y, u = this.z, l = u.redSqr().redSqr(), d = a.redAdd(a);
  for (r = 0; r < e; r++) {
    var p = o.redSqr(), w = d.redSqr(), P = w.redSqr(), A = p.redAdd(p).redIAdd(p).redIAdd(i.redMul(l)), N = o.redMul(w), L = A.redSqr().redISub(N.redAdd(N)), F = N.redISub(L), $ = A.redMul(F);
    $ = $.redIAdd($).redISub(P);
    var K = d.redMul(u);
    r + 1 < e && (l = l.redMul(P)), o = L, u = K, d = $;
  }
  return this.curve.jpoint(o, d.redMul(s), u);
};
qn.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
qn.prototype._zeroDbl = function() {
  var e, r, n;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
    a = a.redIAdd(a);
    var u = i.redAdd(i).redIAdd(i), l = u.redSqr().redISub(a).redISub(a), d = o.redIAdd(o);
    d = d.redIAdd(d), d = d.redIAdd(d), e = l, r = u.redMul(a.redISub(l)).redISub(d), n = this.y.redAdd(this.y);
  } else {
    var p = this.x.redSqr(), w = this.y.redSqr(), P = w.redSqr(), A = this.x.redAdd(w).redSqr().redISub(p).redISub(P);
    A = A.redIAdd(A);
    var N = p.redAdd(p).redIAdd(p), L = N.redSqr(), F = P.redIAdd(P);
    F = F.redIAdd(F), F = F.redIAdd(F), e = L.redISub(A).redISub(A), r = N.redMul(A.redISub(e)).redISub(F), n = this.y.redMul(this.z), n = n.redIAdd(n);
  }
  return this.curve.jpoint(e, r, n);
};
qn.prototype._threeDbl = function() {
  var e, r, n;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
    a = a.redIAdd(a);
    var u = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a), l = u.redSqr().redISub(a).redISub(a);
    e = l;
    var d = o.redIAdd(o);
    d = d.redIAdd(d), d = d.redIAdd(d), r = u.redMul(a.redISub(l)).redISub(d), n = this.y.redAdd(this.y);
  } else {
    var p = this.z.redSqr(), w = this.y.redSqr(), P = this.x.redMul(w), A = this.x.redSub(p).redMul(this.x.redAdd(p));
    A = A.redAdd(A).redIAdd(A);
    var N = P.redIAdd(P);
    N = N.redIAdd(N);
    var L = N.redAdd(N);
    e = A.redSqr().redISub(L), n = this.y.redAdd(this.z).redSqr().redISub(w).redISub(p);
    var F = w.redSqr();
    F = F.redIAdd(F), F = F.redIAdd(F), F = F.redIAdd(F), r = A.redMul(N.redISub(e)).redISub(F);
  }
  return this.curve.jpoint(e, r, n);
};
qn.prototype._dbl = function() {
  var e = this.curve.a, r = this.x, n = this.y, i = this.z, s = i.redSqr().redSqr(), o = r.redSqr(), a = n.redSqr(), u = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(s)), l = r.redAdd(r);
  l = l.redIAdd(l);
  var d = l.redMul(a), p = u.redSqr().redISub(d.redAdd(d)), w = d.redISub(p), P = a.redSqr();
  P = P.redIAdd(P), P = P.redIAdd(P), P = P.redIAdd(P);
  var A = u.redMul(w).redISub(P), N = n.redAdd(n).redMul(i);
  return this.curve.jpoint(p, A, N);
};
qn.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr(), i = r.redSqr(), s = e.redAdd(e).redIAdd(e), o = s.redSqr(), a = this.x.redAdd(r).redSqr().redISub(e).redISub(i);
  a = a.redIAdd(a), a = a.redAdd(a).redIAdd(a), a = a.redISub(o);
  var u = a.redSqr(), l = i.redIAdd(i);
  l = l.redIAdd(l), l = l.redIAdd(l), l = l.redIAdd(l);
  var d = s.redIAdd(a).redSqr().redISub(o).redISub(u).redISub(l), p = r.redMul(d);
  p = p.redIAdd(p), p = p.redIAdd(p);
  var w = this.x.redMul(u).redISub(p);
  w = w.redIAdd(w), w = w.redIAdd(w);
  var P = this.y.redMul(d.redMul(l.redISub(d)).redISub(a.redMul(u)));
  P = P.redIAdd(P), P = P.redIAdd(P), P = P.redIAdd(P);
  var A = this.z.redAdd(a).redSqr().redISub(n).redISub(u);
  return this.curve.jpoint(w, P, A);
};
qn.prototype.mul = function(e, r) {
  return e = new ir(e, r), this.curve._wnafMul(this, e);
};
qn.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var r = this.z.redSqr(), n = e.z.redSqr();
  if (this.x.redMul(n).redISub(e.x.redMul(r)).cmpn(0) !== 0)
    return !1;
  var i = r.redMul(this.z), s = n.redMul(e.z);
  return this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0) === 0;
};
qn.prototype.eqXToP = function(e) {
  var r = this.z.redSqr(), n = e.toRed(this.curve.red).redMul(r);
  if (this.x.cmp(n) === 0)
    return !0;
  for (var i = e.clone(), s = this.curve.redN.redMul(r); ; ) {
    if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)
      return !1;
    if (n.redIAdd(s), this.x.cmp(n) === 0)
      return !0;
  }
};
qn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
qn.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var Ad = $u(function(t, e) {
  var r = e;
  r.base = wc, r.short = aj, r.mont = /*RicMoo:ethers:require(./mont)*/
  null, r.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
}), Pd = $u(function(t, e) {
  var r = e, n = $i.assert;
  function i(a) {
    a.type === "short" ? this.curve = new Ad.short(a) : a.type === "edwards" ? this.curve = new Ad.edwards(a) : this.curve = new Ad.mont(a), this.g = this.curve.g, this.n = this.curve.n, this.hash = a.hash, n(this.g.validate(), "Invalid curve"), n(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  r.PresetCurve = i;
  function s(a, u) {
    Object.defineProperty(r, a, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var l = new i(u);
        return Object.defineProperty(r, a, {
          configurable: !0,
          enumerable: !0,
          value: l
        }), l;
      }
    });
  }
  s("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: bo.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), s("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: bo.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), s("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: bo.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), s("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: bo.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), s("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: bo.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), s("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: bo.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), s("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: bo.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var o;
  try {
    o = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch {
    o = void 0;
  }
  s("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: bo.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      o
    ]
  });
});
function va(t) {
  if (!(this instanceof va))
    return new va(t);
  this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var e = ws.toArray(t.entropy, t.entropyEnc || "hex"), r = ws.toArray(t.nonce, t.nonceEnc || "hex"), n = ws.toArray(t.pers, t.persEnc || "hex");
  Hv(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(e, r, n);
}
var d8 = va;
va.prototype._init = function(e, r, n) {
  var i = e.concat(r).concat(n);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var s = 0; s < this.V.length; s++)
    this.K[s] = 0, this.V[s] = 1;
  this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656;
};
va.prototype._hmac = function() {
  return new bo.hmac(this.hash, this.K);
};
va.prototype._update = function(e) {
  var r = this._hmac().update(this.V).update([0]);
  e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
va.prototype.reseed = function(e, r, n, i) {
  typeof r != "string" && (i = n, n = r, r = null), e = ws.toArray(e, r), n = ws.toArray(n, i), Hv(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(n || [])), this._reseed = 1;
};
va.prototype.generate = function(e, r, n, i) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof r != "string" && (i = n, n = r, r = null), n && (n = ws.toArray(n, i || "hex"), this._update(n));
  for (var s = []; s.length < e; )
    this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
  var o = s.slice(0, e);
  return this._update(n), this._reseed++, ws.encode(o, r);
};
var E1 = $i.assert;
function Zn(t, e) {
  this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var Kv = Zn;
Zn.fromPublic = function(e, r, n) {
  return r instanceof Zn ? r : new Zn(e, {
    pub: r,
    pubEnc: n
  });
};
Zn.fromPrivate = function(e, r, n) {
  return r instanceof Zn ? r : new Zn(e, {
    priv: r,
    privEnc: n
  });
};
Zn.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
Zn.prototype.getPublic = function(e, r) {
  return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
};
Zn.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
Zn.prototype._importPrivate = function(e, r) {
  this.priv = new ir(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
Zn.prototype._importPublic = function(e, r) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? E1(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && E1(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, r);
};
Zn.prototype.derive = function(e) {
  return e.validate() || E1(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
Zn.prototype.sign = function(e, r, n) {
  return this.ec.sign(e, this, r, n);
};
Zn.prototype.verify = function(e, r) {
  return this.ec.verify(e, r, this);
};
Zn.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var cj = $i.assert;
function H0(t, e) {
  if (t instanceof H0)
    return t;
  this._importDER(t, e) || (cj(t.r && t.s, "Signature without r or s"), this.r = new ir(t.r, 16), this.s = new ir(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
}
var W0 = H0;
function uj() {
  this.place = 0;
}
function im(t, e) {
  var r = t[e.place++];
  if (!(r & 128))
    return r;
  var n = r & 15;
  if (n === 0 || n > 4)
    return !1;
  for (var i = 0, s = 0, o = e.place; s < n; s++, o++)
    i <<= 8, i |= t[o], i >>>= 0;
  return i <= 127 ? !1 : (e.place = o, i);
}
function Sx(t) {
  for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r; )
    e++;
  return e === 0 ? t : t.slice(e);
}
H0.prototype._importDER = function(e, r) {
  e = $i.toArray(e, r);
  var n = new uj();
  if (e[n.place++] !== 48)
    return !1;
  var i = im(e, n);
  if (i === !1 || i + n.place !== e.length || e[n.place++] !== 2)
    return !1;
  var s = im(e, n);
  if (s === !1)
    return !1;
  var o = e.slice(n.place, s + n.place);
  if (n.place += s, e[n.place++] !== 2)
    return !1;
  var a = im(e, n);
  if (a === !1 || e.length !== a + n.place)
    return !1;
  var u = e.slice(n.place, a + n.place);
  if (o[0] === 0)
    if (o[1] & 128)
      o = o.slice(1);
    else
      return !1;
  if (u[0] === 0)
    if (u[1] & 128)
      u = u.slice(1);
    else
      return !1;
  return this.r = new ir(o), this.s = new ir(u), this.recoveryParam = null, !0;
};
function sm(t, e) {
  if (e < 128) {
    t.push(e);
    return;
  }
  var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
  for (t.push(r | 128); --r; )
    t.push(e >>> (r << 3) & 255);
  t.push(e);
}
H0.prototype.toDER = function(e) {
  var r = this.r.toArray(), n = this.s.toArray();
  for (r[0] & 128 && (r = [0].concat(r)), n[0] & 128 && (n = [0].concat(n)), r = Sx(r), n = Sx(n); !n[0] && !(n[1] & 128); )
    n = n.slice(1);
  var i = [2];
  sm(i, r.length), i = i.concat(r), i.push(2), sm(i, n.length);
  var s = i.concat(n), o = [48];
  return sm(o, s.length), o = o.concat(s), $i.encode(o, e);
};
var fj = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
), p8 = $i.assert;
function Qi(t) {
  if (!(this instanceof Qi))
    return new Qi(t);
  typeof t == "string" && (p8(
    Object.prototype.hasOwnProperty.call(Pd, t),
    "Unknown curve " + t
  ), t = Pd[t]), t instanceof Pd.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
}
var lj = Qi;
Qi.prototype.keyPair = function(e) {
  return new Kv(this, e);
};
Qi.prototype.keyFromPrivate = function(e, r) {
  return Kv.fromPrivate(this, e, r);
};
Qi.prototype.keyFromPublic = function(e, r) {
  return Kv.fromPublic(this, e, r);
};
Qi.prototype.genKeyPair = function(e) {
  e || (e = {});
  for (var r = new d8({
    hash: this.hash,
    pers: e.pers,
    persEnc: e.persEnc || "utf8",
    entropy: e.entropy || fj(this.hash.hmacStrength),
    entropyEnc: e.entropy && e.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), n = this.n.byteLength(), i = this.n.sub(new ir(2)); ; ) {
    var s = new ir(r.generate(n));
    if (!(s.cmp(i) > 0))
      return s.iaddn(1), this.keyFromPrivate(s);
  }
};
Qi.prototype._truncateToN = function(e, r) {
  var n = e.byteLength() * 8 - this.n.bitLength();
  return n > 0 && (e = e.ushrn(n)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
};
Qi.prototype.sign = function(e, r, n, i) {
  typeof n == "object" && (i = n, n = null), i || (i = {}), r = this.keyFromPrivate(r, n), e = this._truncateToN(new ir(e, 16));
  for (var s = this.n.byteLength(), o = r.getPrivate().toArray("be", s), a = e.toArray("be", s), u = new d8({
    hash: this.hash,
    entropy: o,
    nonce: a,
    pers: i.pers,
    persEnc: i.persEnc || "utf8"
  }), l = this.n.sub(new ir(1)), d = 0; ; d++) {
    var p = i.k ? i.k(d) : new ir(u.generate(this.n.byteLength()));
    if (p = this._truncateToN(p, !0), !(p.cmpn(1) <= 0 || p.cmp(l) >= 0)) {
      var w = this.g.mul(p);
      if (!w.isInfinity()) {
        var P = w.getX(), A = P.umod(this.n);
        if (A.cmpn(0) !== 0) {
          var N = p.invm(this.n).mul(A.mul(r.getPrivate()).iadd(e));
          if (N = N.umod(this.n), N.cmpn(0) !== 0) {
            var L = (w.getY().isOdd() ? 1 : 0) | (P.cmp(A) !== 0 ? 2 : 0);
            return i.canonical && N.cmp(this.nh) > 0 && (N = this.n.sub(N), L ^= 1), new W0({ r: A, s: N, recoveryParam: L });
          }
        }
      }
    }
  }
};
Qi.prototype.verify = function(e, r, n, i) {
  e = this._truncateToN(new ir(e, 16)), n = this.keyFromPublic(n, i), r = new W0(r, "hex");
  var s = r.r, o = r.s;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0 || o.cmpn(1) < 0 || o.cmp(this.n) >= 0)
    return !1;
  var a = o.invm(this.n), u = a.mul(e).umod(this.n), l = a.mul(s).umod(this.n), d;
  return this.curve._maxwellTrick ? (d = this.g.jmulAdd(u, n.getPublic(), l), d.isInfinity() ? !1 : d.eqXToP(s)) : (d = this.g.mulAdd(u, n.getPublic(), l), d.isInfinity() ? !1 : d.getX().umod(this.n).cmp(s) === 0);
};
Qi.prototype.recoverPubKey = function(t, e, r, n) {
  p8((3 & r) === r, "The recovery param is more than two bits"), e = new W0(e, n);
  var i = this.n, s = new ir(t), o = e.r, a = e.s, u = r & 1, l = r >> 1;
  if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && l)
    throw new Error("Unable to find sencond key candinate");
  l ? o = this.curve.pointFromX(o.add(this.curve.n), u) : o = this.curve.pointFromX(o, u);
  var d = e.r.invm(i), p = i.sub(s).mul(d).umod(i), w = a.mul(d).umod(i);
  return this.g.mulAdd(p, o, w);
};
Qi.prototype.getKeyRecoveryParam = function(t, e, r, n) {
  if (e = new W0(e, n), e.recoveryParam !== null)
    return e.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var s;
    try {
      s = this.recoverPubKey(t, e, i);
    } catch {
      continue;
    }
    if (s.eq(r))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var hj = $u(function(t, e) {
  var r = e;
  r.version = "6.5.4", r.utils = $i, r.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }, r.curve = Ad, r.curves = Pd, r.ec = lj, r.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
}), dj = hj.ec;
const pj = "signing-key/5.7.0", S1 = new Yr(pj);
let om = null;
function oa() {
  return om || (om = new dj("secp256k1")), om;
}
class gj {
  constructor(e) {
    xf(this, "curve", "secp256k1"), xf(this, "privateKey", Ti(e)), wB(this.privateKey) !== 32 && S1.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    const r = oa().keyFromPrivate(wn(this.privateKey));
    xf(this, "publicKey", "0x" + r.getPublic(!1, "hex")), xf(this, "compressedPublicKey", "0x" + r.getPublic(!0, "hex")), xf(this, "_isSigningKey", !0);
  }
  _addPoint(e) {
    const r = oa().keyFromPublic(wn(this.publicKey)), n = oa().keyFromPublic(wn(e));
    return "0x" + r.pub.add(n.pub).encodeCompressed("hex");
  }
  signDigest(e) {
    const r = oa().keyFromPrivate(wn(this.privateKey)), n = wn(e);
    n.length !== 32 && S1.throwArgumentError("bad digest length", "digest", e);
    const i = r.sign(n, { canonical: !0 });
    return K4({
      recoveryParam: i.recoveryParam,
      r: fu("0x" + i.r.toString(16), 32),
      s: fu("0x" + i.s.toString(16), 32)
    });
  }
  computeSharedSecret(e) {
    const r = oa().keyFromPrivate(wn(this.privateKey)), n = oa().keyFromPublic(wn(g8(e)));
    return fu("0x" + r.derive(n.getPublic()).toString(16), 32);
  }
  static isSigningKey(e) {
    return !!(e && e._isSigningKey);
  }
}
function mj(t, e) {
  const r = K4(e), n = { r: wn(r.r), s: wn(r.s) };
  return "0x" + oa().recoverPubKey(wn(t), n, r.recoveryParam).encode("hex", !1);
}
function g8(t, e) {
  const r = wn(t);
  return r.length === 32 ? new gj(r).publicKey : r.length === 33 ? "0x" + oa().keyFromPublic(r).getPublic(!1, "hex") : r.length === 65 ? Ti(r) : S1.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
var Ax;
(function(t) {
  t[t.legacy = 0] = "legacy", t[t.eip2930 = 1] = "eip2930", t[t.eip1559 = 2] = "eip1559";
})(Ax || (Ax = {}));
function vj(t) {
  const e = g8(t);
  return RB(mx(jv(mx(e, 1)), 12));
}
function bj(t, e) {
  return vj(mj(wn(t), e));
}
var Vv = {}, K0 = {};
Object.defineProperty(K0, "__esModule", { value: !0 });
var Vn = or, A1 = ki, yj = 20;
function wj(t, e, r) {
  for (var n = 1634760805, i = 857760878, s = 2036477234, o = 1797285236, a = r[3] << 24 | r[2] << 16 | r[1] << 8 | r[0], u = r[7] << 24 | r[6] << 16 | r[5] << 8 | r[4], l = r[11] << 24 | r[10] << 16 | r[9] << 8 | r[8], d = r[15] << 24 | r[14] << 16 | r[13] << 8 | r[12], p = r[19] << 24 | r[18] << 16 | r[17] << 8 | r[16], w = r[23] << 24 | r[22] << 16 | r[21] << 8 | r[20], P = r[27] << 24 | r[26] << 16 | r[25] << 8 | r[24], A = r[31] << 24 | r[30] << 16 | r[29] << 8 | r[28], N = e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0], L = e[7] << 24 | e[6] << 16 | e[5] << 8 | e[4], F = e[11] << 24 | e[10] << 16 | e[9] << 8 | e[8], $ = e[15] << 24 | e[14] << 16 | e[13] << 8 | e[12], K = n, H = i, V = s, te = o, R = a, W = u, pe = l, Ee = d, Y = p, S = w, m = P, f = A, g = N, b = L, x = F, _ = $, E = 0; E < yj; E += 2)
    K = K + R | 0, g ^= K, g = g >>> 16 | g << 16, Y = Y + g | 0, R ^= Y, R = R >>> 20 | R << 12, H = H + W | 0, b ^= H, b = b >>> 16 | b << 16, S = S + b | 0, W ^= S, W = W >>> 20 | W << 12, V = V + pe | 0, x ^= V, x = x >>> 16 | x << 16, m = m + x | 0, pe ^= m, pe = pe >>> 20 | pe << 12, te = te + Ee | 0, _ ^= te, _ = _ >>> 16 | _ << 16, f = f + _ | 0, Ee ^= f, Ee = Ee >>> 20 | Ee << 12, V = V + pe | 0, x ^= V, x = x >>> 24 | x << 8, m = m + x | 0, pe ^= m, pe = pe >>> 25 | pe << 7, te = te + Ee | 0, _ ^= te, _ = _ >>> 24 | _ << 8, f = f + _ | 0, Ee ^= f, Ee = Ee >>> 25 | Ee << 7, H = H + W | 0, b ^= H, b = b >>> 24 | b << 8, S = S + b | 0, W ^= S, W = W >>> 25 | W << 7, K = K + R | 0, g ^= K, g = g >>> 24 | g << 8, Y = Y + g | 0, R ^= Y, R = R >>> 25 | R << 7, K = K + W | 0, _ ^= K, _ = _ >>> 16 | _ << 16, m = m + _ | 0, W ^= m, W = W >>> 20 | W << 12, H = H + pe | 0, g ^= H, g = g >>> 16 | g << 16, f = f + g | 0, pe ^= f, pe = pe >>> 20 | pe << 12, V = V + Ee | 0, b ^= V, b = b >>> 16 | b << 16, Y = Y + b | 0, Ee ^= Y, Ee = Ee >>> 20 | Ee << 12, te = te + R | 0, x ^= te, x = x >>> 16 | x << 16, S = S + x | 0, R ^= S, R = R >>> 20 | R << 12, V = V + Ee | 0, b ^= V, b = b >>> 24 | b << 8, Y = Y + b | 0, Ee ^= Y, Ee = Ee >>> 25 | Ee << 7, te = te + R | 0, x ^= te, x = x >>> 24 | x << 8, S = S + x | 0, R ^= S, R = R >>> 25 | R << 7, H = H + pe | 0, g ^= H, g = g >>> 24 | g << 8, f = f + g | 0, pe ^= f, pe = pe >>> 25 | pe << 7, K = K + W | 0, _ ^= K, _ = _ >>> 24 | _ << 8, m = m + _ | 0, W ^= m, W = W >>> 25 | W << 7;
  Vn.writeUint32LE(K + n | 0, t, 0), Vn.writeUint32LE(H + i | 0, t, 4), Vn.writeUint32LE(V + s | 0, t, 8), Vn.writeUint32LE(te + o | 0, t, 12), Vn.writeUint32LE(R + a | 0, t, 16), Vn.writeUint32LE(W + u | 0, t, 20), Vn.writeUint32LE(pe + l | 0, t, 24), Vn.writeUint32LE(Ee + d | 0, t, 28), Vn.writeUint32LE(Y + p | 0, t, 32), Vn.writeUint32LE(S + w | 0, t, 36), Vn.writeUint32LE(m + P | 0, t, 40), Vn.writeUint32LE(f + A | 0, t, 44), Vn.writeUint32LE(g + N | 0, t, 48), Vn.writeUint32LE(b + L | 0, t, 52), Vn.writeUint32LE(x + F | 0, t, 56), Vn.writeUint32LE(_ + $ | 0, t, 60);
}
function m8(t, e, r, n, i) {
  if (i === void 0 && (i = 0), t.length !== 32)
    throw new Error("ChaCha: key size must be 32 bytes");
  if (n.length < r.length)
    throw new Error("ChaCha: destination is shorter than source");
  var s, o;
  if (i === 0) {
    if (e.length !== 8 && e.length !== 12)
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    s = new Uint8Array(16), o = s.length - e.length, s.set(e, o);
  } else {
    if (e.length !== 16)
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    s = e, o = i;
  }
  for (var a = new Uint8Array(64), u = 0; u < r.length; u += 64) {
    wj(a, s, t);
    for (var l = u; l < u + 64 && l < r.length; l++)
      n[l] = r[l] ^ a[l - u];
    _j(s, 0, o);
  }
  return A1.wipe(a), i === 0 && A1.wipe(s), n;
}
K0.streamXOR = m8;
function xj(t, e, r, n) {
  return n === void 0 && (n = 0), A1.wipe(r), m8(t, e, r, r, n);
}
K0.stream = xj;
function _j(t, e, r) {
  for (var n = 1; r--; )
    n = n + (t[e] & 255) | 0, t[e] = n & 255, n >>>= 8, e++;
  if (n > 0)
    throw new Error("ChaCha: counter overflow");
}
var v8 = {}, Ia = {};
Object.defineProperty(Ia, "__esModule", { value: !0 });
function Ej(t, e, r) {
  return ~(t - 1) & e | t - 1 & r;
}
Ia.select = Ej;
function Sj(t, e) {
  return (t | 0) - (e | 0) - 1 >>> 31 & 1;
}
Ia.lessOrEqual = Sj;
function b8(t, e) {
  if (t.length !== e.length)
    return 0;
  for (var r = 0, n = 0; n < t.length; n++)
    r |= t[n] ^ e[n];
  return 1 & r - 1 >>> 8;
}
Ia.compare = b8;
function Aj(t, e) {
  return t.length === 0 || e.length === 0 ? !1 : b8(t, e) !== 0;
}
Ia.equal = Aj;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = Ia, r = ki;
  t.DIGEST_LENGTH = 16;
  var n = (
    /** @class */
    function() {
      function o(a) {
        this.digestLength = t.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
        var u = a[0] | a[1] << 8;
        this._r[0] = u & 8191;
        var l = a[2] | a[3] << 8;
        this._r[1] = (u >>> 13 | l << 3) & 8191;
        var d = a[4] | a[5] << 8;
        this._r[2] = (l >>> 10 | d << 6) & 7939;
        var p = a[6] | a[7] << 8;
        this._r[3] = (d >>> 7 | p << 9) & 8191;
        var w = a[8] | a[9] << 8;
        this._r[4] = (p >>> 4 | w << 12) & 255, this._r[5] = w >>> 1 & 8190;
        var P = a[10] | a[11] << 8;
        this._r[6] = (w >>> 14 | P << 2) & 8191;
        var A = a[12] | a[13] << 8;
        this._r[7] = (P >>> 11 | A << 5) & 8065;
        var N = a[14] | a[15] << 8;
        this._r[8] = (A >>> 8 | N << 8) & 8191, this._r[9] = N >>> 5 & 127, this._pad[0] = a[16] | a[17] << 8, this._pad[1] = a[18] | a[19] << 8, this._pad[2] = a[20] | a[21] << 8, this._pad[3] = a[22] | a[23] << 8, this._pad[4] = a[24] | a[25] << 8, this._pad[5] = a[26] | a[27] << 8, this._pad[6] = a[28] | a[29] << 8, this._pad[7] = a[30] | a[31] << 8;
      }
      return o.prototype._blocks = function(a, u, l) {
        for (var d = this._fin ? 0 : 2048, p = this._h[0], w = this._h[1], P = this._h[2], A = this._h[3], N = this._h[4], L = this._h[5], F = this._h[6], $ = this._h[7], K = this._h[8], H = this._h[9], V = this._r[0], te = this._r[1], R = this._r[2], W = this._r[3], pe = this._r[4], Ee = this._r[5], Y = this._r[6], S = this._r[7], m = this._r[8], f = this._r[9]; l >= 16; ) {
          var g = a[u + 0] | a[u + 1] << 8;
          p += g & 8191;
          var b = a[u + 2] | a[u + 3] << 8;
          w += (g >>> 13 | b << 3) & 8191;
          var x = a[u + 4] | a[u + 5] << 8;
          P += (b >>> 10 | x << 6) & 8191;
          var _ = a[u + 6] | a[u + 7] << 8;
          A += (x >>> 7 | _ << 9) & 8191;
          var E = a[u + 8] | a[u + 9] << 8;
          N += (_ >>> 4 | E << 12) & 8191, L += E >>> 1 & 8191;
          var v = a[u + 10] | a[u + 11] << 8;
          F += (E >>> 14 | v << 2) & 8191;
          var M = a[u + 12] | a[u + 13] << 8;
          $ += (v >>> 11 | M << 5) & 8191;
          var I = a[u + 14] | a[u + 15] << 8;
          K += (M >>> 8 | I << 8) & 8191, H += I >>> 5 | d;
          var B = 0, ce = B;
          ce += p * V, ce += w * (5 * f), ce += P * (5 * m), ce += A * (5 * S), ce += N * (5 * Y), B = ce >>> 13, ce &= 8191, ce += L * (5 * Ee), ce += F * (5 * pe), ce += $ * (5 * W), ce += K * (5 * R), ce += H * (5 * te), B += ce >>> 13, ce &= 8191;
          var D = B;
          D += p * te, D += w * V, D += P * (5 * f), D += A * (5 * m), D += N * (5 * S), B = D >>> 13, D &= 8191, D += L * (5 * Y), D += F * (5 * Ee), D += $ * (5 * pe), D += K * (5 * W), D += H * (5 * R), B += D >>> 13, D &= 8191;
          var oe = B;
          oe += p * R, oe += w * te, oe += P * V, oe += A * (5 * f), oe += N * (5 * m), B = oe >>> 13, oe &= 8191, oe += L * (5 * S), oe += F * (5 * Y), oe += $ * (5 * Ee), oe += K * (5 * pe), oe += H * (5 * W), B += oe >>> 13, oe &= 8191;
          var Z = B;
          Z += p * W, Z += w * R, Z += P * te, Z += A * V, Z += N * (5 * f), B = Z >>> 13, Z &= 8191, Z += L * (5 * m), Z += F * (5 * S), Z += $ * (5 * Y), Z += K * (5 * Ee), Z += H * (5 * pe), B += Z >>> 13, Z &= 8191;
          var J = B;
          J += p * pe, J += w * W, J += P * R, J += A * te, J += N * V, B = J >>> 13, J &= 8191, J += L * (5 * f), J += F * (5 * m), J += $ * (5 * S), J += K * (5 * Y), J += H * (5 * Ee), B += J >>> 13, J &= 8191;
          var Q = B;
          Q += p * Ee, Q += w * pe, Q += P * W, Q += A * R, Q += N * te, B = Q >>> 13, Q &= 8191, Q += L * V, Q += F * (5 * f), Q += $ * (5 * m), Q += K * (5 * S), Q += H * (5 * Y), B += Q >>> 13, Q &= 8191;
          var T = B;
          T += p * Y, T += w * Ee, T += P * pe, T += A * W, T += N * R, B = T >>> 13, T &= 8191, T += L * te, T += F * V, T += $ * (5 * f), T += K * (5 * m), T += H * (5 * S), B += T >>> 13, T &= 8191;
          var X = B;
          X += p * S, X += w * Y, X += P * Ee, X += A * pe, X += N * W, B = X >>> 13, X &= 8191, X += L * R, X += F * te, X += $ * V, X += K * (5 * f), X += H * (5 * m), B += X >>> 13, X &= 8191;
          var re = B;
          re += p * m, re += w * S, re += P * Y, re += A * Ee, re += N * pe, B = re >>> 13, re &= 8191, re += L * W, re += F * R, re += $ * te, re += K * V, re += H * (5 * f), B += re >>> 13, re &= 8191;
          var de = B;
          de += p * f, de += w * m, de += P * S, de += A * Y, de += N * Ee, B = de >>> 13, de &= 8191, de += L * pe, de += F * W, de += $ * R, de += K * te, de += H * V, B += de >>> 13, de &= 8191, B = (B << 2) + B | 0, B = B + ce | 0, ce = B & 8191, B = B >>> 13, D += B, p = ce, w = D, P = oe, A = Z, N = J, L = Q, F = T, $ = X, K = re, H = de, u += 16, l -= 16;
        }
        this._h[0] = p, this._h[1] = w, this._h[2] = P, this._h[3] = A, this._h[4] = N, this._h[5] = L, this._h[6] = F, this._h[7] = $, this._h[8] = K, this._h[9] = H;
      }, o.prototype.finish = function(a, u) {
        u === void 0 && (u = 0);
        var l = new Uint16Array(10), d, p, w, P;
        if (this._leftover) {
          for (P = this._leftover, this._buffer[P++] = 1; P < 16; P++)
            this._buffer[P] = 0;
          this._fin = 1, this._blocks(this._buffer, 0, 16);
        }
        for (d = this._h[1] >>> 13, this._h[1] &= 8191, P = 2; P < 10; P++)
          this._h[P] += d, d = this._h[P] >>> 13, this._h[P] &= 8191;
        for (this._h[0] += d * 5, d = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += d, d = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += d, l[0] = this._h[0] + 5, d = l[0] >>> 13, l[0] &= 8191, P = 1; P < 10; P++)
          l[P] = this._h[P] + d, d = l[P] >>> 13, l[P] &= 8191;
        for (l[9] -= 8192, p = (d ^ 1) - 1, P = 0; P < 10; P++)
          l[P] &= p;
        for (p = ~p, P = 0; P < 10; P++)
          this._h[P] = this._h[P] & p | l[P];
        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, w = this._h[0] + this._pad[0], this._h[0] = w & 65535, P = 1; P < 8; P++)
          w = (this._h[P] + this._pad[P] | 0) + (w >>> 16) | 0, this._h[P] = w & 65535;
        return a[u + 0] = this._h[0] >>> 0, a[u + 1] = this._h[0] >>> 8, a[u + 2] = this._h[1] >>> 0, a[u + 3] = this._h[1] >>> 8, a[u + 4] = this._h[2] >>> 0, a[u + 5] = this._h[2] >>> 8, a[u + 6] = this._h[3] >>> 0, a[u + 7] = this._h[3] >>> 8, a[u + 8] = this._h[4] >>> 0, a[u + 9] = this._h[4] >>> 8, a[u + 10] = this._h[5] >>> 0, a[u + 11] = this._h[5] >>> 8, a[u + 12] = this._h[6] >>> 0, a[u + 13] = this._h[6] >>> 8, a[u + 14] = this._h[7] >>> 0, a[u + 15] = this._h[7] >>> 8, this._finished = !0, this;
      }, o.prototype.update = function(a) {
        var u = 0, l = a.length, d;
        if (this._leftover) {
          d = 16 - this._leftover, d > l && (d = l);
          for (var p = 0; p < d; p++)
            this._buffer[this._leftover + p] = a[u + p];
          if (l -= d, u += d, this._leftover += d, this._leftover < 16)
            return this;
          this._blocks(this._buffer, 0, 16), this._leftover = 0;
        }
        if (l >= 16 && (d = l - l % 16, this._blocks(a, u, d), u += d, l -= d), l) {
          for (var p = 0; p < l; p++)
            this._buffer[this._leftover + p] = a[u + p];
          this._leftover += l;
        }
        return this;
      }, o.prototype.digest = function() {
        if (this._finished)
          throw new Error("Poly1305 was finished");
        var a = new Uint8Array(16);
        return this.finish(a), a;
      }, o.prototype.clean = function() {
        return r.wipe(this._buffer), r.wipe(this._r), r.wipe(this._h), r.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;
      }, o;
    }()
  );
  t.Poly1305 = n;
  function i(o, a) {
    var u = new n(o);
    u.update(a);
    var l = u.digest();
    return u.clean(), l;
  }
  t.oneTimeAuth = i;
  function s(o, a) {
    return o.length !== t.DIGEST_LENGTH || a.length !== t.DIGEST_LENGTH ? !1 : e.equal(o, a);
  }
  t.equal = s;
})(v8);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = K0, r = v8, n = ki, i = or, s = Ia;
  t.KEY_LENGTH = 32, t.NONCE_LENGTH = 12, t.TAG_LENGTH = 16;
  var o = new Uint8Array(16), a = (
    /** @class */
    function() {
      function u(l) {
        if (this.nonceLength = t.NONCE_LENGTH, this.tagLength = t.TAG_LENGTH, l.length !== t.KEY_LENGTH)
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(l);
      }
      return u.prototype.seal = function(l, d, p, w) {
        if (l.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        var P = new Uint8Array(16);
        P.set(l, P.length - l.length);
        var A = new Uint8Array(32);
        e.stream(this._key, P, A, 4);
        var N = d.length + this.tagLength, L;
        if (w) {
          if (w.length !== N)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          L = w;
        } else
          L = new Uint8Array(N);
        return e.streamXOR(this._key, P, d, L, 4), this._authenticate(L.subarray(L.length - this.tagLength, L.length), A, L.subarray(0, L.length - this.tagLength), p), n.wipe(P), L;
      }, u.prototype.open = function(l, d, p, w) {
        if (l.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        if (d.length < this.tagLength)
          return null;
        var P = new Uint8Array(16);
        P.set(l, P.length - l.length);
        var A = new Uint8Array(32);
        e.stream(this._key, P, A, 4);
        var N = new Uint8Array(this.tagLength);
        if (this._authenticate(N, A, d.subarray(0, d.length - this.tagLength), p), !s.equal(N, d.subarray(d.length - this.tagLength, d.length)))
          return null;
        var L = d.length - this.tagLength, F;
        if (w) {
          if (w.length !== L)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          F = w;
        } else
          F = new Uint8Array(L);
        return e.streamXOR(this._key, P, d.subarray(0, d.length - this.tagLength), F, 4), n.wipe(P), F;
      }, u.prototype.clean = function() {
        return n.wipe(this._key), this;
      }, u.prototype._authenticate = function(l, d, p, w) {
        var P = new r.Poly1305(d);
        w && (P.update(w), w.length % 16 > 0 && P.update(o.subarray(w.length % 16))), P.update(p), p.length % 16 > 0 && P.update(o.subarray(p.length % 16));
        var A = new Uint8Array(8);
        w && i.writeUint64LE(w.length, A), P.update(A), i.writeUint64LE(p.length, A), P.update(A);
        for (var N = P.digest(), L = 0; L < N.length; L++)
          l[L] = N[L];
        P.clean(), n.wipe(N), n.wipe(A);
      }, u;
    }()
  );
  t.ChaCha20Poly1305 = a;
})(Vv);
var y8 = {}, Vl = {}, Gv = {};
Object.defineProperty(Gv, "__esModule", { value: !0 });
function Pj(t) {
  return typeof t.saveState < "u" && typeof t.restoreState < "u" && typeof t.cleanSavedState < "u";
}
Gv.isSerializableHash = Pj;
Object.defineProperty(Vl, "__esModule", { value: !0 });
var Ns = Gv, Mj = Ia, Ij = ki, w8 = (
  /** @class */
  function() {
    function t(e, r) {
      this._finished = !1, this._inner = new e(), this._outer = new e(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
      var n = new Uint8Array(this.blockSize);
      r.length > this.blockSize ? this._inner.update(r).finish(n).clean() : n.set(r);
      for (var i = 0; i < n.length; i++)
        n[i] ^= 54;
      this._inner.update(n);
      for (var i = 0; i < n.length; i++)
        n[i] ^= 106;
      this._outer.update(n), Ns.isSerializableHash(this._inner) && Ns.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), Ij.wipe(n);
    }
    return t.prototype.reset = function() {
      if (!Ns.isSerializableHash(this._inner) || !Ns.isSerializableHash(this._outer))
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, t.prototype.clean = function() {
      Ns.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), Ns.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();
    }, t.prototype.update = function(e) {
      return this._inner.update(e), this;
    }, t.prototype.finish = function(e) {
      return this._finished ? (this._outer.finish(e), this) : (this._inner.finish(e), this._outer.update(e.subarray(0, this.digestLength)).finish(e), this._finished = !0, this);
    }, t.prototype.digest = function() {
      var e = new Uint8Array(this.digestLength);
      return this.finish(e), e;
    }, t.prototype.saveState = function() {
      if (!Ns.isSerializableHash(this._inner))
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      return this._inner.saveState();
    }, t.prototype.restoreState = function(e) {
      if (!Ns.isSerializableHash(this._inner) || !Ns.isSerializableHash(this._outer))
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      return this._inner.restoreState(e), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, t.prototype.cleanSavedState = function(e) {
      if (!Ns.isSerializableHash(this._inner))
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      this._inner.cleanSavedState(e);
    }, t;
  }()
);
Vl.HMAC = w8;
function Cj(t, e, r) {
  var n = new w8(t, e);
  n.update(r);
  var i = n.digest();
  return n.clean(), i;
}
Vl.hmac = Cj;
Vl.equal = Mj.equal;
Object.defineProperty(y8, "__esModule", { value: !0 });
var Px = Vl, Mx = ki, Tj = (
  /** @class */
  function() {
    function t(e, r, n, i) {
      n === void 0 && (n = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = e, this._info = i;
      var s = Px.hmac(this._hash, n, r);
      this._hmac = new Px.HMAC(e, s), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;
    }
    return t.prototype._fillBuffer = function() {
      this._counter[0]++;
      var e = this._counter[0];
      if (e === 0)
        throw new Error("hkdf: cannot expand more");
      this._hmac.reset(), e > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;
    }, t.prototype.expand = function(e) {
      for (var r = new Uint8Array(e), n = 0; n < r.length; n++)
        this._bufpos === this._buffer.length && this._fillBuffer(), r[n] = this._buffer[this._bufpos++];
      return r;
    }, t.prototype.clean = function() {
      this._hmac.clean(), Mx.wipe(this._buffer), Mx.wipe(this._counter), this._bufpos = 0;
    }, t;
  }()
), Rj = y8.HKDF = Tj, Gl = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = or, r = ki;
  t.DIGEST_LENGTH = 32, t.BLOCK_SIZE = 64;
  var n = (
    /** @class */
    function() {
      function a() {
        this.digestLength = t.DIGEST_LENGTH, this.blockSize = t.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return a.prototype._initState = function() {
        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
      }, a.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, a.prototype.clean = function() {
        r.wipe(this._buffer), r.wipe(this._temp), this.reset();
      }, a.prototype.update = function(u, l) {
        if (l === void 0 && (l = u.length), this._finished)
          throw new Error("SHA256: can't update because hash was finished.");
        var d = 0;
        if (this._bytesHashed += l, this._bufferLength > 0) {
          for (; this._bufferLength < this.blockSize && l > 0; )
            this._buffer[this._bufferLength++] = u[d++], l--;
          this._bufferLength === this.blockSize && (s(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (l >= this.blockSize && (d = s(this._temp, this._state, u, d, l), l %= this.blockSize); l > 0; )
          this._buffer[this._bufferLength++] = u[d++], l--;
        return this;
      }, a.prototype.finish = function(u) {
        if (!this._finished) {
          var l = this._bytesHashed, d = this._bufferLength, p = l / 536870912 | 0, w = l << 3, P = l % 64 < 56 ? 64 : 128;
          this._buffer[d] = 128;
          for (var A = d + 1; A < P - 8; A++)
            this._buffer[A] = 0;
          e.writeUint32BE(p, this._buffer, P - 8), e.writeUint32BE(w, this._buffer, P - 4), s(this._temp, this._state, this._buffer, 0, P), this._finished = !0;
        }
        for (var A = 0; A < this.digestLength / 4; A++)
          e.writeUint32BE(this._state[A], u, A * 4);
        return this;
      }, a.prototype.digest = function() {
        var u = new Uint8Array(this.digestLength);
        return this.finish(u), u;
      }, a.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, a.prototype.restoreState = function(u) {
        return this._state.set(u.state), this._bufferLength = u.bufferLength, u.buffer && this._buffer.set(u.buffer), this._bytesHashed = u.bytesHashed, this._finished = !1, this;
      }, a.prototype.cleanSavedState = function(u) {
        r.wipe(u.state), u.buffer && r.wipe(u.buffer), u.bufferLength = 0, u.bytesHashed = 0;
      }, a;
    }()
  );
  t.SHA256 = n;
  var i = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function s(a, u, l, d, p) {
    for (; p >= 64; ) {
      for (var w = u[0], P = u[1], A = u[2], N = u[3], L = u[4], F = u[5], $ = u[6], K = u[7], H = 0; H < 16; H++) {
        var V = d + H * 4;
        a[H] = e.readUint32BE(l, V);
      }
      for (var H = 16; H < 64; H++) {
        var te = a[H - 2], R = (te >>> 17 | te << 15) ^ (te >>> 19 | te << 13) ^ te >>> 10;
        te = a[H - 15];
        var W = (te >>> 7 | te << 25) ^ (te >>> 18 | te << 14) ^ te >>> 3;
        a[H] = (R + a[H - 7] | 0) + (W + a[H - 16] | 0);
      }
      for (var H = 0; H < 64; H++) {
        var R = (((L >>> 6 | L << 26) ^ (L >>> 11 | L << 21) ^ (L >>> 25 | L << 7)) + (L & F ^ ~L & $) | 0) + (K + (i[H] + a[H] | 0) | 0) | 0, W = ((w >>> 2 | w << 30) ^ (w >>> 13 | w << 19) ^ (w >>> 22 | w << 10)) + (w & P ^ w & A ^ P & A) | 0;
        K = $, $ = F, F = L, L = N + R | 0, N = A, A = P, P = w, w = R + W | 0;
      }
      u[0] += w, u[1] += P, u[2] += A, u[3] += N, u[4] += L, u[5] += F, u[6] += $, u[7] += K, d += 64, p -= 64;
    }
    return d;
  }
  function o(a) {
    var u = new n();
    u.update(a);
    var l = u.digest();
    return u.clean(), l;
  }
  t.hash = o;
})(Gl);
var Yv = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.sharedKey = t.generateKeyPair = t.generateKeyPairFromSeed = t.scalarMultBase = t.scalarMult = t.SHARED_KEY_LENGTH = t.SECRET_KEY_LENGTH = t.PUBLIC_KEY_LENGTH = void 0;
  const e = Pa, r = ki;
  t.PUBLIC_KEY_LENGTH = 32, t.SECRET_KEY_LENGTH = 32, t.SHARED_KEY_LENGTH = 32;
  function n(H) {
    const V = new Float64Array(16);
    if (H)
      for (let te = 0; te < H.length; te++)
        V[te] = H[te];
    return V;
  }
  const i = new Uint8Array(32);
  i[0] = 9;
  const s = n([56129, 1]);
  function o(H) {
    let V = 1;
    for (let te = 0; te < 16; te++) {
      let R = H[te] + V + 65535;
      V = Math.floor(R / 65536), H[te] = R - V * 65536;
    }
    H[0] += V - 1 + 37 * (V - 1);
  }
  function a(H, V, te) {
    const R = ~(te - 1);
    for (let W = 0; W < 16; W++) {
      const pe = R & (H[W] ^ V[W]);
      H[W] ^= pe, V[W] ^= pe;
    }
  }
  function u(H, V) {
    const te = n(), R = n();
    for (let W = 0; W < 16; W++)
      R[W] = V[W];
    o(R), o(R), o(R);
    for (let W = 0; W < 2; W++) {
      te[0] = R[0] - 65517;
      for (let Ee = 1; Ee < 15; Ee++)
        te[Ee] = R[Ee] - 65535 - (te[Ee - 1] >> 16 & 1), te[Ee - 1] &= 65535;
      te[15] = R[15] - 32767 - (te[14] >> 16 & 1);
      const pe = te[15] >> 16 & 1;
      te[14] &= 65535, a(R, te, 1 - pe);
    }
    for (let W = 0; W < 16; W++)
      H[2 * W] = R[W] & 255, H[2 * W + 1] = R[W] >> 8;
  }
  function l(H, V) {
    for (let te = 0; te < 16; te++)
      H[te] = V[2 * te] + (V[2 * te + 1] << 8);
    H[15] &= 32767;
  }
  function d(H, V, te) {
    for (let R = 0; R < 16; R++)
      H[R] = V[R] + te[R];
  }
  function p(H, V, te) {
    for (let R = 0; R < 16; R++)
      H[R] = V[R] - te[R];
  }
  function w(H, V, te) {
    let R, W, pe = 0, Ee = 0, Y = 0, S = 0, m = 0, f = 0, g = 0, b = 0, x = 0, _ = 0, E = 0, v = 0, M = 0, I = 0, B = 0, ce = 0, D = 0, oe = 0, Z = 0, J = 0, Q = 0, T = 0, X = 0, re = 0, de = 0, ie = 0, ue = 0, ve = 0, Pe = 0, De = 0, Ce = 0, $e = te[0], Me = te[1], Ne = te[2], Ke = te[3], Le = te[4], qe = te[5], ze = te[6], _e = te[7], Ze = te[8], at = te[9], ke = te[10], Qe = te[11], tt = te[12], Ye = te[13], dt = te[14], lt = te[15];
    R = V[0], pe += R * $e, Ee += R * Me, Y += R * Ne, S += R * Ke, m += R * Le, f += R * qe, g += R * ze, b += R * _e, x += R * Ze, _ += R * at, E += R * ke, v += R * Qe, M += R * tt, I += R * Ye, B += R * dt, ce += R * lt, R = V[1], Ee += R * $e, Y += R * Me, S += R * Ne, m += R * Ke, f += R * Le, g += R * qe, b += R * ze, x += R * _e, _ += R * Ze, E += R * at, v += R * ke, M += R * Qe, I += R * tt, B += R * Ye, ce += R * dt, D += R * lt, R = V[2], Y += R * $e, S += R * Me, m += R * Ne, f += R * Ke, g += R * Le, b += R * qe, x += R * ze, _ += R * _e, E += R * Ze, v += R * at, M += R * ke, I += R * Qe, B += R * tt, ce += R * Ye, D += R * dt, oe += R * lt, R = V[3], S += R * $e, m += R * Me, f += R * Ne, g += R * Ke, b += R * Le, x += R * qe, _ += R * ze, E += R * _e, v += R * Ze, M += R * at, I += R * ke, B += R * Qe, ce += R * tt, D += R * Ye, oe += R * dt, Z += R * lt, R = V[4], m += R * $e, f += R * Me, g += R * Ne, b += R * Ke, x += R * Le, _ += R * qe, E += R * ze, v += R * _e, M += R * Ze, I += R * at, B += R * ke, ce += R * Qe, D += R * tt, oe += R * Ye, Z += R * dt, J += R * lt, R = V[5], f += R * $e, g += R * Me, b += R * Ne, x += R * Ke, _ += R * Le, E += R * qe, v += R * ze, M += R * _e, I += R * Ze, B += R * at, ce += R * ke, D += R * Qe, oe += R * tt, Z += R * Ye, J += R * dt, Q += R * lt, R = V[6], g += R * $e, b += R * Me, x += R * Ne, _ += R * Ke, E += R * Le, v += R * qe, M += R * ze, I += R * _e, B += R * Ze, ce += R * at, D += R * ke, oe += R * Qe, Z += R * tt, J += R * Ye, Q += R * dt, T += R * lt, R = V[7], b += R * $e, x += R * Me, _ += R * Ne, E += R * Ke, v += R * Le, M += R * qe, I += R * ze, B += R * _e, ce += R * Ze, D += R * at, oe += R * ke, Z += R * Qe, J += R * tt, Q += R * Ye, T += R * dt, X += R * lt, R = V[8], x += R * $e, _ += R * Me, E += R * Ne, v += R * Ke, M += R * Le, I += R * qe, B += R * ze, ce += R * _e, D += R * Ze, oe += R * at, Z += R * ke, J += R * Qe, Q += R * tt, T += R * Ye, X += R * dt, re += R * lt, R = V[9], _ += R * $e, E += R * Me, v += R * Ne, M += R * Ke, I += R * Le, B += R * qe, ce += R * ze, D += R * _e, oe += R * Ze, Z += R * at, J += R * ke, Q += R * Qe, T += R * tt, X += R * Ye, re += R * dt, de += R * lt, R = V[10], E += R * $e, v += R * Me, M += R * Ne, I += R * Ke, B += R * Le, ce += R * qe, D += R * ze, oe += R * _e, Z += R * Ze, J += R * at, Q += R * ke, T += R * Qe, X += R * tt, re += R * Ye, de += R * dt, ie += R * lt, R = V[11], v += R * $e, M += R * Me, I += R * Ne, B += R * Ke, ce += R * Le, D += R * qe, oe += R * ze, Z += R * _e, J += R * Ze, Q += R * at, T += R * ke, X += R * Qe, re += R * tt, de += R * Ye, ie += R * dt, ue += R * lt, R = V[12], M += R * $e, I += R * Me, B += R * Ne, ce += R * Ke, D += R * Le, oe += R * qe, Z += R * ze, J += R * _e, Q += R * Ze, T += R * at, X += R * ke, re += R * Qe, de += R * tt, ie += R * Ye, ue += R * dt, ve += R * lt, R = V[13], I += R * $e, B += R * Me, ce += R * Ne, D += R * Ke, oe += R * Le, Z += R * qe, J += R * ze, Q += R * _e, T += R * Ze, X += R * at, re += R * ke, de += R * Qe, ie += R * tt, ue += R * Ye, ve += R * dt, Pe += R * lt, R = V[14], B += R * $e, ce += R * Me, D += R * Ne, oe += R * Ke, Z += R * Le, J += R * qe, Q += R * ze, T += R * _e, X += R * Ze, re += R * at, de += R * ke, ie += R * Qe, ue += R * tt, ve += R * Ye, Pe += R * dt, De += R * lt, R = V[15], ce += R * $e, D += R * Me, oe += R * Ne, Z += R * Ke, J += R * Le, Q += R * qe, T += R * ze, X += R * _e, re += R * Ze, de += R * at, ie += R * ke, ue += R * Qe, ve += R * tt, Pe += R * Ye, De += R * dt, Ce += R * lt, pe += 38 * D, Ee += 38 * oe, Y += 38 * Z, S += 38 * J, m += 38 * Q, f += 38 * T, g += 38 * X, b += 38 * re, x += 38 * de, _ += 38 * ie, E += 38 * ue, v += 38 * ve, M += 38 * Pe, I += 38 * De, B += 38 * Ce, W = 1, R = pe + W + 65535, W = Math.floor(R / 65536), pe = R - W * 65536, R = Ee + W + 65535, W = Math.floor(R / 65536), Ee = R - W * 65536, R = Y + W + 65535, W = Math.floor(R / 65536), Y = R - W * 65536, R = S + W + 65535, W = Math.floor(R / 65536), S = R - W * 65536, R = m + W + 65535, W = Math.floor(R / 65536), m = R - W * 65536, R = f + W + 65535, W = Math.floor(R / 65536), f = R - W * 65536, R = g + W + 65535, W = Math.floor(R / 65536), g = R - W * 65536, R = b + W + 65535, W = Math.floor(R / 65536), b = R - W * 65536, R = x + W + 65535, W = Math.floor(R / 65536), x = R - W * 65536, R = _ + W + 65535, W = Math.floor(R / 65536), _ = R - W * 65536, R = E + W + 65535, W = Math.floor(R / 65536), E = R - W * 65536, R = v + W + 65535, W = Math.floor(R / 65536), v = R - W * 65536, R = M + W + 65535, W = Math.floor(R / 65536), M = R - W * 65536, R = I + W + 65535, W = Math.floor(R / 65536), I = R - W * 65536, R = B + W + 65535, W = Math.floor(R / 65536), B = R - W * 65536, R = ce + W + 65535, W = Math.floor(R / 65536), ce = R - W * 65536, pe += W - 1 + 37 * (W - 1), W = 1, R = pe + W + 65535, W = Math.floor(R / 65536), pe = R - W * 65536, R = Ee + W + 65535, W = Math.floor(R / 65536), Ee = R - W * 65536, R = Y + W + 65535, W = Math.floor(R / 65536), Y = R - W * 65536, R = S + W + 65535, W = Math.floor(R / 65536), S = R - W * 65536, R = m + W + 65535, W = Math.floor(R / 65536), m = R - W * 65536, R = f + W + 65535, W = Math.floor(R / 65536), f = R - W * 65536, R = g + W + 65535, W = Math.floor(R / 65536), g = R - W * 65536, R = b + W + 65535, W = Math.floor(R / 65536), b = R - W * 65536, R = x + W + 65535, W = Math.floor(R / 65536), x = R - W * 65536, R = _ + W + 65535, W = Math.floor(R / 65536), _ = R - W * 65536, R = E + W + 65535, W = Math.floor(R / 65536), E = R - W * 65536, R = v + W + 65535, W = Math.floor(R / 65536), v = R - W * 65536, R = M + W + 65535, W = Math.floor(R / 65536), M = R - W * 65536, R = I + W + 65535, W = Math.floor(R / 65536), I = R - W * 65536, R = B + W + 65535, W = Math.floor(R / 65536), B = R - W * 65536, R = ce + W + 65535, W = Math.floor(R / 65536), ce = R - W * 65536, pe += W - 1 + 37 * (W - 1), H[0] = pe, H[1] = Ee, H[2] = Y, H[3] = S, H[4] = m, H[5] = f, H[6] = g, H[7] = b, H[8] = x, H[9] = _, H[10] = E, H[11] = v, H[12] = M, H[13] = I, H[14] = B, H[15] = ce;
  }
  function P(H, V) {
    w(H, V, V);
  }
  function A(H, V) {
    const te = n();
    for (let R = 0; R < 16; R++)
      te[R] = V[R];
    for (let R = 253; R >= 0; R--)
      P(te, te), R !== 2 && R !== 4 && w(te, te, V);
    for (let R = 0; R < 16; R++)
      H[R] = te[R];
  }
  function N(H, V) {
    const te = new Uint8Array(32), R = new Float64Array(80), W = n(), pe = n(), Ee = n(), Y = n(), S = n(), m = n();
    for (let x = 0; x < 31; x++)
      te[x] = H[x];
    te[31] = H[31] & 127 | 64, te[0] &= 248, l(R, V);
    for (let x = 0; x < 16; x++)
      pe[x] = R[x];
    W[0] = Y[0] = 1;
    for (let x = 254; x >= 0; --x) {
      const _ = te[x >>> 3] >>> (x & 7) & 1;
      a(W, pe, _), a(Ee, Y, _), d(S, W, Ee), p(W, W, Ee), d(Ee, pe, Y), p(pe, pe, Y), P(Y, S), P(m, W), w(W, Ee, W), w(Ee, pe, S), d(S, W, Ee), p(W, W, Ee), P(pe, W), p(Ee, Y, m), w(W, Ee, s), d(W, W, Y), w(Ee, Ee, W), w(W, Y, m), w(Y, pe, R), P(pe, S), a(W, pe, _), a(Ee, Y, _);
    }
    for (let x = 0; x < 16; x++)
      R[x + 16] = W[x], R[x + 32] = Ee[x], R[x + 48] = pe[x], R[x + 64] = Y[x];
    const f = R.subarray(32), g = R.subarray(16);
    A(f, f), w(g, g, f);
    const b = new Uint8Array(32);
    return u(b, g), b;
  }
  t.scalarMult = N;
  function L(H) {
    return N(H, i);
  }
  t.scalarMultBase = L;
  function F(H) {
    if (H.length !== t.SECRET_KEY_LENGTH)
      throw new Error(`x25519: seed must be ${t.SECRET_KEY_LENGTH} bytes`);
    const V = new Uint8Array(H);
    return {
      publicKey: L(V),
      secretKey: V
    };
  }
  t.generateKeyPairFromSeed = F;
  function $(H) {
    const V = (0, e.randomBytes)(32, H), te = F(V);
    return (0, r.wipe)(V), te;
  }
  t.generateKeyPair = $;
  function K(H, V, te = !1) {
    if (H.length !== t.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect secret key length");
    if (V.length !== t.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect public key length");
    const R = N(H, V);
    if (te) {
      let W = 0;
      for (let pe = 0; pe < R.length; pe++)
        W |= R[pe];
      if (W === 0)
        throw new Error("X25519: invalid shared key");
    }
    return R;
  }
  t.sharedKey = K;
})(Yv);
var x8 = {};
const Dj = "elliptic", Oj = "6.6.0", Nj = "EC cryptography", Lj = "lib/elliptic.js", kj = [
  "lib"
], $j = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, Fj = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, Bj = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], Uj = "Fedor Indutny <fedor@indutny.com>", jj = "MIT", qj = {
  url: "https://github.com/indutny/elliptic/issues"
}, zj = "https://github.com/indutny/elliptic", Hj = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, Wj = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, Kj = {
  name: Dj,
  version: Oj,
  description: Nj,
  main: Lj,
  files: kj,
  scripts: $j,
  repository: Fj,
  keywords: Bj,
  author: Uj,
  license: jj,
  bugs: qj,
  homepage: zj,
  devDependencies: Hj,
  dependencies: Wj
};
var Fi = {}, Jv = { exports: {} };
Jv.exports;
(function(t) {
  (function(e, r) {
    function n(Y, S) {
      if (!Y) throw new Error(S || "Assertion failed");
    }
    function i(Y, S) {
      Y.super_ = S;
      var m = function() {
      };
      m.prototype = S.prototype, Y.prototype = new m(), Y.prototype.constructor = Y;
    }
    function s(Y, S, m) {
      if (s.isBN(Y))
        return Y;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, Y !== null && ((S === "le" || S === "be") && (m = S, S = 10), this._init(Y || 0, S || 10, m || "be"));
    }
    typeof e == "object" ? e.exports = s : r.BN = s, s.BN = s, s.wordSize = 26;
    var o;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = zl.Buffer;
    } catch {
    }
    s.isBN = function(S) {
      return S instanceof s ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === s.wordSize && Array.isArray(S.words);
    }, s.max = function(S, m) {
      return S.cmp(m) > 0 ? S : m;
    }, s.min = function(S, m) {
      return S.cmp(m) < 0 ? S : m;
    }, s.prototype._init = function(S, m, f) {
      if (typeof S == "number")
        return this._initNumber(S, m, f);
      if (typeof S == "object")
        return this._initArray(S, m, f);
      m === "hex" && (m = 16), n(m === (m | 0) && m >= 2 && m <= 36), S = S.toString().replace(/\s+/g, "");
      var g = 0;
      S[0] === "-" && (g++, this.negative = 1), g < S.length && (m === 16 ? this._parseHex(S, g, f) : (this._parseBase(S, m, g), f === "le" && this._initArray(this.toArray(), m, f)));
    }, s.prototype._initNumber = function(S, m, f) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (n(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), f === "le" && this._initArray(this.toArray(), m, f);
    }, s.prototype._initArray = function(S, m, f) {
      if (n(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var g = 0; g < this.length; g++)
        this.words[g] = 0;
      var b, x, _ = 0;
      if (f === "be")
        for (g = S.length - 1, b = 0; g >= 0; g -= 3)
          x = S[g] | S[g - 1] << 8 | S[g - 2] << 16, this.words[b] |= x << _ & 67108863, this.words[b + 1] = x >>> 26 - _ & 67108863, _ += 24, _ >= 26 && (_ -= 26, b++);
      else if (f === "le")
        for (g = 0, b = 0; g < S.length; g += 3)
          x = S[g] | S[g + 1] << 8 | S[g + 2] << 16, this.words[b] |= x << _ & 67108863, this.words[b + 1] = x >>> 26 - _ & 67108863, _ += 24, _ >= 26 && (_ -= 26, b++);
      return this.strip();
    };
    function a(Y, S) {
      var m = Y.charCodeAt(S);
      return m >= 65 && m <= 70 ? m - 55 : m >= 97 && m <= 102 ? m - 87 : m - 48 & 15;
    }
    function u(Y, S, m) {
      var f = a(Y, m);
      return m - 1 >= S && (f |= a(Y, m - 1) << 4), f;
    }
    s.prototype._parseHex = function(S, m, f) {
      this.length = Math.ceil((S.length - m) / 6), this.words = new Array(this.length);
      for (var g = 0; g < this.length; g++)
        this.words[g] = 0;
      var b = 0, x = 0, _;
      if (f === "be")
        for (g = S.length - 1; g >= m; g -= 2)
          _ = u(S, m, g) << b, this.words[x] |= _ & 67108863, b >= 18 ? (b -= 18, x += 1, this.words[x] |= _ >>> 26) : b += 8;
      else {
        var E = S.length - m;
        for (g = E % 2 === 0 ? m + 1 : m; g < S.length; g += 2)
          _ = u(S, m, g) << b, this.words[x] |= _ & 67108863, b >= 18 ? (b -= 18, x += 1, this.words[x] |= _ >>> 26) : b += 8;
      }
      this.strip();
    };
    function l(Y, S, m, f) {
      for (var g = 0, b = Math.min(Y.length, m), x = S; x < b; x++) {
        var _ = Y.charCodeAt(x) - 48;
        g *= f, _ >= 49 ? g += _ - 49 + 10 : _ >= 17 ? g += _ - 17 + 10 : g += _;
      }
      return g;
    }
    s.prototype._parseBase = function(S, m, f) {
      this.words = [0], this.length = 1;
      for (var g = 0, b = 1; b <= 67108863; b *= m)
        g++;
      g--, b = b / m | 0;
      for (var x = S.length - f, _ = x % g, E = Math.min(x, x - _) + f, v = 0, M = f; M < E; M += g)
        v = l(S, M, M + g, m), this.imuln(b), this.words[0] + v < 67108864 ? this.words[0] += v : this._iaddn(v);
      if (_ !== 0) {
        var I = 1;
        for (v = l(S, M, S.length, m), M = 0; M < _; M++)
          I *= m;
        this.imuln(I), this.words[0] + v < 67108864 ? this.words[0] += v : this._iaddn(v);
      }
      this.strip();
    }, s.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var m = 0; m < this.length; m++)
        S.words[m] = this.words[m];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, s.prototype.clone = function() {
      var S = new s(null);
      return this.copy(S), S;
    }, s.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, s.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, s.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, s.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var d = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], p = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], w = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    s.prototype.toString = function(S, m) {
      S = S || 10, m = m | 0 || 1;
      var f;
      if (S === 16 || S === "hex") {
        f = "";
        for (var g = 0, b = 0, x = 0; x < this.length; x++) {
          var _ = this.words[x], E = ((_ << g | b) & 16777215).toString(16);
          b = _ >>> 24 - g & 16777215, g += 2, g >= 26 && (g -= 26, x--), b !== 0 || x !== this.length - 1 ? f = d[6 - E.length] + E + f : f = E + f;
        }
        for (b !== 0 && (f = b.toString(16) + f); f.length % m !== 0; )
          f = "0" + f;
        return this.negative !== 0 && (f = "-" + f), f;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var v = p[S], M = w[S];
        f = "";
        var I = this.clone();
        for (I.negative = 0; !I.isZero(); ) {
          var B = I.modn(M).toString(S);
          I = I.idivn(M), I.isZero() ? f = B + f : f = d[v - B.length] + B + f;
        }
        for (this.isZero() && (f = "0" + f); f.length % m !== 0; )
          f = "0" + f;
        return this.negative !== 0 && (f = "-" + f), f;
      }
      n(!1, "Base should be between 2 and 36");
    }, s.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, s.prototype.toJSON = function() {
      return this.toString(16);
    }, s.prototype.toBuffer = function(S, m) {
      return n(typeof o < "u"), this.toArrayLike(o, S, m);
    }, s.prototype.toArray = function(S, m) {
      return this.toArrayLike(Array, S, m);
    }, s.prototype.toArrayLike = function(S, m, f) {
      var g = this.byteLength(), b = f || Math.max(1, g);
      n(g <= b, "byte array longer than desired length"), n(b > 0, "Requested array length <= 0"), this.strip();
      var x = m === "le", _ = new S(b), E, v, M = this.clone();
      if (x) {
        for (v = 0; !M.isZero(); v++)
          E = M.andln(255), M.iushrn(8), _[v] = E;
        for (; v < b; v++)
          _[v] = 0;
      } else {
        for (v = 0; v < b - g; v++)
          _[v] = 0;
        for (v = 0; !M.isZero(); v++)
          E = M.andln(255), M.iushrn(8), _[b - v - 1] = E;
      }
      return _;
    }, Math.clz32 ? s.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : s.prototype._countBits = function(S) {
      var m = S, f = 0;
      return m >= 4096 && (f += 13, m >>>= 13), m >= 64 && (f += 7, m >>>= 7), m >= 8 && (f += 4, m >>>= 4), m >= 2 && (f += 2, m >>>= 2), f + m;
    }, s.prototype._zeroBits = function(S) {
      if (S === 0) return 26;
      var m = S, f = 0;
      return m & 8191 || (f += 13, m >>>= 13), m & 127 || (f += 7, m >>>= 7), m & 15 || (f += 4, m >>>= 4), m & 3 || (f += 2, m >>>= 2), m & 1 || f++, f;
    }, s.prototype.bitLength = function() {
      var S = this.words[this.length - 1], m = this._countBits(S);
      return (this.length - 1) * 26 + m;
    };
    function P(Y) {
      for (var S = new Array(Y.bitLength()), m = 0; m < S.length; m++) {
        var f = m / 26 | 0, g = m % 26;
        S[m] = (Y.words[f] & 1 << g) >>> g;
      }
      return S;
    }
    s.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var S = 0, m = 0; m < this.length; m++) {
        var f = this._zeroBits(this.words[m]);
        if (S += f, f !== 26) break;
      }
      return S;
    }, s.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, s.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, s.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, s.prototype.isNeg = function() {
      return this.negative !== 0;
    }, s.prototype.neg = function() {
      return this.clone().ineg();
    }, s.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, s.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var m = 0; m < S.length; m++)
        this.words[m] = this.words[m] | S.words[m];
      return this.strip();
    }, s.prototype.ior = function(S) {
      return n((this.negative | S.negative) === 0), this.iuor(S);
    }, s.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, s.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, s.prototype.iuand = function(S) {
      var m;
      this.length > S.length ? m = S : m = this;
      for (var f = 0; f < m.length; f++)
        this.words[f] = this.words[f] & S.words[f];
      return this.length = m.length, this.strip();
    }, s.prototype.iand = function(S) {
      return n((this.negative | S.negative) === 0), this.iuand(S);
    }, s.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, s.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, s.prototype.iuxor = function(S) {
      var m, f;
      this.length > S.length ? (m = this, f = S) : (m = S, f = this);
      for (var g = 0; g < f.length; g++)
        this.words[g] = m.words[g] ^ f.words[g];
      if (this !== m)
        for (; g < m.length; g++)
          this.words[g] = m.words[g];
      return this.length = m.length, this.strip();
    }, s.prototype.ixor = function(S) {
      return n((this.negative | S.negative) === 0), this.iuxor(S);
    }, s.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, s.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, s.prototype.inotn = function(S) {
      n(typeof S == "number" && S >= 0);
      var m = Math.ceil(S / 26) | 0, f = S % 26;
      this._expand(m), f > 0 && m--;
      for (var g = 0; g < m; g++)
        this.words[g] = ~this.words[g] & 67108863;
      return f > 0 && (this.words[g] = ~this.words[g] & 67108863 >> 26 - f), this.strip();
    }, s.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, s.prototype.setn = function(S, m) {
      n(typeof S == "number" && S >= 0);
      var f = S / 26 | 0, g = S % 26;
      return this._expand(f + 1), m ? this.words[f] = this.words[f] | 1 << g : this.words[f] = this.words[f] & ~(1 << g), this.strip();
    }, s.prototype.iadd = function(S) {
      var m;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, m = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, m = this.isub(S), S.negative = 1, m._normSign();
      var f, g;
      this.length > S.length ? (f = this, g = S) : (f = S, g = this);
      for (var b = 0, x = 0; x < g.length; x++)
        m = (f.words[x] | 0) + (g.words[x] | 0) + b, this.words[x] = m & 67108863, b = m >>> 26;
      for (; b !== 0 && x < f.length; x++)
        m = (f.words[x] | 0) + b, this.words[x] = m & 67108863, b = m >>> 26;
      if (this.length = f.length, b !== 0)
        this.words[this.length] = b, this.length++;
      else if (f !== this)
        for (; x < f.length; x++)
          this.words[x] = f.words[x];
      return this;
    }, s.prototype.add = function(S) {
      var m;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, m = this.sub(S), S.negative ^= 1, m) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, m = S.sub(this), this.negative = 1, m) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, s.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var m = this.iadd(S);
        return S.negative = 1, m._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var f = this.cmp(S);
      if (f === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var g, b;
      f > 0 ? (g = this, b = S) : (g = S, b = this);
      for (var x = 0, _ = 0; _ < b.length; _++)
        m = (g.words[_] | 0) - (b.words[_] | 0) + x, x = m >> 26, this.words[_] = m & 67108863;
      for (; x !== 0 && _ < g.length; _++)
        m = (g.words[_] | 0) + x, x = m >> 26, this.words[_] = m & 67108863;
      if (x === 0 && _ < g.length && g !== this)
        for (; _ < g.length; _++)
          this.words[_] = g.words[_];
      return this.length = Math.max(this.length, _), g !== this && (this.negative = 1), this.strip();
    }, s.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function A(Y, S, m) {
      m.negative = S.negative ^ Y.negative;
      var f = Y.length + S.length | 0;
      m.length = f, f = f - 1 | 0;
      var g = Y.words[0] | 0, b = S.words[0] | 0, x = g * b, _ = x & 67108863, E = x / 67108864 | 0;
      m.words[0] = _;
      for (var v = 1; v < f; v++) {
        for (var M = E >>> 26, I = E & 67108863, B = Math.min(v, S.length - 1), ce = Math.max(0, v - Y.length + 1); ce <= B; ce++) {
          var D = v - ce | 0;
          g = Y.words[D] | 0, b = S.words[ce] | 0, x = g * b + I, M += x / 67108864 | 0, I = x & 67108863;
        }
        m.words[v] = I | 0, E = M | 0;
      }
      return E !== 0 ? m.words[v] = E | 0 : m.length--, m.strip();
    }
    var N = function(S, m, f) {
      var g = S.words, b = m.words, x = f.words, _ = 0, E, v, M, I = g[0] | 0, B = I & 8191, ce = I >>> 13, D = g[1] | 0, oe = D & 8191, Z = D >>> 13, J = g[2] | 0, Q = J & 8191, T = J >>> 13, X = g[3] | 0, re = X & 8191, de = X >>> 13, ie = g[4] | 0, ue = ie & 8191, ve = ie >>> 13, Pe = g[5] | 0, De = Pe & 8191, Ce = Pe >>> 13, $e = g[6] | 0, Me = $e & 8191, Ne = $e >>> 13, Ke = g[7] | 0, Le = Ke & 8191, qe = Ke >>> 13, ze = g[8] | 0, _e = ze & 8191, Ze = ze >>> 13, at = g[9] | 0, ke = at & 8191, Qe = at >>> 13, tt = b[0] | 0, Ye = tt & 8191, dt = tt >>> 13, lt = b[1] | 0, ct = lt & 8191, qt = lt >>> 13, Yt = b[2] | 0, Et = Yt & 8191, Qt = Yt >>> 13, Jt = b[3] | 0, Dt = Jt & 8191, kt = Jt >>> 13, Ct = b[4] | 0, gt = Ct & 8191, Rt = Ct >>> 13, Nt = b[5] | 0, vt = Nt & 8191, $t = Nt >>> 13, Bt = b[6] | 0, rt = Bt & 8191, Ft = Bt >>> 13, k = b[7] | 0, j = k & 8191, z = k >>> 13, C = b[8] | 0, G = C & 8191, U = C >>> 13, se = b[9] | 0, he = se & 8191, xe = se >>> 13;
      f.negative = S.negative ^ m.negative, f.length = 19, E = Math.imul(B, Ye), v = Math.imul(B, dt), v = v + Math.imul(ce, Ye) | 0, M = Math.imul(ce, dt);
      var Te = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, E = Math.imul(oe, Ye), v = Math.imul(oe, dt), v = v + Math.imul(Z, Ye) | 0, M = Math.imul(Z, dt), E = E + Math.imul(B, ct) | 0, v = v + Math.imul(B, qt) | 0, v = v + Math.imul(ce, ct) | 0, M = M + Math.imul(ce, qt) | 0;
      var Re = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, E = Math.imul(Q, Ye), v = Math.imul(Q, dt), v = v + Math.imul(T, Ye) | 0, M = Math.imul(T, dt), E = E + Math.imul(oe, ct) | 0, v = v + Math.imul(oe, qt) | 0, v = v + Math.imul(Z, ct) | 0, M = M + Math.imul(Z, qt) | 0, E = E + Math.imul(B, Et) | 0, v = v + Math.imul(B, Qt) | 0, v = v + Math.imul(ce, Et) | 0, M = M + Math.imul(ce, Qt) | 0;
      var nt = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, E = Math.imul(re, Ye), v = Math.imul(re, dt), v = v + Math.imul(de, Ye) | 0, M = Math.imul(de, dt), E = E + Math.imul(Q, ct) | 0, v = v + Math.imul(Q, qt) | 0, v = v + Math.imul(T, ct) | 0, M = M + Math.imul(T, qt) | 0, E = E + Math.imul(oe, Et) | 0, v = v + Math.imul(oe, Qt) | 0, v = v + Math.imul(Z, Et) | 0, M = M + Math.imul(Z, Qt) | 0, E = E + Math.imul(B, Dt) | 0, v = v + Math.imul(B, kt) | 0, v = v + Math.imul(ce, Dt) | 0, M = M + Math.imul(ce, kt) | 0;
      var Ue = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (Ue >>> 26) | 0, Ue &= 67108863, E = Math.imul(ue, Ye), v = Math.imul(ue, dt), v = v + Math.imul(ve, Ye) | 0, M = Math.imul(ve, dt), E = E + Math.imul(re, ct) | 0, v = v + Math.imul(re, qt) | 0, v = v + Math.imul(de, ct) | 0, M = M + Math.imul(de, qt) | 0, E = E + Math.imul(Q, Et) | 0, v = v + Math.imul(Q, Qt) | 0, v = v + Math.imul(T, Et) | 0, M = M + Math.imul(T, Qt) | 0, E = E + Math.imul(oe, Dt) | 0, v = v + Math.imul(oe, kt) | 0, v = v + Math.imul(Z, Dt) | 0, M = M + Math.imul(Z, kt) | 0, E = E + Math.imul(B, gt) | 0, v = v + Math.imul(B, Rt) | 0, v = v + Math.imul(ce, gt) | 0, M = M + Math.imul(ce, Rt) | 0;
      var pt = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, E = Math.imul(De, Ye), v = Math.imul(De, dt), v = v + Math.imul(Ce, Ye) | 0, M = Math.imul(Ce, dt), E = E + Math.imul(ue, ct) | 0, v = v + Math.imul(ue, qt) | 0, v = v + Math.imul(ve, ct) | 0, M = M + Math.imul(ve, qt) | 0, E = E + Math.imul(re, Et) | 0, v = v + Math.imul(re, Qt) | 0, v = v + Math.imul(de, Et) | 0, M = M + Math.imul(de, Qt) | 0, E = E + Math.imul(Q, Dt) | 0, v = v + Math.imul(Q, kt) | 0, v = v + Math.imul(T, Dt) | 0, M = M + Math.imul(T, kt) | 0, E = E + Math.imul(oe, gt) | 0, v = v + Math.imul(oe, Rt) | 0, v = v + Math.imul(Z, gt) | 0, M = M + Math.imul(Z, Rt) | 0, E = E + Math.imul(B, vt) | 0, v = v + Math.imul(B, $t) | 0, v = v + Math.imul(ce, vt) | 0, M = M + Math.imul(ce, $t) | 0;
      var it = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, E = Math.imul(Me, Ye), v = Math.imul(Me, dt), v = v + Math.imul(Ne, Ye) | 0, M = Math.imul(Ne, dt), E = E + Math.imul(De, ct) | 0, v = v + Math.imul(De, qt) | 0, v = v + Math.imul(Ce, ct) | 0, M = M + Math.imul(Ce, qt) | 0, E = E + Math.imul(ue, Et) | 0, v = v + Math.imul(ue, Qt) | 0, v = v + Math.imul(ve, Et) | 0, M = M + Math.imul(ve, Qt) | 0, E = E + Math.imul(re, Dt) | 0, v = v + Math.imul(re, kt) | 0, v = v + Math.imul(de, Dt) | 0, M = M + Math.imul(de, kt) | 0, E = E + Math.imul(Q, gt) | 0, v = v + Math.imul(Q, Rt) | 0, v = v + Math.imul(T, gt) | 0, M = M + Math.imul(T, Rt) | 0, E = E + Math.imul(oe, vt) | 0, v = v + Math.imul(oe, $t) | 0, v = v + Math.imul(Z, vt) | 0, M = M + Math.imul(Z, $t) | 0, E = E + Math.imul(B, rt) | 0, v = v + Math.imul(B, Ft) | 0, v = v + Math.imul(ce, rt) | 0, M = M + Math.imul(ce, Ft) | 0;
      var et = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, E = Math.imul(Le, Ye), v = Math.imul(Le, dt), v = v + Math.imul(qe, Ye) | 0, M = Math.imul(qe, dt), E = E + Math.imul(Me, ct) | 0, v = v + Math.imul(Me, qt) | 0, v = v + Math.imul(Ne, ct) | 0, M = M + Math.imul(Ne, qt) | 0, E = E + Math.imul(De, Et) | 0, v = v + Math.imul(De, Qt) | 0, v = v + Math.imul(Ce, Et) | 0, M = M + Math.imul(Ce, Qt) | 0, E = E + Math.imul(ue, Dt) | 0, v = v + Math.imul(ue, kt) | 0, v = v + Math.imul(ve, Dt) | 0, M = M + Math.imul(ve, kt) | 0, E = E + Math.imul(re, gt) | 0, v = v + Math.imul(re, Rt) | 0, v = v + Math.imul(de, gt) | 0, M = M + Math.imul(de, Rt) | 0, E = E + Math.imul(Q, vt) | 0, v = v + Math.imul(Q, $t) | 0, v = v + Math.imul(T, vt) | 0, M = M + Math.imul(T, $t) | 0, E = E + Math.imul(oe, rt) | 0, v = v + Math.imul(oe, Ft) | 0, v = v + Math.imul(Z, rt) | 0, M = M + Math.imul(Z, Ft) | 0, E = E + Math.imul(B, j) | 0, v = v + Math.imul(B, z) | 0, v = v + Math.imul(ce, j) | 0, M = M + Math.imul(ce, z) | 0;
      var St = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, E = Math.imul(_e, Ye), v = Math.imul(_e, dt), v = v + Math.imul(Ze, Ye) | 0, M = Math.imul(Ze, dt), E = E + Math.imul(Le, ct) | 0, v = v + Math.imul(Le, qt) | 0, v = v + Math.imul(qe, ct) | 0, M = M + Math.imul(qe, qt) | 0, E = E + Math.imul(Me, Et) | 0, v = v + Math.imul(Me, Qt) | 0, v = v + Math.imul(Ne, Et) | 0, M = M + Math.imul(Ne, Qt) | 0, E = E + Math.imul(De, Dt) | 0, v = v + Math.imul(De, kt) | 0, v = v + Math.imul(Ce, Dt) | 0, M = M + Math.imul(Ce, kt) | 0, E = E + Math.imul(ue, gt) | 0, v = v + Math.imul(ue, Rt) | 0, v = v + Math.imul(ve, gt) | 0, M = M + Math.imul(ve, Rt) | 0, E = E + Math.imul(re, vt) | 0, v = v + Math.imul(re, $t) | 0, v = v + Math.imul(de, vt) | 0, M = M + Math.imul(de, $t) | 0, E = E + Math.imul(Q, rt) | 0, v = v + Math.imul(Q, Ft) | 0, v = v + Math.imul(T, rt) | 0, M = M + Math.imul(T, Ft) | 0, E = E + Math.imul(oe, j) | 0, v = v + Math.imul(oe, z) | 0, v = v + Math.imul(Z, j) | 0, M = M + Math.imul(Z, z) | 0, E = E + Math.imul(B, G) | 0, v = v + Math.imul(B, U) | 0, v = v + Math.imul(ce, G) | 0, M = M + Math.imul(ce, U) | 0;
      var Tt = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, E = Math.imul(ke, Ye), v = Math.imul(ke, dt), v = v + Math.imul(Qe, Ye) | 0, M = Math.imul(Qe, dt), E = E + Math.imul(_e, ct) | 0, v = v + Math.imul(_e, qt) | 0, v = v + Math.imul(Ze, ct) | 0, M = M + Math.imul(Ze, qt) | 0, E = E + Math.imul(Le, Et) | 0, v = v + Math.imul(Le, Qt) | 0, v = v + Math.imul(qe, Et) | 0, M = M + Math.imul(qe, Qt) | 0, E = E + Math.imul(Me, Dt) | 0, v = v + Math.imul(Me, kt) | 0, v = v + Math.imul(Ne, Dt) | 0, M = M + Math.imul(Ne, kt) | 0, E = E + Math.imul(De, gt) | 0, v = v + Math.imul(De, Rt) | 0, v = v + Math.imul(Ce, gt) | 0, M = M + Math.imul(Ce, Rt) | 0, E = E + Math.imul(ue, vt) | 0, v = v + Math.imul(ue, $t) | 0, v = v + Math.imul(ve, vt) | 0, M = M + Math.imul(ve, $t) | 0, E = E + Math.imul(re, rt) | 0, v = v + Math.imul(re, Ft) | 0, v = v + Math.imul(de, rt) | 0, M = M + Math.imul(de, Ft) | 0, E = E + Math.imul(Q, j) | 0, v = v + Math.imul(Q, z) | 0, v = v + Math.imul(T, j) | 0, M = M + Math.imul(T, z) | 0, E = E + Math.imul(oe, G) | 0, v = v + Math.imul(oe, U) | 0, v = v + Math.imul(Z, G) | 0, M = M + Math.imul(Z, U) | 0, E = E + Math.imul(B, he) | 0, v = v + Math.imul(B, xe) | 0, v = v + Math.imul(ce, he) | 0, M = M + Math.imul(ce, xe) | 0;
      var At = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, E = Math.imul(ke, ct), v = Math.imul(ke, qt), v = v + Math.imul(Qe, ct) | 0, M = Math.imul(Qe, qt), E = E + Math.imul(_e, Et) | 0, v = v + Math.imul(_e, Qt) | 0, v = v + Math.imul(Ze, Et) | 0, M = M + Math.imul(Ze, Qt) | 0, E = E + Math.imul(Le, Dt) | 0, v = v + Math.imul(Le, kt) | 0, v = v + Math.imul(qe, Dt) | 0, M = M + Math.imul(qe, kt) | 0, E = E + Math.imul(Me, gt) | 0, v = v + Math.imul(Me, Rt) | 0, v = v + Math.imul(Ne, gt) | 0, M = M + Math.imul(Ne, Rt) | 0, E = E + Math.imul(De, vt) | 0, v = v + Math.imul(De, $t) | 0, v = v + Math.imul(Ce, vt) | 0, M = M + Math.imul(Ce, $t) | 0, E = E + Math.imul(ue, rt) | 0, v = v + Math.imul(ue, Ft) | 0, v = v + Math.imul(ve, rt) | 0, M = M + Math.imul(ve, Ft) | 0, E = E + Math.imul(re, j) | 0, v = v + Math.imul(re, z) | 0, v = v + Math.imul(de, j) | 0, M = M + Math.imul(de, z) | 0, E = E + Math.imul(Q, G) | 0, v = v + Math.imul(Q, U) | 0, v = v + Math.imul(T, G) | 0, M = M + Math.imul(T, U) | 0, E = E + Math.imul(oe, he) | 0, v = v + Math.imul(oe, xe) | 0, v = v + Math.imul(Z, he) | 0, M = M + Math.imul(Z, xe) | 0;
      var _t = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, E = Math.imul(ke, Et), v = Math.imul(ke, Qt), v = v + Math.imul(Qe, Et) | 0, M = Math.imul(Qe, Qt), E = E + Math.imul(_e, Dt) | 0, v = v + Math.imul(_e, kt) | 0, v = v + Math.imul(Ze, Dt) | 0, M = M + Math.imul(Ze, kt) | 0, E = E + Math.imul(Le, gt) | 0, v = v + Math.imul(Le, Rt) | 0, v = v + Math.imul(qe, gt) | 0, M = M + Math.imul(qe, Rt) | 0, E = E + Math.imul(Me, vt) | 0, v = v + Math.imul(Me, $t) | 0, v = v + Math.imul(Ne, vt) | 0, M = M + Math.imul(Ne, $t) | 0, E = E + Math.imul(De, rt) | 0, v = v + Math.imul(De, Ft) | 0, v = v + Math.imul(Ce, rt) | 0, M = M + Math.imul(Ce, Ft) | 0, E = E + Math.imul(ue, j) | 0, v = v + Math.imul(ue, z) | 0, v = v + Math.imul(ve, j) | 0, M = M + Math.imul(ve, z) | 0, E = E + Math.imul(re, G) | 0, v = v + Math.imul(re, U) | 0, v = v + Math.imul(de, G) | 0, M = M + Math.imul(de, U) | 0, E = E + Math.imul(Q, he) | 0, v = v + Math.imul(Q, xe) | 0, v = v + Math.imul(T, he) | 0, M = M + Math.imul(T, xe) | 0;
      var ht = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, E = Math.imul(ke, Dt), v = Math.imul(ke, kt), v = v + Math.imul(Qe, Dt) | 0, M = Math.imul(Qe, kt), E = E + Math.imul(_e, gt) | 0, v = v + Math.imul(_e, Rt) | 0, v = v + Math.imul(Ze, gt) | 0, M = M + Math.imul(Ze, Rt) | 0, E = E + Math.imul(Le, vt) | 0, v = v + Math.imul(Le, $t) | 0, v = v + Math.imul(qe, vt) | 0, M = M + Math.imul(qe, $t) | 0, E = E + Math.imul(Me, rt) | 0, v = v + Math.imul(Me, Ft) | 0, v = v + Math.imul(Ne, rt) | 0, M = M + Math.imul(Ne, Ft) | 0, E = E + Math.imul(De, j) | 0, v = v + Math.imul(De, z) | 0, v = v + Math.imul(Ce, j) | 0, M = M + Math.imul(Ce, z) | 0, E = E + Math.imul(ue, G) | 0, v = v + Math.imul(ue, U) | 0, v = v + Math.imul(ve, G) | 0, M = M + Math.imul(ve, U) | 0, E = E + Math.imul(re, he) | 0, v = v + Math.imul(re, xe) | 0, v = v + Math.imul(de, he) | 0, M = M + Math.imul(de, xe) | 0;
      var xt = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, E = Math.imul(ke, gt), v = Math.imul(ke, Rt), v = v + Math.imul(Qe, gt) | 0, M = Math.imul(Qe, Rt), E = E + Math.imul(_e, vt) | 0, v = v + Math.imul(_e, $t) | 0, v = v + Math.imul(Ze, vt) | 0, M = M + Math.imul(Ze, $t) | 0, E = E + Math.imul(Le, rt) | 0, v = v + Math.imul(Le, Ft) | 0, v = v + Math.imul(qe, rt) | 0, M = M + Math.imul(qe, Ft) | 0, E = E + Math.imul(Me, j) | 0, v = v + Math.imul(Me, z) | 0, v = v + Math.imul(Ne, j) | 0, M = M + Math.imul(Ne, z) | 0, E = E + Math.imul(De, G) | 0, v = v + Math.imul(De, U) | 0, v = v + Math.imul(Ce, G) | 0, M = M + Math.imul(Ce, U) | 0, E = E + Math.imul(ue, he) | 0, v = v + Math.imul(ue, xe) | 0, v = v + Math.imul(ve, he) | 0, M = M + Math.imul(ve, xe) | 0;
      var st = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, E = Math.imul(ke, vt), v = Math.imul(ke, $t), v = v + Math.imul(Qe, vt) | 0, M = Math.imul(Qe, $t), E = E + Math.imul(_e, rt) | 0, v = v + Math.imul(_e, Ft) | 0, v = v + Math.imul(Ze, rt) | 0, M = M + Math.imul(Ze, Ft) | 0, E = E + Math.imul(Le, j) | 0, v = v + Math.imul(Le, z) | 0, v = v + Math.imul(qe, j) | 0, M = M + Math.imul(qe, z) | 0, E = E + Math.imul(Me, G) | 0, v = v + Math.imul(Me, U) | 0, v = v + Math.imul(Ne, G) | 0, M = M + Math.imul(Ne, U) | 0, E = E + Math.imul(De, he) | 0, v = v + Math.imul(De, xe) | 0, v = v + Math.imul(Ce, he) | 0, M = M + Math.imul(Ce, xe) | 0;
      var bt = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, E = Math.imul(ke, rt), v = Math.imul(ke, Ft), v = v + Math.imul(Qe, rt) | 0, M = Math.imul(Qe, Ft), E = E + Math.imul(_e, j) | 0, v = v + Math.imul(_e, z) | 0, v = v + Math.imul(Ze, j) | 0, M = M + Math.imul(Ze, z) | 0, E = E + Math.imul(Le, G) | 0, v = v + Math.imul(Le, U) | 0, v = v + Math.imul(qe, G) | 0, M = M + Math.imul(qe, U) | 0, E = E + Math.imul(Me, he) | 0, v = v + Math.imul(Me, xe) | 0, v = v + Math.imul(Ne, he) | 0, M = M + Math.imul(Ne, xe) | 0;
      var ut = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, E = Math.imul(ke, j), v = Math.imul(ke, z), v = v + Math.imul(Qe, j) | 0, M = Math.imul(Qe, z), E = E + Math.imul(_e, G) | 0, v = v + Math.imul(_e, U) | 0, v = v + Math.imul(Ze, G) | 0, M = M + Math.imul(Ze, U) | 0, E = E + Math.imul(Le, he) | 0, v = v + Math.imul(Le, xe) | 0, v = v + Math.imul(qe, he) | 0, M = M + Math.imul(qe, xe) | 0;
      var ot = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, E = Math.imul(ke, G), v = Math.imul(ke, U), v = v + Math.imul(Qe, G) | 0, M = Math.imul(Qe, U), E = E + Math.imul(_e, he) | 0, v = v + Math.imul(_e, xe) | 0, v = v + Math.imul(Ze, he) | 0, M = M + Math.imul(Ze, xe) | 0;
      var Se = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, E = Math.imul(ke, he), v = Math.imul(ke, xe), v = v + Math.imul(Qe, he) | 0, M = Math.imul(Qe, xe);
      var Ae = (_ + E | 0) + ((v & 8191) << 13) | 0;
      return _ = (M + (v >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, x[0] = Te, x[1] = Re, x[2] = nt, x[3] = Ue, x[4] = pt, x[5] = it, x[6] = et, x[7] = St, x[8] = Tt, x[9] = At, x[10] = _t, x[11] = ht, x[12] = xt, x[13] = st, x[14] = bt, x[15] = ut, x[16] = ot, x[17] = Se, x[18] = Ae, _ !== 0 && (x[19] = _, f.length++), f;
    };
    Math.imul || (N = A);
    function L(Y, S, m) {
      m.negative = S.negative ^ Y.negative, m.length = Y.length + S.length;
      for (var f = 0, g = 0, b = 0; b < m.length - 1; b++) {
        var x = g;
        g = 0;
        for (var _ = f & 67108863, E = Math.min(b, S.length - 1), v = Math.max(0, b - Y.length + 1); v <= E; v++) {
          var M = b - v, I = Y.words[M] | 0, B = S.words[v] | 0, ce = I * B, D = ce & 67108863;
          x = x + (ce / 67108864 | 0) | 0, D = D + _ | 0, _ = D & 67108863, x = x + (D >>> 26) | 0, g += x >>> 26, x &= 67108863;
        }
        m.words[b] = _, f = x, x = g;
      }
      return f !== 0 ? m.words[b] = f : m.length--, m.strip();
    }
    function F(Y, S, m) {
      var f = new $();
      return f.mulp(Y, S, m);
    }
    s.prototype.mulTo = function(S, m) {
      var f, g = this.length + S.length;
      return this.length === 10 && S.length === 10 ? f = N(this, S, m) : g < 63 ? f = A(this, S, m) : g < 1024 ? f = L(this, S, m) : f = F(this, S, m), f;
    };
    function $(Y, S) {
      this.x = Y, this.y = S;
    }
    $.prototype.makeRBT = function(S) {
      for (var m = new Array(S), f = s.prototype._countBits(S) - 1, g = 0; g < S; g++)
        m[g] = this.revBin(g, f, S);
      return m;
    }, $.prototype.revBin = function(S, m, f) {
      if (S === 0 || S === f - 1) return S;
      for (var g = 0, b = 0; b < m; b++)
        g |= (S & 1) << m - b - 1, S >>= 1;
      return g;
    }, $.prototype.permute = function(S, m, f, g, b, x) {
      for (var _ = 0; _ < x; _++)
        g[_] = m[S[_]], b[_] = f[S[_]];
    }, $.prototype.transform = function(S, m, f, g, b, x) {
      this.permute(x, S, m, f, g, b);
      for (var _ = 1; _ < b; _ <<= 1)
        for (var E = _ << 1, v = Math.cos(2 * Math.PI / E), M = Math.sin(2 * Math.PI / E), I = 0; I < b; I += E)
          for (var B = v, ce = M, D = 0; D < _; D++) {
            var oe = f[I + D], Z = g[I + D], J = f[I + D + _], Q = g[I + D + _], T = B * J - ce * Q;
            Q = B * Q + ce * J, J = T, f[I + D] = oe + J, g[I + D] = Z + Q, f[I + D + _] = oe - J, g[I + D + _] = Z - Q, D !== E && (T = v * B - M * ce, ce = v * ce + M * B, B = T);
          }
    }, $.prototype.guessLen13b = function(S, m) {
      var f = Math.max(m, S) | 1, g = f & 1, b = 0;
      for (f = f / 2 | 0; f; f = f >>> 1)
        b++;
      return 1 << b + 1 + g;
    }, $.prototype.conjugate = function(S, m, f) {
      if (!(f <= 1))
        for (var g = 0; g < f / 2; g++) {
          var b = S[g];
          S[g] = S[f - g - 1], S[f - g - 1] = b, b = m[g], m[g] = -m[f - g - 1], m[f - g - 1] = -b;
        }
    }, $.prototype.normalize13b = function(S, m) {
      for (var f = 0, g = 0; g < m / 2; g++) {
        var b = Math.round(S[2 * g + 1] / m) * 8192 + Math.round(S[2 * g] / m) + f;
        S[g] = b & 67108863, b < 67108864 ? f = 0 : f = b / 67108864 | 0;
      }
      return S;
    }, $.prototype.convert13b = function(S, m, f, g) {
      for (var b = 0, x = 0; x < m; x++)
        b = b + (S[x] | 0), f[2 * x] = b & 8191, b = b >>> 13, f[2 * x + 1] = b & 8191, b = b >>> 13;
      for (x = 2 * m; x < g; ++x)
        f[x] = 0;
      n(b === 0), n((b & -8192) === 0);
    }, $.prototype.stub = function(S) {
      for (var m = new Array(S), f = 0; f < S; f++)
        m[f] = 0;
      return m;
    }, $.prototype.mulp = function(S, m, f) {
      var g = 2 * this.guessLen13b(S.length, m.length), b = this.makeRBT(g), x = this.stub(g), _ = new Array(g), E = new Array(g), v = new Array(g), M = new Array(g), I = new Array(g), B = new Array(g), ce = f.words;
      ce.length = g, this.convert13b(S.words, S.length, _, g), this.convert13b(m.words, m.length, M, g), this.transform(_, x, E, v, g, b), this.transform(M, x, I, B, g, b);
      for (var D = 0; D < g; D++) {
        var oe = E[D] * I[D] - v[D] * B[D];
        v[D] = E[D] * B[D] + v[D] * I[D], E[D] = oe;
      }
      return this.conjugate(E, v, g), this.transform(E, v, ce, x, g, b), this.conjugate(ce, x, g), this.normalize13b(ce, g), f.negative = S.negative ^ m.negative, f.length = S.length + m.length, f.strip();
    }, s.prototype.mul = function(S) {
      var m = new s(null);
      return m.words = new Array(this.length + S.length), this.mulTo(S, m);
    }, s.prototype.mulf = function(S) {
      var m = new s(null);
      return m.words = new Array(this.length + S.length), F(this, S, m);
    }, s.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, s.prototype.imuln = function(S) {
      n(typeof S == "number"), n(S < 67108864);
      for (var m = 0, f = 0; f < this.length; f++) {
        var g = (this.words[f] | 0) * S, b = (g & 67108863) + (m & 67108863);
        m >>= 26, m += g / 67108864 | 0, m += b >>> 26, this.words[f] = b & 67108863;
      }
      return m !== 0 && (this.words[f] = m, this.length++), this;
    }, s.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, s.prototype.sqr = function() {
      return this.mul(this);
    }, s.prototype.isqr = function() {
      return this.imul(this.clone());
    }, s.prototype.pow = function(S) {
      var m = P(S);
      if (m.length === 0) return new s(1);
      for (var f = this, g = 0; g < m.length && m[g] === 0; g++, f = f.sqr())
        ;
      if (++g < m.length)
        for (var b = f.sqr(); g < m.length; g++, b = b.sqr())
          m[g] !== 0 && (f = f.mul(b));
      return f;
    }, s.prototype.iushln = function(S) {
      n(typeof S == "number" && S >= 0);
      var m = S % 26, f = (S - m) / 26, g = 67108863 >>> 26 - m << 26 - m, b;
      if (m !== 0) {
        var x = 0;
        for (b = 0; b < this.length; b++) {
          var _ = this.words[b] & g, E = (this.words[b] | 0) - _ << m;
          this.words[b] = E | x, x = _ >>> 26 - m;
        }
        x && (this.words[b] = x, this.length++);
      }
      if (f !== 0) {
        for (b = this.length - 1; b >= 0; b--)
          this.words[b + f] = this.words[b];
        for (b = 0; b < f; b++)
          this.words[b] = 0;
        this.length += f;
      }
      return this.strip();
    }, s.prototype.ishln = function(S) {
      return n(this.negative === 0), this.iushln(S);
    }, s.prototype.iushrn = function(S, m, f) {
      n(typeof S == "number" && S >= 0);
      var g;
      m ? g = (m - m % 26) / 26 : g = 0;
      var b = S % 26, x = Math.min((S - b) / 26, this.length), _ = 67108863 ^ 67108863 >>> b << b, E = f;
      if (g -= x, g = Math.max(0, g), E) {
        for (var v = 0; v < x; v++)
          E.words[v] = this.words[v];
        E.length = x;
      }
      if (x !== 0) if (this.length > x)
        for (this.length -= x, v = 0; v < this.length; v++)
          this.words[v] = this.words[v + x];
      else
        this.words[0] = 0, this.length = 1;
      var M = 0;
      for (v = this.length - 1; v >= 0 && (M !== 0 || v >= g); v--) {
        var I = this.words[v] | 0;
        this.words[v] = M << 26 - b | I >>> b, M = I & _;
      }
      return E && M !== 0 && (E.words[E.length++] = M), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, s.prototype.ishrn = function(S, m, f) {
      return n(this.negative === 0), this.iushrn(S, m, f);
    }, s.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, s.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, s.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, s.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, s.prototype.testn = function(S) {
      n(typeof S == "number" && S >= 0);
      var m = S % 26, f = (S - m) / 26, g = 1 << m;
      if (this.length <= f) return !1;
      var b = this.words[f];
      return !!(b & g);
    }, s.prototype.imaskn = function(S) {
      n(typeof S == "number" && S >= 0);
      var m = S % 26, f = (S - m) / 26;
      if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= f)
        return this;
      if (m !== 0 && f++, this.length = Math.min(f, this.length), m !== 0) {
        var g = 67108863 ^ 67108863 >>> m << m;
        this.words[this.length - 1] &= g;
      }
      return this.strip();
    }, s.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, s.prototype.iaddn = function(S) {
      return n(typeof S == "number"), n(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, s.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var m = 0; m < this.length && this.words[m] >= 67108864; m++)
        this.words[m] -= 67108864, m === this.length - 1 ? this.words[m + 1] = 1 : this.words[m + 1]++;
      return this.length = Math.max(this.length, m + 1), this;
    }, s.prototype.isubn = function(S) {
      if (n(typeof S == "number"), n(S < 67108864), S < 0) return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var m = 0; m < this.length && this.words[m] < 0; m++)
          this.words[m] += 67108864, this.words[m + 1] -= 1;
      return this.strip();
    }, s.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, s.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, s.prototype.iabs = function() {
      return this.negative = 0, this;
    }, s.prototype.abs = function() {
      return this.clone().iabs();
    }, s.prototype._ishlnsubmul = function(S, m, f) {
      var g = S.length + f, b;
      this._expand(g);
      var x, _ = 0;
      for (b = 0; b < S.length; b++) {
        x = (this.words[b + f] | 0) + _;
        var E = (S.words[b] | 0) * m;
        x -= E & 67108863, _ = (x >> 26) - (E / 67108864 | 0), this.words[b + f] = x & 67108863;
      }
      for (; b < this.length - f; b++)
        x = (this.words[b + f] | 0) + _, _ = x >> 26, this.words[b + f] = x & 67108863;
      if (_ === 0) return this.strip();
      for (n(_ === -1), _ = 0, b = 0; b < this.length; b++)
        x = -(this.words[b] | 0) + _, _ = x >> 26, this.words[b] = x & 67108863;
      return this.negative = 1, this.strip();
    }, s.prototype._wordDiv = function(S, m) {
      var f = this.length - S.length, g = this.clone(), b = S, x = b.words[b.length - 1] | 0, _ = this._countBits(x);
      f = 26 - _, f !== 0 && (b = b.ushln(f), g.iushln(f), x = b.words[b.length - 1] | 0);
      var E = g.length - b.length, v;
      if (m !== "mod") {
        v = new s(null), v.length = E + 1, v.words = new Array(v.length);
        for (var M = 0; M < v.length; M++)
          v.words[M] = 0;
      }
      var I = g.clone()._ishlnsubmul(b, 1, E);
      I.negative === 0 && (g = I, v && (v.words[E] = 1));
      for (var B = E - 1; B >= 0; B--) {
        var ce = (g.words[b.length + B] | 0) * 67108864 + (g.words[b.length + B - 1] | 0);
        for (ce = Math.min(ce / x | 0, 67108863), g._ishlnsubmul(b, ce, B); g.negative !== 0; )
          ce--, g.negative = 0, g._ishlnsubmul(b, 1, B), g.isZero() || (g.negative ^= 1);
        v && (v.words[B] = ce);
      }
      return v && v.strip(), g.strip(), m !== "div" && f !== 0 && g.iushrn(f), {
        div: v || null,
        mod: g
      };
    }, s.prototype.divmod = function(S, m, f) {
      if (n(!S.isZero()), this.isZero())
        return {
          div: new s(0),
          mod: new s(0)
        };
      var g, b, x;
      return this.negative !== 0 && S.negative === 0 ? (x = this.neg().divmod(S, m), m !== "mod" && (g = x.div.neg()), m !== "div" && (b = x.mod.neg(), f && b.negative !== 0 && b.iadd(S)), {
        div: g,
        mod: b
      }) : this.negative === 0 && S.negative !== 0 ? (x = this.divmod(S.neg(), m), m !== "mod" && (g = x.div.neg()), {
        div: g,
        mod: x.mod
      }) : this.negative & S.negative ? (x = this.neg().divmod(S.neg(), m), m !== "div" && (b = x.mod.neg(), f && b.negative !== 0 && b.isub(S)), {
        div: x.div,
        mod: b
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new s(0),
        mod: this
      } : S.length === 1 ? m === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : m === "mod" ? {
        div: null,
        mod: new s(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new s(this.modn(S.words[0]))
      } : this._wordDiv(S, m);
    }, s.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, s.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, s.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, s.prototype.divRound = function(S) {
      var m = this.divmod(S);
      if (m.mod.isZero()) return m.div;
      var f = m.div.negative !== 0 ? m.mod.isub(S) : m.mod, g = S.ushrn(1), b = S.andln(1), x = f.cmp(g);
      return x < 0 || b === 1 && x === 0 ? m.div : m.div.negative !== 0 ? m.div.isubn(1) : m.div.iaddn(1);
    }, s.prototype.modn = function(S) {
      n(S <= 67108863);
      for (var m = (1 << 26) % S, f = 0, g = this.length - 1; g >= 0; g--)
        f = (m * f + (this.words[g] | 0)) % S;
      return f;
    }, s.prototype.idivn = function(S) {
      n(S <= 67108863);
      for (var m = 0, f = this.length - 1; f >= 0; f--) {
        var g = (this.words[f] | 0) + m * 67108864;
        this.words[f] = g / S | 0, m = g % S;
      }
      return this.strip();
    }, s.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, s.prototype.egcd = function(S) {
      n(S.negative === 0), n(!S.isZero());
      var m = this, f = S.clone();
      m.negative !== 0 ? m = m.umod(S) : m = m.clone();
      for (var g = new s(1), b = new s(0), x = new s(0), _ = new s(1), E = 0; m.isEven() && f.isEven(); )
        m.iushrn(1), f.iushrn(1), ++E;
      for (var v = f.clone(), M = m.clone(); !m.isZero(); ) {
        for (var I = 0, B = 1; !(m.words[0] & B) && I < 26; ++I, B <<= 1) ;
        if (I > 0)
          for (m.iushrn(I); I-- > 0; )
            (g.isOdd() || b.isOdd()) && (g.iadd(v), b.isub(M)), g.iushrn(1), b.iushrn(1);
        for (var ce = 0, D = 1; !(f.words[0] & D) && ce < 26; ++ce, D <<= 1) ;
        if (ce > 0)
          for (f.iushrn(ce); ce-- > 0; )
            (x.isOdd() || _.isOdd()) && (x.iadd(v), _.isub(M)), x.iushrn(1), _.iushrn(1);
        m.cmp(f) >= 0 ? (m.isub(f), g.isub(x), b.isub(_)) : (f.isub(m), x.isub(g), _.isub(b));
      }
      return {
        a: x,
        b: _,
        gcd: f.iushln(E)
      };
    }, s.prototype._invmp = function(S) {
      n(S.negative === 0), n(!S.isZero());
      var m = this, f = S.clone();
      m.negative !== 0 ? m = m.umod(S) : m = m.clone();
      for (var g = new s(1), b = new s(0), x = f.clone(); m.cmpn(1) > 0 && f.cmpn(1) > 0; ) {
        for (var _ = 0, E = 1; !(m.words[0] & E) && _ < 26; ++_, E <<= 1) ;
        if (_ > 0)
          for (m.iushrn(_); _-- > 0; )
            g.isOdd() && g.iadd(x), g.iushrn(1);
        for (var v = 0, M = 1; !(f.words[0] & M) && v < 26; ++v, M <<= 1) ;
        if (v > 0)
          for (f.iushrn(v); v-- > 0; )
            b.isOdd() && b.iadd(x), b.iushrn(1);
        m.cmp(f) >= 0 ? (m.isub(f), g.isub(b)) : (f.isub(m), b.isub(g));
      }
      var I;
      return m.cmpn(1) === 0 ? I = g : I = b, I.cmpn(0) < 0 && I.iadd(S), I;
    }, s.prototype.gcd = function(S) {
      if (this.isZero()) return S.abs();
      if (S.isZero()) return this.abs();
      var m = this.clone(), f = S.clone();
      m.negative = 0, f.negative = 0;
      for (var g = 0; m.isEven() && f.isEven(); g++)
        m.iushrn(1), f.iushrn(1);
      do {
        for (; m.isEven(); )
          m.iushrn(1);
        for (; f.isEven(); )
          f.iushrn(1);
        var b = m.cmp(f);
        if (b < 0) {
          var x = m;
          m = f, f = x;
        } else if (b === 0 || f.cmpn(1) === 0)
          break;
        m.isub(f);
      } while (!0);
      return f.iushln(g);
    }, s.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, s.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, s.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, s.prototype.andln = function(S) {
      return this.words[0] & S;
    }, s.prototype.bincn = function(S) {
      n(typeof S == "number");
      var m = S % 26, f = (S - m) / 26, g = 1 << m;
      if (this.length <= f)
        return this._expand(f + 1), this.words[f] |= g, this;
      for (var b = g, x = f; b !== 0 && x < this.length; x++) {
        var _ = this.words[x] | 0;
        _ += b, b = _ >>> 26, _ &= 67108863, this.words[x] = _;
      }
      return b !== 0 && (this.words[x] = b, this.length++), this;
    }, s.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, s.prototype.cmpn = function(S) {
      var m = S < 0;
      if (this.negative !== 0 && !m) return -1;
      if (this.negative === 0 && m) return 1;
      this.strip();
      var f;
      if (this.length > 1)
        f = 1;
      else {
        m && (S = -S), n(S <= 67108863, "Number is too big");
        var g = this.words[0] | 0;
        f = g === S ? 0 : g < S ? -1 : 1;
      }
      return this.negative !== 0 ? -f | 0 : f;
    }, s.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0) return -1;
      if (this.negative === 0 && S.negative !== 0) return 1;
      var m = this.ucmp(S);
      return this.negative !== 0 ? -m | 0 : m;
    }, s.prototype.ucmp = function(S) {
      if (this.length > S.length) return 1;
      if (this.length < S.length) return -1;
      for (var m = 0, f = this.length - 1; f >= 0; f--) {
        var g = this.words[f] | 0, b = S.words[f] | 0;
        if (g !== b) {
          g < b ? m = -1 : g > b && (m = 1);
          break;
        }
      }
      return m;
    }, s.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, s.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, s.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, s.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, s.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, s.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, s.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, s.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, s.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, s.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, s.red = function(S) {
      return new pe(S);
    }, s.prototype.toRed = function(S) {
      return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, s.prototype.fromRed = function() {
      return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, s.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, s.prototype.forceRed = function(S) {
      return n(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, s.prototype.redAdd = function(S) {
      return n(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, s.prototype.redIAdd = function(S) {
      return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, s.prototype.redSub = function(S) {
      return n(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, s.prototype.redISub = function(S) {
      return n(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, s.prototype.redShl = function(S) {
      return n(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, s.prototype.redMul = function(S) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, s.prototype.redIMul = function(S) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, s.prototype.redSqr = function() {
      return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, s.prototype.redISqr = function() {
      return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, s.prototype.redSqrt = function() {
      return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, s.prototype.redInvm = function() {
      return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, s.prototype.redNeg = function() {
      return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, s.prototype.redPow = function(S) {
      return n(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var K = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function H(Y, S) {
      this.name = Y, this.p = new s(S, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    H.prototype._tmp = function() {
      var S = new s(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, H.prototype.ireduce = function(S) {
      var m = S, f;
      do
        this.split(m, this.tmp), m = this.imulK(m), m = m.iadd(this.tmp), f = m.bitLength();
      while (f > this.n);
      var g = f < this.n ? -1 : m.ucmp(this.p);
      return g === 0 ? (m.words[0] = 0, m.length = 1) : g > 0 ? m.isub(this.p) : m.strip !== void 0 ? m.strip() : m._strip(), m;
    }, H.prototype.split = function(S, m) {
      S.iushrn(this.n, 0, m);
    }, H.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function V() {
      H.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(V, H), V.prototype.split = function(S, m) {
      for (var f = 4194303, g = Math.min(S.length, 9), b = 0; b < g; b++)
        m.words[b] = S.words[b];
      if (m.length = g, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var x = S.words[9];
      for (m.words[m.length++] = x & f, b = 10; b < S.length; b++) {
        var _ = S.words[b] | 0;
        S.words[b - 10] = (_ & f) << 4 | x >>> 22, x = _;
      }
      x >>>= 22, S.words[b - 10] = x, x === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, V.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var m = 0, f = 0; f < S.length; f++) {
        var g = S.words[f] | 0;
        m += g * 977, S.words[f] = m & 67108863, m = g * 64 + (m / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function te() {
      H.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(te, H);
    function R() {
      H.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(R, H);
    function W() {
      H.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(W, H), W.prototype.imulK = function(S) {
      for (var m = 0, f = 0; f < S.length; f++) {
        var g = (S.words[f] | 0) * 19 + m, b = g & 67108863;
        g >>>= 26, S.words[f] = b, m = g;
      }
      return m !== 0 && (S.words[S.length++] = m), S;
    }, s._prime = function(S) {
      if (K[S]) return K[S];
      var m;
      if (S === "k256")
        m = new V();
      else if (S === "p224")
        m = new te();
      else if (S === "p192")
        m = new R();
      else if (S === "p25519")
        m = new W();
      else
        throw new Error("Unknown prime " + S);
      return K[S] = m, m;
    };
    function pe(Y) {
      if (typeof Y == "string") {
        var S = s._prime(Y);
        this.m = S.p, this.prime = S;
      } else
        n(Y.gtn(1), "modulus must be greater than 1"), this.m = Y, this.prime = null;
    }
    pe.prototype._verify1 = function(S) {
      n(S.negative === 0, "red works only with positives"), n(S.red, "red works only with red numbers");
    }, pe.prototype._verify2 = function(S, m) {
      n((S.negative | m.negative) === 0, "red works only with positives"), n(
        S.red && S.red === m.red,
        "red works only with red numbers"
      );
    }, pe.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, pe.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, pe.prototype.add = function(S, m) {
      this._verify2(S, m);
      var f = S.add(m);
      return f.cmp(this.m) >= 0 && f.isub(this.m), f._forceRed(this);
    }, pe.prototype.iadd = function(S, m) {
      this._verify2(S, m);
      var f = S.iadd(m);
      return f.cmp(this.m) >= 0 && f.isub(this.m), f;
    }, pe.prototype.sub = function(S, m) {
      this._verify2(S, m);
      var f = S.sub(m);
      return f.cmpn(0) < 0 && f.iadd(this.m), f._forceRed(this);
    }, pe.prototype.isub = function(S, m) {
      this._verify2(S, m);
      var f = S.isub(m);
      return f.cmpn(0) < 0 && f.iadd(this.m), f;
    }, pe.prototype.shl = function(S, m) {
      return this._verify1(S), this.imod(S.ushln(m));
    }, pe.prototype.imul = function(S, m) {
      return this._verify2(S, m), this.imod(S.imul(m));
    }, pe.prototype.mul = function(S, m) {
      return this._verify2(S, m), this.imod(S.mul(m));
    }, pe.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, pe.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, pe.prototype.sqrt = function(S) {
      if (S.isZero()) return S.clone();
      var m = this.m.andln(3);
      if (n(m % 2 === 1), m === 3) {
        var f = this.m.add(new s(1)).iushrn(2);
        return this.pow(S, f);
      }
      for (var g = this.m.subn(1), b = 0; !g.isZero() && g.andln(1) === 0; )
        b++, g.iushrn(1);
      n(!g.isZero());
      var x = new s(1).toRed(this), _ = x.redNeg(), E = this.m.subn(1).iushrn(1), v = this.m.bitLength();
      for (v = new s(2 * v * v).toRed(this); this.pow(v, E).cmp(_) !== 0; )
        v.redIAdd(_);
      for (var M = this.pow(v, g), I = this.pow(S, g.addn(1).iushrn(1)), B = this.pow(S, g), ce = b; B.cmp(x) !== 0; ) {
        for (var D = B, oe = 0; D.cmp(x) !== 0; oe++)
          D = D.redSqr();
        n(oe < ce);
        var Z = this.pow(M, new s(1).iushln(ce - oe - 1));
        I = I.redMul(Z), M = Z.redSqr(), B = B.redMul(M), ce = oe;
      }
      return I;
    }, pe.prototype.invm = function(S) {
      var m = S._invmp(this.m);
      return m.negative !== 0 ? (m.negative = 0, this.imod(m).redNeg()) : this.imod(m);
    }, pe.prototype.pow = function(S, m) {
      if (m.isZero()) return new s(1).toRed(this);
      if (m.cmpn(1) === 0) return S.clone();
      var f = 4, g = new Array(1 << f);
      g[0] = new s(1).toRed(this), g[1] = S;
      for (var b = 2; b < g.length; b++)
        g[b] = this.mul(g[b - 1], S);
      var x = g[0], _ = 0, E = 0, v = m.bitLength() % 26;
      for (v === 0 && (v = 26), b = m.length - 1; b >= 0; b--) {
        for (var M = m.words[b], I = v - 1; I >= 0; I--) {
          var B = M >> I & 1;
          if (x !== g[0] && (x = this.sqr(x)), B === 0 && _ === 0) {
            E = 0;
            continue;
          }
          _ <<= 1, _ |= B, E++, !(E !== f && (b !== 0 || I !== 0)) && (x = this.mul(x, g[_]), E = 0, _ = 0);
        }
        v = 26;
      }
      return x;
    }, pe.prototype.convertTo = function(S) {
      var m = S.umod(this.m);
      return m === S ? m.clone() : m;
    }, pe.prototype.convertFrom = function(S) {
      var m = S.clone();
      return m.red = null, m;
    }, s.mont = function(S) {
      return new Ee(S);
    };
    function Ee(Y) {
      pe.call(this, Y), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(Ee, pe), Ee.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, Ee.prototype.convertFrom = function(S) {
      var m = this.imod(S.mul(this.rinv));
      return m.red = null, m;
    }, Ee.prototype.imul = function(S, m) {
      if (S.isZero() || m.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var f = S.imul(m), g = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), b = f.isub(g).iushrn(this.shift), x = b;
      return b.cmp(this.m) >= 0 ? x = b.isub(this.m) : b.cmpn(0) < 0 && (x = b.iadd(this.m)), x._forceRed(this);
    }, Ee.prototype.mul = function(S, m) {
      if (S.isZero() || m.isZero()) return new s(0)._forceRed(this);
      var f = S.mul(m), g = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), b = f.isub(g).iushrn(this.shift), x = b;
      return b.cmp(this.m) >= 0 ? x = b.isub(this.m) : b.cmpn(0) < 0 && (x = b.iadd(this.m)), x._forceRed(this);
    }, Ee.prototype.invm = function(S) {
      var m = this.imod(S._invmp(this.m).mul(this.r2));
      return m._forceRed(this);
    };
  })(t, gn);
})(Jv);
var qo = Jv.exports, Xv = {};
(function(t) {
  var e = t;
  function r(s, o) {
    if (Array.isArray(s))
      return s.slice();
    if (!s)
      return [];
    var a = [];
    if (typeof s != "string") {
      for (var u = 0; u < s.length; u++)
        a[u] = s[u] | 0;
      return a;
    }
    if (o === "hex") {
      s = s.replace(/[^a-z0-9]+/ig, ""), s.length % 2 !== 0 && (s = "0" + s);
      for (var u = 0; u < s.length; u += 2)
        a.push(parseInt(s[u] + s[u + 1], 16));
    } else
      for (var u = 0; u < s.length; u++) {
        var l = s.charCodeAt(u), d = l >> 8, p = l & 255;
        d ? a.push(d, p) : a.push(p);
      }
    return a;
  }
  e.toArray = r;
  function n(s) {
    return s.length === 1 ? "0" + s : s;
  }
  e.zero2 = n;
  function i(s) {
    for (var o = "", a = 0; a < s.length; a++)
      o += n(s[a].toString(16));
    return o;
  }
  e.toHex = i, e.encode = function(o, a) {
    return a === "hex" ? i(o) : o;
  };
})(Xv);
(function(t) {
  var e = t, r = qo, n = yc, i = Xv;
  e.assert = n, e.toArray = i.toArray, e.zero2 = i.zero2, e.toHex = i.toHex, e.encode = i.encode;
  function s(d, p, w) {
    var P = new Array(Math.max(d.bitLength(), w) + 1), A;
    for (A = 0; A < P.length; A += 1)
      P[A] = 0;
    var N = 1 << p + 1, L = d.clone();
    for (A = 0; A < P.length; A++) {
      var F, $ = L.andln(N - 1);
      L.isOdd() ? ($ > (N >> 1) - 1 ? F = (N >> 1) - $ : F = $, L.isubn(F)) : F = 0, P[A] = F, L.iushrn(1);
    }
    return P;
  }
  e.getNAF = s;
  function o(d, p) {
    var w = [
      [],
      []
    ];
    d = d.clone(), p = p.clone();
    for (var P = 0, A = 0, N; d.cmpn(-P) > 0 || p.cmpn(-A) > 0; ) {
      var L = d.andln(3) + P & 3, F = p.andln(3) + A & 3;
      L === 3 && (L = -1), F === 3 && (F = -1);
      var $;
      L & 1 ? (N = d.andln(7) + P & 7, (N === 3 || N === 5) && F === 2 ? $ = -L : $ = L) : $ = 0, w[0].push($);
      var K;
      F & 1 ? (N = p.andln(7) + A & 7, (N === 3 || N === 5) && L === 2 ? K = -F : K = F) : K = 0, w[1].push(K), 2 * P === $ + 1 && (P = 1 - P), 2 * A === K + 1 && (A = 1 - A), d.iushrn(1), p.iushrn(1);
    }
    return w;
  }
  e.getJSF = o;
  function a(d, p, w) {
    var P = "_" + p;
    d.prototype[p] = function() {
      return this[P] !== void 0 ? this[P] : this[P] = w.call(this);
    };
  }
  e.cachedProperty = a;
  function u(d) {
    return typeof d == "string" ? e.toArray(d, "hex") : d;
  }
  e.parseBytes = u;
  function l(d) {
    return new r(d, "hex", "le");
  }
  e.intFromLE = l;
})(Fi);
var Zv = { exports: {} }, am;
Zv.exports = function(e) {
  return am || (am = new fa(null)), am.generate(e);
};
function fa(t) {
  this.rand = t;
}
Zv.exports.Rand = fa;
fa.prototype.generate = function(e) {
  return this._rand(e);
};
fa.prototype._rand = function(e) {
  if (this.rand.getBytes)
    return this.rand.getBytes(e);
  for (var r = new Uint8Array(e), n = 0; n < r.length; n++)
    r[n] = this.rand.getByte();
  return r;
};
if (typeof self == "object")
  self.crypto && self.crypto.getRandomValues ? fa.prototype._rand = function(e) {
    var r = new Uint8Array(e);
    return self.crypto.getRandomValues(r), r;
  } : self.msCrypto && self.msCrypto.getRandomValues ? fa.prototype._rand = function(e) {
    var r = new Uint8Array(e);
    return self.msCrypto.getRandomValues(r), r;
  } : typeof window == "object" && (fa.prototype._rand = function() {
    throw new Error("Not implemented yet");
  });
else
  try {
    var Ix = zl;
    if (typeof Ix.randomBytes != "function")
      throw new Error("Not supported");
    fa.prototype._rand = function(e) {
      return Ix.randomBytes(e);
    };
  } catch {
  }
var _8 = Zv.exports, Qv = {}, za = qo, Yl = Fi, i0 = Yl.getNAF, Vj = Yl.getJSF, s0 = Yl.assert;
function Ca(t, e) {
  this.type = t, this.p = new za(e.p, 16), this.red = e.prime ? za.red(e.prime) : za.mont(this.p), this.zero = new za(0).toRed(this.red), this.one = new za(1).toRed(this.red), this.two = new za(2).toRed(this.red), this.n = e.n && new za(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var r = this.n && this.p.div(this.n);
  !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var V0 = Ca;
Ca.prototype.point = function() {
  throw new Error("Not implemented");
};
Ca.prototype.validate = function() {
  throw new Error("Not implemented");
};
Ca.prototype._fixedNafMul = function(e, r) {
  s0(e.precomputed);
  var n = e._getDoubles(), i = i0(r, 1, this._bitLength), s = (1 << n.step + 1) - (n.step % 2 === 0 ? 2 : 1);
  s /= 3;
  var o = [], a, u;
  for (a = 0; a < i.length; a += n.step) {
    u = 0;
    for (var l = a + n.step - 1; l >= a; l--)
      u = (u << 1) + i[l];
    o.push(u);
  }
  for (var d = this.jpoint(null, null, null), p = this.jpoint(null, null, null), w = s; w > 0; w--) {
    for (a = 0; a < o.length; a++)
      u = o[a], u === w ? p = p.mixedAdd(n.points[a]) : u === -w && (p = p.mixedAdd(n.points[a].neg()));
    d = d.add(p);
  }
  return d.toP();
};
Ca.prototype._wnafMul = function(e, r) {
  var n = 4, i = e._getNAFPoints(n);
  n = i.wnd;
  for (var s = i.points, o = i0(r, n, this._bitLength), a = this.jpoint(null, null, null), u = o.length - 1; u >= 0; u--) {
    for (var l = 0; u >= 0 && o[u] === 0; u--)
      l++;
    if (u >= 0 && l++, a = a.dblp(l), u < 0)
      break;
    var d = o[u];
    s0(d !== 0), e.type === "affine" ? d > 0 ? a = a.mixedAdd(s[d - 1 >> 1]) : a = a.mixedAdd(s[-d - 1 >> 1].neg()) : d > 0 ? a = a.add(s[d - 1 >> 1]) : a = a.add(s[-d - 1 >> 1].neg());
  }
  return e.type === "affine" ? a.toP() : a;
};
Ca.prototype._wnafMulAdd = function(e, r, n, i, s) {
  var o = this._wnafT1, a = this._wnafT2, u = this._wnafT3, l = 0, d, p, w;
  for (d = 0; d < i; d++) {
    w = r[d];
    var P = w._getNAFPoints(e);
    o[d] = P.wnd, a[d] = P.points;
  }
  for (d = i - 1; d >= 1; d -= 2) {
    var A = d - 1, N = d;
    if (o[A] !== 1 || o[N] !== 1) {
      u[A] = i0(n[A], o[A], this._bitLength), u[N] = i0(n[N], o[N], this._bitLength), l = Math.max(u[A].length, l), l = Math.max(u[N].length, l);
      continue;
    }
    var L = [
      r[A],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      r[N]
      /* 7 */
    ];
    r[A].y.cmp(r[N].y) === 0 ? (L[1] = r[A].add(r[N]), L[2] = r[A].toJ().mixedAdd(r[N].neg())) : r[A].y.cmp(r[N].y.redNeg()) === 0 ? (L[1] = r[A].toJ().mixedAdd(r[N]), L[2] = r[A].add(r[N].neg())) : (L[1] = r[A].toJ().mixedAdd(r[N]), L[2] = r[A].toJ().mixedAdd(r[N].neg()));
    var F = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], $ = Vj(n[A], n[N]);
    for (l = Math.max($[0].length, l), u[A] = new Array(l), u[N] = new Array(l), p = 0; p < l; p++) {
      var K = $[0][p] | 0, H = $[1][p] | 0;
      u[A][p] = F[(K + 1) * 3 + (H + 1)], u[N][p] = 0, a[A] = L;
    }
  }
  var V = this.jpoint(null, null, null), te = this._wnafT4;
  for (d = l; d >= 0; d--) {
    for (var R = 0; d >= 0; ) {
      var W = !0;
      for (p = 0; p < i; p++)
        te[p] = u[p][d] | 0, te[p] !== 0 && (W = !1);
      if (!W)
        break;
      R++, d--;
    }
    if (d >= 0 && R++, V = V.dblp(R), d < 0)
      break;
    for (p = 0; p < i; p++) {
      var pe = te[p];
      pe !== 0 && (pe > 0 ? w = a[p][pe - 1 >> 1] : pe < 0 && (w = a[p][-pe - 1 >> 1].neg()), w.type === "affine" ? V = V.mixedAdd(w) : V = V.add(w));
    }
  }
  for (d = 0; d < i; d++)
    a[d] = null;
  return s ? V : V.toP();
};
function ss(t, e) {
  this.curve = t, this.type = e, this.precomputed = null;
}
Ca.BasePoint = ss;
ss.prototype.eq = function() {
  throw new Error("Not implemented");
};
ss.prototype.validate = function() {
  return this.curve.validate(this);
};
Ca.prototype.decodePoint = function(e, r) {
  e = Yl.toArray(e, r);
  var n = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * n) {
    e[0] === 6 ? s0(e[e.length - 1] % 2 === 0) : e[0] === 7 && s0(e[e.length - 1] % 2 === 1);
    var i = this.point(
      e.slice(1, 1 + n),
      e.slice(1 + n, 1 + 2 * n)
    );
    return i;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n)
    return this.pointFromX(e.slice(1, 1 + n), e[0] === 3);
  throw new Error("Unknown point format");
};
ss.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
ss.prototype._encode = function(e) {
  var r = this.curve.p.byteLength(), n = this.getX().toArray("be", r);
  return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", r));
};
ss.prototype.encode = function(e, r) {
  return Yl.encode(this._encode(r), e);
};
ss.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var r = {
    doubles: null,
    naf: null,
    beta: null
  };
  return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
};
ss.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var r = this.precomputed.doubles;
  return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : !1;
};
ss.prototype._getDoubles = function(e, r) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var n = [this], i = this, s = 0; s < r; s += e) {
    for (var o = 0; o < e; o++)
      i = i.dbl();
    n.push(i);
  }
  return {
    step: e,
    points: n
  };
};
ss.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var r = [this], n = (1 << e) - 1, i = n === 1 ? null : this.dbl(), s = 1; s < n; s++)
    r[s] = r[s - 1].add(i);
  return {
    wnd: e,
    points: r
  };
};
ss.prototype._getBeta = function() {
  return null;
};
ss.prototype.dblp = function(e) {
  for (var r = this, n = 0; n < e; n++)
    r = r.dbl();
  return r;
};
var Gj = Fi, rn = qo, eb = q0, Fu = V0, Yj = Gj.assert;
function os(t) {
  Fu.call(this, "short", t), this.a = new rn(t.a, 16).toRed(this.red), this.b = new rn(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
eb(os, Fu);
var Jj = os;
os.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var r, n;
    if (e.beta)
      r = new rn(e.beta, 16).toRed(this.red);
    else {
      var i = this._getEndoRoots(this.p);
      r = i[0].cmp(i[1]) < 0 ? i[0] : i[1], r = r.toRed(this.red);
    }
    if (e.lambda)
      n = new rn(e.lambda, 16);
    else {
      var s = this._getEndoRoots(this.n);
      this.g.mul(s[0]).x.cmp(this.g.x.redMul(r)) === 0 ? n = s[0] : (n = s[1], Yj(this.g.mul(n).x.cmp(this.g.x.redMul(r)) === 0));
    }
    var o;
    return e.basis ? o = e.basis.map(function(a) {
      return {
        a: new rn(a.a, 16),
        b: new rn(a.b, 16)
      };
    }) : o = this._getEndoBasis(n), {
      beta: r,
      lambda: n,
      basis: o
    };
  }
};
os.prototype._getEndoRoots = function(e) {
  var r = e === this.p ? this.red : rn.mont(e), n = new rn(2).toRed(r).redInvm(), i = n.redNeg(), s = new rn(3).toRed(r).redNeg().redSqrt().redMul(n), o = i.redAdd(s).fromRed(), a = i.redSub(s).fromRed();
  return [o, a];
};
os.prototype._getEndoBasis = function(e) {
  for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), n = e, i = this.n.clone(), s = new rn(1), o = new rn(0), a = new rn(0), u = new rn(1), l, d, p, w, P, A, N, L = 0, F, $; n.cmpn(0) !== 0; ) {
    var K = i.div(n);
    F = i.sub(K.mul(n)), $ = a.sub(K.mul(s));
    var H = u.sub(K.mul(o));
    if (!p && F.cmp(r) < 0)
      l = N.neg(), d = s, p = F.neg(), w = $;
    else if (p && ++L === 2)
      break;
    N = F, i = n, n = F, a = s, s = $, u = o, o = H;
  }
  P = F.neg(), A = $;
  var V = p.sqr().add(w.sqr()), te = P.sqr().add(A.sqr());
  return te.cmp(V) >= 0 && (P = l, A = d), p.negative && (p = p.neg(), w = w.neg()), P.negative && (P = P.neg(), A = A.neg()), [
    { a: p, b: w },
    { a: P, b: A }
  ];
};
os.prototype._endoSplit = function(e) {
  var r = this.endo.basis, n = r[0], i = r[1], s = i.b.mul(e).divRound(this.n), o = n.b.neg().mul(e).divRound(this.n), a = s.mul(n.a), u = o.mul(i.a), l = s.mul(n.b), d = o.mul(i.b), p = e.sub(a).sub(u), w = l.add(d).neg();
  return { k1: p, k2: w };
};
os.prototype.pointFromX = function(e, r) {
  e = new rn(e, 16), e.red || (e = e.toRed(this.red));
  var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), i = n.redSqrt();
  if (i.redSqr().redSub(n).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var s = i.fromRed().isOdd();
  return (r && !s || !r && s) && (i = i.redNeg()), this.point(e, i);
};
os.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var r = e.x, n = e.y, i = this.a.redMul(r), s = r.redSqr().redMul(r).redIAdd(i).redIAdd(this.b);
  return n.redSqr().redISub(s).cmpn(0) === 0;
};
os.prototype._endoWnafMulAdd = function(e, r, n) {
  for (var i = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < e.length; o++) {
    var a = this._endoSplit(r[o]), u = e[o], l = u._getBeta();
    a.k1.negative && (a.k1.ineg(), u = u.neg(!0)), a.k2.negative && (a.k2.ineg(), l = l.neg(!0)), i[o * 2] = u, i[o * 2 + 1] = l, s[o * 2] = a.k1, s[o * 2 + 1] = a.k2;
  }
  for (var d = this._wnafMulAdd(1, i, s, o * 2, n), p = 0; p < o * 2; p++)
    i[p] = null, s[p] = null;
  return d;
};
function kn(t, e, r, n) {
  Fu.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new rn(e, 16), this.y = new rn(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
eb(kn, Fu.BasePoint);
os.prototype.point = function(e, r, n) {
  return new kn(this, e, r, n);
};
os.prototype.pointFromJSON = function(e, r) {
  return kn.fromJSON(this, e, r);
};
kn.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var n = this.curve, i = function(s) {
        return n.point(s.x.redMul(n.endo.beta), s.y);
      };
      e.beta = r, r.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(i)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(i)
        }
      };
    }
    return r;
  }
};
kn.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
kn.fromJSON = function(e, r, n) {
  typeof r == "string" && (r = JSON.parse(r));
  var i = e.point(r[0], r[1], n);
  if (!r[2])
    return i;
  function s(a) {
    return e.point(a[0], a[1], n);
  }
  var o = r[2];
  return i.precomputed = {
    beta: null,
    doubles: o.doubles && {
      step: o.doubles.step,
      points: [i].concat(o.doubles.points.map(s))
    },
    naf: o.naf && {
      wnd: o.naf.wnd,
      points: [i].concat(o.naf.points.map(s))
    }
  }, i;
};
kn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
kn.prototype.isInfinity = function() {
  return this.inf;
};
kn.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var r = this.y.redSub(e.y);
  r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
  var n = r.redSqr().redISub(this.x).redISub(e.x), i = r.redMul(this.x.redSub(n)).redISub(this.y);
  return this.curve.point(n, i);
};
kn.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var r = this.curve.a, n = this.x.redSqr(), i = e.redInvm(), s = n.redAdd(n).redIAdd(n).redIAdd(r).redMul(i), o = s.redSqr().redISub(this.x.redAdd(this.x)), a = s.redMul(this.x.redSub(o)).redISub(this.y);
  return this.curve.point(o, a);
};
kn.prototype.getX = function() {
  return this.x.fromRed();
};
kn.prototype.getY = function() {
  return this.y.fromRed();
};
kn.prototype.mul = function(e) {
  return e = new rn(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
kn.prototype.mulAdd = function(e, r, n) {
  var i = [this, r], s = [e, n];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2);
};
kn.prototype.jmulAdd = function(e, r, n) {
  var i = [this, r], s = [e, n];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, !0) : this.curve._wnafMulAdd(1, i, s, 2, !0);
};
kn.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
kn.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var r = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var n = this.precomputed, i = function(s) {
      return s.neg();
    };
    r.precomputed = {
      naf: n.naf && {
        wnd: n.naf.wnd,
        points: n.naf.points.map(i)
      },
      doubles: n.doubles && {
        step: n.doubles.step,
        points: n.doubles.points.map(i)
      }
    };
  }
  return r;
};
kn.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function zn(t, e, r, n) {
  Fu.BasePoint.call(this, t, "jacobian"), e === null && r === null && n === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new rn(0)) : (this.x = new rn(e, 16), this.y = new rn(r, 16), this.z = new rn(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
eb(zn, Fu.BasePoint);
os.prototype.jpoint = function(e, r, n) {
  return new zn(this, e, r, n);
};
zn.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), r = e.redSqr(), n = this.x.redMul(r), i = this.y.redMul(r).redMul(e);
  return this.curve.point(n, i);
};
zn.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
zn.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var r = e.z.redSqr(), n = this.z.redSqr(), i = this.x.redMul(r), s = e.x.redMul(n), o = this.y.redMul(r.redMul(e.z)), a = e.y.redMul(n.redMul(this.z)), u = i.redSub(s), l = o.redSub(a);
  if (u.cmpn(0) === 0)
    return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var d = u.redSqr(), p = d.redMul(u), w = i.redMul(d), P = l.redSqr().redIAdd(p).redISub(w).redISub(w), A = l.redMul(w.redISub(P)).redISub(o.redMul(p)), N = this.z.redMul(e.z).redMul(u);
  return this.curve.jpoint(P, A, N);
};
zn.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var r = this.z.redSqr(), n = this.x, i = e.x.redMul(r), s = this.y, o = e.y.redMul(r).redMul(this.z), a = n.redSub(i), u = s.redSub(o);
  if (a.cmpn(0) === 0)
    return u.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var l = a.redSqr(), d = l.redMul(a), p = n.redMul(l), w = u.redSqr().redIAdd(d).redISub(p).redISub(p), P = u.redMul(p.redISub(w)).redISub(s.redMul(d)), A = this.z.redMul(a);
  return this.curve.jpoint(w, P, A);
};
zn.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var r;
  if (this.curve.zeroA || this.curve.threeA) {
    var n = this;
    for (r = 0; r < e; r++)
      n = n.dbl();
    return n;
  }
  var i = this.curve.a, s = this.curve.tinv, o = this.x, a = this.y, u = this.z, l = u.redSqr().redSqr(), d = a.redAdd(a);
  for (r = 0; r < e; r++) {
    var p = o.redSqr(), w = d.redSqr(), P = w.redSqr(), A = p.redAdd(p).redIAdd(p).redIAdd(i.redMul(l)), N = o.redMul(w), L = A.redSqr().redISub(N.redAdd(N)), F = N.redISub(L), $ = A.redMul(F);
    $ = $.redIAdd($).redISub(P);
    var K = d.redMul(u);
    r + 1 < e && (l = l.redMul(P)), o = L, u = K, d = $;
  }
  return this.curve.jpoint(o, d.redMul(s), u);
};
zn.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
zn.prototype._zeroDbl = function() {
  var e, r, n;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
    a = a.redIAdd(a);
    var u = i.redAdd(i).redIAdd(i), l = u.redSqr().redISub(a).redISub(a), d = o.redIAdd(o);
    d = d.redIAdd(d), d = d.redIAdd(d), e = l, r = u.redMul(a.redISub(l)).redISub(d), n = this.y.redAdd(this.y);
  } else {
    var p = this.x.redSqr(), w = this.y.redSqr(), P = w.redSqr(), A = this.x.redAdd(w).redSqr().redISub(p).redISub(P);
    A = A.redIAdd(A);
    var N = p.redAdd(p).redIAdd(p), L = N.redSqr(), F = P.redIAdd(P);
    F = F.redIAdd(F), F = F.redIAdd(F), e = L.redISub(A).redISub(A), r = N.redMul(A.redISub(e)).redISub(F), n = this.y.redMul(this.z), n = n.redIAdd(n);
  }
  return this.curve.jpoint(e, r, n);
};
zn.prototype._threeDbl = function() {
  var e, r, n;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
    a = a.redIAdd(a);
    var u = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a), l = u.redSqr().redISub(a).redISub(a);
    e = l;
    var d = o.redIAdd(o);
    d = d.redIAdd(d), d = d.redIAdd(d), r = u.redMul(a.redISub(l)).redISub(d), n = this.y.redAdd(this.y);
  } else {
    var p = this.z.redSqr(), w = this.y.redSqr(), P = this.x.redMul(w), A = this.x.redSub(p).redMul(this.x.redAdd(p));
    A = A.redAdd(A).redIAdd(A);
    var N = P.redIAdd(P);
    N = N.redIAdd(N);
    var L = N.redAdd(N);
    e = A.redSqr().redISub(L), n = this.y.redAdd(this.z).redSqr().redISub(w).redISub(p);
    var F = w.redSqr();
    F = F.redIAdd(F), F = F.redIAdd(F), F = F.redIAdd(F), r = A.redMul(N.redISub(e)).redISub(F);
  }
  return this.curve.jpoint(e, r, n);
};
zn.prototype._dbl = function() {
  var e = this.curve.a, r = this.x, n = this.y, i = this.z, s = i.redSqr().redSqr(), o = r.redSqr(), a = n.redSqr(), u = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(s)), l = r.redAdd(r);
  l = l.redIAdd(l);
  var d = l.redMul(a), p = u.redSqr().redISub(d.redAdd(d)), w = d.redISub(p), P = a.redSqr();
  P = P.redIAdd(P), P = P.redIAdd(P), P = P.redIAdd(P);
  var A = u.redMul(w).redISub(P), N = n.redAdd(n).redMul(i);
  return this.curve.jpoint(p, A, N);
};
zn.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr(), i = r.redSqr(), s = e.redAdd(e).redIAdd(e), o = s.redSqr(), a = this.x.redAdd(r).redSqr().redISub(e).redISub(i);
  a = a.redIAdd(a), a = a.redAdd(a).redIAdd(a), a = a.redISub(o);
  var u = a.redSqr(), l = i.redIAdd(i);
  l = l.redIAdd(l), l = l.redIAdd(l), l = l.redIAdd(l);
  var d = s.redIAdd(a).redSqr().redISub(o).redISub(u).redISub(l), p = r.redMul(d);
  p = p.redIAdd(p), p = p.redIAdd(p);
  var w = this.x.redMul(u).redISub(p);
  w = w.redIAdd(w), w = w.redIAdd(w);
  var P = this.y.redMul(d.redMul(l.redISub(d)).redISub(a.redMul(u)));
  P = P.redIAdd(P), P = P.redIAdd(P), P = P.redIAdd(P);
  var A = this.z.redAdd(a).redSqr().redISub(n).redISub(u);
  return this.curve.jpoint(w, P, A);
};
zn.prototype.mul = function(e, r) {
  return e = new rn(e, r), this.curve._wnafMul(this, e);
};
zn.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var r = this.z.redSqr(), n = e.z.redSqr();
  if (this.x.redMul(n).redISub(e.x.redMul(r)).cmpn(0) !== 0)
    return !1;
  var i = r.redMul(this.z), s = n.redMul(e.z);
  return this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0) === 0;
};
zn.prototype.eqXToP = function(e) {
  var r = this.z.redSqr(), n = e.toRed(this.curve.red).redMul(r);
  if (this.x.cmp(n) === 0)
    return !0;
  for (var i = e.clone(), s = this.curve.redN.redMul(r); ; ) {
    if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)
      return !1;
    if (n.redIAdd(s), this.x.cmp(n) === 0)
      return !0;
  }
};
zn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
zn.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var Zc = qo, E8 = q0, G0 = V0, Xj = Fi;
function Bu(t) {
  G0.call(this, "mont", t), this.a = new Zc(t.a, 16).toRed(this.red), this.b = new Zc(t.b, 16).toRed(this.red), this.i4 = new Zc(4).toRed(this.red).redInvm(), this.two = new Zc(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
E8(Bu, G0);
var Zj = Bu;
Bu.prototype.validate = function(e) {
  var r = e.normalize().x, n = r.redSqr(), i = n.redMul(r).redAdd(n.redMul(this.a)).redAdd(r), s = i.redSqrt();
  return s.redSqr().cmp(i) === 0;
};
function Nn(t, e, r) {
  G0.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new Zc(e, 16), this.z = new Zc(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
E8(Nn, G0.BasePoint);
Bu.prototype.decodePoint = function(e, r) {
  return this.point(Xj.toArray(e, r), 1);
};
Bu.prototype.point = function(e, r) {
  return new Nn(this, e, r);
};
Bu.prototype.pointFromJSON = function(e) {
  return Nn.fromJSON(this, e);
};
Nn.prototype.precompute = function() {
};
Nn.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Nn.fromJSON = function(e, r) {
  return new Nn(e, r[0], r[1] || e.one);
};
Nn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Nn.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
Nn.prototype.dbl = function() {
  var e = this.x.redAdd(this.z), r = e.redSqr(), n = this.x.redSub(this.z), i = n.redSqr(), s = r.redSub(i), o = r.redMul(i), a = s.redMul(i.redAdd(this.curve.a24.redMul(s)));
  return this.curve.point(o, a);
};
Nn.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
Nn.prototype.diffAdd = function(e, r) {
  var n = this.x.redAdd(this.z), i = this.x.redSub(this.z), s = e.x.redAdd(e.z), o = e.x.redSub(e.z), a = o.redMul(n), u = s.redMul(i), l = r.z.redMul(a.redAdd(u).redSqr()), d = r.x.redMul(a.redISub(u).redSqr());
  return this.curve.point(l, d);
};
Nn.prototype.mul = function(e) {
  for (var r = e.clone(), n = this, i = this.curve.point(null, null), s = this, o = []; r.cmpn(0) !== 0; r.iushrn(1))
    o.push(r.andln(1));
  for (var a = o.length - 1; a >= 0; a--)
    o[a] === 0 ? (n = n.diffAdd(i, s), i = i.dbl()) : (i = n.diffAdd(i, s), n = n.dbl());
  return i;
};
Nn.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Nn.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Nn.prototype.eq = function(e) {
  return this.getX().cmp(e.getX()) === 0;
};
Nn.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Nn.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var Qj = Fi, Eo = qo, S8 = q0, Y0 = V0, eq = Qj.assert;
function ro(t) {
  this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, Y0.call(this, "edwards", t), this.a = new Eo(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new Eo(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new Eo(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), eq(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
}
S8(ro, Y0);
var tq = ro;
ro.prototype._mulA = function(e) {
  return this.mOneA ? e.redNeg() : this.a.redMul(e);
};
ro.prototype._mulC = function(e) {
  return this.oneC ? e : this.c.redMul(e);
};
ro.prototype.jpoint = function(e, r, n, i) {
  return this.point(e, r, n, i);
};
ro.prototype.pointFromX = function(e, r) {
  e = new Eo(e, 16), e.red || (e = e.toRed(this.red));
  var n = e.redSqr(), i = this.c2.redSub(this.a.redMul(n)), s = this.one.redSub(this.c2.redMul(this.d).redMul(n)), o = i.redMul(s.redInvm()), a = o.redSqrt();
  if (a.redSqr().redSub(o).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var u = a.fromRed().isOdd();
  return (r && !u || !r && u) && (a = a.redNeg()), this.point(e, a);
};
ro.prototype.pointFromY = function(e, r) {
  e = new Eo(e, 16), e.red || (e = e.toRed(this.red));
  var n = e.redSqr(), i = n.redSub(this.c2), s = n.redMul(this.d).redMul(this.c2).redSub(this.a), o = i.redMul(s.redInvm());
  if (o.cmp(this.zero) === 0) {
    if (r)
      throw new Error("invalid point");
    return this.point(this.zero, e);
  }
  var a = o.redSqrt();
  if (a.redSqr().redSub(o).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return a.fromRed().isOdd() !== r && (a = a.redNeg()), this.point(a, e);
};
ro.prototype.validate = function(e) {
  if (e.isInfinity())
    return !0;
  e.normalize();
  var r = e.x.redSqr(), n = e.y.redSqr(), i = r.redMul(this.a).redAdd(n), s = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(n)));
  return i.cmp(s) === 0;
};
function Wr(t, e, r, n, i) {
  Y0.BasePoint.call(this, t, "projective"), e === null && r === null && n === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new Eo(e, 16), this.y = new Eo(r, 16), this.z = n ? new Eo(n, 16) : this.curve.one, this.t = i && new Eo(i, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
S8(Wr, Y0.BasePoint);
ro.prototype.pointFromJSON = function(e) {
  return Wr.fromJSON(this, e);
};
ro.prototype.point = function(e, r, n, i) {
  return new Wr(this, e, r, n, i);
};
Wr.fromJSON = function(e, r) {
  return new Wr(e, r[0], r[1], r[2]);
};
Wr.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Wr.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Wr.prototype._extDbl = function() {
  var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr();
  n = n.redIAdd(n);
  var i = this.curve._mulA(e), s = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r), o = i.redAdd(r), a = o.redSub(n), u = i.redSub(r), l = s.redMul(a), d = o.redMul(u), p = s.redMul(u), w = a.redMul(o);
  return this.curve.point(l, d, w, p);
};
Wr.prototype._projDbl = function() {
  var e = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), n = this.y.redSqr(), i, s, o, a, u, l;
  if (this.curve.twisted) {
    a = this.curve._mulA(r);
    var d = a.redAdd(n);
    this.zOne ? (i = e.redSub(r).redSub(n).redMul(d.redSub(this.curve.two)), s = d.redMul(a.redSub(n)), o = d.redSqr().redSub(d).redSub(d)) : (u = this.z.redSqr(), l = d.redSub(u).redISub(u), i = e.redSub(r).redISub(n).redMul(l), s = d.redMul(a.redSub(n)), o = d.redMul(l));
  } else
    a = r.redAdd(n), u = this.curve._mulC(this.z).redSqr(), l = a.redSub(u).redSub(u), i = this.curve._mulC(e.redISub(a)).redMul(l), s = this.curve._mulC(a).redMul(r.redISub(n)), o = a.redMul(l);
  return this.curve.point(i, s, o);
};
Wr.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Wr.prototype._extAdd = function(e) {
  var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), n = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), i = this.t.redMul(this.curve.dd).redMul(e.t), s = this.z.redMul(e.z.redAdd(e.z)), o = n.redSub(r), a = s.redSub(i), u = s.redAdd(i), l = n.redAdd(r), d = o.redMul(a), p = u.redMul(l), w = o.redMul(l), P = a.redMul(u);
  return this.curve.point(d, p, P, w);
};
Wr.prototype._projAdd = function(e) {
  var r = this.z.redMul(e.z), n = r.redSqr(), i = this.x.redMul(e.x), s = this.y.redMul(e.y), o = this.curve.d.redMul(i).redMul(s), a = n.redSub(o), u = n.redAdd(o), l = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(i).redISub(s), d = r.redMul(a).redMul(l), p, w;
  return this.curve.twisted ? (p = r.redMul(u).redMul(s.redSub(this.curve._mulA(i))), w = a.redMul(u)) : (p = r.redMul(u).redMul(s.redSub(i)), w = this.curve._mulC(a).redMul(u)), this.curve.point(d, p, w);
};
Wr.prototype.add = function(e) {
  return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
};
Wr.prototype.mul = function(e) {
  return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
};
Wr.prototype.mulAdd = function(e, r, n) {
  return this.curve._wnafMulAdd(1, [this, r], [e, n], 2, !1);
};
Wr.prototype.jmulAdd = function(e, r, n) {
  return this.curve._wnafMulAdd(1, [this, r], [e, n], 2, !0);
};
Wr.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var e = this.z.redInvm();
  return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this;
};
Wr.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Wr.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
Wr.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
Wr.prototype.eq = function(e) {
  return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
};
Wr.prototype.eqXToP = function(e) {
  var r = e.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(r) === 0)
    return !0;
  for (var n = e.clone(), i = this.curve.redN.redMul(this.z); ; ) {
    if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0)
      return !1;
    if (r.redIAdd(i), this.x.cmp(r) === 0)
      return !0;
  }
};
Wr.prototype.toP = Wr.prototype.normalize;
Wr.prototype.mixedAdd = Wr.prototype.add;
(function(t) {
  var e = t;
  e.base = V0, e.short = Jj, e.mont = Zj, e.edwards = tq;
})(Qv);
var J0 = {}, cm, Cx;
function rq() {
  return Cx || (Cx = 1, cm = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), cm;
}
(function(t) {
  var e = t, r = Kl, n = Qv, i = Fi, s = i.assert;
  function o(l) {
    l.type === "short" ? this.curve = new n.short(l) : l.type === "edwards" ? this.curve = new n.edwards(l) : this.curve = new n.mont(l), this.g = this.curve.g, this.n = this.curve.n, this.hash = l.hash, s(this.g.validate(), "Invalid curve"), s(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  e.PresetCurve = o;
  function a(l, d) {
    Object.defineProperty(e, l, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var p = new o(d);
        return Object.defineProperty(e, l, {
          configurable: !0,
          enumerable: !0,
          value: p
        }), p;
      }
    });
  }
  a("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: r.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), a("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: r.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), a("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: r.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), a("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: r.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), a("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: r.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), a("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: r.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), a("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: r.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var u;
  try {
    u = rq();
  } catch {
    u = void 0;
  }
  a("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: r.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      u
    ]
  });
})(J0);
var nq = Kl, sc = Xv, A8 = yc;
function ba(t) {
  if (!(this instanceof ba))
    return new ba(t);
  this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var e = sc.toArray(t.entropy, t.entropyEnc || "hex"), r = sc.toArray(t.nonce, t.nonceEnc || "hex"), n = sc.toArray(t.pers, t.persEnc || "hex");
  A8(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(e, r, n);
}
var iq = ba;
ba.prototype._init = function(e, r, n) {
  var i = e.concat(r).concat(n);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var s = 0; s < this.V.length; s++)
    this.K[s] = 0, this.V[s] = 1;
  this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656;
};
ba.prototype._hmac = function() {
  return new nq.hmac(this.hash, this.K);
};
ba.prototype._update = function(e) {
  var r = this._hmac().update(this.V).update([0]);
  e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
ba.prototype.reseed = function(e, r, n, i) {
  typeof r != "string" && (i = n, n = r, r = null), e = sc.toArray(e, r), n = sc.toArray(n, i), A8(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(n || [])), this._reseed = 1;
};
ba.prototype.generate = function(e, r, n, i) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof r != "string" && (i = n, n = r, r = null), n && (n = sc.toArray(n, i || "hex"), this._update(n));
  for (var s = []; s.length < e; )
    this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
  var o = s.slice(0, e);
  return this._update(n), this._reseed++, sc.encode(o, r);
};
var sq = qo, oq = Fi, P1 = oq.assert;
function Qn(t, e) {
  this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var aq = Qn;
Qn.fromPublic = function(e, r, n) {
  return r instanceof Qn ? r : new Qn(e, {
    pub: r,
    pubEnc: n
  });
};
Qn.fromPrivate = function(e, r, n) {
  return r instanceof Qn ? r : new Qn(e, {
    priv: r,
    privEnc: n
  });
};
Qn.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
Qn.prototype.getPublic = function(e, r) {
  return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
};
Qn.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
Qn.prototype._importPrivate = function(e, r) {
  this.priv = new sq(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
Qn.prototype._importPublic = function(e, r) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? P1(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && P1(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, r);
};
Qn.prototype.derive = function(e) {
  return e.validate() || P1(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
Qn.prototype.sign = function(e, r, n) {
  return this.ec.sign(e, this, r, n);
};
Qn.prototype.verify = function(e, r, n) {
  return this.ec.verify(e, r, this, void 0, n);
};
Qn.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var o0 = qo, tb = Fi, cq = tb.assert;
function X0(t, e) {
  if (t instanceof X0)
    return t;
  this._importDER(t, e) || (cq(t.r && t.s, "Signature without r or s"), this.r = new o0(t.r, 16), this.s = new o0(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
}
var uq = X0;
function fq() {
  this.place = 0;
}
function um(t, e) {
  var r = t[e.place++];
  if (!(r & 128))
    return r;
  var n = r & 15;
  if (n === 0 || n > 4 || t[e.place] === 0)
    return !1;
  for (var i = 0, s = 0, o = e.place; s < n; s++, o++)
    i <<= 8, i |= t[o], i >>>= 0;
  return i <= 127 ? !1 : (e.place = o, i);
}
function Tx(t) {
  for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r; )
    e++;
  return e === 0 ? t : t.slice(e);
}
X0.prototype._importDER = function(e, r) {
  e = tb.toArray(e, r);
  var n = new fq();
  if (e[n.place++] !== 48)
    return !1;
  var i = um(e, n);
  if (i === !1 || i + n.place !== e.length || e[n.place++] !== 2)
    return !1;
  var s = um(e, n);
  if (s === !1 || e[n.place] & 128)
    return !1;
  var o = e.slice(n.place, s + n.place);
  if (n.place += s, e[n.place++] !== 2)
    return !1;
  var a = um(e, n);
  if (a === !1 || e.length !== a + n.place || e[n.place] & 128)
    return !1;
  var u = e.slice(n.place, a + n.place);
  if (o[0] === 0)
    if (o[1] & 128)
      o = o.slice(1);
    else
      return !1;
  if (u[0] === 0)
    if (u[1] & 128)
      u = u.slice(1);
    else
      return !1;
  return this.r = new o0(o), this.s = new o0(u), this.recoveryParam = null, !0;
};
function fm(t, e) {
  if (e < 128) {
    t.push(e);
    return;
  }
  var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
  for (t.push(r | 128); --r; )
    t.push(e >>> (r << 3) & 255);
  t.push(e);
}
X0.prototype.toDER = function(e) {
  var r = this.r.toArray(), n = this.s.toArray();
  for (r[0] & 128 && (r = [0].concat(r)), n[0] & 128 && (n = [0].concat(n)), r = Tx(r), n = Tx(n); !n[0] && !(n[1] & 128); )
    n = n.slice(1);
  var i = [2];
  fm(i, r.length), i = i.concat(r), i.push(2), fm(i, n.length);
  var s = i.concat(n), o = [48];
  return fm(o, s.length), o = o.concat(s), tb.encode(o, e);
};
var So = qo, P8 = iq, lq = Fi, lm = J0, hq = _8, M8 = lq.assert, rb = aq, Z0 = uq;
function es(t) {
  if (!(this instanceof es))
    return new es(t);
  typeof t == "string" && (M8(
    Object.prototype.hasOwnProperty.call(lm, t),
    "Unknown curve " + t
  ), t = lm[t]), t instanceof lm.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
}
var dq = es;
es.prototype.keyPair = function(e) {
  return new rb(this, e);
};
es.prototype.keyFromPrivate = function(e, r) {
  return rb.fromPrivate(this, e, r);
};
es.prototype.keyFromPublic = function(e, r) {
  return rb.fromPublic(this, e, r);
};
es.prototype.genKeyPair = function(e) {
  e || (e = {});
  for (var r = new P8({
    hash: this.hash,
    pers: e.pers,
    persEnc: e.persEnc || "utf8",
    entropy: e.entropy || hq(this.hash.hmacStrength),
    entropyEnc: e.entropy && e.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), n = this.n.byteLength(), i = this.n.sub(new So(2)); ; ) {
    var s = new So(r.generate(n));
    if (!(s.cmp(i) > 0))
      return s.iaddn(1), this.keyFromPrivate(s);
  }
};
es.prototype._truncateToN = function(e, r, n) {
  var i;
  if (So.isBN(e) || typeof e == "number")
    e = new So(e, 16), i = e.byteLength();
  else if (typeof e == "object")
    i = e.length, e = new So(e, 16);
  else {
    var s = e.toString();
    i = s.length + 1 >>> 1, e = new So(s, 16);
  }
  typeof n != "number" && (n = i * 8);
  var o = n - this.n.bitLength();
  return o > 0 && (e = e.ushrn(o)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
};
es.prototype.sign = function(e, r, n, i) {
  typeof n == "object" && (i = n, n = null), i || (i = {}), r = this.keyFromPrivate(r, n), e = this._truncateToN(e, !1, i.msgBitLength);
  for (var s = this.n.byteLength(), o = r.getPrivate().toArray("be", s), a = e.toArray("be", s), u = new P8({
    hash: this.hash,
    entropy: o,
    nonce: a,
    pers: i.pers,
    persEnc: i.persEnc || "utf8"
  }), l = this.n.sub(new So(1)), d = 0; ; d++) {
    var p = i.k ? i.k(d) : new So(u.generate(this.n.byteLength()));
    if (p = this._truncateToN(p, !0), !(p.cmpn(1) <= 0 || p.cmp(l) >= 0)) {
      var w = this.g.mul(p);
      if (!w.isInfinity()) {
        var P = w.getX(), A = P.umod(this.n);
        if (A.cmpn(0) !== 0) {
          var N = p.invm(this.n).mul(A.mul(r.getPrivate()).iadd(e));
          if (N = N.umod(this.n), N.cmpn(0) !== 0) {
            var L = (w.getY().isOdd() ? 1 : 0) | (P.cmp(A) !== 0 ? 2 : 0);
            return i.canonical && N.cmp(this.nh) > 0 && (N = this.n.sub(N), L ^= 1), new Z0({ r: A, s: N, recoveryParam: L });
          }
        }
      }
    }
  }
};
es.prototype.verify = function(e, r, n, i, s) {
  s || (s = {}), e = this._truncateToN(e, !1, s.msgBitLength), n = this.keyFromPublic(n, i), r = new Z0(r, "hex");
  var o = r.r, a = r.s;
  if (o.cmpn(1) < 0 || o.cmp(this.n) >= 0 || a.cmpn(1) < 0 || a.cmp(this.n) >= 0)
    return !1;
  var u = a.invm(this.n), l = u.mul(e).umod(this.n), d = u.mul(o).umod(this.n), p;
  return this.curve._maxwellTrick ? (p = this.g.jmulAdd(l, n.getPublic(), d), p.isInfinity() ? !1 : p.eqXToP(o)) : (p = this.g.mulAdd(l, n.getPublic(), d), p.isInfinity() ? !1 : p.getX().umod(this.n).cmp(o) === 0);
};
es.prototype.recoverPubKey = function(t, e, r, n) {
  M8((3 & r) === r, "The recovery param is more than two bits"), e = new Z0(e, n);
  var i = this.n, s = new So(t), o = e.r, a = e.s, u = r & 1, l = r >> 1;
  if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && l)
    throw new Error("Unable to find sencond key candinate");
  l ? o = this.curve.pointFromX(o.add(this.curve.n), u) : o = this.curve.pointFromX(o, u);
  var d = e.r.invm(i), p = i.sub(s).mul(d).umod(i), w = a.mul(d).umod(i);
  return this.g.mulAdd(p, o, w);
};
es.prototype.getKeyRecoveryParam = function(t, e, r, n) {
  if (e = new Z0(e, n), e.recoveryParam !== null)
    return e.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var s;
    try {
      s = this.recoverPubKey(t, e, i);
    } catch {
      continue;
    }
    if (s.eq(r))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var Jl = Fi, I8 = Jl.assert, Rx = Jl.parseBytes, Uu = Jl.cachedProperty;
function On(t, e) {
  this.eddsa = t, this._secret = Rx(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = Rx(e.pub);
}
On.fromPublic = function(e, r) {
  return r instanceof On ? r : new On(e, { pub: r });
};
On.fromSecret = function(e, r) {
  return r instanceof On ? r : new On(e, { secret: r });
};
On.prototype.secret = function() {
  return this._secret;
};
Uu(On, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
Uu(On, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
Uu(On, "privBytes", function() {
  var e = this.eddsa, r = this.hash(), n = e.encodingLength - 1, i = r.slice(0, e.encodingLength);
  return i[0] &= 248, i[n] &= 127, i[n] |= 64, i;
});
Uu(On, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
Uu(On, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
Uu(On, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
On.prototype.sign = function(e) {
  return I8(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
};
On.prototype.verify = function(e, r) {
  return this.eddsa.verify(e, r, this);
};
On.prototype.getSecret = function(e) {
  return I8(this._secret, "KeyPair is public only"), Jl.encode(this.secret(), e);
};
On.prototype.getPublic = function(e) {
  return Jl.encode(this.pubBytes(), e);
};
var pq = On, gq = qo, Q0 = Fi, Dx = Q0.assert, ep = Q0.cachedProperty, mq = Q0.parseBytes;
function xc(t, e) {
  this.eddsa = t, typeof e != "object" && (e = mq(e)), Array.isArray(e) && (Dx(e.length === t.encodingLength * 2, "Signature has invalid size"), e = {
    R: e.slice(0, t.encodingLength),
    S: e.slice(t.encodingLength)
  }), Dx(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof gq && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
}
ep(xc, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
ep(xc, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
ep(xc, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
ep(xc, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
xc.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
xc.prototype.toHex = function() {
  return Q0.encode(this.toBytes(), "hex").toUpperCase();
};
var vq = xc, bq = Kl, yq = J0, Su = Fi, wq = Su.assert, C8 = Su.parseBytes, T8 = pq, Ox = vq;
function _i(t) {
  if (wq(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof _i))
    return new _i(t);
  t = yq[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = bq.sha512;
}
var xq = _i;
_i.prototype.sign = function(e, r) {
  e = C8(e);
  var n = this.keyFromSecret(r), i = this.hashInt(n.messagePrefix(), e), s = this.g.mul(i), o = this.encodePoint(s), a = this.hashInt(o, n.pubBytes(), e).mul(n.priv()), u = i.add(a).umod(this.curve.n);
  return this.makeSignature({ R: s, S: u, Rencoded: o });
};
_i.prototype.verify = function(e, r, n) {
  if (e = C8(e), r = this.makeSignature(r), r.S().gte(r.eddsa.curve.n) || r.S().isNeg())
    return !1;
  var i = this.keyFromPublic(n), s = this.hashInt(r.Rencoded(), i.pubBytes(), e), o = this.g.mul(r.S()), a = r.R().add(i.pub().mul(s));
  return a.eq(o);
};
_i.prototype.hashInt = function() {
  for (var e = this.hash(), r = 0; r < arguments.length; r++)
    e.update(arguments[r]);
  return Su.intFromLE(e.digest()).umod(this.curve.n);
};
_i.prototype.keyFromPublic = function(e) {
  return T8.fromPublic(this, e);
};
_i.prototype.keyFromSecret = function(e) {
  return T8.fromSecret(this, e);
};
_i.prototype.makeSignature = function(e) {
  return e instanceof Ox ? e : new Ox(this, e);
};
_i.prototype.encodePoint = function(e) {
  var r = e.getY().toArray("le", this.encodingLength);
  return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r;
};
_i.prototype.decodePoint = function(e) {
  e = Su.parseBytes(e);
  var r = e.length - 1, n = e.slice(0, r).concat(e[r] & -129), i = (e[r] & 128) !== 0, s = Su.intFromLE(n);
  return this.curve.pointFromY(s, i);
};
_i.prototype.encodeInt = function(e) {
  return e.toArray("le", this.encodingLength);
};
_i.prototype.decodeInt = function(e) {
  return Su.intFromLE(e);
};
_i.prototype.isPoint = function(e) {
  return e instanceof this.pointClass;
};
(function(t) {
  var e = t;
  e.version = Kj.version, e.utils = Fi, e.rand = _8, e.curve = Qv, e.curves = J0, e.ec = dq, e.eddsa = xq;
})(x8);
const _q = { waku: { publish: "waku_publish", batchPublish: "waku_batchPublish", subscribe: "waku_subscribe", batchSubscribe: "waku_batchSubscribe", subscription: "waku_subscription", unsubscribe: "waku_unsubscribe", batchUnsubscribe: "waku_batchUnsubscribe", batchFetchMessages: "waku_batchFetchMessages" }, irn: { publish: "irn_publish", batchPublish: "irn_batchPublish", subscribe: "irn_subscribe", batchSubscribe: "irn_batchSubscribe", subscription: "irn_subscription", unsubscribe: "irn_unsubscribe", batchUnsubscribe: "irn_batchUnsubscribe", batchFetchMessages: "irn_batchFetchMessages" }, iridium: { publish: "iridium_publish", batchPublish: "iridium_batchPublish", subscribe: "iridium_subscribe", batchSubscribe: "iridium_batchSubscribe", subscription: "iridium_subscription", unsubscribe: "iridium_unsubscribe", batchUnsubscribe: "iridium_batchUnsubscribe", batchFetchMessages: "iridium_batchFetchMessages" } }, Eq = ":";
function lu(t) {
  const [e, r] = t.split(Eq);
  return { namespace: e, reference: r };
}
function R8(t, e) {
  return t.includes(":") ? [t] : e.chains || [];
}
var Sq = Object.defineProperty, Nx = Object.getOwnPropertySymbols, Aq = Object.prototype.hasOwnProperty, Pq = Object.prototype.propertyIsEnumerable, Lx = (t, e, r) => e in t ? Sq(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, kx = (t, e) => {
  for (var r in e || (e = {})) Aq.call(e, r) && Lx(t, r, e[r]);
  if (Nx) for (var r of Nx(e)) Pq.call(e, r) && Lx(t, r, e[r]);
  return t;
};
const Mq = "ReactNative", Ri = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, Iq = "js";
function a0() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function ju() {
  return !Wl() && !!Fv() && navigator.product === Mq;
}
function Xl() {
  return !a0() && !!Fv() && !!Wl();
}
function Zl() {
  return ju() ? Ri.reactNative : a0() ? Ri.node : Xl() ? Ri.browser : Ri.unknown;
}
function Cq() {
  var t;
  try {
    return ju() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (t = global.Application) == null ? void 0 : t.applicationId : void 0;
  } catch {
    return;
  }
}
function Tq(t, e) {
  let r = wl.parse(t);
  return r = kx(kx({}, r), e), t = wl.stringify(r), t;
}
function D8() {
  return q4() || { name: "", description: "", url: "", icons: [""] };
}
function Rq() {
  if (Zl() === Ri.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: r, Version: n } = global.Platform;
    return [r, n].join("-");
  }
  const t = zF();
  if (t === null) return "unknown";
  const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
  return t.type === "browser" ? [e, t.name, t.version].join("-") : [e, t.version].join("-");
}
function Dq() {
  var t;
  const e = Zl();
  return e === Ri.browser ? [e, ((t = j4()) == null ? void 0 : t.host) || "unknown"].join(":") : e;
}
function O8(t, e, r) {
  const n = Rq(), i = Dq();
  return [[t, e].join("-"), [Iq, r].join("-"), n, i].join("/");
}
function Oq({ protocol: t, version: e, relayUrl: r, sdkVersion: n, auth: i, projectId: s, useOnCloseEvent: o, bundleId: a }) {
  const u = r.split("?"), l = O8(t, e, n), d = { auth: i, ua: l, projectId: s, useOnCloseEvent: o, origin: a || void 0 }, p = Tq(u[1] || "", d);
  return u[0] + "?" + p;
}
function tc(t, e) {
  return t.filter((r) => e.includes(r)).length === t.length;
}
function N8(t) {
  return Object.fromEntries(t.entries());
}
function L8(t) {
  return new Map(Object.entries(t));
}
function Va(t = mt.FIVE_MINUTES, e) {
  const r = mt.toMiliseconds(t || mt.FIVE_MINUTES);
  let n, i, s;
  return { resolve: (o) => {
    s && n && (clearTimeout(s), n(o));
  }, reject: (o) => {
    s && i && (clearTimeout(s), i(o));
  }, done: () => new Promise((o, a) => {
    s = setTimeout(() => {
      a(new Error(e));
    }, r), n = o, i = a;
  }) };
}
function hu(t, e, r) {
  return new Promise(async (n, i) => {
    const s = setTimeout(() => i(new Error(r)), e);
    try {
      const o = await t;
      n(o);
    } catch (o) {
      i(o);
    }
    clearTimeout(s);
  });
}
function k8(t, e) {
  if (typeof e == "string" && e.startsWith(`${t}:`)) return e;
  if (t.toLowerCase() === "topic") {
    if (typeof e != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (t.toLowerCase() === "id") {
    if (typeof e != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${t}`);
}
function Nq(t) {
  return k8("topic", t);
}
function Lq(t) {
  return k8("id", t);
}
function $8(t) {
  const [e, r] = t.split(":"), n = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof r == "string") n.topic = r;
  else if (e === "id" && Number.isInteger(Number(r))) n.id = Number(r);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${r}`);
  return n;
}
function En(t, e) {
  return mt.fromMiliseconds(Date.now() + mt.toMiliseconds(t));
}
function aa(t) {
  return Date.now() >= mt.toMiliseconds(t);
}
function br(t, e) {
  return `${t}${e ? `:${e}` : ""}`;
}
function Md(t = [], e = []) {
  return [.../* @__PURE__ */ new Set([...t, ...e])];
}
async function kq({ id: t, topic: e, wcDeepLink: r }) {
  var n;
  try {
    if (!r) return;
    const i = typeof r == "string" ? JSON.parse(r) : r, s = i == null ? void 0 : i.href;
    if (typeof s != "string") return;
    const o = $q(s, t, e), a = Zl();
    if (a === Ri.browser) {
      if (!((n = Wl()) != null && n.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      o.startsWith("https://") || o.startsWith("http://") ? window.open(o, "_blank", "noreferrer noopener") : window.open(o, Bq() ? "_blank" : "_self", "noreferrer noopener");
    } else a === Ri.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(o);
  } catch (i) {
    console.error(i);
  }
}
function $q(t, e, r) {
  const n = `requestId=${e}&sessionTopic=${r}`;
  t.endsWith("/") && (t = t.slice(0, -1));
  let i = `${t}`;
  if (t.startsWith("https://t.me")) {
    const s = t.includes("?") ? "&startapp=" : "?startapp=";
    i = `${i}${s}${Uq(n, !0)}`;
  } else i = `${i}/wc?${n}`;
  return i;
}
async function Fq(t, e) {
  let r = "";
  try {
    if (Xl() && (r = localStorage.getItem(e), r)) return r;
    r = await t.getItem(e);
  } catch (n) {
    console.error(n);
  }
  return r;
}
function $x(t, e) {
  if (!t.includes(e)) return null;
  const r = t.split(/([&,?,=])/), n = r.indexOf(e);
  return r[n + 2];
}
function Fx() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t) => {
    const e = Math.random() * 16 | 0;
    return (t === "x" ? e : e & 3 | 8).toString(16);
  });
}
function nb() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function Bq() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function Uq(t, e = !1) {
  const r = Buffer.from(t).toString("base64");
  return e ? r.replace(/[=]/g, "") : r;
}
function F8(t) {
  return Buffer.from(t, "base64").toString("utf-8");
}
const jq = "https://rpc.walletconnect.org/v1";
async function qq(t, e, r, n, i, s) {
  switch (r.t) {
    case "eip191":
      return zq(t, e, r.s);
    case "eip1271":
      return await Hq(t, e, r.s, n, i, s);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${r.t}`);
  }
}
function zq(t, e, r) {
  return bj(V4(e), r).toLowerCase() === t.toLowerCase();
}
async function Hq(t, e, r, n, i, s) {
  const o = lu(n);
  if (!o.namespace || !o.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${n}`);
  try {
    const a = "0x1626ba7e", u = "0000000000000000000000000000000000000000000000000000000000000040", l = "0000000000000000000000000000000000000000000000000000000000000041", d = r.substring(2), p = V4(e).substring(2), w = a + p + u + l + d, P = await fetch(`${s || jq}/?chainId=${n}&projectId=${i}`, { method: "POST", body: JSON.stringify({ id: Wq(), jsonrpc: "2.0", method: "eth_call", params: [{ to: t, data: w }, "latest"] }) }), { result: A } = await P.json();
    return A ? A.slice(0, a.length).toLowerCase() === a.toLowerCase() : !1;
  } catch (a) {
    return console.error("isValidEip1271Signature: ", a), !1;
  }
}
function Wq() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
var Kq = Object.defineProperty, Vq = Object.defineProperties, Gq = Object.getOwnPropertyDescriptors, Bx = Object.getOwnPropertySymbols, Yq = Object.prototype.hasOwnProperty, Jq = Object.prototype.propertyIsEnumerable, Ux = (t, e, r) => e in t ? Kq(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Xq = (t, e) => {
  for (var r in e || (e = {})) Yq.call(e, r) && Ux(t, r, e[r]);
  if (Bx) for (var r of Bx(e)) Jq.call(e, r) && Ux(t, r, e[r]);
  return t;
}, Zq = (t, e) => Vq(t, Gq(e));
const Qq = "did:pkh:", ib = (t) => t == null ? void 0 : t.split(":"), ez = (t) => {
  const e = t && ib(t);
  if (e) return t.includes(Qq) ? e[3] : e[1];
}, M1 = (t) => {
  const e = t && ib(t);
  if (e) return e[2] + ":" + e[3];
}, c0 = (t) => {
  const e = t && ib(t);
  if (e) return e.pop();
};
async function jx(t) {
  const { cacao: e, projectId: r } = t, { s: n, p: i } = e, s = B8(i, i.iss), o = c0(i.iss);
  return await qq(o, s, n, M1(i.iss), r);
}
const B8 = (t, e) => {
  const r = `${t.domain} wants you to sign in with your Ethereum account:`, n = c0(e);
  if (!t.aud && !t.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let i = t.statement || void 0;
  const s = `URI: ${t.aud || t.uri}`, o = `Version: ${t.version}`, a = `Chain ID: ${ez(e)}`, u = `Nonce: ${t.nonce}`, l = `Issued At: ${t.iat}`, d = t.exp ? `Expiration Time: ${t.exp}` : void 0, p = t.nbf ? `Not Before: ${t.nbf}` : void 0, w = t.requestId ? `Request ID: ${t.requestId}` : void 0, P = t.resources ? `Resources:${t.resources.map((N) => `
- ${N}`).join("")}` : void 0, A = Id(t.resources);
  if (A) {
    const N = xl(A);
    i = uz(i, N);
  }
  return [r, n, "", i, "", s, o, a, u, l, d, p, w, P].filter((N) => N != null).join(`
`);
};
function tz(t) {
  return Buffer.from(JSON.stringify(t)).toString("base64");
}
function rz(t) {
  return JSON.parse(Buffer.from(t, "base64").toString("utf-8"));
}
function lc(t) {
  if (!t) throw new Error("No recap provided, value is undefined");
  if (!t.att) throw new Error("No `att` property found");
  const e = Object.keys(t.att);
  if (!(e != null && e.length)) throw new Error("No resources found in `att` property");
  e.forEach((r) => {
    const n = t.att[r];
    if (Array.isArray(n)) throw new Error(`Resource must be an object: ${r}`);
    if (typeof n != "object") throw new Error(`Resource must be an object: ${r}`);
    if (!Object.keys(n).length) throw new Error(`Resource object is empty: ${r}`);
    Object.keys(n).forEach((i) => {
      const s = n[i];
      if (!Array.isArray(s)) throw new Error(`Ability limits ${i} must be an array of objects, found: ${s}`);
      if (!s.length) throw new Error(`Value of ${i} is empty array, must be an array with objects`);
      s.forEach((o) => {
        if (typeof o != "object") throw new Error(`Ability limits (${i}) must be an array of objects, found: ${o}`);
      });
    });
  });
}
function nz(t, e, r, n = {}) {
  return r == null || r.sort((i, s) => i.localeCompare(s)), { att: { [t]: iz(e, r, n) } };
}
function iz(t, e, r = {}) {
  e = e == null ? void 0 : e.sort((i, s) => i.localeCompare(s));
  const n = e.map((i) => ({ [`${t}/${i}`]: [r] }));
  return Object.assign({}, ...n);
}
function U8(t) {
  return lc(t), `urn:recap:${tz(t).replace(/=/g, "")}`;
}
function xl(t) {
  const e = rz(t.replace("urn:recap:", ""));
  return lc(e), e;
}
function sz(t, e, r) {
  const n = nz(t, e, r);
  return U8(n);
}
function oz(t) {
  return t && t.includes("urn:recap:");
}
function az(t, e) {
  const r = xl(t), n = xl(e), i = cz(r, n);
  return U8(i);
}
function cz(t, e) {
  lc(t), lc(e);
  const r = Object.keys(t.att).concat(Object.keys(e.att)).sort((i, s) => i.localeCompare(s)), n = { att: {} };
  return r.forEach((i) => {
    var s, o;
    Object.keys(((s = t.att) == null ? void 0 : s[i]) || {}).concat(Object.keys(((o = e.att) == null ? void 0 : o[i]) || {})).sort((a, u) => a.localeCompare(u)).forEach((a) => {
      var u, l;
      n.att[i] = Zq(Xq({}, n.att[i]), { [a]: ((u = t.att[i]) == null ? void 0 : u[a]) || ((l = e.att[i]) == null ? void 0 : l[a]) });
    });
  }), n;
}
function uz(t = "", e) {
  lc(e);
  const r = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (t.includes(r)) return t;
  const n = [];
  let i = 0;
  Object.keys(e.att).forEach((a) => {
    const u = Object.keys(e.att[a]).map((p) => ({ ability: p.split("/")[0], action: p.split("/")[1] }));
    u.sort((p, w) => p.action.localeCompare(w.action));
    const l = {};
    u.forEach((p) => {
      l[p.ability] || (l[p.ability] = []), l[p.ability].push(p.action);
    });
    const d = Object.keys(l).map((p) => (i++, `(${i}) '${p}': '${l[p].join("', '")}' for '${a}'.`));
    n.push(d.join(", ").replace(".,", "."));
  });
  const s = n.join(" "), o = `${r}${s}`;
  return `${t ? t + " " : ""}${o}`;
}
function qx(t) {
  var e;
  const r = xl(t);
  lc(r);
  const n = (e = r.att) == null ? void 0 : e.eip155;
  return n ? Object.keys(n).map((i) => i.split("/")[1]) : [];
}
function zx(t) {
  const e = xl(t);
  lc(e);
  const r = [];
  return Object.values(e.att).forEach((n) => {
    Object.values(n).forEach((i) => {
      var s;
      (s = i == null ? void 0 : i[0]) != null && s.chains && r.push(i[0].chains);
    });
  }), [...new Set(r.flat())];
}
function Id(t) {
  if (!t) return;
  const e = t == null ? void 0 : t[t.length - 1];
  return oz(e) ? e : void 0;
}
const j8 = "base10", oi = "base16", la = "base64pad", Sf = "base64url", Ql = "utf8", q8 = 0, Io = 1, eh = 2, fz = 0, Hx = 1, jf = 12, sb = 32;
function lz() {
  const t = Yv.generateKeyPair();
  return { privateKey: Dn(t.secretKey, oi), publicKey: Dn(t.publicKey, oi) };
}
function I1() {
  const t = Pa.randomBytes(sb);
  return Dn(t, oi);
}
function hz(t, e) {
  const r = Yv.sharedKey(Rn(t, oi), Rn(e, oi), !0), n = new Rj(Gl.SHA256, r).expand(sb);
  return Dn(n, oi);
}
function Cd(t) {
  const e = Gl.hash(Rn(t, oi));
  return Dn(e, oi);
}
function wo(t) {
  const e = Gl.hash(Rn(t, Ql));
  return Dn(e, oi);
}
function z8(t) {
  return Rn(`${t}`, j8);
}
function hc(t) {
  return Number(Dn(t, j8));
}
function dz(t) {
  const e = z8(typeof t.type < "u" ? t.type : q8);
  if (hc(e) === Io && typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const r = typeof t.senderPublicKey < "u" ? Rn(t.senderPublicKey, oi) : void 0, n = typeof t.iv < "u" ? Rn(t.iv, oi) : Pa.randomBytes(jf), i = new Vv.ChaCha20Poly1305(Rn(t.symKey, oi)).seal(n, Rn(t.message, Ql));
  return H8({ type: e, sealed: i, iv: n, senderPublicKey: r, encoding: t.encoding });
}
function pz(t, e) {
  const r = z8(eh), n = Pa.randomBytes(jf), i = Rn(t, Ql);
  return H8({ type: r, sealed: i, iv: n, encoding: e });
}
function gz(t) {
  const e = new Vv.ChaCha20Poly1305(Rn(t.symKey, oi)), { sealed: r, iv: n } = _l({ encoded: t.encoded, encoding: t == null ? void 0 : t.encoding }), i = e.open(n, r);
  if (i === null) throw new Error("Failed to decrypt");
  return Dn(i, Ql);
}
function mz(t, e) {
  const { sealed: r } = _l({ encoded: t, encoding: e });
  return Dn(r, Ql);
}
function H8(t) {
  const { encoding: e = la } = t;
  if (hc(t.type) === eh) return Dn(Ed([t.type, t.sealed]), e);
  if (hc(t.type) === Io) {
    if (typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return Dn(Ed([t.type, t.senderPublicKey, t.iv, t.sealed]), e);
  }
  return Dn(Ed([t.type, t.iv, t.sealed]), e);
}
function _l(t) {
  const { encoded: e, encoding: r = la } = t, n = Rn(e, r), i = n.slice(fz, Hx), s = Hx;
  if (hc(i) === Io) {
    const l = s + sb, d = l + jf, p = n.slice(s, l), w = n.slice(l, d), P = n.slice(d);
    return { type: i, sealed: P, iv: w, senderPublicKey: p };
  }
  if (hc(i) === eh) {
    const l = n.slice(s), d = Pa.randomBytes(jf);
    return { type: i, sealed: l, iv: d };
  }
  const o = s + jf, a = n.slice(s, o), u = n.slice(o);
  return { type: i, sealed: u, iv: a };
}
function vz(t, e) {
  const r = _l({ encoded: t, encoding: e == null ? void 0 : e.encoding });
  return W8({ type: hc(r.type), senderPublicKey: typeof r.senderPublicKey < "u" ? Dn(r.senderPublicKey, oi) : void 0, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey });
}
function W8(t) {
  const e = (t == null ? void 0 : t.type) || q8;
  if (e === Io) {
    if (typeof (t == null ? void 0 : t.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (t == null ? void 0 : t.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: t == null ? void 0 : t.senderPublicKey, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey };
}
function Wx(t) {
  return t.type === Io && typeof t.senderPublicKey == "string" && typeof t.receiverPublicKey == "string";
}
function Kx(t) {
  return t.type === eh;
}
function bz(t) {
  return new x8.ec("p256").keyFromPublic({ x: Buffer.from(t.x, "base64").toString("hex"), y: Buffer.from(t.y, "base64").toString("hex") }, "hex");
}
function yz(t) {
  let e = t.replace(/-/g, "+").replace(/_/g, "/");
  const r = e.length % 4;
  return r > 0 && (e += "=".repeat(4 - r)), e;
}
function wz(t) {
  return Buffer.from(yz(t), "base64");
}
function xz(t, e) {
  const [r, n, i] = t.split("."), s = wz(i);
  if (s.length !== 64) throw new Error("Invalid signature length");
  const o = s.slice(0, 32).toString("hex"), a = s.slice(32, 64).toString("hex"), u = `${r}.${n}`, l = new Gl.SHA256().update(Buffer.from(u)).digest(), d = bz(e), p = Buffer.from(l).toString("hex");
  if (!d.verify(p, { r: o, s: a })) throw new Error("Invalid signature");
  return v1(t).payload;
}
const _z = "irn";
function C1(t) {
  return (t == null ? void 0 : t.relay) || { protocol: _z };
}
function $f(t) {
  const e = _q[t];
  if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${t}`);
  return e;
}
var Ez = Object.defineProperty, Sz = Object.defineProperties, Az = Object.getOwnPropertyDescriptors, Vx = Object.getOwnPropertySymbols, Pz = Object.prototype.hasOwnProperty, Mz = Object.prototype.propertyIsEnumerable, Gx = (t, e, r) => e in t ? Ez(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Yx = (t, e) => {
  for (var r in e || (e = {})) Pz.call(e, r) && Gx(t, r, e[r]);
  if (Vx) for (var r of Vx(e)) Mz.call(e, r) && Gx(t, r, e[r]);
  return t;
}, Iz = (t, e) => Sz(t, Az(e));
function Cz(t, e = "-") {
  const r = {}, n = "relay" + e;
  return Object.keys(t).forEach((i) => {
    if (i.startsWith(n)) {
      const s = i.replace(n, ""), o = t[i];
      r[s] = o;
    }
  }), r;
}
function Jx(t) {
  if (!t.includes("wc:")) {
    const u = F8(t);
    u != null && u.includes("wc:") && (t = u);
  }
  t = t.includes("wc://") ? t.replace("wc://", "") : t, t = t.includes("wc:") ? t.replace("wc:", "") : t;
  const e = t.indexOf(":"), r = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0, n = t.substring(0, e), i = t.substring(e + 1, r).split("@"), s = typeof r < "u" ? t.substring(r) : "", o = wl.parse(s), a = typeof o.methods == "string" ? o.methods.split(",") : void 0;
  return { protocol: n, topic: Tz(i[0]), version: parseInt(i[1], 10), symKey: o.symKey, relay: Cz(o), methods: a, expiryTimestamp: o.expiryTimestamp ? parseInt(o.expiryTimestamp, 10) : void 0 };
}
function Tz(t) {
  return t.startsWith("//") ? t.substring(2) : t;
}
function Rz(t, e = "-") {
  const r = "relay", n = {};
  return Object.keys(t).forEach((i) => {
    const s = r + e + i;
    t[i] && (n[s] = t[i]);
  }), n;
}
function Xx(t) {
  return `${t.protocol}:${t.topic}@${t.version}?` + wl.stringify(Yx(Iz(Yx({ symKey: t.symKey }, Rz(t.relay)), { expiryTimestamp: t.expiryTimestamp }), t.methods ? { methods: t.methods.join(",") } : {}));
}
function ud(t, e, r) {
  return `${t}?wc_ev=${r}&topic=${e}`;
}
function qu(t) {
  const e = [];
  return t.forEach((r) => {
    const [n, i] = r.split(":");
    e.push(`${n}:${i}`);
  }), e;
}
function Dz(t) {
  const e = [];
  return Object.values(t).forEach((r) => {
    e.push(...qu(r.accounts));
  }), e;
}
function Oz(t, e) {
  const r = [];
  return Object.values(t).forEach((n) => {
    qu(n.accounts).includes(e) && r.push(...n.methods);
  }), r;
}
function Nz(t, e) {
  const r = [];
  return Object.values(t).forEach((n) => {
    qu(n.accounts).includes(e) && r.push(...n.events);
  }), r;
}
function ob(t) {
  return t.includes(":");
}
function Ff(t) {
  return ob(t) ? t.split(":")[0] : t;
}
function Lz(t) {
  const e = {};
  return t == null || t.forEach((r) => {
    const [n, i] = r.split(":");
    e[n] || (e[n] = { accounts: [], chains: [], events: [] }), e[n].accounts.push(r), e[n].chains.push(`${n}:${i}`);
  }), e;
}
function Zx(t, e) {
  e = e.map((n) => n.replace("did:pkh:", ""));
  const r = Lz(e);
  for (const [n, i] of Object.entries(r)) i.methods ? i.methods = Md(i.methods, t) : i.methods = t, i.events = ["chainChanged", "accountsChanged"];
  return r;
}
const kz = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, $z = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function ft(t, e) {
  const { message: r, code: n } = $z[t];
  return { message: e ? `${r} ${e}` : r, code: n };
}
function Or(t, e) {
  const { message: r, code: n } = kz[t];
  return { message: e ? `${r} ${e}` : r, code: n };
}
function dc(t, e) {
  return !!Array.isArray(t);
}
function El(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;
}
function gi(t) {
  return typeof t > "u";
}
function dn(t, e) {
  return e && gi(t) ? !0 : typeof t == "string" && !!t.trim().length;
}
function ab(t, e) {
  return typeof t == "number" && !isNaN(t);
}
function Fz(t, e) {
  const { requiredNamespaces: r } = e, n = Object.keys(t.namespaces), i = Object.keys(r);
  let s = !0;
  return tc(i, n) ? (n.forEach((o) => {
    const { accounts: a, methods: u, events: l } = t.namespaces[o], d = qu(a), p = r[o];
    (!tc(R8(o, p), d) || !tc(p.methods, u) || !tc(p.events, l)) && (s = !1);
  }), s) : !1;
}
function u0(t) {
  return dn(t, !1) && t.includes(":") ? t.split(":").length === 2 : !1;
}
function Bz(t) {
  if (dn(t, !1) && t.includes(":")) {
    const e = t.split(":");
    if (e.length === 3) {
      const r = e[0] + ":" + e[1];
      return !!e[2] && u0(r);
    }
  }
  return !1;
}
function Uz(t) {
  function e(r) {
    try {
      return typeof new URL(r) < "u";
    } catch {
      return !1;
    }
  }
  try {
    if (dn(t, !1)) {
      if (e(t)) return !0;
      const r = F8(t);
      return e(r);
    }
  } catch {
  }
  return !1;
}
function jz(t) {
  var e;
  return (e = t == null ? void 0 : t.proposer) == null ? void 0 : e.publicKey;
}
function qz(t) {
  return t == null ? void 0 : t.topic;
}
function zz(t, e) {
  let r = null;
  return dn(t == null ? void 0 : t.publicKey, !1) || (r = ft("MISSING_OR_INVALID", `${e} controller public key should be a string`)), r;
}
function Qx(t) {
  let e = !0;
  return dc(t) ? t.length && (e = t.every((r) => dn(r, !1))) : e = !1, e;
}
function Hz(t, e, r) {
  let n = null;
  return dc(e) && e.length ? e.forEach((i) => {
    n || u0(i) || (n = Or("UNSUPPORTED_CHAINS", `${r}, chain ${i} should be a string and conform to "namespace:chainId" format`));
  }) : u0(t) || (n = Or("UNSUPPORTED_CHAINS", `${r}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), n;
}
function Wz(t, e, r) {
  let n = null;
  return Object.entries(t).forEach(([i, s]) => {
    if (n) return;
    const o = Hz(i, R8(i, s), `${e} ${r}`);
    o && (n = o);
  }), n;
}
function Kz(t, e) {
  let r = null;
  return dc(t) ? t.forEach((n) => {
    r || Bz(n) || (r = Or("UNSUPPORTED_ACCOUNTS", `${e}, account ${n} should be a string and conform to "namespace:chainId:address" format`));
  }) : r = Or("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), r;
}
function Vz(t, e) {
  let r = null;
  return Object.values(t).forEach((n) => {
    if (r) return;
    const i = Kz(n == null ? void 0 : n.accounts, `${e} namespace`);
    i && (r = i);
  }), r;
}
function Gz(t, e) {
  let r = null;
  return Qx(t == null ? void 0 : t.methods) ? Qx(t == null ? void 0 : t.events) || (r = Or("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : r = Or("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), r;
}
function K8(t, e) {
  let r = null;
  return Object.values(t).forEach((n) => {
    if (r) return;
    const i = Gz(n, `${e}, namespace`);
    i && (r = i);
  }), r;
}
function Yz(t, e, r) {
  let n = null;
  if (t && El(t)) {
    const i = K8(t, e);
    i && (n = i);
    const s = Wz(t, e, r);
    s && (n = s);
  } else n = ft("MISSING_OR_INVALID", `${e}, ${r} should be an object with data`);
  return n;
}
function hm(t, e) {
  let r = null;
  if (t && El(t)) {
    const n = K8(t, e);
    n && (r = n);
    const i = Vz(t, e);
    i && (r = i);
  } else r = ft("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return r;
}
function V8(t) {
  return dn(t.protocol, !0);
}
function Jz(t, e) {
  let r = !1;
  return t ? t && dc(t) && t.length && t.forEach((n) => {
    r = V8(n);
  }) : r = !0, r;
}
function Xz(t) {
  return typeof t == "number";
}
function pi(t) {
  return typeof t < "u" && typeof t !== null;
}
function Zz(t) {
  return !(!t || typeof t != "object" || !t.code || !ab(t.code) || !t.message || !dn(t.message, !1));
}
function Qz(t) {
  return !(gi(t) || !dn(t.method, !1));
}
function eH(t) {
  return !(gi(t) || gi(t.result) && gi(t.error) || !ab(t.id) || !dn(t.jsonrpc, !1));
}
function tH(t) {
  return !(gi(t) || !dn(t.name, !1));
}
function e3(t, e) {
  return !(!u0(e) || !Dz(t).includes(e));
}
function rH(t, e, r) {
  return dn(r, !1) ? Oz(t, e).includes(r) : !1;
}
function nH(t, e, r) {
  return dn(r, !1) ? Nz(t, e).includes(r) : !1;
}
function t3(t, e, r) {
  let n = null;
  const i = iH(t), s = sH(e), o = Object.keys(i), a = Object.keys(s), u = r3(Object.keys(t)), l = r3(Object.keys(e)), d = u.filter((p) => !l.includes(p));
  return d.length && (n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces keys don't satisfy requiredNamespaces.
      Required: ${d.toString()}
      Received: ${Object.keys(e).toString()}`)), tc(o, a) || (n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`)), Object.keys(e).forEach((p) => {
    if (!p.includes(":") || n) return;
    const w = qu(e[p].accounts);
    w.includes(p) || (n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces accounts don't satisfy namespace accounts for ${p}
        Required: ${p}
        Approved: ${w.toString()}`));
  }), o.forEach((p) => {
    n || (tc(i[p].methods, s[p].methods) ? tc(i[p].events, s[p].events) || (n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces events don't satisfy namespace events for ${p}`)) : n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces methods don't satisfy namespace methods for ${p}`));
  }), n;
}
function iH(t) {
  const e = {};
  return Object.keys(t).forEach((r) => {
    var n;
    r.includes(":") ? e[r] = t[r] : (n = t[r].chains) == null || n.forEach((i) => {
      e[i] = { methods: t[r].methods, events: t[r].events };
    });
  }), e;
}
function r3(t) {
  return [...new Set(t.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function sH(t) {
  const e = {};
  return Object.keys(t).forEach((r) => {
    if (r.includes(":")) e[r] = t[r];
    else {
      const n = qu(t[r].accounts);
      n == null || n.forEach((i) => {
        e[i] = { accounts: t[r].accounts.filter((s) => s.includes(`${i}:`)), methods: t[r].methods, events: t[r].events };
      });
    }
  }), e;
}
function oH(t, e) {
  return ab(t) && t <= e.max && t >= e.min;
}
function n3() {
  const t = Zl();
  return new Promise((e) => {
    switch (t) {
      case Ri.browser:
        e(aH());
        break;
      case Ri.reactNative:
        e(cH());
        break;
      case Ri.node:
        e(uH());
        break;
      default:
        e(!0);
    }
  });
}
function aH() {
  return Xl() && (navigator == null ? void 0 : navigator.onLine);
}
async function cH() {
  if (ju() && typeof global < "u" && global != null && global.NetInfo) {
    const t = await (global == null ? void 0 : global.NetInfo.fetch());
    return t == null ? void 0 : t.isConnected;
  }
  return !0;
}
function uH() {
  return !0;
}
function fH(t) {
  switch (Zl()) {
    case Ri.browser:
      lH(t);
      break;
    case Ri.reactNative:
      hH(t);
      break;
  }
}
function lH(t) {
  !ju() && Xl() && (window.addEventListener("online", () => t(!0)), window.addEventListener("offline", () => t(!1)));
}
function hH(t) {
  ju() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener((e) => t(e == null ? void 0 : e.isConnected)));
}
const dm = {};
class Af {
  static get(e) {
    return dm[e];
  }
  static set(e, r) {
    dm[e] = r;
  }
  static delete(e) {
    delete dm[e];
  }
}
const dH = "PARSE_ERROR", pH = "INVALID_REQUEST", gH = "METHOD_NOT_FOUND", mH = "INVALID_PARAMS", G8 = "INTERNAL_ERROR", cb = "SERVER_ERROR", vH = [-32700, -32600, -32601, -32602, -32603], qf = {
  [dH]: { code: -32700, message: "Parse error" },
  [pH]: { code: -32600, message: "Invalid Request" },
  [gH]: { code: -32601, message: "Method not found" },
  [mH]: { code: -32602, message: "Invalid params" },
  [G8]: { code: -32603, message: "Internal error" },
  [cb]: { code: -32e3, message: "Server error" }
}, Y8 = cb;
function bH(t) {
  return vH.includes(t);
}
function i3(t) {
  return Object.keys(qf).includes(t) ? qf[t] : qf[Y8];
}
function yH(t) {
  const e = Object.values(qf).find((r) => r.code === t);
  return e || qf[Y8];
}
function J8(t, e, r) {
  return t.message.includes("getaddrinfo ENOTFOUND") || t.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${r} RPC url at ${e}`) : t;
}
var X8 = {}, go = {}, s3;
function wH() {
  if (s3) return go;
  s3 = 1, Object.defineProperty(go, "__esModule", { value: !0 }), go.isBrowserCryptoAvailable = go.getSubtleCrypto = go.getBrowerCrypto = void 0;
  function t() {
    return (gn == null ? void 0 : gn.crypto) || (gn == null ? void 0 : gn.msCrypto) || {};
  }
  go.getBrowerCrypto = t;
  function e() {
    const n = t();
    return n.subtle || n.webkitSubtle;
  }
  go.getSubtleCrypto = e;
  function r() {
    return !!t() && !!e();
  }
  return go.isBrowserCryptoAvailable = r, go;
}
var mo = {}, o3;
function xH() {
  if (o3) return mo;
  o3 = 1, Object.defineProperty(mo, "__esModule", { value: !0 }), mo.isBrowser = mo.isNode = mo.isReactNative = void 0;
  function t() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  mo.isReactNative = t;
  function e() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
  }
  mo.isNode = e;
  function r() {
    return !t() && !e();
  }
  return mo.isBrowser = r, mo;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = Bl;
  e.__exportStar(wH(), t), e.__exportStar(xH(), t);
})(X8);
function ca(t = 3) {
  const e = Date.now() * Math.pow(10, t), r = Math.floor(Math.random() * Math.pow(10, t));
  return e + r;
}
function rc(t = 6) {
  return BigInt(ca(t));
}
function ha(t, e, r) {
  return {
    id: r || ca(),
    jsonrpc: "2.0",
    method: t,
    params: e
  };
}
function tp(t, e) {
  return {
    id: t,
    jsonrpc: "2.0",
    result: e
  };
}
function rp(t, e, r) {
  return {
    id: t,
    jsonrpc: "2.0",
    error: _H(e)
  };
}
function _H(t, e) {
  return typeof t > "u" ? i3(G8) : (typeof t == "string" && (t = Object.assign(Object.assign({}, i3(cb)), { message: t })), bH(t.code) && (t = yH(t.code)), t);
}
let EH = class {
}, SH = class extends EH {
  constructor() {
    super();
  }
}, AH = class extends SH {
  constructor(e) {
    super();
  }
};
const PH = "^https?:", MH = "^wss?:";
function IH(t) {
  const e = t.match(new RegExp(/^\w+:/, "gi"));
  if (!(!e || !e.length))
    return e[0];
}
function Z8(t, e) {
  const r = IH(t);
  return typeof r > "u" ? !1 : new RegExp(e).test(r);
}
function a3(t) {
  return Z8(t, PH);
}
function c3(t) {
  return Z8(t, MH);
}
function CH(t) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(t);
}
function Q8(t) {
  return typeof t == "object" && "id" in t && "jsonrpc" in t && t.jsonrpc === "2.0";
}
function ub(t) {
  return Q8(t) && "method" in t;
}
function np(t) {
  return Q8(t) && (Bs(t) || Zi(t));
}
function Bs(t) {
  return "result" in t;
}
function Zi(t) {
  return "error" in t;
}
let as = class extends AH {
  constructor(e) {
    super(e), this.events = new rs.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners();
  }
  async connect(e = this.connection) {
    await this.open(e);
  }
  async disconnect() {
    await this.close();
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async request(e, r) {
    return this.requestStrict(ha(e.method, e.params || [], e.id || rc().toString()), r);
  }
  async requestStrict(e, r) {
    return new Promise(async (n, i) => {
      if (!this.connection.connected) try {
        await this.open();
      } catch (s) {
        i(s);
      }
      this.events.on(`${e.id}`, (s) => {
        Zi(s) ? i(s.error) : n(s.result);
      });
      try {
        await this.connection.send(e, r);
      } catch (s) {
        i(s);
      }
    });
  }
  setConnection(e = this.connection) {
    return e;
  }
  onPayload(e) {
    this.events.emit("payload", e), np(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", { type: e.method, data: e.params });
  }
  onClose(e) {
    e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(e = this.connection) {
    this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (e) => this.onPayload(e)), this.connection.on("close", (e) => this.onClose(e)), this.connection.on("error", (e) => this.events.emit("error", e)), this.connection.on("register_error", (e) => this.onClose()), this.hasRegisteredEventListeners = !0);
  }
};
const TH = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"), RH = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", u3 = (t) => t.split("?")[0], f3 = 10, DH = TH();
let OH = class {
  constructor(e) {
    if (this.url = e, this.events = new rs.EventEmitter(), this.registering = !1, !c3(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, r) => {
      if (typeof this.socket > "u") {
        r(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n) => {
        this.onClose(n), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(ko(e));
    } catch (r) {
      this.onError(e.id, r);
    }
  }
  register(e = this.url) {
    if (!c3(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const r = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= r || this.events.listenerCount("open") >= r) && this.events.setMaxListeners(r + 1), new Promise((n, i) => {
        this.events.once("register_error", (s) => {
          this.resetMaxListeners(), i(s);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return i(new Error("WebSocket connection is missing or invalid"));
          n(this.socket);
        });
      });
    }
    return this.url = e, this.registering = !0, new Promise((r, n) => {
      const i = new URLSearchParams(e).get("origin"), s = X8.isReactNative() ? { headers: { origin: i } } : { rejectUnauthorized: !CH(e) }, o = new DH(e, [], s);
      RH() ? o.onerror = (a) => {
        const u = a;
        n(this.emitError(u.error));
      } : o.on("error", (a) => {
        n(this.emitError(a));
      }), o.onopen = () => {
        this.onOpen(o), r(o);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (r) => this.onPayload(r), e.onclose = (r) => this.onClose(r), this.socket = e, this.registering = !1, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const r = typeof e.data == "string" ? uc(e.data) : e.data;
    this.events.emit("payload", r);
  }
  onError(e, r) {
    const n = this.parseError(r), i = n.message || n.toString(), s = rp(e, i);
    this.events.emit("payload", s);
  }
  parseError(e, r = this.url) {
    return J8(e, u3(r), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > f3 && this.events.setMaxListeners(f3);
  }
  emitError(e) {
    const r = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${u3(this.url)}`));
    return this.events.emit("register_error", r), r;
  }
};
var f0 = { exports: {} };
f0.exports;
(function(t, e) {
  var r = 200, n = "__lodash_hash_undefined__", i = 1, s = 2, o = 9007199254740991, a = "[object Arguments]", u = "[object Array]", l = "[object AsyncFunction]", d = "[object Boolean]", p = "[object Date]", w = "[object Error]", P = "[object Function]", A = "[object GeneratorFunction]", N = "[object Map]", L = "[object Number]", F = "[object Null]", $ = "[object Object]", K = "[object Promise]", H = "[object Proxy]", V = "[object RegExp]", te = "[object Set]", R = "[object String]", W = "[object Symbol]", pe = "[object Undefined]", Ee = "[object WeakMap]", Y = "[object ArrayBuffer]", S = "[object DataView]", m = "[object Float32Array]", f = "[object Float64Array]", g = "[object Int8Array]", b = "[object Int16Array]", x = "[object Int32Array]", _ = "[object Uint8Array]", E = "[object Uint8ClampedArray]", v = "[object Uint16Array]", M = "[object Uint32Array]", I = /[\\^$.*+?()[\]{}|]/g, B = /^\[object .+?Constructor\]$/, ce = /^(?:0|[1-9]\d*)$/, D = {};
  D[m] = D[f] = D[g] = D[b] = D[x] = D[_] = D[E] = D[v] = D[M] = !0, D[a] = D[u] = D[Y] = D[d] = D[S] = D[p] = D[w] = D[P] = D[N] = D[L] = D[$] = D[V] = D[te] = D[R] = D[Ee] = !1;
  var oe = typeof gn == "object" && gn && gn.Object === Object && gn, Z = typeof self == "object" && self && self.Object === Object && self, J = oe || Z || Function("return this")(), Q = e && !e.nodeType && e, T = Q && !0 && t && !t.nodeType && t, X = T && T.exports === Q, re = X && oe.process, de = function() {
    try {
      return re && re.binding && re.binding("util");
    } catch {
    }
  }(), ie = de && de.isTypedArray;
  function ue(ae, ye) {
    for (var Ge = -1, Pt = ae == null ? 0 : ae.length, Ur = 0, rr = []; ++Ge < Pt; ) {
      var Kr = ae[Ge];
      ye(Kr, Ge, ae) && (rr[Ur++] = Kr);
    }
    return rr;
  }
  function ve(ae, ye) {
    for (var Ge = -1, Pt = ye.length, Ur = ae.length; ++Ge < Pt; )
      ae[Ur + Ge] = ye[Ge];
    return ae;
  }
  function Pe(ae, ye) {
    for (var Ge = -1, Pt = ae == null ? 0 : ae.length; ++Ge < Pt; )
      if (ye(ae[Ge], Ge, ae))
        return !0;
    return !1;
  }
  function De(ae, ye) {
    for (var Ge = -1, Pt = Array(ae); ++Ge < ae; )
      Pt[Ge] = ye(Ge);
    return Pt;
  }
  function Ce(ae) {
    return function(ye) {
      return ae(ye);
    };
  }
  function $e(ae, ye) {
    return ae.has(ye);
  }
  function Me(ae, ye) {
    return ae == null ? void 0 : ae[ye];
  }
  function Ne(ae) {
    var ye = -1, Ge = Array(ae.size);
    return ae.forEach(function(Pt, Ur) {
      Ge[++ye] = [Ur, Pt];
    }), Ge;
  }
  function Ke(ae, ye) {
    return function(Ge) {
      return ae(ye(Ge));
    };
  }
  function Le(ae) {
    var ye = -1, Ge = Array(ae.size);
    return ae.forEach(function(Pt) {
      Ge[++ye] = Pt;
    }), Ge;
  }
  var qe = Array.prototype, ze = Function.prototype, _e = Object.prototype, Ze = J["__core-js_shared__"], at = ze.toString, ke = _e.hasOwnProperty, Qe = function() {
    var ae = /[^.]+$/.exec(Ze && Ze.keys && Ze.keys.IE_PROTO || "");
    return ae ? "Symbol(src)_1." + ae : "";
  }(), tt = _e.toString, Ye = RegExp(
    "^" + at.call(ke).replace(I, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), dt = X ? J.Buffer : void 0, lt = J.Symbol, ct = J.Uint8Array, qt = _e.propertyIsEnumerable, Yt = qe.splice, Et = lt ? lt.toStringTag : void 0, Qt = Object.getOwnPropertySymbols, Jt = dt ? dt.isBuffer : void 0, Dt = Ke(Object.keys, Object), kt = yr(J, "DataView"), Ct = yr(J, "Map"), gt = yr(J, "Promise"), Rt = yr(J, "Set"), Nt = yr(J, "WeakMap"), vt = yr(Object, "create"), $t = no(kt), Bt = no(Ct), rt = no(gt), Ft = no(Rt), k = no(Nt), j = lt ? lt.prototype : void 0, z = j ? j.valueOf : void 0;
  function C(ae) {
    var ye = -1, Ge = ae == null ? 0 : ae.length;
    for (this.clear(); ++ye < Ge; ) {
      var Pt = ae[ye];
      this.set(Pt[0], Pt[1]);
    }
  }
  function G() {
    this.__data__ = vt ? vt(null) : {}, this.size = 0;
  }
  function U(ae) {
    var ye = this.has(ae) && delete this.__data__[ae];
    return this.size -= ye ? 1 : 0, ye;
  }
  function se(ae) {
    var ye = this.__data__;
    if (vt) {
      var Ge = ye[ae];
      return Ge === n ? void 0 : Ge;
    }
    return ke.call(ye, ae) ? ye[ae] : void 0;
  }
  function he(ae) {
    var ye = this.__data__;
    return vt ? ye[ae] !== void 0 : ke.call(ye, ae);
  }
  function xe(ae, ye) {
    var Ge = this.__data__;
    return this.size += this.has(ae) ? 0 : 1, Ge[ae] = vt && ye === void 0 ? n : ye, this;
  }
  C.prototype.clear = G, C.prototype.delete = U, C.prototype.get = se, C.prototype.has = he, C.prototype.set = xe;
  function Te(ae) {
    var ye = -1, Ge = ae == null ? 0 : ae.length;
    for (this.clear(); ++ye < Ge; ) {
      var Pt = ae[ye];
      this.set(Pt[0], Pt[1]);
    }
  }
  function Re() {
    this.__data__ = [], this.size = 0;
  }
  function nt(ae) {
    var ye = this.__data__, Ge = Je(ye, ae);
    if (Ge < 0)
      return !1;
    var Pt = ye.length - 1;
    return Ge == Pt ? ye.pop() : Yt.call(ye, Ge, 1), --this.size, !0;
  }
  function Ue(ae) {
    var ye = this.__data__, Ge = Je(ye, ae);
    return Ge < 0 ? void 0 : ye[Ge][1];
  }
  function pt(ae) {
    return Je(this.__data__, ae) > -1;
  }
  function it(ae, ye) {
    var Ge = this.__data__, Pt = Je(Ge, ae);
    return Pt < 0 ? (++this.size, Ge.push([ae, ye])) : Ge[Pt][1] = ye, this;
  }
  Te.prototype.clear = Re, Te.prototype.delete = nt, Te.prototype.get = Ue, Te.prototype.has = pt, Te.prototype.set = it;
  function et(ae) {
    var ye = -1, Ge = ae == null ? 0 : ae.length;
    for (this.clear(); ++ye < Ge; ) {
      var Pt = ae[ye];
      this.set(Pt[0], Pt[1]);
    }
  }
  function St() {
    this.size = 0, this.__data__ = {
      hash: new C(),
      map: new (Ct || Te)(),
      string: new C()
    };
  }
  function Tt(ae) {
    var ye = mr(this, ae).delete(ae);
    return this.size -= ye ? 1 : 0, ye;
  }
  function At(ae) {
    return mr(this, ae).get(ae);
  }
  function _t(ae) {
    return mr(this, ae).has(ae);
  }
  function ht(ae, ye) {
    var Ge = mr(this, ae), Pt = Ge.size;
    return Ge.set(ae, ye), this.size += Ge.size == Pt ? 0 : 1, this;
  }
  et.prototype.clear = St, et.prototype.delete = Tt, et.prototype.get = At, et.prototype.has = _t, et.prototype.set = ht;
  function xt(ae) {
    var ye = -1, Ge = ae == null ? 0 : ae.length;
    for (this.__data__ = new et(); ++ye < Ge; )
      this.add(ae[ye]);
  }
  function st(ae) {
    return this.__data__.set(ae, n), this;
  }
  function bt(ae) {
    return this.__data__.has(ae);
  }
  xt.prototype.add = xt.prototype.push = st, xt.prototype.has = bt;
  function ut(ae) {
    var ye = this.__data__ = new Te(ae);
    this.size = ye.size;
  }
  function ot() {
    this.__data__ = new Te(), this.size = 0;
  }
  function Se(ae) {
    var ye = this.__data__, Ge = ye.delete(ae);
    return this.size = ye.size, Ge;
  }
  function Ae(ae) {
    return this.__data__.get(ae);
  }
  function Ve(ae) {
    return this.__data__.has(ae);
  }
  function Be(ae, ye) {
    var Ge = this.__data__;
    if (Ge instanceof Te) {
      var Pt = Ge.__data__;
      if (!Ct || Pt.length < r - 1)
        return Pt.push([ae, ye]), this.size = ++Ge.size, this;
      Ge = this.__data__ = new et(Pt);
    }
    return Ge.set(ae, ye), this.size = Ge.size, this;
  }
  ut.prototype.clear = ot, ut.prototype.delete = Se, ut.prototype.get = Ae, ut.prototype.has = Ve, ut.prototype.set = Be;
  function je(ae, ye) {
    var Ge = Pc(ae), Pt = !Ge && hh(ae), Ur = !Ge && !Pt && Ju(ae), rr = !Ge && !Pt && !Ur && gh(ae), Kr = Ge || Pt || Ur || rr, vn = Kr ? De(ae.length, String) : [], _r = vn.length;
    for (var jr in ae)
      ke.call(ae, jr) && !(Kr && // Safari 9 has enumerable `arguments.length` in strict mode.
      (jr == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      Ur && (jr == "offset" || jr == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      rr && (jr == "buffer" || jr == "byteLength" || jr == "byteOffset") || // Skip index properties.
      nn(jr, _r))) && vn.push(jr);
    return vn;
  }
  function Je(ae, ye) {
    for (var Ge = ae.length; Ge--; )
      if (lh(ae[Ge][0], ye))
        return Ge;
    return -1;
  }
  function Lt(ae, ye, Ge) {
    var Pt = ye(ae);
    return Pc(ae) ? Pt : ve(Pt, Ge(ae));
  }
  function zt(ae) {
    return ae == null ? ae === void 0 ? pe : F : Et && Et in Object(ae) ? $r(ae) : Rp(ae);
  }
  function Xt(ae) {
    return Ra(ae) && zt(ae) == a;
  }
  function Ht(ae, ye, Ge, Pt, Ur) {
    return ae === ye ? !0 : ae == null || ye == null || !Ra(ae) && !Ra(ye) ? ae !== ae && ye !== ye : le(ae, ye, Ge, Pt, Ht, Ur);
  }
  function le(ae, ye, Ge, Pt, Ur, rr) {
    var Kr = Pc(ae), vn = Pc(ye), _r = Kr ? u : Ir(ae), jr = vn ? u : Ir(ye);
    _r = _r == a ? $ : _r, jr = jr == a ? $ : jr;
    var an = _r == $, ci = jr == $, bn = _r == jr;
    if (bn && Ju(ae)) {
      if (!Ju(ye))
        return !1;
      Kr = !0, an = !1;
    }
    if (bn && !an)
      return rr || (rr = new ut()), Kr || gh(ae) ? Zt(ae, ye, Ge, Pt, Ur, rr) : gr(ae, ye, _r, Ge, Pt, Ur, rr);
    if (!(Ge & i)) {
      var Vr = an && ke.call(ae, "__wrapped__"), ei = ci && ke.call(ye, "__wrapped__");
      if (Vr || ei) {
        var us = Vr ? ae.value() : ae, Bi = ei ? ye.value() : ye;
        return rr || (rr = new ut()), Ur(us, Bi, Ge, Pt, rr);
      }
    }
    return bn ? (rr || (rr = new ut()), lr(ae, ye, Ge, Pt, Ur, rr)) : !1;
  }
  function tr(ae) {
    if (!ph(ae) || on(ae))
      return !1;
    var ye = Mc(ae) ? Ye : B;
    return ye.test(no(ae));
  }
  function dr(ae) {
    return Ra(ae) && dh(ae.length) && !!D[zt(ae)];
  }
  function pr(ae) {
    if (!fh(ae))
      return Dt(ae);
    var ye = [];
    for (var Ge in Object(ae))
      ke.call(ae, Ge) && Ge != "constructor" && ye.push(Ge);
    return ye;
  }
  function Zt(ae, ye, Ge, Pt, Ur, rr) {
    var Kr = Ge & i, vn = ae.length, _r = ye.length;
    if (vn != _r && !(Kr && _r > vn))
      return !1;
    var jr = rr.get(ae);
    if (jr && rr.get(ye))
      return jr == ye;
    var an = -1, ci = !0, bn = Ge & s ? new xt() : void 0;
    for (rr.set(ae, ye), rr.set(ye, ae); ++an < vn; ) {
      var Vr = ae[an], ei = ye[an];
      if (Pt)
        var us = Kr ? Pt(ei, Vr, an, ye, ae, rr) : Pt(Vr, ei, an, ae, ye, rr);
      if (us !== void 0) {
        if (us)
          continue;
        ci = !1;
        break;
      }
      if (bn) {
        if (!Pe(ye, function(Bi, Ms) {
          if (!$e(bn, Ms) && (Vr === Bi || Ur(Vr, Bi, Ge, Pt, rr)))
            return bn.push(Ms);
        })) {
          ci = !1;
          break;
        }
      } else if (!(Vr === ei || Ur(Vr, ei, Ge, Pt, rr))) {
        ci = !1;
        break;
      }
    }
    return rr.delete(ae), rr.delete(ye), ci;
  }
  function gr(ae, ye, Ge, Pt, Ur, rr, Kr) {
    switch (Ge) {
      case S:
        if (ae.byteLength != ye.byteLength || ae.byteOffset != ye.byteOffset)
          return !1;
        ae = ae.buffer, ye = ye.buffer;
      case Y:
        return !(ae.byteLength != ye.byteLength || !rr(new ct(ae), new ct(ye)));
      case d:
      case p:
      case L:
        return lh(+ae, +ye);
      case w:
        return ae.name == ye.name && ae.message == ye.message;
      case V:
      case R:
        return ae == ye + "";
      case N:
        var vn = Ne;
      case te:
        var _r = Pt & i;
        if (vn || (vn = Le), ae.size != ye.size && !_r)
          return !1;
        var jr = Kr.get(ae);
        if (jr)
          return jr == ye;
        Pt |= s, Kr.set(ae, ye);
        var an = Zt(vn(ae), vn(ye), Pt, Ur, rr, Kr);
        return Kr.delete(ae), an;
      case W:
        if (z)
          return z.call(ae) == z.call(ye);
    }
    return !1;
  }
  function lr(ae, ye, Ge, Pt, Ur, rr) {
    var Kr = Ge & i, vn = Rr(ae), _r = vn.length, jr = Rr(ye), an = jr.length;
    if (_r != an && !Kr)
      return !1;
    for (var ci = _r; ci--; ) {
      var bn = vn[ci];
      if (!(Kr ? bn in ye : ke.call(ye, bn)))
        return !1;
    }
    var Vr = rr.get(ae);
    if (Vr && rr.get(ye))
      return Vr == ye;
    var ei = !0;
    rr.set(ae, ye), rr.set(ye, ae);
    for (var us = Kr; ++ci < _r; ) {
      bn = vn[ci];
      var Bi = ae[bn], Ms = ye[bn];
      if (Pt)
        var Xu = Kr ? Pt(Ms, Bi, bn, ye, ae, rr) : Pt(Bi, Ms, bn, ae, ye, rr);
      if (!(Xu === void 0 ? Bi === Ms || Ur(Bi, Ms, Ge, Pt, rr) : Xu)) {
        ei = !1;
        break;
      }
      us || (us = bn == "constructor");
    }
    if (ei && !us) {
      var Da = ae.constructor, Pn = ye.constructor;
      Da != Pn && "constructor" in ae && "constructor" in ye && !(typeof Da == "function" && Da instanceof Da && typeof Pn == "function" && Pn instanceof Pn) && (ei = !1);
    }
    return rr.delete(ae), rr.delete(ye), ei;
  }
  function Rr(ae) {
    return Lt(ae, Np, Fr);
  }
  function mr(ae, ye) {
    var Ge = ae.__data__;
    return sn(ye) ? Ge[typeof ye == "string" ? "string" : "hash"] : Ge.map;
  }
  function yr(ae, ye) {
    var Ge = Me(ae, ye);
    return tr(Ge) ? Ge : void 0;
  }
  function $r(ae) {
    var ye = ke.call(ae, Et), Ge = ae[Et];
    try {
      ae[Et] = void 0;
      var Pt = !0;
    } catch {
    }
    var Ur = tt.call(ae);
    return Pt && (ye ? ae[Et] = Ge : delete ae[Et]), Ur;
  }
  var Fr = Qt ? function(ae) {
    return ae == null ? [] : (ae = Object(ae), ue(Qt(ae), function(ye) {
      return qt.call(ae, ye);
    }));
  } : Br, Ir = zt;
  (kt && Ir(new kt(new ArrayBuffer(1))) != S || Ct && Ir(new Ct()) != N || gt && Ir(gt.resolve()) != K || Rt && Ir(new Rt()) != te || Nt && Ir(new Nt()) != Ee) && (Ir = function(ae) {
    var ye = zt(ae), Ge = ye == $ ? ae.constructor : void 0, Pt = Ge ? no(Ge) : "";
    if (Pt)
      switch (Pt) {
        case $t:
          return S;
        case Bt:
          return N;
        case rt:
          return K;
        case Ft:
          return te;
        case k:
          return Ee;
      }
    return ye;
  });
  function nn(ae, ye) {
    return ye = ye ?? o, !!ye && (typeof ae == "number" || ce.test(ae)) && ae > -1 && ae % 1 == 0 && ae < ye;
  }
  function sn(ae) {
    var ye = typeof ae;
    return ye == "string" || ye == "number" || ye == "symbol" || ye == "boolean" ? ae !== "__proto__" : ae === null;
  }
  function on(ae) {
    return !!Qe && Qe in ae;
  }
  function fh(ae) {
    var ye = ae && ae.constructor, Ge = typeof ye == "function" && ye.prototype || _e;
    return ae === Ge;
  }
  function Rp(ae) {
    return tt.call(ae);
  }
  function no(ae) {
    if (ae != null) {
      try {
        return at.call(ae);
      } catch {
      }
      try {
        return ae + "";
      } catch {
      }
    }
    return "";
  }
  function lh(ae, ye) {
    return ae === ye || ae !== ae && ye !== ye;
  }
  var hh = Xt(/* @__PURE__ */ function() {
    return arguments;
  }()) ? Xt : function(ae) {
    return Ra(ae) && ke.call(ae, "callee") && !qt.call(ae, "callee");
  }, Pc = Array.isArray;
  function Dp(ae) {
    return ae != null && dh(ae.length) && !Mc(ae);
  }
  var Ju = Jt || Dr;
  function Op(ae, ye) {
    return Ht(ae, ye);
  }
  function Mc(ae) {
    if (!ph(ae))
      return !1;
    var ye = zt(ae);
    return ye == P || ye == A || ye == l || ye == H;
  }
  function dh(ae) {
    return typeof ae == "number" && ae > -1 && ae % 1 == 0 && ae <= o;
  }
  function ph(ae) {
    var ye = typeof ae;
    return ae != null && (ye == "object" || ye == "function");
  }
  function Ra(ae) {
    return ae != null && typeof ae == "object";
  }
  var gh = ie ? Ce(ie) : dr;
  function Np(ae) {
    return Dp(ae) ? je(ae) : pr(ae);
  }
  function Br() {
    return [];
  }
  function Dr() {
    return !1;
  }
  t.exports = Op;
})(f0, f0.exports);
var NH = f0.exports;
const LH = /* @__PURE__ */ ts(NH), eE = "wc", tE = 2, rE = "core", Zs = `${eE}@2:${rE}:`, kH = { logger: "error" }, $H = { database: ":memory:" }, FH = "crypto", l3 = "client_ed25519_seed", BH = mt.ONE_DAY, UH = "keychain", jH = "0.3", qH = "messages", zH = "0.3", HH = mt.SIX_HOURS, WH = "publisher", nE = "irn", KH = "error", iE = "wss://relay.walletconnect.org", VH = "relayer", si = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", publish: "relayer_publish" }, GH = "_subscription", Vi = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, YH = 0.1, T1 = "2.17.2", zr = { link_mode: "link_mode", relay: "relay" }, JH = "0.3", XH = "WALLETCONNECT_CLIENT_ID", h3 = "WALLETCONNECT_LINK_MODE_APPS", Us = { created: "subscription_created", deleted: "subscription_deleted", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, ZH = "subscription", QH = "0.3", eW = mt.FIVE_SECONDS * 1e3, tW = "pairing", rW = "0.3", Pf = { wc_pairingDelete: { req: { ttl: mt.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: mt.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: mt.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: mt.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: mt.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: mt.ONE_DAY, prompt: !1, tag: 0 } } }, Xa = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" }, gs = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, nW = "history", iW = "0.3", sW = "expirer", Ji = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, oW = "0.3", aW = "verify-api", cW = "https://verify.walletconnect.com", sE = "https://verify.walletconnect.org", zf = sE, uW = `${zf}/v3`, fW = [cW, sE], lW = "echo", hW = "https://echo.walletconnect.com", Fs = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal" }, yo = { no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_listener_not_found: "proposal_listener_not_found" }, ms = { session_approve_started: "session_approve_started", session_namespaces_validation_success: "session_namespaces_validation_success", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" }, Ha = { no_internet_connection: "no_internet_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" }, Wa = { authenticated_session_approve_started: "authenticated_session_approve_started", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve" }, Mf = { no_internet_connection: "no_internet_connection", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" }, dW = 0.1, pW = "event-client", gW = 86400, mW = "https://pulse.walletconnect.org/batch";
function vW(t, e) {
  if (t.length >= 255) throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++) r[n] = 255;
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i), o = s.charCodeAt(0);
    if (r[o] !== 255) throw new TypeError(s + " is ambiguous");
    r[o] = i;
  }
  var a = t.length, u = t.charAt(0), l = Math.log(a) / Math.log(256), d = Math.log(256) / Math.log(a);
  function p(A) {
    if (A instanceof Uint8Array || (ArrayBuffer.isView(A) ? A = new Uint8Array(A.buffer, A.byteOffset, A.byteLength) : Array.isArray(A) && (A = Uint8Array.from(A))), !(A instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (A.length === 0) return "";
    for (var N = 0, L = 0, F = 0, $ = A.length; F !== $ && A[F] === 0; ) F++, N++;
    for (var K = ($ - F) * d + 1 >>> 0, H = new Uint8Array(K); F !== $; ) {
      for (var V = A[F], te = 0, R = K - 1; (V !== 0 || te < L) && R !== -1; R--, te++) V += 256 * H[R] >>> 0, H[R] = V % a >>> 0, V = V / a >>> 0;
      if (V !== 0) throw new Error("Non-zero carry");
      L = te, F++;
    }
    for (var W = K - L; W !== K && H[W] === 0; ) W++;
    for (var pe = u.repeat(N); W < K; ++W) pe += t.charAt(H[W]);
    return pe;
  }
  function w(A) {
    if (typeof A != "string") throw new TypeError("Expected String");
    if (A.length === 0) return new Uint8Array();
    var N = 0;
    if (A[N] !== " ") {
      for (var L = 0, F = 0; A[N] === u; ) L++, N++;
      for (var $ = (A.length - N) * l + 1 >>> 0, K = new Uint8Array($); A[N]; ) {
        var H = r[A.charCodeAt(N)];
        if (H === 255) return;
        for (var V = 0, te = $ - 1; (H !== 0 || V < F) && te !== -1; te--, V++) H += a * K[te] >>> 0, K[te] = H % 256 >>> 0, H = H / 256 >>> 0;
        if (H !== 0) throw new Error("Non-zero carry");
        F = V, N++;
      }
      if (A[N] !== " ") {
        for (var R = $ - F; R !== $ && K[R] === 0; ) R++;
        for (var W = new Uint8Array(L + ($ - R)), pe = L; R !== $; ) W[pe++] = K[R++];
        return W;
      }
    }
  }
  function P(A) {
    var N = w(A);
    if (N) return N;
    throw new Error(`Non-${e} character`);
  }
  return { encode: p, decodeUnsafe: w, decode: P };
}
var bW = vW, yW = bW;
const oE = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array") return t;
  if (t instanceof ArrayBuffer) return new Uint8Array(t);
  if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, wW = (t) => new TextEncoder().encode(t), xW = (t) => new TextDecoder().decode(t);
class _W {
  constructor(e, r, n) {
    this.name = e, this.prefix = r, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class EW {
  constructor(e, r, n) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return aE(this, e);
  }
}
class SW {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return aE(this, e);
  }
  decode(e) {
    const r = e[0], n = this.decoders[r];
    if (n) return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const aE = (t, e) => new SW({ ...t.decoders || { [t.prefix]: t }, ...e.decoders || { [e.prefix]: e } });
class AW {
  constructor(e, r, n, i) {
    this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = i, this.encoder = new _W(e, r, n), this.decoder = new EW(e, r, i);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const ip = ({ name: t, prefix: e, encode: r, decode: n }) => new AW(t, e, r, n), th = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: n, decode: i } = yW(r, e);
  return ip({ prefix: t, name: e, encode: n, decode: (s) => oE(i(s)) });
}, PW = (t, e, r, n) => {
  const i = {};
  for (let d = 0; d < e.length; ++d) i[e[d]] = d;
  let s = t.length;
  for (; t[s - 1] === "="; ) --s;
  const o = new Uint8Array(s * r / 8 | 0);
  let a = 0, u = 0, l = 0;
  for (let d = 0; d < s; ++d) {
    const p = i[t[d]];
    if (p === void 0) throw new SyntaxError(`Non-${n} character`);
    u = u << r | p, a += r, a >= 8 && (a -= 8, o[l++] = 255 & u >> a);
  }
  if (a >= r || 255 & u << 8 - a) throw new SyntaxError("Unexpected end of data");
  return o;
}, MW = (t, e, r) => {
  const n = e[e.length - 1] === "=", i = (1 << r) - 1;
  let s = "", o = 0, a = 0;
  for (let u = 0; u < t.length; ++u) for (a = a << 8 | t[u], o += 8; o > r; ) o -= r, s += e[i & a >> o];
  if (o && (s += e[i & a << r - o]), n) for (; s.length * r & 7; ) s += "=";
  return s;
}, Hn = ({ name: t, prefix: e, bitsPerChar: r, alphabet: n }) => ip({ prefix: e, name: t, encode(i) {
  return MW(i, n, r);
}, decode(i) {
  return PW(i, n, r, t);
} }), IW = ip({ prefix: "\0", name: "identity", encode: (t) => xW(t), decode: (t) => wW(t) });
var CW = Object.freeze({ __proto__: null, identity: IW });
const TW = Hn({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var RW = Object.freeze({ __proto__: null, base2: TW });
const DW = Hn({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var OW = Object.freeze({ __proto__: null, base8: DW });
const NW = th({ prefix: "9", name: "base10", alphabet: "0123456789" });
var LW = Object.freeze({ __proto__: null, base10: NW });
const kW = Hn({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), $W = Hn({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var FW = Object.freeze({ __proto__: null, base16: kW, base16upper: $W });
const BW = Hn({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), UW = Hn({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), jW = Hn({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), qW = Hn({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), zW = Hn({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), HW = Hn({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), WW = Hn({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), KW = Hn({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), VW = Hn({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var GW = Object.freeze({ __proto__: null, base32: BW, base32upper: UW, base32pad: jW, base32padupper: qW, base32hex: zW, base32hexupper: HW, base32hexpad: WW, base32hexpadupper: KW, base32z: VW });
const YW = th({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), JW = th({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var XW = Object.freeze({ __proto__: null, base36: YW, base36upper: JW });
const ZW = th({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), QW = th({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var eK = Object.freeze({ __proto__: null, base58btc: ZW, base58flickr: QW });
const tK = Hn({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), rK = Hn({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), nK = Hn({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), iK = Hn({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var sK = Object.freeze({ __proto__: null, base64: tK, base64pad: rK, base64url: nK, base64urlpad: iK });
const cE = Array.from(""), oK = cE.reduce((t, e, r) => (t[r] = e, t), []), aK = cE.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function cK(t) {
  return t.reduce((e, r) => (e += oK[r], e), "");
}
function uK(t) {
  const e = [];
  for (const r of t) {
    const n = aK[r.codePointAt(0)];
    if (n === void 0) throw new Error(`Non-base256emoji character: ${r}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const fK = ip({ prefix: "", name: "base256emoji", encode: cK, decode: uK });
var lK = Object.freeze({ __proto__: null, base256emoji: fK }), hK = uE, d3 = 128, dK = 127, pK = ~dK, gK = Math.pow(2, 31);
function uE(t, e, r) {
  e = e || [], r = r || 0;
  for (var n = r; t >= gK; ) e[r++] = t & 255 | d3, t /= 128;
  for (; t & pK; ) e[r++] = t & 255 | d3, t >>>= 7;
  return e[r] = t | 0, uE.bytes = r - n + 1, e;
}
var mK = R1, vK = 128, p3 = 127;
function R1(t, n) {
  var r = 0, n = n || 0, i = 0, s = n, o, a = t.length;
  do {
    if (s >= a) throw R1.bytes = 0, new RangeError("Could not decode varint");
    o = t[s++], r += i < 28 ? (o & p3) << i : (o & p3) * Math.pow(2, i), i += 7;
  } while (o >= vK);
  return R1.bytes = s - n, r;
}
var bK = Math.pow(2, 7), yK = Math.pow(2, 14), wK = Math.pow(2, 21), xK = Math.pow(2, 28), _K = Math.pow(2, 35), EK = Math.pow(2, 42), SK = Math.pow(2, 49), AK = Math.pow(2, 56), PK = Math.pow(2, 63), MK = function(t) {
  return t < bK ? 1 : t < yK ? 2 : t < wK ? 3 : t < xK ? 4 : t < _K ? 5 : t < EK ? 6 : t < SK ? 7 : t < AK ? 8 : t < PK ? 9 : 10;
}, IK = { encode: hK, decode: mK, encodingLength: MK }, fE = IK;
const g3 = (t, e, r = 0) => (fE.encode(t, e, r), e), m3 = (t) => fE.encodingLength(t), D1 = (t, e) => {
  const r = e.byteLength, n = m3(t), i = n + m3(r), s = new Uint8Array(i + r);
  return g3(t, s, 0), g3(r, s, n), s.set(e, i), new CK(t, r, e, s);
};
class CK {
  constructor(e, r, n, i) {
    this.code = e, this.size = r, this.digest = n, this.bytes = i;
  }
}
const lE = ({ name: t, code: e, encode: r }) => new TK(t, e, r);
class TK {
  constructor(e, r, n) {
    this.name = e, this.code = r, this.encode = n;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const r = this.encode(e);
      return r instanceof Uint8Array ? D1(this.code, r) : r.then((n) => D1(this.code, n));
    } else throw Error("Unknown type, must be binary type");
  }
}
const hE = (t) => async (e) => new Uint8Array(await crypto.subtle.digest(t, e)), RK = lE({ name: "sha2-256", code: 18, encode: hE("SHA-256") }), DK = lE({ name: "sha2-512", code: 19, encode: hE("SHA-512") });
var OK = Object.freeze({ __proto__: null, sha256: RK, sha512: DK });
const dE = 0, NK = "identity", pE = oE, LK = (t) => D1(dE, pE(t)), kK = { code: dE, name: NK, encode: pE, digest: LK };
var $K = Object.freeze({ __proto__: null, identity: kK });
new TextEncoder(), new TextDecoder();
const v3 = { ...CW, ...RW, ...OW, ...LW, ...FW, ...GW, ...XW, ...eK, ...sK, ...lK };
({ ...OK, ...$K });
function FK(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(t) : new Uint8Array(t);
}
function gE(t, e, r, n) {
  return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: r }, decoder: { decode: n } };
}
const b3 = gE("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), pm = gE("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = FK(t.length);
  for (let r = 0; r < t.length; r++) e[r] = t.charCodeAt(r);
  return e;
}), BK = { utf8: b3, "utf-8": b3, hex: v3.base16, latin1: pm, ascii: pm, binary: pm, ...v3 };
function UK(t, e = "utf8") {
  const r = BK[e];
  if (!r) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t, "utf8") : r.decoder.decode(`${r.prefix}${t}`);
}
let jK = class {
  constructor(e, r) {
    this.core = e, this.logger = r, this.keychain = /* @__PURE__ */ new Map(), this.name = UH, this.version = jH, this.initialized = !1, this.storagePrefix = Zs, this.init = async () => {
      if (!this.initialized) {
        const n = await this.getKeyChain();
        typeof n < "u" && (this.keychain = n), this.initialized = !0;
      }
    }, this.has = (n) => (this.isInitialized(), this.keychain.has(n)), this.set = async (n, i) => {
      this.isInitialized(), this.keychain.set(n, i), await this.persist();
    }, this.get = (n) => {
      this.isInitialized();
      const i = this.keychain.get(n);
      if (typeof i > "u") {
        const { message: s } = ft("NO_MATCHING_KEY", `${this.name}: ${n}`);
        throw new Error(s);
      }
      return i;
    }, this.del = async (n) => {
      this.isInitialized(), this.keychain.delete(n), await this.persist();
    }, this.core = e, this.logger = ai(r, this.name);
  }
  get context() {
    return Si(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, N8(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? L8(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}, qK = class {
  constructor(e, r, n) {
    this.core = e, this.logger = r, this.name = FH, this.randomSessionIdentifier = I1(), this.initialized = !1, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0);
    }, this.hasKeys = (i) => (this.isInitialized(), this.keychain.has(i)), this.getClientId = async () => {
      this.isInitialized();
      const i = await this.getClientSeed(), s = nx(i);
      return U4(s.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const i = lz();
      return this.setPrivateKey(i.publicKey, i.privateKey);
    }, this.signJWT = async (i) => {
      this.isInitialized();
      const s = await this.getClientSeed(), o = nx(s), a = this.randomSessionIdentifier;
      return await NF(a, i, BH, o);
    }, this.generateSharedKey = (i, s, o) => {
      this.isInitialized();
      const a = this.getPrivateKey(i), u = hz(a, s);
      return this.setSymKey(u, o);
    }, this.setSymKey = async (i, s) => {
      this.isInitialized();
      const o = s || Cd(i);
      return await this.keychain.set(o, i), o;
    }, this.deleteKeyPair = async (i) => {
      this.isInitialized(), await this.keychain.del(i);
    }, this.deleteSymKey = async (i) => {
      this.isInitialized(), await this.keychain.del(i);
    }, this.encode = async (i, s, o) => {
      this.isInitialized();
      const a = W8(o), u = ko(s);
      if (Kx(a)) return pz(u, o == null ? void 0 : o.encoding);
      if (Wx(a)) {
        const w = a.senderPublicKey, P = a.receiverPublicKey;
        i = await this.generateSharedKey(w, P);
      }
      const l = this.getSymKey(i), { type: d, senderPublicKey: p } = a;
      return dz({ type: d, symKey: l, message: u, senderPublicKey: p, encoding: o == null ? void 0 : o.encoding });
    }, this.decode = async (i, s, o) => {
      this.isInitialized();
      const a = vz(s, o);
      if (Kx(a)) {
        const u = mz(s, o == null ? void 0 : o.encoding);
        return uc(u);
      }
      if (Wx(a)) {
        const u = a.receiverPublicKey, l = a.senderPublicKey;
        i = await this.generateSharedKey(u, l);
      }
      try {
        const u = this.getSymKey(i), l = gz({ symKey: u, encoded: s, encoding: o == null ? void 0 : o.encoding });
        return uc(l);
      } catch (u) {
        this.logger.error(`Failed to decode message from topic: '${i}', clientId: '${await this.getClientId()}'`), this.logger.error(u);
      }
    }, this.getPayloadType = (i, s = la) => {
      const o = _l({ encoded: i, encoding: s });
      return hc(o.type);
    }, this.getPayloadSenderPublicKey = (i, s = la) => {
      const o = _l({ encoded: i, encoding: s });
      return o.senderPublicKey ? Dn(o.senderPublicKey, oi) : void 0;
    }, this.core = e, this.logger = ai(r, this.name), this.keychain = n || new jK(this.core, this.logger);
  }
  get context() {
    return Si(this.logger);
  }
  async setPrivateKey(e, r) {
    return await this.keychain.set(e, r), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(l3);
    } catch {
      e = I1(), await this.keychain.set(l3, e);
    }
    return UK(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
class zK extends Uk {
  constructor(e, r) {
    super(e, r), this.logger = e, this.core = r, this.messages = /* @__PURE__ */ new Map(), this.name = qH, this.version = zH, this.initialized = !1, this.storagePrefix = Zs, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const n = await this.getRelayerMessages();
          typeof n < "u" && (this.messages = n), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (n) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(n);
        } finally {
          this.initialized = !0;
        }
      }
    }, this.set = async (n, i) => {
      this.isInitialized();
      const s = wo(i);
      let o = this.messages.get(n);
      return typeof o > "u" && (o = {}), typeof o[s] < "u" || (o[s] = i, this.messages.set(n, o), await this.persist()), s;
    }, this.get = (n) => {
      this.isInitialized();
      let i = this.messages.get(n);
      return typeof i > "u" && (i = {}), i;
    }, this.has = (n, i) => {
      this.isInitialized();
      const s = this.get(n), o = wo(i);
      return typeof s[o] < "u";
    }, this.del = async (n) => {
      this.isInitialized(), this.messages.delete(n), await this.persist();
    }, this.logger = ai(e, this.name), this.core = r;
  }
  get context() {
    return Si(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, N8(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? L8(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class HK extends jk {
  constructor(e, r) {
    super(e, r), this.relayer = e, this.logger = r, this.events = new rs.EventEmitter(), this.name = WH, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = mt.toMiliseconds(mt.ONE_MINUTE), this.failedPublishTimeout = mt.toMiliseconds(mt.ONE_SECOND), this.needsTransportRestart = !1, this.publish = async (n, i, s) => {
      var o;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: n, message: i, opts: s } });
      const a = (s == null ? void 0 : s.ttl) || HH, u = C1(s), l = (s == null ? void 0 : s.prompt) || !1, d = (s == null ? void 0 : s.tag) || 0, p = (s == null ? void 0 : s.id) || rc().toString(), w = { topic: n, message: i, opts: { ttl: a, relay: u, prompt: l, tag: d, id: p, attestation: s == null ? void 0 : s.attestation } }, P = `Failed to publish payload, please try again. id:${p} tag:${d}`, A = Date.now();
      let N, L = 1;
      try {
        for (; N === void 0; ) {
          if (Date.now() - A > this.publishTimeout) throw new Error(P);
          this.logger.trace({ id: p, attempts: L }, `publisher.publish - attempt ${L}`), N = await await hu(this.rpcPublish(n, i, a, u, l, d, p, s == null ? void 0 : s.attestation).catch((F) => this.logger.warn(F)), this.publishTimeout, P), L++, N || await new Promise((F) => setTimeout(F, this.failedPublishTimeout));
        }
        this.relayer.events.emit(si.publish, w), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { id: p, topic: n, message: i, opts: s } });
      } catch (F) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(F), (o = s == null ? void 0 : s.internal) != null && o.throwOnFailedPublish) throw F;
        this.queue.set(p, w);
      }
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.relayer = e, this.logger = ai(r, this.name), this.registerEventListeners();
  }
  get context() {
    return Si(this.logger);
  }
  rpcPublish(e, r, n, i, s, o, a, u) {
    var l, d, p, w;
    const P = { method: $f(i.protocol).publish, params: { topic: e, message: r, ttl: n, prompt: s, tag: o, attestation: u }, id: a };
    return gi((l = P.params) == null ? void 0 : l.prompt) && ((d = P.params) == null || delete d.prompt), gi((p = P.params) == null ? void 0 : p.tag) && ((w = P.params) == null || delete w.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: P }), this.relayer.request(P);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: r, message: n, opts: i } = e;
      await this.publish(r, n, i);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(Du.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = !1, this.relayer.events.emit(si.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(si.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
}
class WK {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, r) => {
      const n = this.get(e);
      this.exists(e, r) || this.map.set(e, [...n, r]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, r) => this.get(e).includes(r), this.delete = (e, r) => {
      if (typeof r > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const n = this.get(e);
      if (!this.exists(e, r)) return;
      const i = n.filter((s) => s !== r);
      if (!i.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, i);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var KK = Object.defineProperty, VK = Object.defineProperties, GK = Object.getOwnPropertyDescriptors, y3 = Object.getOwnPropertySymbols, YK = Object.prototype.hasOwnProperty, JK = Object.prototype.propertyIsEnumerable, w3 = (t, e, r) => e in t ? KK(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, If = (t, e) => {
  for (var r in e || (e = {})) YK.call(e, r) && w3(t, r, e[r]);
  if (y3) for (var r of y3(e)) JK.call(e, r) && w3(t, r, e[r]);
  return t;
}, gm = (t, e) => VK(t, GK(e));
class XK extends Hk {
  constructor(e, r) {
    super(e, r), this.relayer = e, this.logger = r, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new WK(), this.events = new rs.EventEmitter(), this.name = ZH, this.version = QH, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = Zs, this.subscribeTimeout = mt.toMiliseconds(mt.ONE_MINUTE), this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.pendingBatchMessages = [], this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = !0;
    }, this.subscribe = async (n, i) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: i } });
      try {
        const s = C1(i), o = { topic: n, relay: s, transportType: i == null ? void 0 : i.transportType };
        this.pending.set(n, o);
        const a = await this.rpcSubscribe(n, s, i);
        return typeof a == "string" && (this.onSubscribe(a, o), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: i } })), a;
      } catch (s) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(s), s;
      }
    }, this.unsubscribe = async (n, i) => {
      await this.restartToComplete(), this.isInitialized(), typeof (i == null ? void 0 : i.id) < "u" ? await this.unsubscribeById(n, i.id, i) : await this.unsubscribeByTopic(n, i);
    }, this.isSubscribed = async (n) => {
      if (this.topics.includes(n)) return !0;
      const i = `${this.pendingSubscriptionWatchLabel}_${n}`;
      return await new Promise((s, o) => {
        const a = new mt.Watch();
        a.start(i);
        const u = setInterval(() => {
          !this.pending.has(n) && this.topics.includes(n) && (clearInterval(u), a.stop(i), s(!0)), a.elapsed(i) >= eW && (clearInterval(u), a.stop(i), o(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => !1);
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.start = async () => {
      await this.onConnect();
    }, this.stop = async () => {
      await this.onDisconnect();
    }, this.restart = async () => {
      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;
    }, this.relayer = e, this.logger = ai(r, this.name), this.clientId = "";
  }
  get context() {
    return Si(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, r) {
    let n = !1;
    try {
      n = this.getSubscription(e).topic === r;
    } catch {
    }
    return n;
  }
  onEnable() {
    this.cached = [], this.initialized = !0;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, r) {
    const n = this.topicMap.get(e);
    await Promise.all(n.map(async (i) => await this.unsubscribeById(e, i, r)));
  }
  async unsubscribeById(e, r, n) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: r, opts: n } });
    try {
      const i = C1(n);
      await this.rpcUnsubscribe(e, r, i);
      const s = Or("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, r, s), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: r, opts: n } });
    } catch (i) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i), i;
    }
  }
  async rpcSubscribe(e, r, n) {
    var i;
    (n == null ? void 0 : n.transportType) === zr.relay && await this.restartToComplete();
    const s = { method: $f(r.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s });
    const o = (i = n == null ? void 0 : n.internal) == null ? void 0 : i.throwOnFailedPublish;
    try {
      const a = wo(e + this.clientId);
      if ((n == null ? void 0 : n.transportType) === zr.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(s).catch((l) => this.logger.warn(l));
      }, mt.toMiliseconds(mt.ONE_SECOND)), a;
      const u = await hu(this.relayer.request(s).catch((l) => this.logger.warn(l)), this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!u && o) throw new Error(`Subscribing to ${e} failed, please try again`);
      return u ? a : null;
    } catch (a) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(si.connection_stalled), o) throw a;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const r = e[0].relay, n = { method: $f(r.protocol).batchSubscribe, params: { topics: e.map((i) => i.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    try {
      return await await hu(this.relayer.request(n).catch((i) => this.logger.warn(i)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(si.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const r = e[0].relay, n = { method: $f(r.protocol).batchFetchMessages, params: { topics: e.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    let i;
    try {
      i = await await hu(this.relayer.request(n).catch((s) => this.logger.warn(s)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(si.connection_stalled);
    }
    return i;
  }
  rpcUnsubscribe(e, r, n) {
    const i = { method: $f(n.protocol).unsubscribe, params: { topic: e, id: r } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i }), this.relayer.request(i);
  }
  onSubscribe(e, r) {
    this.setSubscription(e, gm(If({}, r), { id: e })), this.pending.delete(r.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((r) => {
      this.setSubscription(r.id, If({}, r)), this.pending.delete(r.topic);
    });
  }
  async onUnsubscribe(e, r, n) {
    this.events.removeAllListeners(r), this.hasSubscription(r, e) && this.deleteSubscription(r, n), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, r) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: r }), this.addSubscription(e, r);
  }
  addSubscription(e, r) {
    this.subscriptions.set(e, If({}, r)), this.topicMap.set(r.topic, e), this.events.emit(Us.created, r);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const r = this.subscriptions.get(e);
    if (!r) {
      const { message: n } = ft("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return r;
  }
  deleteSubscription(e, r) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: r });
    const n = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(n.topic, e), this.events.emit(Us.deleted, gm(If({}, n), { reason: r }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(Us.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let r = 0; r < e; r++) {
        const n = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchFetchMessages(n), await this.batchSubscribe(n);
      }
    }
    this.events.emit(Us.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: r } = ft("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length) return;
    const r = await this.rpcBatchSubscribe(e);
    dc(r) && this.onBatchSubscribe(r.map((n, i) => gm(If({}, e[i]), { id: n })));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const r = await this.rpcBatchFetchMessages(e);
    r && r.messages && (this.pendingBatchMessages = this.pendingBatchMessages.concat(r.messages));
  }
  async onConnect() {
    await this.restart(), this.onEnable();
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || !this.relayer.connected) return;
    const e = [];
    this.pending.forEach((r) => {
      e.push(r);
    }), await this.batchSubscribe(e), this.pendingBatchMessages.length && (await this.relayer.handleBatchMessageEvents(this.pendingBatchMessages), this.pendingBatchMessages = []);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(Du.pulse, async () => {
      await this.checkPending();
    }), this.events.on(Us.created, async (e) => {
      const r = Us.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), await this.persist();
    }), this.events.on(Us.deleted, async (e) => {
      const r = Us.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen(), this.restartInProgress && await new Promise((e) => {
      const r = setInterval(() => {
        this.restartInProgress || (clearInterval(r), e());
      }, this.pollingInterval);
    });
  }
}
var ZK = Object.defineProperty, x3 = Object.getOwnPropertySymbols, QK = Object.prototype.hasOwnProperty, eV = Object.prototype.propertyIsEnumerable, _3 = (t, e, r) => e in t ? ZK(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, E3 = (t, e) => {
  for (var r in e || (e = {})) QK.call(e, r) && _3(t, r, e[r]);
  if (x3) for (var r of x3(e)) eV.call(e, r) && _3(t, r, e[r]);
  return t;
};
class tV extends qk {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new rs.EventEmitter(), this.name = VH, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "stalled", "interrupted"], this.hasExperiencedNetworkDisruption = !1, this.requestsInFlight = /* @__PURE__ */ new Map(), this.heartBeatTimeout = mt.toMiliseconds(mt.THIRTY_SECONDS + mt.ONE_SECOND), this.request = async (r) => {
      var n, i;
      this.logger.debug("Publishing Request Payload");
      const s = r.id || rc().toString();
      await this.toEstablishConnection();
      try {
        const o = this.provider.request(r);
        this.requestsInFlight.set(s, { promise: o, request: r }), this.logger.trace({ id: s, method: r.method, topic: (n = r.params) == null ? void 0 : n.topic }, "relayer.request - attempt to publish...");
        const a = await new Promise(async (u, l) => {
          const d = () => {
            l(new Error(`relayer.request - publish interrupted, id: ${s}`));
          };
          this.provider.on(Vi.disconnect, d);
          const p = await o;
          this.provider.off(Vi.disconnect, d), u(p);
        });
        return this.logger.trace({ id: s, method: r.method, topic: (i = r.params) == null ? void 0 : i.topic }, "relayer.request - published"), a;
      } catch (o) {
        throw this.logger.debug(`Failed to Publish Request: ${s}`), o;
      } finally {
        this.requestsInFlight.delete(s);
      }
    }, this.resetPingTimeout = () => {
      if (a0()) try {
        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
          var r, n, i;
          (i = (n = (r = this.provider) == null ? void 0 : r.connection) == null ? void 0 : n.socket) == null || i.terminate();
        }, this.heartBeatTimeout);
      } catch (r) {
        this.logger.warn(r);
      }
    }, this.onPayloadHandler = (r) => {
      this.onProviderPayload(r), this.resetPingTimeout();
    }, this.onConnectHandler = () => {
      this.logger.trace("relayer connected"), this.startPingTimeout(), this.events.emit(si.connect);
    }, this.onDisconnectHandler = () => {
      this.logger.trace("relayer disconnected"), this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (r) => {
      this.logger.error(r), this.events.emit(si.error, r), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(Vi.payload, this.onPayloadHandler), this.provider.on(Vi.connect, this.onConnectHandler), this.provider.on(Vi.disconnect, this.onDisconnectHandler), this.provider.on(Vi.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? ai(e.logger, this.name) : jl(k0({ level: e.logger || KH })), this.messages = new zK(this.logger, e.core), this.subscriber = new XK(this, this.logger), this.publisher = new HK(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || iE, this.projectId = e.projectId, this.bundleId = Cq(), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = !0, this.subscriber.cached.length > 0) try {
      await this.transportOpen();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  get context() {
    return Si(this.logger);
  }
  get connected() {
    var e, r, n;
    return ((n = (r = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : r.socket) == null ? void 0 : n.readyState) === 1;
  }
  get connecting() {
    var e, r, n;
    return ((n = (r = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : r.socket) == null ? void 0 : n.readyState) === 0;
  }
  async publish(e, r, n) {
    this.isInitialized(), await this.publisher.publish(e, r, n), await this.recordMessageEvent({ topic: e, message: r, publishedAt: Date.now(), transportType: zr.relay });
  }
  async subscribe(e, r) {
    var n, i, s;
    this.isInitialized(), (r == null ? void 0 : r.transportType) === "relay" && await this.toEstablishConnection();
    const o = typeof ((n = r == null ? void 0 : r.internal) == null ? void 0 : n.throwOnFailedPublish) > "u" ? !0 : (i = r == null ? void 0 : r.internal) == null ? void 0 : i.throwOnFailedPublish;
    let a = ((s = this.subscriber.topicMap.get(e)) == null ? void 0 : s[0]) || "", u;
    const l = (d) => {
      d.topic === e && (this.subscriber.off(Us.created, l), u());
    };
    return await Promise.all([new Promise((d) => {
      u = d, this.subscriber.on(Us.created, l);
    }), new Promise(async (d, p) => {
      a = await this.subscriber.subscribe(e, E3({ internal: { throwOnFailedPublish: o } }, r)).catch((w) => {
        o && p(w);
      }) || a, d();
    })]), a;
  }
  async unsubscribe(e, r) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, r);
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async transportDisconnect() {
    if (!this.hasExperiencedNetworkDisruption && this.connected && this.requestsInFlight.size > 0) try {
      await Promise.all(Array.from(this.requestsInFlight.values()).map((e) => e.promise));
    } catch (e) {
      this.logger.warn(e);
    }
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await hu(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = !0, await this.transportDisconnect();
  }
  async transportOpen(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), await this.createProvider(), this.connectionAttemptInProgress = !0, this.transportExplicitlyClosed = !1;
    try {
      await new Promise(async (r, n) => {
        const i = () => {
          this.provider.off(Vi.disconnect, i), n(new Error("Connection interrupted while trying to subscribe"));
        };
        this.provider.on(Vi.disconnect, i), await hu(this.provider.connect(), mt.toMiliseconds(mt.ONE_MINUTE), `Socket stalled when trying to connect to ${this.relayUrl}`).catch((s) => {
          n(s);
        }).finally(() => {
          clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;
        }), this.subscriber.start().catch((s) => {
          this.logger.error(s), this.onDisconnectHandler();
        }), this.hasExperiencedNetworkDisruption = !1, r();
      });
    } catch (r) {
      this.logger.error(r);
      const n = r;
      if (this.hasExperiencedNetworkDisruption = !0, !this.isConnectionStalled(n.message)) throw r;
    } finally {
      this.connectionAttemptInProgress = !1;
    }
  }
  async restartTransport(e) {
    this.connectionAttemptInProgress || (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await n3()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const r = e.sort((n, i) => n.publishedAt - i.publishedAt);
    this.logger.trace(`Batch of ${r.length} message events sorted`);
    for (const n of r) try {
      await this.onMessageEvent(n);
    } catch (i) {
      this.logger.warn(i);
    }
    this.logger.trace(`Batch of ${r.length} message events processed`);
  }
  async onLinkMessageEvent(e, r) {
    const { topic: n } = e;
    if (!r.sessionExists) {
      const i = En(mt.FIVE_MINUTES), s = { topic: n, expiry: i, relay: { protocol: "irn" }, active: !1 };
      await this.core.pairing.pairings.set(n, s);
    }
    this.events.emit(si.message, e), await this.recordMessageEvent(e);
  }
  startPingTimeout() {
    var e, r, n, i, s;
    if (a0()) try {
      (r = (e = this.provider) == null ? void 0 : e.connection) != null && r.socket && ((s = (i = (n = this.provider) == null ? void 0 : n.connection) == null ? void 0 : i.socket) == null || s.once("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o) {
      this.logger.warn(o);
    }
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((r) => e.includes(r));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new as(new OH(Oq({ sdkVersion: T1, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: !0, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: r, message: n } = e;
    await this.messages.set(r, n);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: r, message: n } = e;
    if (!n || n.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${n}`), !0;
    if (!await this.subscriber.isSubscribed(r)) return this.logger.debug(`Ignoring message for non-subscribed topic ${r}`), !0;
    const i = this.messages.has(r, n);
    return i && this.logger.debug(`Ignoring duplicate message: ${n}`), i;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), ub(e)) {
      if (!e.method.endsWith(GH)) return;
      const r = e.params, { topic: n, message: i, publishedAt: s, attestation: o } = r.data, a = { topic: n, message: i, publishedAt: s, transportType: zr.relay, attestation: o };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(E3({ type: "event", event: r.id }, a)), this.events.emit(r.id, a), await this.acknowledgePayload(e), await this.onMessageEvent(a);
    } else np(e) && this.events.emit(si.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(si.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const r = tp(e.id, !0);
    await this.provider.connection.send(r);
  }
  unregisterProviderListeners() {
    this.provider.off(Vi.payload, this.onPayloadHandler), this.provider.off(Vi.connect, this.onConnectHandler), this.provider.off(Vi.disconnect, this.onDisconnectHandler), this.provider.off(Vi.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await n3();
    fH(async (r) => {
      e !== r && (e = r, r ? await this.restartTransport().catch((n) => this.logger.error(n)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportDisconnect(), this.transportExplicitlyClosed = !1));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), this.requestsInFlight.clear(), clearTimeout(this.pingTimeout), this.events.emit(si.disconnect), this.connectionAttemptInProgress = !1, !this.transportExplicitlyClosed && (this.reconnectTimeout || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e));
    }, mt.toMiliseconds(YH))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (this.connectionAttemptInProgress && await new Promise((e) => {
      const r = setInterval(() => {
        this.connected && (clearInterval(r), e());
      }, this.connectionStatusPollingInterval);
    }), await this.transportOpen());
  }
}
var rV = Object.defineProperty, S3 = Object.getOwnPropertySymbols, nV = Object.prototype.hasOwnProperty, iV = Object.prototype.propertyIsEnumerable, A3 = (t, e, r) => e in t ? rV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, P3 = (t, e) => {
  for (var r in e || (e = {})) nV.call(e, r) && A3(t, r, e[r]);
  if (S3) for (var r of S3(e)) iV.call(e, r) && A3(t, r, e[r]);
  return t;
};
class _c extends zk {
  constructor(e, r, n, i = Zs, s = void 0) {
    super(e, r, n, i), this.core = e, this.logger = r, this.name = n, this.map = /* @__PURE__ */ new Map(), this.version = JH, this.cached = [], this.initialized = !1, this.storagePrefix = Zs, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o) => {
        this.getKey && o !== null && !gi(o) ? this.map.set(this.getKey(o), o) : jz(o) ? this.map.set(o.id, o) : qz(o) && this.map.set(o.topic, o);
      }), this.cached = [], this.initialized = !0);
    }, this.set = async (o, a) => {
      this.isInitialized(), this.map.has(o) ? await this.update(o, a) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o, value: a }), this.map.set(o, a), await this.persist());
    }, this.get = (o) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o }), this.getData(o)), this.getAll = (o) => (this.isInitialized(), o ? this.values.filter((a) => Object.keys(o).every((u) => LH(a[u], o[u]))) : this.values), this.update = async (o, a) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o, update: a });
      const u = P3(P3({}, this.getData(o)), a);
      this.map.set(o, u), await this.persist();
    }, this.delete = async (o, a) => {
      this.isInitialized(), this.map.has(o) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o, reason: a }), this.map.delete(o), this.addToRecentlyDeleted(o), await this.persist());
    }, this.logger = ai(r, this.name), this.storagePrefix = i, this.getKey = s;
  }
  get context() {
    return Si(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const r = this.map.get(e);
    if (!r) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: i } = ft("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(i), new Error(i);
      }
      const { message: n } = ft("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(n), new Error(n);
    }
    return r;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: r } = ft("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class sV {
  constructor(e, r) {
    this.core = e, this.logger = r, this.name = tW, this.version = rW, this.events = new Lv(), this.initialized = !1, this.storagePrefix = Zs, this.ignoredPayloadTypes = [Io], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
    }, this.register = ({ methods: n }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...n])];
    }, this.create = async (n) => {
      this.isInitialized();
      const i = I1(), s = await this.core.crypto.setSymKey(i), o = En(mt.FIVE_MINUTES), a = { protocol: nE }, u = { topic: s, expiry: o, relay: a, active: !1, methods: n == null ? void 0 : n.methods }, l = Xx({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: i, relay: a, expiryTimestamp: o, methods: n == null ? void 0 : n.methods });
      return this.events.emit(Xa.create, u), this.core.expirer.set(s, o), await this.pairings.set(s, u), await this.core.relayer.subscribe(s, { transportType: n == null ? void 0 : n.transportType }), { topic: s, uri: l };
    }, this.pair = async (n) => {
      this.isInitialized();
      const i = this.core.eventClient.createEvent({ properties: { topic: n == null ? void 0 : n.uri, trace: [Fs.pairing_started] } });
      this.isValidPair(n, i);
      const { topic: s, symKey: o, relay: a, expiryTimestamp: u, methods: l } = Jx(n.uri);
      i.props.properties.topic = s, i.addTrace(Fs.pairing_uri_validation_success), i.addTrace(Fs.pairing_uri_not_expired);
      let d;
      if (this.pairings.keys.includes(s)) {
        if (d = this.pairings.get(s), i.addTrace(Fs.existing_pairing), d.active) throw i.setError(yo.active_pairing_already_exists), new Error(`Pairing already exists: ${s}. Please try again with a new connection URI.`);
        i.addTrace(Fs.pairing_not_expired);
      }
      const p = u || En(mt.FIVE_MINUTES), w = { topic: s, relay: a, expiry: p, active: !1, methods: l };
      this.core.expirer.set(s, p), await this.pairings.set(s, w), i.addTrace(Fs.store_new_pairing), n.activatePairing && await this.activate({ topic: s }), this.events.emit(Xa.create, w), i.addTrace(Fs.emit_inactive_pairing), this.core.crypto.keychain.has(s) || await this.core.crypto.setSymKey(o, s), i.addTrace(Fs.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        i.setError(yo.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(s, { relay: a });
      } catch (P) {
        throw i.setError(yo.subscribe_pairing_topic_failure), P;
      }
      return i.addTrace(Fs.subscribe_pairing_topic_success), w;
    }, this.activate = async ({ topic: n }) => {
      this.isInitialized();
      const i = En(mt.THIRTY_DAYS);
      this.core.expirer.set(n, i), await this.pairings.update(n, { active: !0, expiry: i });
    }, this.ping = async (n) => {
      this.isInitialized(), await this.isValidPing(n);
      const { topic: i } = n;
      if (this.pairings.keys.includes(i)) {
        const s = await this.sendRequest(i, "wc_pairingPing", {}), { done: o, resolve: a, reject: u } = Va();
        this.events.once(br("pairing_ping", s), ({ error: l }) => {
          l ? u(l) : a();
        }), await o();
      }
    }, this.updateExpiry = async ({ topic: n, expiry: i }) => {
      this.isInitialized(), await this.pairings.update(n, { expiry: i });
    }, this.updateMetadata = async ({ topic: n, metadata: i }) => {
      this.isInitialized(), await this.pairings.update(n, { peerMetadata: i });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (n) => {
      this.isInitialized(), await this.isValidDisconnect(n);
      const { topic: i } = n;
      this.pairings.keys.includes(i) && (await this.sendRequest(i, "wc_pairingDelete", Or("USER_DISCONNECTED")), await this.deletePairing(i));
    }, this.formatUriFromPairing = (n) => {
      this.isInitialized();
      const { topic: i, relay: s, expiry: o, methods: a } = n, u = this.core.crypto.keychain.get(i);
      return Xx({ protocol: this.core.protocol, version: this.core.version, topic: i, symKey: u, relay: s, expiryTimestamp: o, methods: a });
    }, this.sendRequest = async (n, i, s) => {
      const o = ha(i, s), a = await this.core.crypto.encode(n, o), u = Pf[i].req;
      return this.core.history.set(n, o), this.core.relayer.publish(n, a, u), o.id;
    }, this.sendResult = async (n, i, s) => {
      const o = tp(n, s), a = await this.core.crypto.encode(i, o), u = await this.core.history.get(i, n), l = Pf[u.request.method].res;
      await this.core.relayer.publish(i, a, l), await this.core.history.resolve(o);
    }, this.sendError = async (n, i, s) => {
      const o = rp(n, s), a = await this.core.crypto.encode(i, o), u = await this.core.history.get(i, n), l = Pf[u.request.method] ? Pf[u.request.method].res : Pf.unregistered_method.res;
      await this.core.relayer.publish(i, a, l), await this.core.history.resolve(o);
    }, this.deletePairing = async (n, i) => {
      await this.core.relayer.unsubscribe(n), await Promise.all([this.pairings.delete(n, Or("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(n), i ? Promise.resolve() : this.core.expirer.del(n)]);
    }, this.cleanup = async () => {
      const n = this.pairings.getAll().filter((i) => aa(i.expiry));
      await Promise.all(n.map((i) => this.deletePairing(i.topic)));
    }, this.onRelayEventRequest = (n) => {
      const { topic: i, payload: s } = n;
      switch (s.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i, s);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i, s);
        default:
          return this.onUnknownRpcMethodRequest(i, s);
      }
    }, this.onRelayEventResponse = async (n) => {
      const { topic: i, payload: s } = n, o = (await this.core.history.get(i, s.id)).request.method;
      switch (o) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i, s);
        default:
          return this.onUnknownRpcMethodResponse(o);
      }
    }, this.onPairingPingRequest = async (n, i) => {
      const { id: s } = i;
      try {
        this.isValidPing({ topic: n }), await this.sendResult(s, n, !0), this.events.emit(Xa.ping, { id: s, topic: n });
      } catch (o) {
        await this.sendError(s, n, o), this.logger.error(o);
      }
    }, this.onPairingPingResponse = (n, i) => {
      const { id: s } = i;
      setTimeout(() => {
        Bs(i) ? this.events.emit(br("pairing_ping", s), {}) : Zi(i) && this.events.emit(br("pairing_ping", s), { error: i.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (n, i) => {
      const { id: s } = i;
      try {
        this.isValidDisconnect({ topic: n }), await this.deletePairing(n), this.events.emit(Xa.delete, { id: s, topic: n });
      } catch (o) {
        await this.sendError(s, n, o), this.logger.error(o);
      }
    }, this.onUnknownRpcMethodRequest = async (n, i) => {
      const { id: s, method: o } = i;
      try {
        if (this.registeredMethods.includes(o)) return;
        const a = Or("WC_METHOD_UNSUPPORTED", o);
        await this.sendError(s, n, a), this.logger.error(a);
      } catch (a) {
        await this.sendError(s, n, a), this.logger.error(a);
      }
    }, this.onUnknownRpcMethodResponse = (n) => {
      this.registeredMethods.includes(n) || this.logger.error(Or("WC_METHOD_UNSUPPORTED", n));
    }, this.isValidPair = (n, i) => {
      var s;
      if (!pi(n)) {
        const { message: a } = ft("MISSING_OR_INVALID", `pair() params: ${n}`);
        throw i.setError(yo.malformed_pairing_uri), new Error(a);
      }
      if (!Uz(n.uri)) {
        const { message: a } = ft("MISSING_OR_INVALID", `pair() uri: ${n.uri}`);
        throw i.setError(yo.malformed_pairing_uri), new Error(a);
      }
      const o = Jx(n == null ? void 0 : n.uri);
      if (!((s = o == null ? void 0 : o.relay) != null && s.protocol)) {
        const { message: a } = ft("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw i.setError(yo.malformed_pairing_uri), new Error(a);
      }
      if (!(o != null && o.symKey)) {
        const { message: a } = ft("MISSING_OR_INVALID", "pair() uri#symKey");
        throw i.setError(yo.malformed_pairing_uri), new Error(a);
      }
      if (o != null && o.expiryTimestamp && mt.toMiliseconds(o == null ? void 0 : o.expiryTimestamp) < Date.now()) {
        i.setError(yo.pairing_expired);
        const { message: a } = ft("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a);
      }
    }, this.isValidPing = async (n) => {
      if (!pi(n)) {
        const { message: s } = ft("MISSING_OR_INVALID", `ping() params: ${n}`);
        throw new Error(s);
      }
      const { topic: i } = n;
      await this.isValidPairingTopic(i);
    }, this.isValidDisconnect = async (n) => {
      if (!pi(n)) {
        const { message: s } = ft("MISSING_OR_INVALID", `disconnect() params: ${n}`);
        throw new Error(s);
      }
      const { topic: i } = n;
      await this.isValidPairingTopic(i);
    }, this.isValidPairingTopic = async (n) => {
      if (!dn(n, !1)) {
        const { message: i } = ft("MISSING_OR_INVALID", `pairing topic should be a string: ${n}`);
        throw new Error(i);
      }
      if (!this.pairings.keys.includes(n)) {
        const { message: i } = ft("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n}`);
        throw new Error(i);
      }
      if (aa(this.pairings.get(n).expiry)) {
        await this.deletePairing(n);
        const { message: i } = ft("EXPIRED", `pairing topic: ${n}`);
        throw new Error(i);
      }
    }, this.core = e, this.logger = ai(r, this.name), this.pairings = new _c(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return Si(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(si.message, async (e) => {
      const { topic: r, message: n, transportType: i } = e;
      if (!this.pairings.keys.includes(r) || i === zr.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(n))) return;
      const s = await this.core.crypto.decode(r, n);
      try {
        ub(s) ? (this.core.history.set(r, s), this.onRelayEventRequest({ topic: r, payload: s })) : np(s) && (await this.core.history.resolve(s), await this.onRelayEventResponse({ topic: r, payload: s }), this.core.history.delete(r, s.id));
      } catch (o) {
        this.logger.error(o);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(Ji.expired, async (e) => {
      const { topic: r } = $8(e.target);
      r && this.pairings.keys.includes(r) && (await this.deletePairing(r, !0), this.events.emit(Xa.expire, { topic: r }));
    });
  }
}
class oV extends Bk {
  constructor(e, r) {
    super(e, r), this.core = e, this.logger = r, this.records = /* @__PURE__ */ new Map(), this.events = new rs.EventEmitter(), this.name = nW, this.version = iW, this.cached = [], this.initialized = !1, this.storagePrefix = Zs, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.records.set(n.id, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.set = (n, i, s) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: n, request: i, chainId: s }), this.records.has(i.id)) return;
      const o = { id: i.id, topic: n, request: { method: i.method, params: i.params || null }, chainId: s, expiry: En(mt.THIRTY_DAYS) };
      this.records.set(o.id, o), this.persist(), this.events.emit(gs.created, o);
    }, this.resolve = async (n) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: n }), !this.records.has(n.id)) return;
      const i = await this.getRecord(n.id);
      typeof i.response > "u" && (i.response = Zi(n) ? { error: n.error } : { result: n.result }, this.records.set(i.id, i), this.persist(), this.events.emit(gs.updated, i));
    }, this.get = async (n, i) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: n, id: i }), await this.getRecord(i)), this.delete = (n, i) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i }), this.values.forEach((s) => {
        if (s.topic === n) {
          if (typeof i < "u" && s.id !== i) return;
          this.records.delete(s.id), this.events.emit(gs.deleted, s);
        }
      }), this.persist();
    }, this.exists = async (n, i) => (this.isInitialized(), this.records.has(i) ? (await this.getRecord(i)).topic === n : !1), this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.logger = ai(r, this.name);
  }
  get context() {
    return Si(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((r) => {
      if (typeof r.response < "u") return;
      const n = { topic: r.topic, request: ha(r.request.method, r.request.params, r.id), chainId: r.chainId };
      return e.push(n);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const r = this.records.get(e);
    if (!r) {
      const { message: n } = ft("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return r;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(gs.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: r } = ft("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(gs.created, (e) => {
      const r = gs.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e });
    }), this.events.on(gs.updated, (e) => {
      const r = gs.updated;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e });
    }), this.events.on(gs.deleted, (e) => {
      const r = gs.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e });
    }), this.core.heartbeat.on(Du.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = !1;
      this.records.forEach((r) => {
        mt.toMiliseconds(r.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${r.id}`), this.records.delete(r.id), this.events.emit(gs.deleted, r, !1), e = !0);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class aV extends Wk {
  constructor(e, r) {
    super(e, r), this.core = e, this.logger = r, this.expirations = /* @__PURE__ */ new Map(), this.events = new rs.EventEmitter(), this.name = sW, this.version = oW, this.cached = [], this.initialized = !1, this.storagePrefix = Zs, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.expirations.set(n.target, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.has = (n) => {
      try {
        const i = this.formatTarget(n);
        return typeof this.getExpiration(i) < "u";
      } catch {
        return !1;
      }
    }, this.set = (n, i) => {
      this.isInitialized();
      const s = this.formatTarget(n), o = { target: s, expiry: i };
      this.expirations.set(s, o), this.checkExpiry(s, o), this.events.emit(Ji.created, { target: s, expiration: o });
    }, this.get = (n) => {
      this.isInitialized();
      const i = this.formatTarget(n);
      return this.getExpiration(i);
    }, this.del = (n) => {
      if (this.isInitialized(), this.has(n)) {
        const i = this.formatTarget(n), s = this.getExpiration(i);
        this.expirations.delete(i), this.events.emit(Ji.deleted, { target: i, expiration: s });
      }
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.logger = ai(r, this.name);
  }
  get context() {
    return Si(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return Nq(e);
    if (typeof e == "number") return Lq(e);
    const { message: r } = ft("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(r);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(Ji.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: r } = ft("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const r = this.expirations.get(e);
    if (!r) {
      const { message: n } = ft("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(n), new Error(n);
    }
    return r;
  }
  checkExpiry(e, r) {
    const { expiry: n } = r;
    mt.toMiliseconds(n) - Date.now() <= 0 && this.expire(e, r);
  }
  expire(e, r) {
    this.expirations.delete(e), this.events.emit(Ji.expired, { target: e, expiration: r });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, r) => this.checkExpiry(r, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(Du.pulse, () => this.checkExpirations()), this.events.on(Ji.created, (e) => {
      const r = Ji.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    }), this.events.on(Ji.expired, (e) => {
      const r = Ji.expired;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    }), this.events.on(Ji.deleted, (e) => {
      const r = Ji.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class cV extends Kk {
  constructor(e, r, n) {
    super(e, r, n), this.core = e, this.logger = r, this.store = n, this.name = aW, this.verifyUrlV3 = uW, this.storagePrefix = Zs, this.version = tE, this.init = async () => {
      var i;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && mt.toMiliseconds((i = this.publicKey) == null ? void 0 : i.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }, this.register = async (i) => {
      if (!Xl() || this.isDevEnv) return;
      const s = window.location.origin, { id: o, decryptedId: a } = i, u = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${s}&id=${o}&decryptedId=${a}`;
      try {
        const l = Wl(), d = this.startAbortTimer(mt.ONE_SECOND * 5), p = await new Promise((w, P) => {
          const A = () => {
            window.removeEventListener("message", L), l.body.removeChild(N), P("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", A);
          const N = l.createElement("iframe");
          N.src = u, N.style.display = "none", N.addEventListener("error", A, { signal: this.abortController.signal });
          const L = (F) => {
            if (F.data && typeof F.data == "string") try {
              const $ = JSON.parse(F.data);
              if ($.type === "verify_attestation") {
                if (v1($.attestation).payload.id !== o) return;
                clearInterval(d), l.body.removeChild(N), this.abortController.signal.removeEventListener("abort", A), window.removeEventListener("message", L), w($.attestation === null ? "" : $.attestation);
              }
            } catch ($) {
              this.logger.warn($);
            }
          };
          l.body.appendChild(N), window.addEventListener("message", L, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", p), p;
      } catch (l) {
        this.logger.warn(l);
      }
      return "";
    }, this.resolve = async (i) => {
      if (this.isDevEnv) return "";
      const { attestationId: s, hash: o, encryptedId: a } = i;
      if (s === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (s) {
        if (v1(s).payload.id !== a) return;
        const l = await this.isValidJwtAttestation(s);
        if (l) {
          if (!l.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return l;
        }
      }
      if (!o) return;
      const u = this.getVerifyUrl(i == null ? void 0 : i.verifyUrl);
      return this.fetchAttestation(o, u);
    }, this.fetchAttestation = async (i, s) => {
      this.logger.debug(`resolving attestation: ${i} from url: ${s}`);
      const o = this.startAbortTimer(mt.ONE_SECOND * 5), a = await fetch(`${s}/attestation/${i}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o), a.status === 200 ? await a.json() : void 0;
    }, this.getVerifyUrl = (i) => {
      let s = i || zf;
      return fW.includes(s) || (this.logger.info(`verify url: ${s}, not included in trusted list, assigning default: ${zf}`), s = zf), s;
    }, this.fetchPublicKey = async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const i = this.startAbortTimer(mt.FIVE_SECONDS), s = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(i), await s.json();
      } catch (i) {
        this.logger.warn(i);
      }
    }, this.persistPublicKey = async (i) => {
      this.logger.debug("persisting public key to local storage", i), await this.store.setItem(this.storeKey, i), this.publicKey = i;
    }, this.removePublicKey = async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }, this.isValidJwtAttestation = async (i) => {
      const s = await this.getPublicKey();
      try {
        if (s) return this.validateAttestation(i, s);
      } catch (a) {
        this.logger.error(a), this.logger.warn("error validating attestation");
      }
      const o = await this.fetchAndPersistPublicKey();
      try {
        if (o) return this.validateAttestation(i, o);
      } catch (a) {
        this.logger.error(a), this.logger.warn("error validating attestation");
      }
    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (s) => {
        const o = await this.fetchPublicKey();
        o && (await this.persistPublicKey(o), s(o));
      });
      const i = await this.fetchPromise;
      return this.fetchPromise = void 0, i;
    }, this.validateAttestation = (i, s) => {
      const o = xz(i, s.publicKey), a = { hasExpired: mt.toMiliseconds(o.exp) < Date.now(), payload: o };
      if (a.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a.payload.origin, isScam: a.payload.isScam, isVerified: a.payload.isVerified };
    }, this.logger = ai(r, this.name), this.abortController = new AbortController(), this.isDevEnv = nb(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return Si(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), mt.toMiliseconds(e));
  }
}
class uV extends Vk {
  constructor(e, r) {
    super(e, r), this.projectId = e, this.logger = r, this.context = lW, this.registerDeviceToken = async (n) => {
      const { clientId: i, token: s, notificationType: o, enableEncrypted: a = !1 } = n, u = `${hW}/${this.projectId}/clients`;
      await fetch(u, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i, type: o, token: s, always_raw: a }) });
    }, this.logger = ai(r, this.context);
  }
}
var fV = Object.defineProperty, M3 = Object.getOwnPropertySymbols, lV = Object.prototype.hasOwnProperty, hV = Object.prototype.propertyIsEnumerable, I3 = (t, e, r) => e in t ? fV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Cf = (t, e) => {
  for (var r in e || (e = {})) lV.call(e, r) && I3(t, r, e[r]);
  if (M3) for (var r of M3(e)) hV.call(e, r) && I3(t, r, e[r]);
  return t;
};
class dV extends Gk {
  constructor(e, r, n = !0) {
    super(e, r, n), this.core = e, this.logger = r, this.context = pW, this.storagePrefix = Zs, this.storageVersion = dW, this.events = /* @__PURE__ */ new Map(), this.shouldPersist = !1, this.init = async () => {
      if (!nb()) try {
        const i = { eventId: Fx(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: O8(this.core.relayer.protocol, this.core.relayer.version, T1) } } };
        await this.sendEvent([i]);
      } catch (i) {
        this.logger.warn(i);
      }
    }, this.createEvent = (i) => {
      const { event: s = "ERROR", type: o = "", properties: { topic: a, trace: u } } = i, l = Fx(), d = this.core.projectId || "", p = Date.now(), w = Cf({ eventId: l, timestamp: p, props: { event: s, type: o, properties: { topic: a, trace: u } }, bundleId: d, domain: this.getAppDomain() }, this.setMethods(l));
      return this.telemetryEnabled && (this.events.set(l, w), this.shouldPersist = !0), w;
    }, this.getEvent = (i) => {
      const { eventId: s, topic: o } = i;
      if (s) return this.events.get(s);
      const a = Array.from(this.events.values()).find((u) => u.props.properties.topic === o);
      if (a) return Cf(Cf({}, a), this.setMethods(a.eventId));
    }, this.deleteEvent = (i) => {
      const { eventId: s } = i;
      this.events.delete(s), this.shouldPersist = !0;
    }, this.setEventListeners = () => {
      this.core.heartbeat.on(Du.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((i) => {
          mt.fromMiliseconds(Date.now()) - mt.fromMiliseconds(i.timestamp) > gW && (this.events.delete(i.eventId), this.shouldPersist = !0);
        });
      });
    }, this.setMethods = (i) => ({ addTrace: (s) => this.addTrace(i, s), setError: (s) => this.setError(i, s) }), this.addTrace = (i, s) => {
      const o = this.events.get(i);
      o && (o.props.properties.trace.push(s), this.events.set(i, o), this.shouldPersist = !0);
    }, this.setError = (i, s) => {
      const o = this.events.get(i);
      o && (o.props.type = s, o.timestamp = Date.now(), this.events.set(i, o), this.shouldPersist = !0);
    }, this.persist = async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = !1;
    }, this.restore = async () => {
      try {
        const i = await this.core.storage.getItem(this.storageKey) || [];
        if (!i.length) return;
        i.forEach((s) => {
          this.events.set(s.eventId, Cf(Cf({}, s), this.setMethods(s.eventId)));
        });
      } catch (i) {
        this.logger.warn(i);
      }
    }, this.submit = async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const i = [];
      for (const [s, o] of this.events) o.props.type && i.push(o);
      if (i.length !== 0) try {
        if ((await this.sendEvent(i)).ok) for (const s of i) this.events.delete(s.eventId), this.shouldPersist = !0;
      } catch (s) {
        this.logger.warn(s);
      }
    }, this.sendEvent = async (i) => {
      const s = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${mW}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${T1}${s}`, { method: "POST", body: JSON.stringify(i) });
    }, this.getAppDomain = () => D8().url, this.logger = ai(r, this.context), this.telemetryEnabled = n, n ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
}
var pV = Object.defineProperty, C3 = Object.getOwnPropertySymbols, gV = Object.prototype.hasOwnProperty, mV = Object.prototype.propertyIsEnumerable, T3 = (t, e, r) => e in t ? pV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, R3 = (t, e) => {
  for (var r in e || (e = {})) gV.call(e, r) && T3(t, r, e[r]);
  if (C3) for (var r of C3(e)) mV.call(e, r) && T3(t, r, e[r]);
  return t;
};
class fb extends Fk {
  constructor(e) {
    var r;
    super(e), this.protocol = eE, this.version = tE, this.name = rE, this.events = new rs.EventEmitter(), this.initialized = !1, this.on = (o, a) => this.events.on(o, a), this.once = (o, a) => this.events.once(o, a), this.off = (o, a) => this.events.off(o, a), this.removeListener = (o, a) => this.events.removeListener(o, a), this.dispatchEnvelope = ({ topic: o, message: a, sessionExists: u }) => {
      if (!o || !a) return;
      const l = { topic: o, message: a, publishedAt: Date.now(), transportType: zr.link_mode };
      this.relayer.onLinkMessageEvent(l, { sessionExists: u });
    }, this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || iE, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const n = k0({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : kH.logger }), { logger: i, chunkLoggerController: s } = $k({ opts: n, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = s, (r = this.logChunkController) != null && r.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var o, a;
      (o = this.logChunkController) != null && o.downloadLogsBlobInBrowser && ((a = this.logChunkController) == null || a.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = ai(i, this.name), this.heartbeat = new RL(), this.crypto = new qK(this, this.logger, e == null ? void 0 : e.keychain), this.history = new oV(this, this.logger), this.expirer = new aV(this, this.logger), this.storage = e != null && e.storage ? e.storage : new uk(R3(R3({}, $H), e == null ? void 0 : e.storageOptions)), this.relayer = new tV({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new sV(this, this.logger), this.verify = new cV(this, this.logger, this.storage), this.echoClient = new uV(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new dV(this, this.logger, e == null ? void 0 : e.telemetryEnabled);
  }
  static async init(e) {
    const r = new fb(e);
    await r.initialize();
    const n = await r.crypto.getClientId();
    return await r.storage.setItem(XH, n), r;
  }
  get context() {
    return Si(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(h3, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.eventClient.init(), this.linkModeSupportedApps = await this.storage.getItem(h3) || [], this.initialized = !0, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
}
const vV = fb, mE = "wc", vE = 2, bE = "client", lb = `${mE}@${vE}:${bE}:`, mm = { name: bE, logger: "error" }, D3 = "WALLETCONNECT_DEEPLINK_CHOICE", bV = "proposal", yE = "Proposal expired", yV = "session", Wc = mt.SEVEN_DAYS, wV = "engine", In = { wc_sessionPropose: { req: { ttl: mt.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1101 }, reject: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1120 }, autoReject: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1121 } }, wc_sessionSettle: { req: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: mt.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: mt.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: mt.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: mt.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: mt.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: mt.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: mt.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: mt.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: mt.ONE_DAY, prompt: !1, tag: 1114 }, res: { ttl: mt.ONE_DAY, prompt: !1, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: mt.ONE_HOUR, prompt: !0, tag: 1116 }, res: { ttl: mt.ONE_HOUR, prompt: !1, tag: 1117 }, reject: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1118 }, autoReject: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1119 } } }, vm = { min: mt.FIVE_MINUTES, max: mt.SEVEN_DAYS }, Ls = { idle: "IDLE", active: "ACTIVE" }, xV = "request", _V = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"], EV = "wc", SV = "auth", AV = "authKeys", PV = "pairingTopics", MV = "requests", sp = `${EV}@${1.5}:${SV}:`, Td = `${sp}:PUB_KEY`;
var IV = Object.defineProperty, CV = Object.defineProperties, TV = Object.getOwnPropertyDescriptors, O3 = Object.getOwnPropertySymbols, RV = Object.prototype.hasOwnProperty, DV = Object.prototype.propertyIsEnumerable, N3 = (t, e, r) => e in t ? IV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, tn = (t, e) => {
  for (var r in e || (e = {})) RV.call(e, r) && N3(t, r, e[r]);
  if (O3) for (var r of O3(e)) DV.call(e, r) && N3(t, r, e[r]);
  return t;
}, vs = (t, e) => CV(t, TV(e));
class OV extends Jk {
  constructor(e) {
    super(e), this.name = wV, this.events = new Lv(), this.initialized = !1, this.requestQueue = { state: Ls.idle, queue: [] }, this.sessionRequestQueue = { state: Ls.idle, queue: [] }, this.requestQueueDelay = mt.ONE_SECOND, this.expectedPairingMethodMap = /* @__PURE__ */ new Map(), this.recentlyDeletedMap = /* @__PURE__ */ new Map(), this.recentlyDeletedLimit = 200, this.relayMessageCache = [], this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(In) }), this.initialized = !0, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, mt.toMiliseconds(this.requestQueueDelay)));
    }, this.connect = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const n = vs(tn({}, r), { requiredNamespaces: r.requiredNamespaces || {}, optionalNamespaces: r.optionalNamespaces || {} });
      await this.isValidConnect(n);
      const { pairingTopic: i, requiredNamespaces: s, optionalNamespaces: o, sessionProperties: a, relays: u } = n;
      let l = i, d, p = !1;
      try {
        l && (p = this.client.core.pairing.pairings.get(l).active);
      } catch (H) {
        throw this.client.logger.error(`connect() -> pairing.get(${l}) failed`), H;
      }
      if (!l || !p) {
        const { topic: H, uri: V } = await this.client.core.pairing.create();
        l = H, d = V;
      }
      if (!l) {
        const { message: H } = ft("NO_MATCHING_KEY", `connect() pairing topic: ${l}`);
        throw new Error(H);
      }
      const w = await this.client.core.crypto.generateKeyPair(), P = In.wc_sessionPropose.req.ttl || mt.FIVE_MINUTES, A = En(P), N = tn({ requiredNamespaces: s, optionalNamespaces: o, relays: u ?? [{ protocol: nE }], proposer: { publicKey: w, metadata: this.client.metadata }, expiryTimestamp: A, pairingTopic: l }, a && { sessionProperties: a }), { reject: L, resolve: F, done: $ } = Va(P, yE);
      this.events.once(br("session_connect"), async ({ error: H, session: V }) => {
        if (H) L(H);
        else if (V) {
          V.self.publicKey = w;
          const te = vs(tn({}, V), { pairingTopic: N.pairingTopic, requiredNamespaces: N.requiredNamespaces, optionalNamespaces: N.optionalNamespaces, transportType: zr.relay });
          await this.client.session.set(V.topic, te), await this.setExpiry(V.topic, V.expiry), l && await this.client.core.pairing.updateMetadata({ topic: l, metadata: V.peer.metadata }), this.cleanupDuplicatePairings(te), F(te);
        }
      });
      const K = await this.sendRequest({ topic: l, method: "wc_sessionPropose", params: N, throwOnFailedPublish: !0 });
      return await this.setProposal(K, tn({ id: K }, N)), { uri: d, approval: $ };
    }, this.pair = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(r);
      } catch (n) {
        throw this.client.logger.error("pair() failed"), n;
      }
    }, this.approve = async (r) => {
      var n, i, s;
      const o = this.client.core.eventClient.createEvent({ properties: { topic: (n = r == null ? void 0 : r.id) == null ? void 0 : n.toString(), trace: [ms.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (W) {
        throw o.setError(Ha.no_internet_connection), W;
      }
      try {
        await this.isValidProposalId(r == null ? void 0 : r.id);
      } catch (W) {
        throw this.client.logger.error(`approve() -> proposal.get(${r == null ? void 0 : r.id}) failed`), o.setError(Ha.proposal_not_found), W;
      }
      try {
        await this.isValidApprove(r);
      } catch (W) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), o.setError(Ha.session_approve_namespace_validation_failure), W;
      }
      const { id: a, relayProtocol: u, namespaces: l, sessionProperties: d, sessionConfig: p } = r, w = this.client.proposal.get(a);
      this.client.core.eventClient.deleteEvent({ eventId: o.eventId });
      const { pairingTopic: P, proposer: A, requiredNamespaces: N, optionalNamespaces: L } = w;
      let F = (i = this.client.core.eventClient) == null ? void 0 : i.getEvent({ topic: P });
      F || (F = (s = this.client.core.eventClient) == null ? void 0 : s.createEvent({ type: ms.session_approve_started, properties: { topic: P, trace: [ms.session_approve_started, ms.session_namespaces_validation_success] } }));
      const $ = await this.client.core.crypto.generateKeyPair(), K = A.publicKey, H = await this.client.core.crypto.generateSharedKey($, K), V = tn(tn({ relay: { protocol: u ?? "irn" }, namespaces: l, controller: { publicKey: $, metadata: this.client.metadata }, expiry: En(Wc) }, d && { sessionProperties: d }), p && { sessionConfig: p }), te = zr.relay;
      F.addTrace(ms.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(H, { transportType: te });
      } catch (W) {
        throw F.setError(Ha.subscribe_session_topic_failure), W;
      }
      F.addTrace(ms.subscribe_session_topic_success);
      const R = vs(tn({}, V), { topic: H, requiredNamespaces: N, optionalNamespaces: L, pairingTopic: P, acknowledged: !1, self: V.controller, peer: { publicKey: A.publicKey, metadata: A.metadata }, controller: $, transportType: zr.relay });
      await this.client.session.set(H, R), F.addTrace(ms.store_session);
      try {
        F.addTrace(ms.publishing_session_settle), await this.sendRequest({ topic: H, method: "wc_sessionSettle", params: V, throwOnFailedPublish: !0 }).catch((W) => {
          throw F == null || F.setError(Ha.session_settle_publish_failure), W;
        }), F.addTrace(ms.session_settle_publish_success), F.addTrace(ms.publishing_session_approve), await this.sendResult({ id: a, topic: P, result: { relay: { protocol: u ?? "irn" }, responderPublicKey: $ }, throwOnFailedPublish: !0 }).catch((W) => {
          throw F == null || F.setError(Ha.session_approve_publish_failure), W;
        }), F.addTrace(ms.session_approve_publish_success);
      } catch (W) {
        throw this.client.logger.error(W), this.client.session.delete(H, Or("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(H), W;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: F.eventId }), await this.client.core.pairing.updateMetadata({ topic: P, metadata: A.metadata }), await this.client.proposal.delete(a, Or("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: P }), await this.setExpiry(H, En(Wc)), { topic: H, acknowledged: () => Promise.resolve(this.client.session.get(H)) };
    }, this.reject = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(r);
      } catch (o) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), o;
      }
      const { id: n, reason: i } = r;
      let s;
      try {
        s = this.client.proposal.get(n).pairingTopic;
      } catch (o) {
        throw this.client.logger.error(`reject() -> proposal.get(${n}) failed`), o;
      }
      s && (await this.sendError({ id: n, topic: s, error: i, rpcOpts: In.wc_sessionPropose.reject }), await this.client.proposal.delete(n, Or("USER_DISCONNECTED")));
    }, this.update = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(r);
      } catch (p) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), p;
      }
      const { topic: n, namespaces: i } = r, { done: s, resolve: o, reject: a } = Va(), u = ca(), l = rc().toString(), d = this.client.session.get(n).namespaces;
      return this.events.once(br("session_update", u), ({ error: p }) => {
        p ? a(p) : o();
      }), await this.client.session.update(n, { namespaces: i }), await this.sendRequest({ topic: n, method: "wc_sessionUpdate", params: { namespaces: i }, throwOnFailedPublish: !0, clientRpcId: u, relayRpcId: l }).catch((p) => {
        this.client.logger.error(p), this.client.session.update(n, { namespaces: d }), a(p);
      }), { acknowledged: s };
    }, this.extend = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(r);
      } catch (u) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), u;
      }
      const { topic: n } = r, i = ca(), { done: s, resolve: o, reject: a } = Va();
      return this.events.once(br("session_extend", i), ({ error: u }) => {
        u ? a(u) : o();
      }), await this.setExpiry(n, En(Wc)), this.sendRequest({ topic: n, method: "wc_sessionExtend", params: {}, clientRpcId: i, throwOnFailedPublish: !0 }).catch((u) => {
        a(u);
      }), { acknowledged: s };
    }, this.request = async (r) => {
      this.isInitialized();
      try {
        await this.isValidRequest(r);
      } catch (A) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), A;
      }
      const { chainId: n, request: i, topic: s, expiry: o = In.wc_sessionRequest.req.ttl } = r, a = this.client.session.get(s);
      (a == null ? void 0 : a.transportType) === zr.relay && await this.confirmOnlineStateOrThrow();
      const u = ca(), l = rc().toString(), { done: d, resolve: p, reject: w } = Va(o, "Request expired. Please try again.");
      this.events.once(br("session_request", u), ({ error: A, result: N }) => {
        A ? w(A) : p(N);
      });
      const P = this.getAppLinkIfEnabled(a.peer.metadata, a.transportType);
      return P ? (await this.sendRequest({ clientRpcId: u, relayRpcId: l, topic: s, method: "wc_sessionRequest", params: { request: vs(tn({}, i), { expiryTimestamp: En(o) }), chainId: n }, expiry: o, throwOnFailedPublish: !0, appLink: P }).catch((A) => w(A)), this.client.events.emit("session_request_sent", { topic: s, request: i, chainId: n, id: u }), await d()) : await Promise.all([new Promise(async (A) => {
        await this.sendRequest({ clientRpcId: u, relayRpcId: l, topic: s, method: "wc_sessionRequest", params: { request: vs(tn({}, i), { expiryTimestamp: En(o) }), chainId: n }, expiry: o, throwOnFailedPublish: !0 }).catch((N) => w(N)), this.client.events.emit("session_request_sent", { topic: s, request: i, chainId: n, id: u }), A();
      }), new Promise(async (A) => {
        var N;
        if (!((N = a.sessionConfig) != null && N.disableDeepLink)) {
          const L = await Fq(this.client.core.storage, D3);
          await kq({ id: u, topic: s, wcDeepLink: L });
        }
        A();
      }), d()]).then((A) => A[2]);
    }, this.respond = async (r) => {
      this.isInitialized(), await this.isValidRespond(r);
      const { topic: n, response: i } = r, { id: s } = i, o = this.client.session.get(n);
      o.transportType === zr.relay && await this.confirmOnlineStateOrThrow();
      const a = this.getAppLinkIfEnabled(o.peer.metadata, o.transportType);
      Bs(i) ? await this.sendResult({ id: s, topic: n, result: i.result, throwOnFailedPublish: !0, appLink: a }) : Zi(i) && await this.sendError({ id: s, topic: n, error: i.error, appLink: a }), this.cleanupAfterResponse(r);
    }, this.ping = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(r);
      } catch (i) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), i;
      }
      const { topic: n } = r;
      if (this.client.session.keys.includes(n)) {
        const i = ca(), s = rc().toString(), { done: o, resolve: a, reject: u } = Va();
        this.events.once(br("session_ping", i), ({ error: l }) => {
          l ? u(l) : a();
        }), await Promise.all([this.sendRequest({ topic: n, method: "wc_sessionPing", params: {}, throwOnFailedPublish: !0, clientRpcId: i, relayRpcId: s }), o()]);
      } else this.client.core.pairing.pairings.keys.includes(n) && await this.client.core.pairing.ping({ topic: n });
    }, this.emit = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(r);
      const { topic: n, event: i, chainId: s } = r, o = rc().toString();
      await this.sendRequest({ topic: n, method: "wc_sessionEvent", params: { event: i, chainId: s }, throwOnFailedPublish: !0, relayRpcId: o });
    }, this.disconnect = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(r);
      const { topic: n } = r;
      if (this.client.session.keys.includes(n)) await this.sendRequest({ topic: n, method: "wc_sessionDelete", params: Or("USER_DISCONNECTED"), throwOnFailedPublish: !0 }), await this.deleteSession({ topic: n, emitEvent: !1 });
      else if (this.client.core.pairing.pairings.keys.includes(n)) await this.client.core.pairing.disconnect({ topic: n });
      else {
        const { message: i } = ft("MISMATCHED_TOPIC", `Session or pairing topic not found: ${n}`);
        throw new Error(i);
      }
    }, this.find = (r) => (this.isInitialized(), this.client.session.getAll().filter((n) => Fz(n, r))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (r, n) => {
      var i;
      this.isInitialized(), this.isValidAuthenticate(r);
      const s = n && this.client.core.linkModeSupportedApps.includes(n) && ((i = this.client.metadata.redirect) == null ? void 0 : i.linkMode), o = s ? zr.link_mode : zr.relay;
      o === zr.relay && await this.confirmOnlineStateOrThrow();
      const { chains: a, statement: u = "", uri: l, domain: d, nonce: p, type: w, exp: P, nbf: A, methods: N = [], expiry: L } = r, F = [...r.resources || []], { topic: $, uri: K } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: o });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: $, uri: K } });
      const H = await this.client.core.crypto.generateKeyPair(), V = Cd(H);
      if (await Promise.all([this.client.auth.authKeys.set(Td, { responseTopic: V, publicKey: H }), this.client.auth.pairingTopics.set(V, { topic: V, pairingTopic: $ })]), await this.client.core.relayer.subscribe(V, { transportType: o }), this.client.logger.info(`sending request to new pairing topic: ${$}`), N.length > 0) {
        const { namespace: _ } = lu(a[0]);
        let E = sz(_, "request", N);
        Id(F) && (E = az(E, F.pop())), F.push(E);
      }
      const te = L && L > In.wc_sessionAuthenticate.req.ttl ? L : In.wc_sessionAuthenticate.req.ttl, R = { authPayload: { type: w ?? "caip122", chains: a, statement: u, aud: l, domain: d, version: "1", nonce: p, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: P, nbf: A, resources: F }, requester: { publicKey: H, metadata: this.client.metadata }, expiryTimestamp: En(te) }, W = { eip155: { chains: a, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...N])], events: ["chainChanged", "accountsChanged"] } }, pe = { requiredNamespaces: {}, optionalNamespaces: W, relays: [{ protocol: "irn" }], pairingTopic: $, proposer: { publicKey: H, metadata: this.client.metadata }, expiryTimestamp: En(In.wc_sessionPropose.req.ttl) }, { done: Ee, resolve: Y, reject: S } = Va(te, "Request expired"), m = async ({ error: _, session: E }) => {
        if (this.events.off(br("session_request", g), f), _) S(_);
        else if (E) {
          E.self.publicKey = H, await this.client.session.set(E.topic, E), await this.setExpiry(E.topic, E.expiry), $ && await this.client.core.pairing.updateMetadata({ topic: $, metadata: E.peer.metadata });
          const v = this.client.session.get(E.topic);
          await this.deleteProposal(b), Y({ session: v });
        }
      }, f = async (_) => {
        var E, v, M;
        if (await this.deletePendingAuthRequest(g, { message: "fulfilled", code: 0 }), _.error) {
          const J = Or("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return _.error.code === J.code ? void 0 : (this.events.off(br("session_connect"), m), S(_.error.message));
        }
        await this.deleteProposal(b), this.events.off(br("session_connect"), m);
        const { cacaos: I, responder: B } = _.result, ce = [], D = [];
        for (const J of I) {
          await jx({ cacao: J, projectId: this.client.core.projectId }) || (this.client.logger.error(J, "Signature verification failed"), S(Or("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: Q } = J, T = Id(Q.resources), X = [M1(Q.iss)], re = c0(Q.iss);
          if (T) {
            const de = qx(T), ie = zx(T);
            ce.push(...de), X.push(...ie);
          }
          for (const de of X) D.push(`${de}:${re}`);
        }
        const oe = await this.client.core.crypto.generateSharedKey(H, B.publicKey);
        let Z;
        ce.length > 0 && (Z = { topic: oe, acknowledged: !0, self: { publicKey: H, metadata: this.client.metadata }, peer: B, controller: B.publicKey, expiry: En(Wc), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: $, namespaces: Zx([...new Set(ce)], [...new Set(D)]), transportType: o }, await this.client.core.relayer.subscribe(oe, { transportType: o }), await this.client.session.set(oe, Z), $ && await this.client.core.pairing.updateMetadata({ topic: $, metadata: B.metadata }), Z = this.client.session.get(oe)), (E = this.client.metadata.redirect) != null && E.linkMode && (v = B.metadata.redirect) != null && v.linkMode && (M = B.metadata.redirect) != null && M.universal && n && (this.client.core.addLinkModeSupportedApp(B.metadata.redirect.universal), this.client.session.update(oe, { transportType: zr.link_mode })), Y({ auths: I, session: Z });
      }, g = ca(), b = ca();
      this.events.once(br("session_connect"), m), this.events.once(br("session_request", g), f);
      let x;
      try {
        if (s) {
          const _ = ha("wc_sessionAuthenticate", R, g);
          this.client.core.history.set($, _);
          const E = await this.client.core.crypto.encode("", _, { type: eh, encoding: Sf });
          x = ud(n, $, E);
        } else await Promise.all([this.sendRequest({ topic: $, method: "wc_sessionAuthenticate", params: R, expiry: r.expiry, throwOnFailedPublish: !0, clientRpcId: g }), this.sendRequest({ topic: $, method: "wc_sessionPropose", params: pe, expiry: In.wc_sessionPropose.req.ttl, throwOnFailedPublish: !0, clientRpcId: b })]);
      } catch (_) {
        throw this.events.off(br("session_connect"), m), this.events.off(br("session_request", g), f), _;
      }
      return await this.setProposal(b, tn({ id: b }, pe)), await this.setAuthRequest(g, { request: vs(tn({}, R), { verifyContext: {} }), pairingTopic: $, transportType: o }), { uri: x ?? K, response: Ee };
    }, this.approveSessionAuthenticate = async (r) => {
      const { id: n, auths: i } = r, s = this.client.core.eventClient.createEvent({ properties: { topic: n.toString(), trace: [Wa.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (L) {
        throw s.setError(Mf.no_internet_connection), L;
      }
      const o = this.getPendingAuthRequest(n);
      if (!o) throw s.setError(Mf.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${n}`);
      const a = o.transportType || zr.relay;
      a === zr.relay && await this.confirmOnlineStateOrThrow();
      const u = o.requester.publicKey, l = await this.client.core.crypto.generateKeyPair(), d = Cd(u), p = { type: Io, receiverPublicKey: u, senderPublicKey: l }, w = [], P = [];
      for (const L of i) {
        if (!await jx({ cacao: L, projectId: this.client.core.projectId })) {
          s.setError(Mf.invalid_cacao);
          const V = Or("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: n, topic: d, error: V, encodeOpts: p }), new Error(V.message);
        }
        s.addTrace(Wa.cacaos_verified);
        const { p: F } = L, $ = Id(F.resources), K = [M1(F.iss)], H = c0(F.iss);
        if ($) {
          const V = qx($), te = zx($);
          w.push(...V), K.push(...te);
        }
        for (const V of K) P.push(`${V}:${H}`);
      }
      const A = await this.client.core.crypto.generateSharedKey(l, u);
      s.addTrace(Wa.create_authenticated_session_topic);
      let N;
      if ((w == null ? void 0 : w.length) > 0) {
        N = { topic: A, acknowledged: !0, self: { publicKey: l, metadata: this.client.metadata }, peer: { publicKey: u, metadata: o.requester.metadata }, controller: u, expiry: En(Wc), authentication: i, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: o.pairingTopic, namespaces: Zx([...new Set(w)], [...new Set(P)]), transportType: a }, s.addTrace(Wa.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(A, { transportType: a });
        } catch (L) {
          throw s.setError(Mf.subscribe_authenticated_session_topic_failure), L;
        }
        s.addTrace(Wa.subscribe_authenticated_session_topic_success), await this.client.session.set(A, N), s.addTrace(Wa.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: o.pairingTopic, metadata: o.requester.metadata });
      }
      s.addTrace(Wa.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: d, id: n, result: { cacaos: i, responder: { publicKey: l, metadata: this.client.metadata } }, encodeOpts: p, throwOnFailedPublish: !0, appLink: this.getAppLinkIfEnabled(o.requester.metadata, a) });
      } catch (L) {
        throw s.setError(Mf.authenticated_session_approve_publish_failure), L;
      }
      return await this.client.auth.requests.delete(n, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: o.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: s.eventId }), { session: N };
    }, this.rejectSessionAuthenticate = async (r) => {
      this.isInitialized();
      const { id: n, reason: i } = r, s = this.getPendingAuthRequest(n);
      if (!s) throw new Error(`Could not find pending auth request with id ${n}`);
      s.transportType === zr.relay && await this.confirmOnlineStateOrThrow();
      const o = s.requester.publicKey, a = await this.client.core.crypto.generateKeyPair(), u = Cd(o), l = { type: Io, receiverPublicKey: o, senderPublicKey: a };
      await this.sendError({ id: n, topic: u, error: i, encodeOpts: l, rpcOpts: In.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(s.requester.metadata, s.transportType) }), await this.client.auth.requests.delete(n, { message: "rejected", code: 0 }), await this.client.proposal.delete(n, Or("USER_DISCONNECTED"));
    }, this.formatAuthMessage = (r) => {
      this.isInitialized();
      const { request: n, iss: i } = r;
      return B8(n, i);
    }, this.processRelayMessageCache = () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const r = this.relayMessageCache.shift();
          r && await this.onRelayMessage(r);
        } catch (r) {
          this.client.logger.error(r);
        }
      }, 50);
    }, this.cleanupDuplicatePairings = async (r) => {
      if (r.pairingTopic) try {
        const n = this.client.core.pairing.pairings.get(r.pairingTopic), i = this.client.core.pairing.pairings.getAll().filter((s) => {
          var o, a;
          return ((o = s.peerMetadata) == null ? void 0 : o.url) && ((a = s.peerMetadata) == null ? void 0 : a.url) === r.peer.metadata.url && s.topic && s.topic !== n.topic;
        });
        if (i.length === 0) return;
        this.client.logger.info(`Cleaning up ${i.length} duplicate pairing(s)`), await Promise.all(i.map((s) => this.client.core.pairing.disconnect({ topic: s.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (n) {
        this.client.logger.error(n);
      }
    }, this.deleteSession = async (r) => {
      var n;
      const { topic: i, expirerHasDeleted: s = !1, emitEvent: o = !0, id: a = 0 } = r, { self: u } = this.client.session.get(i);
      await this.client.core.relayer.unsubscribe(i), await this.client.session.delete(i, Or("USER_DISCONNECTED")), this.addToRecentlyDeleted(i, "session"), this.client.core.crypto.keychain.has(u.publicKey) && await this.client.core.crypto.deleteKeyPair(u.publicKey), this.client.core.crypto.keychain.has(i) && await this.client.core.crypto.deleteSymKey(i), s || this.client.core.expirer.del(i), this.client.core.storage.removeItem(D3).catch((l) => this.client.logger.warn(l)), this.getPendingSessionRequests().forEach((l) => {
        l.topic === i && this.deletePendingSessionRequest(l.id, Or("USER_DISCONNECTED"));
      }), i === ((n = this.sessionRequestQueue.queue[0]) == null ? void 0 : n.topic) && (this.sessionRequestQueue.state = Ls.idle), o && this.client.events.emit("session_delete", { id: a, topic: i });
    }, this.deleteProposal = async (r, n) => {
      if (n) try {
        const i = this.client.proposal.get(r), s = this.client.core.eventClient.getEvent({ topic: i.pairingTopic });
        s == null || s.setError(Ha.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(r, Or("USER_DISCONNECTED")), n ? Promise.resolve() : this.client.core.expirer.del(r)]), this.addToRecentlyDeleted(r, "proposal");
    }, this.deletePendingSessionRequest = async (r, n, i = !1) => {
      await Promise.all([this.client.pendingRequest.delete(r, n), i ? Promise.resolve() : this.client.core.expirer.del(r)]), this.addToRecentlyDeleted(r, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((s) => s.id !== r), i && (this.sessionRequestQueue.state = Ls.idle, this.client.events.emit("session_request_expire", { id: r }));
    }, this.deletePendingAuthRequest = async (r, n, i = !1) => {
      await Promise.all([this.client.auth.requests.delete(r, n), i ? Promise.resolve() : this.client.core.expirer.del(r)]);
    }, this.setExpiry = async (r, n) => {
      this.client.session.keys.includes(r) && (this.client.core.expirer.set(r, n), await this.client.session.update(r, { expiry: n }));
    }, this.setProposal = async (r, n) => {
      this.client.core.expirer.set(r, En(In.wc_sessionPropose.req.ttl)), await this.client.proposal.set(r, n);
    }, this.setAuthRequest = async (r, n) => {
      const { request: i, pairingTopic: s, transportType: o = zr.relay } = n;
      this.client.core.expirer.set(r, i.expiryTimestamp), await this.client.auth.requests.set(r, { authPayload: i.authPayload, requester: i.requester, expiryTimestamp: i.expiryTimestamp, id: r, pairingTopic: s, verifyContext: i.verifyContext, transportType: o });
    }, this.setPendingSessionRequest = async (r) => {
      const { id: n, topic: i, params: s, verifyContext: o } = r, a = s.request.expiryTimestamp || En(In.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(n, a), await this.client.pendingRequest.set(n, { id: n, topic: i, params: s, verifyContext: o });
    }, this.sendRequest = async (r) => {
      const { topic: n, method: i, params: s, expiry: o, relayRpcId: a, clientRpcId: u, throwOnFailedPublish: l, appLink: d } = r, p = ha(i, s, u);
      let w;
      const P = !!d;
      try {
        const L = P ? Sf : la;
        w = await this.client.core.crypto.encode(n, p, { encoding: L });
      } catch (L) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${n} failed`), L;
      }
      let A;
      if (_V.includes(i)) {
        const L = wo(JSON.stringify(p)), F = wo(w);
        A = await this.client.core.verify.register({ id: F, decryptedId: L });
      }
      const N = In[i].req;
      if (N.attestation = A, o && (N.ttl = o), a && (N.id = a), this.client.core.history.set(n, p), P) {
        const L = ud(d, n, w);
        await global.Linking.openURL(L, this.client.name);
      } else {
        const L = In[i].req;
        o && (L.ttl = o), a && (L.id = a), l ? (L.internal = vs(tn({}, L.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(n, w, L)) : this.client.core.relayer.publish(n, w, L).catch((F) => this.client.logger.error(F));
      }
      return p.id;
    }, this.sendResult = async (r) => {
      const { id: n, topic: i, result: s, throwOnFailedPublish: o, encodeOpts: a, appLink: u } = r, l = tp(n, s);
      let d;
      const p = u && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const P = p ? Sf : la;
        d = await this.client.core.crypto.encode(i, l, vs(tn({}, a || {}), { encoding: P }));
      } catch (P) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${i} failed`), P;
      }
      let w;
      try {
        w = await this.client.core.history.get(i, n);
      } catch (P) {
        throw this.client.logger.error(`sendResult() -> history.get(${i}, ${n}) failed`), P;
      }
      if (p) {
        const P = ud(u, i, d);
        await global.Linking.openURL(P, this.client.name);
      } else {
        const P = In[w.request.method].res;
        o ? (P.internal = vs(tn({}, P.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(i, d, P)) : this.client.core.relayer.publish(i, d, P).catch((A) => this.client.logger.error(A));
      }
      await this.client.core.history.resolve(l);
    }, this.sendError = async (r) => {
      const { id: n, topic: i, error: s, encodeOpts: o, rpcOpts: a, appLink: u } = r, l = rp(n, s);
      let d;
      const p = u && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const P = p ? Sf : la;
        d = await this.client.core.crypto.encode(i, l, vs(tn({}, o || {}), { encoding: P }));
      } catch (P) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${i} failed`), P;
      }
      let w;
      try {
        w = await this.client.core.history.get(i, n);
      } catch (P) {
        throw this.client.logger.error(`sendError() -> history.get(${i}, ${n}) failed`), P;
      }
      if (p) {
        const P = ud(u, i, d);
        await global.Linking.openURL(P, this.client.name);
      } else {
        const P = a || In[w.request.method].res;
        this.client.core.relayer.publish(i, d, P);
      }
      await this.client.core.history.resolve(l);
    }, this.cleanup = async () => {
      const r = [], n = [];
      this.client.session.getAll().forEach((i) => {
        let s = !1;
        aa(i.expiry) && (s = !0), this.client.core.crypto.keychain.has(i.topic) || (s = !0), s && r.push(i.topic);
      }), this.client.proposal.getAll().forEach((i) => {
        aa(i.expiryTimestamp) && n.push(i.id);
      }), await Promise.all([...r.map((i) => this.deleteSession({ topic: i })), ...n.map((i) => this.deleteProposal(i))]);
    }, this.onRelayEventRequest = async (r) => {
      this.requestQueue.queue.push(r), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === Ls.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = Ls.active;
        const r = this.requestQueue.queue.shift();
        if (r) try {
          await this.processRequest(r);
        } catch (n) {
          this.client.logger.warn(n);
        }
      }
      this.requestQueue.state = Ls.idle;
    }, this.processRequest = async (r) => {
      const { topic: n, payload: i, attestation: s, transportType: o, encryptedId: a } = r, u = i.method;
      if (!this.shouldIgnorePairingRequest({ topic: n, requestMethod: u })) switch (u) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: n, payload: i, attestation: s, encryptedId: a });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(n, i);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(n, i);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(n, i);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(n, i);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(n, i);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: n, payload: i, attestation: s, encryptedId: a, transportType: o });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(n, i);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: n, payload: i, attestation: s, encryptedId: a, transportType: o });
        default:
          return this.client.logger.info(`Unsupported request method ${u}`);
      }
    }, this.onRelayEventResponse = async (r) => {
      const { topic: n, payload: i, transportType: s } = r, o = (await this.client.core.history.get(n, i.id)).request.method;
      switch (o) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(n, i, s);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(n, i);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(n, i);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(n, i);
        case "wc_sessionPing":
          return this.onSessionPingResponse(n, i);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(n, i);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(n, i);
        default:
          return this.client.logger.info(`Unsupported response method ${o}`);
      }
    }, this.onRelayEventUnknownPayload = (r) => {
      const { topic: n } = r, { message: i } = ft("MISSING_OR_INVALID", `Decoded payload on topic ${n} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(i);
    }, this.shouldIgnorePairingRequest = (r) => {
      const { topic: n, requestMethod: i } = r, s = this.expectedPairingMethodMap.get(n);
      return !s || s.includes(i) ? !1 : !!(s.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }, this.onSessionProposeRequest = async (r) => {
      const { topic: n, payload: i, attestation: s, encryptedId: o } = r, { params: a, id: u } = i;
      try {
        const l = this.client.core.eventClient.getEvent({ topic: n });
        this.isValidConnect(tn({}, i.params));
        const d = a.expiryTimestamp || En(In.wc_sessionPropose.req.ttl), p = tn({ id: u, pairingTopic: n, expiryTimestamp: d }, a);
        await this.setProposal(u, p);
        const w = await this.getVerifyContext({ attestationId: s, hash: wo(JSON.stringify(i)), encryptedId: o, metadata: p.proposer.metadata });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l == null || l.setError(yo.proposal_listener_not_found)), l == null || l.addTrace(Fs.emit_session_proposal), this.client.events.emit("session_proposal", { id: u, params: p, verifyContext: w });
      } catch (l) {
        await this.sendError({ id: u, topic: n, error: l, rpcOpts: In.wc_sessionPropose.autoReject }), this.client.logger.error(l);
      }
    }, this.onSessionProposeResponse = async (r, n, i) => {
      const { id: s } = n;
      if (Bs(n)) {
        const { result: o } = n;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: o });
        const a = this.client.proposal.get(s);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: a });
        const u = a.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: u });
        const l = o.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l });
        const d = await this.client.core.crypto.generateSharedKey(u, l);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: d });
        const p = await this.client.core.relayer.subscribe(d, { transportType: i });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p }), await this.client.core.pairing.activate({ topic: r });
      } else if (Zi(n)) {
        await this.client.proposal.delete(s, Or("USER_DISCONNECTED"));
        const o = br("session_connect");
        if (this.events.listenerCount(o) === 0) throw new Error(`emitting ${o} without any listeners, 954`);
        this.events.emit(br("session_connect"), { error: n.error });
      }
    }, this.onSessionSettleRequest = async (r, n) => {
      const { id: i, params: s } = n;
      try {
        this.isValidSessionSettleRequest(s);
        const { relay: o, controller: a, expiry: u, namespaces: l, sessionProperties: d, sessionConfig: p } = n.params, w = vs(tn(tn({ topic: r, relay: o, expiry: u, namespaces: l, acknowledged: !0, pairingTopic: "", requiredNamespaces: {}, optionalNamespaces: {}, controller: a.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: a.publicKey, metadata: a.metadata } }, d && { sessionProperties: d }), p && { sessionConfig: p }), { transportType: zr.relay }), P = br("session_connect");
        if (this.events.listenerCount(P) === 0) throw new Error(`emitting ${P} without any listeners 997`);
        this.events.emit(br("session_connect"), { session: w }), await this.sendResult({ id: n.id, topic: r, result: !0, throwOnFailedPublish: !0 });
      } catch (o) {
        await this.sendError({ id: i, topic: r, error: o }), this.client.logger.error(o);
      }
    }, this.onSessionSettleResponse = async (r, n) => {
      const { id: i } = n;
      Bs(n) ? (await this.client.session.update(r, { acknowledged: !0 }), this.events.emit(br("session_approve", i), {})) : Zi(n) && (await this.client.session.delete(r, Or("USER_DISCONNECTED")), this.events.emit(br("session_approve", i), { error: n.error }));
    }, this.onSessionUpdateRequest = async (r, n) => {
      const { params: i, id: s } = n;
      try {
        const o = `${r}_session_update`, a = Af.get(o);
        if (a && this.isRequestOutOfSync(a, s)) {
          this.client.logger.info(`Discarding out of sync request - ${s}`), this.sendError({ id: s, topic: r, error: Or("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(tn({ topic: r }, i));
        try {
          Af.set(o, s), await this.client.session.update(r, { namespaces: i.namespaces }), await this.sendResult({ id: s, topic: r, result: !0, throwOnFailedPublish: !0 });
        } catch (u) {
          throw Af.delete(o), u;
        }
        this.client.events.emit("session_update", { id: s, topic: r, params: i });
      } catch (o) {
        await this.sendError({ id: s, topic: r, error: o }), this.client.logger.error(o);
      }
    }, this.isRequestOutOfSync = (r, n) => parseInt(n.toString().slice(0, -3)) <= parseInt(r.toString().slice(0, -3)), this.onSessionUpdateResponse = (r, n) => {
      const { id: i } = n, s = br("session_update", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      Bs(n) ? this.events.emit(br("session_update", i), {}) : Zi(n) && this.events.emit(br("session_update", i), { error: n.error });
    }, this.onSessionExtendRequest = async (r, n) => {
      const { id: i } = n;
      try {
        this.isValidExtend({ topic: r }), await this.setExpiry(r, En(Wc)), await this.sendResult({ id: i, topic: r, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_extend", { id: i, topic: r });
      } catch (s) {
        await this.sendError({ id: i, topic: r, error: s }), this.client.logger.error(s);
      }
    }, this.onSessionExtendResponse = (r, n) => {
      const { id: i } = n, s = br("session_extend", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      Bs(n) ? this.events.emit(br("session_extend", i), {}) : Zi(n) && this.events.emit(br("session_extend", i), { error: n.error });
    }, this.onSessionPingRequest = async (r, n) => {
      const { id: i } = n;
      try {
        this.isValidPing({ topic: r }), await this.sendResult({ id: i, topic: r, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_ping", { id: i, topic: r });
      } catch (s) {
        await this.sendError({ id: i, topic: r, error: s }), this.client.logger.error(s);
      }
    }, this.onSessionPingResponse = (r, n) => {
      const { id: i } = n, s = br("session_ping", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      setTimeout(() => {
        Bs(n) ? this.events.emit(br("session_ping", i), {}) : Zi(n) && this.events.emit(br("session_ping", i), { error: n.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (r, n) => {
      const { id: i } = n;
      try {
        this.isValidDisconnect({ topic: r, reason: n.params }), Promise.all([new Promise((s) => {
          this.client.core.relayer.once(si.publish, async () => {
            s(await this.deleteSession({ topic: r, id: i }));
          });
        }), this.sendResult({ id: i, topic: r, result: !0, throwOnFailedPublish: !0 }), this.cleanupPendingSentRequestsForTopic({ topic: r, error: Or("USER_DISCONNECTED") })]).catch((s) => this.client.logger.error(s));
      } catch (s) {
        this.client.logger.error(s);
      }
    }, this.onSessionRequest = async (r) => {
      var n, i, s;
      const { topic: o, payload: a, attestation: u, encryptedId: l, transportType: d } = r, { id: p, params: w } = a;
      try {
        await this.isValidRequest(tn({ topic: o }, w));
        const P = this.client.session.get(o), A = await this.getVerifyContext({ attestationId: u, hash: wo(JSON.stringify(ha("wc_sessionRequest", w, p))), encryptedId: l, metadata: P.peer.metadata, transportType: d }), N = { id: p, topic: o, params: w, verifyContext: A };
        await this.setPendingSessionRequest(N), d === zr.link_mode && (n = P.peer.metadata.redirect) != null && n.universal && this.client.core.addLinkModeSupportedApp((i = P.peer.metadata.redirect) == null ? void 0 : i.universal), (s = this.client.signConfig) != null && s.disableRequestQueue ? this.emitSessionRequest(N) : (this.addSessionRequestToSessionRequestQueue(N), this.processSessionRequestQueue());
      } catch (P) {
        await this.sendError({ id: p, topic: o, error: P }), this.client.logger.error(P);
      }
    }, this.onSessionRequestResponse = (r, n) => {
      const { id: i } = n, s = br("session_request", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      Bs(n) ? this.events.emit(br("session_request", i), { result: n.result }) : Zi(n) && this.events.emit(br("session_request", i), { error: n.error });
    }, this.onSessionEventRequest = async (r, n) => {
      const { id: i, params: s } = n;
      try {
        const o = `${r}_session_event_${s.event.name}`, a = Af.get(o);
        if (a && this.isRequestOutOfSync(a, i)) {
          this.client.logger.info(`Discarding out of sync request - ${i}`);
          return;
        }
        this.isValidEmit(tn({ topic: r }, s)), this.client.events.emit("session_event", { id: i, topic: r, params: s }), Af.set(o, i);
      } catch (o) {
        await this.sendError({ id: i, topic: r, error: o }), this.client.logger.error(o);
      }
    }, this.onSessionAuthenticateResponse = (r, n) => {
      const { id: i } = n;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: r, payload: n }), Bs(n) ? this.events.emit(br("session_request", i), { result: n.result }) : Zi(n) && this.events.emit(br("session_request", i), { error: n.error });
    }, this.onSessionAuthenticateRequest = async (r) => {
      var n;
      const { topic: i, payload: s, attestation: o, encryptedId: a, transportType: u } = r;
      try {
        const { requester: l, authPayload: d, expiryTimestamp: p } = s.params, w = await this.getVerifyContext({ attestationId: o, hash: wo(JSON.stringify(s)), encryptedId: a, metadata: l.metadata, transportType: u }), P = { requester: l, pairingTopic: i, id: s.id, authPayload: d, verifyContext: w, expiryTimestamp: p };
        await this.setAuthRequest(s.id, { request: P, pairingTopic: i, transportType: u }), u === zr.link_mode && (n = l.metadata.redirect) != null && n.universal && this.client.core.addLinkModeSupportedApp(l.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: i, params: s.params, id: s.id, verifyContext: w });
      } catch (l) {
        this.client.logger.error(l);
        const d = s.params.requester.publicKey, p = await this.client.core.crypto.generateKeyPair(), w = this.getAppLinkIfEnabled(s.params.requester.metadata, u), P = { type: Io, receiverPublicKey: d, senderPublicKey: p };
        await this.sendError({ id: s.id, topic: i, error: l, encodeOpts: P, rpcOpts: In.wc_sessionAuthenticate.autoReject, appLink: w });
      }
    }, this.addSessionRequestToSessionRequestQueue = (r) => {
      this.sessionRequestQueue.queue.push(r);
    }, this.cleanupAfterResponse = (r) => {
      this.deletePendingSessionRequest(r.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = Ls.idle, this.processSessionRequestQueue();
      }, mt.toMiliseconds(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: r, error: n }) => {
      const i = this.client.core.history.pending;
      i.length > 0 && i.filter((s) => s.topic === r && s.request.method === "wc_sessionRequest").forEach((s) => {
        const o = s.request.id, a = br("session_request", o);
        if (this.events.listenerCount(a) === 0) throw new Error(`emitting ${a} without any listeners`);
        this.events.emit(br("session_request", s.request.id), { error: n });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === Ls.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const r = this.sessionRequestQueue.queue[0];
      if (!r) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = Ls.active, this.emitSessionRequest(r);
      } catch (n) {
        this.client.logger.error(n);
      }
    }, this.emitSessionRequest = (r) => {
      this.client.events.emit("session_request", r);
    }, this.onPairingCreated = (r) => {
      if (r.methods && this.expectedPairingMethodMap.set(r.topic, r.methods), r.active) return;
      const n = this.client.proposal.getAll().find((i) => i.pairingTopic === r.topic);
      n && this.onSessionProposeRequest({ topic: r.topic, payload: ha("wc_sessionPropose", { requiredNamespaces: n.requiredNamespaces, optionalNamespaces: n.optionalNamespaces, relays: n.relays, proposer: n.proposer, sessionProperties: n.sessionProperties }, n.id) });
    }, this.isValidConnect = async (r) => {
      if (!pi(r)) {
        const { message: u } = ft("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(r)}`);
        throw new Error(u);
      }
      const { pairingTopic: n, requiredNamespaces: i, optionalNamespaces: s, sessionProperties: o, relays: a } = r;
      if (gi(n) || await this.isValidPairingTopic(n), !Jz(a)) {
        const { message: u } = ft("MISSING_OR_INVALID", `connect() relays: ${a}`);
        throw new Error(u);
      }
      !gi(i) && El(i) !== 0 && this.validateNamespaces(i, "requiredNamespaces"), !gi(s) && El(s) !== 0 && this.validateNamespaces(s, "optionalNamespaces"), gi(o) || this.validateSessionProps(o, "sessionProperties");
    }, this.validateNamespaces = (r, n) => {
      const i = Yz(r, "connect()", n);
      if (i) throw new Error(i.message);
    }, this.isValidApprove = async (r) => {
      if (!pi(r)) throw new Error(ft("MISSING_OR_INVALID", `approve() params: ${r}`).message);
      const { id: n, namespaces: i, relayProtocol: s, sessionProperties: o } = r;
      this.checkRecentlyDeleted(n), await this.isValidProposalId(n);
      const a = this.client.proposal.get(n), u = hm(i, "approve()");
      if (u) throw new Error(u.message);
      const l = t3(a.requiredNamespaces, i, "approve()");
      if (l) throw new Error(l.message);
      if (!dn(s, !0)) {
        const { message: d } = ft("MISSING_OR_INVALID", `approve() relayProtocol: ${s}`);
        throw new Error(d);
      }
      gi(o) || this.validateSessionProps(o, "sessionProperties");
    }, this.isValidReject = async (r) => {
      if (!pi(r)) {
        const { message: s } = ft("MISSING_OR_INVALID", `reject() params: ${r}`);
        throw new Error(s);
      }
      const { id: n, reason: i } = r;
      if (this.checkRecentlyDeleted(n), await this.isValidProposalId(n), !Zz(i)) {
        const { message: s } = ft("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(i)}`);
        throw new Error(s);
      }
    }, this.isValidSessionSettleRequest = (r) => {
      if (!pi(r)) {
        const { message: l } = ft("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${r}`);
        throw new Error(l);
      }
      const { relay: n, controller: i, namespaces: s, expiry: o } = r;
      if (!V8(n)) {
        const { message: l } = ft("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l);
      }
      const a = zz(i, "onSessionSettleRequest()");
      if (a) throw new Error(a.message);
      const u = hm(s, "onSessionSettleRequest()");
      if (u) throw new Error(u.message);
      if (aa(o)) {
        const { message: l } = ft("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l);
      }
    }, this.isValidUpdate = async (r) => {
      if (!pi(r)) {
        const { message: u } = ft("MISSING_OR_INVALID", `update() params: ${r}`);
        throw new Error(u);
      }
      const { topic: n, namespaces: i } = r;
      this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
      const s = this.client.session.get(n), o = hm(i, "update()");
      if (o) throw new Error(o.message);
      const a = t3(s.requiredNamespaces, i, "update()");
      if (a) throw new Error(a.message);
    }, this.isValidExtend = async (r) => {
      if (!pi(r)) {
        const { message: i } = ft("MISSING_OR_INVALID", `extend() params: ${r}`);
        throw new Error(i);
      }
      const { topic: n } = r;
      this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
    }, this.isValidRequest = async (r) => {
      if (!pi(r)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() params: ${r}`);
        throw new Error(u);
      }
      const { topic: n, request: i, chainId: s, expiry: o } = r;
      this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
      const { namespaces: a } = this.client.session.get(n);
      if (!e3(a, s)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() chainId: ${s}`);
        throw new Error(u);
      }
      if (!Qz(i)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() ${JSON.stringify(i)}`);
        throw new Error(u);
      }
      if (!rH(a, s, i.method)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() method: ${i.method}`);
        throw new Error(u);
      }
      if (o && !oH(o, vm)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() expiry: ${o}. Expiry must be a number (in seconds) between ${vm.min} and ${vm.max}`);
        throw new Error(u);
      }
    }, this.isValidRespond = async (r) => {
      var n;
      if (!pi(r)) {
        const { message: o } = ft("MISSING_OR_INVALID", `respond() params: ${r}`);
        throw new Error(o);
      }
      const { topic: i, response: s } = r;
      try {
        await this.isValidSessionTopic(i);
      } catch (o) {
        throw (n = r == null ? void 0 : r.response) != null && n.id && this.cleanupAfterResponse(r), o;
      }
      if (!eH(s)) {
        const { message: o } = ft("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(s)}`);
        throw new Error(o);
      }
    }, this.isValidPing = async (r) => {
      if (!pi(r)) {
        const { message: i } = ft("MISSING_OR_INVALID", `ping() params: ${r}`);
        throw new Error(i);
      }
      const { topic: n } = r;
      await this.isValidSessionOrPairingTopic(n);
    }, this.isValidEmit = async (r) => {
      if (!pi(r)) {
        const { message: a } = ft("MISSING_OR_INVALID", `emit() params: ${r}`);
        throw new Error(a);
      }
      const { topic: n, event: i, chainId: s } = r;
      await this.isValidSessionTopic(n);
      const { namespaces: o } = this.client.session.get(n);
      if (!e3(o, s)) {
        const { message: a } = ft("MISSING_OR_INVALID", `emit() chainId: ${s}`);
        throw new Error(a);
      }
      if (!tH(i)) {
        const { message: a } = ft("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
        throw new Error(a);
      }
      if (!nH(o, s, i.name)) {
        const { message: a } = ft("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
        throw new Error(a);
      }
    }, this.isValidDisconnect = async (r) => {
      if (!pi(r)) {
        const { message: i } = ft("MISSING_OR_INVALID", `disconnect() params: ${r}`);
        throw new Error(i);
      }
      const { topic: n } = r;
      await this.isValidSessionOrPairingTopic(n);
    }, this.isValidAuthenticate = (r) => {
      const { chains: n, uri: i, domain: s, nonce: o } = r;
      if (!Array.isArray(n) || n.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!dn(i, !1)) throw new Error("uri is required parameter");
      if (!dn(s, !1)) throw new Error("domain is required parameter");
      if (!dn(o, !1)) throw new Error("nonce is required parameter");
      if ([...new Set(n.map((u) => lu(u).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: a } = lu(n[0]);
      if (a !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }, this.getVerifyContext = async (r) => {
      const { attestationId: n, hash: i, encryptedId: s, metadata: o, transportType: a } = r, u = { verified: { verifyUrl: o.verifyUrl || zf, validation: "UNKNOWN", origin: o.url || "" } };
      try {
        if (a === zr.link_mode) {
          const d = this.getAppLinkIfEnabled(o, a);
          return u.verified.validation = d && new URL(d).origin === new URL(o.url).origin ? "VALID" : "INVALID", u;
        }
        const l = await this.client.core.verify.resolve({ attestationId: n, hash: i, encryptedId: s, verifyUrl: o.verifyUrl });
        l && (u.verified.origin = l.origin, u.verified.isScam = l.isScam, u.verified.validation = l.origin === new URL(o.url).origin ? "VALID" : "INVALID");
      } catch (l) {
        this.client.logger.warn(l);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(u)}`), u;
    }, this.validateSessionProps = (r, n) => {
      Object.values(r).forEach((i) => {
        if (!dn(i, !1)) {
          const { message: s } = ft("MISSING_OR_INVALID", `${n} must be in Record<string, string> format. Received: ${JSON.stringify(i)}`);
          throw new Error(s);
        }
      });
    }, this.getPendingAuthRequest = (r) => {
      const n = this.client.auth.requests.get(r);
      return typeof n == "object" ? n : void 0;
    }, this.addToRecentlyDeleted = (r, n) => {
      if (this.recentlyDeletedMap.set(r, n), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let i = 0;
        const s = this.recentlyDeletedLimit / 2;
        for (const o of this.recentlyDeletedMap.keys()) {
          if (i++ >= s) break;
          this.recentlyDeletedMap.delete(o);
        }
      }
    }, this.checkRecentlyDeleted = (r) => {
      const n = this.recentlyDeletedMap.get(r);
      if (n) {
        const { message: i } = ft("MISSING_OR_INVALID", `Record was recently deleted - ${n}: ${r}`);
        throw new Error(i);
      }
    }, this.isLinkModeEnabled = (r, n) => {
      var i, s, o, a, u, l, d, p, w;
      return !r || n !== zr.link_mode ? !1 : ((s = (i = this.client.metadata) == null ? void 0 : i.redirect) == null ? void 0 : s.linkMode) === !0 && ((a = (o = this.client.metadata) == null ? void 0 : o.redirect) == null ? void 0 : a.universal) !== void 0 && ((l = (u = this.client.metadata) == null ? void 0 : u.redirect) == null ? void 0 : l.universal) !== "" && ((d = r == null ? void 0 : r.redirect) == null ? void 0 : d.universal) !== void 0 && ((p = r == null ? void 0 : r.redirect) == null ? void 0 : p.universal) !== "" && ((w = r == null ? void 0 : r.redirect) == null ? void 0 : w.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(r.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }, this.getAppLinkIfEnabled = (r, n) => {
      var i;
      return this.isLinkModeEnabled(r, n) ? (i = r == null ? void 0 : r.redirect) == null ? void 0 : i.universal : void 0;
    }, this.handleLinkModeMessage = ({ url: r }) => {
      if (!r || !r.includes("wc_ev") || !r.includes("topic")) return;
      const n = $x(r, "topic") || "", i = decodeURIComponent($x(r, "wc_ev") || ""), s = this.client.session.keys.includes(n);
      s && this.client.session.update(n, { transportType: zr.link_mode }), this.client.core.dispatchEnvelope({ topic: n, message: i, sessionExists: s });
    }, this.registerLinkModeListeners = async () => {
      var r;
      if (nb() || ju() && (r = this.client.metadata.redirect) != null && r.linkMode) {
        const n = global == null ? void 0 : global.Linking;
        if (typeof n < "u") {
          n.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const i = await n.getInitialURL();
          i && setTimeout(() => {
            this.handleLinkModeMessage({ url: i });
          }, 50);
        }
      }
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(si.message, (e) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(e) : this.onRelayMessage(e);
    });
  }
  async onRelayMessage(e) {
    const { topic: r, message: n, attestation: i, transportType: s } = e, { publicKey: o } = this.client.auth.authKeys.keys.includes(Td) ? this.client.auth.authKeys.get(Td) : { publicKey: void 0 }, a = await this.client.core.crypto.decode(r, n, { receiverPublicKey: o, encoding: s === zr.link_mode ? Sf : la });
    try {
      ub(a) ? (this.client.core.history.set(r, a), this.onRelayEventRequest({ topic: r, payload: a, attestation: i, transportType: s, encryptedId: wo(n) })) : np(a) ? (await this.client.core.history.resolve(a), await this.onRelayEventResponse({ topic: r, payload: a, transportType: s }), this.client.core.history.delete(r, a.id)) : this.onRelayEventUnknownPayload({ topic: r, payload: a, transportType: s });
    } catch (u) {
      this.client.logger.error(u);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(Ji.expired, async (e) => {
      const { topic: r, id: n } = $8(e.target);
      if (n && this.client.pendingRequest.keys.includes(n)) return await this.deletePendingSessionRequest(n, ft("EXPIRED"), !0);
      if (n && this.client.auth.requests.keys.includes(n)) return await this.deletePendingAuthRequest(n, ft("EXPIRED"), !0);
      r ? this.client.session.keys.includes(r) && (await this.deleteSession({ topic: r, expirerHasDeleted: !0 }), this.client.events.emit("session_expire", { topic: r })) : n && (await this.deleteProposal(n, !0), this.client.events.emit("proposal_expire", { id: n }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(Xa.create, (e) => this.onPairingCreated(e)), this.client.core.pairing.events.on(Xa.delete, (e) => {
      this.addToRecentlyDeleted(e.topic, "pairing");
    });
  }
  isValidPairingTopic(e) {
    if (!dn(e, !1)) {
      const { message: r } = ft("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
      throw new Error(r);
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: r } = ft("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (aa(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: r } = ft("EXPIRED", `pairing topic: ${e}`);
      throw new Error(r);
    }
  }
  async isValidSessionTopic(e) {
    if (!dn(e, !1)) {
      const { message: r } = ft("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
      throw new Error(r);
    }
    if (this.checkRecentlyDeleted(e), !this.client.session.keys.includes(e)) {
      const { message: r } = ft("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (aa(this.client.session.get(e).expiry)) {
      await this.deleteSession({ topic: e });
      const { message: r } = ft("EXPIRED", `session topic: ${e}`);
      throw new Error(r);
    }
    if (!this.client.core.crypto.keychain.has(e)) {
      const { message: r } = ft("MISSING_OR_INVALID", `session topic does not exist in keychain: ${e}`);
      throw await this.deleteSession({ topic: e }), new Error(r);
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if (this.checkRecentlyDeleted(e), this.client.session.keys.includes(e)) await this.isValidSessionTopic(e);
    else if (this.client.core.pairing.pairings.keys.includes(e)) this.isValidPairingTopic(e);
    else if (dn(e, !1)) {
      const { message: r } = ft("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
      throw new Error(r);
    } else {
      const { message: r } = ft("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
      throw new Error(r);
    }
  }
  async isValidProposalId(e) {
    if (!Xz(e)) {
      const { message: r } = ft("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
      throw new Error(r);
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: r } = ft("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (aa(this.client.proposal.get(e).expiryTimestamp)) {
      await this.deleteProposal(e);
      const { message: r } = ft("EXPIRED", `proposal id: ${e}`);
      throw new Error(r);
    }
  }
}
class NV extends _c {
  constructor(e, r) {
    super(e, r, bV, lb), this.core = e, this.logger = r;
  }
}
let LV = class extends _c {
  constructor(e, r) {
    super(e, r, yV, lb), this.core = e, this.logger = r;
  }
};
class kV extends _c {
  constructor(e, r) {
    super(e, r, xV, lb, (n) => n.id), this.core = e, this.logger = r;
  }
}
class $V extends _c {
  constructor(e, r) {
    super(e, r, AV, sp, () => Td), this.core = e, this.logger = r;
  }
}
class FV extends _c {
  constructor(e, r) {
    super(e, r, PV, sp), this.core = e, this.logger = r;
  }
}
class BV extends _c {
  constructor(e, r) {
    super(e, r, MV, sp, (n) => n.id), this.core = e, this.logger = r;
  }
}
class UV {
  constructor(e, r) {
    this.core = e, this.logger = r, this.authKeys = new $V(this.core, this.logger), this.pairingTopics = new FV(this.core, this.logger), this.requests = new BV(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
}
class hb extends Yk {
  constructor(e) {
    super(e), this.protocol = mE, this.version = vE, this.name = mm.name, this.events = new rs.EventEmitter(), this.on = (n, i) => this.events.on(n, i), this.once = (n, i) => this.events.once(n, i), this.off = (n, i) => this.events.off(n, i), this.removeListener = (n, i) => this.events.removeListener(n, i), this.removeAllListeners = (n) => this.events.removeAllListeners(n), this.connect = async (n) => {
      try {
        return await this.engine.connect(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.pair = async (n) => {
      try {
        return await this.engine.pair(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.approve = async (n) => {
      try {
        return await this.engine.approve(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.reject = async (n) => {
      try {
        return await this.engine.reject(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.update = async (n) => {
      try {
        return await this.engine.update(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.extend = async (n) => {
      try {
        return await this.engine.extend(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.request = async (n) => {
      try {
        return await this.engine.request(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.respond = async (n) => {
      try {
        return await this.engine.respond(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.ping = async (n) => {
      try {
        return await this.engine.ping(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.emit = async (n) => {
      try {
        return await this.engine.emit(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.disconnect = async (n) => {
      try {
        return await this.engine.disconnect(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.find = (n) => {
      try {
        return this.engine.find(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.authenticate = async (n, i) => {
      try {
        return await this.engine.authenticate(n, i);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.formatAuthMessage = (n) => {
      try {
        return this.engine.formatAuthMessage(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.approveSessionAuthenticate = async (n) => {
      try {
        return await this.engine.approveSessionAuthenticate(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.rejectSessionAuthenticate = async (n) => {
      try {
        return await this.engine.rejectSessionAuthenticate(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.name = (e == null ? void 0 : e.name) || mm.name, this.metadata = (e == null ? void 0 : e.metadata) || D8(), this.signConfig = e == null ? void 0 : e.signConfig;
    const r = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : jl(k0({ level: (e == null ? void 0 : e.logger) || mm.logger }));
    this.core = (e == null ? void 0 : e.core) || new vV(e), this.logger = ai(r, this.name), this.session = new LV(this.core, this.logger), this.proposal = new NV(this.core, this.logger), this.pendingRequest = new kV(this.core, this.logger), this.engine = new OV(this), this.auth = new UV(this.core, this.logger);
  }
  static async init(e) {
    const r = new hb(e);
    return await r.initialize(), r;
  }
  get context() {
    return Si(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), this.engine.processRelayMessageCache();
    } catch (e) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(e.message), e;
    }
  }
}
var l0 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
l0.exports;
(function(t, e) {
  (function() {
    var r, n = "4.17.21", i = 200, s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", o = "Expected a function", a = "Invalid `variable` option passed into `_.template`", u = "__lodash_hash_undefined__", l = 500, d = "__lodash_placeholder__", p = 1, w = 2, P = 4, A = 1, N = 2, L = 1, F = 2, $ = 4, K = 8, H = 16, V = 32, te = 64, R = 128, W = 256, pe = 512, Ee = 30, Y = "...", S = 800, m = 16, f = 1, g = 2, b = 3, x = 1 / 0, _ = 9007199254740991, E = 17976931348623157e292, v = NaN, M = 4294967295, I = M - 1, B = M >>> 1, ce = [
      ["ary", R],
      ["bind", L],
      ["bindKey", F],
      ["curry", K],
      ["curryRight", H],
      ["flip", pe],
      ["partial", V],
      ["partialRight", te],
      ["rearg", W]
    ], D = "[object Arguments]", oe = "[object Array]", Z = "[object AsyncFunction]", J = "[object Boolean]", Q = "[object Date]", T = "[object DOMException]", X = "[object Error]", re = "[object Function]", de = "[object GeneratorFunction]", ie = "[object Map]", ue = "[object Number]", ve = "[object Null]", Pe = "[object Object]", De = "[object Promise]", Ce = "[object Proxy]", $e = "[object RegExp]", Me = "[object Set]", Ne = "[object String]", Ke = "[object Symbol]", Le = "[object Undefined]", qe = "[object WeakMap]", ze = "[object WeakSet]", _e = "[object ArrayBuffer]", Ze = "[object DataView]", at = "[object Float32Array]", ke = "[object Float64Array]", Qe = "[object Int8Array]", tt = "[object Int16Array]", Ye = "[object Int32Array]", dt = "[object Uint8Array]", lt = "[object Uint8ClampedArray]", ct = "[object Uint16Array]", qt = "[object Uint32Array]", Yt = /\b__p \+= '';/g, Et = /\b(__p \+=) '' \+/g, Qt = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Jt = /&(?:amp|lt|gt|quot|#39);/g, Dt = /[&<>"']/g, kt = RegExp(Jt.source), Ct = RegExp(Dt.source), gt = /<%-([\s\S]+?)%>/g, Rt = /<%([\s\S]+?)%>/g, Nt = /<%=([\s\S]+?)%>/g, vt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, $t = /^\w*$/, Bt = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, rt = /[\\^$.*+?()[\]{}|]/g, Ft = RegExp(rt.source), k = /^\s+/, j = /\s/, z = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, C = /\{\n\/\* \[wrapped with (.+)\] \*/, G = /,? & /, U = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, se = /[()=,{}\[\]\/\s]/, he = /\\(\\)?/g, xe = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Te = /\w*$/, Re = /^[-+]0x[0-9a-f]+$/i, nt = /^0b[01]+$/i, Ue = /^\[object .+?Constructor\]$/, pt = /^0o[0-7]+$/i, it = /^(?:0|[1-9]\d*)$/, et = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, St = /($^)/, Tt = /['\n\r\u2028\u2029\\]/g, At = "\\ud800-\\udfff", _t = "\\u0300-\\u036f", ht = "\\ufe20-\\ufe2f", xt = "\\u20d0-\\u20ff", st = _t + ht + xt, bt = "\\u2700-\\u27bf", ut = "a-z\\xdf-\\xf6\\xf8-\\xff", ot = "\\xac\\xb1\\xd7\\xf7", Se = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Ae = "\\u2000-\\u206f", Ve = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Be = "A-Z\\xc0-\\xd6\\xd8-\\xde", je = "\\ufe0e\\ufe0f", Je = ot + Se + Ae + Ve, Lt = "[']", zt = "[" + At + "]", Xt = "[" + Je + "]", Ht = "[" + st + "]", le = "\\d+", tr = "[" + bt + "]", dr = "[" + ut + "]", pr = "[^" + At + Je + le + bt + ut + Be + "]", Zt = "\\ud83c[\\udffb-\\udfff]", gr = "(?:" + Ht + "|" + Zt + ")", lr = "[^" + At + "]", Rr = "(?:\\ud83c[\\udde6-\\uddff]){2}", mr = "[\\ud800-\\udbff][\\udc00-\\udfff]", yr = "[" + Be + "]", $r = "\\u200d", Fr = "(?:" + dr + "|" + pr + ")", Ir = "(?:" + yr + "|" + pr + ")", nn = "(?:" + Lt + "(?:d|ll|m|re|s|t|ve))?", sn = "(?:" + Lt + "(?:D|LL|M|RE|S|T|VE))?", on = gr + "?", fh = "[" + je + "]?", Rp = "(?:" + $r + "(?:" + [lr, Rr, mr].join("|") + ")" + fh + on + ")*", no = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", lh = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", hh = fh + on + Rp, Pc = "(?:" + [tr, Rr, mr].join("|") + ")" + hh, Dp = "(?:" + [lr + Ht + "?", Ht, Rr, mr, zt].join("|") + ")", Ju = RegExp(Lt, "g"), Op = RegExp(Ht, "g"), Mc = RegExp(Zt + "(?=" + Zt + ")|" + Dp + hh, "g"), dh = RegExp([
      yr + "?" + dr + "+" + nn + "(?=" + [Xt, yr, "$"].join("|") + ")",
      Ir + "+" + sn + "(?=" + [Xt, yr + Fr, "$"].join("|") + ")",
      yr + "?" + Fr + "+" + nn,
      yr + "+" + sn,
      lh,
      no,
      le,
      Pc
    ].join("|"), "g"), ph = RegExp("[" + $r + At + st + je + "]"), Ra = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, gh = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], Np = -1, Br = {};
    Br[at] = Br[ke] = Br[Qe] = Br[tt] = Br[Ye] = Br[dt] = Br[lt] = Br[ct] = Br[qt] = !0, Br[D] = Br[oe] = Br[_e] = Br[J] = Br[Ze] = Br[Q] = Br[X] = Br[re] = Br[ie] = Br[ue] = Br[Pe] = Br[$e] = Br[Me] = Br[Ne] = Br[qe] = !1;
    var Dr = {};
    Dr[D] = Dr[oe] = Dr[_e] = Dr[Ze] = Dr[J] = Dr[Q] = Dr[at] = Dr[ke] = Dr[Qe] = Dr[tt] = Dr[Ye] = Dr[ie] = Dr[ue] = Dr[Pe] = Dr[$e] = Dr[Me] = Dr[Ne] = Dr[Ke] = Dr[dt] = Dr[lt] = Dr[ct] = Dr[qt] = !0, Dr[X] = Dr[re] = Dr[qe] = !1;
    var ae = {
      // Latin-1 Supplement block.
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "C",
      : "c",
      : "D",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "N",
      : "n",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "Y",
      : "y",
      : "y",
      : "Ae",
      : "ae",
      : "Th",
      : "th",
      : "ss",
      // Latin Extended-A block.
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "C",
      : "C",
      : "C",
      : "C",
      : "c",
      : "c",
      : "c",
      : "c",
      : "D",
      : "D",
      : "d",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "e",
      : "G",
      : "G",
      : "G",
      : "G",
      : "g",
      : "g",
      : "g",
      : "g",
      : "H",
      : "H",
      : "h",
      : "h",
      : "I",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "i",
      : "J",
      : "j",
      : "K",
      : "k",
      : "k",
      : "L",
      : "L",
      : "L",
      : "L",
      : "L",
      : "l",
      : "l",
      : "l",
      : "l",
      : "l",
      : "N",
      : "N",
      : "N",
      : "N",
      : "n",
      : "n",
      : "n",
      : "n",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "R",
      : "R",
      : "R",
      : "r",
      : "r",
      : "r",
      : "S",
      : "S",
      : "S",
      : "S",
      : "s",
      : "s",
      : "s",
      : "s",
      : "T",
      : "T",
      : "T",
      : "t",
      : "t",
      : "t",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "W",
      : "w",
      : "Y",
      : "y",
      : "Y",
      : "Z",
      : "Z",
      : "Z",
      : "z",
      : "z",
      : "z",
      : "IJ",
      : "ij",
      : "Oe",
      : "oe",
      : "'n",
      : "s"
    }, ye = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, Ge = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, Pt = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, Ur = parseFloat, rr = parseInt, Kr = typeof gn == "object" && gn && gn.Object === Object && gn, vn = typeof self == "object" && self && self.Object === Object && self, _r = Kr || vn || Function("return this")(), jr = e && !e.nodeType && e, an = jr && !0 && t && !t.nodeType && t, ci = an && an.exports === jr, bn = ci && Kr.process, Vr = function() {
      try {
        var be = an && an.require && an.require("util").types;
        return be || bn && bn.binding && bn.binding("util");
      } catch {
      }
    }(), ei = Vr && Vr.isArrayBuffer, us = Vr && Vr.isDate, Bi = Vr && Vr.isMap, Ms = Vr && Vr.isRegExp, Xu = Vr && Vr.isSet, Da = Vr && Vr.isTypedArray;
    function Pn(be, Fe, Ie) {
      switch (Ie.length) {
        case 0:
          return be.call(Fe);
        case 1:
          return be.call(Fe, Ie[0]);
        case 2:
          return be.call(Fe, Ie[0], Ie[1]);
        case 3:
          return be.call(Fe, Ie[0], Ie[1], Ie[2]);
      }
      return be.apply(Fe, Ie);
    }
    function K9(be, Fe, Ie, It) {
      for (var er = -1, Pr = be == null ? 0 : be.length; ++er < Pr; ) {
        var xn = be[er];
        Fe(It, xn, Ie(xn), be);
      }
      return It;
    }
    function Ui(be, Fe) {
      for (var Ie = -1, It = be == null ? 0 : be.length; ++Ie < It && Fe(be[Ie], Ie, be) !== !1; )
        ;
      return be;
    }
    function V9(be, Fe) {
      for (var Ie = be == null ? 0 : be.length; Ie-- && Fe(be[Ie], Ie, be) !== !1; )
        ;
      return be;
    }
    function dy(be, Fe) {
      for (var Ie = -1, It = be == null ? 0 : be.length; ++Ie < It; )
        if (!Fe(be[Ie], Ie, be))
          return !1;
      return !0;
    }
    function zo(be, Fe) {
      for (var Ie = -1, It = be == null ? 0 : be.length, er = 0, Pr = []; ++Ie < It; ) {
        var xn = be[Ie];
        Fe(xn, Ie, be) && (Pr[er++] = xn);
      }
      return Pr;
    }
    function mh(be, Fe) {
      var Ie = be == null ? 0 : be.length;
      return !!Ie && Ic(be, Fe, 0) > -1;
    }
    function Lp(be, Fe, Ie) {
      for (var It = -1, er = be == null ? 0 : be.length; ++It < er; )
        if (Ie(Fe, be[It]))
          return !0;
      return !1;
    }
    function Xr(be, Fe) {
      for (var Ie = -1, It = be == null ? 0 : be.length, er = Array(It); ++Ie < It; )
        er[Ie] = Fe(be[Ie], Ie, be);
      return er;
    }
    function Ho(be, Fe) {
      for (var Ie = -1, It = Fe.length, er = be.length; ++Ie < It; )
        be[er + Ie] = Fe[Ie];
      return be;
    }
    function kp(be, Fe, Ie, It) {
      var er = -1, Pr = be == null ? 0 : be.length;
      for (It && Pr && (Ie = be[++er]); ++er < Pr; )
        Ie = Fe(Ie, be[er], er, be);
      return Ie;
    }
    function G9(be, Fe, Ie, It) {
      var er = be == null ? 0 : be.length;
      for (It && er && (Ie = be[--er]); er--; )
        Ie = Fe(Ie, be[er], er, be);
      return Ie;
    }
    function $p(be, Fe) {
      for (var Ie = -1, It = be == null ? 0 : be.length; ++Ie < It; )
        if (Fe(be[Ie], Ie, be))
          return !0;
      return !1;
    }
    var Y9 = Fp("length");
    function J9(be) {
      return be.split("");
    }
    function X9(be) {
      return be.match(U) || [];
    }
    function py(be, Fe, Ie) {
      var It;
      return Ie(be, function(er, Pr, xn) {
        if (Fe(er, Pr, xn))
          return It = Pr, !1;
      }), It;
    }
    function vh(be, Fe, Ie, It) {
      for (var er = be.length, Pr = Ie + (It ? 1 : -1); It ? Pr-- : ++Pr < er; )
        if (Fe(be[Pr], Pr, be))
          return Pr;
      return -1;
    }
    function Ic(be, Fe, Ie) {
      return Fe === Fe ? uA(be, Fe, Ie) : vh(be, gy, Ie);
    }
    function Z9(be, Fe, Ie, It) {
      for (var er = Ie - 1, Pr = be.length; ++er < Pr; )
        if (It(be[er], Fe))
          return er;
      return -1;
    }
    function gy(be) {
      return be !== be;
    }
    function my(be, Fe) {
      var Ie = be == null ? 0 : be.length;
      return Ie ? Up(be, Fe) / Ie : v;
    }
    function Fp(be) {
      return function(Fe) {
        return Fe == null ? r : Fe[be];
      };
    }
    function Bp(be) {
      return function(Fe) {
        return be == null ? r : be[Fe];
      };
    }
    function vy(be, Fe, Ie, It, er) {
      return er(be, function(Pr, xn, qr) {
        Ie = It ? (It = !1, Pr) : Fe(Ie, Pr, xn, qr);
      }), Ie;
    }
    function Q9(be, Fe) {
      var Ie = be.length;
      for (be.sort(Fe); Ie--; )
        be[Ie] = be[Ie].value;
      return be;
    }
    function Up(be, Fe) {
      for (var Ie, It = -1, er = be.length; ++It < er; ) {
        var Pr = Fe(be[It]);
        Pr !== r && (Ie = Ie === r ? Pr : Ie + Pr);
      }
      return Ie;
    }
    function jp(be, Fe) {
      for (var Ie = -1, It = Array(be); ++Ie < be; )
        It[Ie] = Fe(Ie);
      return It;
    }
    function eA(be, Fe) {
      return Xr(Fe, function(Ie) {
        return [Ie, be[Ie]];
      });
    }
    function by(be) {
      return be && be.slice(0, _y(be) + 1).replace(k, "");
    }
    function Ai(be) {
      return function(Fe) {
        return be(Fe);
      };
    }
    function qp(be, Fe) {
      return Xr(Fe, function(Ie) {
        return be[Ie];
      });
    }
    function Zu(be, Fe) {
      return be.has(Fe);
    }
    function yy(be, Fe) {
      for (var Ie = -1, It = be.length; ++Ie < It && Ic(Fe, be[Ie], 0) > -1; )
        ;
      return Ie;
    }
    function wy(be, Fe) {
      for (var Ie = be.length; Ie-- && Ic(Fe, be[Ie], 0) > -1; )
        ;
      return Ie;
    }
    function tA(be, Fe) {
      for (var Ie = be.length, It = 0; Ie--; )
        be[Ie] === Fe && ++It;
      return It;
    }
    var rA = Bp(ae), nA = Bp(ye);
    function iA(be) {
      return "\\" + Pt[be];
    }
    function sA(be, Fe) {
      return be == null ? r : be[Fe];
    }
    function Cc(be) {
      return ph.test(be);
    }
    function oA(be) {
      return Ra.test(be);
    }
    function aA(be) {
      for (var Fe, Ie = []; !(Fe = be.next()).done; )
        Ie.push(Fe.value);
      return Ie;
    }
    function zp(be) {
      var Fe = -1, Ie = Array(be.size);
      return be.forEach(function(It, er) {
        Ie[++Fe] = [er, It];
      }), Ie;
    }
    function xy(be, Fe) {
      return function(Ie) {
        return be(Fe(Ie));
      };
    }
    function Wo(be, Fe) {
      for (var Ie = -1, It = be.length, er = 0, Pr = []; ++Ie < It; ) {
        var xn = be[Ie];
        (xn === Fe || xn === d) && (be[Ie] = d, Pr[er++] = Ie);
      }
      return Pr;
    }
    function bh(be) {
      var Fe = -1, Ie = Array(be.size);
      return be.forEach(function(It) {
        Ie[++Fe] = It;
      }), Ie;
    }
    function cA(be) {
      var Fe = -1, Ie = Array(be.size);
      return be.forEach(function(It) {
        Ie[++Fe] = [It, It];
      }), Ie;
    }
    function uA(be, Fe, Ie) {
      for (var It = Ie - 1, er = be.length; ++It < er; )
        if (be[It] === Fe)
          return It;
      return -1;
    }
    function fA(be, Fe, Ie) {
      for (var It = Ie + 1; It--; )
        if (be[It] === Fe)
          return It;
      return It;
    }
    function Tc(be) {
      return Cc(be) ? hA(be) : Y9(be);
    }
    function fs(be) {
      return Cc(be) ? dA(be) : J9(be);
    }
    function _y(be) {
      for (var Fe = be.length; Fe-- && j.test(be.charAt(Fe)); )
        ;
      return Fe;
    }
    var lA = Bp(Ge);
    function hA(be) {
      for (var Fe = Mc.lastIndex = 0; Mc.test(be); )
        ++Fe;
      return Fe;
    }
    function dA(be) {
      return be.match(Mc) || [];
    }
    function pA(be) {
      return be.match(dh) || [];
    }
    var gA = function be(Fe) {
      Fe = Fe == null ? _r : Rc.defaults(_r.Object(), Fe, Rc.pick(_r, gh));
      var Ie = Fe.Array, It = Fe.Date, er = Fe.Error, Pr = Fe.Function, xn = Fe.Math, qr = Fe.Object, Hp = Fe.RegExp, mA = Fe.String, ji = Fe.TypeError, yh = Ie.prototype, vA = Pr.prototype, Dc = qr.prototype, wh = Fe["__core-js_shared__"], xh = vA.toString, Tr = Dc.hasOwnProperty, bA = 0, Ey = function() {
        var c = /[^.]+$/.exec(wh && wh.keys && wh.keys.IE_PROTO || "");
        return c ? "Symbol(src)_1." + c : "";
      }(), _h = Dc.toString, yA = xh.call(qr), wA = _r._, xA = Hp(
        "^" + xh.call(Tr).replace(rt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Eh = ci ? Fe.Buffer : r, Ko = Fe.Symbol, Sh = Fe.Uint8Array, Sy = Eh ? Eh.allocUnsafe : r, Ah = xy(qr.getPrototypeOf, qr), Ay = qr.create, Py = Dc.propertyIsEnumerable, Ph = yh.splice, My = Ko ? Ko.isConcatSpreadable : r, Qu = Ko ? Ko.iterator : r, Oa = Ko ? Ko.toStringTag : r, Mh = function() {
        try {
          var c = Fa(qr, "defineProperty");
          return c({}, "", {}), c;
        } catch {
        }
      }(), _A = Fe.clearTimeout !== _r.clearTimeout && Fe.clearTimeout, EA = It && It.now !== _r.Date.now && It.now, SA = Fe.setTimeout !== _r.setTimeout && Fe.setTimeout, Ih = xn.ceil, Ch = xn.floor, Wp = qr.getOwnPropertySymbols, AA = Eh ? Eh.isBuffer : r, Iy = Fe.isFinite, PA = yh.join, MA = xy(qr.keys, qr), _n = xn.max, Wn = xn.min, IA = It.now, CA = Fe.parseInt, Cy = xn.random, TA = yh.reverse, Kp = Fa(Fe, "DataView"), ef = Fa(Fe, "Map"), Vp = Fa(Fe, "Promise"), Oc = Fa(Fe, "Set"), tf = Fa(Fe, "WeakMap"), rf = Fa(qr, "create"), Th = tf && new tf(), Nc = {}, RA = Ba(Kp), DA = Ba(ef), OA = Ba(Vp), NA = Ba(Oc), LA = Ba(tf), Rh = Ko ? Ko.prototype : r, nf = Rh ? Rh.valueOf : r, Ty = Rh ? Rh.toString : r;
      function ee(c) {
        if (en(c) && !nr(c) && !(c instanceof wr)) {
          if (c instanceof qi)
            return c;
          if (Tr.call(c, "__wrapped__"))
            return Rw(c);
        }
        return new qi(c);
      }
      var Lc = /* @__PURE__ */ function() {
        function c() {
        }
        return function(h) {
          if (!Zr(h))
            return {};
          if (Ay)
            return Ay(h);
          c.prototype = h;
          var y = new c();
          return c.prototype = r, y;
        };
      }();
      function Dh() {
      }
      function qi(c, h) {
        this.__wrapped__ = c, this.__actions__ = [], this.__chain__ = !!h, this.__index__ = 0, this.__values__ = r;
      }
      ee.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: gt,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: Rt,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: Nt,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: ee
        }
      }, ee.prototype = Dh.prototype, ee.prototype.constructor = ee, qi.prototype = Lc(Dh.prototype), qi.prototype.constructor = qi;
      function wr(c) {
        this.__wrapped__ = c, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = M, this.__views__ = [];
      }
      function kA() {
        var c = new wr(this.__wrapped__);
        return c.__actions__ = ui(this.__actions__), c.__dir__ = this.__dir__, c.__filtered__ = this.__filtered__, c.__iteratees__ = ui(this.__iteratees__), c.__takeCount__ = this.__takeCount__, c.__views__ = ui(this.__views__), c;
      }
      function $A() {
        if (this.__filtered__) {
          var c = new wr(this);
          c.__dir__ = -1, c.__filtered__ = !0;
        } else
          c = this.clone(), c.__dir__ *= -1;
        return c;
      }
      function FA() {
        var c = this.__wrapped__.value(), h = this.__dir__, y = nr(c), O = h < 0, q = y ? c.length : 0, ne = JP(0, q, this.__views__), fe = ne.start, ge = ne.end, we = ge - fe, He = O ? ge : fe - 1, We = this.__iteratees__, Xe = We.length, wt = 0, Ot = Wn(we, this.__takeCount__);
        if (!y || !O && q == we && Ot == we)
          return ew(c, this.__actions__);
        var Wt = [];
        e:
          for (; we-- && wt < Ot; ) {
            He += h;
            for (var ur = -1, Kt = c[He]; ++ur < Xe; ) {
              var vr = We[ur], Er = vr.iteratee, Ii = vr.type, ni = Er(Kt);
              if (Ii == g)
                Kt = ni;
              else if (!ni) {
                if (Ii == f)
                  continue e;
                break e;
              }
            }
            Wt[wt++] = Kt;
          }
        return Wt;
      }
      wr.prototype = Lc(Dh.prototype), wr.prototype.constructor = wr;
      function Na(c) {
        var h = -1, y = c == null ? 0 : c.length;
        for (this.clear(); ++h < y; ) {
          var O = c[h];
          this.set(O[0], O[1]);
        }
      }
      function BA() {
        this.__data__ = rf ? rf(null) : {}, this.size = 0;
      }
      function UA(c) {
        var h = this.has(c) && delete this.__data__[c];
        return this.size -= h ? 1 : 0, h;
      }
      function jA(c) {
        var h = this.__data__;
        if (rf) {
          var y = h[c];
          return y === u ? r : y;
        }
        return Tr.call(h, c) ? h[c] : r;
      }
      function qA(c) {
        var h = this.__data__;
        return rf ? h[c] !== r : Tr.call(h, c);
      }
      function zA(c, h) {
        var y = this.__data__;
        return this.size += this.has(c) ? 0 : 1, y[c] = rf && h === r ? u : h, this;
      }
      Na.prototype.clear = BA, Na.prototype.delete = UA, Na.prototype.get = jA, Na.prototype.has = qA, Na.prototype.set = zA;
      function io(c) {
        var h = -1, y = c == null ? 0 : c.length;
        for (this.clear(); ++h < y; ) {
          var O = c[h];
          this.set(O[0], O[1]);
        }
      }
      function HA() {
        this.__data__ = [], this.size = 0;
      }
      function WA(c) {
        var h = this.__data__, y = Oh(h, c);
        if (y < 0)
          return !1;
        var O = h.length - 1;
        return y == O ? h.pop() : Ph.call(h, y, 1), --this.size, !0;
      }
      function KA(c) {
        var h = this.__data__, y = Oh(h, c);
        return y < 0 ? r : h[y][1];
      }
      function VA(c) {
        return Oh(this.__data__, c) > -1;
      }
      function GA(c, h) {
        var y = this.__data__, O = Oh(y, c);
        return O < 0 ? (++this.size, y.push([c, h])) : y[O][1] = h, this;
      }
      io.prototype.clear = HA, io.prototype.delete = WA, io.prototype.get = KA, io.prototype.has = VA, io.prototype.set = GA;
      function so(c) {
        var h = -1, y = c == null ? 0 : c.length;
        for (this.clear(); ++h < y; ) {
          var O = c[h];
          this.set(O[0], O[1]);
        }
      }
      function YA() {
        this.size = 0, this.__data__ = {
          hash: new Na(),
          map: new (ef || io)(),
          string: new Na()
        };
      }
      function JA(c) {
        var h = Wh(this, c).delete(c);
        return this.size -= h ? 1 : 0, h;
      }
      function XA(c) {
        return Wh(this, c).get(c);
      }
      function ZA(c) {
        return Wh(this, c).has(c);
      }
      function QA(c, h) {
        var y = Wh(this, c), O = y.size;
        return y.set(c, h), this.size += y.size == O ? 0 : 1, this;
      }
      so.prototype.clear = YA, so.prototype.delete = JA, so.prototype.get = XA, so.prototype.has = ZA, so.prototype.set = QA;
      function La(c) {
        var h = -1, y = c == null ? 0 : c.length;
        for (this.__data__ = new so(); ++h < y; )
          this.add(c[h]);
      }
      function eP(c) {
        return this.__data__.set(c, u), this;
      }
      function tP(c) {
        return this.__data__.has(c);
      }
      La.prototype.add = La.prototype.push = eP, La.prototype.has = tP;
      function ls(c) {
        var h = this.__data__ = new io(c);
        this.size = h.size;
      }
      function rP() {
        this.__data__ = new io(), this.size = 0;
      }
      function nP(c) {
        var h = this.__data__, y = h.delete(c);
        return this.size = h.size, y;
      }
      function iP(c) {
        return this.__data__.get(c);
      }
      function sP(c) {
        return this.__data__.has(c);
      }
      function oP(c, h) {
        var y = this.__data__;
        if (y instanceof io) {
          var O = y.__data__;
          if (!ef || O.length < i - 1)
            return O.push([c, h]), this.size = ++y.size, this;
          y = this.__data__ = new so(O);
        }
        return y.set(c, h), this.size = y.size, this;
      }
      ls.prototype.clear = rP, ls.prototype.delete = nP, ls.prototype.get = iP, ls.prototype.has = sP, ls.prototype.set = oP;
      function Ry(c, h) {
        var y = nr(c), O = !y && Ua(c), q = !y && !O && Xo(c), ne = !y && !O && !q && Bc(c), fe = y || O || q || ne, ge = fe ? jp(c.length, mA) : [], we = ge.length;
        for (var He in c)
          (h || Tr.call(c, He)) && !(fe && // Safari 9 has enumerable `arguments.length` in strict mode.
          (He == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          q && (He == "offset" || He == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          ne && (He == "buffer" || He == "byteLength" || He == "byteOffset") || // Skip index properties.
          uo(He, we))) && ge.push(He);
        return ge;
      }
      function Dy(c) {
        var h = c.length;
        return h ? c[ig(0, h - 1)] : r;
      }
      function aP(c, h) {
        return Kh(ui(c), ka(h, 0, c.length));
      }
      function cP(c) {
        return Kh(ui(c));
      }
      function Gp(c, h, y) {
        (y !== r && !hs(c[h], y) || y === r && !(h in c)) && oo(c, h, y);
      }
      function sf(c, h, y) {
        var O = c[h];
        (!(Tr.call(c, h) && hs(O, y)) || y === r && !(h in c)) && oo(c, h, y);
      }
      function Oh(c, h) {
        for (var y = c.length; y--; )
          if (hs(c[y][0], h))
            return y;
        return -1;
      }
      function uP(c, h, y, O) {
        return Vo(c, function(q, ne, fe) {
          h(O, q, y(q), fe);
        }), O;
      }
      function Oy(c, h) {
        return c && Cs(h, Mn(h), c);
      }
      function fP(c, h) {
        return c && Cs(h, li(h), c);
      }
      function oo(c, h, y) {
        h == "__proto__" && Mh ? Mh(c, h, {
          configurable: !0,
          enumerable: !0,
          value: y,
          writable: !0
        }) : c[h] = y;
      }
      function Yp(c, h) {
        for (var y = -1, O = h.length, q = Ie(O), ne = c == null; ++y < O; )
          q[y] = ne ? r : Cg(c, h[y]);
        return q;
      }
      function ka(c, h, y) {
        return c === c && (y !== r && (c = c <= y ? c : y), h !== r && (c = c >= h ? c : h)), c;
      }
      function zi(c, h, y, O, q, ne) {
        var fe, ge = h & p, we = h & w, He = h & P;
        if (y && (fe = q ? y(c, O, q, ne) : y(c)), fe !== r)
          return fe;
        if (!Zr(c))
          return c;
        var We = nr(c);
        if (We) {
          if (fe = ZP(c), !ge)
            return ui(c, fe);
        } else {
          var Xe = Kn(c), wt = Xe == re || Xe == de;
          if (Xo(c))
            return nw(c, ge);
          if (Xe == Pe || Xe == D || wt && !q) {
            if (fe = we || wt ? {} : _w(c), !ge)
              return we ? jP(c, fP(fe, c)) : UP(c, Oy(fe, c));
          } else {
            if (!Dr[Xe])
              return q ? c : {};
            fe = QP(c, Xe, ge);
          }
        }
        ne || (ne = new ls());
        var Ot = ne.get(c);
        if (Ot)
          return Ot;
        ne.set(c, fe), Xw(c) ? c.forEach(function(Kt) {
          fe.add(zi(Kt, h, y, Kt, c, ne));
        }) : Yw(c) && c.forEach(function(Kt, vr) {
          fe.set(vr, zi(Kt, h, y, vr, c, ne));
        });
        var Wt = He ? we ? gg : pg : we ? li : Mn, ur = We ? r : Wt(c);
        return Ui(ur || c, function(Kt, vr) {
          ur && (vr = Kt, Kt = c[vr]), sf(fe, vr, zi(Kt, h, y, vr, c, ne));
        }), fe;
      }
      function lP(c) {
        var h = Mn(c);
        return function(y) {
          return Ny(y, c, h);
        };
      }
      function Ny(c, h, y) {
        var O = y.length;
        if (c == null)
          return !O;
        for (c = qr(c); O--; ) {
          var q = y[O], ne = h[q], fe = c[q];
          if (fe === r && !(q in c) || !ne(fe))
            return !1;
        }
        return !0;
      }
      function Ly(c, h, y) {
        if (typeof c != "function")
          throw new ji(o);
        return hf(function() {
          c.apply(r, y);
        }, h);
      }
      function of(c, h, y, O) {
        var q = -1, ne = mh, fe = !0, ge = c.length, we = [], He = h.length;
        if (!ge)
          return we;
        y && (h = Xr(h, Ai(y))), O ? (ne = Lp, fe = !1) : h.length >= i && (ne = Zu, fe = !1, h = new La(h));
        e:
          for (; ++q < ge; ) {
            var We = c[q], Xe = y == null ? We : y(We);
            if (We = O || We !== 0 ? We : 0, fe && Xe === Xe) {
              for (var wt = He; wt--; )
                if (h[wt] === Xe)
                  continue e;
              we.push(We);
            } else ne(h, Xe, O) || we.push(We);
          }
        return we;
      }
      var Vo = cw(Is), ky = cw(Xp, !0);
      function hP(c, h) {
        var y = !0;
        return Vo(c, function(O, q, ne) {
          return y = !!h(O, q, ne), y;
        }), y;
      }
      function Nh(c, h, y) {
        for (var O = -1, q = c.length; ++O < q; ) {
          var ne = c[O], fe = h(ne);
          if (fe != null && (ge === r ? fe === fe && !Mi(fe) : y(fe, ge)))
            var ge = fe, we = ne;
        }
        return we;
      }
      function dP(c, h, y, O) {
        var q = c.length;
        for (y = ar(y), y < 0 && (y = -y > q ? 0 : q + y), O = O === r || O > q ? q : ar(O), O < 0 && (O += q), O = y > O ? 0 : Qw(O); y < O; )
          c[y++] = h;
        return c;
      }
      function $y(c, h) {
        var y = [];
        return Vo(c, function(O, q, ne) {
          h(O, q, ne) && y.push(O);
        }), y;
      }
      function $n(c, h, y, O, q) {
        var ne = -1, fe = c.length;
        for (y || (y = tM), q || (q = []); ++ne < fe; ) {
          var ge = c[ne];
          h > 0 && y(ge) ? h > 1 ? $n(ge, h - 1, y, O, q) : Ho(q, ge) : O || (q[q.length] = ge);
        }
        return q;
      }
      var Jp = uw(), Fy = uw(!0);
      function Is(c, h) {
        return c && Jp(c, h, Mn);
      }
      function Xp(c, h) {
        return c && Fy(c, h, Mn);
      }
      function Lh(c, h) {
        return zo(h, function(y) {
          return fo(c[y]);
        });
      }
      function $a(c, h) {
        h = Yo(h, c);
        for (var y = 0, O = h.length; c != null && y < O; )
          c = c[Ts(h[y++])];
        return y && y == O ? c : r;
      }
      function By(c, h, y) {
        var O = h(c);
        return nr(c) ? O : Ho(O, y(c));
      }
      function ti(c) {
        return c == null ? c === r ? Le : ve : Oa && Oa in qr(c) ? YP(c) : cM(c);
      }
      function Zp(c, h) {
        return c > h;
      }
      function pP(c, h) {
        return c != null && Tr.call(c, h);
      }
      function gP(c, h) {
        return c != null && h in qr(c);
      }
      function mP(c, h, y) {
        return c >= Wn(h, y) && c < _n(h, y);
      }
      function Qp(c, h, y) {
        for (var O = y ? Lp : mh, q = c[0].length, ne = c.length, fe = ne, ge = Ie(ne), we = 1 / 0, He = []; fe--; ) {
          var We = c[fe];
          fe && h && (We = Xr(We, Ai(h))), we = Wn(We.length, we), ge[fe] = !y && (h || q >= 120 && We.length >= 120) ? new La(fe && We) : r;
        }
        We = c[0];
        var Xe = -1, wt = ge[0];
        e:
          for (; ++Xe < q && He.length < we; ) {
            var Ot = We[Xe], Wt = h ? h(Ot) : Ot;
            if (Ot = y || Ot !== 0 ? Ot : 0, !(wt ? Zu(wt, Wt) : O(He, Wt, y))) {
              for (fe = ne; --fe; ) {
                var ur = ge[fe];
                if (!(ur ? Zu(ur, Wt) : O(c[fe], Wt, y)))
                  continue e;
              }
              wt && wt.push(Wt), He.push(Ot);
            }
          }
        return He;
      }
      function vP(c, h, y, O) {
        return Is(c, function(q, ne, fe) {
          h(O, y(q), ne, fe);
        }), O;
      }
      function af(c, h, y) {
        h = Yo(h, c), c = Pw(c, h);
        var O = c == null ? c : c[Ts(Wi(h))];
        return O == null ? r : Pn(O, c, y);
      }
      function Uy(c) {
        return en(c) && ti(c) == D;
      }
      function bP(c) {
        return en(c) && ti(c) == _e;
      }
      function yP(c) {
        return en(c) && ti(c) == Q;
      }
      function cf(c, h, y, O, q) {
        return c === h ? !0 : c == null || h == null || !en(c) && !en(h) ? c !== c && h !== h : wP(c, h, y, O, cf, q);
      }
      function wP(c, h, y, O, q, ne) {
        var fe = nr(c), ge = nr(h), we = fe ? oe : Kn(c), He = ge ? oe : Kn(h);
        we = we == D ? Pe : we, He = He == D ? Pe : He;
        var We = we == Pe, Xe = He == Pe, wt = we == He;
        if (wt && Xo(c)) {
          if (!Xo(h))
            return !1;
          fe = !0, We = !1;
        }
        if (wt && !We)
          return ne || (ne = new ls()), fe || Bc(c) ? yw(c, h, y, O, q, ne) : VP(c, h, we, y, O, q, ne);
        if (!(y & A)) {
          var Ot = We && Tr.call(c, "__wrapped__"), Wt = Xe && Tr.call(h, "__wrapped__");
          if (Ot || Wt) {
            var ur = Ot ? c.value() : c, Kt = Wt ? h.value() : h;
            return ne || (ne = new ls()), q(ur, Kt, y, O, ne);
          }
        }
        return wt ? (ne || (ne = new ls()), GP(c, h, y, O, q, ne)) : !1;
      }
      function xP(c) {
        return en(c) && Kn(c) == ie;
      }
      function eg(c, h, y, O) {
        var q = y.length, ne = q, fe = !O;
        if (c == null)
          return !ne;
        for (c = qr(c); q--; ) {
          var ge = y[q];
          if (fe && ge[2] ? ge[1] !== c[ge[0]] : !(ge[0] in c))
            return !1;
        }
        for (; ++q < ne; ) {
          ge = y[q];
          var we = ge[0], He = c[we], We = ge[1];
          if (fe && ge[2]) {
            if (He === r && !(we in c))
              return !1;
          } else {
            var Xe = new ls();
            if (O)
              var wt = O(He, We, we, c, h, Xe);
            if (!(wt === r ? cf(We, He, A | N, O, Xe) : wt))
              return !1;
          }
        }
        return !0;
      }
      function jy(c) {
        if (!Zr(c) || nM(c))
          return !1;
        var h = fo(c) ? xA : Ue;
        return h.test(Ba(c));
      }
      function _P(c) {
        return en(c) && ti(c) == $e;
      }
      function EP(c) {
        return en(c) && Kn(c) == Me;
      }
      function SP(c) {
        return en(c) && Zh(c.length) && !!Br[ti(c)];
      }
      function qy(c) {
        return typeof c == "function" ? c : c == null ? hi : typeof c == "object" ? nr(c) ? Wy(c[0], c[1]) : Hy(c) : f2(c);
      }
      function tg(c) {
        if (!lf(c))
          return MA(c);
        var h = [];
        for (var y in qr(c))
          Tr.call(c, y) && y != "constructor" && h.push(y);
        return h;
      }
      function AP(c) {
        if (!Zr(c))
          return aM(c);
        var h = lf(c), y = [];
        for (var O in c)
          O == "constructor" && (h || !Tr.call(c, O)) || y.push(O);
        return y;
      }
      function rg(c, h) {
        return c < h;
      }
      function zy(c, h) {
        var y = -1, O = fi(c) ? Ie(c.length) : [];
        return Vo(c, function(q, ne, fe) {
          O[++y] = h(q, ne, fe);
        }), O;
      }
      function Hy(c) {
        var h = vg(c);
        return h.length == 1 && h[0][2] ? Sw(h[0][0], h[0][1]) : function(y) {
          return y === c || eg(y, c, h);
        };
      }
      function Wy(c, h) {
        return yg(c) && Ew(h) ? Sw(Ts(c), h) : function(y) {
          var O = Cg(y, c);
          return O === r && O === h ? Tg(y, c) : cf(h, O, A | N);
        };
      }
      function kh(c, h, y, O, q) {
        c !== h && Jp(h, function(ne, fe) {
          if (q || (q = new ls()), Zr(ne))
            PP(c, h, fe, y, kh, O, q);
          else {
            var ge = O ? O(xg(c, fe), ne, fe + "", c, h, q) : r;
            ge === r && (ge = ne), Gp(c, fe, ge);
          }
        }, li);
      }
      function PP(c, h, y, O, q, ne, fe) {
        var ge = xg(c, y), we = xg(h, y), He = fe.get(we);
        if (He) {
          Gp(c, y, He);
          return;
        }
        var We = ne ? ne(ge, we, y + "", c, h, fe) : r, Xe = We === r;
        if (Xe) {
          var wt = nr(we), Ot = !wt && Xo(we), Wt = !wt && !Ot && Bc(we);
          We = we, wt || Ot || Wt ? nr(ge) ? We = ge : cn(ge) ? We = ui(ge) : Ot ? (Xe = !1, We = nw(we, !0)) : Wt ? (Xe = !1, We = iw(we, !0)) : We = [] : df(we) || Ua(we) ? (We = ge, Ua(ge) ? We = e2(ge) : (!Zr(ge) || fo(ge)) && (We = _w(we))) : Xe = !1;
        }
        Xe && (fe.set(we, We), q(We, we, O, ne, fe), fe.delete(we)), Gp(c, y, We);
      }
      function Ky(c, h) {
        var y = c.length;
        if (y)
          return h += h < 0 ? y : 0, uo(h, y) ? c[h] : r;
      }
      function Vy(c, h, y) {
        h.length ? h = Xr(h, function(ne) {
          return nr(ne) ? function(fe) {
            return $a(fe, ne.length === 1 ? ne[0] : ne);
          } : ne;
        }) : h = [hi];
        var O = -1;
        h = Xr(h, Ai(jt()));
        var q = zy(c, function(ne, fe, ge) {
          var we = Xr(h, function(He) {
            return He(ne);
          });
          return { criteria: we, index: ++O, value: ne };
        });
        return Q9(q, function(ne, fe) {
          return BP(ne, fe, y);
        });
      }
      function MP(c, h) {
        return Gy(c, h, function(y, O) {
          return Tg(c, O);
        });
      }
      function Gy(c, h, y) {
        for (var O = -1, q = h.length, ne = {}; ++O < q; ) {
          var fe = h[O], ge = $a(c, fe);
          y(ge, fe) && uf(ne, Yo(fe, c), ge);
        }
        return ne;
      }
      function IP(c) {
        return function(h) {
          return $a(h, c);
        };
      }
      function ng(c, h, y, O) {
        var q = O ? Z9 : Ic, ne = -1, fe = h.length, ge = c;
        for (c === h && (h = ui(h)), y && (ge = Xr(c, Ai(y))); ++ne < fe; )
          for (var we = 0, He = h[ne], We = y ? y(He) : He; (we = q(ge, We, we, O)) > -1; )
            ge !== c && Ph.call(ge, we, 1), Ph.call(c, we, 1);
        return c;
      }
      function Yy(c, h) {
        for (var y = c ? h.length : 0, O = y - 1; y--; ) {
          var q = h[y];
          if (y == O || q !== ne) {
            var ne = q;
            uo(q) ? Ph.call(c, q, 1) : ag(c, q);
          }
        }
        return c;
      }
      function ig(c, h) {
        return c + Ch(Cy() * (h - c + 1));
      }
      function CP(c, h, y, O) {
        for (var q = -1, ne = _n(Ih((h - c) / (y || 1)), 0), fe = Ie(ne); ne--; )
          fe[O ? ne : ++q] = c, c += y;
        return fe;
      }
      function sg(c, h) {
        var y = "";
        if (!c || h < 1 || h > _)
          return y;
        do
          h % 2 && (y += c), h = Ch(h / 2), h && (c += c);
        while (h);
        return y;
      }
      function hr(c, h) {
        return _g(Aw(c, h, hi), c + "");
      }
      function TP(c) {
        return Dy(Uc(c));
      }
      function RP(c, h) {
        var y = Uc(c);
        return Kh(y, ka(h, 0, y.length));
      }
      function uf(c, h, y, O) {
        if (!Zr(c))
          return c;
        h = Yo(h, c);
        for (var q = -1, ne = h.length, fe = ne - 1, ge = c; ge != null && ++q < ne; ) {
          var we = Ts(h[q]), He = y;
          if (we === "__proto__" || we === "constructor" || we === "prototype")
            return c;
          if (q != fe) {
            var We = ge[we];
            He = O ? O(We, we, ge) : r, He === r && (He = Zr(We) ? We : uo(h[q + 1]) ? [] : {});
          }
          sf(ge, we, He), ge = ge[we];
        }
        return c;
      }
      var Jy = Th ? function(c, h) {
        return Th.set(c, h), c;
      } : hi, DP = Mh ? function(c, h) {
        return Mh(c, "toString", {
          configurable: !0,
          enumerable: !1,
          value: Dg(h),
          writable: !0
        });
      } : hi;
      function OP(c) {
        return Kh(Uc(c));
      }
      function Hi(c, h, y) {
        var O = -1, q = c.length;
        h < 0 && (h = -h > q ? 0 : q + h), y = y > q ? q : y, y < 0 && (y += q), q = h > y ? 0 : y - h >>> 0, h >>>= 0;
        for (var ne = Ie(q); ++O < q; )
          ne[O] = c[O + h];
        return ne;
      }
      function NP(c, h) {
        var y;
        return Vo(c, function(O, q, ne) {
          return y = h(O, q, ne), !y;
        }), !!y;
      }
      function $h(c, h, y) {
        var O = 0, q = c == null ? O : c.length;
        if (typeof h == "number" && h === h && q <= B) {
          for (; O < q; ) {
            var ne = O + q >>> 1, fe = c[ne];
            fe !== null && !Mi(fe) && (y ? fe <= h : fe < h) ? O = ne + 1 : q = ne;
          }
          return q;
        }
        return og(c, h, hi, y);
      }
      function og(c, h, y, O) {
        var q = 0, ne = c == null ? 0 : c.length;
        if (ne === 0)
          return 0;
        h = y(h);
        for (var fe = h !== h, ge = h === null, we = Mi(h), He = h === r; q < ne; ) {
          var We = Ch((q + ne) / 2), Xe = y(c[We]), wt = Xe !== r, Ot = Xe === null, Wt = Xe === Xe, ur = Mi(Xe);
          if (fe)
            var Kt = O || Wt;
          else He ? Kt = Wt && (O || wt) : ge ? Kt = Wt && wt && (O || !Ot) : we ? Kt = Wt && wt && !Ot && (O || !ur) : Ot || ur ? Kt = !1 : Kt = O ? Xe <= h : Xe < h;
          Kt ? q = We + 1 : ne = We;
        }
        return Wn(ne, I);
      }
      function Xy(c, h) {
        for (var y = -1, O = c.length, q = 0, ne = []; ++y < O; ) {
          var fe = c[y], ge = h ? h(fe) : fe;
          if (!y || !hs(ge, we)) {
            var we = ge;
            ne[q++] = fe === 0 ? 0 : fe;
          }
        }
        return ne;
      }
      function Zy(c) {
        return typeof c == "number" ? c : Mi(c) ? v : +c;
      }
      function Pi(c) {
        if (typeof c == "string")
          return c;
        if (nr(c))
          return Xr(c, Pi) + "";
        if (Mi(c))
          return Ty ? Ty.call(c) : "";
        var h = c + "";
        return h == "0" && 1 / c == -x ? "-0" : h;
      }
      function Go(c, h, y) {
        var O = -1, q = mh, ne = c.length, fe = !0, ge = [], we = ge;
        if (y)
          fe = !1, q = Lp;
        else if (ne >= i) {
          var He = h ? null : WP(c);
          if (He)
            return bh(He);
          fe = !1, q = Zu, we = new La();
        } else
          we = h ? [] : ge;
        e:
          for (; ++O < ne; ) {
            var We = c[O], Xe = h ? h(We) : We;
            if (We = y || We !== 0 ? We : 0, fe && Xe === Xe) {
              for (var wt = we.length; wt--; )
                if (we[wt] === Xe)
                  continue e;
              h && we.push(Xe), ge.push(We);
            } else q(we, Xe, y) || (we !== ge && we.push(Xe), ge.push(We));
          }
        return ge;
      }
      function ag(c, h) {
        return h = Yo(h, c), c = Pw(c, h), c == null || delete c[Ts(Wi(h))];
      }
      function Qy(c, h, y, O) {
        return uf(c, h, y($a(c, h)), O);
      }
      function Fh(c, h, y, O) {
        for (var q = c.length, ne = O ? q : -1; (O ? ne-- : ++ne < q) && h(c[ne], ne, c); )
          ;
        return y ? Hi(c, O ? 0 : ne, O ? ne + 1 : q) : Hi(c, O ? ne + 1 : 0, O ? q : ne);
      }
      function ew(c, h) {
        var y = c;
        return y instanceof wr && (y = y.value()), kp(h, function(O, q) {
          return q.func.apply(q.thisArg, Ho([O], q.args));
        }, y);
      }
      function cg(c, h, y) {
        var O = c.length;
        if (O < 2)
          return O ? Go(c[0]) : [];
        for (var q = -1, ne = Ie(O); ++q < O; )
          for (var fe = c[q], ge = -1; ++ge < O; )
            ge != q && (ne[q] = of(ne[q] || fe, c[ge], h, y));
        return Go($n(ne, 1), h, y);
      }
      function tw(c, h, y) {
        for (var O = -1, q = c.length, ne = h.length, fe = {}; ++O < q; ) {
          var ge = O < ne ? h[O] : r;
          y(fe, c[O], ge);
        }
        return fe;
      }
      function ug(c) {
        return cn(c) ? c : [];
      }
      function fg(c) {
        return typeof c == "function" ? c : hi;
      }
      function Yo(c, h) {
        return nr(c) ? c : yg(c, h) ? [c] : Tw(Cr(c));
      }
      var LP = hr;
      function Jo(c, h, y) {
        var O = c.length;
        return y = y === r ? O : y, !h && y >= O ? c : Hi(c, h, y);
      }
      var rw = _A || function(c) {
        return _r.clearTimeout(c);
      };
      function nw(c, h) {
        if (h)
          return c.slice();
        var y = c.length, O = Sy ? Sy(y) : new c.constructor(y);
        return c.copy(O), O;
      }
      function lg(c) {
        var h = new c.constructor(c.byteLength);
        return new Sh(h).set(new Sh(c)), h;
      }
      function kP(c, h) {
        var y = h ? lg(c.buffer) : c.buffer;
        return new c.constructor(y, c.byteOffset, c.byteLength);
      }
      function $P(c) {
        var h = new c.constructor(c.source, Te.exec(c));
        return h.lastIndex = c.lastIndex, h;
      }
      function FP(c) {
        return nf ? qr(nf.call(c)) : {};
      }
      function iw(c, h) {
        var y = h ? lg(c.buffer) : c.buffer;
        return new c.constructor(y, c.byteOffset, c.length);
      }
      function sw(c, h) {
        if (c !== h) {
          var y = c !== r, O = c === null, q = c === c, ne = Mi(c), fe = h !== r, ge = h === null, we = h === h, He = Mi(h);
          if (!ge && !He && !ne && c > h || ne && fe && we && !ge && !He || O && fe && we || !y && we || !q)
            return 1;
          if (!O && !ne && !He && c < h || He && y && q && !O && !ne || ge && y && q || !fe && q || !we)
            return -1;
        }
        return 0;
      }
      function BP(c, h, y) {
        for (var O = -1, q = c.criteria, ne = h.criteria, fe = q.length, ge = y.length; ++O < fe; ) {
          var we = sw(q[O], ne[O]);
          if (we) {
            if (O >= ge)
              return we;
            var He = y[O];
            return we * (He == "desc" ? -1 : 1);
          }
        }
        return c.index - h.index;
      }
      function ow(c, h, y, O) {
        for (var q = -1, ne = c.length, fe = y.length, ge = -1, we = h.length, He = _n(ne - fe, 0), We = Ie(we + He), Xe = !O; ++ge < we; )
          We[ge] = h[ge];
        for (; ++q < fe; )
          (Xe || q < ne) && (We[y[q]] = c[q]);
        for (; He--; )
          We[ge++] = c[q++];
        return We;
      }
      function aw(c, h, y, O) {
        for (var q = -1, ne = c.length, fe = -1, ge = y.length, we = -1, He = h.length, We = _n(ne - ge, 0), Xe = Ie(We + He), wt = !O; ++q < We; )
          Xe[q] = c[q];
        for (var Ot = q; ++we < He; )
          Xe[Ot + we] = h[we];
        for (; ++fe < ge; )
          (wt || q < ne) && (Xe[Ot + y[fe]] = c[q++]);
        return Xe;
      }
      function ui(c, h) {
        var y = -1, O = c.length;
        for (h || (h = Ie(O)); ++y < O; )
          h[y] = c[y];
        return h;
      }
      function Cs(c, h, y, O) {
        var q = !y;
        y || (y = {});
        for (var ne = -1, fe = h.length; ++ne < fe; ) {
          var ge = h[ne], we = O ? O(y[ge], c[ge], ge, y, c) : r;
          we === r && (we = c[ge]), q ? oo(y, ge, we) : sf(y, ge, we);
        }
        return y;
      }
      function UP(c, h) {
        return Cs(c, bg(c), h);
      }
      function jP(c, h) {
        return Cs(c, ww(c), h);
      }
      function Bh(c, h) {
        return function(y, O) {
          var q = nr(y) ? K9 : uP, ne = h ? h() : {};
          return q(y, c, jt(O, 2), ne);
        };
      }
      function kc(c) {
        return hr(function(h, y) {
          var O = -1, q = y.length, ne = q > 1 ? y[q - 1] : r, fe = q > 2 ? y[2] : r;
          for (ne = c.length > 3 && typeof ne == "function" ? (q--, ne) : r, fe && ri(y[0], y[1], fe) && (ne = q < 3 ? r : ne, q = 1), h = qr(h); ++O < q; ) {
            var ge = y[O];
            ge && c(h, ge, O, ne);
          }
          return h;
        });
      }
      function cw(c, h) {
        return function(y, O) {
          if (y == null)
            return y;
          if (!fi(y))
            return c(y, O);
          for (var q = y.length, ne = h ? q : -1, fe = qr(y); (h ? ne-- : ++ne < q) && O(fe[ne], ne, fe) !== !1; )
            ;
          return y;
        };
      }
      function uw(c) {
        return function(h, y, O) {
          for (var q = -1, ne = qr(h), fe = O(h), ge = fe.length; ge--; ) {
            var we = fe[c ? ge : ++q];
            if (y(ne[we], we, ne) === !1)
              break;
          }
          return h;
        };
      }
      function qP(c, h, y) {
        var O = h & L, q = ff(c);
        function ne() {
          var fe = this && this !== _r && this instanceof ne ? q : c;
          return fe.apply(O ? y : this, arguments);
        }
        return ne;
      }
      function fw(c) {
        return function(h) {
          h = Cr(h);
          var y = Cc(h) ? fs(h) : r, O = y ? y[0] : h.charAt(0), q = y ? Jo(y, 1).join("") : h.slice(1);
          return O[c]() + q;
        };
      }
      function $c(c) {
        return function(h) {
          return kp(c2(a2(h).replace(Ju, "")), c, "");
        };
      }
      function ff(c) {
        return function() {
          var h = arguments;
          switch (h.length) {
            case 0:
              return new c();
            case 1:
              return new c(h[0]);
            case 2:
              return new c(h[0], h[1]);
            case 3:
              return new c(h[0], h[1], h[2]);
            case 4:
              return new c(h[0], h[1], h[2], h[3]);
            case 5:
              return new c(h[0], h[1], h[2], h[3], h[4]);
            case 6:
              return new c(h[0], h[1], h[2], h[3], h[4], h[5]);
            case 7:
              return new c(h[0], h[1], h[2], h[3], h[4], h[5], h[6]);
          }
          var y = Lc(c.prototype), O = c.apply(y, h);
          return Zr(O) ? O : y;
        };
      }
      function zP(c, h, y) {
        var O = ff(c);
        function q() {
          for (var ne = arguments.length, fe = Ie(ne), ge = ne, we = Fc(q); ge--; )
            fe[ge] = arguments[ge];
          var He = ne < 3 && fe[0] !== we && fe[ne - 1] !== we ? [] : Wo(fe, we);
          if (ne -= He.length, ne < y)
            return gw(
              c,
              h,
              Uh,
              q.placeholder,
              r,
              fe,
              He,
              r,
              r,
              y - ne
            );
          var We = this && this !== _r && this instanceof q ? O : c;
          return Pn(We, this, fe);
        }
        return q;
      }
      function lw(c) {
        return function(h, y, O) {
          var q = qr(h);
          if (!fi(h)) {
            var ne = jt(y, 3);
            h = Mn(h), y = function(ge) {
              return ne(q[ge], ge, q);
            };
          }
          var fe = c(h, y, O);
          return fe > -1 ? q[ne ? h[fe] : fe] : r;
        };
      }
      function hw(c) {
        return co(function(h) {
          var y = h.length, O = y, q = qi.prototype.thru;
          for (c && h.reverse(); O--; ) {
            var ne = h[O];
            if (typeof ne != "function")
              throw new ji(o);
            if (q && !fe && Hh(ne) == "wrapper")
              var fe = new qi([], !0);
          }
          for (O = fe ? O : y; ++O < y; ) {
            ne = h[O];
            var ge = Hh(ne), we = ge == "wrapper" ? mg(ne) : r;
            we && wg(we[0]) && we[1] == (R | K | V | W) && !we[4].length && we[9] == 1 ? fe = fe[Hh(we[0])].apply(fe, we[3]) : fe = ne.length == 1 && wg(ne) ? fe[ge]() : fe.thru(ne);
          }
          return function() {
            var He = arguments, We = He[0];
            if (fe && He.length == 1 && nr(We))
              return fe.plant(We).value();
            for (var Xe = 0, wt = y ? h[Xe].apply(this, He) : We; ++Xe < y; )
              wt = h[Xe].call(this, wt);
            return wt;
          };
        });
      }
      function Uh(c, h, y, O, q, ne, fe, ge, we, He) {
        var We = h & R, Xe = h & L, wt = h & F, Ot = h & (K | H), Wt = h & pe, ur = wt ? r : ff(c);
        function Kt() {
          for (var vr = arguments.length, Er = Ie(vr), Ii = vr; Ii--; )
            Er[Ii] = arguments[Ii];
          if (Ot)
            var ni = Fc(Kt), Ci = tA(Er, ni);
          if (O && (Er = ow(Er, O, q, Ot)), ne && (Er = aw(Er, ne, fe, Ot)), vr -= Ci, Ot && vr < He) {
            var un = Wo(Er, ni);
            return gw(
              c,
              h,
              Uh,
              Kt.placeholder,
              y,
              Er,
              un,
              ge,
              we,
              He - vr
            );
          }
          var ds = Xe ? y : this, ho = wt ? ds[c] : c;
          return vr = Er.length, ge ? Er = uM(Er, ge) : Wt && vr > 1 && Er.reverse(), We && we < vr && (Er.length = we), this && this !== _r && this instanceof Kt && (ho = ur || ff(ho)), ho.apply(ds, Er);
        }
        return Kt;
      }
      function dw(c, h) {
        return function(y, O) {
          return vP(y, c, h(O), {});
        };
      }
      function jh(c, h) {
        return function(y, O) {
          var q;
          if (y === r && O === r)
            return h;
          if (y !== r && (q = y), O !== r) {
            if (q === r)
              return O;
            typeof y == "string" || typeof O == "string" ? (y = Pi(y), O = Pi(O)) : (y = Zy(y), O = Zy(O)), q = c(y, O);
          }
          return q;
        };
      }
      function hg(c) {
        return co(function(h) {
          return h = Xr(h, Ai(jt())), hr(function(y) {
            var O = this;
            return c(h, function(q) {
              return Pn(q, O, y);
            });
          });
        });
      }
      function qh(c, h) {
        h = h === r ? " " : Pi(h);
        var y = h.length;
        if (y < 2)
          return y ? sg(h, c) : h;
        var O = sg(h, Ih(c / Tc(h)));
        return Cc(h) ? Jo(fs(O), 0, c).join("") : O.slice(0, c);
      }
      function HP(c, h, y, O) {
        var q = h & L, ne = ff(c);
        function fe() {
          for (var ge = -1, we = arguments.length, He = -1, We = O.length, Xe = Ie(We + we), wt = this && this !== _r && this instanceof fe ? ne : c; ++He < We; )
            Xe[He] = O[He];
          for (; we--; )
            Xe[He++] = arguments[++ge];
          return Pn(wt, q ? y : this, Xe);
        }
        return fe;
      }
      function pw(c) {
        return function(h, y, O) {
          return O && typeof O != "number" && ri(h, y, O) && (y = O = r), h = lo(h), y === r ? (y = h, h = 0) : y = lo(y), O = O === r ? h < y ? 1 : -1 : lo(O), CP(h, y, O, c);
        };
      }
      function zh(c) {
        return function(h, y) {
          return typeof h == "string" && typeof y == "string" || (h = Ki(h), y = Ki(y)), c(h, y);
        };
      }
      function gw(c, h, y, O, q, ne, fe, ge, we, He) {
        var We = h & K, Xe = We ? fe : r, wt = We ? r : fe, Ot = We ? ne : r, Wt = We ? r : ne;
        h |= We ? V : te, h &= ~(We ? te : V), h & $ || (h &= ~(L | F));
        var ur = [
          c,
          h,
          q,
          Ot,
          Xe,
          Wt,
          wt,
          ge,
          we,
          He
        ], Kt = y.apply(r, ur);
        return wg(c) && Mw(Kt, ur), Kt.placeholder = O, Iw(Kt, c, h);
      }
      function dg(c) {
        var h = xn[c];
        return function(y, O) {
          if (y = Ki(y), O = O == null ? 0 : Wn(ar(O), 292), O && Iy(y)) {
            var q = (Cr(y) + "e").split("e"), ne = h(q[0] + "e" + (+q[1] + O));
            return q = (Cr(ne) + "e").split("e"), +(q[0] + "e" + (+q[1] - O));
          }
          return h(y);
        };
      }
      var WP = Oc && 1 / bh(new Oc([, -0]))[1] == x ? function(c) {
        return new Oc(c);
      } : Lg;
      function mw(c) {
        return function(h) {
          var y = Kn(h);
          return y == ie ? zp(h) : y == Me ? cA(h) : eA(h, c(h));
        };
      }
      function ao(c, h, y, O, q, ne, fe, ge) {
        var we = h & F;
        if (!we && typeof c != "function")
          throw new ji(o);
        var He = O ? O.length : 0;
        if (He || (h &= ~(V | te), O = q = r), fe = fe === r ? fe : _n(ar(fe), 0), ge = ge === r ? ge : ar(ge), He -= q ? q.length : 0, h & te) {
          var We = O, Xe = q;
          O = q = r;
        }
        var wt = we ? r : mg(c), Ot = [
          c,
          h,
          y,
          O,
          q,
          We,
          Xe,
          ne,
          fe,
          ge
        ];
        if (wt && oM(Ot, wt), c = Ot[0], h = Ot[1], y = Ot[2], O = Ot[3], q = Ot[4], ge = Ot[9] = Ot[9] === r ? we ? 0 : c.length : _n(Ot[9] - He, 0), !ge && h & (K | H) && (h &= ~(K | H)), !h || h == L)
          var Wt = qP(c, h, y);
        else h == K || h == H ? Wt = zP(c, h, ge) : (h == V || h == (L | V)) && !q.length ? Wt = HP(c, h, y, O) : Wt = Uh.apply(r, Ot);
        var ur = wt ? Jy : Mw;
        return Iw(ur(Wt, Ot), c, h);
      }
      function vw(c, h, y, O) {
        return c === r || hs(c, Dc[y]) && !Tr.call(O, y) ? h : c;
      }
      function bw(c, h, y, O, q, ne) {
        return Zr(c) && Zr(h) && (ne.set(h, c), kh(c, h, r, bw, ne), ne.delete(h)), c;
      }
      function KP(c) {
        return df(c) ? r : c;
      }
      function yw(c, h, y, O, q, ne) {
        var fe = y & A, ge = c.length, we = h.length;
        if (ge != we && !(fe && we > ge))
          return !1;
        var He = ne.get(c), We = ne.get(h);
        if (He && We)
          return He == h && We == c;
        var Xe = -1, wt = !0, Ot = y & N ? new La() : r;
        for (ne.set(c, h), ne.set(h, c); ++Xe < ge; ) {
          var Wt = c[Xe], ur = h[Xe];
          if (O)
            var Kt = fe ? O(ur, Wt, Xe, h, c, ne) : O(Wt, ur, Xe, c, h, ne);
          if (Kt !== r) {
            if (Kt)
              continue;
            wt = !1;
            break;
          }
          if (Ot) {
            if (!$p(h, function(vr, Er) {
              if (!Zu(Ot, Er) && (Wt === vr || q(Wt, vr, y, O, ne)))
                return Ot.push(Er);
            })) {
              wt = !1;
              break;
            }
          } else if (!(Wt === ur || q(Wt, ur, y, O, ne))) {
            wt = !1;
            break;
          }
        }
        return ne.delete(c), ne.delete(h), wt;
      }
      function VP(c, h, y, O, q, ne, fe) {
        switch (y) {
          case Ze:
            if (c.byteLength != h.byteLength || c.byteOffset != h.byteOffset)
              return !1;
            c = c.buffer, h = h.buffer;
          case _e:
            return !(c.byteLength != h.byteLength || !ne(new Sh(c), new Sh(h)));
          case J:
          case Q:
          case ue:
            return hs(+c, +h);
          case X:
            return c.name == h.name && c.message == h.message;
          case $e:
          case Ne:
            return c == h + "";
          case ie:
            var ge = zp;
          case Me:
            var we = O & A;
            if (ge || (ge = bh), c.size != h.size && !we)
              return !1;
            var He = fe.get(c);
            if (He)
              return He == h;
            O |= N, fe.set(c, h);
            var We = yw(ge(c), ge(h), O, q, ne, fe);
            return fe.delete(c), We;
          case Ke:
            if (nf)
              return nf.call(c) == nf.call(h);
        }
        return !1;
      }
      function GP(c, h, y, O, q, ne) {
        var fe = y & A, ge = pg(c), we = ge.length, He = pg(h), We = He.length;
        if (we != We && !fe)
          return !1;
        for (var Xe = we; Xe--; ) {
          var wt = ge[Xe];
          if (!(fe ? wt in h : Tr.call(h, wt)))
            return !1;
        }
        var Ot = ne.get(c), Wt = ne.get(h);
        if (Ot && Wt)
          return Ot == h && Wt == c;
        var ur = !0;
        ne.set(c, h), ne.set(h, c);
        for (var Kt = fe; ++Xe < we; ) {
          wt = ge[Xe];
          var vr = c[wt], Er = h[wt];
          if (O)
            var Ii = fe ? O(Er, vr, wt, h, c, ne) : O(vr, Er, wt, c, h, ne);
          if (!(Ii === r ? vr === Er || q(vr, Er, y, O, ne) : Ii)) {
            ur = !1;
            break;
          }
          Kt || (Kt = wt == "constructor");
        }
        if (ur && !Kt) {
          var ni = c.constructor, Ci = h.constructor;
          ni != Ci && "constructor" in c && "constructor" in h && !(typeof ni == "function" && ni instanceof ni && typeof Ci == "function" && Ci instanceof Ci) && (ur = !1);
        }
        return ne.delete(c), ne.delete(h), ur;
      }
      function co(c) {
        return _g(Aw(c, r, Nw), c + "");
      }
      function pg(c) {
        return By(c, Mn, bg);
      }
      function gg(c) {
        return By(c, li, ww);
      }
      var mg = Th ? function(c) {
        return Th.get(c);
      } : Lg;
      function Hh(c) {
        for (var h = c.name + "", y = Nc[h], O = Tr.call(Nc, h) ? y.length : 0; O--; ) {
          var q = y[O], ne = q.func;
          if (ne == null || ne == c)
            return q.name;
        }
        return h;
      }
      function Fc(c) {
        var h = Tr.call(ee, "placeholder") ? ee : c;
        return h.placeholder;
      }
      function jt() {
        var c = ee.iteratee || Og;
        return c = c === Og ? qy : c, arguments.length ? c(arguments[0], arguments[1]) : c;
      }
      function Wh(c, h) {
        var y = c.__data__;
        return rM(h) ? y[typeof h == "string" ? "string" : "hash"] : y.map;
      }
      function vg(c) {
        for (var h = Mn(c), y = h.length; y--; ) {
          var O = h[y], q = c[O];
          h[y] = [O, q, Ew(q)];
        }
        return h;
      }
      function Fa(c, h) {
        var y = sA(c, h);
        return jy(y) ? y : r;
      }
      function YP(c) {
        var h = Tr.call(c, Oa), y = c[Oa];
        try {
          c[Oa] = r;
          var O = !0;
        } catch {
        }
        var q = _h.call(c);
        return O && (h ? c[Oa] = y : delete c[Oa]), q;
      }
      var bg = Wp ? function(c) {
        return c == null ? [] : (c = qr(c), zo(Wp(c), function(h) {
          return Py.call(c, h);
        }));
      } : kg, ww = Wp ? function(c) {
        for (var h = []; c; )
          Ho(h, bg(c)), c = Ah(c);
        return h;
      } : kg, Kn = ti;
      (Kp && Kn(new Kp(new ArrayBuffer(1))) != Ze || ef && Kn(new ef()) != ie || Vp && Kn(Vp.resolve()) != De || Oc && Kn(new Oc()) != Me || tf && Kn(new tf()) != qe) && (Kn = function(c) {
        var h = ti(c), y = h == Pe ? c.constructor : r, O = y ? Ba(y) : "";
        if (O)
          switch (O) {
            case RA:
              return Ze;
            case DA:
              return ie;
            case OA:
              return De;
            case NA:
              return Me;
            case LA:
              return qe;
          }
        return h;
      });
      function JP(c, h, y) {
        for (var O = -1, q = y.length; ++O < q; ) {
          var ne = y[O], fe = ne.size;
          switch (ne.type) {
            case "drop":
              c += fe;
              break;
            case "dropRight":
              h -= fe;
              break;
            case "take":
              h = Wn(h, c + fe);
              break;
            case "takeRight":
              c = _n(c, h - fe);
              break;
          }
        }
        return { start: c, end: h };
      }
      function XP(c) {
        var h = c.match(C);
        return h ? h[1].split(G) : [];
      }
      function xw(c, h, y) {
        h = Yo(h, c);
        for (var O = -1, q = h.length, ne = !1; ++O < q; ) {
          var fe = Ts(h[O]);
          if (!(ne = c != null && y(c, fe)))
            break;
          c = c[fe];
        }
        return ne || ++O != q ? ne : (q = c == null ? 0 : c.length, !!q && Zh(q) && uo(fe, q) && (nr(c) || Ua(c)));
      }
      function ZP(c) {
        var h = c.length, y = new c.constructor(h);
        return h && typeof c[0] == "string" && Tr.call(c, "index") && (y.index = c.index, y.input = c.input), y;
      }
      function _w(c) {
        return typeof c.constructor == "function" && !lf(c) ? Lc(Ah(c)) : {};
      }
      function QP(c, h, y) {
        var O = c.constructor;
        switch (h) {
          case _e:
            return lg(c);
          case J:
          case Q:
            return new O(+c);
          case Ze:
            return kP(c, y);
          case at:
          case ke:
          case Qe:
          case tt:
          case Ye:
          case dt:
          case lt:
          case ct:
          case qt:
            return iw(c, y);
          case ie:
            return new O();
          case ue:
          case Ne:
            return new O(c);
          case $e:
            return $P(c);
          case Me:
            return new O();
          case Ke:
            return FP(c);
        }
      }
      function eM(c, h) {
        var y = h.length;
        if (!y)
          return c;
        var O = y - 1;
        return h[O] = (y > 1 ? "& " : "") + h[O], h = h.join(y > 2 ? ", " : " "), c.replace(z, `{
/* [wrapped with ` + h + `] */
`);
      }
      function tM(c) {
        return nr(c) || Ua(c) || !!(My && c && c[My]);
      }
      function uo(c, h) {
        var y = typeof c;
        return h = h ?? _, !!h && (y == "number" || y != "symbol" && it.test(c)) && c > -1 && c % 1 == 0 && c < h;
      }
      function ri(c, h, y) {
        if (!Zr(y))
          return !1;
        var O = typeof h;
        return (O == "number" ? fi(y) && uo(h, y.length) : O == "string" && h in y) ? hs(y[h], c) : !1;
      }
      function yg(c, h) {
        if (nr(c))
          return !1;
        var y = typeof c;
        return y == "number" || y == "symbol" || y == "boolean" || c == null || Mi(c) ? !0 : $t.test(c) || !vt.test(c) || h != null && c in qr(h);
      }
      function rM(c) {
        var h = typeof c;
        return h == "string" || h == "number" || h == "symbol" || h == "boolean" ? c !== "__proto__" : c === null;
      }
      function wg(c) {
        var h = Hh(c), y = ee[h];
        if (typeof y != "function" || !(h in wr.prototype))
          return !1;
        if (c === y)
          return !0;
        var O = mg(y);
        return !!O && c === O[0];
      }
      function nM(c) {
        return !!Ey && Ey in c;
      }
      var iM = wh ? fo : $g;
      function lf(c) {
        var h = c && c.constructor, y = typeof h == "function" && h.prototype || Dc;
        return c === y;
      }
      function Ew(c) {
        return c === c && !Zr(c);
      }
      function Sw(c, h) {
        return function(y) {
          return y == null ? !1 : y[c] === h && (h !== r || c in qr(y));
        };
      }
      function sM(c) {
        var h = Jh(c, function(O) {
          return y.size === l && y.clear(), O;
        }), y = h.cache;
        return h;
      }
      function oM(c, h) {
        var y = c[1], O = h[1], q = y | O, ne = q < (L | F | R), fe = O == R && y == K || O == R && y == W && c[7].length <= h[8] || O == (R | W) && h[7].length <= h[8] && y == K;
        if (!(ne || fe))
          return c;
        O & L && (c[2] = h[2], q |= y & L ? 0 : $);
        var ge = h[3];
        if (ge) {
          var we = c[3];
          c[3] = we ? ow(we, ge, h[4]) : ge, c[4] = we ? Wo(c[3], d) : h[4];
        }
        return ge = h[5], ge && (we = c[5], c[5] = we ? aw(we, ge, h[6]) : ge, c[6] = we ? Wo(c[5], d) : h[6]), ge = h[7], ge && (c[7] = ge), O & R && (c[8] = c[8] == null ? h[8] : Wn(c[8], h[8])), c[9] == null && (c[9] = h[9]), c[0] = h[0], c[1] = q, c;
      }
      function aM(c) {
        var h = [];
        if (c != null)
          for (var y in qr(c))
            h.push(y);
        return h;
      }
      function cM(c) {
        return _h.call(c);
      }
      function Aw(c, h, y) {
        return h = _n(h === r ? c.length - 1 : h, 0), function() {
          for (var O = arguments, q = -1, ne = _n(O.length - h, 0), fe = Ie(ne); ++q < ne; )
            fe[q] = O[h + q];
          q = -1;
          for (var ge = Ie(h + 1); ++q < h; )
            ge[q] = O[q];
          return ge[h] = y(fe), Pn(c, this, ge);
        };
      }
      function Pw(c, h) {
        return h.length < 2 ? c : $a(c, Hi(h, 0, -1));
      }
      function uM(c, h) {
        for (var y = c.length, O = Wn(h.length, y), q = ui(c); O--; ) {
          var ne = h[O];
          c[O] = uo(ne, y) ? q[ne] : r;
        }
        return c;
      }
      function xg(c, h) {
        if (!(h === "constructor" && typeof c[h] == "function") && h != "__proto__")
          return c[h];
      }
      var Mw = Cw(Jy), hf = SA || function(c, h) {
        return _r.setTimeout(c, h);
      }, _g = Cw(DP);
      function Iw(c, h, y) {
        var O = h + "";
        return _g(c, eM(O, fM(XP(O), y)));
      }
      function Cw(c) {
        var h = 0, y = 0;
        return function() {
          var O = IA(), q = m - (O - y);
          if (y = O, q > 0) {
            if (++h >= S)
              return arguments[0];
          } else
            h = 0;
          return c.apply(r, arguments);
        };
      }
      function Kh(c, h) {
        var y = -1, O = c.length, q = O - 1;
        for (h = h === r ? O : h; ++y < h; ) {
          var ne = ig(y, q), fe = c[ne];
          c[ne] = c[y], c[y] = fe;
        }
        return c.length = h, c;
      }
      var Tw = sM(function(c) {
        var h = [];
        return c.charCodeAt(0) === 46 && h.push(""), c.replace(Bt, function(y, O, q, ne) {
          h.push(q ? ne.replace(he, "$1") : O || y);
        }), h;
      });
      function Ts(c) {
        if (typeof c == "string" || Mi(c))
          return c;
        var h = c + "";
        return h == "0" && 1 / c == -x ? "-0" : h;
      }
      function Ba(c) {
        if (c != null) {
          try {
            return xh.call(c);
          } catch {
          }
          try {
            return c + "";
          } catch {
          }
        }
        return "";
      }
      function fM(c, h) {
        return Ui(ce, function(y) {
          var O = "_." + y[0];
          h & y[1] && !mh(c, O) && c.push(O);
        }), c.sort();
      }
      function Rw(c) {
        if (c instanceof wr)
          return c.clone();
        var h = new qi(c.__wrapped__, c.__chain__);
        return h.__actions__ = ui(c.__actions__), h.__index__ = c.__index__, h.__values__ = c.__values__, h;
      }
      function lM(c, h, y) {
        (y ? ri(c, h, y) : h === r) ? h = 1 : h = _n(ar(h), 0);
        var O = c == null ? 0 : c.length;
        if (!O || h < 1)
          return [];
        for (var q = 0, ne = 0, fe = Ie(Ih(O / h)); q < O; )
          fe[ne++] = Hi(c, q, q += h);
        return fe;
      }
      function hM(c) {
        for (var h = -1, y = c == null ? 0 : c.length, O = 0, q = []; ++h < y; ) {
          var ne = c[h];
          ne && (q[O++] = ne);
        }
        return q;
      }
      function dM() {
        var c = arguments.length;
        if (!c)
          return [];
        for (var h = Ie(c - 1), y = arguments[0], O = c; O--; )
          h[O - 1] = arguments[O];
        return Ho(nr(y) ? ui(y) : [y], $n(h, 1));
      }
      var pM = hr(function(c, h) {
        return cn(c) ? of(c, $n(h, 1, cn, !0)) : [];
      }), gM = hr(function(c, h) {
        var y = Wi(h);
        return cn(y) && (y = r), cn(c) ? of(c, $n(h, 1, cn, !0), jt(y, 2)) : [];
      }), mM = hr(function(c, h) {
        var y = Wi(h);
        return cn(y) && (y = r), cn(c) ? of(c, $n(h, 1, cn, !0), r, y) : [];
      });
      function vM(c, h, y) {
        var O = c == null ? 0 : c.length;
        return O ? (h = y || h === r ? 1 : ar(h), Hi(c, h < 0 ? 0 : h, O)) : [];
      }
      function bM(c, h, y) {
        var O = c == null ? 0 : c.length;
        return O ? (h = y || h === r ? 1 : ar(h), h = O - h, Hi(c, 0, h < 0 ? 0 : h)) : [];
      }
      function yM(c, h) {
        return c && c.length ? Fh(c, jt(h, 3), !0, !0) : [];
      }
      function wM(c, h) {
        return c && c.length ? Fh(c, jt(h, 3), !0) : [];
      }
      function xM(c, h, y, O) {
        var q = c == null ? 0 : c.length;
        return q ? (y && typeof y != "number" && ri(c, h, y) && (y = 0, O = q), dP(c, h, y, O)) : [];
      }
      function Dw(c, h, y) {
        var O = c == null ? 0 : c.length;
        if (!O)
          return -1;
        var q = y == null ? 0 : ar(y);
        return q < 0 && (q = _n(O + q, 0)), vh(c, jt(h, 3), q);
      }
      function Ow(c, h, y) {
        var O = c == null ? 0 : c.length;
        if (!O)
          return -1;
        var q = O - 1;
        return y !== r && (q = ar(y), q = y < 0 ? _n(O + q, 0) : Wn(q, O - 1)), vh(c, jt(h, 3), q, !0);
      }
      function Nw(c) {
        var h = c == null ? 0 : c.length;
        return h ? $n(c, 1) : [];
      }
      function _M(c) {
        var h = c == null ? 0 : c.length;
        return h ? $n(c, x) : [];
      }
      function EM(c, h) {
        var y = c == null ? 0 : c.length;
        return y ? (h = h === r ? 1 : ar(h), $n(c, h)) : [];
      }
      function SM(c) {
        for (var h = -1, y = c == null ? 0 : c.length, O = {}; ++h < y; ) {
          var q = c[h];
          O[q[0]] = q[1];
        }
        return O;
      }
      function Lw(c) {
        return c && c.length ? c[0] : r;
      }
      function AM(c, h, y) {
        var O = c == null ? 0 : c.length;
        if (!O)
          return -1;
        var q = y == null ? 0 : ar(y);
        return q < 0 && (q = _n(O + q, 0)), Ic(c, h, q);
      }
      function PM(c) {
        var h = c == null ? 0 : c.length;
        return h ? Hi(c, 0, -1) : [];
      }
      var MM = hr(function(c) {
        var h = Xr(c, ug);
        return h.length && h[0] === c[0] ? Qp(h) : [];
      }), IM = hr(function(c) {
        var h = Wi(c), y = Xr(c, ug);
        return h === Wi(y) ? h = r : y.pop(), y.length && y[0] === c[0] ? Qp(y, jt(h, 2)) : [];
      }), CM = hr(function(c) {
        var h = Wi(c), y = Xr(c, ug);
        return h = typeof h == "function" ? h : r, h && y.pop(), y.length && y[0] === c[0] ? Qp(y, r, h) : [];
      });
      function TM(c, h) {
        return c == null ? "" : PA.call(c, h);
      }
      function Wi(c) {
        var h = c == null ? 0 : c.length;
        return h ? c[h - 1] : r;
      }
      function RM(c, h, y) {
        var O = c == null ? 0 : c.length;
        if (!O)
          return -1;
        var q = O;
        return y !== r && (q = ar(y), q = q < 0 ? _n(O + q, 0) : Wn(q, O - 1)), h === h ? fA(c, h, q) : vh(c, gy, q, !0);
      }
      function DM(c, h) {
        return c && c.length ? Ky(c, ar(h)) : r;
      }
      var OM = hr(kw);
      function kw(c, h) {
        return c && c.length && h && h.length ? ng(c, h) : c;
      }
      function NM(c, h, y) {
        return c && c.length && h && h.length ? ng(c, h, jt(y, 2)) : c;
      }
      function LM(c, h, y) {
        return c && c.length && h && h.length ? ng(c, h, r, y) : c;
      }
      var kM = co(function(c, h) {
        var y = c == null ? 0 : c.length, O = Yp(c, h);
        return Yy(c, Xr(h, function(q) {
          return uo(q, y) ? +q : q;
        }).sort(sw)), O;
      });
      function $M(c, h) {
        var y = [];
        if (!(c && c.length))
          return y;
        var O = -1, q = [], ne = c.length;
        for (h = jt(h, 3); ++O < ne; ) {
          var fe = c[O];
          h(fe, O, c) && (y.push(fe), q.push(O));
        }
        return Yy(c, q), y;
      }
      function Eg(c) {
        return c == null ? c : TA.call(c);
      }
      function FM(c, h, y) {
        var O = c == null ? 0 : c.length;
        return O ? (y && typeof y != "number" && ri(c, h, y) ? (h = 0, y = O) : (h = h == null ? 0 : ar(h), y = y === r ? O : ar(y)), Hi(c, h, y)) : [];
      }
      function BM(c, h) {
        return $h(c, h);
      }
      function UM(c, h, y) {
        return og(c, h, jt(y, 2));
      }
      function jM(c, h) {
        var y = c == null ? 0 : c.length;
        if (y) {
          var O = $h(c, h);
          if (O < y && hs(c[O], h))
            return O;
        }
        return -1;
      }
      function qM(c, h) {
        return $h(c, h, !0);
      }
      function zM(c, h, y) {
        return og(c, h, jt(y, 2), !0);
      }
      function HM(c, h) {
        var y = c == null ? 0 : c.length;
        if (y) {
          var O = $h(c, h, !0) - 1;
          if (hs(c[O], h))
            return O;
        }
        return -1;
      }
      function WM(c) {
        return c && c.length ? Xy(c) : [];
      }
      function KM(c, h) {
        return c && c.length ? Xy(c, jt(h, 2)) : [];
      }
      function VM(c) {
        var h = c == null ? 0 : c.length;
        return h ? Hi(c, 1, h) : [];
      }
      function GM(c, h, y) {
        return c && c.length ? (h = y || h === r ? 1 : ar(h), Hi(c, 0, h < 0 ? 0 : h)) : [];
      }
      function YM(c, h, y) {
        var O = c == null ? 0 : c.length;
        return O ? (h = y || h === r ? 1 : ar(h), h = O - h, Hi(c, h < 0 ? 0 : h, O)) : [];
      }
      function JM(c, h) {
        return c && c.length ? Fh(c, jt(h, 3), !1, !0) : [];
      }
      function XM(c, h) {
        return c && c.length ? Fh(c, jt(h, 3)) : [];
      }
      var ZM = hr(function(c) {
        return Go($n(c, 1, cn, !0));
      }), QM = hr(function(c) {
        var h = Wi(c);
        return cn(h) && (h = r), Go($n(c, 1, cn, !0), jt(h, 2));
      }), eI = hr(function(c) {
        var h = Wi(c);
        return h = typeof h == "function" ? h : r, Go($n(c, 1, cn, !0), r, h);
      });
      function tI(c) {
        return c && c.length ? Go(c) : [];
      }
      function rI(c, h) {
        return c && c.length ? Go(c, jt(h, 2)) : [];
      }
      function nI(c, h) {
        return h = typeof h == "function" ? h : r, c && c.length ? Go(c, r, h) : [];
      }
      function Sg(c) {
        if (!(c && c.length))
          return [];
        var h = 0;
        return c = zo(c, function(y) {
          if (cn(y))
            return h = _n(y.length, h), !0;
        }), jp(h, function(y) {
          return Xr(c, Fp(y));
        });
      }
      function $w(c, h) {
        if (!(c && c.length))
          return [];
        var y = Sg(c);
        return h == null ? y : Xr(y, function(O) {
          return Pn(h, r, O);
        });
      }
      var iI = hr(function(c, h) {
        return cn(c) ? of(c, h) : [];
      }), sI = hr(function(c) {
        return cg(zo(c, cn));
      }), oI = hr(function(c) {
        var h = Wi(c);
        return cn(h) && (h = r), cg(zo(c, cn), jt(h, 2));
      }), aI = hr(function(c) {
        var h = Wi(c);
        return h = typeof h == "function" ? h : r, cg(zo(c, cn), r, h);
      }), cI = hr(Sg);
      function uI(c, h) {
        return tw(c || [], h || [], sf);
      }
      function fI(c, h) {
        return tw(c || [], h || [], uf);
      }
      var lI = hr(function(c) {
        var h = c.length, y = h > 1 ? c[h - 1] : r;
        return y = typeof y == "function" ? (c.pop(), y) : r, $w(c, y);
      });
      function Fw(c) {
        var h = ee(c);
        return h.__chain__ = !0, h;
      }
      function hI(c, h) {
        return h(c), c;
      }
      function Vh(c, h) {
        return h(c);
      }
      var dI = co(function(c) {
        var h = c.length, y = h ? c[0] : 0, O = this.__wrapped__, q = function(ne) {
          return Yp(ne, c);
        };
        return h > 1 || this.__actions__.length || !(O instanceof wr) || !uo(y) ? this.thru(q) : (O = O.slice(y, +y + (h ? 1 : 0)), O.__actions__.push({
          func: Vh,
          args: [q],
          thisArg: r
        }), new qi(O, this.__chain__).thru(function(ne) {
          return h && !ne.length && ne.push(r), ne;
        }));
      });
      function pI() {
        return Fw(this);
      }
      function gI() {
        return new qi(this.value(), this.__chain__);
      }
      function mI() {
        this.__values__ === r && (this.__values__ = Zw(this.value()));
        var c = this.__index__ >= this.__values__.length, h = c ? r : this.__values__[this.__index__++];
        return { done: c, value: h };
      }
      function vI() {
        return this;
      }
      function bI(c) {
        for (var h, y = this; y instanceof Dh; ) {
          var O = Rw(y);
          O.__index__ = 0, O.__values__ = r, h ? q.__wrapped__ = O : h = O;
          var q = O;
          y = y.__wrapped__;
        }
        return q.__wrapped__ = c, h;
      }
      function yI() {
        var c = this.__wrapped__;
        if (c instanceof wr) {
          var h = c;
          return this.__actions__.length && (h = new wr(this)), h = h.reverse(), h.__actions__.push({
            func: Vh,
            args: [Eg],
            thisArg: r
          }), new qi(h, this.__chain__);
        }
        return this.thru(Eg);
      }
      function wI() {
        return ew(this.__wrapped__, this.__actions__);
      }
      var xI = Bh(function(c, h, y) {
        Tr.call(c, y) ? ++c[y] : oo(c, y, 1);
      });
      function _I(c, h, y) {
        var O = nr(c) ? dy : hP;
        return y && ri(c, h, y) && (h = r), O(c, jt(h, 3));
      }
      function EI(c, h) {
        var y = nr(c) ? zo : $y;
        return y(c, jt(h, 3));
      }
      var SI = lw(Dw), AI = lw(Ow);
      function PI(c, h) {
        return $n(Gh(c, h), 1);
      }
      function MI(c, h) {
        return $n(Gh(c, h), x);
      }
      function II(c, h, y) {
        return y = y === r ? 1 : ar(y), $n(Gh(c, h), y);
      }
      function Bw(c, h) {
        var y = nr(c) ? Ui : Vo;
        return y(c, jt(h, 3));
      }
      function Uw(c, h) {
        var y = nr(c) ? V9 : ky;
        return y(c, jt(h, 3));
      }
      var CI = Bh(function(c, h, y) {
        Tr.call(c, y) ? c[y].push(h) : oo(c, y, [h]);
      });
      function TI(c, h, y, O) {
        c = fi(c) ? c : Uc(c), y = y && !O ? ar(y) : 0;
        var q = c.length;
        return y < 0 && (y = _n(q + y, 0)), Qh(c) ? y <= q && c.indexOf(h, y) > -1 : !!q && Ic(c, h, y) > -1;
      }
      var RI = hr(function(c, h, y) {
        var O = -1, q = typeof h == "function", ne = fi(c) ? Ie(c.length) : [];
        return Vo(c, function(fe) {
          ne[++O] = q ? Pn(h, fe, y) : af(fe, h, y);
        }), ne;
      }), DI = Bh(function(c, h, y) {
        oo(c, y, h);
      });
      function Gh(c, h) {
        var y = nr(c) ? Xr : zy;
        return y(c, jt(h, 3));
      }
      function OI(c, h, y, O) {
        return c == null ? [] : (nr(h) || (h = h == null ? [] : [h]), y = O ? r : y, nr(y) || (y = y == null ? [] : [y]), Vy(c, h, y));
      }
      var NI = Bh(function(c, h, y) {
        c[y ? 0 : 1].push(h);
      }, function() {
        return [[], []];
      });
      function LI(c, h, y) {
        var O = nr(c) ? kp : vy, q = arguments.length < 3;
        return O(c, jt(h, 4), y, q, Vo);
      }
      function kI(c, h, y) {
        var O = nr(c) ? G9 : vy, q = arguments.length < 3;
        return O(c, jt(h, 4), y, q, ky);
      }
      function $I(c, h) {
        var y = nr(c) ? zo : $y;
        return y(c, Xh(jt(h, 3)));
      }
      function FI(c) {
        var h = nr(c) ? Dy : TP;
        return h(c);
      }
      function BI(c, h, y) {
        (y ? ri(c, h, y) : h === r) ? h = 1 : h = ar(h);
        var O = nr(c) ? aP : RP;
        return O(c, h);
      }
      function UI(c) {
        var h = nr(c) ? cP : OP;
        return h(c);
      }
      function jI(c) {
        if (c == null)
          return 0;
        if (fi(c))
          return Qh(c) ? Tc(c) : c.length;
        var h = Kn(c);
        return h == ie || h == Me ? c.size : tg(c).length;
      }
      function qI(c, h, y) {
        var O = nr(c) ? $p : NP;
        return y && ri(c, h, y) && (h = r), O(c, jt(h, 3));
      }
      var zI = hr(function(c, h) {
        if (c == null)
          return [];
        var y = h.length;
        return y > 1 && ri(c, h[0], h[1]) ? h = [] : y > 2 && ri(h[0], h[1], h[2]) && (h = [h[0]]), Vy(c, $n(h, 1), []);
      }), Yh = EA || function() {
        return _r.Date.now();
      };
      function HI(c, h) {
        if (typeof h != "function")
          throw new ji(o);
        return c = ar(c), function() {
          if (--c < 1)
            return h.apply(this, arguments);
        };
      }
      function jw(c, h, y) {
        return h = y ? r : h, h = c && h == null ? c.length : h, ao(c, R, r, r, r, r, h);
      }
      function qw(c, h) {
        var y;
        if (typeof h != "function")
          throw new ji(o);
        return c = ar(c), function() {
          return --c > 0 && (y = h.apply(this, arguments)), c <= 1 && (h = r), y;
        };
      }
      var Ag = hr(function(c, h, y) {
        var O = L;
        if (y.length) {
          var q = Wo(y, Fc(Ag));
          O |= V;
        }
        return ao(c, O, h, y, q);
      }), zw = hr(function(c, h, y) {
        var O = L | F;
        if (y.length) {
          var q = Wo(y, Fc(zw));
          O |= V;
        }
        return ao(h, O, c, y, q);
      });
      function Hw(c, h, y) {
        h = y ? r : h;
        var O = ao(c, K, r, r, r, r, r, h);
        return O.placeholder = Hw.placeholder, O;
      }
      function Ww(c, h, y) {
        h = y ? r : h;
        var O = ao(c, H, r, r, r, r, r, h);
        return O.placeholder = Ww.placeholder, O;
      }
      function Kw(c, h, y) {
        var O, q, ne, fe, ge, we, He = 0, We = !1, Xe = !1, wt = !0;
        if (typeof c != "function")
          throw new ji(o);
        h = Ki(h) || 0, Zr(y) && (We = !!y.leading, Xe = "maxWait" in y, ne = Xe ? _n(Ki(y.maxWait) || 0, h) : ne, wt = "trailing" in y ? !!y.trailing : wt);
        function Ot(un) {
          var ds = O, ho = q;
          return O = q = r, He = un, fe = c.apply(ho, ds), fe;
        }
        function Wt(un) {
          return He = un, ge = hf(vr, h), We ? Ot(un) : fe;
        }
        function ur(un) {
          var ds = un - we, ho = un - He, l2 = h - ds;
          return Xe ? Wn(l2, ne - ho) : l2;
        }
        function Kt(un) {
          var ds = un - we, ho = un - He;
          return we === r || ds >= h || ds < 0 || Xe && ho >= ne;
        }
        function vr() {
          var un = Yh();
          if (Kt(un))
            return Er(un);
          ge = hf(vr, ur(un));
        }
        function Er(un) {
          return ge = r, wt && O ? Ot(un) : (O = q = r, fe);
        }
        function Ii() {
          ge !== r && rw(ge), He = 0, O = we = q = ge = r;
        }
        function ni() {
          return ge === r ? fe : Er(Yh());
        }
        function Ci() {
          var un = Yh(), ds = Kt(un);
          if (O = arguments, q = this, we = un, ds) {
            if (ge === r)
              return Wt(we);
            if (Xe)
              return rw(ge), ge = hf(vr, h), Ot(we);
          }
          return ge === r && (ge = hf(vr, h)), fe;
        }
        return Ci.cancel = Ii, Ci.flush = ni, Ci;
      }
      var WI = hr(function(c, h) {
        return Ly(c, 1, h);
      }), KI = hr(function(c, h, y) {
        return Ly(c, Ki(h) || 0, y);
      });
      function VI(c) {
        return ao(c, pe);
      }
      function Jh(c, h) {
        if (typeof c != "function" || h != null && typeof h != "function")
          throw new ji(o);
        var y = function() {
          var O = arguments, q = h ? h.apply(this, O) : O[0], ne = y.cache;
          if (ne.has(q))
            return ne.get(q);
          var fe = c.apply(this, O);
          return y.cache = ne.set(q, fe) || ne, fe;
        };
        return y.cache = new (Jh.Cache || so)(), y;
      }
      Jh.Cache = so;
      function Xh(c) {
        if (typeof c != "function")
          throw new ji(o);
        return function() {
          var h = arguments;
          switch (h.length) {
            case 0:
              return !c.call(this);
            case 1:
              return !c.call(this, h[0]);
            case 2:
              return !c.call(this, h[0], h[1]);
            case 3:
              return !c.call(this, h[0], h[1], h[2]);
          }
          return !c.apply(this, h);
        };
      }
      function GI(c) {
        return qw(2, c);
      }
      var YI = LP(function(c, h) {
        h = h.length == 1 && nr(h[0]) ? Xr(h[0], Ai(jt())) : Xr($n(h, 1), Ai(jt()));
        var y = h.length;
        return hr(function(O) {
          for (var q = -1, ne = Wn(O.length, y); ++q < ne; )
            O[q] = h[q].call(this, O[q]);
          return Pn(c, this, O);
        });
      }), Pg = hr(function(c, h) {
        var y = Wo(h, Fc(Pg));
        return ao(c, V, r, h, y);
      }), Vw = hr(function(c, h) {
        var y = Wo(h, Fc(Vw));
        return ao(c, te, r, h, y);
      }), JI = co(function(c, h) {
        return ao(c, W, r, r, r, h);
      });
      function XI(c, h) {
        if (typeof c != "function")
          throw new ji(o);
        return h = h === r ? h : ar(h), hr(c, h);
      }
      function ZI(c, h) {
        if (typeof c != "function")
          throw new ji(o);
        return h = h == null ? 0 : _n(ar(h), 0), hr(function(y) {
          var O = y[h], q = Jo(y, 0, h);
          return O && Ho(q, O), Pn(c, this, q);
        });
      }
      function QI(c, h, y) {
        var O = !0, q = !0;
        if (typeof c != "function")
          throw new ji(o);
        return Zr(y) && (O = "leading" in y ? !!y.leading : O, q = "trailing" in y ? !!y.trailing : q), Kw(c, h, {
          leading: O,
          maxWait: h,
          trailing: q
        });
      }
      function eC(c) {
        return jw(c, 1);
      }
      function tC(c, h) {
        return Pg(fg(h), c);
      }
      function rC() {
        if (!arguments.length)
          return [];
        var c = arguments[0];
        return nr(c) ? c : [c];
      }
      function nC(c) {
        return zi(c, P);
      }
      function iC(c, h) {
        return h = typeof h == "function" ? h : r, zi(c, P, h);
      }
      function sC(c) {
        return zi(c, p | P);
      }
      function oC(c, h) {
        return h = typeof h == "function" ? h : r, zi(c, p | P, h);
      }
      function aC(c, h) {
        return h == null || Ny(c, h, Mn(h));
      }
      function hs(c, h) {
        return c === h || c !== c && h !== h;
      }
      var cC = zh(Zp), uC = zh(function(c, h) {
        return c >= h;
      }), Ua = Uy(/* @__PURE__ */ function() {
        return arguments;
      }()) ? Uy : function(c) {
        return en(c) && Tr.call(c, "callee") && !Py.call(c, "callee");
      }, nr = Ie.isArray, fC = ei ? Ai(ei) : bP;
      function fi(c) {
        return c != null && Zh(c.length) && !fo(c);
      }
      function cn(c) {
        return en(c) && fi(c);
      }
      function lC(c) {
        return c === !0 || c === !1 || en(c) && ti(c) == J;
      }
      var Xo = AA || $g, hC = us ? Ai(us) : yP;
      function dC(c) {
        return en(c) && c.nodeType === 1 && !df(c);
      }
      function pC(c) {
        if (c == null)
          return !0;
        if (fi(c) && (nr(c) || typeof c == "string" || typeof c.splice == "function" || Xo(c) || Bc(c) || Ua(c)))
          return !c.length;
        var h = Kn(c);
        if (h == ie || h == Me)
          return !c.size;
        if (lf(c))
          return !tg(c).length;
        for (var y in c)
          if (Tr.call(c, y))
            return !1;
        return !0;
      }
      function gC(c, h) {
        return cf(c, h);
      }
      function mC(c, h, y) {
        y = typeof y == "function" ? y : r;
        var O = y ? y(c, h) : r;
        return O === r ? cf(c, h, r, y) : !!O;
      }
      function Mg(c) {
        if (!en(c))
          return !1;
        var h = ti(c);
        return h == X || h == T || typeof c.message == "string" && typeof c.name == "string" && !df(c);
      }
      function vC(c) {
        return typeof c == "number" && Iy(c);
      }
      function fo(c) {
        if (!Zr(c))
          return !1;
        var h = ti(c);
        return h == re || h == de || h == Z || h == Ce;
      }
      function Gw(c) {
        return typeof c == "number" && c == ar(c);
      }
      function Zh(c) {
        return typeof c == "number" && c > -1 && c % 1 == 0 && c <= _;
      }
      function Zr(c) {
        var h = typeof c;
        return c != null && (h == "object" || h == "function");
      }
      function en(c) {
        return c != null && typeof c == "object";
      }
      var Yw = Bi ? Ai(Bi) : xP;
      function bC(c, h) {
        return c === h || eg(c, h, vg(h));
      }
      function yC(c, h, y) {
        return y = typeof y == "function" ? y : r, eg(c, h, vg(h), y);
      }
      function wC(c) {
        return Jw(c) && c != +c;
      }
      function xC(c) {
        if (iM(c))
          throw new er(s);
        return jy(c);
      }
      function _C(c) {
        return c === null;
      }
      function EC(c) {
        return c == null;
      }
      function Jw(c) {
        return typeof c == "number" || en(c) && ti(c) == ue;
      }
      function df(c) {
        if (!en(c) || ti(c) != Pe)
          return !1;
        var h = Ah(c);
        if (h === null)
          return !0;
        var y = Tr.call(h, "constructor") && h.constructor;
        return typeof y == "function" && y instanceof y && xh.call(y) == yA;
      }
      var Ig = Ms ? Ai(Ms) : _P;
      function SC(c) {
        return Gw(c) && c >= -_ && c <= _;
      }
      var Xw = Xu ? Ai(Xu) : EP;
      function Qh(c) {
        return typeof c == "string" || !nr(c) && en(c) && ti(c) == Ne;
      }
      function Mi(c) {
        return typeof c == "symbol" || en(c) && ti(c) == Ke;
      }
      var Bc = Da ? Ai(Da) : SP;
      function AC(c) {
        return c === r;
      }
      function PC(c) {
        return en(c) && Kn(c) == qe;
      }
      function MC(c) {
        return en(c) && ti(c) == ze;
      }
      var IC = zh(rg), CC = zh(function(c, h) {
        return c <= h;
      });
      function Zw(c) {
        if (!c)
          return [];
        if (fi(c))
          return Qh(c) ? fs(c) : ui(c);
        if (Qu && c[Qu])
          return aA(c[Qu]());
        var h = Kn(c), y = h == ie ? zp : h == Me ? bh : Uc;
        return y(c);
      }
      function lo(c) {
        if (!c)
          return c === 0 ? c : 0;
        if (c = Ki(c), c === x || c === -x) {
          var h = c < 0 ? -1 : 1;
          return h * E;
        }
        return c === c ? c : 0;
      }
      function ar(c) {
        var h = lo(c), y = h % 1;
        return h === h ? y ? h - y : h : 0;
      }
      function Qw(c) {
        return c ? ka(ar(c), 0, M) : 0;
      }
      function Ki(c) {
        if (typeof c == "number")
          return c;
        if (Mi(c))
          return v;
        if (Zr(c)) {
          var h = typeof c.valueOf == "function" ? c.valueOf() : c;
          c = Zr(h) ? h + "" : h;
        }
        if (typeof c != "string")
          return c === 0 ? c : +c;
        c = by(c);
        var y = nt.test(c);
        return y || pt.test(c) ? rr(c.slice(2), y ? 2 : 8) : Re.test(c) ? v : +c;
      }
      function e2(c) {
        return Cs(c, li(c));
      }
      function TC(c) {
        return c ? ka(ar(c), -_, _) : c === 0 ? c : 0;
      }
      function Cr(c) {
        return c == null ? "" : Pi(c);
      }
      var RC = kc(function(c, h) {
        if (lf(h) || fi(h)) {
          Cs(h, Mn(h), c);
          return;
        }
        for (var y in h)
          Tr.call(h, y) && sf(c, y, h[y]);
      }), t2 = kc(function(c, h) {
        Cs(h, li(h), c);
      }), ed = kc(function(c, h, y, O) {
        Cs(h, li(h), c, O);
      }), DC = kc(function(c, h, y, O) {
        Cs(h, Mn(h), c, O);
      }), OC = co(Yp);
      function NC(c, h) {
        var y = Lc(c);
        return h == null ? y : Oy(y, h);
      }
      var LC = hr(function(c, h) {
        c = qr(c);
        var y = -1, O = h.length, q = O > 2 ? h[2] : r;
        for (q && ri(h[0], h[1], q) && (O = 1); ++y < O; )
          for (var ne = h[y], fe = li(ne), ge = -1, we = fe.length; ++ge < we; ) {
            var He = fe[ge], We = c[He];
            (We === r || hs(We, Dc[He]) && !Tr.call(c, He)) && (c[He] = ne[He]);
          }
        return c;
      }), kC = hr(function(c) {
        return c.push(r, bw), Pn(r2, r, c);
      });
      function $C(c, h) {
        return py(c, jt(h, 3), Is);
      }
      function FC(c, h) {
        return py(c, jt(h, 3), Xp);
      }
      function BC(c, h) {
        return c == null ? c : Jp(c, jt(h, 3), li);
      }
      function UC(c, h) {
        return c == null ? c : Fy(c, jt(h, 3), li);
      }
      function jC(c, h) {
        return c && Is(c, jt(h, 3));
      }
      function qC(c, h) {
        return c && Xp(c, jt(h, 3));
      }
      function zC(c) {
        return c == null ? [] : Lh(c, Mn(c));
      }
      function HC(c) {
        return c == null ? [] : Lh(c, li(c));
      }
      function Cg(c, h, y) {
        var O = c == null ? r : $a(c, h);
        return O === r ? y : O;
      }
      function WC(c, h) {
        return c != null && xw(c, h, pP);
      }
      function Tg(c, h) {
        return c != null && xw(c, h, gP);
      }
      var KC = dw(function(c, h, y) {
        h != null && typeof h.toString != "function" && (h = _h.call(h)), c[h] = y;
      }, Dg(hi)), VC = dw(function(c, h, y) {
        h != null && typeof h.toString != "function" && (h = _h.call(h)), Tr.call(c, h) ? c[h].push(y) : c[h] = [y];
      }, jt), GC = hr(af);
      function Mn(c) {
        return fi(c) ? Ry(c) : tg(c);
      }
      function li(c) {
        return fi(c) ? Ry(c, !0) : AP(c);
      }
      function YC(c, h) {
        var y = {};
        return h = jt(h, 3), Is(c, function(O, q, ne) {
          oo(y, h(O, q, ne), O);
        }), y;
      }
      function JC(c, h) {
        var y = {};
        return h = jt(h, 3), Is(c, function(O, q, ne) {
          oo(y, q, h(O, q, ne));
        }), y;
      }
      var XC = kc(function(c, h, y) {
        kh(c, h, y);
      }), r2 = kc(function(c, h, y, O) {
        kh(c, h, y, O);
      }), ZC = co(function(c, h) {
        var y = {};
        if (c == null)
          return y;
        var O = !1;
        h = Xr(h, function(ne) {
          return ne = Yo(ne, c), O || (O = ne.length > 1), ne;
        }), Cs(c, gg(c), y), O && (y = zi(y, p | w | P, KP));
        for (var q = h.length; q--; )
          ag(y, h[q]);
        return y;
      });
      function QC(c, h) {
        return n2(c, Xh(jt(h)));
      }
      var eT = co(function(c, h) {
        return c == null ? {} : MP(c, h);
      });
      function n2(c, h) {
        if (c == null)
          return {};
        var y = Xr(gg(c), function(O) {
          return [O];
        });
        return h = jt(h), Gy(c, y, function(O, q) {
          return h(O, q[0]);
        });
      }
      function tT(c, h, y) {
        h = Yo(h, c);
        var O = -1, q = h.length;
        for (q || (q = 1, c = r); ++O < q; ) {
          var ne = c == null ? r : c[Ts(h[O])];
          ne === r && (O = q, ne = y), c = fo(ne) ? ne.call(c) : ne;
        }
        return c;
      }
      function rT(c, h, y) {
        return c == null ? c : uf(c, h, y);
      }
      function nT(c, h, y, O) {
        return O = typeof O == "function" ? O : r, c == null ? c : uf(c, h, y, O);
      }
      var i2 = mw(Mn), s2 = mw(li);
      function iT(c, h, y) {
        var O = nr(c), q = O || Xo(c) || Bc(c);
        if (h = jt(h, 4), y == null) {
          var ne = c && c.constructor;
          q ? y = O ? new ne() : [] : Zr(c) ? y = fo(ne) ? Lc(Ah(c)) : {} : y = {};
        }
        return (q ? Ui : Is)(c, function(fe, ge, we) {
          return h(y, fe, ge, we);
        }), y;
      }
      function sT(c, h) {
        return c == null ? !0 : ag(c, h);
      }
      function oT(c, h, y) {
        return c == null ? c : Qy(c, h, fg(y));
      }
      function aT(c, h, y, O) {
        return O = typeof O == "function" ? O : r, c == null ? c : Qy(c, h, fg(y), O);
      }
      function Uc(c) {
        return c == null ? [] : qp(c, Mn(c));
      }
      function cT(c) {
        return c == null ? [] : qp(c, li(c));
      }
      function uT(c, h, y) {
        return y === r && (y = h, h = r), y !== r && (y = Ki(y), y = y === y ? y : 0), h !== r && (h = Ki(h), h = h === h ? h : 0), ka(Ki(c), h, y);
      }
      function fT(c, h, y) {
        return h = lo(h), y === r ? (y = h, h = 0) : y = lo(y), c = Ki(c), mP(c, h, y);
      }
      function lT(c, h, y) {
        if (y && typeof y != "boolean" && ri(c, h, y) && (h = y = r), y === r && (typeof h == "boolean" ? (y = h, h = r) : typeof c == "boolean" && (y = c, c = r)), c === r && h === r ? (c = 0, h = 1) : (c = lo(c), h === r ? (h = c, c = 0) : h = lo(h)), c > h) {
          var O = c;
          c = h, h = O;
        }
        if (y || c % 1 || h % 1) {
          var q = Cy();
          return Wn(c + q * (h - c + Ur("1e-" + ((q + "").length - 1))), h);
        }
        return ig(c, h);
      }
      var hT = $c(function(c, h, y) {
        return h = h.toLowerCase(), c + (y ? o2(h) : h);
      });
      function o2(c) {
        return Rg(Cr(c).toLowerCase());
      }
      function a2(c) {
        return c = Cr(c), c && c.replace(et, rA).replace(Op, "");
      }
      function dT(c, h, y) {
        c = Cr(c), h = Pi(h);
        var O = c.length;
        y = y === r ? O : ka(ar(y), 0, O);
        var q = y;
        return y -= h.length, y >= 0 && c.slice(y, q) == h;
      }
      function pT(c) {
        return c = Cr(c), c && Ct.test(c) ? c.replace(Dt, nA) : c;
      }
      function gT(c) {
        return c = Cr(c), c && Ft.test(c) ? c.replace(rt, "\\$&") : c;
      }
      var mT = $c(function(c, h, y) {
        return c + (y ? "-" : "") + h.toLowerCase();
      }), vT = $c(function(c, h, y) {
        return c + (y ? " " : "") + h.toLowerCase();
      }), bT = fw("toLowerCase");
      function yT(c, h, y) {
        c = Cr(c), h = ar(h);
        var O = h ? Tc(c) : 0;
        if (!h || O >= h)
          return c;
        var q = (h - O) / 2;
        return qh(Ch(q), y) + c + qh(Ih(q), y);
      }
      function wT(c, h, y) {
        c = Cr(c), h = ar(h);
        var O = h ? Tc(c) : 0;
        return h && O < h ? c + qh(h - O, y) : c;
      }
      function xT(c, h, y) {
        c = Cr(c), h = ar(h);
        var O = h ? Tc(c) : 0;
        return h && O < h ? qh(h - O, y) + c : c;
      }
      function _T(c, h, y) {
        return y || h == null ? h = 0 : h && (h = +h), CA(Cr(c).replace(k, ""), h || 0);
      }
      function ET(c, h, y) {
        return (y ? ri(c, h, y) : h === r) ? h = 1 : h = ar(h), sg(Cr(c), h);
      }
      function ST() {
        var c = arguments, h = Cr(c[0]);
        return c.length < 3 ? h : h.replace(c[1], c[2]);
      }
      var AT = $c(function(c, h, y) {
        return c + (y ? "_" : "") + h.toLowerCase();
      });
      function PT(c, h, y) {
        return y && typeof y != "number" && ri(c, h, y) && (h = y = r), y = y === r ? M : y >>> 0, y ? (c = Cr(c), c && (typeof h == "string" || h != null && !Ig(h)) && (h = Pi(h), !h && Cc(c)) ? Jo(fs(c), 0, y) : c.split(h, y)) : [];
      }
      var MT = $c(function(c, h, y) {
        return c + (y ? " " : "") + Rg(h);
      });
      function IT(c, h, y) {
        return c = Cr(c), y = y == null ? 0 : ka(ar(y), 0, c.length), h = Pi(h), c.slice(y, y + h.length) == h;
      }
      function CT(c, h, y) {
        var O = ee.templateSettings;
        y && ri(c, h, y) && (h = r), c = Cr(c), h = ed({}, h, O, vw);
        var q = ed({}, h.imports, O.imports, vw), ne = Mn(q), fe = qp(q, ne), ge, we, He = 0, We = h.interpolate || St, Xe = "__p += '", wt = Hp(
          (h.escape || St).source + "|" + We.source + "|" + (We === Nt ? xe : St).source + "|" + (h.evaluate || St).source + "|$",
          "g"
        ), Ot = "//# sourceURL=" + (Tr.call(h, "sourceURL") ? (h.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Np + "]") + `
`;
        c.replace(wt, function(Kt, vr, Er, Ii, ni, Ci) {
          return Er || (Er = Ii), Xe += c.slice(He, Ci).replace(Tt, iA), vr && (ge = !0, Xe += `' +
__e(` + vr + `) +
'`), ni && (we = !0, Xe += `';
` + ni + `;
__p += '`), Er && (Xe += `' +
((__t = (` + Er + `)) == null ? '' : __t) +
'`), He = Ci + Kt.length, Kt;
        }), Xe += `';
`;
        var Wt = Tr.call(h, "variable") && h.variable;
        if (!Wt)
          Xe = `with (obj) {
` + Xe + `
}
`;
        else if (se.test(Wt))
          throw new er(a);
        Xe = (we ? Xe.replace(Yt, "") : Xe).replace(Et, "$1").replace(Qt, "$1;"), Xe = "function(" + (Wt || "obj") + `) {
` + (Wt ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (ge ? ", __e = _.escape" : "") + (we ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Xe + `return __p
}`;
        var ur = u2(function() {
          return Pr(ne, Ot + "return " + Xe).apply(r, fe);
        });
        if (ur.source = Xe, Mg(ur))
          throw ur;
        return ur;
      }
      function TT(c) {
        return Cr(c).toLowerCase();
      }
      function RT(c) {
        return Cr(c).toUpperCase();
      }
      function DT(c, h, y) {
        if (c = Cr(c), c && (y || h === r))
          return by(c);
        if (!c || !(h = Pi(h)))
          return c;
        var O = fs(c), q = fs(h), ne = yy(O, q), fe = wy(O, q) + 1;
        return Jo(O, ne, fe).join("");
      }
      function OT(c, h, y) {
        if (c = Cr(c), c && (y || h === r))
          return c.slice(0, _y(c) + 1);
        if (!c || !(h = Pi(h)))
          return c;
        var O = fs(c), q = wy(O, fs(h)) + 1;
        return Jo(O, 0, q).join("");
      }
      function NT(c, h, y) {
        if (c = Cr(c), c && (y || h === r))
          return c.replace(k, "");
        if (!c || !(h = Pi(h)))
          return c;
        var O = fs(c), q = yy(O, fs(h));
        return Jo(O, q).join("");
      }
      function LT(c, h) {
        var y = Ee, O = Y;
        if (Zr(h)) {
          var q = "separator" in h ? h.separator : q;
          y = "length" in h ? ar(h.length) : y, O = "omission" in h ? Pi(h.omission) : O;
        }
        c = Cr(c);
        var ne = c.length;
        if (Cc(c)) {
          var fe = fs(c);
          ne = fe.length;
        }
        if (y >= ne)
          return c;
        var ge = y - Tc(O);
        if (ge < 1)
          return O;
        var we = fe ? Jo(fe, 0, ge).join("") : c.slice(0, ge);
        if (q === r)
          return we + O;
        if (fe && (ge += we.length - ge), Ig(q)) {
          if (c.slice(ge).search(q)) {
            var He, We = we;
            for (q.global || (q = Hp(q.source, Cr(Te.exec(q)) + "g")), q.lastIndex = 0; He = q.exec(We); )
              var Xe = He.index;
            we = we.slice(0, Xe === r ? ge : Xe);
          }
        } else if (c.indexOf(Pi(q), ge) != ge) {
          var wt = we.lastIndexOf(q);
          wt > -1 && (we = we.slice(0, wt));
        }
        return we + O;
      }
      function kT(c) {
        return c = Cr(c), c && kt.test(c) ? c.replace(Jt, lA) : c;
      }
      var $T = $c(function(c, h, y) {
        return c + (y ? " " : "") + h.toUpperCase();
      }), Rg = fw("toUpperCase");
      function c2(c, h, y) {
        return c = Cr(c), h = y ? r : h, h === r ? oA(c) ? pA(c) : X9(c) : c.match(h) || [];
      }
      var u2 = hr(function(c, h) {
        try {
          return Pn(c, r, h);
        } catch (y) {
          return Mg(y) ? y : new er(y);
        }
      }), FT = co(function(c, h) {
        return Ui(h, function(y) {
          y = Ts(y), oo(c, y, Ag(c[y], c));
        }), c;
      });
      function BT(c) {
        var h = c == null ? 0 : c.length, y = jt();
        return c = h ? Xr(c, function(O) {
          if (typeof O[1] != "function")
            throw new ji(o);
          return [y(O[0]), O[1]];
        }) : [], hr(function(O) {
          for (var q = -1; ++q < h; ) {
            var ne = c[q];
            if (Pn(ne[0], this, O))
              return Pn(ne[1], this, O);
          }
        });
      }
      function UT(c) {
        return lP(zi(c, p));
      }
      function Dg(c) {
        return function() {
          return c;
        };
      }
      function jT(c, h) {
        return c == null || c !== c ? h : c;
      }
      var qT = hw(), zT = hw(!0);
      function hi(c) {
        return c;
      }
      function Og(c) {
        return qy(typeof c == "function" ? c : zi(c, p));
      }
      function HT(c) {
        return Hy(zi(c, p));
      }
      function WT(c, h) {
        return Wy(c, zi(h, p));
      }
      var KT = hr(function(c, h) {
        return function(y) {
          return af(y, c, h);
        };
      }), VT = hr(function(c, h) {
        return function(y) {
          return af(c, y, h);
        };
      });
      function Ng(c, h, y) {
        var O = Mn(h), q = Lh(h, O);
        y == null && !(Zr(h) && (q.length || !O.length)) && (y = h, h = c, c = this, q = Lh(h, Mn(h)));
        var ne = !(Zr(y) && "chain" in y) || !!y.chain, fe = fo(c);
        return Ui(q, function(ge) {
          var we = h[ge];
          c[ge] = we, fe && (c.prototype[ge] = function() {
            var He = this.__chain__;
            if (ne || He) {
              var We = c(this.__wrapped__), Xe = We.__actions__ = ui(this.__actions__);
              return Xe.push({ func: we, args: arguments, thisArg: c }), We.__chain__ = He, We;
            }
            return we.apply(c, Ho([this.value()], arguments));
          });
        }), c;
      }
      function GT() {
        return _r._ === this && (_r._ = wA), this;
      }
      function Lg() {
      }
      function YT(c) {
        return c = ar(c), hr(function(h) {
          return Ky(h, c);
        });
      }
      var JT = hg(Xr), XT = hg(dy), ZT = hg($p);
      function f2(c) {
        return yg(c) ? Fp(Ts(c)) : IP(c);
      }
      function QT(c) {
        return function(h) {
          return c == null ? r : $a(c, h);
        };
      }
      var eR = pw(), tR = pw(!0);
      function kg() {
        return [];
      }
      function $g() {
        return !1;
      }
      function rR() {
        return {};
      }
      function nR() {
        return "";
      }
      function iR() {
        return !0;
      }
      function sR(c, h) {
        if (c = ar(c), c < 1 || c > _)
          return [];
        var y = M, O = Wn(c, M);
        h = jt(h), c -= M;
        for (var q = jp(O, h); ++y < c; )
          h(y);
        return q;
      }
      function oR(c) {
        return nr(c) ? Xr(c, Ts) : Mi(c) ? [c] : ui(Tw(Cr(c)));
      }
      function aR(c) {
        var h = ++bA;
        return Cr(c) + h;
      }
      var cR = jh(function(c, h) {
        return c + h;
      }, 0), uR = dg("ceil"), fR = jh(function(c, h) {
        return c / h;
      }, 1), lR = dg("floor");
      function hR(c) {
        return c && c.length ? Nh(c, hi, Zp) : r;
      }
      function dR(c, h) {
        return c && c.length ? Nh(c, jt(h, 2), Zp) : r;
      }
      function pR(c) {
        return my(c, hi);
      }
      function gR(c, h) {
        return my(c, jt(h, 2));
      }
      function mR(c) {
        return c && c.length ? Nh(c, hi, rg) : r;
      }
      function vR(c, h) {
        return c && c.length ? Nh(c, jt(h, 2), rg) : r;
      }
      var bR = jh(function(c, h) {
        return c * h;
      }, 1), yR = dg("round"), wR = jh(function(c, h) {
        return c - h;
      }, 0);
      function xR(c) {
        return c && c.length ? Up(c, hi) : 0;
      }
      function _R(c, h) {
        return c && c.length ? Up(c, jt(h, 2)) : 0;
      }
      return ee.after = HI, ee.ary = jw, ee.assign = RC, ee.assignIn = t2, ee.assignInWith = ed, ee.assignWith = DC, ee.at = OC, ee.before = qw, ee.bind = Ag, ee.bindAll = FT, ee.bindKey = zw, ee.castArray = rC, ee.chain = Fw, ee.chunk = lM, ee.compact = hM, ee.concat = dM, ee.cond = BT, ee.conforms = UT, ee.constant = Dg, ee.countBy = xI, ee.create = NC, ee.curry = Hw, ee.curryRight = Ww, ee.debounce = Kw, ee.defaults = LC, ee.defaultsDeep = kC, ee.defer = WI, ee.delay = KI, ee.difference = pM, ee.differenceBy = gM, ee.differenceWith = mM, ee.drop = vM, ee.dropRight = bM, ee.dropRightWhile = yM, ee.dropWhile = wM, ee.fill = xM, ee.filter = EI, ee.flatMap = PI, ee.flatMapDeep = MI, ee.flatMapDepth = II, ee.flatten = Nw, ee.flattenDeep = _M, ee.flattenDepth = EM, ee.flip = VI, ee.flow = qT, ee.flowRight = zT, ee.fromPairs = SM, ee.functions = zC, ee.functionsIn = HC, ee.groupBy = CI, ee.initial = PM, ee.intersection = MM, ee.intersectionBy = IM, ee.intersectionWith = CM, ee.invert = KC, ee.invertBy = VC, ee.invokeMap = RI, ee.iteratee = Og, ee.keyBy = DI, ee.keys = Mn, ee.keysIn = li, ee.map = Gh, ee.mapKeys = YC, ee.mapValues = JC, ee.matches = HT, ee.matchesProperty = WT, ee.memoize = Jh, ee.merge = XC, ee.mergeWith = r2, ee.method = KT, ee.methodOf = VT, ee.mixin = Ng, ee.negate = Xh, ee.nthArg = YT, ee.omit = ZC, ee.omitBy = QC, ee.once = GI, ee.orderBy = OI, ee.over = JT, ee.overArgs = YI, ee.overEvery = XT, ee.overSome = ZT, ee.partial = Pg, ee.partialRight = Vw, ee.partition = NI, ee.pick = eT, ee.pickBy = n2, ee.property = f2, ee.propertyOf = QT, ee.pull = OM, ee.pullAll = kw, ee.pullAllBy = NM, ee.pullAllWith = LM, ee.pullAt = kM, ee.range = eR, ee.rangeRight = tR, ee.rearg = JI, ee.reject = $I, ee.remove = $M, ee.rest = XI, ee.reverse = Eg, ee.sampleSize = BI, ee.set = rT, ee.setWith = nT, ee.shuffle = UI, ee.slice = FM, ee.sortBy = zI, ee.sortedUniq = WM, ee.sortedUniqBy = KM, ee.split = PT, ee.spread = ZI, ee.tail = VM, ee.take = GM, ee.takeRight = YM, ee.takeRightWhile = JM, ee.takeWhile = XM, ee.tap = hI, ee.throttle = QI, ee.thru = Vh, ee.toArray = Zw, ee.toPairs = i2, ee.toPairsIn = s2, ee.toPath = oR, ee.toPlainObject = e2, ee.transform = iT, ee.unary = eC, ee.union = ZM, ee.unionBy = QM, ee.unionWith = eI, ee.uniq = tI, ee.uniqBy = rI, ee.uniqWith = nI, ee.unset = sT, ee.unzip = Sg, ee.unzipWith = $w, ee.update = oT, ee.updateWith = aT, ee.values = Uc, ee.valuesIn = cT, ee.without = iI, ee.words = c2, ee.wrap = tC, ee.xor = sI, ee.xorBy = oI, ee.xorWith = aI, ee.zip = cI, ee.zipObject = uI, ee.zipObjectDeep = fI, ee.zipWith = lI, ee.entries = i2, ee.entriesIn = s2, ee.extend = t2, ee.extendWith = ed, Ng(ee, ee), ee.add = cR, ee.attempt = u2, ee.camelCase = hT, ee.capitalize = o2, ee.ceil = uR, ee.clamp = uT, ee.clone = nC, ee.cloneDeep = sC, ee.cloneDeepWith = oC, ee.cloneWith = iC, ee.conformsTo = aC, ee.deburr = a2, ee.defaultTo = jT, ee.divide = fR, ee.endsWith = dT, ee.eq = hs, ee.escape = pT, ee.escapeRegExp = gT, ee.every = _I, ee.find = SI, ee.findIndex = Dw, ee.findKey = $C, ee.findLast = AI, ee.findLastIndex = Ow, ee.findLastKey = FC, ee.floor = lR, ee.forEach = Bw, ee.forEachRight = Uw, ee.forIn = BC, ee.forInRight = UC, ee.forOwn = jC, ee.forOwnRight = qC, ee.get = Cg, ee.gt = cC, ee.gte = uC, ee.has = WC, ee.hasIn = Tg, ee.head = Lw, ee.identity = hi, ee.includes = TI, ee.indexOf = AM, ee.inRange = fT, ee.invoke = GC, ee.isArguments = Ua, ee.isArray = nr, ee.isArrayBuffer = fC, ee.isArrayLike = fi, ee.isArrayLikeObject = cn, ee.isBoolean = lC, ee.isBuffer = Xo, ee.isDate = hC, ee.isElement = dC, ee.isEmpty = pC, ee.isEqual = gC, ee.isEqualWith = mC, ee.isError = Mg, ee.isFinite = vC, ee.isFunction = fo, ee.isInteger = Gw, ee.isLength = Zh, ee.isMap = Yw, ee.isMatch = bC, ee.isMatchWith = yC, ee.isNaN = wC, ee.isNative = xC, ee.isNil = EC, ee.isNull = _C, ee.isNumber = Jw, ee.isObject = Zr, ee.isObjectLike = en, ee.isPlainObject = df, ee.isRegExp = Ig, ee.isSafeInteger = SC, ee.isSet = Xw, ee.isString = Qh, ee.isSymbol = Mi, ee.isTypedArray = Bc, ee.isUndefined = AC, ee.isWeakMap = PC, ee.isWeakSet = MC, ee.join = TM, ee.kebabCase = mT, ee.last = Wi, ee.lastIndexOf = RM, ee.lowerCase = vT, ee.lowerFirst = bT, ee.lt = IC, ee.lte = CC, ee.max = hR, ee.maxBy = dR, ee.mean = pR, ee.meanBy = gR, ee.min = mR, ee.minBy = vR, ee.stubArray = kg, ee.stubFalse = $g, ee.stubObject = rR, ee.stubString = nR, ee.stubTrue = iR, ee.multiply = bR, ee.nth = DM, ee.noConflict = GT, ee.noop = Lg, ee.now = Yh, ee.pad = yT, ee.padEnd = wT, ee.padStart = xT, ee.parseInt = _T, ee.random = lT, ee.reduce = LI, ee.reduceRight = kI, ee.repeat = ET, ee.replace = ST, ee.result = tT, ee.round = yR, ee.runInContext = be, ee.sample = FI, ee.size = jI, ee.snakeCase = AT, ee.some = qI, ee.sortedIndex = BM, ee.sortedIndexBy = UM, ee.sortedIndexOf = jM, ee.sortedLastIndex = qM, ee.sortedLastIndexBy = zM, ee.sortedLastIndexOf = HM, ee.startCase = MT, ee.startsWith = IT, ee.subtract = wR, ee.sum = xR, ee.sumBy = _R, ee.template = CT, ee.times = sR, ee.toFinite = lo, ee.toInteger = ar, ee.toLength = Qw, ee.toLower = TT, ee.toNumber = Ki, ee.toSafeInteger = TC, ee.toString = Cr, ee.toUpper = RT, ee.trim = DT, ee.trimEnd = OT, ee.trimStart = NT, ee.truncate = LT, ee.unescape = kT, ee.uniqueId = aR, ee.upperCase = $T, ee.upperFirst = Rg, ee.each = Bw, ee.eachRight = Uw, ee.first = Lw, Ng(ee, function() {
        var c = {};
        return Is(ee, function(h, y) {
          Tr.call(ee.prototype, y) || (c[y] = h);
        }), c;
      }(), { chain: !1 }), ee.VERSION = n, Ui(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(c) {
        ee[c].placeholder = ee;
      }), Ui(["drop", "take"], function(c, h) {
        wr.prototype[c] = function(y) {
          y = y === r ? 1 : _n(ar(y), 0);
          var O = this.__filtered__ && !h ? new wr(this) : this.clone();
          return O.__filtered__ ? O.__takeCount__ = Wn(y, O.__takeCount__) : O.__views__.push({
            size: Wn(y, M),
            type: c + (O.__dir__ < 0 ? "Right" : "")
          }), O;
        }, wr.prototype[c + "Right"] = function(y) {
          return this.reverse()[c](y).reverse();
        };
      }), Ui(["filter", "map", "takeWhile"], function(c, h) {
        var y = h + 1, O = y == f || y == b;
        wr.prototype[c] = function(q) {
          var ne = this.clone();
          return ne.__iteratees__.push({
            iteratee: jt(q, 3),
            type: y
          }), ne.__filtered__ = ne.__filtered__ || O, ne;
        };
      }), Ui(["head", "last"], function(c, h) {
        var y = "take" + (h ? "Right" : "");
        wr.prototype[c] = function() {
          return this[y](1).value()[0];
        };
      }), Ui(["initial", "tail"], function(c, h) {
        var y = "drop" + (h ? "" : "Right");
        wr.prototype[c] = function() {
          return this.__filtered__ ? new wr(this) : this[y](1);
        };
      }), wr.prototype.compact = function() {
        return this.filter(hi);
      }, wr.prototype.find = function(c) {
        return this.filter(c).head();
      }, wr.prototype.findLast = function(c) {
        return this.reverse().find(c);
      }, wr.prototype.invokeMap = hr(function(c, h) {
        return typeof c == "function" ? new wr(this) : this.map(function(y) {
          return af(y, c, h);
        });
      }), wr.prototype.reject = function(c) {
        return this.filter(Xh(jt(c)));
      }, wr.prototype.slice = function(c, h) {
        c = ar(c);
        var y = this;
        return y.__filtered__ && (c > 0 || h < 0) ? new wr(y) : (c < 0 ? y = y.takeRight(-c) : c && (y = y.drop(c)), h !== r && (h = ar(h), y = h < 0 ? y.dropRight(-h) : y.take(h - c)), y);
      }, wr.prototype.takeRightWhile = function(c) {
        return this.reverse().takeWhile(c).reverse();
      }, wr.prototype.toArray = function() {
        return this.take(M);
      }, Is(wr.prototype, function(c, h) {
        var y = /^(?:filter|find|map|reject)|While$/.test(h), O = /^(?:head|last)$/.test(h), q = ee[O ? "take" + (h == "last" ? "Right" : "") : h], ne = O || /^find/.test(h);
        q && (ee.prototype[h] = function() {
          var fe = this.__wrapped__, ge = O ? [1] : arguments, we = fe instanceof wr, He = ge[0], We = we || nr(fe), Xe = function(vr) {
            var Er = q.apply(ee, Ho([vr], ge));
            return O && wt ? Er[0] : Er;
          };
          We && y && typeof He == "function" && He.length != 1 && (we = We = !1);
          var wt = this.__chain__, Ot = !!this.__actions__.length, Wt = ne && !wt, ur = we && !Ot;
          if (!ne && We) {
            fe = ur ? fe : new wr(this);
            var Kt = c.apply(fe, ge);
            return Kt.__actions__.push({ func: Vh, args: [Xe], thisArg: r }), new qi(Kt, wt);
          }
          return Wt && ur ? c.apply(this, ge) : (Kt = this.thru(Xe), Wt ? O ? Kt.value()[0] : Kt.value() : Kt);
        });
      }), Ui(["pop", "push", "shift", "sort", "splice", "unshift"], function(c) {
        var h = yh[c], y = /^(?:push|sort|unshift)$/.test(c) ? "tap" : "thru", O = /^(?:pop|shift)$/.test(c);
        ee.prototype[c] = function() {
          var q = arguments;
          if (O && !this.__chain__) {
            var ne = this.value();
            return h.apply(nr(ne) ? ne : [], q);
          }
          return this[y](function(fe) {
            return h.apply(nr(fe) ? fe : [], q);
          });
        };
      }), Is(wr.prototype, function(c, h) {
        var y = ee[h];
        if (y) {
          var O = y.name + "";
          Tr.call(Nc, O) || (Nc[O] = []), Nc[O].push({ name: h, func: y });
        }
      }), Nc[Uh(r, F).name] = [{
        name: "wrapper",
        func: r
      }], wr.prototype.clone = kA, wr.prototype.reverse = $A, wr.prototype.value = FA, ee.prototype.at = dI, ee.prototype.chain = pI, ee.prototype.commit = gI, ee.prototype.next = mI, ee.prototype.plant = bI, ee.prototype.reverse = yI, ee.prototype.toJSON = ee.prototype.valueOf = ee.prototype.value = wI, ee.prototype.first = ee.prototype.head, Qu && (ee.prototype[Qu] = vI), ee;
    }, Rc = gA();
    an ? ((an.exports = Rc)._ = Rc, jr._ = Rc) : _r._ = Rc;
  }).call(gn);
})(l0, l0.exports);
var jV = l0.exports, O1 = { exports: {} };
(function(t, e) {
  var r = typeof self < "u" ? self : gn, n = function() {
    function s() {
      this.fetch = !1, this.DOMException = r.DOMException;
    }
    return s.prototype = r, new s();
  }();
  (function(s) {
    (function(o) {
      var a = {
        searchParams: "URLSearchParams" in s,
        iterable: "Symbol" in s && "iterator" in Symbol,
        blob: "FileReader" in s && "Blob" in s && function() {
          try {
            return new Blob(), !0;
          } catch {
            return !1;
          }
        }(),
        formData: "FormData" in s,
        arrayBuffer: "ArrayBuffer" in s
      };
      function u(f) {
        return f && DataView.prototype.isPrototypeOf(f);
      }
      if (a.arrayBuffer)
        var l = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ], d = ArrayBuffer.isView || function(f) {
          return f && l.indexOf(Object.prototype.toString.call(f)) > -1;
        };
      function p(f) {
        if (typeof f != "string" && (f = String(f)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(f))
          throw new TypeError("Invalid character in header field name");
        return f.toLowerCase();
      }
      function w(f) {
        return typeof f != "string" && (f = String(f)), f;
      }
      function P(f) {
        var g = {
          next: function() {
            var b = f.shift();
            return { done: b === void 0, value: b };
          }
        };
        return a.iterable && (g[Symbol.iterator] = function() {
          return g;
        }), g;
      }
      function A(f) {
        this.map = {}, f instanceof A ? f.forEach(function(g, b) {
          this.append(b, g);
        }, this) : Array.isArray(f) ? f.forEach(function(g) {
          this.append(g[0], g[1]);
        }, this) : f && Object.getOwnPropertyNames(f).forEach(function(g) {
          this.append(g, f[g]);
        }, this);
      }
      A.prototype.append = function(f, g) {
        f = p(f), g = w(g);
        var b = this.map[f];
        this.map[f] = b ? b + ", " + g : g;
      }, A.prototype.delete = function(f) {
        delete this.map[p(f)];
      }, A.prototype.get = function(f) {
        return f = p(f), this.has(f) ? this.map[f] : null;
      }, A.prototype.has = function(f) {
        return this.map.hasOwnProperty(p(f));
      }, A.prototype.set = function(f, g) {
        this.map[p(f)] = w(g);
      }, A.prototype.forEach = function(f, g) {
        for (var b in this.map)
          this.map.hasOwnProperty(b) && f.call(g, this.map[b], b, this);
      }, A.prototype.keys = function() {
        var f = [];
        return this.forEach(function(g, b) {
          f.push(b);
        }), P(f);
      }, A.prototype.values = function() {
        var f = [];
        return this.forEach(function(g) {
          f.push(g);
        }), P(f);
      }, A.prototype.entries = function() {
        var f = [];
        return this.forEach(function(g, b) {
          f.push([b, g]);
        }), P(f);
      }, a.iterable && (A.prototype[Symbol.iterator] = A.prototype.entries);
      function N(f) {
        if (f.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        f.bodyUsed = !0;
      }
      function L(f) {
        return new Promise(function(g, b) {
          f.onload = function() {
            g(f.result);
          }, f.onerror = function() {
            b(f.error);
          };
        });
      }
      function F(f) {
        var g = new FileReader(), b = L(g);
        return g.readAsArrayBuffer(f), b;
      }
      function $(f) {
        var g = new FileReader(), b = L(g);
        return g.readAsText(f), b;
      }
      function K(f) {
        for (var g = new Uint8Array(f), b = new Array(g.length), x = 0; x < g.length; x++)
          b[x] = String.fromCharCode(g[x]);
        return b.join("");
      }
      function H(f) {
        if (f.slice)
          return f.slice(0);
        var g = new Uint8Array(f.byteLength);
        return g.set(new Uint8Array(f)), g.buffer;
      }
      function V() {
        return this.bodyUsed = !1, this._initBody = function(f) {
          this._bodyInit = f, f ? typeof f == "string" ? this._bodyText = f : a.blob && Blob.prototype.isPrototypeOf(f) ? this._bodyBlob = f : a.formData && FormData.prototype.isPrototypeOf(f) ? this._bodyFormData = f : a.searchParams && URLSearchParams.prototype.isPrototypeOf(f) ? this._bodyText = f.toString() : a.arrayBuffer && a.blob && u(f) ? (this._bodyArrayBuffer = H(f.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : a.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(f) || d(f)) ? this._bodyArrayBuffer = H(f) : this._bodyText = f = Object.prototype.toString.call(f) : this._bodyText = "", this.headers.get("content-type") || (typeof f == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : a.searchParams && URLSearchParams.prototype.isPrototypeOf(f) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, a.blob && (this.blob = function() {
          var f = N(this);
          if (f)
            return f;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? N(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(F);
        }), this.text = function() {
          var f = N(this);
          if (f)
            return f;
          if (this._bodyBlob)
            return $(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(K(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, a.formData && (this.formData = function() {
          return this.text().then(pe);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var te = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function R(f) {
        var g = f.toUpperCase();
        return te.indexOf(g) > -1 ? g : f;
      }
      function W(f, g) {
        g = g || {};
        var b = g.body;
        if (f instanceof W) {
          if (f.bodyUsed)
            throw new TypeError("Already read");
          this.url = f.url, this.credentials = f.credentials, g.headers || (this.headers = new A(f.headers)), this.method = f.method, this.mode = f.mode, this.signal = f.signal, !b && f._bodyInit != null && (b = f._bodyInit, f.bodyUsed = !0);
        } else
          this.url = String(f);
        if (this.credentials = g.credentials || this.credentials || "same-origin", (g.headers || !this.headers) && (this.headers = new A(g.headers)), this.method = R(g.method || this.method || "GET"), this.mode = g.mode || this.mode || null, this.signal = g.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && b)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(b);
      }
      W.prototype.clone = function() {
        return new W(this, { body: this._bodyInit });
      };
      function pe(f) {
        var g = new FormData();
        return f.trim().split("&").forEach(function(b) {
          if (b) {
            var x = b.split("="), _ = x.shift().replace(/\+/g, " "), E = x.join("=").replace(/\+/g, " ");
            g.append(decodeURIComponent(_), decodeURIComponent(E));
          }
        }), g;
      }
      function Ee(f) {
        var g = new A(), b = f.replace(/\r?\n[\t ]+/g, " ");
        return b.split(/\r?\n/).forEach(function(x) {
          var _ = x.split(":"), E = _.shift().trim();
          if (E) {
            var v = _.join(":").trim();
            g.append(E, v);
          }
        }), g;
      }
      V.call(W.prototype);
      function Y(f, g) {
        g || (g = {}), this.type = "default", this.status = g.status === void 0 ? 200 : g.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in g ? g.statusText : "OK", this.headers = new A(g.headers), this.url = g.url || "", this._initBody(f);
      }
      V.call(Y.prototype), Y.prototype.clone = function() {
        return new Y(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new A(this.headers),
          url: this.url
        });
      }, Y.error = function() {
        var f = new Y(null, { status: 0, statusText: "" });
        return f.type = "error", f;
      };
      var S = [301, 302, 303, 307, 308];
      Y.redirect = function(f, g) {
        if (S.indexOf(g) === -1)
          throw new RangeError("Invalid status code");
        return new Y(null, { status: g, headers: { location: f } });
      }, o.DOMException = s.DOMException;
      try {
        new o.DOMException();
      } catch {
        o.DOMException = function(g, b) {
          this.message = g, this.name = b;
          var x = Error(g);
          this.stack = x.stack;
        }, o.DOMException.prototype = Object.create(Error.prototype), o.DOMException.prototype.constructor = o.DOMException;
      }
      function m(f, g) {
        return new Promise(function(b, x) {
          var _ = new W(f, g);
          if (_.signal && _.signal.aborted)
            return x(new o.DOMException("Aborted", "AbortError"));
          var E = new XMLHttpRequest();
          function v() {
            E.abort();
          }
          E.onload = function() {
            var M = {
              status: E.status,
              statusText: E.statusText,
              headers: Ee(E.getAllResponseHeaders() || "")
            };
            M.url = "responseURL" in E ? E.responseURL : M.headers.get("X-Request-URL");
            var I = "response" in E ? E.response : E.responseText;
            b(new Y(I, M));
          }, E.onerror = function() {
            x(new TypeError("Network request failed"));
          }, E.ontimeout = function() {
            x(new TypeError("Network request failed"));
          }, E.onabort = function() {
            x(new o.DOMException("Aborted", "AbortError"));
          }, E.open(_.method, _.url, !0), _.credentials === "include" ? E.withCredentials = !0 : _.credentials === "omit" && (E.withCredentials = !1), "responseType" in E && a.blob && (E.responseType = "blob"), _.headers.forEach(function(M, I) {
            E.setRequestHeader(I, M);
          }), _.signal && (_.signal.addEventListener("abort", v), E.onreadystatechange = function() {
            E.readyState === 4 && _.signal.removeEventListener("abort", v);
          }), E.send(typeof _._bodyInit > "u" ? null : _._bodyInit);
        });
      }
      return m.polyfill = !0, s.fetch || (s.fetch = m, s.Headers = A, s.Request = W, s.Response = Y), o.Headers = A, o.Request = W, o.Response = Y, o.fetch = m, Object.defineProperty(o, "__esModule", { value: !0 }), o;
    })({});
  })(n), n.fetch.ponyfill = !0, delete n.fetch.polyfill;
  var i = n;
  e = i.fetch, e.default = i.fetch, e.fetch = i.fetch, e.Headers = i.Headers, e.Request = i.Request, e.Response = i.Response, t.exports = e;
})(O1, O1.exports);
var qV = O1.exports;
const L3 = /* @__PURE__ */ ts(qV);
var zV = Object.defineProperty, HV = Object.defineProperties, WV = Object.getOwnPropertyDescriptors, k3 = Object.getOwnPropertySymbols, KV = Object.prototype.hasOwnProperty, VV = Object.prototype.propertyIsEnumerable, $3 = (t, e, r) => e in t ? zV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, F3 = (t, e) => {
  for (var r in e || (e = {})) KV.call(e, r) && $3(t, r, e[r]);
  if (k3) for (var r of k3(e)) VV.call(e, r) && $3(t, r, e[r]);
  return t;
}, B3 = (t, e) => HV(t, WV(e));
const GV = { Accept: "application/json", "Content-Type": "application/json" }, YV = "POST", U3 = { headers: GV, method: YV }, j3 = 10;
let Ss = class {
  constructor(e, r = !1) {
    if (this.url = e, this.disableProviderPing = r, this.events = new rs.EventEmitter(), this.isAvailable = !1, this.registering = !1, !a3(e)) throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
    this.url = e, this.disableProviderPing = r;
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    if (!this.isAvailable) throw new Error("Connection already closed");
    this.onClose();
  }
  async send(e) {
    this.isAvailable || await this.register();
    try {
      const r = ko(e), n = await (await L3(this.url, B3(F3({}, U3), { body: r }))).json();
      this.onPayload({ data: n });
    } catch (r) {
      this.onError(e.id, r);
    }
  }
  async register(e = this.url) {
    if (!a3(e)) throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
    if (this.registering) {
      const r = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= r || this.events.listenerCount("open") >= r) && this.events.setMaxListeners(r + 1), new Promise((n, i) => {
        this.events.once("register_error", (s) => {
          this.resetMaxListeners(), i(s);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.isAvailable > "u") return i(new Error("HTTP connection is missing or invalid"));
          n();
        });
      });
    }
    this.url = e, this.registering = !0;
    try {
      if (!this.disableProviderPing) {
        const r = ko({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
        await L3(e, B3(F3({}, U3), { body: r }));
      }
      this.onOpen();
    } catch (r) {
      const n = this.parseError(r);
      throw this.events.emit("register_error", n), this.onClose(), n;
    }
  }
  onOpen() {
    this.isAvailable = !0, this.registering = !1, this.events.emit("open");
  }
  onClose() {
    this.isAvailable = !1, this.registering = !1, this.events.emit("close");
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const r = typeof e.data == "string" ? uc(e.data) : e.data;
    this.events.emit("payload", r);
  }
  onError(e, r) {
    const n = this.parseError(r), i = n.message || n.toString(), s = rp(e, i);
    this.events.emit("payload", s);
  }
  parseError(e, r = this.url) {
    return J8(e, r, "HTTP");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > j3 && this.events.setMaxListeners(j3);
  }
};
const q3 = "error", JV = "wss://relay.walletconnect.org", XV = "wc", ZV = "universal_provider", z3 = `${XV}@2:${ZV}:`, wE = "https://rpc.walletconnect.org/v1/", Jc = "generic", QV = `${wE}bundler`, cs = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
var eG = Object.defineProperty, tG = Object.defineProperties, rG = Object.getOwnPropertyDescriptors, H3 = Object.getOwnPropertySymbols, nG = Object.prototype.hasOwnProperty, iG = Object.prototype.propertyIsEnumerable, W3 = (t, e, r) => e in t ? eG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, fd = (t, e) => {
  for (var r in e || (e = {})) nG.call(e, r) && W3(t, r, e[r]);
  if (H3) for (var r of H3(e)) iG.call(e, r) && W3(t, r, e[r]);
  return t;
}, sG = (t, e) => tG(t, rG(e));
function Ni(t, e, r) {
  var n;
  const i = lu(t);
  return ((n = e.rpcMap) == null ? void 0 : n[i.reference]) || `${wE}?chainId=${i.namespace}:${i.reference}&projectId=${r}`;
}
function Ec(t) {
  return t.includes(":") ? t.split(":")[1] : t;
}
function xE(t) {
  return t.map((e) => `${e.split(":")[0]}:${e.split(":")[1]}`);
}
function oG(t, e) {
  const r = Object.keys(e.namespaces).filter((i) => i.includes(t));
  if (!r.length) return [];
  const n = [];
  return r.forEach((i) => {
    const s = e.namespaces[i].accounts;
    n.push(...s);
  }), n;
}
function bm(t = {}, e = {}) {
  const r = K3(t), n = K3(e);
  return jV.merge(r, n);
}
function K3(t) {
  var e, r, n, i;
  const s = {};
  if (!El(t)) return s;
  for (const [o, a] of Object.entries(t)) {
    const u = ob(o) ? [o] : a.chains, l = a.methods || [], d = a.events || [], p = a.rpcMap || {}, w = Ff(o);
    s[w] = sG(fd(fd({}, s[w]), a), { chains: Md(u, (e = s[w]) == null ? void 0 : e.chains), methods: Md(l, (r = s[w]) == null ? void 0 : r.methods), events: Md(d, (n = s[w]) == null ? void 0 : n.events), rpcMap: fd(fd({}, p), (i = s[w]) == null ? void 0 : i.rpcMap) });
  }
  return s;
}
function aG(t) {
  return t.includes(":") ? t.split(":")[2] : t;
}
function V3(t) {
  const e = {};
  for (const [r, n] of Object.entries(t)) {
    const i = n.methods || [], s = n.events || [], o = n.accounts || [], a = ob(r) ? [r] : n.chains ? n.chains : xE(n.accounts);
    e[r] = { chains: a, methods: i, events: s, accounts: o };
  }
  return e;
}
function ym(t) {
  return typeof t == "number" ? t : t.includes("0x") ? parseInt(t, 16) : (t = t.includes(":") ? t.split(":")[1] : t, isNaN(Number(t)) ? t : Number(t));
}
const _E = {}, Ar = (t) => _E[t], wm = (t, e) => {
  _E[t] = e;
};
class cG {
  constructor(e) {
    this.name = "polkadot", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = Ec(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Ni(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new as(new Ss(n, Ar("disableProviderPing")));
  }
}
var uG = Object.defineProperty, fG = Object.defineProperties, lG = Object.getOwnPropertyDescriptors, G3 = Object.getOwnPropertySymbols, hG = Object.prototype.hasOwnProperty, dG = Object.prototype.propertyIsEnumerable, Y3 = (t, e, r) => e in t ? uG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, J3 = (t, e) => {
  for (var r in e || (e = {})) hG.call(e, r) && Y3(t, r, e[r]);
  if (G3) for (var r of G3(e)) dG.call(e, r) && Y3(t, r, e[r]);
  return t;
}, X3 = (t, e) => fG(t, lG(e));
class pG {
  constructor(e) {
    this.name = "eip155", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(e) {
    switch (e.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(e);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(e);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(e);
    }
    return this.namespace.methods.includes(e.request.method) ? await this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(parseInt(e), r), this.chainId = parseInt(e), this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  createHttpProvider(e, r) {
    const n = r || Ni(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new as(new Ss(n, Ar("disableProviderPing")));
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = parseInt(Ec(r));
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const e = this.chainId, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  async handleSwitchChain(e) {
    var r, n;
    let i = e.request.params ? (r = e.request.params[0]) == null ? void 0 : r.chainId : "0x0";
    i = i.startsWith("0x") ? i : `0x${i}`;
    const s = parseInt(i, 16);
    if (this.isChainApproved(s)) this.setDefaultChain(`${s}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: e.topic, request: { method: e.request.method, params: [{ chainId: i }] }, chainId: (n = this.namespace.chains) == null ? void 0 : n[0] }), this.setDefaultChain(`${s}`);
    else throw new Error(`Failed to switch to chain 'eip155:${s}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(e) {
    return this.namespace.chains.includes(`${this.name}:${e}`);
  }
  async getCapabilities(e) {
    var r, n, i;
    const s = (n = (r = e.request) == null ? void 0 : r.params) == null ? void 0 : n[0];
    if (!s) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const o = this.client.session.get(e.topic), a = ((i = o == null ? void 0 : o.sessionProperties) == null ? void 0 : i.capabilities) || {};
    if (a != null && a[s]) return a == null ? void 0 : a[s];
    const u = await this.client.request(e);
    try {
      await this.client.session.update(e.topic, { sessionProperties: X3(J3({}, o.sessionProperties || {}), { capabilities: X3(J3({}, a || {}), { [s]: u }) }) });
    } catch (l) {
      console.warn("Failed to update session with capabilities", l);
    }
    return u;
  }
  async getCallStatus(e) {
    var r, n;
    const i = this.client.session.get(e.topic), s = (r = i.sessionProperties) == null ? void 0 : r.bundler_name;
    if (s) {
      const a = this.getBundlerUrl(e.chainId, s);
      try {
        return await this.getUserOperationReceipt(a, e);
      } catch (u) {
        console.warn("Failed to fetch call status from bundler", u, a);
      }
    }
    const o = (n = i.sessionProperties) == null ? void 0 : n.bundler_url;
    if (o) try {
      return await this.getUserOperationReceipt(o, e);
    } catch (a) {
      console.warn("Failed to fetch call status from custom bundler", a, o);
    }
    if (this.namespace.methods.includes(e.request.method)) return await this.client.request(e);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(e, r) {
    var n;
    const i = new URL(e), s = await fetch(i, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(ha("eth_getUserOperationReceipt", [(n = r.request.params) == null ? void 0 : n[0]])) });
    if (!s.ok) throw new Error(`Failed to fetch user operation receipt - ${s.status}`);
    return await s.json();
  }
  getBundlerUrl(e, r) {
    return `${QV}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${r}`;
  }
}
class gG {
  constructor(e) {
    this.name = "solana", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = Ec(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Ni(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new as(new Ss(n, Ar("disableProviderPing")));
  }
}
let mG = class {
  constructor(e) {
    this.name = "cosmos", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = Ec(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Ni(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new as(new Ss(n, Ar("disableProviderPing")));
  }
}, vG = class {
  constructor(e) {
    this.name = "algorand", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    if (!this.httpProviders[e]) {
      const n = r || Ni(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
      if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, n);
    }
    this.chainId = e, this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      e[r] = this.createHttpProvider(r, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Ni(e, this.namespace, this.client.core.projectId);
    return typeof n > "u" ? void 0 : new as(new Ss(n, Ar("disableProviderPing")));
  }
}, bG = class {
  constructor(e) {
    this.name = "cip34", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      const n = this.getCardanoRPCUrl(r), i = Ec(r);
      e[i] = this.createHttpProvider(i, n);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  getCardanoRPCUrl(e) {
    const r = this.namespace.rpcMap;
    if (r) return r[e];
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || this.getCardanoRPCUrl(e);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new as(new Ss(n, Ar("disableProviderPing")));
  }
}, yG = class {
  constructor(e) {
    this.name = "elrond", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = Ec(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Ni(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new as(new Ss(n, Ar("disableProviderPing")));
  }
};
class wG {
  constructor(e) {
    this.name = "multiversx", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = Ec(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Ni(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new as(new Ss(n, Ar("disableProviderPing")));
  }
}
let xG = class {
  constructor(e) {
    this.name = "near", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    if (this.chainId = e, !this.httpProviders[e]) {
      const n = r || Ni(`${this.name}:${e}`, this.namespace);
      if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, n);
    }
    this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      e[r] = this.createHttpProvider(r, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Ni(e, this.namespace);
    return typeof n > "u" ? void 0 : new as(new Ss(n, Ar("disableProviderPing")));
  }
};
class _G {
  constructor(e) {
    this.name = "tezos", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    if (this.chainId = e, !this.httpProviders[e]) {
      const n = r || Ni(`${this.name}:${e}`, this.namespace);
      if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, n);
    }
    this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      e[r] = this.createHttpProvider(r);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Ni(e, this.namespace);
    return typeof n > "u" ? void 0 : new as(new Ss(n));
  }
}
class EG {
  constructor(e) {
    this.name = Jc, this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(e.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(e.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(e.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(e.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider(e.chainId).request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(cs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var e, r;
    const n = {};
    return (r = (e = this.namespace) == null ? void 0 : e.accounts) == null || r.forEach((i) => {
      const s = lu(i);
      n[`${s.namespace}:${s.reference}`] = this.createHttpProvider(i);
    }), n;
  }
  getHttpProvider(e) {
    const r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Ni(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new as(new Ss(n, Ar("disableProviderPing")));
  }
}
var SG = Object.defineProperty, AG = Object.defineProperties, PG = Object.getOwnPropertyDescriptors, Z3 = Object.getOwnPropertySymbols, MG = Object.prototype.hasOwnProperty, IG = Object.prototype.propertyIsEnumerable, Q3 = (t, e, r) => e in t ? SG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, ld = (t, e) => {
  for (var r in e || (e = {})) MG.call(e, r) && Q3(t, r, e[r]);
  if (Z3) for (var r of Z3(e)) IG.call(e, r) && Q3(t, r, e[r]);
  return t;
}, xm = (t, e) => AG(t, PG(e));
let EE = class SE {
  constructor(e) {
    this.events = new Lv(), this.rpcProviders = {}, this.shouldAbortPairingAttempt = !1, this.maxPairingAttempts = 10, this.disableProviderPing = !1, this.providerOpts = e, this.logger = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : jl(k0({ level: (e == null ? void 0 : e.logger) || q3 })), this.disableProviderPing = (e == null ? void 0 : e.disableProviderPing) || !1;
  }
  static async init(e) {
    const r = new SE(e);
    return await r.initialize(), r;
  }
  async request(e, r, n) {
    const [i, s] = this.validateChain(r);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(i).request({ request: ld({}, e), chainId: `${i}:${s}`, topic: this.session.topic, expiry: n });
  }
  sendAsync(e, r, n, i) {
    const s = (/* @__PURE__ */ new Date()).getTime();
    this.request(e, n, i).then((o) => r(null, tp(s, o))).catch((o) => r(o, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var e;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (e = this.session) == null ? void 0 : e.topic, reason: Or("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(e) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(e), await this.cleanupPendingPairings(), !e.skipPairing) return await this.pair(e.pairingTopic);
  }
  async authenticate(e, r) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(e), await this.cleanupPendingPairings();
    const { uri: n, response: i } = await this.client.authenticate(e, r);
    n && (this.uri = n, this.events.emit("display_uri", n));
    const s = await i();
    if (this.session = s.session, this.session) {
      const o = V3(this.session.namespaces);
      this.namespaces = bm(this.namespaces, o), this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return s;
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  get isWalletConnect() {
    return !0;
  }
  async pair(e) {
    this.shouldAbortPairingAttempt = !1;
    let r = 0;
    do {
      if (this.shouldAbortPairingAttempt) throw new Error("Pairing aborted");
      if (r >= this.maxPairingAttempts) throw new Error("Max auto pairing attempts reached");
      const { uri: n, approval: i } = await this.client.connect({ pairingTopic: e, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties });
      n && (this.uri = n, this.events.emit("display_uri", n)), await i().then((s) => {
        this.session = s;
        const o = V3(s.namespaces);
        this.namespaces = bm(this.namespaces, o), this.persist("namespaces", this.namespaces);
      }).catch((s) => {
        if (s.message !== yE) throw s;
        r++;
      });
    } while (!this.session);
    return this.onConnect(), this.session;
  }
  setDefaultChain(e, r) {
    try {
      if (!this.session) return;
      const [n, i] = this.validateChain(e), s = this.getProvider(n);
      s.name === Jc ? s.setDefaultChain(`${n}:${i}`, r) : s.setDefaultChain(i, r);
    } catch (n) {
      if (!/Please call connect/.test(n.message)) throw n;
    }
  }
  async cleanupPendingPairings(e = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const r = this.client.pairing.getAll();
    if (dc(r)) {
      for (const n of r) e.deletePairings ? this.client.core.expirer.set(n.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(n.topic);
      this.logger.info(`Inactive pairings cleared: ${r.length}`);
    }
  }
  abortPairingAttempt() {
    this.shouldAbortPairingAttempt = !0;
  }
  async checkStorage() {
    if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
      const e = this.client.session.keys.length - 1;
      this.session = this.client.session.get(this.client.session.keys[e]), this.createProviders();
    }
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    this.client = this.providerOpts.client || await hb.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || q3, relayUrl: this.providerOpts.relayUrl || JV, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const e = [...new Set(Object.keys(this.session.namespaces).map((r) => Ff(r)))];
    wm("client", this.client), wm("events", this.events), wm("disableProviderPing", this.disableProviderPing), e.forEach((r) => {
      if (!this.session) return;
      const n = oG(r, this.session), i = xE(n), s = bm(this.namespaces, this.optionalNamespaces), o = xm(ld({}, s[r]), { accounts: n, chains: i });
      switch (r) {
        case "eip155":
          this.rpcProviders[r] = new pG({ namespace: o });
          break;
        case "algorand":
          this.rpcProviders[r] = new vG({ namespace: o });
          break;
        case "solana":
          this.rpcProviders[r] = new gG({ namespace: o });
          break;
        case "cosmos":
          this.rpcProviders[r] = new mG({ namespace: o });
          break;
        case "polkadot":
          this.rpcProviders[r] = new cG({ namespace: o });
          break;
        case "cip34":
          this.rpcProviders[r] = new bG({ namespace: o });
          break;
        case "elrond":
          this.rpcProviders[r] = new yG({ namespace: o });
          break;
        case "multiversx":
          this.rpcProviders[r] = new wG({ namespace: o });
          break;
        case "near":
          this.rpcProviders[r] = new xG({ namespace: o });
          break;
        case "tezos":
          this.rpcProviders[r] = new _G({ namespace: o });
          break;
        default:
          this.rpcProviders[Jc] ? this.rpcProviders[Jc].updateNamespace(o) : this.rpcProviders[Jc] = new EG({ namespace: o });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (e) => {
      this.events.emit("session_ping", e);
    }), this.client.on("session_event", (e) => {
      const { params: r } = e, { event: n } = r;
      if (n.name === "accountsChanged") {
        const i = n.data;
        i && dc(i) && this.events.emit("accountsChanged", i.map(aG));
      } else if (n.name === "chainChanged") {
        const i = r.chainId, s = r.event.data, o = Ff(i), a = ym(i) !== ym(s) ? `${o}:${ym(s)}` : i;
        this.onChainChanged(a);
      } else this.events.emit(n.name, n.data);
      this.events.emit("session_event", e);
    }), this.client.on("session_update", ({ topic: e, params: r }) => {
      var n;
      const { namespaces: i } = r, s = (n = this.client) == null ? void 0 : n.session.get(e);
      this.session = xm(ld({}, s), { namespaces: i }), this.onSessionUpdate(), this.events.emit("session_update", { topic: e, params: r });
    }), this.client.on("session_delete", async (e) => {
      await this.cleanup(), this.events.emit("session_delete", e), this.events.emit("disconnect", xm(ld({}, Or("USER_DISCONNECTED")), { data: e.topic }));
    }), this.on(cs.DEFAULT_CHAIN_CHANGED, (e) => {
      this.onChainChanged(e, !0);
    });
  }
  getProvider(e) {
    return this.rpcProviders[e] || this.rpcProviders[Jc];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((e) => {
      var r;
      this.getProvider(e).updateNamespace((r = this.session) == null ? void 0 : r.namespaces[e]);
    });
  }
  setNamespaces(e) {
    const { namespaces: r, optionalNamespaces: n, sessionProperties: i } = e;
    r && Object.keys(r).length && (this.namespaces = r), n && Object.keys(n).length && (this.optionalNamespaces = n), this.sessionProperties = i, this.persist("namespaces", r), this.persist("optionalNamespaces", n);
  }
  validateChain(e) {
    const [r, n] = (e == null ? void 0 : e.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [r, n];
    if (r && !Object.keys(this.namespaces || {}).map((o) => Ff(o)).includes(r)) throw new Error(`Namespace '${r}' is not configured. Please call connect() first with namespace config.`);
    if (r && n) return [r, n];
    const i = Ff(Object.keys(this.namespaces)[0]), s = this.rpcProviders[i].getDefaultChain();
    return [i, s];
  }
  async requestAccounts() {
    const [e] = this.validateChain();
    return await this.getProvider(e).requestAccounts();
  }
  onChainChanged(e, r = !1) {
    if (!this.namespaces) return;
    const [n, i] = this.validateChain(e);
    i && (r || this.getProvider(n).setDefaultChain(i), this.namespaces[n] ? this.namespaces[n].defaultChain = i : this.namespaces[`${n}:${i}`] ? this.namespaces[`${n}:${i}`].defaultChain = i : this.namespaces[`${n}:${i}`] = { defaultChain: i }, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", i));
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({ deletePairings: !0 });
  }
  persist(e, r) {
    this.client.core.storage.setItem(`${z3}/${e}`, r);
  }
  async getFromStore(e) {
    return await this.client.core.storage.getItem(`${z3}/${e}`);
  }
};
const CG = EE;
function TG() {
  return new Promise((t) => {
    const e = [];
    let r;
    window.addEventListener("eip6963:announceProvider", (n) => {
      const { detail: i } = n;
      r && clearTimeout(r), e.push(i), r = setTimeout(() => t(e), 200);
    }), r = setTimeout(() => t(e), 200), window.dispatchEvent(new Event("eip6963:requestProvider"));
  });
}
class Qs {
  constructor(e, r) {
    this.scope = e, this.module = r;
  }
  storeObject(e, r) {
    this.setItem(e, JSON.stringify(r));
  }
  loadObject(e) {
    const r = this.getItem(e);
    return r ? JSON.parse(r) : void 0;
  }
  setItem(e, r) {
    localStorage.setItem(this.scopedKey(e), r);
  }
  getItem(e) {
    return localStorage.getItem(this.scopedKey(e));
  }
  removeItem(e) {
    localStorage.removeItem(this.scopedKey(e));
  }
  clear() {
    const e = this.scopedKey(""), r = [];
    for (let n = 0; n < localStorage.length; n++) {
      const i = localStorage.key(n);
      typeof i == "string" && i.startsWith(e) && r.push(i);
    }
    r.forEach((n) => localStorage.removeItem(n));
  }
  scopedKey(e) {
    return `-${this.scope}${this.module ? `:${this.module}` : ""}:${e}`;
  }
  static clearAll() {
    new Qs("CBWSDK").clear(), new Qs("walletlink").clear();
  }
}
const fn = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901,
    unsupportedChain: 4902
  }
}, N1 = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  4001: {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  4100: {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  4200: {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  4900: {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  4901: {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  },
  4902: {
    standard: "EIP-3085",
    message: "Unrecognized chain ID."
  }
}, AE = "Unspecified error message.", RG = "Unspecified server error.";
function db(t, e = AE) {
  if (t && Number.isInteger(t)) {
    const r = t.toString();
    if (L1(N1, r))
      return N1[r].message;
    if (PE(t))
      return RG;
  }
  return e;
}
function DG(t) {
  if (!Number.isInteger(t))
    return !1;
  const e = t.toString();
  return !!(N1[e] || PE(t));
}
function OG(t, { shouldIncludeStack: e = !1 } = {}) {
  const r = {};
  if (t && typeof t == "object" && !Array.isArray(t) && L1(t, "code") && DG(t.code)) {
    const n = t;
    r.code = n.code, n.message && typeof n.message == "string" ? (r.message = n.message, L1(n, "data") && (r.data = n.data)) : (r.message = db(r.code), r.data = { originalError: e_(t) });
  } else
    r.code = fn.rpc.internal, r.message = t_(t, "message") ? t.message : AE, r.data = { originalError: e_(t) };
  return e && (r.stack = t_(t, "stack") ? t.stack : void 0), r;
}
function PE(t) {
  return t >= -32099 && t <= -32e3;
}
function e_(t) {
  return t && typeof t == "object" && !Array.isArray(t) ? Object.assign({}, t) : t;
}
function L1(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function t_(t, e) {
  return typeof t == "object" && t !== null && e in t && typeof t[e] == "string";
}
const Sr = {
  rpc: {
    parse: (t) => Gi(fn.rpc.parse, t),
    invalidRequest: (t) => Gi(fn.rpc.invalidRequest, t),
    invalidParams: (t) => Gi(fn.rpc.invalidParams, t),
    methodNotFound: (t) => Gi(fn.rpc.methodNotFound, t),
    internal: (t) => Gi(fn.rpc.internal, t),
    server: (t) => {
      if (!t || typeof t != "object" || Array.isArray(t))
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      const { code: e } = t;
      if (!Number.isInteger(e) || e > -32005 || e < -32099)
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      return Gi(e, t);
    },
    invalidInput: (t) => Gi(fn.rpc.invalidInput, t),
    resourceNotFound: (t) => Gi(fn.rpc.resourceNotFound, t),
    resourceUnavailable: (t) => Gi(fn.rpc.resourceUnavailable, t),
    transactionRejected: (t) => Gi(fn.rpc.transactionRejected, t),
    methodNotSupported: (t) => Gi(fn.rpc.methodNotSupported, t),
    limitExceeded: (t) => Gi(fn.rpc.limitExceeded, t)
  },
  provider: {
    userRejectedRequest: (t) => Kc(fn.provider.userRejectedRequest, t),
    unauthorized: (t) => Kc(fn.provider.unauthorized, t),
    unsupportedMethod: (t) => Kc(fn.provider.unsupportedMethod, t),
    disconnected: (t) => Kc(fn.provider.disconnected, t),
    chainDisconnected: (t) => Kc(fn.provider.chainDisconnected, t),
    unsupportedChain: (t) => Kc(fn.provider.unsupportedChain, t),
    custom: (t) => {
      if (!t || typeof t != "object" || Array.isArray(t))
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      const { code: e, message: r, data: n } = t;
      if (!r || typeof r != "string")
        throw new Error('"message" must be a nonempty string');
      return new CE(e, r, n);
    }
  }
};
function Gi(t, e) {
  const [r, n] = ME(e);
  return new IE(t, r || db(t), n);
}
function Kc(t, e) {
  const [r, n] = ME(e);
  return new CE(t, r || db(t), n);
}
function ME(t) {
  if (t) {
    if (typeof t == "string")
      return [t];
    if (typeof t == "object" && !Array.isArray(t)) {
      const { message: e, data: r } = t;
      if (e && typeof e != "string")
        throw new Error("Must specify string message.");
      return [e || void 0, r];
    }
  }
  return [];
}
class IE extends Error {
  constructor(e, r, n) {
    if (!Number.isInteger(e))
      throw new Error('"code" must be an integer.');
    if (!r || typeof r != "string")
      throw new Error('"message" must be a nonempty string.');
    super(r), this.code = e, n !== void 0 && (this.data = n);
  }
}
class CE extends IE {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(e, r, n) {
    if (!NG(e))
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(e, r, n);
  }
}
function NG(t) {
  return Number.isInteger(t) && t >= 1e3 && t <= 4999;
}
function pb() {
  return (t) => t;
}
const Sl = pb(), LG = pb(), kG = pb();
function xo(t) {
  return Math.floor(t);
}
const TE = /^[0-9]*$/, RE = /^[a-f0-9]*$/;
function Za(t) {
  return gb(crypto.getRandomValues(new Uint8Array(t)));
}
function gb(t) {
  return [...t].map((e) => e.toString(16).padStart(2, "0")).join("");
}
function Rd(t) {
  return new Uint8Array(t.match(/.{1,2}/g).map((e) => Number.parseInt(e, 16)));
}
function Hf(t, e = !1) {
  const r = t.toString("hex");
  return Sl(e ? `0x${r}` : r);
}
function _m(t) {
  return Hf(k1(t), !0);
}
function ks(t) {
  return kG(t.toString(10));
}
function da(t) {
  return Sl(`0x${BigInt(t).toString(16)}`);
}
function DE(t) {
  return t.startsWith("0x") || t.startsWith("0X");
}
function mb(t) {
  return DE(t) ? t.slice(2) : t;
}
function OE(t) {
  return DE(t) ? `0x${t.slice(2)}` : `0x${t}`;
}
function op(t) {
  if (typeof t != "string")
    return !1;
  const e = mb(t).toLowerCase();
  return RE.test(e);
}
function $G(t, e = !1) {
  if (typeof t == "string") {
    const r = mb(t).toLowerCase();
    if (RE.test(r))
      return Sl(e ? `0x${r}` : r);
  }
  throw Sr.rpc.invalidParams(`"${String(t)}" is not a hexadecimal string`);
}
function vb(t, e = !1) {
  let r = $G(t, !1);
  return r.length % 2 === 1 && (r = Sl(`0${r}`)), e ? Sl(`0x${r}`) : r;
}
function ta(t) {
  if (typeof t == "string") {
    const e = mb(t).toLowerCase();
    if (op(e) && e.length === 40)
      return LG(OE(e));
  }
  throw Sr.rpc.invalidParams(`Invalid Ethereum address: ${String(t)}`);
}
function k1(t) {
  if (Buffer.isBuffer(t))
    return t;
  if (typeof t == "string") {
    if (op(t)) {
      const e = vb(t, !1);
      return Buffer.from(e, "hex");
    }
    return Buffer.from(t, "utf8");
  }
  throw Sr.rpc.invalidParams(`Not binary data: ${String(t)}`);
}
function Wf(t) {
  if (typeof t == "number" && Number.isInteger(t))
    return xo(t);
  if (typeof t == "string") {
    if (TE.test(t))
      return xo(Number(t));
    if (op(t))
      return xo(Number(BigInt(vb(t, !0))));
  }
  throw Sr.rpc.invalidParams(`Not an integer: ${String(t)}`);
}
function Tf(t) {
  if (t !== null && (typeof t == "bigint" || BG(t)))
    return BigInt(t.toString(10));
  if (typeof t == "number")
    return BigInt(Wf(t));
  if (typeof t == "string") {
    if (TE.test(t))
      return BigInt(t);
    if (op(t))
      return BigInt(vb(t, !0));
  }
  throw Sr.rpc.invalidParams(`Not an integer: ${String(t)}`);
}
function FG(t) {
  if (typeof t == "string")
    return JSON.parse(t);
  if (typeof t == "object")
    return t;
  throw Sr.rpc.invalidParams(`Not a JSON string or an object: ${String(t)}`);
}
function BG(t) {
  if (t == null || typeof t.constructor != "function")
    return !1;
  const { constructor: e } = t;
  return typeof e.config == "function" && typeof e.EUCLID == "number";
}
async function UG() {
  return crypto.subtle.generateKey({
    name: "ECDH",
    namedCurve: "P-256"
  }, !0, ["deriveKey"]);
}
async function jG(t, e) {
  return crypto.subtle.deriveKey({
    name: "ECDH",
    public: e
  }, t, {
    name: "AES-GCM",
    length: 256
  }, !1, ["encrypt", "decrypt"]);
}
async function qG(t, e) {
  const r = crypto.getRandomValues(new Uint8Array(12)), n = await crypto.subtle.encrypt({
    name: "AES-GCM",
    iv: r
  }, t, new TextEncoder().encode(e));
  return { iv: r, cipherText: n };
}
async function zG(t, { iv: e, cipherText: r }) {
  const n = await crypto.subtle.decrypt({
    name: "AES-GCM",
    iv: e
  }, t, r);
  return new TextDecoder().decode(n);
}
function NE(t) {
  switch (t) {
    case "public":
      return "spki";
    case "private":
      return "pkcs8";
  }
}
async function LE(t, e) {
  const r = NE(t), n = await crypto.subtle.exportKey(r, e);
  return gb(new Uint8Array(n));
}
async function kE(t, e) {
  const r = NE(t), n = Rd(e).buffer;
  return await crypto.subtle.importKey(r, new Uint8Array(n), {
    name: "ECDH",
    namedCurve: "P-256"
  }, !0, t === "private" ? ["deriveKey"] : []);
}
async function HG(t, e) {
  const r = JSON.stringify(t, (n, i) => {
    if (!(i instanceof Error))
      return i;
    const s = i;
    return Object.assign(Object.assign({}, s.code ? { code: s.code } : {}), { message: s.message });
  });
  return qG(e, r);
}
async function WG(t, e) {
  return JSON.parse(await zG(e, t));
}
const Em = {
  storageKey: "ownPrivateKey",
  keyType: "private"
}, Sm = {
  storageKey: "ownPublicKey",
  keyType: "public"
}, Am = {
  storageKey: "peerPublicKey",
  keyType: "public"
};
class KG {
  constructor() {
    this.storage = new Qs("CBWSDK", "SCWKeyManager"), this.ownPrivateKey = null, this.ownPublicKey = null, this.peerPublicKey = null, this.sharedSecret = null;
  }
  async getOwnPublicKey() {
    return await this.loadKeysIfNeeded(), this.ownPublicKey;
  }
  // returns null if the shared secret is not yet derived
  async getSharedSecret() {
    return await this.loadKeysIfNeeded(), this.sharedSecret;
  }
  async setPeerPublicKey(e) {
    this.sharedSecret = null, this.peerPublicKey = e, await this.storeKey(Am, e), await this.loadKeysIfNeeded();
  }
  async clear() {
    this.ownPrivateKey = null, this.ownPublicKey = null, this.peerPublicKey = null, this.sharedSecret = null, this.storage.removeItem(Sm.storageKey), this.storage.removeItem(Em.storageKey), this.storage.removeItem(Am.storageKey);
  }
  async generateKeyPair() {
    const e = await UG();
    this.ownPrivateKey = e.privateKey, this.ownPublicKey = e.publicKey, await this.storeKey(Em, e.privateKey), await this.storeKey(Sm, e.publicKey);
  }
  async loadKeysIfNeeded() {
    if (this.ownPrivateKey === null && (this.ownPrivateKey = await this.loadKey(Em)), this.ownPublicKey === null && (this.ownPublicKey = await this.loadKey(Sm)), (this.ownPrivateKey === null || this.ownPublicKey === null) && await this.generateKeyPair(), this.peerPublicKey === null && (this.peerPublicKey = await this.loadKey(Am)), this.sharedSecret === null) {
      if (this.ownPrivateKey === null || this.peerPublicKey === null)
        return;
      this.sharedSecret = await jG(this.ownPrivateKey, this.peerPublicKey);
    }
  }
  // storage methods
  async loadKey(e) {
    const r = this.storage.getItem(e.storageKey);
    return r ? kE(e.keyType, r) : null;
  }
  async storeKey(e, r) {
    const n = await LE(e.keyType, r);
    this.storage.setItem(e.storageKey, n);
  }
}
const rh = "4.2.4", $E = "@coinbase/wallet-sdk";
async function FE(t, e) {
  const r = Object.assign(Object.assign({}, t), { jsonrpc: "2.0", id: crypto.randomUUID() }), n = await window.fetch(e, {
    method: "POST",
    body: JSON.stringify(r),
    mode: "cors",
    headers: {
      "Content-Type": "application/json",
      "X-Cbw-Sdk-Version": rh,
      "X-Cbw-Sdk-Platform": $E
    }
  }), { result: i, error: s } = await n.json();
  if (s)
    throw s;
  return i;
}
function VG() {
  return globalThis.coinbaseWalletExtension;
}
function GG() {
  var t, e;
  try {
    const r = globalThis;
    return (t = r.ethereum) !== null && t !== void 0 ? t : (e = r.top) === null || e === void 0 ? void 0 : e.ethereum;
  } catch {
    return;
  }
}
function YG({ metadata: t, preference: e }) {
  var r, n;
  const { appName: i, appLogoUrl: s, appChainIds: o } = t;
  if (e.options !== "smartWalletOnly") {
    const u = VG();
    if (u)
      return (r = u.setAppInfo) === null || r === void 0 || r.call(u, i, s, o, e), u;
  }
  const a = GG();
  if (a != null && a.isCoinbaseBrowser)
    return (n = a.setAppInfo) === null || n === void 0 || n.call(a, i, s, o, e), a;
}
function JG(t) {
  if (!t || typeof t != "object" || Array.isArray(t))
    throw Sr.rpc.invalidParams({
      message: "Expected a single, non-array, object argument.",
      data: t
    });
  const { method: e, params: r } = t;
  if (typeof e != "string" || e.length === 0)
    throw Sr.rpc.invalidParams({
      message: "'args.method' must be a non-empty string.",
      data: t
    });
  if (r !== void 0 && !Array.isArray(r) && (typeof r != "object" || r === null))
    throw Sr.rpc.invalidParams({
      message: "'args.params' must be an object or array if provided.",
      data: t
    });
  switch (e) {
    case "eth_sign":
    case "eth_signTypedData_v2":
    case "eth_subscribe":
    case "eth_unsubscribe":
      throw Sr.provider.unsupportedMethod();
  }
}
const r_ = "accounts", n_ = "activeChain", i_ = "availableChains", s_ = "walletCapabilities";
class XG {
  constructor(e) {
    var r, n, i;
    this.metadata = e.metadata, this.communicator = e.communicator, this.callback = e.callback, this.keyManager = new KG(), this.storage = new Qs("CBWSDK", "SCWStateManager"), this.accounts = (r = this.storage.loadObject(r_)) !== null && r !== void 0 ? r : [], this.chain = this.storage.loadObject(n_) || {
      id: (i = (n = e.metadata.appChainIds) === null || n === void 0 ? void 0 : n[0]) !== null && i !== void 0 ? i : 1
    }, this.handshake = this.handshake.bind(this), this.request = this.request.bind(this), this.createRequestMessage = this.createRequestMessage.bind(this), this.decryptResponseMessage = this.decryptResponseMessage.bind(this);
  }
  async handshake(e) {
    var r, n;
    const i = await this.createRequestMessage({
      handshake: {
        method: e.method,
        params: Object.assign({}, this.metadata, (r = e.params) !== null && r !== void 0 ? r : {})
      }
    }), s = await this.communicator.postRequestAndWaitForResponse(i);
    if ("failure" in s.content)
      throw s.content.failure;
    const o = await kE("public", s.sender);
    await this.keyManager.setPeerPublicKey(o);
    const u = (await this.decryptResponseMessage(s)).result;
    if ("error" in u)
      throw u.error;
    const l = u.value;
    this.accounts = l, this.storage.storeObject(r_, l), (n = this.callback) === null || n === void 0 || n.call(this, "accountsChanged", l);
  }
  async request(e) {
    var r;
    if (this.accounts.length === 0)
      throw Sr.provider.unauthorized();
    switch (e.method) {
      case "eth_requestAccounts":
        return (r = this.callback) === null || r === void 0 || r.call(this, "connect", { chainId: da(this.chain.id) }), this.accounts;
      case "eth_accounts":
        return this.accounts;
      case "eth_coinbase":
        return this.accounts[0];
      case "net_version":
        return this.chain.id;
      case "eth_chainId":
        return da(this.chain.id);
      case "wallet_getCapabilities":
        return this.storage.loadObject(s_);
      case "wallet_switchEthereumChain":
        return this.handleSwitchChainRequest(e);
      case "eth_ecRecover":
      case "personal_sign":
      case "personal_ecRecover":
      case "eth_signTransaction":
      case "eth_sendTransaction":
      case "eth_signTypedData_v1":
      case "eth_signTypedData_v3":
      case "eth_signTypedData_v4":
      case "eth_signTypedData":
      case "wallet_addEthereumChain":
      case "wallet_watchAsset":
      case "wallet_sendCalls":
      case "wallet_showCallsStatus":
      case "wallet_grantPermissions":
        return this.sendRequestToPopup(e);
      default:
        if (!this.chain.rpcUrl)
          throw Sr.rpc.internal("No RPC URL set for chain");
        return FE(e, this.chain.rpcUrl);
    }
  }
  async sendRequestToPopup(e) {
    var r, n;
    await ((n = (r = this.communicator).waitForPopupLoaded) === null || n === void 0 ? void 0 : n.call(r));
    const i = await this.sendEncryptedRequest(e), o = (await this.decryptResponseMessage(i)).result;
    if ("error" in o)
      throw o.error;
    return o.value;
  }
  async cleanup() {
    var e, r;
    this.storage.clear(), await this.keyManager.clear(), this.accounts = [], this.chain = {
      id: (r = (e = this.metadata.appChainIds) === null || e === void 0 ? void 0 : e[0]) !== null && r !== void 0 ? r : 1
    };
  }
  /**
   * @returns `null` if the request was successful.
   * https://eips.ethereum.org/EIPS/eip-3326#wallet_switchethereumchain
   */
  async handleSwitchChainRequest(e) {
    var r;
    const n = e.params;
    if (!n || !(!((r = n[0]) === null || r === void 0) && r.chainId))
      throw Sr.rpc.invalidParams();
    const i = Wf(n[0].chainId);
    if (this.updateChain(i))
      return null;
    const o = await this.sendRequestToPopup(e);
    return o === null && this.updateChain(i), o;
  }
  async sendEncryptedRequest(e) {
    const r = await this.keyManager.getSharedSecret();
    if (!r)
      throw Sr.provider.unauthorized("No valid session found, try requestAccounts before other methods");
    const n = await HG({
      action: e,
      chainId: this.chain.id
    }, r), i = await this.createRequestMessage({ encrypted: n });
    return this.communicator.postRequestAndWaitForResponse(i);
  }
  async createRequestMessage(e) {
    const r = await LE("public", await this.keyManager.getOwnPublicKey());
    return {
      id: crypto.randomUUID(),
      sender: r,
      content: e,
      timestamp: /* @__PURE__ */ new Date()
    };
  }
  async decryptResponseMessage(e) {
    var r, n;
    const i = e.content;
    if ("failure" in i)
      throw i.failure;
    const s = await this.keyManager.getSharedSecret();
    if (!s)
      throw Sr.provider.unauthorized("Invalid session");
    const o = await WG(i.encrypted, s), a = (r = o.data) === null || r === void 0 ? void 0 : r.chains;
    if (a) {
      const l = Object.entries(a).map(([d, p]) => ({
        id: Number(d),
        rpcUrl: p
      }));
      this.storage.storeObject(i_, l), this.updateChain(this.chain.id, l);
    }
    const u = (n = o.data) === null || n === void 0 ? void 0 : n.capabilities;
    return u && this.storage.storeObject(s_, u), o;
  }
  updateChain(e, r) {
    var n;
    const i = r ?? this.storage.loadObject(i_), s = i == null ? void 0 : i.find((o) => o.id === e);
    return s ? (s !== this.chain && (this.chain = s, this.storage.storeObject(n_, s), (n = this.callback) === null || n === void 0 || n.call(this, "chainChanged", da(s.id))), !0) : !1;
  }
}
const ZG = /* @__PURE__ */ bv(TD), { keccak_256: QG } = ZG;
function BE(t) {
  return Buffer.allocUnsafe(t).fill(0);
}
function eY(t) {
  return t.toString(2).length;
}
function UE(t, e) {
  let r = t.toString(16);
  r.length % 2 !== 0 && (r = "0" + r);
  const n = r.match(/.{1,2}/g).map((i) => parseInt(i, 16));
  for (; n.length < e; )
    n.unshift(0);
  return Buffer.from(n);
}
function tY(t, e) {
  const r = t < 0n;
  let n;
  if (r) {
    const i = (1n << BigInt(e)) - 1n;
    n = (~t & i) + 1n;
  } else
    n = t;
  return n &= (1n << BigInt(e)) - 1n, n;
}
function jE(t, e, r) {
  const n = BE(e);
  return t = ap(t), r ? t.length < e ? (t.copy(n), n) : t.slice(0, e) : t.length < e ? (t.copy(n, e - t.length), n) : t.slice(-e);
}
function rY(t, e) {
  return jE(t, e, !0);
}
function ap(t) {
  if (!Buffer.isBuffer(t))
    if (Array.isArray(t))
      t = Buffer.from(t);
    else if (typeof t == "string")
      qE(t) ? t = Buffer.from(sY(zE(t)), "hex") : t = Buffer.from(t);
    else if (typeof t == "number")
      t = intToBuffer(t);
    else if (t == null)
      t = Buffer.allocUnsafe(0);
    else if (typeof t == "bigint")
      t = UE(t);
    else if (t.toArray)
      t = Buffer.from(t.toArray());
    else
      throw new Error("invalid type");
  return t;
}
function nY(t) {
  return t = ap(t), "0x" + t.toString("hex");
}
function iY(t, e) {
  if (t = ap(t), e || (e = 256), e !== 256)
    throw new Error("unsupported");
  return Buffer.from(QG(new Uint8Array(t)));
}
function sY(t) {
  return t.length % 2 ? "0" + t : t;
}
function qE(t) {
  return typeof t == "string" && t.match(/^0x[0-9A-Fa-f]*$/);
}
function zE(t) {
  return typeof t == "string" && t.startsWith("0x") ? t.slice(2) : t;
}
var HE = {
  zeros: BE,
  setLength: jE,
  setLengthRight: rY,
  isHexString: qE,
  stripHexPrefix: zE,
  toBuffer: ap,
  bufferToHex: nY,
  keccak: iY,
  bitLengthFromBigInt: eY,
  bufferBEFromBigInt: UE,
  twosFromBigInt: tY
};
const ii = HE;
function WE(t) {
  return t.startsWith("int[") ? "int256" + t.slice(3) : t === "int" ? "int256" : t.startsWith("uint[") ? "uint256" + t.slice(4) : t === "uint" ? "uint256" : t.startsWith("fixed[") ? "fixed128x128" + t.slice(5) : t === "fixed" ? "fixed128x128" : t.startsWith("ufixed[") ? "ufixed128x128" + t.slice(6) : t === "ufixed" ? "ufixed128x128" : t;
}
function du(t) {
  return Number.parseInt(/^\D+(\d+)$/.exec(t)[1], 10);
}
function o_(t) {
  var e = /^\D+(\d+)x(\d+)$/.exec(t);
  return [Number.parseInt(e[1], 10), Number.parseInt(e[2], 10)];
}
function KE(t) {
  var e = t.match(/(.*)\[(.*?)\]$/);
  return e ? e[2] === "" ? "dynamic" : Number.parseInt(e[2], 10) : null;
}
function Qa(t) {
  var e = typeof t;
  if (e === "string" || e === "number")
    return BigInt(t);
  if (e === "bigint")
    return t;
  throw new Error("Argument is not a number");
}
function js(t, e) {
  var r, n, i, s;
  if (t === "address")
    return js("uint160", Qa(e));
  if (t === "bool")
    return js("uint8", e ? 1 : 0);
  if (t === "string")
    return js("bytes", new Buffer(e, "utf8"));
  if (aY(t)) {
    if (typeof e.length > "u")
      throw new Error("Not an array?");
    if (r = KE(t), r !== "dynamic" && r !== 0 && e.length > r)
      throw new Error("Elements exceed array size: " + r);
    i = [], t = t.slice(0, t.lastIndexOf("[")), typeof e == "string" && (e = JSON.parse(e));
    for (s in e)
      i.push(js(t, e[s]));
    if (r === "dynamic") {
      var o = js("uint256", e.length);
      i.unshift(o);
    }
    return Buffer.concat(i);
  } else {
    if (t === "bytes")
      return e = new Buffer(e), i = Buffer.concat([js("uint256", e.length), e]), e.length % 32 !== 0 && (i = Buffer.concat([i, ii.zeros(32 - e.length % 32)])), i;
    if (t.startsWith("bytes")) {
      if (r = du(t), r < 1 || r > 32)
        throw new Error("Invalid bytes<N> width: " + r);
      return ii.setLengthRight(e, 32);
    } else if (t.startsWith("uint")) {
      if (r = du(t), r % 8 || r < 8 || r > 256)
        throw new Error("Invalid uint<N> width: " + r);
      n = Qa(e);
      const a = ii.bitLengthFromBigInt(n);
      if (a > r)
        throw new Error("Supplied uint exceeds width: " + r + " vs " + a);
      if (n < 0)
        throw new Error("Supplied uint is negative");
      return ii.bufferBEFromBigInt(n, 32);
    } else if (t.startsWith("int")) {
      if (r = du(t), r % 8 || r < 8 || r > 256)
        throw new Error("Invalid int<N> width: " + r);
      n = Qa(e);
      const a = ii.bitLengthFromBigInt(n);
      if (a > r)
        throw new Error("Supplied int exceeds width: " + r + " vs " + a);
      const u = ii.twosFromBigInt(n, 256);
      return ii.bufferBEFromBigInt(u, 32);
    } else if (t.startsWith("ufixed")) {
      if (r = o_(t), n = Qa(e), n < 0)
        throw new Error("Supplied ufixed is negative");
      return js("uint256", n * BigInt(2) ** BigInt(r[1]));
    } else if (t.startsWith("fixed"))
      return r = o_(t), js("int256", Qa(e) * BigInt(2) ** BigInt(r[1]));
  }
  throw new Error("Unsupported or invalid type: " + t);
}
function oY(t) {
  return t === "string" || t === "bytes" || KE(t) === "dynamic";
}
function aY(t) {
  return t.lastIndexOf("]") === t.length - 1;
}
function cY(t, e) {
  var r = [], n = [], i = 32 * t.length;
  for (var s in t) {
    var o = WE(t[s]), a = e[s], u = js(o, a);
    oY(o) ? (r.push(js("uint256", i)), n.push(u), i += u.length) : r.push(u);
  }
  return Buffer.concat(r.concat(n));
}
function VE(t, e) {
  if (t.length !== e.length)
    throw new Error("Number of types are not matching the values");
  for (var r, n, i = [], s = 0; s < t.length; s++) {
    var o = WE(t[s]), a = e[s];
    if (o === "bytes")
      i.push(a);
    else if (o === "string")
      i.push(new Buffer(a, "utf8"));
    else if (o === "bool")
      i.push(new Buffer(a ? "01" : "00", "hex"));
    else if (o === "address")
      i.push(ii.setLength(a, 20));
    else if (o.startsWith("bytes")) {
      if (r = du(o), r < 1 || r > 32)
        throw new Error("Invalid bytes<N> width: " + r);
      i.push(ii.setLengthRight(a, r));
    } else if (o.startsWith("uint")) {
      if (r = du(o), r % 8 || r < 8 || r > 256)
        throw new Error("Invalid uint<N> width: " + r);
      n = Qa(a);
      const u = ii.bitLengthFromBigInt(n);
      if (u > r)
        throw new Error("Supplied uint exceeds width: " + r + " vs " + u);
      i.push(ii.bufferBEFromBigInt(n, r / 8));
    } else if (o.startsWith("int")) {
      if (r = du(o), r % 8 || r < 8 || r > 256)
        throw new Error("Invalid int<N> width: " + r);
      n = Qa(a);
      const u = ii.bitLengthFromBigInt(n);
      if (u > r)
        throw new Error("Supplied int exceeds width: " + r + " vs " + u);
      const l = ii.twosFromBigInt(n, r);
      i.push(ii.bufferBEFromBigInt(l, r / 8));
    } else
      throw new Error("Unsupported or invalid type: " + o);
  }
  return Buffer.concat(i);
}
function uY(t, e) {
  return ii.keccak(VE(t, e));
}
var fY = {
  rawEncode: cY,
  solidityPack: VE,
  soliditySHA3: uY
};
const bs = HE, Kf = fY, GE = {
  type: "object",
  properties: {
    types: {
      type: "object",
      additionalProperties: {
        type: "array",
        items: {
          type: "object",
          properties: {
            name: { type: "string" },
            type: { type: "string" }
          },
          required: ["name", "type"]
        }
      }
    },
    primaryType: { type: "string" },
    domain: { type: "object" },
    message: { type: "object" }
  },
  required: ["types", "primaryType", "domain", "message"]
}, Pm = {
  /**
   * Encodes an object by encoding and concatenating each of its members
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of an object
   */
  encodeData(t, e, r, n = !0) {
    const i = ["bytes32"], s = [this.hashType(t, r)];
    if (n) {
      const o = (a, u, l) => {
        if (r[u] !== void 0)
          return ["bytes32", l == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : bs.keccak(this.encodeData(u, l, r, n))];
        if (l === void 0)
          throw new Error(`missing value for field ${a} of type ${u}`);
        if (u === "bytes")
          return ["bytes32", bs.keccak(l)];
        if (u === "string")
          return typeof l == "string" && (l = Buffer.from(l, "utf8")), ["bytes32", bs.keccak(l)];
        if (u.lastIndexOf("]") === u.length - 1) {
          const d = u.slice(0, u.lastIndexOf("[")), p = l.map((w) => o(a, d, w));
          return ["bytes32", bs.keccak(Kf.rawEncode(
            p.map(([w]) => w),
            p.map(([, w]) => w)
          ))];
        }
        return [u, l];
      };
      for (const a of r[t]) {
        const [u, l] = o(a.name, a.type, e[a.name]);
        i.push(u), s.push(l);
      }
    } else
      for (const o of r[t]) {
        let a = e[o.name];
        if (a !== void 0)
          if (o.type === "bytes")
            i.push("bytes32"), a = bs.keccak(a), s.push(a);
          else if (o.type === "string")
            i.push("bytes32"), typeof a == "string" && (a = Buffer.from(a, "utf8")), a = bs.keccak(a), s.push(a);
          else if (r[o.type] !== void 0)
            i.push("bytes32"), a = bs.keccak(this.encodeData(o.type, a, r, n)), s.push(a);
          else {
            if (o.type.lastIndexOf("]") === o.type.length - 1)
              throw new Error("Arrays currently unimplemented in encodeData");
            i.push(o.type), s.push(a);
          }
      }
    return Kf.rawEncode(i, s);
  },
  /**
   * Encodes the type of an object by encoding a comma delimited list of its members
   *
   * @param {string} primaryType - Root type to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of the type of an object
   */
  encodeType(t, e) {
    let r = "", n = this.findTypeDependencies(t, e).filter((i) => i !== t);
    n = [t].concat(n.sort());
    for (const i of n) {
      if (!e[i])
        throw new Error("No type definition specified: " + i);
      r += i + "(" + e[i].map(({ name: o, type: a }) => a + " " + o).join(",") + ")";
    }
    return r;
  },
  /**
   * Finds all types within a type definition object
   *
   * @param {string} primaryType - Root type
   * @param {Object} types - Type definitions
   * @param {Array} results - current set of accumulated types
   * @returns {Array} - Set of all types found in the type definition
   */
  findTypeDependencies(t, e, r = []) {
    if (t = t.match(/^\w*/)[0], r.includes(t) || e[t] === void 0)
      return r;
    r.push(t);
    for (const n of e[t])
      for (const i of this.findTypeDependencies(n.type, e, r))
        !r.includes(i) && r.push(i);
    return r;
  },
  /**
   * Hashes an object
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to hash
   * @param {Object} types - Type definitions
   * @returns {Buffer} - Hash of an object
   */
  hashStruct(t, e, r, n = !0) {
    return bs.keccak(this.encodeData(t, e, r, n));
  },
  /**
   * Hashes the type of an object
   *
   * @param {string} primaryType - Root type to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashType(t, e) {
    return bs.keccak(this.encodeType(t, e));
  },
  /**
   * Removes properties from a message object that are not defined per EIP-712
   *
   * @param {Object} data - typed message object
   * @returns {Object} - typed message object with only allowed fields
   */
  sanitizeData(t) {
    const e = {};
    for (const r in GE.properties)
      t[r] && (e[r] = t[r]);
    return e.types && (e.types = Object.assign({ EIP712Domain: [] }, e.types)), e;
  },
  /**
   * Returns the hash of a typed message as per EIP-712 for signing
   *
   * @param {Object} typedData - Types message data to sign
   * @returns {string} - sha3 hash for signing
   */
  hash(t, e = !0) {
    const r = this.sanitizeData(t), n = [Buffer.from("1901", "hex")];
    return n.push(this.hashStruct("EIP712Domain", r.domain, r.types, e)), r.primaryType !== "EIP712Domain" && n.push(this.hashStruct(r.primaryType, r.message, r.types, e)), bs.keccak(Buffer.concat(n));
  }
};
var lY = {
  TYPED_MESSAGE_SCHEMA: GE,
  TypedDataUtils: Pm,
  hashForSignTypedDataLegacy: function(t) {
    return hY(t.data);
  },
  hashForSignTypedData_v3: function(t) {
    return Pm.hash(t.data, !1);
  },
  hashForSignTypedData_v4: function(t) {
    return Pm.hash(t.data);
  }
};
function hY(t) {
  const e = new Error("Expect argument to be non-empty array");
  if (typeof t != "object" || !t.length) throw e;
  const r = t.map(function(s) {
    return s.type === "bytes" ? bs.toBuffer(s.value) : s.value;
  }), n = t.map(function(s) {
    return s.type;
  }), i = t.map(function(s) {
    if (!s.name) throw e;
    return s.type + " " + s.name;
  });
  return Kf.soliditySHA3(
    ["bytes32", "bytes32"],
    [
      Kf.soliditySHA3(new Array(t.length).fill("string"), i),
      Kf.soliditySHA3(n, r)
    ]
  );
}
const hd = /* @__PURE__ */ ts(lY), dY = "walletUsername", $1 = "Addresses", pY = "AppVersion";
function Bn(t) {
  return t.errorMessage !== void 0;
}
class gY {
  // @param secret hex representation of 32-byte secret
  constructor(e) {
    this.secret = e;
  }
  /**
   *
   * @param plainText string to be encrypted
   * returns hex string representation of bytes in the order: initialization vector (iv),
   * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the
   * encrypted plainText.
   */
  async encrypt(e) {
    const r = this.secret;
    if (r.length !== 64)
      throw Error("secret must be 256 bits");
    const n = crypto.getRandomValues(new Uint8Array(12)), i = await crypto.subtle.importKey("raw", Rd(r), { name: "aes-gcm" }, !1, ["encrypt", "decrypt"]), s = new TextEncoder(), o = await window.crypto.subtle.encrypt({
      name: "AES-GCM",
      iv: n
    }, i, s.encode(e)), a = 16, u = o.slice(o.byteLength - a), l = o.slice(0, o.byteLength - a), d = new Uint8Array(u), p = new Uint8Array(l), w = new Uint8Array([...n, ...d, ...p]);
    return gb(w);
  }
  /**
   *
   * @param cipherText hex string representation of bytes in the order: initialization vector (iv),
   * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.
   */
  async decrypt(e) {
    const r = this.secret;
    if (r.length !== 64)
      throw Error("secret must be 256 bits");
    return new Promise((n, i) => {
      (async function() {
        const s = await crypto.subtle.importKey("raw", Rd(r), { name: "aes-gcm" }, !1, ["encrypt", "decrypt"]), o = Rd(e), a = o.slice(0, 12), u = o.slice(12, 28), l = o.slice(28), d = new Uint8Array([...l, ...u]), p = {
          name: "AES-GCM",
          iv: new Uint8Array(a)
        };
        try {
          const w = await window.crypto.subtle.decrypt(p, s, d), P = new TextDecoder();
          n(P.decode(w));
        } catch (w) {
          i(w);
        }
      })();
    });
  }
}
class mY {
  constructor(e, r, n) {
    this.linkAPIUrl = e, this.sessionId = r;
    const i = `${r}:${n}`;
    this.auth = `Basic ${btoa(i)}`;
  }
  // mark unseen events as seen
  async markUnseenEventsAsSeen(e) {
    return Promise.all(e.map((r) => fetch(`${this.linkAPIUrl}/events/${r.eventId}/seen`, {
      method: "POST",
      headers: {
        Authorization: this.auth
      }
    }))).catch((r) => console.error("Unabled to mark event as failed:", r));
  }
  async fetchUnseenEvents() {
    var e;
    const r = await fetch(`${this.linkAPIUrl}/events?unseen=true`, {
      headers: {
        Authorization: this.auth
      }
    });
    if (r.ok) {
      const { events: n, error: i } = await r.json();
      if (i)
        throw new Error(`Check unseen events failed: ${i}`);
      const s = (e = n == null ? void 0 : n.filter((o) => o.event === "Web3Response").map((o) => ({
        type: "Event",
        sessionId: this.sessionId,
        eventId: o.id,
        event: o.event,
        data: o.data
      }))) !== null && e !== void 0 ? e : [];
      return this.markUnseenEventsAsSeen(s), s;
    }
    throw new Error(`Check unseen events failed: ${r.status}`);
  }
}
var Ao;
(function(t) {
  t[t.DISCONNECTED = 0] = "DISCONNECTED", t[t.CONNECTING = 1] = "CONNECTING", t[t.CONNECTED = 2] = "CONNECTED";
})(Ao || (Ao = {}));
class vY {
  setConnectionStateListener(e) {
    this.connectionStateListener = e;
  }
  setIncomingDataListener(e) {
    this.incomingDataListener = e;
  }
  /**
   * Constructor
   * @param url WebSocket server URL
   * @param [WebSocketClass] Custom WebSocket implementation
   */
  constructor(e, r = WebSocket) {
    this.WebSocketClass = r, this.webSocket = null, this.pendingData = [], this.url = e.replace(/^http/, "ws");
  }
  /**
   * Make a websocket connection
   * @returns a Promise that resolves when connected
   */
  async connect() {
    if (this.webSocket)
      throw new Error("webSocket object is not null");
    return new Promise((e, r) => {
      var n;
      let i;
      try {
        this.webSocket = i = new this.WebSocketClass(this.url);
      } catch (s) {
        r(s);
        return;
      }
      (n = this.connectionStateListener) === null || n === void 0 || n.call(this, Ao.CONNECTING), i.onclose = (s) => {
        var o;
        this.clearWebSocket(), r(new Error(`websocket error ${s.code}: ${s.reason}`)), (o = this.connectionStateListener) === null || o === void 0 || o.call(this, Ao.DISCONNECTED);
      }, i.onopen = (s) => {
        var o;
        e(), (o = this.connectionStateListener) === null || o === void 0 || o.call(this, Ao.CONNECTED), this.pendingData.length > 0 && ([...this.pendingData].forEach((u) => this.sendData(u)), this.pendingData = []);
      }, i.onmessage = (s) => {
        var o, a;
        if (s.data === "h")
          (o = this.incomingDataListener) === null || o === void 0 || o.call(this, {
            type: "Heartbeat"
          });
        else
          try {
            const u = JSON.parse(s.data);
            (a = this.incomingDataListener) === null || a === void 0 || a.call(this, u);
          } catch {
          }
      };
    });
  }
  /**
   * Disconnect from server
   */
  disconnect() {
    var e;
    const { webSocket: r } = this;
    if (r) {
      this.clearWebSocket(), (e = this.connectionStateListener) === null || e === void 0 || e.call(this, Ao.DISCONNECTED), this.connectionStateListener = void 0, this.incomingDataListener = void 0;
      try {
        r.close();
      } catch {
      }
    }
  }
  /**
   * Send data to server
   * @param data text to send
   */
  sendData(e) {
    const { webSocket: r } = this;
    if (!r) {
      this.pendingData.push(e), this.connect();
      return;
    }
    r.send(e);
  }
  clearWebSocket() {
    const { webSocket: e } = this;
    e && (this.webSocket = null, e.onclose = null, e.onerror = null, e.onmessage = null, e.onopen = null);
  }
}
const a_ = 1e4, bY = 6e4;
class yY {
  /**
   * Constructor
   * @param session Session
   * @param linkAPIUrl Coinbase Wallet link server URL
   * @param listener WalletLinkConnectionUpdateListener
   * @param [WebSocketClass] Custom WebSocket implementation
   */
  constructor({ session: e, linkAPIUrl: r, listener: n }) {
    this.destroyed = !1, this.lastHeartbeatResponse = 0, this.nextReqId = xo(1), this._connected = !1, this._linked = !1, this.shouldFetchUnseenEventsOnConnect = !1, this.requestResolutions = /* @__PURE__ */ new Map(), this.handleSessionMetadataUpdated = (s) => {
      if (!s)
        return;
      (/* @__PURE__ */ new Map([
        ["__destroyed", this.handleDestroyed],
        ["EthereumAddress", this.handleAccountUpdated],
        ["WalletUsername", this.handleWalletUsernameUpdated],
        ["AppVersion", this.handleAppVersionUpdated],
        [
          "ChainId",
          // ChainId and JsonRpcUrl are always updated together
          (a) => s.JsonRpcUrl && this.handleChainUpdated(a, s.JsonRpcUrl)
        ]
      ])).forEach((a, u) => {
        const l = s[u];
        l !== void 0 && a(l);
      });
    }, this.handleDestroyed = (s) => {
      var o;
      s === "1" && ((o = this.listener) === null || o === void 0 || o.resetAndReload());
    }, this.handleAccountUpdated = async (s) => {
      var o;
      const a = await this.cipher.decrypt(s);
      (o = this.listener) === null || o === void 0 || o.accountUpdated(a);
    }, this.handleMetadataUpdated = async (s, o) => {
      var a;
      const u = await this.cipher.decrypt(o);
      (a = this.listener) === null || a === void 0 || a.metadataUpdated(s, u);
    }, this.handleWalletUsernameUpdated = async (s) => {
      this.handleMetadataUpdated(dY, s);
    }, this.handleAppVersionUpdated = async (s) => {
      this.handleMetadataUpdated(pY, s);
    }, this.handleChainUpdated = async (s, o) => {
      var a;
      const u = await this.cipher.decrypt(s), l = await this.cipher.decrypt(o);
      (a = this.listener) === null || a === void 0 || a.chainUpdated(u, l);
    }, this.session = e, this.cipher = new gY(e.secret), this.listener = n;
    const i = new vY(`${r}/rpc`, WebSocket);
    i.setConnectionStateListener(async (s) => {
      let o = !1;
      switch (s) {
        case Ao.DISCONNECTED:
          if (!this.destroyed) {
            const a = async () => {
              await new Promise((u) => setTimeout(u, 5e3)), this.destroyed || i.connect().catch(() => {
                a();
              });
            };
            a();
          }
          break;
        case Ao.CONNECTED:
          o = await this.handleConnected(), this.updateLastHeartbeat(), setInterval(() => {
            this.heartbeat();
          }, a_), this.shouldFetchUnseenEventsOnConnect && this.fetchUnseenEventsAPI();
          break;
        case Ao.CONNECTING:
          break;
      }
      this.connected !== o && (this.connected = o);
    }), i.setIncomingDataListener((s) => {
      var o;
      switch (s.type) {
        case "Heartbeat":
          this.updateLastHeartbeat();
          return;
        case "IsLinkedOK":
        case "Linked": {
          const a = s.type === "IsLinkedOK" ? s.linked : void 0;
          this.linked = a || s.onlineGuests > 0;
          break;
        }
        case "GetSessionConfigOK":
        case "SessionConfigUpdated": {
          this.handleSessionMetadataUpdated(s.metadata);
          break;
        }
        case "Event": {
          this.handleIncomingEvent(s);
          break;
        }
      }
      s.id !== void 0 && ((o = this.requestResolutions.get(s.id)) === null || o === void 0 || o(s));
    }), this.ws = i, this.http = new mY(r, e.id, e.key);
  }
  /**
   * Make a connection to the server
   */
  connect() {
    if (this.destroyed)
      throw new Error("instance is destroyed");
    this.ws.connect();
  }
  /**
   * Terminate connection, and mark as destroyed. To reconnect, create a new
   * instance of WalletSDKConnection
   */
  async destroy() {
    this.destroyed || (await this.makeRequest({
      type: "SetSessionConfig",
      id: xo(this.nextReqId++),
      sessionId: this.session.id,
      metadata: { __destroyed: "1" }
    }, { timeout: 1e3 }), this.destroyed = !0, this.ws.disconnect(), this.listener = void 0);
  }
  get connected() {
    return this._connected;
  }
  set connected(e) {
    this._connected = e;
  }
  get linked() {
    return this._linked;
  }
  set linked(e) {
    var r, n;
    this._linked = e, e && ((r = this.onceLinked) === null || r === void 0 || r.call(this)), (n = this.listener) === null || n === void 0 || n.linkedUpdated(e);
  }
  setOnceLinked(e) {
    return new Promise((r) => {
      this.linked ? e().then(r) : this.onceLinked = () => {
        e().then(r), this.onceLinked = void 0;
      };
    });
  }
  async handleIncomingEvent(e) {
    var r;
    if (e.type !== "Event" || e.event !== "Web3Response")
      return;
    const n = await this.cipher.decrypt(e.data), i = JSON.parse(n);
    if (i.type !== "WEB3_RESPONSE")
      return;
    const { id: s, response: o } = i;
    (r = this.listener) === null || r === void 0 || r.handleWeb3ResponseMessage(s, o);
  }
  async checkUnseenEvents() {
    if (!this.connected) {
      this.shouldFetchUnseenEventsOnConnect = !0;
      return;
    }
    await new Promise((e) => setTimeout(e, 250));
    try {
      await this.fetchUnseenEventsAPI();
    } catch (e) {
      console.error("Unable to check for unseen events", e);
    }
  }
  async fetchUnseenEventsAPI() {
    this.shouldFetchUnseenEventsOnConnect = !1, (await this.http.fetchUnseenEvents()).forEach((r) => this.handleIncomingEvent(r));
  }
  /**
   * Publish an event and emit event ID when successful
   * @param event event name
   * @param unencryptedData unencrypted event data
   * @param callWebhook whether the webhook should be invoked
   * @returns a Promise that emits event ID when successful
   */
  async publishEvent(e, r, n = !1) {
    const i = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, r), { origin: location.origin, location: location.href, relaySource: "coinbaseWalletExtension" in window && window.coinbaseWalletExtension ? "injected_sdk" : "sdk" }))), s = {
      type: "PublishEvent",
      id: xo(this.nextReqId++),
      sessionId: this.session.id,
      event: e,
      data: i,
      callWebhook: n
    };
    return this.setOnceLinked(async () => {
      const o = await this.makeRequest(s);
      if (o.type === "Fail")
        throw new Error(o.error || "failed to publish event");
      return o.eventId;
    });
  }
  sendData(e) {
    this.ws.sendData(JSON.stringify(e));
  }
  updateLastHeartbeat() {
    this.lastHeartbeatResponse = Date.now();
  }
  heartbeat() {
    if (Date.now() - this.lastHeartbeatResponse > a_ * 2) {
      this.ws.disconnect();
      return;
    }
    try {
      this.ws.sendData("h");
    } catch {
    }
  }
  async makeRequest(e, r = { timeout: bY }) {
    const n = e.id;
    this.sendData(e);
    let i;
    return Promise.race([
      new Promise((s, o) => {
        i = window.setTimeout(() => {
          o(new Error(`request ${n} timed out`));
        }, r.timeout);
      }),
      new Promise((s) => {
        this.requestResolutions.set(n, (o) => {
          clearTimeout(i), s(o), this.requestResolutions.delete(n);
        });
      })
    ]);
  }
  async handleConnected() {
    return (await this.makeRequest({
      type: "HostSession",
      id: xo(this.nextReqId++),
      sessionId: this.session.id,
      sessionKey: this.session.key
    })).type === "Fail" ? !1 : (this.sendData({
      type: "IsLinked",
      id: xo(this.nextReqId++),
      sessionId: this.session.id
    }), this.sendData({
      type: "GetSessionConfig",
      id: xo(this.nextReqId++),
      sessionId: this.session.id
    }), !0);
  }
}
class wY {
  constructor() {
    this._nextRequestId = 0, this.callbacks = /* @__PURE__ */ new Map();
  }
  makeRequestId() {
    this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
    const e = this._nextRequestId, r = OE(e.toString(16));
    return this.callbacks.get(r) && this.callbacks.delete(r), e;
  }
}
const c_ = "session:id", u_ = "session:secret", f_ = "session:linked";
class pu {
  constructor(e, r, n, i = !1) {
    this.storage = e, this.id = r, this.secret = n, this.key = lD(r4(`${r}, ${n} WalletLink`)), this._linked = !!i;
  }
  static create(e) {
    const r = Za(16), n = Za(32);
    return new pu(e, r, n).save();
  }
  static load(e) {
    const r = e.getItem(c_), n = e.getItem(f_), i = e.getItem(u_);
    return r && i ? new pu(e, r, i, n === "1") : null;
  }
  get linked() {
    return this._linked;
  }
  set linked(e) {
    this._linked = e, this.persistLinked();
  }
  save() {
    return this.storage.setItem(c_, this.id), this.storage.setItem(u_, this.secret), this.persistLinked(), this;
  }
  persistLinked() {
    this.storage.setItem(f_, this._linked ? "1" : "0");
  }
}
function xY() {
  try {
    return window.frameElement !== null;
  } catch {
    return !1;
  }
}
function _Y() {
  try {
    return xY() && window.top ? window.top.location : window.location;
  } catch {
    return window.location;
  }
}
function EY() {
  var t;
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test((t = window == null ? void 0 : window.navigator) === null || t === void 0 ? void 0 : t.userAgent);
}
function YE() {
  var t, e;
  return (e = (t = window == null ? void 0 : window.matchMedia) === null || t === void 0 ? void 0 : t.call(window, "(prefers-color-scheme: dark)").matches) !== null && e !== void 0 ? e : !1;
}
const SY = '@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}';
function JE() {
  const t = document.createElement("style");
  t.type = "text/css", t.appendChild(document.createTextNode(SY)), document.documentElement.appendChild(t);
}
function XE(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number") n += t;
  else if (typeof t == "object") if (Array.isArray(t)) for (e = 0; e < t.length; e++) t[e] && (r = XE(t[e])) && (n && (n += " "), n += r);
  else for (e in t) t[e] && (n && (n += " "), n += e);
  return n;
}
function Vf() {
  for (var t, e, r = 0, n = ""; r < arguments.length; ) (t = arguments[r++]) && (e = XE(t)) && (n && (n += " "), n += e);
  return n;
}
var cp, Jr, ZE, ec, l_, QE, F1, eS, bb, B1, U1, Al = {}, tS = [], AY = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, yb = Array.isArray;
function pa(t, e) {
  for (var r in e) t[r] = e[r];
  return t;
}
function wb(t) {
  t && t.parentNode && t.parentNode.removeChild(t);
}
function Nr(t, e, r) {
  var n, i, s, o = {};
  for (s in e) s == "key" ? n = e[s] : s == "ref" ? i = e[s] : o[s] = e[s];
  if (arguments.length > 2 && (o.children = arguments.length > 3 ? cp.call(arguments, 2) : r), typeof t == "function" && t.defaultProps != null) for (s in t.defaultProps) o[s] === void 0 && (o[s] = t.defaultProps[s]);
  return Dd(t, o, n, i, null);
}
function Dd(t, e, r, n, i) {
  var s = { type: t, props: e, key: r, ref: n, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: i ?? ++ZE, __i: -1, __u: 0 };
  return i == null && Jr.vnode != null && Jr.vnode(s), s;
}
function nh(t) {
  return t.children;
}
function Od(t, e) {
  this.props = t, this.context = e;
}
function Au(t, e) {
  if (e == null) return t.__ ? Au(t.__, t.__i + 1) : null;
  for (var r; e < t.__k.length; e++) if ((r = t.__k[e]) != null && r.__e != null) return r.__e;
  return typeof t.type == "function" ? Au(t) : null;
}
function rS(t) {
  var e, r;
  if ((t = t.__) != null && t.__c != null) {
    for (t.__e = t.__c.base = null, e = 0; e < t.__k.length; e++) if ((r = t.__k[e]) != null && r.__e != null) {
      t.__e = t.__c.base = r.__e;
      break;
    }
    return rS(t);
  }
}
function h_(t) {
  (!t.__d && (t.__d = !0) && ec.push(t) && !h0.__r++ || l_ !== Jr.debounceRendering) && ((l_ = Jr.debounceRendering) || QE)(h0);
}
function h0() {
  var t, e, r, n, i, s, o, a;
  for (ec.sort(F1); t = ec.shift(); ) t.__d && (e = ec.length, n = void 0, s = (i = (r = t).__v).__e, o = [], a = [], r.__P && ((n = pa({}, i)).__v = i.__v + 1, Jr.vnode && Jr.vnode(n), xb(r.__P, n, i, r.__n, r.__P.namespaceURI, 32 & i.__u ? [s] : null, o, s ?? Au(i), !!(32 & i.__u), a), n.__v = i.__v, n.__.__k[n.__i] = n, sS(o, n, a), n.__e != s && rS(n)), ec.length > e && ec.sort(F1));
  h0.__r = 0;
}
function nS(t, e, r, n, i, s, o, a, u, l, d) {
  var p, w, P, A, N, L, F = n && n.__k || tS, $ = e.length;
  for (u = PY(r, e, F, u), p = 0; p < $; p++) (P = r.__k[p]) != null && (w = P.__i === -1 ? Al : F[P.__i] || Al, P.__i = p, L = xb(t, P, w, i, s, o, a, u, l, d), A = P.__e, P.ref && w.ref != P.ref && (w.ref && _b(w.ref, null, P), d.push(P.ref, P.__c || A, P)), N == null && A != null && (N = A), 4 & P.__u || w.__k === P.__k ? u = iS(P, u, t) : typeof P.type == "function" && L !== void 0 ? u = L : A && (u = A.nextSibling), P.__u &= -7);
  return r.__e = N, u;
}
function PY(t, e, r, n) {
  var i, s, o, a, u, l = e.length, d = r.length, p = d, w = 0;
  for (t.__k = [], i = 0; i < l; i++) (s = e[i]) != null && typeof s != "boolean" && typeof s != "function" ? (a = i + w, (s = t.__k[i] = typeof s == "string" || typeof s == "number" || typeof s == "bigint" || s.constructor == String ? Dd(null, s, null, null, null) : yb(s) ? Dd(nh, { children: s }, null, null, null) : s.constructor === void 0 && s.__b > 0 ? Dd(s.type, s.props, s.key, s.ref ? s.ref : null, s.__v) : s).__ = t, s.__b = t.__b + 1, o = null, (u = s.__i = MY(s, r, a, p)) !== -1 && (p--, (o = r[u]) && (o.__u |= 2)), o == null || o.__v === null ? (u == -1 && w--, typeof s.type != "function" && (s.__u |= 4)) : u !== a && (u == a - 1 ? w-- : u == a + 1 ? w++ : (u > a ? w-- : w++, s.__u |= 4))) : s = t.__k[i] = null;
  if (p) for (i = 0; i < d; i++) (o = r[i]) != null && !(2 & o.__u) && (o.__e == n && (n = Au(o)), oS(o, o));
  return n;
}
function iS(t, e, r) {
  var n, i;
  if (typeof t.type == "function") {
    for (n = t.__k, i = 0; n && i < n.length; i++) n[i] && (n[i].__ = t, e = iS(n[i], e, r));
    return e;
  }
  t.__e != e && (e && t.type && !r.contains(e) && (e = Au(t)), r.insertBefore(t.__e, e || null), e = t.__e);
  do
    e = e && e.nextSibling;
  while (e != null && e.nodeType === 8);
  return e;
}
function MY(t, e, r, n) {
  var i = t.key, s = t.type, o = r - 1, a = r + 1, u = e[r];
  if (u === null || u && i == u.key && s === u.type && !(2 & u.__u)) return r;
  if ((typeof s != "function" || s === nh || i) && n > (u != null && !(2 & u.__u) ? 1 : 0)) for (; o >= 0 || a < e.length; ) {
    if (o >= 0) {
      if ((u = e[o]) && !(2 & u.__u) && i == u.key && s === u.type) return o;
      o--;
    }
    if (a < e.length) {
      if ((u = e[a]) && !(2 & u.__u) && i == u.key && s === u.type) return a;
      a++;
    }
  }
  return -1;
}
function d_(t, e, r) {
  e[0] === "-" ? t.setProperty(e, r ?? "") : t[e] = r == null ? "" : typeof r != "number" || AY.test(e) ? r : r + "px";
}
function dd(t, e, r, n, i) {
  var s;
  e: if (e === "style") if (typeof r == "string") t.style.cssText = r;
  else {
    if (typeof n == "string" && (t.style.cssText = n = ""), n) for (e in n) r && e in r || d_(t.style, e, "");
    if (r) for (e in r) n && r[e] === n[e] || d_(t.style, e, r[e]);
  }
  else if (e[0] === "o" && e[1] === "n") s = e !== (e = e.replace(eS, "$1")), e = e.toLowerCase() in t || e === "onFocusOut" || e === "onFocusIn" ? e.toLowerCase().slice(2) : e.slice(2), t.l || (t.l = {}), t.l[e + s] = r, r ? n ? r.u = n.u : (r.u = bb, t.addEventListener(e, s ? U1 : B1, s)) : t.removeEventListener(e, s ? U1 : B1, s);
  else {
    if (i == "http://www.w3.org/2000/svg") e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if (e != "width" && e != "height" && e != "href" && e != "list" && e != "form" && e != "tabIndex" && e != "download" && e != "rowSpan" && e != "colSpan" && e != "role" && e != "popover" && e in t) try {
      t[e] = r ?? "";
      break e;
    } catch {
    }
    typeof r == "function" || (r == null || r === !1 && e[4] !== "-" ? t.removeAttribute(e) : t.setAttribute(e, e == "popover" && r == 1 ? "" : r));
  }
}
function p_(t) {
  return function(e) {
    if (this.l) {
      var r = this.l[e.type + t];
      if (e.t == null) e.t = bb++;
      else if (e.t < r.u) return;
      return r(Jr.event ? Jr.event(e) : e);
    }
  };
}
function xb(t, e, r, n, i, s, o, a, u, l) {
  var d, p, w, P, A, N, L, F, $, K, H, V, te, R, W, pe, Ee, Y = e.type;
  if (e.constructor !== void 0) return null;
  128 & r.__u && (u = !!(32 & r.__u), s = [a = e.__e = r.__e]), (d = Jr.__b) && d(e);
  e: if (typeof Y == "function") try {
    if (F = e.props, $ = "prototype" in Y && Y.prototype.render, K = (d = Y.contextType) && n[d.__c], H = d ? K ? K.props.value : d.__ : n, r.__c ? L = (p = e.__c = r.__c).__ = p.__E : ($ ? e.__c = p = new Y(F, H) : (e.__c = p = new Od(F, H), p.constructor = Y, p.render = CY), K && K.sub(p), p.props = F, p.state || (p.state = {}), p.context = H, p.__n = n, w = p.__d = !0, p.__h = [], p._sb = []), $ && p.__s == null && (p.__s = p.state), $ && Y.getDerivedStateFromProps != null && (p.__s == p.state && (p.__s = pa({}, p.__s)), pa(p.__s, Y.getDerivedStateFromProps(F, p.__s))), P = p.props, A = p.state, p.__v = e, w) $ && Y.getDerivedStateFromProps == null && p.componentWillMount != null && p.componentWillMount(), $ && p.componentDidMount != null && p.__h.push(p.componentDidMount);
    else {
      if ($ && Y.getDerivedStateFromProps == null && F !== P && p.componentWillReceiveProps != null && p.componentWillReceiveProps(F, H), !p.__e && (p.shouldComponentUpdate != null && p.shouldComponentUpdate(F, p.__s, H) === !1 || e.__v === r.__v)) {
        for (e.__v !== r.__v && (p.props = F, p.state = p.__s, p.__d = !1), e.__e = r.__e, e.__k = r.__k, e.__k.some(function(S) {
          S && (S.__ = e);
        }), V = 0; V < p._sb.length; V++) p.__h.push(p._sb[V]);
        p._sb = [], p.__h.length && o.push(p);
        break e;
      }
      p.componentWillUpdate != null && p.componentWillUpdate(F, p.__s, H), $ && p.componentDidUpdate != null && p.__h.push(function() {
        p.componentDidUpdate(P, A, N);
      });
    }
    if (p.context = H, p.props = F, p.__P = t, p.__e = !1, te = Jr.__r, R = 0, $) {
      for (p.state = p.__s, p.__d = !1, te && te(e), d = p.render(p.props, p.state, p.context), W = 0; W < p._sb.length; W++) p.__h.push(p._sb[W]);
      p._sb = [];
    } else do
      p.__d = !1, te && te(e), d = p.render(p.props, p.state, p.context), p.state = p.__s;
    while (p.__d && ++R < 25);
    p.state = p.__s, p.getChildContext != null && (n = pa(pa({}, n), p.getChildContext())), $ && !w && p.getSnapshotBeforeUpdate != null && (N = p.getSnapshotBeforeUpdate(P, A)), a = nS(t, yb(pe = d != null && d.type === nh && d.key == null ? d.props.children : d) ? pe : [pe], e, r, n, i, s, o, a, u, l), p.base = e.__e, e.__u &= -161, p.__h.length && o.push(p), L && (p.__E = p.__ = null);
  } catch (S) {
    if (e.__v = null, u || s != null) if (S.then) {
      for (e.__u |= u ? 160 : 128; a && a.nodeType === 8 && a.nextSibling; ) a = a.nextSibling;
      s[s.indexOf(a)] = null, e.__e = a;
    } else for (Ee = s.length; Ee--; ) wb(s[Ee]);
    else e.__e = r.__e, e.__k = r.__k;
    Jr.__e(S, e, r);
  }
  else s == null && e.__v === r.__v ? (e.__k = r.__k, e.__e = r.__e) : a = e.__e = IY(r.__e, e, r, n, i, s, o, u, l);
  return (d = Jr.diffed) && d(e), 128 & e.__u ? void 0 : a;
}
function sS(t, e, r) {
  for (var n = 0; n < r.length; n++) _b(r[n], r[++n], r[++n]);
  Jr.__c && Jr.__c(e, t), t.some(function(i) {
    try {
      t = i.__h, i.__h = [], t.some(function(s) {
        s.call(i);
      });
    } catch (s) {
      Jr.__e(s, i.__v);
    }
  });
}
function IY(t, e, r, n, i, s, o, a, u) {
  var l, d, p, w, P, A, N, L = r.props, F = e.props, $ = e.type;
  if ($ === "svg" ? i = "http://www.w3.org/2000/svg" : $ === "math" ? i = "http://www.w3.org/1998/Math/MathML" : i || (i = "http://www.w3.org/1999/xhtml"), s != null) {
    for (l = 0; l < s.length; l++) if ((P = s[l]) && "setAttribute" in P == !!$ && ($ ? P.localName === $ : P.nodeType === 3)) {
      t = P, s[l] = null;
      break;
    }
  }
  if (t == null) {
    if ($ === null) return document.createTextNode(F);
    t = document.createElementNS(i, $, F.is && F), a && (Jr.__m && Jr.__m(e, s), a = !1), s = null;
  }
  if ($ === null) L === F || a && t.data === F || (t.data = F);
  else {
    if (s = s && cp.call(t.childNodes), L = r.props || Al, !a && s != null) for (L = {}, l = 0; l < t.attributes.length; l++) L[(P = t.attributes[l]).name] = P.value;
    for (l in L) if (P = L[l], l != "children") {
      if (l == "dangerouslySetInnerHTML") p = P;
      else if (!(l in F)) {
        if (l == "value" && "defaultValue" in F || l == "checked" && "defaultChecked" in F) continue;
        dd(t, l, null, P, i);
      }
    }
    for (l in F) P = F[l], l == "children" ? w = P : l == "dangerouslySetInnerHTML" ? d = P : l == "value" ? A = P : l == "checked" ? N = P : a && typeof P != "function" || L[l] === P || dd(t, l, P, L[l], i);
    if (d) a || p && (d.__html === p.__html || d.__html === t.innerHTML) || (t.innerHTML = d.__html), e.__k = [];
    else if (p && (t.innerHTML = ""), nS(t, yb(w) ? w : [w], e, r, n, $ === "foreignObject" ? "http://www.w3.org/1999/xhtml" : i, s, o, s ? s[0] : r.__k && Au(r, 0), a, u), s != null) for (l = s.length; l--; ) wb(s[l]);
    a || (l = "value", $ === "progress" && A == null ? t.removeAttribute("value") : A !== void 0 && (A !== t[l] || $ === "progress" && !A || $ === "option" && A !== L[l]) && dd(t, l, A, L[l], i), l = "checked", N !== void 0 && N !== t[l] && dd(t, l, N, L[l], i));
  }
  return t;
}
function _b(t, e, r) {
  try {
    if (typeof t == "function") {
      var n = typeof t.__u == "function";
      n && t.__u(), n && e == null || (t.__u = t(e));
    } else t.current = e;
  } catch (i) {
    Jr.__e(i, r);
  }
}
function oS(t, e, r) {
  var n, i;
  if (Jr.unmount && Jr.unmount(t), (n = t.ref) && (n.current && n.current !== t.__e || _b(n, null, e)), (n = t.__c) != null) {
    if (n.componentWillUnmount) try {
      n.componentWillUnmount();
    } catch (s) {
      Jr.__e(s, e);
    }
    n.base = n.__P = null;
  }
  if (n = t.__k) for (i = 0; i < n.length; i++) n[i] && oS(n[i], e, r || typeof t.type != "function");
  r || wb(t.__e), t.__c = t.__ = t.__e = void 0;
}
function CY(t, e, r) {
  return this.constructor(t, r);
}
function j1(t, e, r) {
  var n, i, s, o;
  e === document && (e = document.documentElement), Jr.__ && Jr.__(t, e), i = (n = typeof r == "function") ? null : e.__k, s = [], o = [], xb(e, t = (!n && r || e).__k = Nr(nh, null, [t]), i || Al, Al, e.namespaceURI, !n && r ? [r] : i ? null : e.firstChild ? cp.call(e.childNodes) : null, s, !n && r ? r : i ? i.__e : e.firstChild, n, o), sS(s, t, o);
}
cp = tS.slice, Jr = { __e: function(t, e, r, n) {
  for (var i, s, o; e = e.__; ) if ((i = e.__c) && !i.__) try {
    if ((s = i.constructor) && s.getDerivedStateFromError != null && (i.setState(s.getDerivedStateFromError(t)), o = i.__d), i.componentDidCatch != null && (i.componentDidCatch(t, n || {}), o = i.__d), o) return i.__E = i;
  } catch (a) {
    t = a;
  }
  throw t;
} }, ZE = 0, Od.prototype.setState = function(t, e) {
  var r;
  r = this.__s != null && this.__s !== this.state ? this.__s : this.__s = pa({}, this.state), typeof t == "function" && (t = t(pa({}, r), this.props)), t && pa(r, t), t != null && this.__v && (e && this._sb.push(e), h_(this));
}, Od.prototype.forceUpdate = function(t) {
  this.__v && (this.__e = !0, t && this.__h.push(t), h_(this));
}, Od.prototype.render = nh, ec = [], QE = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, F1 = function(t, e) {
  return t.__v.__b - e.__v.__b;
}, h0.__r = 0, eS = /(PointerCapture)$|Capture$/i, bb = 0, B1 = p_(!1), U1 = p_(!0);
var d0, pn, Mm, g_, q1 = 0, aS = [], yn = Jr, m_ = yn.__b, v_ = yn.__r, b_ = yn.diffed, y_ = yn.__c, w_ = yn.unmount, x_ = yn.__;
function cS(t, e) {
  yn.__h && yn.__h(pn, t, q1 || e), q1 = 0;
  var r = pn.__H || (pn.__H = { __: [], __h: [] });
  return t >= r.__.length && r.__.push({}), r.__[t];
}
function __(t) {
  return q1 = 1, TY(uS, t);
}
function TY(t, e, r) {
  var n = cS(d0++, 2);
  if (n.t = t, !n.__c && (n.__ = [uS(void 0, e), function(a) {
    var u = n.__N ? n.__N[0] : n.__[0], l = n.t(u, a);
    u !== l && (n.__N = [l, n.__[1]], n.__c.setState({}));
  }], n.__c = pn, !pn.u)) {
    var i = function(a, u, l) {
      if (!n.__c.__H) return !0;
      var d = n.__c.__H.__.filter(function(w) {
        return !!w.__c;
      });
      if (d.every(function(w) {
        return !w.__N;
      })) return !s || s.call(this, a, u, l);
      var p = n.__c.props !== a;
      return d.forEach(function(w) {
        if (w.__N) {
          var P = w.__[0];
          w.__ = w.__N, w.__N = void 0, P !== w.__[0] && (p = !0);
        }
      }), s && s.call(this, a, u, l) || p;
    };
    pn.u = !0;
    var s = pn.shouldComponentUpdate, o = pn.componentWillUpdate;
    pn.componentWillUpdate = function(a, u, l) {
      if (this.__e) {
        var d = s;
        s = void 0, i(a, u, l), s = d;
      }
      o && o.call(this, a, u, l);
    }, pn.shouldComponentUpdate = i;
  }
  return n.__N || n.__;
}
function RY(t, e) {
  var r = cS(d0++, 3);
  !yn.__s && NY(r.__H, e) && (r.__ = t, r.i = e, pn.__H.__h.push(r));
}
function DY() {
  for (var t; t = aS.shift(); ) if (t.__P && t.__H) try {
    t.__H.__h.forEach(Nd), t.__H.__h.forEach(z1), t.__H.__h = [];
  } catch (e) {
    t.__H.__h = [], yn.__e(e, t.__v);
  }
}
yn.__b = function(t) {
  pn = null, m_ && m_(t);
}, yn.__ = function(t, e) {
  t && e.__k && e.__k.__m && (t.__m = e.__k.__m), x_ && x_(t, e);
}, yn.__r = function(t) {
  v_ && v_(t), d0 = 0;
  var e = (pn = t.__c).__H;
  e && (Mm === pn ? (e.__h = [], pn.__h = [], e.__.forEach(function(r) {
    r.__N && (r.__ = r.__N), r.i = r.__N = void 0;
  })) : (e.__h.forEach(Nd), e.__h.forEach(z1), e.__h = [], d0 = 0)), Mm = pn;
}, yn.diffed = function(t) {
  b_ && b_(t);
  var e = t.__c;
  e && e.__H && (e.__H.__h.length && (aS.push(e) !== 1 && g_ === yn.requestAnimationFrame || ((g_ = yn.requestAnimationFrame) || OY)(DY)), e.__H.__.forEach(function(r) {
    r.i && (r.__H = r.i), r.i = void 0;
  })), Mm = pn = null;
}, yn.__c = function(t, e) {
  e.some(function(r) {
    try {
      r.__h.forEach(Nd), r.__h = r.__h.filter(function(n) {
        return !n.__ || z1(n);
      });
    } catch (n) {
      e.some(function(i) {
        i.__h && (i.__h = []);
      }), e = [], yn.__e(n, r.__v);
    }
  }), y_ && y_(t, e);
}, yn.unmount = function(t) {
  w_ && w_(t);
  var e, r = t.__c;
  r && r.__H && (r.__H.__.forEach(function(n) {
    try {
      Nd(n);
    } catch (i) {
      e = i;
    }
  }), r.__H = void 0, e && yn.__e(e, r.__v));
};
var E_ = typeof requestAnimationFrame == "function";
function OY(t) {
  var e, r = function() {
    clearTimeout(n), E_ && cancelAnimationFrame(e), setTimeout(t);
  }, n = setTimeout(r, 100);
  E_ && (e = requestAnimationFrame(r));
}
function Nd(t) {
  var e = pn, r = t.__c;
  typeof r == "function" && (t.__c = void 0, r()), pn = e;
}
function z1(t) {
  var e = pn;
  t.__c = t.__(), pn = e;
}
function NY(t, e) {
  return !t || t.length !== e.length || e.some(function(r, n) {
    return r !== t[n];
  });
}
function uS(t, e) {
  return typeof e == "function" ? e(t) : e;
}
const LY = ".-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}", kY = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+", $Y = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=";
class FY {
  constructor() {
    this.items = /* @__PURE__ */ new Map(), this.nextItemKey = 0, this.root = null, this.darkMode = YE();
  }
  attach(e) {
    this.root = document.createElement("div"), this.root.className = "-cbwsdk-snackbar-root", e.appendChild(this.root), this.render();
  }
  presentItem(e) {
    const r = this.nextItemKey++;
    return this.items.set(r, e), this.render(), () => {
      this.items.delete(r), this.render();
    };
  }
  clear() {
    this.items.clear(), this.render();
  }
  render() {
    this.root && j1(Nr(
      "div",
      null,
      Nr(fS, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([e, r]) => Nr(BY, Object.assign({}, r, { key: e }))))
    ), this.root);
  }
}
const fS = (t) => Nr(
  "div",
  { class: Vf("-cbwsdk-snackbar-container") },
  Nr("style", null, LY),
  Nr("div", { class: "-cbwsdk-snackbar" }, t.children)
), BY = ({ autoExpand: t, message: e, menuItems: r }) => {
  const [n, i] = __(!0), [s, o] = __(t ?? !1);
  RY(() => {
    const u = [
      window.setTimeout(() => {
        i(!1);
      }, 1),
      window.setTimeout(() => {
        o(!0);
      }, 1e4)
    ];
    return () => {
      u.forEach(window.clearTimeout);
    };
  });
  const a = () => {
    o(!s);
  };
  return Nr(
    "div",
    { class: Vf("-cbwsdk-snackbar-instance", n && "-cbwsdk-snackbar-instance-hidden", s && "-cbwsdk-snackbar-instance-expanded") },
    Nr(
      "div",
      { class: "-cbwsdk-snackbar-instance-header", onClick: a },
      Nr("img", { src: kY, class: "-cbwsdk-snackbar-instance-header-cblogo" }),
      " ",
      Nr("div", { class: "-cbwsdk-snackbar-instance-header-message" }, e),
      Nr(
        "div",
        { class: "-gear-container" },
        !s && Nr(
          "svg",
          { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
          Nr("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" })
        ),
        Nr("img", { src: $Y, class: "-gear-icon", title: "Expand" })
      )
    ),
    r && r.length > 0 && Nr("div", { class: "-cbwsdk-snackbar-instance-menu" }, r.map((u, l) => Nr(
      "div",
      { class: Vf("-cbwsdk-snackbar-instance-menu-item", u.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"), onClick: u.onClick, key: l },
      Nr(
        "svg",
        { width: u.svgWidth, height: u.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        Nr("path", { "fill-rule": u.defaultFillRule, "clip-rule": u.defaultClipRule, d: u.path, fill: "#AAAAAA" })
      ),
      Nr("span", { class: Vf("-cbwsdk-snackbar-instance-menu-item-info", u.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red") }, u.info)
    )))
  );
};
class UY {
  constructor() {
    this.attached = !1, this.snackbar = new FY();
  }
  attach() {
    if (this.attached)
      throw new Error("Coinbase Wallet SDK UI is already attached");
    const e = document.documentElement, r = document.createElement("div");
    r.className = "-cbwsdk-css-reset", e.appendChild(r), this.snackbar.attach(r), this.attached = !0, JE();
  }
  showConnecting(e) {
    let r;
    return e.isUnlinkedErrorState ? r = {
      autoExpand: !0,
      message: "Connection lost",
      menuItems: [
        {
          isRed: !1,
          info: "Reset connection",
          svgWidth: "10",
          svgHeight: "11",
          path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
          defaultFillRule: "evenodd",
          defaultClipRule: "evenodd",
          onClick: e.onResetConnection
        }
      ]
    } : r = {
      message: "Confirm on phone",
      menuItems: [
        {
          isRed: !0,
          info: "Cancel transaction",
          svgWidth: "11",
          svgHeight: "11",
          path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
          defaultFillRule: "inherit",
          defaultClipRule: "inherit",
          onClick: e.onCancel
        },
        {
          isRed: !1,
          info: "Reset connection",
          svgWidth: "10",
          svgHeight: "11",
          path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
          defaultFillRule: "evenodd",
          defaultClipRule: "evenodd",
          onClick: e.onResetConnection
        }
      ]
    }, this.snackbar.presentItem(r);
  }
}
const jY = ".-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop{position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s;background-color:rgba(10,11,13,.5)}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box{display:block;position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);padding:20px;border-radius:8px;background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box p{display:block;font-weight:400;font-size:14px;line-height:20px;padding-bottom:12px;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box button{appearance:none;border:none;background:none;color:#0052ff;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark{background-color:#0a0b0d;color:#fff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark button{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light{background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light button{color:#0052ff}";
class qY {
  constructor() {
    this.root = null, this.darkMode = YE();
  }
  attach() {
    const e = document.documentElement;
    this.root = document.createElement("div"), this.root.className = "-cbwsdk-css-reset", e.appendChild(this.root), JE();
  }
  present(e) {
    this.render(e);
  }
  clear() {
    this.render(null);
  }
  render(e) {
    this.root && (j1(null, this.root), e && j1(Nr(zY, Object.assign({}, e, { onDismiss: () => {
      this.clear();
    }, darkMode: this.darkMode })), this.root));
  }
}
const zY = ({ title: t, buttonText: e, darkMode: r, onButtonClick: n, onDismiss: i }) => {
  const s = r ? "dark" : "light";
  return Nr(
    fS,
    { darkMode: r },
    Nr(
      "div",
      { class: "-cbwsdk-redirect-dialog" },
      Nr("style", null, jY),
      Nr("div", { class: "-cbwsdk-redirect-dialog-backdrop", onClick: i }),
      Nr(
        "div",
        { class: Vf("-cbwsdk-redirect-dialog-box", s) },
        Nr("p", null, t),
        Nr("button", { onClick: n }, e)
      )
    )
  );
}, HY = "https://keys.coinbase.com/connect", S_ = "https://www.walletlink.org", WY = "https://go.cb-w.com/walletlink";
class A_ {
  constructor() {
    this.attached = !1, this.redirectDialog = new qY();
  }
  attach() {
    if (this.attached)
      throw new Error("Coinbase Wallet SDK UI is already attached");
    this.redirectDialog.attach(), this.attached = !0;
  }
  redirectToCoinbaseWallet(e) {
    const r = new URL(WY);
    r.searchParams.append("redirect_url", _Y().href), e && r.searchParams.append("wl_url", e);
    const n = document.createElement("a");
    n.target = "cbw-opener", n.href = r.href, n.rel = "noreferrer noopener", n.click();
  }
  openCoinbaseWalletDeeplink(e) {
    this.redirectDialog.present({
      title: "Redirecting to Coinbase Wallet...",
      buttonText: "Open",
      onButtonClick: () => {
        this.redirectToCoinbaseWallet(e);
      }
    }), setTimeout(() => {
      this.redirectToCoinbaseWallet(e);
    }, 99);
  }
  showConnecting(e) {
    return () => {
      this.redirectDialog.clear();
    };
  }
}
class _o {
  constructor(e) {
    this.chainCallbackParams = { chainId: "", jsonRpcUrl: "" }, this.isMobileWeb = EY(), this.linkedUpdated = (s) => {
      this.isLinked = s;
      const o = this.storage.getItem($1);
      if (s && (this._session.linked = s), this.isUnlinkedErrorState = !1, o) {
        const a = o.split(" "), u = this.storage.getItem("IsStandaloneSigning") === "true";
        a[0] !== "" && !s && this._session.linked && !u && (this.isUnlinkedErrorState = !0);
      }
    }, this.metadataUpdated = (s, o) => {
      this.storage.setItem(s, o);
    }, this.chainUpdated = (s, o) => {
      this.chainCallbackParams.chainId === s && this.chainCallbackParams.jsonRpcUrl === o || (this.chainCallbackParams = {
        chainId: s,
        jsonRpcUrl: o
      }, this.chainCallback && this.chainCallback(o, Number.parseInt(s, 10)));
    }, this.accountUpdated = (s) => {
      this.accountsCallback && this.accountsCallback([s]), _o.accountRequestCallbackIds.size > 0 && (Array.from(_o.accountRequestCallbackIds.values()).forEach((o) => {
        this.invokeCallback(o, {
          method: "requestEthereumAccounts",
          result: [s]
        });
      }), _o.accountRequestCallbackIds.clear());
    }, this.resetAndReload = this.resetAndReload.bind(this), this.linkAPIUrl = e.linkAPIUrl, this.storage = e.storage, this.metadata = e.metadata, this.accountsCallback = e.accountsCallback, this.chainCallback = e.chainCallback;
    const { session: r, ui: n, connection: i } = this.subscribe();
    this._session = r, this.connection = i, this.relayEventManager = new wY(), this.ui = n, this.ui.attach();
  }
  subscribe() {
    const e = pu.load(this.storage) || pu.create(this.storage), { linkAPIUrl: r } = this, n = new yY({
      session: e,
      linkAPIUrl: r,
      listener: this
    }), i = this.isMobileWeb ? new A_() : new UY();
    return n.connect(), { session: e, ui: i, connection: n };
  }
  resetAndReload() {
    this.connection.destroy().then(() => {
      const e = pu.load(this.storage);
      (e == null ? void 0 : e.id) === this._session.id && Qs.clearAll(), document.location.reload();
    }).catch((e) => {
    });
  }
  signEthereumTransaction(e) {
    return this.sendRequest({
      method: "signEthereumTransaction",
      params: {
        fromAddress: e.fromAddress,
        toAddress: e.toAddress,
        weiValue: ks(e.weiValue),
        data: Hf(e.data, !0),
        nonce: e.nonce,
        gasPriceInWei: e.gasPriceInWei ? ks(e.gasPriceInWei) : null,
        maxFeePerGas: e.gasPriceInWei ? ks(e.gasPriceInWei) : null,
        maxPriorityFeePerGas: e.gasPriceInWei ? ks(e.gasPriceInWei) : null,
        gasLimit: e.gasLimit ? ks(e.gasLimit) : null,
        chainId: e.chainId,
        shouldSubmit: !1
      }
    });
  }
  signAndSubmitEthereumTransaction(e) {
    return this.sendRequest({
      method: "signEthereumTransaction",
      params: {
        fromAddress: e.fromAddress,
        toAddress: e.toAddress,
        weiValue: ks(e.weiValue),
        data: Hf(e.data, !0),
        nonce: e.nonce,
        gasPriceInWei: e.gasPriceInWei ? ks(e.gasPriceInWei) : null,
        maxFeePerGas: e.maxFeePerGas ? ks(e.maxFeePerGas) : null,
        maxPriorityFeePerGas: e.maxPriorityFeePerGas ? ks(e.maxPriorityFeePerGas) : null,
        gasLimit: e.gasLimit ? ks(e.gasLimit) : null,
        chainId: e.chainId,
        shouldSubmit: !0
      }
    });
  }
  submitEthereumTransaction(e, r) {
    return this.sendRequest({
      method: "submitEthereumTransaction",
      params: {
        signedTransaction: Hf(e, !0),
        chainId: r
      }
    });
  }
  getWalletLinkSession() {
    return this._session;
  }
  sendRequest(e) {
    let r = null;
    const n = Za(8), i = (s) => {
      this.publishWeb3RequestCanceledEvent(n), this.handleErrorResponse(n, e.method, s), r == null || r();
    };
    return new Promise((s, o) => {
      r = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: i,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      }), this.relayEventManager.callbacks.set(n, (a) => {
        if (r == null || r(), Bn(a))
          return o(new Error(a.errorMessage));
        s(a);
      }), this.publishWeb3RequestEvent(n, e);
    });
  }
  publishWeb3RequestEvent(e, r) {
    const n = { type: "WEB3_REQUEST", id: e, request: r };
    this.publishEvent("Web3Request", n, !0).then((i) => {
    }).catch((i) => {
      this.handleWeb3ResponseMessage(n.id, {
        method: r.method,
        errorMessage: i.message
      });
    }), this.isMobileWeb && this.openCoinbaseWalletDeeplink(r.method);
  }
  // copied from MobileRelay
  openCoinbaseWalletDeeplink(e) {
    if (this.ui instanceof A_)
      switch (e) {
        case "requestEthereumAccounts":
        case "switchEthereumChain":
          return;
        default:
          window.addEventListener("blur", () => {
            window.addEventListener("focus", () => {
              this.connection.checkUnseenEvents();
            }, { once: !0 });
          }, { once: !0 }), this.ui.openCoinbaseWalletDeeplink();
          break;
      }
  }
  publishWeb3RequestCanceledEvent(e) {
    const r = {
      type: "WEB3_REQUEST_CANCELED",
      id: e
    };
    this.publishEvent("Web3RequestCanceled", r, !1).then();
  }
  publishEvent(e, r, n) {
    return this.connection.publishEvent(e, r, n);
  }
  handleWeb3ResponseMessage(e, r) {
    if (r.method === "requestEthereumAccounts") {
      _o.accountRequestCallbackIds.forEach((n) => this.invokeCallback(n, r)), _o.accountRequestCallbackIds.clear();
      return;
    }
    this.invokeCallback(e, r);
  }
  handleErrorResponse(e, r, n) {
    var i;
    const s = (i = n == null ? void 0 : n.message) !== null && i !== void 0 ? i : "Unspecified error message.";
    this.handleWeb3ResponseMessage(e, {
      method: r,
      errorMessage: s
    });
  }
  invokeCallback(e, r) {
    const n = this.relayEventManager.callbacks.get(e);
    n && (n(r), this.relayEventManager.callbacks.delete(e));
  }
  requestEthereumAccounts() {
    const { appName: e, appLogoUrl: r } = this.metadata, n = {
      method: "requestEthereumAccounts",
      params: {
        appName: e,
        appLogoUrl: r
      }
    }, i = Za(8);
    return new Promise((s, o) => {
      this.relayEventManager.callbacks.set(i, (a) => {
        if (Bn(a))
          return o(new Error(a.errorMessage));
        s(a);
      }), _o.accountRequestCallbackIds.add(i), this.publishWeb3RequestEvent(i, n);
    });
  }
  watchAsset(e, r, n, i, s, o) {
    const a = {
      method: "watchAsset",
      params: {
        type: e,
        options: {
          address: r,
          symbol: n,
          decimals: i,
          image: s
        },
        chainId: o
      }
    };
    let u = null;
    const l = Za(8), d = (p) => {
      this.publishWeb3RequestCanceledEvent(l), this.handleErrorResponse(l, a.method, p), u == null || u();
    };
    return u = this.ui.showConnecting({
      isUnlinkedErrorState: this.isUnlinkedErrorState,
      onCancel: d,
      onResetConnection: this.resetAndReload
      // eslint-disable-line @typescript-eslint/unbound-method
    }), new Promise((p, w) => {
      this.relayEventManager.callbacks.set(l, (P) => {
        if (u == null || u(), Bn(P))
          return w(new Error(P.errorMessage));
        p(P);
      }), this.publishWeb3RequestEvent(l, a);
    });
  }
  addEthereumChain(e, r, n, i, s, o) {
    const a = {
      method: "addEthereumChain",
      params: {
        chainId: e,
        rpcUrls: r,
        blockExplorerUrls: i,
        chainName: s,
        iconUrls: n,
        nativeCurrency: o
      }
    };
    let u = null;
    const l = Za(8), d = (p) => {
      this.publishWeb3RequestCanceledEvent(l), this.handleErrorResponse(l, a.method, p), u == null || u();
    };
    return u = this.ui.showConnecting({
      isUnlinkedErrorState: this.isUnlinkedErrorState,
      onCancel: d,
      onResetConnection: this.resetAndReload
      // eslint-disable-line @typescript-eslint/unbound-method
    }), new Promise((p, w) => {
      this.relayEventManager.callbacks.set(l, (P) => {
        if (u == null || u(), Bn(P))
          return w(new Error(P.errorMessage));
        p(P);
      }), this.publishWeb3RequestEvent(l, a);
    });
  }
  switchEthereumChain(e, r) {
    const n = {
      method: "switchEthereumChain",
      params: Object.assign({ chainId: e }, { address: r })
    };
    let i = null;
    const s = Za(8), o = (a) => {
      this.publishWeb3RequestCanceledEvent(s), this.handleErrorResponse(s, n.method, a), i == null || i();
    };
    return i = this.ui.showConnecting({
      isUnlinkedErrorState: this.isUnlinkedErrorState,
      onCancel: o,
      onResetConnection: this.resetAndReload
      // eslint-disable-line @typescript-eslint/unbound-method
    }), new Promise((a, u) => {
      this.relayEventManager.callbacks.set(s, (l) => {
        if (i == null || i(), Bn(l) && l.errorCode)
          return u(Sr.provider.custom({
            code: l.errorCode,
            message: "Unrecognized chain ID. Try adding the chain using addEthereumChain first."
          }));
        if (Bn(l))
          return u(new Error(l.errorMessage));
        a(l);
      }), this.publishWeb3RequestEvent(s, n);
    });
  }
}
_o.accountRequestCallbackIds = /* @__PURE__ */ new Set();
const P_ = "DefaultChainId", M_ = "DefaultJsonRpcUrl";
class lS {
  constructor(e) {
    this._relay = null, this._addresses = [], this.metadata = e.metadata, this._storage = new Qs("walletlink", S_), this.callback = e.callback || null;
    const r = this._storage.getItem($1);
    if (r) {
      const n = r.split(" ");
      n[0] !== "" && (this._addresses = n.map((i) => ta(i)));
    }
    this.initializeRelay();
  }
  getSession() {
    const e = this.initializeRelay(), { id: r, secret: n } = e.getWalletLinkSession();
    return { id: r, secret: n };
  }
  async handshake() {
    await this._eth_requestAccounts();
  }
  get selectedAddress() {
    return this._addresses[0] || void 0;
  }
  get jsonRpcUrl() {
    var e;
    return (e = this._storage.getItem(M_)) !== null && e !== void 0 ? e : void 0;
  }
  set jsonRpcUrl(e) {
    this._storage.setItem(M_, e);
  }
  updateProviderInfo(e, r) {
    var n;
    this.jsonRpcUrl = e;
    const i = this.getChainId();
    this._storage.setItem(P_, r.toString(10)), Wf(r) !== i && ((n = this.callback) === null || n === void 0 || n.call(this, "chainChanged", da(r)));
  }
  async watchAsset(e) {
    const r = Array.isArray(e) ? e[0] : e;
    if (!r.type)
      throw Sr.rpc.invalidParams("Type is required");
    if ((r == null ? void 0 : r.type) !== "ERC20")
      throw Sr.rpc.invalidParams(`Asset of type '${r.type}' is not supported`);
    if (!(r != null && r.options))
      throw Sr.rpc.invalidParams("Options are required");
    if (!(r != null && r.options.address))
      throw Sr.rpc.invalidParams("Address is required");
    const n = this.getChainId(), { address: i, symbol: s, image: o, decimals: a } = r.options, l = await this.initializeRelay().watchAsset(r.type, i, s, a, o, n == null ? void 0 : n.toString());
    return Bn(l) ? !1 : !!l.result;
  }
  async addEthereumChain(e) {
    var r, n;
    const i = e[0];
    if (((r = i.rpcUrls) === null || r === void 0 ? void 0 : r.length) === 0)
      throw Sr.rpc.invalidParams("please pass in at least 1 rpcUrl");
    if (!i.chainName || i.chainName.trim() === "")
      throw Sr.rpc.invalidParams("chainName is a required field");
    if (!i.nativeCurrency)
      throw Sr.rpc.invalidParams("nativeCurrency is a required field");
    const s = Number.parseInt(i.chainId, 16);
    if (s === this.getChainId())
      return !1;
    const o = this.initializeRelay(), { rpcUrls: a = [], blockExplorerUrls: u = [], chainName: l, iconUrls: d = [], nativeCurrency: p } = i, w = await o.addEthereumChain(s.toString(), a, d, u, l, p);
    if (Bn(w))
      return !1;
    if (((n = w.result) === null || n === void 0 ? void 0 : n.isApproved) === !0)
      return this.updateProviderInfo(a[0], s), null;
    throw Sr.rpc.internal("unable to add ethereum chain");
  }
  async switchEthereumChain(e) {
    const r = e[0], n = Number.parseInt(r.chainId, 16), s = await this.initializeRelay().switchEthereumChain(n.toString(10), this.selectedAddress || void 0);
    if (Bn(s))
      throw s;
    const o = s.result;
    return o.isApproved && o.rpcUrl.length > 0 && this.updateProviderInfo(o.rpcUrl, n), null;
  }
  async cleanup() {
    this.callback = null, this._relay && this._relay.resetAndReload(), this._storage.clear();
  }
  _setAddresses(e, r) {
    var n;
    if (!Array.isArray(e))
      throw new Error("addresses is not an array");
    const i = e.map((s) => ta(s));
    JSON.stringify(i) !== JSON.stringify(this._addresses) && (this._addresses = i, (n = this.callback) === null || n === void 0 || n.call(this, "accountsChanged", i), this._storage.setItem($1, i.join(" ")));
  }
  async request(e) {
    const r = e.params || [];
    switch (e.method) {
      case "eth_accounts":
        return [...this._addresses];
      case "eth_coinbase":
        return this.selectedAddress || null;
      case "net_version":
        return this.getChainId().toString(10);
      case "eth_chainId":
        return da(this.getChainId());
      case "eth_requestAccounts":
        return this._eth_requestAccounts();
      case "eth_ecRecover":
      case "personal_ecRecover":
        return this.ecRecover(e);
      case "personal_sign":
        return this.personalSign(e);
      case "eth_signTransaction":
        return this._eth_signTransaction(r);
      case "eth_sendRawTransaction":
        return this._eth_sendRawTransaction(r);
      case "eth_sendTransaction":
        return this._eth_sendTransaction(r);
      case "eth_signTypedData_v1":
      case "eth_signTypedData_v3":
      case "eth_signTypedData_v4":
      case "eth_signTypedData":
        return this.signTypedData(e);
      case "wallet_addEthereumChain":
        return this.addEthereumChain(r);
      case "wallet_switchEthereumChain":
        return this.switchEthereumChain(r);
      case "wallet_watchAsset":
        return this.watchAsset(r);
      default:
        if (!this.jsonRpcUrl)
          throw Sr.rpc.internal("No RPC URL set for chain");
        return FE(e, this.jsonRpcUrl);
    }
  }
  _ensureKnownAddress(e) {
    const r = ta(e);
    if (!this._addresses.map((i) => ta(i)).includes(r))
      throw new Error("Unknown Ethereum address");
  }
  _prepareTransactionParams(e) {
    const r = e.from ? ta(e.from) : this.selectedAddress;
    if (!r)
      throw new Error("Ethereum address is unavailable");
    this._ensureKnownAddress(r);
    const n = e.to ? ta(e.to) : null, i = e.value != null ? Tf(e.value) : BigInt(0), s = e.data ? k1(e.data) : Buffer.alloc(0), o = e.nonce != null ? Wf(e.nonce) : null, a = e.gasPrice != null ? Tf(e.gasPrice) : null, u = e.maxFeePerGas != null ? Tf(e.maxFeePerGas) : null, l = e.maxPriorityFeePerGas != null ? Tf(e.maxPriorityFeePerGas) : null, d = e.gas != null ? Tf(e.gas) : null, p = e.chainId ? Wf(e.chainId) : this.getChainId();
    return {
      fromAddress: r,
      toAddress: n,
      weiValue: i,
      data: s,
      nonce: o,
      gasPriceInWei: a,
      maxFeePerGas: u,
      maxPriorityFeePerGas: l,
      gasLimit: d,
      chainId: p
    };
  }
  async ecRecover(e) {
    const { method: r, params: n } = e;
    if (!Array.isArray(n))
      throw Sr.rpc.invalidParams();
    const s = await this.initializeRelay().sendRequest({
      method: "ethereumAddressFromSignedMessage",
      params: {
        message: _m(n[0]),
        signature: _m(n[1]),
        addPrefix: r === "personal_ecRecover"
      }
    });
    if (Bn(s))
      throw s;
    return s.result;
  }
  getChainId() {
    var e;
    return Number.parseInt((e = this._storage.getItem(P_)) !== null && e !== void 0 ? e : "1", 10);
  }
  async _eth_requestAccounts() {
    var e, r;
    if (this._addresses.length > 0)
      return (e = this.callback) === null || e === void 0 || e.call(this, "connect", { chainId: da(this.getChainId()) }), this._addresses;
    const i = await this.initializeRelay().requestEthereumAccounts();
    if (Bn(i))
      throw i;
    if (!i.result)
      throw new Error("accounts received is empty");
    return this._setAddresses(i.result), (r = this.callback) === null || r === void 0 || r.call(this, "connect", { chainId: da(this.getChainId()) }), this._addresses;
  }
  async personalSign({ params: e }) {
    if (!Array.isArray(e))
      throw Sr.rpc.invalidParams();
    const r = e[1], n = e[0];
    this._ensureKnownAddress(r);
    const s = await this.initializeRelay().sendRequest({
      method: "signEthereumMessage",
      params: {
        address: ta(r),
        message: _m(n),
        addPrefix: !0,
        typedDataJson: null
      }
    });
    if (Bn(s))
      throw s;
    return s.result;
  }
  async _eth_signTransaction(e) {
    const r = this._prepareTransactionParams(e[0] || {}), i = await this.initializeRelay().signEthereumTransaction(r);
    if (Bn(i))
      throw i;
    return i.result;
  }
  async _eth_sendRawTransaction(e) {
    const r = k1(e[0]), i = await this.initializeRelay().submitEthereumTransaction(r, this.getChainId());
    if (Bn(i))
      throw i;
    return i.result;
  }
  async _eth_sendTransaction(e) {
    const r = this._prepareTransactionParams(e[0] || {}), i = await this.initializeRelay().signAndSubmitEthereumTransaction(r);
    if (Bn(i))
      throw i;
    return i.result;
  }
  async signTypedData(e) {
    const { method: r, params: n } = e;
    if (!Array.isArray(n))
      throw Sr.rpc.invalidParams();
    const i = (l) => {
      const d = {
        eth_signTypedData_v1: hd.hashForSignTypedDataLegacy,
        eth_signTypedData_v3: hd.hashForSignTypedData_v3,
        eth_signTypedData_v4: hd.hashForSignTypedData_v4,
        eth_signTypedData: hd.hashForSignTypedData_v4
      };
      return Hf(d[r]({
        data: FG(l)
      }), !0);
    }, s = n[r === "eth_signTypedData_v1" ? 1 : 0], o = n[r === "eth_signTypedData_v1" ? 0 : 1];
    this._ensureKnownAddress(s);
    const u = await this.initializeRelay().sendRequest({
      method: "signEthereumMessage",
      params: {
        address: ta(s),
        message: i(o),
        typedDataJson: JSON.stringify(o, null, 2),
        addPrefix: !1
      }
    });
    if (Bn(u))
      throw u;
    return u.result;
  }
  initializeRelay() {
    return this._relay || (this._relay = new _o({
      linkAPIUrl: S_,
      storage: this._storage,
      metadata: this.metadata,
      accountsCallback: this._setAddresses.bind(this),
      chainCallback: this.updateProviderInfo.bind(this)
    })), this._relay;
  }
}
const hS = "SignerType", dS = new Qs("CBWSDK", "SignerConfigurator");
function KY() {
  return dS.getItem(hS);
}
function VY(t) {
  dS.setItem(hS, t);
}
async function GY(t) {
  const { communicator: e, metadata: r, handshakeRequest: n, callback: i } = t;
  JY(e, r, i).catch(() => {
  });
  const s = {
    id: crypto.randomUUID(),
    event: "selectSignerType",
    data: Object.assign(Object.assign({}, t.preference), { handshakeRequest: n })
  }, { data: o } = await e.postRequestAndWaitForResponse(s);
  return o;
}
function YY(t) {
  const { signerType: e, metadata: r, communicator: n, callback: i } = t;
  switch (e) {
    case "scw":
      return new XG({
        metadata: r,
        callback: i,
        communicator: n
      });
    case "walletlink":
      return new lS({
        metadata: r,
        callback: i
      });
  }
}
async function JY(t, e, r) {
  await t.onMessage(({ event: i }) => i === "WalletLinkSessionRequest");
  const n = new lS({
    metadata: e,
    callback: r
  });
  t.postMessage({
    event: "WalletLinkUpdate",
    data: { session: n.getSession() }
  }), await n.handshake(), t.postMessage({
    event: "WalletLinkUpdate",
    data: { connected: !0 }
  });
}
const XY = `Coinbase Wallet SDK requires the Cross-Origin-Opener-Policy header to not be set to 'same-origin'. This is to ensure that the SDK can communicate with the Coinbase Smart Wallet app.

Please see https://www.smartwallet.dev/guides/tips/popup-tips#cross-origin-opener-policy for more information.`, ZY = () => {
  let t;
  return {
    getCrossOriginOpenerPolicy: () => t === void 0 ? "undefined" : t,
    checkCrossOriginOpenerPolicy: async () => {
      if (typeof window > "u") {
        t = "non-browser-env";
        return;
      }
      try {
        const e = `${window.location.origin}${window.location.pathname}`, r = await fetch(e, {
          method: "HEAD"
        });
        if (!r.ok)
          throw new Error(`HTTP error! status: ${r.status}`);
        const n = r.headers.get("Cross-Origin-Opener-Policy");
        t = n ?? "null", t === "same-origin" && console.error(XY);
      } catch (e) {
        console.error("Error checking Cross-Origin-Opener-Policy:", e.message), t = "error";
      }
    }
  };
}, { checkCrossOriginOpenerPolicy: QY, getCrossOriginOpenerPolicy: eJ } = ZY(), I_ = 420, C_ = 540;
function tJ(t) {
  const e = (window.innerWidth - I_) / 2 + window.screenX, r = (window.innerHeight - C_) / 2 + window.screenY;
  nJ(t);
  const n = window.open(t, "Smart Wallet", `width=${I_}, height=${C_}, left=${e}, top=${r}`);
  if (n == null || n.focus(), !n)
    throw Sr.rpc.internal("Pop up window failed to open");
  return n;
}
function rJ(t) {
  t && !t.closed && t.close();
}
function nJ(t) {
  const e = {
    sdkName: $E,
    sdkVersion: rh,
    origin: window.location.origin,
    coop: eJ()
  };
  for (const [r, n] of Object.entries(e))
    t.searchParams.append(r, n.toString());
}
class iJ {
  constructor({ url: e = HY, metadata: r, preference: n }) {
    this.popup = null, this.listeners = /* @__PURE__ */ new Map(), this.postMessage = async (i) => {
      (await this.waitForPopupLoaded()).postMessage(i, this.url.origin);
    }, this.postRequestAndWaitForResponse = async (i) => {
      const s = this.onMessage(({ requestId: o }) => o === i.id);
      return this.postMessage(i), await s;
    }, this.onMessage = async (i) => new Promise((s, o) => {
      const a = (u) => {
        if (u.origin !== this.url.origin)
          return;
        const l = u.data;
        i(l) && (s(l), window.removeEventListener("message", a), this.listeners.delete(a));
      };
      window.addEventListener("message", a), this.listeners.set(a, { reject: o });
    }), this.disconnect = () => {
      rJ(this.popup), this.popup = null, this.listeners.forEach(({ reject: i }, s) => {
        i(Sr.provider.userRejectedRequest("Request rejected")), window.removeEventListener("message", s);
      }), this.listeners.clear();
    }, this.waitForPopupLoaded = async () => this.popup && !this.popup.closed ? (this.popup.focus(), this.popup) : (this.popup = tJ(this.url), this.onMessage(({ event: i }) => i === "PopupUnload").then(this.disconnect).catch(() => {
    }), this.onMessage(({ event: i }) => i === "PopupLoaded").then((i) => {
      this.postMessage({
        requestId: i.id,
        data: {
          version: rh,
          metadata: this.metadata,
          preference: this.preference,
          location: window.location.toString()
        }
      });
    }).then(() => {
      if (!this.popup)
        throw Sr.rpc.internal();
      return this.popup;
    })), this.url = new URL(e), this.metadata = r, this.preference = n;
  }
}
function sJ(t) {
  const e = OG(oJ(t), {
    shouldIncludeStack: !0
  }), r = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
  return r.searchParams.set("version", rh), r.searchParams.set("code", e.code.toString()), r.searchParams.set("message", e.message), Object.assign(Object.assign({}, e), { docUrl: r.href });
}
function oJ(t) {
  var e;
  if (typeof t == "string")
    return {
      message: t,
      code: fn.rpc.internal
    };
  if (Bn(t)) {
    const r = t.errorMessage, n = (e = t.errorCode) !== null && e !== void 0 ? e : r.match(/(denied|rejected)/i) ? fn.provider.userRejectedRequest : void 0;
    return Object.assign(Object.assign({}, t), {
      message: r,
      code: n,
      data: { method: t.method }
    });
  }
  return t;
}
var pS = { exports: {} };
(function(t) {
  var e = Object.prototype.hasOwnProperty, r = "~";
  function n() {
  }
  Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (r = !1));
  function i(u, l, d) {
    this.fn = u, this.context = l, this.once = d || !1;
  }
  function s(u, l, d, p, w) {
    if (typeof d != "function")
      throw new TypeError("The listener must be a function");
    var P = new i(d, p || u, w), A = r ? r + l : l;
    return u._events[A] ? u._events[A].fn ? u._events[A] = [u._events[A], P] : u._events[A].push(P) : (u._events[A] = P, u._eventsCount++), u;
  }
  function o(u, l) {
    --u._eventsCount === 0 ? u._events = new n() : delete u._events[l];
  }
  function a() {
    this._events = new n(), this._eventsCount = 0;
  }
  a.prototype.eventNames = function() {
    var l = [], d, p;
    if (this._eventsCount === 0) return l;
    for (p in d = this._events)
      e.call(d, p) && l.push(r ? p.slice(1) : p);
    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(d)) : l;
  }, a.prototype.listeners = function(l) {
    var d = r ? r + l : l, p = this._events[d];
    if (!p) return [];
    if (p.fn) return [p.fn];
    for (var w = 0, P = p.length, A = new Array(P); w < P; w++)
      A[w] = p[w].fn;
    return A;
  }, a.prototype.listenerCount = function(l) {
    var d = r ? r + l : l, p = this._events[d];
    return p ? p.fn ? 1 : p.length : 0;
  }, a.prototype.emit = function(l, d, p, w, P, A) {
    var N = r ? r + l : l;
    if (!this._events[N]) return !1;
    var L = this._events[N], F = arguments.length, $, K;
    if (L.fn) {
      switch (L.once && this.removeListener(l, L.fn, void 0, !0), F) {
        case 1:
          return L.fn.call(L.context), !0;
        case 2:
          return L.fn.call(L.context, d), !0;
        case 3:
          return L.fn.call(L.context, d, p), !0;
        case 4:
          return L.fn.call(L.context, d, p, w), !0;
        case 5:
          return L.fn.call(L.context, d, p, w, P), !0;
        case 6:
          return L.fn.call(L.context, d, p, w, P, A), !0;
      }
      for (K = 1, $ = new Array(F - 1); K < F; K++)
        $[K - 1] = arguments[K];
      L.fn.apply(L.context, $);
    } else {
      var H = L.length, V;
      for (K = 0; K < H; K++)
        switch (L[K].once && this.removeListener(l, L[K].fn, void 0, !0), F) {
          case 1:
            L[K].fn.call(L[K].context);
            break;
          case 2:
            L[K].fn.call(L[K].context, d);
            break;
          case 3:
            L[K].fn.call(L[K].context, d, p);
            break;
          case 4:
            L[K].fn.call(L[K].context, d, p, w);
            break;
          default:
            if (!$) for (V = 1, $ = new Array(F - 1); V < F; V++)
              $[V - 1] = arguments[V];
            L[K].fn.apply(L[K].context, $);
        }
    }
    return !0;
  }, a.prototype.on = function(l, d, p) {
    return s(this, l, d, p, !1);
  }, a.prototype.once = function(l, d, p) {
    return s(this, l, d, p, !0);
  }, a.prototype.removeListener = function(l, d, p, w) {
    var P = r ? r + l : l;
    if (!this._events[P]) return this;
    if (!d)
      return o(this, P), this;
    var A = this._events[P];
    if (A.fn)
      A.fn === d && (!w || A.once) && (!p || A.context === p) && o(this, P);
    else {
      for (var N = 0, L = [], F = A.length; N < F; N++)
        (A[N].fn !== d || w && !A[N].once || p && A[N].context !== p) && L.push(A[N]);
      L.length ? this._events[P] = L.length === 1 ? L[0] : L : o(this, P);
    }
    return this;
  }, a.prototype.removeAllListeners = function(l) {
    var d;
    return l ? (d = r ? r + l : l, this._events[d] && o(this, d)) : (this._events = new n(), this._eventsCount = 0), this;
  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, t.exports = a;
})(pS);
var aJ = pS.exports;
const cJ = /* @__PURE__ */ ts(aJ);
class uJ extends cJ {
}
var fJ = function(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
  return r;
};
class lJ extends uJ {
  constructor(e) {
    var { metadata: r } = e, n = e.preference, { keysUrl: i } = n, s = fJ(n, ["keysUrl"]);
    super(), this.signer = null, this.isCoinbaseWallet = !0, this.metadata = r, this.preference = s, this.communicator = new iJ({
      url: i,
      metadata: r,
      preference: s
    });
    const o = KY();
    o && (this.signer = this.initSigner(o));
  }
  async request(e) {
    try {
      if (JG(e), !this.signer)
        switch (e.method) {
          case "eth_requestAccounts": {
            const r = await this.requestSignerSelection(e), n = this.initSigner(r);
            await n.handshake(e), this.signer = n, VY(r);
            break;
          }
          case "net_version":
            return 1;
          case "eth_chainId":
            return da(1);
          default:
            throw Sr.provider.unauthorized("Must call 'eth_requestAccounts' before other methods");
        }
      return this.signer.request(e);
    } catch (r) {
      const { code: n } = r;
      return n === fn.provider.unauthorized && this.disconnect(), Promise.reject(sJ(r));
    }
  }
  /** @deprecated Use `.request({ method: 'eth_requestAccounts' })` instead. */
  async enable() {
    return console.warn('.enable() has been deprecated. Please use .request({ method: "eth_requestAccounts" }) instead.'), await this.request({
      method: "eth_requestAccounts"
    });
  }
  async disconnect() {
    var e;
    await ((e = this.signer) === null || e === void 0 ? void 0 : e.cleanup()), this.signer = null, Qs.clearAll(), this.emit("disconnect", Sr.provider.disconnected("User initiated disconnection"));
  }
  requestSignerSelection(e) {
    return GY({
      communicator: this.communicator,
      preference: this.preference,
      metadata: this.metadata,
      handshakeRequest: e,
      callback: this.emit.bind(this)
    });
  }
  initSigner(e) {
    return YY({
      signerType: e,
      metadata: this.metadata,
      communicator: this.communicator,
      callback: this.emit.bind(this)
    });
  }
}
function hJ(t) {
  if (t) {
    if (!["all", "smartWalletOnly", "eoaOnly"].includes(t.options))
      throw new Error(`Invalid options: ${t.options}`);
    if (t.attribution && t.attribution.auto !== void 0 && t.attribution.dataSuffix !== void 0)
      throw new Error("Attribution cannot contain both auto and dataSuffix properties");
  }
}
function dJ(t) {
  var e;
  const r = {
    metadata: t.metadata,
    preference: t.preference
  };
  return (e = YG(r)) !== null && e !== void 0 ? e : new lJ(r);
}
const pJ = {
  options: "all"
};
function gJ(t) {
  var e;
  new Qs("CBWSDK").setItem("VERSION", rh), QY();
  const n = {
    metadata: {
      appName: t.appName || "Dapp",
      appLogoUrl: t.appLogoUrl || "",
      appChainIds: t.appChainIds || []
    },
    preference: Object.assign(pJ, (e = t.preference) !== null && e !== void 0 ? e : {})
  };
  hJ(n.preference);
  let i = null;
  return {
    getProvider: () => (i || (i = dJ(n)), i)
  };
}
function gS(t, e) {
  return function() {
    return t.apply(e, arguments);
  };
}
const { toString: mJ } = Object.prototype, { getPrototypeOf: Eb } = Object, up = /* @__PURE__ */ ((t) => (e) => {
  const r = mJ.call(e);
  return t[r] || (t[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), As = (t) => (t = t.toLowerCase(), (e) => up(e) === t), fp = (t) => (e) => typeof e === t, { isArray: zu } = Array, Pl = fp("undefined");
function vJ(t) {
  return t !== null && !Pl(t) && t.constructor !== null && !Pl(t.constructor) && Di(t.constructor.isBuffer) && t.constructor.isBuffer(t);
}
const mS = As("ArrayBuffer");
function bJ(t) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && mS(t.buffer), e;
}
const yJ = fp("string"), Di = fp("function"), vS = fp("number"), lp = (t) => t !== null && typeof t == "object", wJ = (t) => t === !0 || t === !1, Ld = (t) => {
  if (up(t) !== "object")
    return !1;
  const e = Eb(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
}, xJ = As("Date"), _J = As("File"), EJ = As("Blob"), SJ = As("FileList"), AJ = (t) => lp(t) && Di(t.pipe), PJ = (t) => {
  let e;
  return t && (typeof FormData == "function" && t instanceof FormData || Di(t.append) && ((e = up(t)) === "formdata" || // detect form-data instance
  e === "object" && Di(t.toString) && t.toString() === "[object FormData]"));
}, MJ = As("URLSearchParams"), [IJ, CJ, TJ, RJ] = ["ReadableStream", "Request", "Response", "Headers"].map(As), DJ = (t) => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function ih(t, e, { allOwnKeys: r = !1 } = {}) {
  if (t === null || typeof t > "u")
    return;
  let n, i;
  if (typeof t != "object" && (t = [t]), zu(t))
    for (n = 0, i = t.length; n < i; n++)
      e.call(null, t[n], n, t);
  else {
    const s = r ? Object.getOwnPropertyNames(t) : Object.keys(t), o = s.length;
    let a;
    for (n = 0; n < o; n++)
      a = s[n], e.call(null, t[a], a, t);
  }
}
function bS(t, e) {
  e = e.toLowerCase();
  const r = Object.keys(t);
  let n = r.length, i;
  for (; n-- > 0; )
    if (i = r[n], e === i.toLowerCase())
      return i;
  return null;
}
const nc = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, yS = (t) => !Pl(t) && t !== nc;
function H1() {
  const { caseless: t } = yS(this) && this || {}, e = {}, r = (n, i) => {
    const s = t && bS(e, i) || i;
    Ld(e[s]) && Ld(n) ? e[s] = H1(e[s], n) : Ld(n) ? e[s] = H1({}, n) : zu(n) ? e[s] = n.slice() : e[s] = n;
  };
  for (let n = 0, i = arguments.length; n < i; n++)
    arguments[n] && ih(arguments[n], r);
  return e;
}
const OJ = (t, e, r, { allOwnKeys: n } = {}) => (ih(e, (i, s) => {
  r && Di(i) ? t[s] = gS(i, r) : t[s] = i;
}, { allOwnKeys: n }), t), NJ = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), LJ = (t, e, r, n) => {
  t.prototype = Object.create(e.prototype, n), t.prototype.constructor = t, Object.defineProperty(t, "super", {
    value: e.prototype
  }), r && Object.assign(t.prototype, r);
}, kJ = (t, e, r, n) => {
  let i, s, o;
  const a = {};
  if (e = e || {}, t == null) return e;
  do {
    for (i = Object.getOwnPropertyNames(t), s = i.length; s-- > 0; )
      o = i[s], (!n || n(o, t, e)) && !a[o] && (e[o] = t[o], a[o] = !0);
    t = r !== !1 && Eb(t);
  } while (t && (!r || r(t, e)) && t !== Object.prototype);
  return e;
}, $J = (t, e, r) => {
  t = String(t), (r === void 0 || r > t.length) && (r = t.length), r -= e.length;
  const n = t.indexOf(e, r);
  return n !== -1 && n === r;
}, FJ = (t) => {
  if (!t) return null;
  if (zu(t)) return t;
  let e = t.length;
  if (!vS(e)) return null;
  const r = new Array(e);
  for (; e-- > 0; )
    r[e] = t[e];
  return r;
}, BJ = /* @__PURE__ */ ((t) => (e) => t && e instanceof t)(typeof Uint8Array < "u" && Eb(Uint8Array)), UJ = (t, e) => {
  const n = (t && t[Symbol.iterator]).call(t);
  let i;
  for (; (i = n.next()) && !i.done; ) {
    const s = i.value;
    e.call(t, s[0], s[1]);
  }
}, jJ = (t, e) => {
  let r;
  const n = [];
  for (; (r = t.exec(e)) !== null; )
    n.push(r);
  return n;
}, qJ = As("HTMLFormElement"), zJ = (t) => t.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, n, i) {
    return n.toUpperCase() + i;
  }
), T_ = (({ hasOwnProperty: t }) => (e, r) => t.call(e, r))(Object.prototype), HJ = As("RegExp"), wS = (t, e) => {
  const r = Object.getOwnPropertyDescriptors(t), n = {};
  ih(r, (i, s) => {
    let o;
    (o = e(i, s, t)) !== !1 && (n[s] = o || i);
  }), Object.defineProperties(t, n);
}, WJ = (t) => {
  wS(t, (e, r) => {
    if (Di(t) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const n = t[r];
    if (Di(n)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
}, KJ = (t, e) => {
  const r = {}, n = (i) => {
    i.forEach((s) => {
      r[s] = !0;
    });
  };
  return zu(t) ? n(t) : n(String(t).split(e)), r;
}, VJ = () => {
}, GJ = (t, e) => t != null && Number.isFinite(t = +t) ? t : e, Im = "abcdefghijklmnopqrstuvwxyz", R_ = "0123456789", xS = {
  DIGIT: R_,
  ALPHA: Im,
  ALPHA_DIGIT: Im + Im.toUpperCase() + R_
}, YJ = (t = 16, e = xS.ALPHA_DIGIT) => {
  let r = "";
  const { length: n } = e;
  for (; t--; )
    r += e[Math.random() * n | 0];
  return r;
};
function JJ(t) {
  return !!(t && Di(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator]);
}
const XJ = (t) => {
  const e = new Array(10), r = (n, i) => {
    if (lp(n)) {
      if (e.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        e[i] = n;
        const s = zu(n) ? [] : {};
        return ih(n, (o, a) => {
          const u = r(o, i + 1);
          !Pl(u) && (s[a] = u);
        }), e[i] = void 0, s;
      }
    }
    return n;
  };
  return r(t, 0);
}, ZJ = As("AsyncFunction"), QJ = (t) => t && (lp(t) || Di(t)) && Di(t.then) && Di(t.catch), _S = ((t, e) => t ? setImmediate : e ? ((r, n) => (nc.addEventListener("message", ({ source: i, data: s }) => {
  i === nc && s === r && n.length && n.shift()();
}, !1), (i) => {
  n.push(i), nc.postMessage(r, "*");
}))(`axios@${Math.random()}`, []) : (r) => setTimeout(r))(
  typeof setImmediate == "function",
  Di(nc.postMessage)
), eX = typeof queueMicrotask < "u" ? queueMicrotask.bind(nc) : typeof process < "u" && process.nextTick || _S, Oe = {
  isArray: zu,
  isArrayBuffer: mS,
  isBuffer: vJ,
  isFormData: PJ,
  isArrayBufferView: bJ,
  isString: yJ,
  isNumber: vS,
  isBoolean: wJ,
  isObject: lp,
  isPlainObject: Ld,
  isReadableStream: IJ,
  isRequest: CJ,
  isResponse: TJ,
  isHeaders: RJ,
  isUndefined: Pl,
  isDate: xJ,
  isFile: _J,
  isBlob: EJ,
  isRegExp: HJ,
  isFunction: Di,
  isStream: AJ,
  isURLSearchParams: MJ,
  isTypedArray: BJ,
  isFileList: SJ,
  forEach: ih,
  merge: H1,
  extend: OJ,
  trim: DJ,
  stripBOM: NJ,
  inherits: LJ,
  toFlatObject: kJ,
  kindOf: up,
  kindOfTest: As,
  endsWith: $J,
  toArray: FJ,
  forEachEntry: UJ,
  matchAll: jJ,
  isHTMLForm: qJ,
  hasOwnProperty: T_,
  hasOwnProp: T_,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: wS,
  freezeMethods: WJ,
  toObjectSet: KJ,
  toCamelCase: zJ,
  noop: VJ,
  toFiniteNumber: GJ,
  findKey: bS,
  global: nc,
  isContextDefined: yS,
  ALPHABET: xS,
  generateString: YJ,
  isSpecCompliantForm: JJ,
  toJSONObject: XJ,
  isAsyncFn: ZJ,
  isThenable: QJ,
  setImmediate: _S,
  asap: eX
};
function sr(t, e, r, n, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), r && (this.config = r), n && (this.request = n), i && (this.response = i, this.status = i.status ? i.status : null);
}
Oe.inherits(sr, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Oe.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const ES = sr.prototype, SS = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((t) => {
  SS[t] = { value: t };
});
Object.defineProperties(sr, SS);
Object.defineProperty(ES, "isAxiosError", { value: !0 });
sr.from = (t, e, r, n, i, s) => {
  const o = Object.create(ES);
  return Oe.toFlatObject(t, o, function(u) {
    return u !== Error.prototype;
  }, (a) => a !== "isAxiosError"), sr.call(o, t.message, e, r, n, i), o.cause = t, o.name = t.name, s && Object.assign(o, s), o;
};
const tX = null;
function W1(t) {
  return Oe.isPlainObject(t) || Oe.isArray(t);
}
function AS(t) {
  return Oe.endsWith(t, "[]") ? t.slice(0, -2) : t;
}
function D_(t, e, r) {
  return t ? t.concat(e).map(function(i, s) {
    return i = AS(i), !r && s ? "[" + i + "]" : i;
  }).join(r ? "." : "") : e;
}
function rX(t) {
  return Oe.isArray(t) && !t.some(W1);
}
const nX = Oe.toFlatObject(Oe, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function hp(t, e, r) {
  if (!Oe.isObject(t))
    throw new TypeError("target must be an object");
  e = e || new FormData(), r = Oe.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(N, L) {
    return !Oe.isUndefined(L[N]);
  });
  const n = r.metaTokens, i = r.visitor || d, s = r.dots, o = r.indexes, u = (r.Blob || typeof Blob < "u" && Blob) && Oe.isSpecCompliantForm(e);
  if (!Oe.isFunction(i))
    throw new TypeError("visitor must be a function");
  function l(A) {
    if (A === null) return "";
    if (Oe.isDate(A))
      return A.toISOString();
    if (!u && Oe.isBlob(A))
      throw new sr("Blob is not supported. Use a Buffer instead.");
    return Oe.isArrayBuffer(A) || Oe.isTypedArray(A) ? u && typeof Blob == "function" ? new Blob([A]) : Buffer.from(A) : A;
  }
  function d(A, N, L) {
    let F = A;
    if (A && !L && typeof A == "object") {
      if (Oe.endsWith(N, "{}"))
        N = n ? N : N.slice(0, -2), A = JSON.stringify(A);
      else if (Oe.isArray(A) && rX(A) || (Oe.isFileList(A) || Oe.endsWith(N, "[]")) && (F = Oe.toArray(A)))
        return N = AS(N), F.forEach(function(K, H) {
          !(Oe.isUndefined(K) || K === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? D_([N], H, s) : o === null ? N : N + "[]",
            l(K)
          );
        }), !1;
    }
    return W1(A) ? !0 : (e.append(D_(L, N, s), l(A)), !1);
  }
  const p = [], w = Object.assign(nX, {
    defaultVisitor: d,
    convertValue: l,
    isVisitable: W1
  });
  function P(A, N) {
    if (!Oe.isUndefined(A)) {
      if (p.indexOf(A) !== -1)
        throw Error("Circular reference detected in " + N.join("."));
      p.push(A), Oe.forEach(A, function(F, $) {
        (!(Oe.isUndefined(F) || F === null) && i.call(
          e,
          F,
          Oe.isString($) ? $.trim() : $,
          N,
          w
        )) === !0 && P(F, N ? N.concat($) : [$]);
      }), p.pop();
    }
  }
  if (!Oe.isObject(t))
    throw new TypeError("data must be an object");
  return P(t), e;
}
function O_(t) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(n) {
    return e[n];
  });
}
function Sb(t, e) {
  this._pairs = [], t && hp(t, this, e);
}
const PS = Sb.prototype;
PS.append = function(e, r) {
  this._pairs.push([e, r]);
};
PS.toString = function(e) {
  const r = e ? function(n) {
    return e.call(this, n, O_);
  } : O_;
  return this._pairs.map(function(i) {
    return r(i[0]) + "=" + r(i[1]);
  }, "").join("&");
};
function iX(t) {
  return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function MS(t, e, r) {
  if (!e)
    return t;
  const n = r && r.encode || iX;
  Oe.isFunction(r) && (r = {
    serialize: r
  });
  const i = r && r.serialize;
  let s;
  if (i ? s = i(e, r) : s = Oe.isURLSearchParams(e) ? e.toString() : new Sb(e, r).toString(n), s) {
    const o = t.indexOf("#");
    o !== -1 && (t = t.slice(0, o)), t += (t.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return t;
}
class N_ {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, r, n) {
    return this.handlers.push({
      fulfilled: e,
      rejected: r,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    Oe.forEach(this.handlers, function(n) {
      n !== null && e(n);
    });
  }
}
const IS = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, sX = typeof URLSearchParams < "u" ? URLSearchParams : Sb, oX = typeof FormData < "u" ? FormData : null, aX = typeof Blob < "u" ? Blob : null, cX = {
  isBrowser: !0,
  classes: {
    URLSearchParams: sX,
    FormData: oX,
    Blob: aX
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Ab = typeof window < "u" && typeof document < "u", K1 = typeof navigator == "object" && navigator || void 0, uX = Ab && (!K1 || ["ReactNative", "NativeScript", "NS"].indexOf(K1.product) < 0), fX = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", lX = Ab && window.location.href || "http://localhost", hX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Ab,
  hasStandardBrowserEnv: uX,
  hasStandardBrowserWebWorkerEnv: fX,
  navigator: K1,
  origin: lX
}, Symbol.toStringTag, { value: "Module" })), Yn = {
  ...hX,
  ...cX
};
function dX(t, e) {
  return hp(t, new Yn.classes.URLSearchParams(), Object.assign({
    visitor: function(r, n, i, s) {
      return Yn.isNode && Oe.isBuffer(r) ? (this.append(n, r.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function pX(t) {
  return Oe.matchAll(/\w+|\[(\w*)]/g, t).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function gX(t) {
  const e = {}, r = Object.keys(t);
  let n;
  const i = r.length;
  let s;
  for (n = 0; n < i; n++)
    s = r[n], e[s] = t[s];
  return e;
}
function CS(t) {
  function e(r, n, i, s) {
    let o = r[s++];
    if (o === "__proto__") return !0;
    const a = Number.isFinite(+o), u = s >= r.length;
    return o = !o && Oe.isArray(i) ? i.length : o, u ? (Oe.hasOwnProp(i, o) ? i[o] = [i[o], n] : i[o] = n, !a) : ((!i[o] || !Oe.isObject(i[o])) && (i[o] = []), e(r, n, i[o], s) && Oe.isArray(i[o]) && (i[o] = gX(i[o])), !a);
  }
  if (Oe.isFormData(t) && Oe.isFunction(t.entries)) {
    const r = {};
    return Oe.forEachEntry(t, (n, i) => {
      e(pX(n), i, r, 0);
    }), r;
  }
  return null;
}
function mX(t, e, r) {
  if (Oe.isString(t))
    try {
      return (e || JSON.parse)(t), Oe.trim(t);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (r || JSON.stringify)(t);
}
const sh = {
  transitional: IS,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, r) {
    const n = r.getContentType() || "", i = n.indexOf("application/json") > -1, s = Oe.isObject(e);
    if (s && Oe.isHTMLForm(e) && (e = new FormData(e)), Oe.isFormData(e))
      return i ? JSON.stringify(CS(e)) : e;
    if (Oe.isArrayBuffer(e) || Oe.isBuffer(e) || Oe.isStream(e) || Oe.isFile(e) || Oe.isBlob(e) || Oe.isReadableStream(e))
      return e;
    if (Oe.isArrayBufferView(e))
      return e.buffer;
    if (Oe.isURLSearchParams(e))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let a;
    if (s) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return dX(e, this.formSerializer).toString();
      if ((a = Oe.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
        const u = this.env && this.env.FormData;
        return hp(
          a ? { "files[]": e } : e,
          u && new u(),
          this.formSerializer
        );
      }
    }
    return s || i ? (r.setContentType("application/json", !1), mX(e)) : e;
  }],
  transformResponse: [function(e) {
    const r = this.transitional || sh.transitional, n = r && r.forcedJSONParsing, i = this.responseType === "json";
    if (Oe.isResponse(e) || Oe.isReadableStream(e))
      return e;
    if (e && Oe.isString(e) && (n && !this.responseType || i)) {
      const o = !(r && r.silentJSONParsing) && i;
      try {
        return JSON.parse(e);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? sr.from(a, sr.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Yn.classes.FormData,
    Blob: Yn.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
Oe.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
  sh.headers[t] = {};
});
const vX = Oe.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), bX = (t) => {
  const e = {};
  let r, n, i;
  return t && t.split(`
`).forEach(function(o) {
    i = o.indexOf(":"), r = o.substring(0, i).trim().toLowerCase(), n = o.substring(i + 1).trim(), !(!r || e[r] && vX[r]) && (r === "set-cookie" ? e[r] ? e[r].push(n) : e[r] = [n] : e[r] = e[r] ? e[r] + ", " + n : n);
  }), e;
}, L_ = Symbol("internals");
function Rf(t) {
  return t && String(t).trim().toLowerCase();
}
function kd(t) {
  return t === !1 || t == null ? t : Oe.isArray(t) ? t.map(kd) : String(t);
}
function yX(t) {
  const e = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = r.exec(t); )
    e[n[1]] = n[2];
  return e;
}
const wX = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
function Cm(t, e, r, n, i) {
  if (Oe.isFunction(n))
    return n.call(this, e, r);
  if (i && (e = r), !!Oe.isString(e)) {
    if (Oe.isString(n))
      return e.indexOf(n) !== -1;
    if (Oe.isRegExp(n))
      return n.test(e);
  }
}
function xX(t) {
  return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, r, n) => r.toUpperCase() + n);
}
function _X(t, e) {
  const r = Oe.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(t, n + r, {
      value: function(i, s, o) {
        return this[n].call(this, e, i, s, o);
      },
      configurable: !0
    });
  });
}
let yi = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, r, n) {
    const i = this;
    function s(a, u, l) {
      const d = Rf(u);
      if (!d)
        throw new Error("header name must be a non-empty string");
      const p = Oe.findKey(i, d);
      (!p || i[p] === void 0 || l === !0 || l === void 0 && i[p] !== !1) && (i[p || u] = kd(a));
    }
    const o = (a, u) => Oe.forEach(a, (l, d) => s(l, d, u));
    if (Oe.isPlainObject(e) || e instanceof this.constructor)
      o(e, r);
    else if (Oe.isString(e) && (e = e.trim()) && !wX(e))
      o(bX(e), r);
    else if (Oe.isHeaders(e))
      for (const [a, u] of e.entries())
        s(u, a, n);
    else
      e != null && s(r, e, n);
    return this;
  }
  get(e, r) {
    if (e = Rf(e), e) {
      const n = Oe.findKey(this, e);
      if (n) {
        const i = this[n];
        if (!r)
          return i;
        if (r === !0)
          return yX(i);
        if (Oe.isFunction(r))
          return r.call(this, i, n);
        if (Oe.isRegExp(r))
          return r.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, r) {
    if (e = Rf(e), e) {
      const n = Oe.findKey(this, e);
      return !!(n && this[n] !== void 0 && (!r || Cm(this, this[n], n, r)));
    }
    return !1;
  }
  delete(e, r) {
    const n = this;
    let i = !1;
    function s(o) {
      if (o = Rf(o), o) {
        const a = Oe.findKey(n, o);
        a && (!r || Cm(n, n[a], a, r)) && (delete n[a], i = !0);
      }
    }
    return Oe.isArray(e) ? e.forEach(s) : s(e), i;
  }
  clear(e) {
    const r = Object.keys(this);
    let n = r.length, i = !1;
    for (; n--; ) {
      const s = r[n];
      (!e || Cm(this, this[s], s, e, !0)) && (delete this[s], i = !0);
    }
    return i;
  }
  normalize(e) {
    const r = this, n = {};
    return Oe.forEach(this, (i, s) => {
      const o = Oe.findKey(n, s);
      if (o) {
        r[o] = kd(i), delete r[s];
        return;
      }
      const a = e ? xX(s) : String(s).trim();
      a !== s && delete r[s], r[a] = kd(i), n[a] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const r = /* @__PURE__ */ Object.create(null);
    return Oe.forEach(this, (n, i) => {
      n != null && n !== !1 && (r[i] = e && Oe.isArray(n) ? n.join(", ") : n);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, r]) => e + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...r) {
    const n = new this(e);
    return r.forEach((i) => n.set(i)), n;
  }
  static accessor(e) {
    const n = (this[L_] = this[L_] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function s(o) {
      const a = Rf(o);
      n[a] || (_X(i, o), n[a] = !0);
    }
    return Oe.isArray(e) ? e.forEach(s) : s(e), this;
  }
};
yi.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Oe.reduceDescriptors(yi.prototype, ({ value: t }, e) => {
  let r = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => t,
    set(n) {
      this[r] = n;
    }
  };
});
Oe.freezeMethods(yi);
function Tm(t, e) {
  const r = this || sh, n = e || r, i = yi.from(n.headers);
  let s = n.data;
  return Oe.forEach(t, function(a) {
    s = a.call(r, s, i.normalize(), e ? e.status : void 0);
  }), i.normalize(), s;
}
function TS(t) {
  return !!(t && t.__CANCEL__);
}
function Hu(t, e, r) {
  sr.call(this, t ?? "canceled", sr.ERR_CANCELED, e, r), this.name = "CanceledError";
}
Oe.inherits(Hu, sr, {
  __CANCEL__: !0
});
function RS(t, e, r) {
  const n = r.config.validateStatus;
  !r.status || !n || n(r.status) ? t(r) : e(new sr(
    "Request failed with status code " + r.status,
    [sr.ERR_BAD_REQUEST, sr.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
function EX(t) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
  return e && e[1] || "";
}
function SX(t, e) {
  t = t || 10;
  const r = new Array(t), n = new Array(t);
  let i = 0, s = 0, o;
  return e = e !== void 0 ? e : 1e3, function(u) {
    const l = Date.now(), d = n[s];
    o || (o = l), r[i] = u, n[i] = l;
    let p = s, w = 0;
    for (; p !== i; )
      w += r[p++], p = p % t;
    if (i = (i + 1) % t, i === s && (s = (s + 1) % t), l - o < e)
      return;
    const P = d && l - d;
    return P ? Math.round(w * 1e3 / P) : void 0;
  };
}
function AX(t, e) {
  let r = 0, n = 1e3 / e, i, s;
  const o = (l, d = Date.now()) => {
    r = d, i = null, s && (clearTimeout(s), s = null), t.apply(null, l);
  };
  return [(...l) => {
    const d = Date.now(), p = d - r;
    p >= n ? o(l, d) : (i = l, s || (s = setTimeout(() => {
      s = null, o(i);
    }, n - p)));
  }, () => i && o(i)];
}
const p0 = (t, e, r = 3) => {
  let n = 0;
  const i = SX(50, 250);
  return AX((s) => {
    const o = s.loaded, a = s.lengthComputable ? s.total : void 0, u = o - n, l = i(u), d = o <= a;
    n = o;
    const p = {
      loaded: o,
      total: a,
      progress: a ? o / a : void 0,
      bytes: u,
      rate: l || void 0,
      estimated: l && a && d ? (a - o) / l : void 0,
      event: s,
      lengthComputable: a != null,
      [e ? "download" : "upload"]: !0
    };
    t(p);
  }, r);
}, k_ = (t, e) => {
  const r = t != null;
  return [(n) => e[0]({
    lengthComputable: r,
    total: t,
    loaded: n
  }), e[1]];
}, $_ = (t) => (...e) => Oe.asap(() => t(...e)), PX = Yn.hasStandardBrowserEnv ? /* @__PURE__ */ ((t, e) => (r) => (r = new URL(r, Yn.origin), t.protocol === r.protocol && t.host === r.host && (e || t.port === r.port)))(
  new URL(Yn.origin),
  Yn.navigator && /(msie|trident)/i.test(Yn.navigator.userAgent)
) : () => !0, MX = Yn.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(t, e, r, n, i, s) {
      const o = [t + "=" + encodeURIComponent(e)];
      Oe.isNumber(r) && o.push("expires=" + new Date(r).toGMTString()), Oe.isString(n) && o.push("path=" + n), Oe.isString(i) && o.push("domain=" + i), s === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(t) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(t) {
      this.write(t, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function IX(t) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
}
function CX(t, e) {
  return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t;
}
function DS(t, e) {
  return t && !IX(e) ? CX(t, e) : e;
}
const F_ = (t) => t instanceof yi ? { ...t } : t;
function pc(t, e) {
  e = e || {};
  const r = {};
  function n(l, d, p, w) {
    return Oe.isPlainObject(l) && Oe.isPlainObject(d) ? Oe.merge.call({ caseless: w }, l, d) : Oe.isPlainObject(d) ? Oe.merge({}, d) : Oe.isArray(d) ? d.slice() : d;
  }
  function i(l, d, p, w) {
    if (Oe.isUndefined(d)) {
      if (!Oe.isUndefined(l))
        return n(void 0, l, p, w);
    } else return n(l, d, p, w);
  }
  function s(l, d) {
    if (!Oe.isUndefined(d))
      return n(void 0, d);
  }
  function o(l, d) {
    if (Oe.isUndefined(d)) {
      if (!Oe.isUndefined(l))
        return n(void 0, l);
    } else return n(void 0, d);
  }
  function a(l, d, p) {
    if (p in e)
      return n(l, d);
    if (p in t)
      return n(void 0, l);
  }
  const u = {
    url: s,
    method: s,
    data: s,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (l, d, p) => i(F_(l), F_(d), p, !0)
  };
  return Oe.forEach(Object.keys(Object.assign({}, t, e)), function(d) {
    const p = u[d] || i, w = p(t[d], e[d], d);
    Oe.isUndefined(w) && p !== a || (r[d] = w);
  }), r;
}
const OS = (t) => {
  const e = pc({}, t);
  let { data: r, withXSRFToken: n, xsrfHeaderName: i, xsrfCookieName: s, headers: o, auth: a } = e;
  e.headers = o = yi.from(o), e.url = MS(DS(e.baseURL, e.url), t.params, t.paramsSerializer), a && o.set(
    "Authorization",
    "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
  );
  let u;
  if (Oe.isFormData(r)) {
    if (Yn.hasStandardBrowserEnv || Yn.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if ((u = o.getContentType()) !== !1) {
      const [l, ...d] = u ? u.split(";").map((p) => p.trim()).filter(Boolean) : [];
      o.setContentType([l || "multipart/form-data", ...d].join("; "));
    }
  }
  if (Yn.hasStandardBrowserEnv && (n && Oe.isFunction(n) && (n = n(e)), n || n !== !1 && PX(e.url))) {
    const l = i && s && MX.read(s);
    l && o.set(i, l);
  }
  return e;
}, TX = typeof XMLHttpRequest < "u", RX = TX && function(t) {
  return new Promise(function(r, n) {
    const i = OS(t);
    let s = i.data;
    const o = yi.from(i.headers).normalize();
    let { responseType: a, onUploadProgress: u, onDownloadProgress: l } = i, d, p, w, P, A;
    function N() {
      P && P(), A && A(), i.cancelToken && i.cancelToken.unsubscribe(d), i.signal && i.signal.removeEventListener("abort", d);
    }
    let L = new XMLHttpRequest();
    L.open(i.method.toUpperCase(), i.url, !0), L.timeout = i.timeout;
    function F() {
      if (!L)
        return;
      const K = yi.from(
        "getAllResponseHeaders" in L && L.getAllResponseHeaders()
      ), V = {
        data: !a || a === "text" || a === "json" ? L.responseText : L.response,
        status: L.status,
        statusText: L.statusText,
        headers: K,
        config: t,
        request: L
      };
      RS(function(R) {
        r(R), N();
      }, function(R) {
        n(R), N();
      }, V), L = null;
    }
    "onloadend" in L ? L.onloadend = F : L.onreadystatechange = function() {
      !L || L.readyState !== 4 || L.status === 0 && !(L.responseURL && L.responseURL.indexOf("file:") === 0) || setTimeout(F);
    }, L.onabort = function() {
      L && (n(new sr("Request aborted", sr.ECONNABORTED, t, L)), L = null);
    }, L.onerror = function() {
      n(new sr("Network Error", sr.ERR_NETWORK, t, L)), L = null;
    }, L.ontimeout = function() {
      let H = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const V = i.transitional || IS;
      i.timeoutErrorMessage && (H = i.timeoutErrorMessage), n(new sr(
        H,
        V.clarifyTimeoutError ? sr.ETIMEDOUT : sr.ECONNABORTED,
        t,
        L
      )), L = null;
    }, s === void 0 && o.setContentType(null), "setRequestHeader" in L && Oe.forEach(o.toJSON(), function(H, V) {
      L.setRequestHeader(V, H);
    }), Oe.isUndefined(i.withCredentials) || (L.withCredentials = !!i.withCredentials), a && a !== "json" && (L.responseType = i.responseType), l && ([w, A] = p0(l, !0), L.addEventListener("progress", w)), u && L.upload && ([p, P] = p0(u), L.upload.addEventListener("progress", p), L.upload.addEventListener("loadend", P)), (i.cancelToken || i.signal) && (d = (K) => {
      L && (n(!K || K.type ? new Hu(null, t, L) : K), L.abort(), L = null);
    }, i.cancelToken && i.cancelToken.subscribe(d), i.signal && (i.signal.aborted ? d() : i.signal.addEventListener("abort", d)));
    const $ = EX(i.url);
    if ($ && Yn.protocols.indexOf($) === -1) {
      n(new sr("Unsupported protocol " + $ + ":", sr.ERR_BAD_REQUEST, t));
      return;
    }
    L.send(s || null);
  });
}, DX = (t, e) => {
  const { length: r } = t = t ? t.filter(Boolean) : [];
  if (e || r) {
    let n = new AbortController(), i;
    const s = function(l) {
      if (!i) {
        i = !0, a();
        const d = l instanceof Error ? l : this.reason;
        n.abort(d instanceof sr ? d : new Hu(d instanceof Error ? d.message : d));
      }
    };
    let o = e && setTimeout(() => {
      o = null, s(new sr(`timeout ${e} of ms exceeded`, sr.ETIMEDOUT));
    }, e);
    const a = () => {
      t && (o && clearTimeout(o), o = null, t.forEach((l) => {
        l.unsubscribe ? l.unsubscribe(s) : l.removeEventListener("abort", s);
      }), t = null);
    };
    t.forEach((l) => l.addEventListener("abort", s));
    const { signal: u } = n;
    return u.unsubscribe = () => Oe.asap(a), u;
  }
}, OX = function* (t, e) {
  let r = t.byteLength;
  if (r < e) {
    yield t;
    return;
  }
  let n = 0, i;
  for (; n < r; )
    i = n + e, yield t.slice(n, i), n = i;
}, NX = async function* (t, e) {
  for await (const r of LX(t))
    yield* OX(r, e);
}, LX = async function* (t) {
  if (t[Symbol.asyncIterator]) {
    yield* t;
    return;
  }
  const e = t.getReader();
  try {
    for (; ; ) {
      const { done: r, value: n } = await e.read();
      if (r)
        break;
      yield n;
    }
  } finally {
    await e.cancel();
  }
}, B_ = (t, e, r, n) => {
  const i = NX(t, e);
  let s = 0, o, a = (u) => {
    o || (o = !0, n && n(u));
  };
  return new ReadableStream({
    async pull(u) {
      try {
        const { done: l, value: d } = await i.next();
        if (l) {
          a(), u.close();
          return;
        }
        let p = d.byteLength;
        if (r) {
          let w = s += p;
          r(w);
        }
        u.enqueue(new Uint8Array(d));
      } catch (l) {
        throw a(l), l;
      }
    },
    cancel(u) {
      return a(u), i.return();
    }
  }, {
    highWaterMark: 2
  });
}, dp = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", NS = dp && typeof ReadableStream == "function", kX = dp && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((t) => (e) => t.encode(e))(new TextEncoder()) : async (t) => new Uint8Array(await new Response(t).arrayBuffer())), LS = (t, ...e) => {
  try {
    return !!t(...e);
  } catch {
    return !1;
  }
}, $X = NS && LS(() => {
  let t = !1;
  const e = new Request(Yn.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return t = !0, "half";
    }
  }).headers.has("Content-Type");
  return t && !e;
}), U_ = 64 * 1024, V1 = NS && LS(() => Oe.isReadableStream(new Response("").body)), g0 = {
  stream: V1 && ((t) => t.body)
};
dp && ((t) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !g0[e] && (g0[e] = Oe.isFunction(t[e]) ? (r) => r[e]() : (r, n) => {
      throw new sr(`Response type '${e}' is not supported`, sr.ERR_NOT_SUPPORT, n);
    });
  });
})(new Response());
const FX = async (t) => {
  if (t == null)
    return 0;
  if (Oe.isBlob(t))
    return t.size;
  if (Oe.isSpecCompliantForm(t))
    return (await new Request(Yn.origin, {
      method: "POST",
      body: t
    }).arrayBuffer()).byteLength;
  if (Oe.isArrayBufferView(t) || Oe.isArrayBuffer(t))
    return t.byteLength;
  if (Oe.isURLSearchParams(t) && (t = t + ""), Oe.isString(t))
    return (await kX(t)).byteLength;
}, BX = async (t, e) => {
  const r = Oe.toFiniteNumber(t.getContentLength());
  return r ?? FX(e);
}, UX = dp && (async (t) => {
  let {
    url: e,
    method: r,
    data: n,
    signal: i,
    cancelToken: s,
    timeout: o,
    onDownloadProgress: a,
    onUploadProgress: u,
    responseType: l,
    headers: d,
    withCredentials: p = "same-origin",
    fetchOptions: w
  } = OS(t);
  l = l ? (l + "").toLowerCase() : "text";
  let P = DX([i, s && s.toAbortSignal()], o), A;
  const N = P && P.unsubscribe && (() => {
    P.unsubscribe();
  });
  let L;
  try {
    if (u && $X && r !== "get" && r !== "head" && (L = await BX(d, n)) !== 0) {
      let V = new Request(e, {
        method: "POST",
        body: n,
        duplex: "half"
      }), te;
      if (Oe.isFormData(n) && (te = V.headers.get("content-type")) && d.setContentType(te), V.body) {
        const [R, W] = k_(
          L,
          p0($_(u))
        );
        n = B_(V.body, U_, R, W);
      }
    }
    Oe.isString(p) || (p = p ? "include" : "omit");
    const F = "credentials" in Request.prototype;
    A = new Request(e, {
      ...w,
      signal: P,
      method: r.toUpperCase(),
      headers: d.normalize().toJSON(),
      body: n,
      duplex: "half",
      credentials: F ? p : void 0
    });
    let $ = await fetch(A);
    const K = V1 && (l === "stream" || l === "response");
    if (V1 && (a || K && N)) {
      const V = {};
      ["status", "statusText", "headers"].forEach((pe) => {
        V[pe] = $[pe];
      });
      const te = Oe.toFiniteNumber($.headers.get("content-length")), [R, W] = a && k_(
        te,
        p0($_(a), !0)
      ) || [];
      $ = new Response(
        B_($.body, U_, R, () => {
          W && W(), N && N();
        }),
        V
      );
    }
    l = l || "text";
    let H = await g0[Oe.findKey(g0, l) || "text"]($, t);
    return !K && N && N(), await new Promise((V, te) => {
      RS(V, te, {
        data: H,
        headers: yi.from($.headers),
        status: $.status,
        statusText: $.statusText,
        config: t,
        request: A
      });
    });
  } catch (F) {
    throw N && N(), F && F.name === "TypeError" && /fetch/i.test(F.message) ? Object.assign(
      new sr("Network Error", sr.ERR_NETWORK, t, A),
      {
        cause: F.cause || F
      }
    ) : sr.from(F, F && F.code, t, A);
  }
}), G1 = {
  http: tX,
  xhr: RX,
  fetch: UX
};
Oe.forEach(G1, (t, e) => {
  if (t) {
    try {
      Object.defineProperty(t, "name", { value: e });
    } catch {
    }
    Object.defineProperty(t, "adapterName", { value: e });
  }
});
const j_ = (t) => `- ${t}`, jX = (t) => Oe.isFunction(t) || t === null || t === !1, kS = {
  getAdapter: (t) => {
    t = Oe.isArray(t) ? t : [t];
    const { length: e } = t;
    let r, n;
    const i = {};
    for (let s = 0; s < e; s++) {
      r = t[s];
      let o;
      if (n = r, !jX(r) && (n = G1[(o = String(r)).toLowerCase()], n === void 0))
        throw new sr(`Unknown adapter '${o}'`);
      if (n)
        break;
      i[o || "#" + s] = n;
    }
    if (!n) {
      const s = Object.entries(i).map(
        ([a, u]) => `adapter ${a} ` + (u === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = e ? s.length > 1 ? `since :
` + s.map(j_).join(`
`) : " " + j_(s[0]) : "as no adapter specified";
      throw new sr(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return n;
  },
  adapters: G1
};
function Rm(t) {
  if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)
    throw new Hu(null, t);
}
function q_(t) {
  return Rm(t), t.headers = yi.from(t.headers), t.data = Tm.call(
    t,
    t.transformRequest
  ), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), kS.getAdapter(t.adapter || sh.adapter)(t).then(function(n) {
    return Rm(t), n.data = Tm.call(
      t,
      t.transformResponse,
      n
    ), n.headers = yi.from(n.headers), n;
  }, function(n) {
    return TS(n) || (Rm(t), n && n.response && (n.response.data = Tm.call(
      t,
      t.transformResponse,
      n.response
    ), n.response.headers = yi.from(n.response.headers))), Promise.reject(n);
  });
}
const $S = "1.7.8", pp = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
  pp[t] = function(n) {
    return typeof n === t || "a" + (e < 1 ? "n " : " ") + t;
  };
});
const z_ = {};
pp.transitional = function(e, r, n) {
  function i(s, o) {
    return "[Axios v" + $S + "] Transitional option '" + s + "'" + o + (n ? ". " + n : "");
  }
  return (s, o, a) => {
    if (e === !1)
      throw new sr(
        i(o, " has been removed" + (r ? " in " + r : "")),
        sr.ERR_DEPRECATED
      );
    return r && !z_[o] && (z_[o] = !0, console.warn(
      i(
        o,
        " has been deprecated since v" + r + " and will be removed in the near future"
      )
    )), e ? e(s, o, a) : !0;
  };
};
pp.spelling = function(e) {
  return (r, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0);
};
function qX(t, e, r) {
  if (typeof t != "object")
    throw new sr("options must be an object", sr.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(t);
  let i = n.length;
  for (; i-- > 0; ) {
    const s = n[i], o = e[s];
    if (o) {
      const a = t[s], u = a === void 0 || o(a, s, t);
      if (u !== !0)
        throw new sr("option " + s + " must be " + u, sr.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new sr("Unknown option " + s, sr.ERR_BAD_OPTION);
  }
}
const $d = {
  assertOptions: qX,
  validators: pp
}, $s = $d.validators;
let oc = class {
  constructor(e) {
    this.defaults = e, this.interceptors = {
      request: new N_(),
      response: new N_()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, r) {
    try {
      return await this._request(e, r);
    } catch (n) {
      if (n instanceof Error) {
        let i = {};
        Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error();
        const s = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? s && !String(n.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + s) : n.stack = s;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(e, r) {
    typeof e == "string" ? (r = r || {}, r.url = e) : r = e || {}, r = pc(this.defaults, r);
    const { transitional: n, paramsSerializer: i, headers: s } = r;
    n !== void 0 && $d.assertOptions(n, {
      silentJSONParsing: $s.transitional($s.boolean),
      forcedJSONParsing: $s.transitional($s.boolean),
      clarifyTimeoutError: $s.transitional($s.boolean)
    }, !1), i != null && (Oe.isFunction(i) ? r.paramsSerializer = {
      serialize: i
    } : $d.assertOptions(i, {
      encode: $s.function,
      serialize: $s.function
    }, !0)), $d.assertOptions(r, {
      baseUrl: $s.spelling("baseURL"),
      withXsrfToken: $s.spelling("withXSRFToken")
    }, !0), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let o = s && Oe.merge(
      s.common,
      s[r.method]
    );
    s && Oe.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (A) => {
        delete s[A];
      }
    ), r.headers = yi.concat(o, s);
    const a = [];
    let u = !0;
    this.interceptors.request.forEach(function(N) {
      typeof N.runWhen == "function" && N.runWhen(r) === !1 || (u = u && N.synchronous, a.unshift(N.fulfilled, N.rejected));
    });
    const l = [];
    this.interceptors.response.forEach(function(N) {
      l.push(N.fulfilled, N.rejected);
    });
    let d, p = 0, w;
    if (!u) {
      const A = [q_.bind(this), void 0];
      for (A.unshift.apply(A, a), A.push.apply(A, l), w = A.length, d = Promise.resolve(r); p < w; )
        d = d.then(A[p++], A[p++]);
      return d;
    }
    w = a.length;
    let P = r;
    for (p = 0; p < w; ) {
      const A = a[p++], N = a[p++];
      try {
        P = A(P);
      } catch (L) {
        N.call(this, L);
        break;
      }
    }
    try {
      d = q_.call(this, P);
    } catch (A) {
      return Promise.reject(A);
    }
    for (p = 0, w = l.length; p < w; )
      d = d.then(l[p++], l[p++]);
    return d;
  }
  getUri(e) {
    e = pc(this.defaults, e);
    const r = DS(e.baseURL, e.url);
    return MS(r, e.params, e.paramsSerializer);
  }
};
Oe.forEach(["delete", "get", "head", "options"], function(e) {
  oc.prototype[e] = function(r, n) {
    return this.request(pc(n || {}, {
      method: e,
      url: r,
      data: (n || {}).data
    }));
  };
});
Oe.forEach(["post", "put", "patch"], function(e) {
  function r(n) {
    return function(s, o, a) {
      return this.request(pc(a || {}, {
        method: e,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: o
      }));
    };
  }
  oc.prototype[e] = r(), oc.prototype[e + "Form"] = r(!0);
});
let zX = class FS {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(s) {
      r = s;
    });
    const n = this;
    this.promise.then((i) => {
      if (!n._listeners) return;
      let s = n._listeners.length;
      for (; s-- > 0; )
        n._listeners[s](i);
      n._listeners = null;
    }), this.promise.then = (i) => {
      let s;
      const o = new Promise((a) => {
        n.subscribe(a), s = a;
      }).then(i);
      return o.cancel = function() {
        n.unsubscribe(s);
      }, o;
    }, e(function(s, o, a) {
      n.reason || (n.reason = new Hu(s, o, a), r(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(e);
    r !== -1 && this._listeners.splice(r, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), r = (n) => {
      e.abort(n);
    };
    return this.subscribe(r), e.signal.unsubscribe = () => this.unsubscribe(r), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new FS(function(i) {
        e = i;
      }),
      cancel: e
    };
  }
};
function HX(t) {
  return function(r) {
    return t.apply(null, r);
  };
}
function WX(t) {
  return Oe.isObject(t) && t.isAxiosError === !0;
}
const Y1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Y1).forEach(([t, e]) => {
  Y1[e] = t;
});
function BS(t) {
  const e = new oc(t), r = gS(oc.prototype.request, e);
  return Oe.extend(r, oc.prototype, e, { allOwnKeys: !0 }), Oe.extend(r, e, null, { allOwnKeys: !0 }), r.create = function(i) {
    return BS(pc(t, i));
  }, r;
}
const mn = BS(sh);
mn.Axios = oc;
mn.CanceledError = Hu;
mn.CancelToken = zX;
mn.isCancel = TS;
mn.VERSION = $S;
mn.toFormData = hp;
mn.AxiosError = sr;
mn.Cancel = mn.CanceledError;
mn.all = function(e) {
  return Promise.all(e);
};
mn.spread = HX;
mn.isAxiosError = WX;
mn.mergeConfig = pc;
mn.AxiosHeaders = yi;
mn.formToJSON = (t) => CS(Oe.isHTMLForm(t) ? new FormData(t) : t);
mn.getAdapter = kS.getAdapter;
mn.HttpStatusCode = Y1;
mn.default = mn;
const {
  Axios: Jse,
  AxiosError: KX,
  CanceledError: Xse,
  isCancel: Zse,
  CancelToken: Qse,
  VERSION: eoe,
  all: toe,
  Cancel: roe,
  isAxiosError: noe,
  spread: ioe,
  toFormData: soe,
  AxiosHeaders: ooe,
  HttpStatusCode: aoe,
  formToJSON: coe,
  getAdapter: uoe,
  mergeConfig: foe
} = mn, US = mn.create({
  timeout: 6e4,
  headers: {
    "Content-Type": "application/json"
  }
});
function VX(t) {
  var e, r, n;
  if (((e = t.data) == null ? void 0 : e.success) !== !0) {
    const i = new KX(
      (r = t.data) == null ? void 0 : r.errorMessage,
      (n = t.data) == null ? void 0 : n.errorCode,
      t.config,
      t.request,
      t
    );
    return Promise.reject(i);
  } else
    return t;
}
US.interceptors.response.use(
  VX
);
class GX {
  constructor(e) {
    Rs(this, "_apiBase", "");
    this.request = e;
  }
  setApiBase(e) {
    this._apiBase = e || "";
  }
  async getNonce(e) {
    const { data: r } = await this.request.post(`${this._apiBase}/api/v2/user/nonce`, e);
    return r.data;
  }
  async getEmailCode(e) {
    const { data: r } = await this.request.post(`${this._apiBase}/api/v2/user/get_code`, e);
    return r.data;
  }
  async emailLogin(e) {
    return (await this.request.post(`${this._apiBase}/api/v2/user/login`, e)).data;
  }
  async walletLogin(e) {
    return (await this.request.post(`${this._apiBase}/api/v2/user/login`, e)).data;
  }
  async tonLogin(e) {
    return (await this.request.post(`${this._apiBase}/api/v2/user/login`, e)).data;
  }
}
const ya = new GX(US), YX = {
  projectId: "7a4434fefbcc9af474fb5c995e47d286",
  metadata: {
    name: "codatta",
    description: "codatta",
    url: "https://codatta.io/",
    icons: ["https://avatars.githubusercontent.com/u/171659315"]
  }
}, JX = gJ({
  appName: "codatta",
  appLogoUrl: "https://avatars.githubusercontent.com/u/171659315"
}), jS = Sa({
  saveLastUsedWallet: () => {
  },
  lastUsedWallet: null,
  wallets: [],
  initialized: !1,
  featuredWallets: []
});
function gp() {
  return Tn(jS);
}
function loe(t) {
  const { apiBaseUrl: e } = t, [r, n] = fr([]), [i, s] = fr([]), [o, a] = fr(null), [u, l] = fr(!1), d = (P) => {
    console.log("saveLastUsedWallet", P);
  };
  function p(P) {
    const A = P.filter((F) => F.featured || F.installed), N = P.filter((F) => !F.featured && !F.installed), L = [...A, ...N];
    n(L), s(A);
  }
  async function w() {
    const P = [], A = /* @__PURE__ */ new Map();
    RR.forEach((L) => {
      const F = new ml(L);
      L.name === "Coinbase Wallet" && F.EIP6963Detected({
        info: { name: "Coinbase Wallet", uuid: "coinbase", icon: L.image, rdns: "coinbase" },
        provider: JX.getProvider()
      }), A.set(F.key, F), P.push(F);
    }), (await TG()).forEach((L) => {
      const F = A.get(L.info.name);
      if (F)
        F.EIP6963Detected(L);
      else {
        const $ = new ml(L);
        A.set($.key, $), P.push($);
      }
    });
    try {
      const L = JSON.parse(localStorage.getItem("xn-last-used-info") || "{}"), F = A.get(L.key);
      if (F) {
        if (F.lastUsed = !0, L.provider === "UniversalProvider") {
          const $ = await EE.init(YX);
          $.session && F.setUniversalProvider($);
        }
        a(F);
      }
    } catch (L) {
      console.log(L);
    }
    p(P), l(!0);
  }
  return Xn(() => {
    w(), ya.setApiBase(e);
  }, []), /* @__PURE__ */ me.jsx(
    jS.Provider,
    {
      value: {
        saveLastUsedWallet: d,
        wallets: r,
        initialized: u,
        lastUsedWallet: o,
        featuredWallets: i
      },
      children: t.children
    }
  );
}
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const XX = (t) => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), qS = (...t) => t.filter((e, r, n) => !!e && e.trim() !== "" && n.indexOf(e) === r).join(" ").trim();
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var ZX = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const QX = gv(
  ({
    color: t = "currentColor",
    size: e = 24,
    strokeWidth: r = 2,
    absoluteStrokeWidth: n,
    className: i = "",
    children: s,
    iconNode: o,
    ...a
  }, u) => jd(
    "svg",
    {
      ref: u,
      ...ZX,
      width: e,
      height: e,
      stroke: t,
      strokeWidth: n ? Number(r) * 24 / Number(e) : r,
      className: qS("lucide", i),
      ...a
    },
    [
      ...o.map(([l, d]) => jd(l, d)),
      ...Array.isArray(s) ? s : [s]
    ]
  )
);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ps = (t, e) => {
  const r = gv(
    ({ className: n, ...i }, s) => jd(QX, {
      ref: s,
      iconNode: e,
      className: qS(`lucide-${XX(t)}`, n),
      ...i
    })
  );
  return r.displayName = `${t}`, r;
};
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const eZ = Ps("ArrowLeft", [
  ["path", { d: "m12 19-7-7 7-7", key: "1l729n" }],
  ["path", { d: "M19 12H5", key: "x3x0zl" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const zS = Ps("ArrowRight", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const tZ = Ps("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const rZ = Ps("CircleCheckBig", [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const nZ = Ps("Download", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }],
  ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const iZ = Ps("Globe", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" }],
  ["path", { d: "M2 12h20", key: "9i4pu4" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const HS = Ps("Laptop", [
  [
    "path",
    {
      d: "M20 16V7a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v9m16 0H4m16 0 1.28 2.55a1 1 0 0 1-.9 1.45H3.62a1 1 0 0 1-.9-1.45L4 16",
      key: "tarvll"
    }
  ]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const sZ = Ps("Link2", [
  ["path", { d: "M9 17H7A5 5 0 0 1 7 7h2", key: "8i5ue5" }],
  ["path", { d: "M15 7h2a5 5 0 1 1 0 10h-2", key: "1b9ql8" }],
  ["line", { x1: "8", x2: "16", y1: "12", y2: "12", key: "1jonct" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const gc = Ps("LoaderCircle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const oZ = Ps("Mail", [
  ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" }],
  ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7", key: "1ocrg3" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const WS = Ps("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
]), H_ = /* @__PURE__ */ new Set();
function mp(t, e, r) {
  t || H_.has(e) || (console.warn(e), H_.add(e));
}
function aZ(t) {
  if (typeof Proxy > "u")
    return t;
  const e = /* @__PURE__ */ new Map(), r = (...n) => (process.env.NODE_ENV !== "production" && mp(!1, "motion() is deprecated. Use motion.create() instead."), t(...n));
  return new Proxy(r, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (n, i) => i === "create" ? t : (e.has(i) || e.set(i, t(i)), e.get(i))
  });
}
function vp(t) {
  return t !== null && typeof t == "object" && typeof t.start == "function";
}
const J1 = (t) => Array.isArray(t);
function KS(t, e) {
  if (!Array.isArray(e))
    return !1;
  const r = e.length;
  if (r !== t.length)
    return !1;
  for (let n = 0; n < r; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function Ml(t) {
  return typeof t == "string" || Array.isArray(t);
}
function W_(t) {
  const e = [{}, {}];
  return t == null || t.values.forEach((r, n) => {
    e[0][n] = r.get(), e[1][n] = r.getVelocity();
  }), e;
}
function Pb(t, e, r, n) {
  if (typeof e == "function") {
    const [i, s] = W_(n);
    e = e(r !== void 0 ? r : t.custom, i, s);
  }
  if (typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function") {
    const [i, s] = W_(n);
    e = e(r !== void 0 ? r : t.custom, i, s);
  }
  return e;
}
function bp(t, e, r) {
  const n = t.getProps();
  return Pb(n, e, r !== void 0 ? r : n.custom, t);
}
const Mb = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], Ib = ["initial", ...Mb], oh = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], Sc = new Set(oh), Ks = (t) => t * 1e3, Co = (t) => t / 1e3, cZ = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, uZ = (t) => ({
  type: "spring",
  stiffness: 550,
  damping: t === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), fZ = {
  type: "keyframes",
  duration: 0.8
}, lZ = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, hZ = (t, { keyframes: e }) => e.length > 2 ? fZ : Sc.has(t) ? t.startsWith("scale") ? uZ(e[1]) : cZ : lZ;
function Cb(t, e) {
  return t ? t[e] || t.default || t : void 0;
}
const dZ = {
  useManualTiming: !1
}, pZ = (t) => t !== null;
function yp(t, { repeat: e, repeatType: r = "loop" }, n) {
  const i = t.filter(pZ), s = e && r !== "loop" && e % 2 === 1 ? 0 : i.length - 1;
  return !s || n === void 0 ? i[s] : n;
}
const Un = (t) => t;
function gZ(t) {
  let e = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), n = !1, i = !1;
  const s = /* @__PURE__ */ new WeakSet();
  let o = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function a(l) {
    s.has(l) && (u.schedule(l), t()), l(o);
  }
  const u = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (l, d = !1, p = !1) => {
      const P = p && n ? e : r;
      return d && s.add(l), P.has(l) || P.add(l), l;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (l) => {
      r.delete(l), s.delete(l);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (l) => {
      if (o = l, n) {
        i = !0;
        return;
      }
      n = !0, [e, r] = [r, e], r.clear(), e.forEach(a), n = !1, i && (i = !1, u.process(l));
    }
  };
  return u;
}
const pd = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
], mZ = 40;
function VS(t, e) {
  let r = !1, n = !0;
  const i = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, s = () => r = !0, o = pd.reduce((F, $) => (F[$] = gZ(s), F), {}), { read: a, resolveKeyframes: u, update: l, preRender: d, render: p, postRender: w } = o, P = () => {
    const F = performance.now();
    r = !1, i.delta = n ? 1e3 / 60 : Math.max(Math.min(F - i.timestamp, mZ), 1), i.timestamp = F, i.isProcessing = !0, a.process(i), u.process(i), l.process(i), d.process(i), p.process(i), w.process(i), i.isProcessing = !1, r && e && (n = !1, t(P));
  }, A = () => {
    r = !0, n = !0, i.isProcessing || t(P);
  };
  return { schedule: pd.reduce((F, $) => {
    const K = o[$];
    return F[$] = (H, V = !1, te = !1) => (r || A(), K.schedule(H, V, te)), F;
  }, {}), cancel: (F) => {
    for (let $ = 0; $ < pd.length; $++)
      o[pd[$]].cancel(F);
  }, state: i, steps: o };
}
const { schedule: Lr, cancel: wa, state: Fn, steps: Dm } = VS(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Un, !0), GS = (t, e, r) => (((1 - 3 * r + 3 * e) * t + (3 * r - 6 * e)) * t + 3 * e) * t, vZ = 1e-7, bZ = 12;
function yZ(t, e, r, n, i) {
  let s, o, a = 0;
  do
    o = e + (r - e) / 2, s = GS(o, n, i) - t, s > 0 ? r = o : e = o;
  while (Math.abs(s) > vZ && ++a < bZ);
  return o;
}
function ah(t, e, r, n) {
  if (t === e && r === n)
    return Un;
  const i = (s) => yZ(s, 0, 1, t, r);
  return (s) => s === 0 || s === 1 ? s : GS(i(s), e, n);
}
const YS = (t) => (e) => e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, JS = (t) => (e) => 1 - t(1 - e), XS = /* @__PURE__ */ ah(0.33, 1.53, 0.69, 0.99), Tb = /* @__PURE__ */ JS(XS), ZS = /* @__PURE__ */ YS(Tb), QS = (t) => (t *= 2) < 1 ? 0.5 * Tb(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))), Rb = (t) => 1 - Math.sin(Math.acos(t)), e7 = JS(Rb), t7 = YS(Rb), r7 = (t) => /^0[^.\s]+$/u.test(t);
function wZ(t) {
  return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || r7(t) : !0;
}
let Wu = Un, Uo = Un;
process.env.NODE_ENV !== "production" && (Wu = (t, e) => {
  !t && typeof console < "u" && console.warn(e);
}, Uo = (t, e) => {
  if (!t)
    throw new Error(e);
});
const n7 = (t) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t), i7 = (t) => (e) => typeof e == "string" && e.startsWith(t), s7 = /* @__PURE__ */ i7("--"), xZ = /* @__PURE__ */ i7("var(--"), Db = (t) => xZ(t) ? _Z.test(t.split("/*")[0].trim()) : !1, _Z = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, EZ = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function SZ(t) {
  const e = EZ.exec(t);
  if (!e)
    return [,];
  const [, r, n, i] = e;
  return [`--${r ?? n}`, i];
}
const AZ = 4;
function o7(t, e, r = 1) {
  Uo(r <= AZ, `Max CSS variable fallback depth detected in property "${t}". This may indicate a circular fallback dependency.`);
  const [n, i] = SZ(t);
  if (!n)
    return;
  const s = window.getComputedStyle(e).getPropertyValue(n);
  if (s) {
    const o = s.trim();
    return n7(o) ? parseFloat(o) : o;
  }
  return Db(i) ? o7(i, e, r + 1) : i;
}
const xa = (t, e, r) => r > e ? e : r < t ? t : r, Ku = {
  test: (t) => typeof t == "number",
  parse: parseFloat,
  transform: (t) => t
}, Il = {
  ...Ku,
  transform: (t) => xa(0, 1, t)
}, gd = {
  ...Ku,
  default: 1
}, ch = (t) => ({
  test: (e) => typeof e == "string" && e.endsWith(t) && e.split(" ").length === 1,
  parse: parseFloat,
  transform: (e) => `${e}${t}`
}), sa = /* @__PURE__ */ ch("deg"), Vs = /* @__PURE__ */ ch("%"), Vt = /* @__PURE__ */ ch("px"), PZ = /* @__PURE__ */ ch("vh"), MZ = /* @__PURE__ */ ch("vw"), K_ = {
  ...Vs,
  parse: (t) => Vs.parse(t) / 100,
  transform: (t) => Vs.transform(t * 100)
}, IZ = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]), V_ = (t) => t === Ku || t === Vt, G_ = (t, e) => parseFloat(t.split(", ")[e]), Y_ = (t, e) => (r, { transform: n }) => {
  if (n === "none" || !n)
    return 0;
  const i = n.match(/^matrix3d\((.+)\)$/u);
  if (i)
    return G_(i[1], e);
  {
    const s = n.match(/^matrix\((.+)\)$/u);
    return s ? G_(s[1], t) : 0;
  }
}, CZ = /* @__PURE__ */ new Set(["x", "y", "z"]), TZ = oh.filter((t) => !CZ.has(t));
function RZ(t) {
  const e = [];
  return TZ.forEach((r) => {
    const n = t.getValue(r);
    n !== void 0 && (e.push([r, n.get()]), n.set(r.startsWith("scale") ? 1 : 0));
  }), e;
}
const Pu = {
  // Dimensions
  width: ({ x: t }, { paddingLeft: e = "0", paddingRight: r = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(r),
  height: ({ y: t }, { paddingTop: e = "0", paddingBottom: r = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(r),
  top: (t, { top: e }) => parseFloat(e),
  left: (t, { left: e }) => parseFloat(e),
  bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min),
  right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min),
  // Transform
  x: Y_(4, 13),
  y: Y_(5, 14)
};
Pu.translateX = Pu.x;
Pu.translateY = Pu.y;
const a7 = (t) => (e) => e.test(t), DZ = {
  test: (t) => t === "auto",
  parse: (t) => t
}, c7 = [Ku, Vt, Vs, sa, MZ, PZ, DZ], J_ = (t) => c7.find(a7(t)), ac = /* @__PURE__ */ new Set();
let X1 = !1, Z1 = !1;
function u7() {
  if (Z1) {
    const t = Array.from(ac).filter((n) => n.needsMeasurement), e = new Set(t.map((n) => n.element)), r = /* @__PURE__ */ new Map();
    e.forEach((n) => {
      const i = RZ(n);
      i.length && (r.set(n, i), n.render());
    }), t.forEach((n) => n.measureInitialState()), e.forEach((n) => {
      n.render();
      const i = r.get(n);
      i && i.forEach(([s, o]) => {
        var a;
        (a = n.getValue(s)) === null || a === void 0 || a.set(o);
      });
    }), t.forEach((n) => n.measureEndState()), t.forEach((n) => {
      n.suspendedScrollY !== void 0 && window.scrollTo(0, n.suspendedScrollY);
    });
  }
  Z1 = !1, X1 = !1, ac.forEach((t) => t.complete()), ac.clear();
}
function f7() {
  ac.forEach((t) => {
    t.readKeyframes(), t.needsMeasurement && (Z1 = !0);
  });
}
function OZ() {
  f7(), u7();
}
class Ob {
  constructor(e, r, n, i, s, o = !1) {
    this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = r, this.name = n, this.motionValue = i, this.element = s, this.isAsync = o;
  }
  scheduleResolve() {
    this.isScheduled = !0, this.isAsync ? (ac.add(this), X1 || (X1 = !0, Lr.read(f7), Lr.resolveKeyframes(u7))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, name: r, element: n, motionValue: i } = this;
    for (let s = 0; s < e.length; s++)
      if (e[s] === null)
        if (s === 0) {
          const o = i == null ? void 0 : i.get(), a = e[e.length - 1];
          if (o !== void 0)
            e[0] = o;
          else if (n && r) {
            const u = n.readValue(r, a);
            u != null && (e[0] = u);
          }
          e[0] === void 0 && (e[0] = a), i && o === void 0 && i.set(e[0]);
        } else
          e[s] = e[s - 1];
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), ac.delete(this);
  }
  cancel() {
    this.isComplete || (this.isScheduled = !1, ac.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const Gf = (t) => Math.round(t * 1e5) / 1e5, Nb = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function NZ(t) {
  return t == null;
}
const LZ = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, Lb = (t, e) => (r) => !!(typeof r == "string" && LZ.test(r) && r.startsWith(t) || e && !NZ(r) && Object.prototype.hasOwnProperty.call(r, e)), l7 = (t, e, r) => (n) => {
  if (typeof n != "string")
    return n;
  const [i, s, o, a] = n.match(Nb);
  return {
    [t]: parseFloat(i),
    [e]: parseFloat(s),
    [r]: parseFloat(o),
    alpha: a !== void 0 ? parseFloat(a) : 1
  };
}, kZ = (t) => xa(0, 255, t), Om = {
  ...Ku,
  transform: (t) => Math.round(kZ(t))
}, ic = {
  test: /* @__PURE__ */ Lb("rgb", "red"),
  parse: /* @__PURE__ */ l7("red", "green", "blue"),
  transform: ({ red: t, green: e, blue: r, alpha: n = 1 }) => "rgba(" + Om.transform(t) + ", " + Om.transform(e) + ", " + Om.transform(r) + ", " + Gf(Il.transform(n)) + ")"
};
function $Z(t) {
  let e = "", r = "", n = "", i = "";
  return t.length > 5 ? (e = t.substring(1, 3), r = t.substring(3, 5), n = t.substring(5, 7), i = t.substring(7, 9)) : (e = t.substring(1, 2), r = t.substring(2, 3), n = t.substring(3, 4), i = t.substring(4, 5), e += e, r += r, n += n, i += i), {
    red: parseInt(e, 16),
    green: parseInt(r, 16),
    blue: parseInt(n, 16),
    alpha: i ? parseInt(i, 16) / 255 : 1
  };
}
const Q1 = {
  test: /* @__PURE__ */ Lb("#"),
  parse: $Z,
  transform: ic.transform
}, Qc = {
  test: /* @__PURE__ */ Lb("hsl", "hue"),
  parse: /* @__PURE__ */ l7("hue", "saturation", "lightness"),
  transform: ({ hue: t, saturation: e, lightness: r, alpha: n = 1 }) => "hsla(" + Math.round(t) + ", " + Vs.transform(Gf(e)) + ", " + Vs.transform(Gf(r)) + ", " + Gf(Il.transform(n)) + ")"
}, Gn = {
  test: (t) => ic.test(t) || Q1.test(t) || Qc.test(t),
  parse: (t) => ic.test(t) ? ic.parse(t) : Qc.test(t) ? Qc.parse(t) : Q1.parse(t),
  transform: (t) => typeof t == "string" ? t : t.hasOwnProperty("red") ? ic.transform(t) : Qc.transform(t)
}, FZ = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function BZ(t) {
  var e, r;
  return isNaN(t) && typeof t == "string" && (((e = t.match(Nb)) === null || e === void 0 ? void 0 : e.length) || 0) + (((r = t.match(FZ)) === null || r === void 0 ? void 0 : r.length) || 0) > 0;
}
const h7 = "number", d7 = "color", UZ = "var", jZ = "var(", X_ = "${}", qZ = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function Cl(t) {
  const e = t.toString(), r = [], n = {
    color: [],
    number: [],
    var: []
  }, i = [];
  let s = 0;
  const a = e.replace(qZ, (u) => (Gn.test(u) ? (n.color.push(s), i.push(d7), r.push(Gn.parse(u))) : u.startsWith(jZ) ? (n.var.push(s), i.push(UZ), r.push(u)) : (n.number.push(s), i.push(h7), r.push(parseFloat(u))), ++s, X_)).split(X_);
  return { values: r, split: a, indexes: n, types: i };
}
function p7(t) {
  return Cl(t).values;
}
function g7(t) {
  const { split: e, types: r } = Cl(t), n = e.length;
  return (i) => {
    let s = "";
    for (let o = 0; o < n; o++)
      if (s += e[o], i[o] !== void 0) {
        const a = r[o];
        a === h7 ? s += Gf(i[o]) : a === d7 ? s += Gn.transform(i[o]) : s += i[o];
      }
    return s;
  };
}
const zZ = (t) => typeof t == "number" ? 0 : t;
function HZ(t) {
  const e = p7(t);
  return g7(t)(e.map(zZ));
}
const _a = {
  test: BZ,
  parse: p7,
  createTransformer: g7,
  getAnimatableNone: HZ
}, WZ = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function KZ(t) {
  const [e, r] = t.slice(0, -1).split("(");
  if (e === "drop-shadow")
    return t;
  const [n] = r.match(Nb) || [];
  if (!n)
    return t;
  const i = r.replace(n, "");
  let s = WZ.has(e) ? 1 : 0;
  return n !== r && (s *= 100), e + "(" + s + i + ")";
}
const VZ = /\b([a-z-]*)\(.*?\)/gu, ev = {
  ..._a,
  getAnimatableNone: (t) => {
    const e = t.match(VZ);
    return e ? e.map(KZ).join(" ") : t;
  }
}, GZ = {
  // Border props
  borderWidth: Vt,
  borderTopWidth: Vt,
  borderRightWidth: Vt,
  borderBottomWidth: Vt,
  borderLeftWidth: Vt,
  borderRadius: Vt,
  radius: Vt,
  borderTopLeftRadius: Vt,
  borderTopRightRadius: Vt,
  borderBottomRightRadius: Vt,
  borderBottomLeftRadius: Vt,
  // Positioning props
  width: Vt,
  maxWidth: Vt,
  height: Vt,
  maxHeight: Vt,
  top: Vt,
  right: Vt,
  bottom: Vt,
  left: Vt,
  // Spacing props
  padding: Vt,
  paddingTop: Vt,
  paddingRight: Vt,
  paddingBottom: Vt,
  paddingLeft: Vt,
  margin: Vt,
  marginTop: Vt,
  marginRight: Vt,
  marginBottom: Vt,
  marginLeft: Vt,
  // Misc
  backgroundPositionX: Vt,
  backgroundPositionY: Vt
}, YZ = {
  rotate: sa,
  rotateX: sa,
  rotateY: sa,
  rotateZ: sa,
  scale: gd,
  scaleX: gd,
  scaleY: gd,
  scaleZ: gd,
  skew: sa,
  skewX: sa,
  skewY: sa,
  distance: Vt,
  translateX: Vt,
  translateY: Vt,
  translateZ: Vt,
  x: Vt,
  y: Vt,
  z: Vt,
  perspective: Vt,
  transformPerspective: Vt,
  opacity: Il,
  originX: K_,
  originY: K_,
  originZ: Vt
}, Z_ = {
  ...Ku,
  transform: Math.round
}, kb = {
  ...GZ,
  ...YZ,
  zIndex: Z_,
  size: Vt,
  // SVG
  fillOpacity: Il,
  strokeOpacity: Il,
  numOctaves: Z_
}, JZ = {
  ...kb,
  // Color props
  color: Gn,
  backgroundColor: Gn,
  outlineColor: Gn,
  fill: Gn,
  stroke: Gn,
  // Border props
  borderColor: Gn,
  borderTopColor: Gn,
  borderRightColor: Gn,
  borderBottomColor: Gn,
  borderLeftColor: Gn,
  filter: ev,
  WebkitFilter: ev
}, $b = (t) => JZ[t];
function m7(t, e) {
  let r = $b(t);
  return r !== ev && (r = _a), r.getAnimatableNone ? r.getAnimatableNone(e) : void 0;
}
const XZ = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function ZZ(t, e, r) {
  let n = 0, i;
  for (; n < t.length && !i; ) {
    const s = t[n];
    typeof s == "string" && !XZ.has(s) && Cl(s).values.length && (i = t[n]), n++;
  }
  if (i && r)
    for (const s of e)
      t[s] = m7(r, i);
}
class v7 extends Ob {
  constructor(e, r, n, i, s) {
    super(e, r, n, i, s, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: r, name: n } = this;
    if (!r || !r.current)
      return;
    super.readKeyframes();
    for (let u = 0; u < e.length; u++) {
      let l = e[u];
      if (typeof l == "string" && (l = l.trim(), Db(l))) {
        const d = o7(l, r.current);
        d !== void 0 && (e[u] = d), u === e.length - 1 && (this.finalKeyframe = l);
      }
    }
    if (this.resolveNoneKeyframes(), !IZ.has(n) || e.length !== 2)
      return;
    const [i, s] = e, o = J_(i), a = J_(s);
    if (o !== a)
      if (V_(o) && V_(a))
        for (let u = 0; u < e.length; u++) {
          const l = e[u];
          typeof l == "string" && (e[u] = parseFloat(l));
        }
      else
        this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: r } = this, n = [];
    for (let i = 0; i < e.length; i++)
      wZ(e[i]) && n.push(i);
    n.length && ZZ(e, n, r);
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: r, name: n } = this;
    if (!e || !e.current)
      return;
    n === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Pu[n](e.measureViewportBox(), window.getComputedStyle(e.current)), r[0] = this.measuredOrigin;
    const i = r[r.length - 1];
    i !== void 0 && e.getValue(n, i).jump(i, !1);
  }
  measureEndState() {
    var e;
    const { element: r, name: n, unresolvedKeyframes: i } = this;
    if (!r || !r.current)
      return;
    const s = r.getValue(n);
    s && s.jump(this.measuredOrigin, !1);
    const o = i.length - 1, a = i[o];
    i[o] = Pu[n](r.measureViewportBox(), window.getComputedStyle(r.current)), a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a), !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach(([u, l]) => {
      r.getValue(u).set(l);
    }), this.resolveNoneKeyframes();
  }
}
function Fb(t) {
  return typeof t == "function";
}
let Fd;
function QZ() {
  Fd = void 0;
}
const Gs = {
  now: () => (Fd === void 0 && Gs.set(Fn.isProcessing || dZ.useManualTiming ? Fn.timestamp : performance.now()), Fd),
  set: (t) => {
    Fd = t, queueMicrotask(QZ);
  }
}, Q_ = (t, e) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && // It's animatable if we have a string
(_a.test(t) || t === "0") && // And it contains numbers and/or colors
!t.startsWith("url("));
function eQ(t) {
  const e = t[0];
  if (t.length === 1)
    return !0;
  for (let r = 0; r < t.length; r++)
    if (t[r] !== e)
      return !0;
}
function tQ(t, e, r, n) {
  const i = t[0];
  if (i === null)
    return !1;
  if (e === "display" || e === "visibility")
    return !0;
  const s = t[t.length - 1], o = Q_(i, e), a = Q_(s, e);
  return Wu(o === a, `You are trying to animate ${e} from "${i}" to "${s}". ${i} is not an animatable value - to enable this animation set ${i} to a value animatable to ${s} via the \`style\` property.`), !o || !a ? !1 : eQ(t) || (r === "spring" || Fb(r)) && n;
}
const rQ = 40;
class b7 {
  constructor({ autoplay: e = !0, delay: r = 0, type: n = "keyframes", repeat: i = 0, repeatDelay: s = 0, repeatType: o = "loop", ...a }) {
    this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = Gs.now(), this.options = {
      autoplay: e,
      delay: r,
      type: n,
      repeat: i,
      repeatDelay: s,
      repeatType: o,
      ...a
    }, this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    return this.resolvedAt ? this.resolvedAt - this.createdAt > rQ ? this.resolvedAt : this.createdAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && OZ(), this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(e, r) {
    this.resolvedAt = Gs.now(), this.hasAttemptedResolve = !0;
    const { name: n, type: i, velocity: s, delay: o, onComplete: a, onUpdate: u, isGenerator: l } = this.options;
    if (!l && !tQ(e, n, i, s))
      if (o)
        this.options.duration = 0;
      else {
        u == null || u(yp(e, this.options, r)), a == null || a(), this.resolveFinishedPromise();
        return;
      }
    const d = this.initPlayback(e, r);
    d !== !1 && (this._resolved = {
      keyframes: e,
      finalKeyframe: r,
      ...d
    }, this.onPostResolved());
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(e, r) {
    return this.currentFinishedPromise.then(e, r);
  }
  flatten() {
    this.options.type = "keyframes", this.options.ease = "linear";
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((e) => {
      this.resolveFinishedPromise = e;
    });
  }
}
function y7(t, e) {
  return e ? t * (1e3 / e) : 0;
}
const nQ = 5;
function w7(t, e, r) {
  const n = Math.max(e - nQ, 0);
  return y7(r - t(n), e - n);
}
const Nm = 1e-3, iQ = 0.01, e6 = 10, sQ = 0.05, oQ = 1;
function aQ({ duration: t = 800, bounce: e = 0.25, velocity: r = 0, mass: n = 1 }) {
  let i, s;
  Wu(t <= Ks(e6), "Spring duration must be 10 seconds or less");
  let o = 1 - e;
  o = xa(sQ, oQ, o), t = xa(iQ, e6, Co(t)), o < 1 ? (i = (l) => {
    const d = l * o, p = d * t, w = d - r, P = tv(l, o), A = Math.exp(-p);
    return Nm - w / P * A;
  }, s = (l) => {
    const p = l * o * t, w = p * r + r, P = Math.pow(o, 2) * Math.pow(l, 2) * t, A = Math.exp(-p), N = tv(Math.pow(l, 2), o);
    return (-i(l) + Nm > 0 ? -1 : 1) * ((w - P) * A) / N;
  }) : (i = (l) => {
    const d = Math.exp(-l * t), p = (l - r) * t + 1;
    return -Nm + d * p;
  }, s = (l) => {
    const d = Math.exp(-l * t), p = (r - l) * (t * t);
    return d * p;
  });
  const a = 5 / t, u = uQ(i, s, a);
  if (t = Ks(t), isNaN(u))
    return {
      stiffness: 100,
      damping: 10,
      duration: t
    };
  {
    const l = Math.pow(u, 2) * n;
    return {
      stiffness: l,
      damping: o * 2 * Math.sqrt(n * l),
      duration: t
    };
  }
}
const cQ = 12;
function uQ(t, e, r) {
  let n = r;
  for (let i = 1; i < cQ; i++)
    n = n - t(n) / e(n);
  return n;
}
function tv(t, e) {
  return t * Math.sqrt(1 - e * e);
}
const fQ = ["duration", "bounce"], lQ = ["stiffness", "damping", "mass"];
function t6(t, e) {
  return e.some((r) => t[r] !== void 0);
}
function hQ(t) {
  let e = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...t
  };
  if (!t6(t, lQ) && t6(t, fQ)) {
    const r = aQ(t);
    e = {
      ...e,
      ...r,
      mass: 1
    }, e.isResolvedFromDuration = !0;
  }
  return e;
}
function x7({ keyframes: t, restDelta: e, restSpeed: r, ...n }) {
  const i = t[0], s = t[t.length - 1], o = { done: !1, value: i }, { stiffness: a, damping: u, mass: l, duration: d, velocity: p, isResolvedFromDuration: w } = hQ({
    ...n,
    velocity: -Co(n.velocity || 0)
  }), P = p || 0, A = u / (2 * Math.sqrt(a * l)), N = s - i, L = Co(Math.sqrt(a / l)), F = Math.abs(N) < 5;
  r || (r = F ? 0.01 : 2), e || (e = F ? 5e-3 : 0.5);
  let $;
  if (A < 1) {
    const K = tv(L, A);
    $ = (H) => {
      const V = Math.exp(-A * L * H);
      return s - V * ((P + A * L * N) / K * Math.sin(K * H) + N * Math.cos(K * H));
    };
  } else if (A === 1)
    $ = (K) => s - Math.exp(-L * K) * (N + (P + L * N) * K);
  else {
    const K = L * Math.sqrt(A * A - 1);
    $ = (H) => {
      const V = Math.exp(-A * L * H), te = Math.min(K * H, 300);
      return s - V * ((P + A * L * N) * Math.sinh(te) + K * N * Math.cosh(te)) / K;
    };
  }
  return {
    calculatedDuration: w && d || null,
    next: (K) => {
      const H = $(K);
      if (w)
        o.done = K >= d;
      else {
        let V = 0;
        A < 1 && (V = K === 0 ? Ks(P) : w7($, K, H));
        const te = Math.abs(V) <= r, R = Math.abs(s - H) <= e;
        o.done = te && R;
      }
      return o.value = o.done ? s : H, o;
    }
  };
}
function r6({ keyframes: t, velocity: e = 0, power: r = 0.8, timeConstant: n = 325, bounceDamping: i = 10, bounceStiffness: s = 500, modifyTarget: o, min: a, max: u, restDelta: l = 0.5, restSpeed: d }) {
  const p = t[0], w = {
    done: !1,
    value: p
  }, P = (W) => a !== void 0 && W < a || u !== void 0 && W > u, A = (W) => a === void 0 ? u : u === void 0 || Math.abs(a - W) < Math.abs(u - W) ? a : u;
  let N = r * e;
  const L = p + N, F = o === void 0 ? L : o(L);
  F !== L && (N = F - p);
  const $ = (W) => -N * Math.exp(-W / n), K = (W) => F + $(W), H = (W) => {
    const pe = $(W), Ee = K(W);
    w.done = Math.abs(pe) <= l, w.value = w.done ? F : Ee;
  };
  let V, te;
  const R = (W) => {
    P(w.value) && (V = W, te = x7({
      keyframes: [w.value, A(w.value)],
      velocity: w7(K, W, w.value),
      // TODO: This should be passing * 1000
      damping: i,
      stiffness: s,
      restDelta: l,
      restSpeed: d
    }));
  };
  return R(0), {
    calculatedDuration: null,
    next: (W) => {
      let pe = !1;
      return !te && V === void 0 && (pe = !0, H(W), R(W)), V !== void 0 && W >= V ? te.next(W - V) : (!pe && H(W), w);
    }
  };
}
const dQ = /* @__PURE__ */ ah(0.42, 0, 1, 1), pQ = /* @__PURE__ */ ah(0, 0, 0.58, 1), _7 = /* @__PURE__ */ ah(0.42, 0, 0.58, 1), gQ = (t) => Array.isArray(t) && typeof t[0] != "number", Bb = (t) => Array.isArray(t) && typeof t[0] == "number", n6 = {
  linear: Un,
  easeIn: dQ,
  easeInOut: _7,
  easeOut: pQ,
  circIn: Rb,
  circInOut: t7,
  circOut: e7,
  backIn: Tb,
  backInOut: ZS,
  backOut: XS,
  anticipate: QS
}, i6 = (t) => {
  if (Bb(t)) {
    Uo(t.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [e, r, n, i] = t;
    return ah(e, r, n, i);
  } else if (typeof t == "string")
    return Uo(n6[t] !== void 0, `Invalid easing type '${t}'`), n6[t];
  return t;
}, mQ = (t, e) => (r) => e(t(r)), To = (...t) => t.reduce(mQ), Mu = (t, e, r) => {
  const n = e - t;
  return n === 0 ? 1 : (r - t) / n;
}, Qr = (t, e, r) => t + (e - t) * r;
function Lm(t, e, r) {
  return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? t + (e - t) * 6 * r : r < 1 / 2 ? e : r < 2 / 3 ? t + (e - t) * (2 / 3 - r) * 6 : t;
}
function vQ({ hue: t, saturation: e, lightness: r, alpha: n }) {
  t /= 360, e /= 100, r /= 100;
  let i = 0, s = 0, o = 0;
  if (!e)
    i = s = o = r;
  else {
    const a = r < 0.5 ? r * (1 + e) : r + e - r * e, u = 2 * r - a;
    i = Lm(u, a, t + 1 / 3), s = Lm(u, a, t), o = Lm(u, a, t - 1 / 3);
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(s * 255),
    blue: Math.round(o * 255),
    alpha: n
  };
}
function m0(t, e) {
  return (r) => r > 0 ? e : t;
}
const km = (t, e, r) => {
  const n = t * t, i = r * (e * e - n) + n;
  return i < 0 ? 0 : Math.sqrt(i);
}, bQ = [Q1, ic, Qc], yQ = (t) => bQ.find((e) => e.test(t));
function s6(t) {
  const e = yQ(t);
  if (Wu(!!e, `'${t}' is not an animatable color. Use the equivalent color code instead.`), !e)
    return !1;
  let r = e.parse(t);
  return e === Qc && (r = vQ(r)), r;
}
const o6 = (t, e) => {
  const r = s6(t), n = s6(e);
  if (!r || !n)
    return m0(t, e);
  const i = { ...r };
  return (s) => (i.red = km(r.red, n.red, s), i.green = km(r.green, n.green, s), i.blue = km(r.blue, n.blue, s), i.alpha = Qr(r.alpha, n.alpha, s), ic.transform(i));
}, rv = /* @__PURE__ */ new Set(["none", "hidden"]);
function wQ(t, e) {
  return rv.has(t) ? (r) => r <= 0 ? t : e : (r) => r >= 1 ? e : t;
}
function xQ(t, e) {
  return (r) => Qr(t, e, r);
}
function Ub(t) {
  return typeof t == "number" ? xQ : typeof t == "string" ? Db(t) ? m0 : Gn.test(t) ? o6 : SQ : Array.isArray(t) ? E7 : typeof t == "object" ? Gn.test(t) ? o6 : _Q : m0;
}
function E7(t, e) {
  const r = [...t], n = r.length, i = t.map((s, o) => Ub(s)(s, e[o]));
  return (s) => {
    for (let o = 0; o < n; o++)
      r[o] = i[o](s);
    return r;
  };
}
function _Q(t, e) {
  const r = { ...t, ...e }, n = {};
  for (const i in r)
    t[i] !== void 0 && e[i] !== void 0 && (n[i] = Ub(t[i])(t[i], e[i]));
  return (i) => {
    for (const s in n)
      r[s] = n[s](i);
    return r;
  };
}
function EQ(t, e) {
  var r;
  const n = [], i = { color: 0, var: 0, number: 0 };
  for (let s = 0; s < e.values.length; s++) {
    const o = e.types[s], a = t.indexes[o][i[o]], u = (r = t.values[a]) !== null && r !== void 0 ? r : 0;
    n[s] = u, i[o]++;
  }
  return n;
}
const SQ = (t, e) => {
  const r = _a.createTransformer(e), n = Cl(t), i = Cl(e);
  return n.indexes.var.length === i.indexes.var.length && n.indexes.color.length === i.indexes.color.length && n.indexes.number.length >= i.indexes.number.length ? rv.has(t) && !i.values.length || rv.has(e) && !n.values.length ? wQ(t, e) : To(E7(EQ(n, i), i.values), r) : (Wu(!0, `Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), m0(t, e));
};
function S7(t, e, r) {
  return typeof t == "number" && typeof e == "number" && typeof r == "number" ? Qr(t, e, r) : Ub(t)(t, e);
}
function AQ(t, e, r) {
  const n = [], i = r || S7, s = t.length - 1;
  for (let o = 0; o < s; o++) {
    let a = i(t[o], t[o + 1]);
    if (e) {
      const u = Array.isArray(e) ? e[o] || Un : e;
      a = To(u, a);
    }
    n.push(a);
  }
  return n;
}
function PQ(t, e, { clamp: r = !0, ease: n, mixer: i } = {}) {
  const s = t.length;
  if (Uo(s === e.length, "Both input and output ranges must be the same length"), s === 1)
    return () => e[0];
  if (s === 2 && t[0] === t[1])
    return () => e[1];
  t[0] > t[s - 1] && (t = [...t].reverse(), e = [...e].reverse());
  const o = AQ(e, n, i), a = o.length, u = (l) => {
    let d = 0;
    if (a > 1)
      for (; d < t.length - 2 && !(l < t[d + 1]); d++)
        ;
    const p = Mu(t[d], t[d + 1], l);
    return o[d](p);
  };
  return r ? (l) => u(xa(t[0], t[s - 1], l)) : u;
}
function MQ(t, e) {
  const r = t[t.length - 1];
  for (let n = 1; n <= e; n++) {
    const i = Mu(0, e, n);
    t.push(Qr(r, 1, i));
  }
}
function IQ(t) {
  const e = [0];
  return MQ(e, t.length - 1), e;
}
function CQ(t, e) {
  return t.map((r) => r * e);
}
function TQ(t, e) {
  return t.map(() => e || _7).splice(0, t.length - 1);
}
function v0({ duration: t = 300, keyframes: e, times: r, ease: n = "easeInOut" }) {
  const i = gQ(n) ? n.map(i6) : i6(n), s = {
    done: !1,
    value: e[0]
  }, o = CQ(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    r && r.length === e.length ? r : IQ(e),
    t
  ), a = PQ(o, e, {
    ease: Array.isArray(i) ? i : TQ(e, i)
  });
  return {
    calculatedDuration: t,
    next: (u) => (s.value = a(u), s.done = u >= t, s)
  };
}
const a6 = 2e4;
function RQ(t) {
  let e = 0;
  const r = 50;
  let n = t.next(e);
  for (; !n.done && e < a6; )
    e += r, n = t.next(e);
  return e >= a6 ? 1 / 0 : e;
}
const DQ = (t) => {
  const e = ({ timestamp: r }) => t(r);
  return {
    start: () => Lr.update(e, !0),
    stop: () => wa(e),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => Fn.isProcessing ? Fn.timestamp : Gs.now()
  };
}, OQ = {
  decay: r6,
  inertia: r6,
  tween: v0,
  keyframes: v0,
  spring: x7
}, NQ = (t) => t / 100;
class jb extends b7 {
  constructor(e) {
    super(e), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
      if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
        return;
      this.teardown();
      const { onStop: u } = this.options;
      u && u();
    };
    const { name: r, motionValue: n, element: i, keyframes: s } = this.options, o = (i == null ? void 0 : i.KeyframeResolver) || Ob, a = (u, l) => this.onKeyframesResolved(u, l);
    this.resolver = new o(s, a, r, n, i), this.resolver.scheduleResolve();
  }
  flatten() {
    super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
  }
  initPlayback(e) {
    const { type: r = "keyframes", repeat: n = 0, repeatDelay: i = 0, repeatType: s, velocity: o = 0 } = this.options, a = Fb(r) ? r : OQ[r] || v0;
    let u, l;
    a !== v0 && typeof e[0] != "number" && (process.env.NODE_ENV !== "production" && Uo(e.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${e}`), u = To(NQ, S7(e[0], e[1])), e = [0, 100]);
    const d = a({ ...this.options, keyframes: e });
    s === "mirror" && (l = a({
      ...this.options,
      keyframes: [...e].reverse(),
      velocity: -o
    })), d.calculatedDuration === null && (d.calculatedDuration = RQ(d));
    const { calculatedDuration: p } = d, w = p + i, P = w * (n + 1) - i;
    return {
      generator: d,
      mirroredGenerator: l,
      mapPercentToKeyframes: u,
      calculatedDuration: p,
      resolvedDuration: w,
      totalDuration: P
    };
  }
  onPostResolved() {
    const { autoplay: e = !0 } = this.options;
    this.play(), this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState;
  }
  tick(e, r = !1) {
    const { resolved: n } = this;
    if (!n) {
      const { keyframes: W } = this.options;
      return { done: !0, value: W[W.length - 1] };
    }
    const { finalKeyframe: i, generator: s, mirroredGenerator: o, mapPercentToKeyframes: a, keyframes: u, calculatedDuration: l, totalDuration: d, resolvedDuration: p } = n;
    if (this.startTime === null)
      return s.next(0);
    const { delay: w, repeat: P, repeatType: A, repeatDelay: N, onUpdate: L } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - d / this.speed, this.startTime)), r ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed;
    const F = this.currentTime - w * (this.speed >= 0 ? 1 : -1), $ = this.speed >= 0 ? F < 0 : F > d;
    this.currentTime = Math.max(F, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = d);
    let K = this.currentTime, H = s;
    if (P) {
      const W = Math.min(this.currentTime, d) / p;
      let pe = Math.floor(W), Ee = W % 1;
      !Ee && W >= 1 && (Ee = 1), Ee === 1 && pe--, pe = Math.min(pe, P + 1), !!(pe % 2) && (A === "reverse" ? (Ee = 1 - Ee, N && (Ee -= N / p)) : A === "mirror" && (H = o)), K = xa(0, 1, Ee) * p;
    }
    const V = $ ? { done: !1, value: u[0] } : H.next(K);
    a && (V.value = a(V.value));
    let { done: te } = V;
    !$ && l !== null && (te = this.speed >= 0 ? this.currentTime >= d : this.currentTime <= 0);
    const R = this.holdTime === null && (this.state === "finished" || this.state === "running" && te);
    return R && i !== void 0 && (V.value = yp(u, this.options, i)), L && L(V.value), R && this.finish(), V;
  }
  get duration() {
    const { resolved: e } = this;
    return e ? Co(e.calculatedDuration) : 0;
  }
  get time() {
    return Co(this.currentTime);
  }
  set time(e) {
    e = Ks(e), this.currentTime = e, this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(e) {
    const r = this.playbackSpeed !== e;
    this.playbackSpeed = e, r && (this.time = Co(this.currentTime));
  }
  play() {
    if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver: e = DQ, onPlay: r, startTime: n } = this.options;
    this.driver || (this.driver = e((s) => this.tick(s))), r && r();
    const i = this.driver.now();
    this.holdTime !== null ? this.startTime = i - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = i) : this.startTime = n ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    var e;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused", this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0;
  }
  complete() {
    this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.teardown(), this.state = "finished";
    const { onComplete: e } = this.options;
    e && e();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(e) {
    return this.startTime = 0, this.tick(e, !0);
  }
}
const LQ = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]), kQ = 10, $Q = (t, e) => {
  let r = "";
  const n = Math.max(Math.round(e / kQ), 2);
  for (let i = 0; i < n; i++)
    r += t(Mu(0, n - 1, i)) + ", ";
  return `linear(${r.substring(0, r.length - 2)})`;
};
function qb(t) {
  let e;
  return () => (e === void 0 && (e = t()), e);
}
const FQ = {
  linearEasing: void 0
};
function BQ(t, e) {
  const r = qb(t);
  return () => {
    var n;
    return (n = FQ[e]) !== null && n !== void 0 ? n : r();
  };
}
const b0 = /* @__PURE__ */ BQ(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing");
function A7(t) {
  return !!(typeof t == "function" && b0() || !t || typeof t == "string" && (t in nv || b0()) || Bb(t) || Array.isArray(t) && t.every(A7));
}
const Bf = ([t, e, r, n]) => `cubic-bezier(${t}, ${e}, ${r}, ${n})`, nv = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ Bf([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ Bf([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ Bf([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ Bf([0.33, 1.53, 0.69, 0.99])
};
function P7(t, e) {
  if (t)
    return typeof t == "function" && b0() ? $Q(t, e) : Bb(t) ? Bf(t) : Array.isArray(t) ? t.map((r) => P7(r, e) || nv.easeOut) : nv[t];
}
function UQ(t, e, r, { delay: n = 0, duration: i = 300, repeat: s = 0, repeatType: o = "loop", ease: a = "easeInOut", times: u } = {}) {
  const l = { [e]: r };
  u && (l.offset = u);
  const d = P7(a, i);
  return Array.isArray(d) && (l.easing = d), t.animate(l, {
    delay: n,
    duration: i,
    easing: Array.isArray(d) ? "linear" : d,
    fill: "both",
    iterations: s + 1,
    direction: o === "reverse" ? "alternate" : "normal"
  });
}
function c6(t, e) {
  t.timeline = e, t.onfinish = null;
}
const jQ = /* @__PURE__ */ qb(() => Object.hasOwnProperty.call(Element.prototype, "animate")), y0 = 10, qQ = 2e4;
function zQ(t) {
  return Fb(t.type) || t.type === "spring" || !A7(t.ease);
}
function HQ(t, e) {
  const r = new jb({
    ...e,
    keyframes: t,
    repeat: 0,
    delay: 0,
    isGenerator: !0
  });
  let n = { done: !1, value: t[0] };
  const i = [];
  let s = 0;
  for (; !n.done && s < qQ; )
    n = r.sample(s), i.push(n.value), s += y0;
  return {
    times: void 0,
    keyframes: i,
    duration: s - y0,
    ease: "linear"
  };
}
const M7 = {
  anticipate: QS,
  backInOut: ZS,
  circInOut: t7
};
function WQ(t) {
  return t in M7;
}
class u6 extends b7 {
  constructor(e) {
    super(e);
    const { name: r, motionValue: n, element: i, keyframes: s } = this.options;
    this.resolver = new v7(s, (o, a) => this.onKeyframesResolved(o, a), r, n, i), this.resolver.scheduleResolve();
  }
  initPlayback(e, r) {
    var n;
    let { duration: i = 300, times: s, ease: o, type: a, motionValue: u, name: l, startTime: d } = this.options;
    if (!(!((n = u.owner) === null || n === void 0) && n.current))
      return !1;
    if (typeof o == "string" && b0() && WQ(o) && (o = M7[o]), zQ(this.options)) {
      const { onComplete: w, onUpdate: P, motionValue: A, element: N, ...L } = this.options, F = HQ(e, L);
      e = F.keyframes, e.length === 1 && (e[1] = e[0]), i = F.duration, s = F.times, o = F.ease, a = "keyframes";
    }
    const p = UQ(u.owner.current, l, e, { ...this.options, duration: i, times: s, ease: o });
    return p.startTime = d ?? this.calcStartTime(), this.pendingTimeline ? (c6(p, this.pendingTimeline), this.pendingTimeline = void 0) : p.onfinish = () => {
      const { onComplete: w } = this.options;
      u.set(yp(e, this.options, r)), w && w(), this.cancel(), this.resolveFinishedPromise();
    }, {
      animation: p,
      duration: i,
      times: s,
      type: a,
      ease: o,
      keyframes: e
    };
  }
  get duration() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { duration: r } = e;
    return Co(r);
  }
  get time() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { animation: r } = e;
    return Co(r.currentTime || 0);
  }
  set time(e) {
    const { resolved: r } = this;
    if (!r)
      return;
    const { animation: n } = r;
    n.currentTime = Ks(e);
  }
  get speed() {
    const { resolved: e } = this;
    if (!e)
      return 1;
    const { animation: r } = e;
    return r.playbackRate;
  }
  set speed(e) {
    const { resolved: r } = this;
    if (!r)
      return;
    const { animation: n } = r;
    n.playbackRate = e;
  }
  get state() {
    const { resolved: e } = this;
    if (!e)
      return "idle";
    const { animation: r } = e;
    return r.playState;
  }
  get startTime() {
    const { resolved: e } = this;
    if (!e)
      return null;
    const { animation: r } = e;
    return r.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(e) {
    if (!this._resolved)
      this.pendingTimeline = e;
    else {
      const { resolved: r } = this;
      if (!r)
        return Un;
      const { animation: n } = r;
      c6(n, e);
    }
    return Un;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: r } = e;
    r.playState === "finished" && this.updateFinishedPromise(), r.play();
  }
  pause() {
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: r } = e;
    r.pause();
  }
  stop() {
    if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: r, keyframes: n, duration: i, type: s, ease: o, times: a } = e;
    if (r.playState === "idle" || r.playState === "finished")
      return;
    if (this.time) {
      const { motionValue: l, onUpdate: d, onComplete: p, element: w, ...P } = this.options, A = new jb({
        ...P,
        keyframes: n,
        duration: i,
        type: s,
        ease: o,
        times: a,
        isGenerator: !0
      }), N = Ks(this.time);
      l.setWithVelocity(A.sample(N - y0).value, A.sample(N).value, y0);
    }
    const { onStop: u } = this.options;
    u && u(), this.cancel();
  }
  complete() {
    const { resolved: e } = this;
    e && e.animation.finish();
  }
  cancel() {
    const { resolved: e } = this;
    e && e.animation.cancel();
  }
  static supports(e) {
    const { motionValue: r, name: n, repeatDelay: i, repeatType: s, damping: o, type: a } = e;
    return jQ() && n && LQ.has(n) && r && r.owner && r.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !r.owner.getProps().onUpdate && !i && s !== "mirror" && o !== 0 && a !== "inertia";
  }
}
const KQ = qb(() => window.ScrollTimeline !== void 0);
class VQ {
  constructor(e) {
    this.stop = () => this.runAll("stop"), this.animations = e.filter(Boolean);
  }
  then(e, r) {
    return Promise.all(this.animations).then(e).catch(r);
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(e) {
    return this.animations[0][e];
  }
  setAll(e, r) {
    for (let n = 0; n < this.animations.length; n++)
      this.animations[n][e] = r;
  }
  attachTimeline(e, r) {
    const n = this.animations.map((i) => KQ() && i.attachTimeline ? i.attachTimeline(e) : r(i));
    return () => {
      n.forEach((i, s) => {
        i && i(), this.animations[s].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(e) {
    this.setAll("time", e);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(e) {
    this.setAll("speed", e);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let e = 0;
    for (let r = 0; r < this.animations.length; r++)
      e = Math.max(e, this.animations[r].duration);
    return e;
  }
  runAll(e) {
    this.animations.forEach((r) => r[e]());
  }
  flatten() {
    this.runAll("flatten");
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
function GQ({ when: t, delay: e, delayChildren: r, staggerChildren: n, staggerDirection: i, repeat: s, repeatType: o, repeatDelay: a, from: u, elapsed: l, ...d }) {
  return !!Object.keys(d).length;
}
const zb = (t, e, r, n = {}, i, s) => (o) => {
  const a = Cb(n, t) || {}, u = a.delay || n.delay || 0;
  let { elapsed: l = 0 } = n;
  l = l - Ks(u);
  let d = {
    keyframes: Array.isArray(r) ? r : [null, r],
    ease: "easeOut",
    velocity: e.getVelocity(),
    ...a,
    delay: -l,
    onUpdate: (w) => {
      e.set(w), a.onUpdate && a.onUpdate(w);
    },
    onComplete: () => {
      o(), a.onComplete && a.onComplete();
    },
    name: t,
    motionValue: e,
    element: s ? void 0 : i
  };
  GQ(a) || (d = {
    ...d,
    ...hZ(t, d)
  }), d.duration && (d.duration = Ks(d.duration)), d.repeatDelay && (d.repeatDelay = Ks(d.repeatDelay)), d.from !== void 0 && (d.keyframes[0] = d.from);
  let p = !1;
  if ((d.type === !1 || d.duration === 0 && !d.repeatDelay) && (d.duration = 0, d.delay === 0 && (p = !0)), p && !s && e.get() !== void 0) {
    const w = yp(d.keyframes, a);
    if (w !== void 0)
      return Lr.update(() => {
        d.onUpdate(w), d.onComplete();
      }), new VQ([]);
  }
  return !s && u6.supports(d) ? new u6(d) : new jb(d);
}, YQ = (t) => !!(t && typeof t == "object" && t.mix && t.toValue), JQ = (t) => J1(t) ? t[t.length - 1] || 0 : t;
function Hb(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function Wb(t, e) {
  const r = t.indexOf(e);
  r > -1 && t.splice(r, 1);
}
class Kb {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return Hb(this.subscriptions, e), () => Wb(this.subscriptions, e);
  }
  notify(e, r, n) {
    const i = this.subscriptions.length;
    if (i)
      if (i === 1)
        this.subscriptions[0](e, r, n);
      else
        for (let s = 0; s < i; s++) {
          const o = this.subscriptions[s];
          o && o(e, r, n);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const f6 = 30, XQ = (t) => !isNaN(parseFloat(t));
class ZQ {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(e, r = {}) {
    this.version = "11.11.17", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (n, i = !0) => {
      const s = Gs.now();
      this.updatedAt !== s && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(n), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), i && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.hasAnimated = !1, this.setCurrent(e), this.owner = r.owner;
  }
  setCurrent(e) {
    this.current = e, this.updatedAt = Gs.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = XQ(this.current));
  }
  setPrevFrameValue(e = this.current) {
    this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(e) {
    return process.env.NODE_ENV !== "production" && mp(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", e);
  }
  on(e, r) {
    this.events[e] || (this.events[e] = new Kb());
    const n = this.events[e].add(r);
    return e === "change" ? () => {
      n(), Lr.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : n;
  }
  clearListeners() {
    for (const e in this.events)
      this.events[e].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(e, r) {
    this.passiveEffect = e, this.stopPassiveEffect = r;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(e, r = !0) {
    !r || !this.passiveEffect ? this.updateAndNotify(e, r) : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, r, n) {
    this.set(r), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - n;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(e, r = !0) {
    this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, r && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const e = Gs.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > f6)
      return 0;
    const r = Math.min(this.updatedAt - this.prevUpdatedAt, f6);
    return y7(parseFloat(this.current) - parseFloat(this.prevFrameValue), r);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(e) {
    return this.stop(), new Promise((r) => {
      this.hasAnimated = !0, this.animation = e(r), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Tl(t, e) {
  return new ZQ(t, e);
}
function QQ(t, e, r) {
  t.hasValue(e) ? t.getValue(e).set(r) : t.addValue(e, Tl(r));
}
function eee(t, e) {
  const r = bp(t, e);
  let { transitionEnd: n = {}, transition: i = {}, ...s } = r || {};
  s = { ...s, ...n };
  for (const o in s) {
    const a = JQ(s[o]);
    QQ(t, o, a);
  }
}
const Vb = (t) => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), tee = "framerAppearId", I7 = "data-" + Vb(tee);
function C7(t) {
  return t.props[I7];
}
const Jn = (t) => !!(t && t.getVelocity);
function ree(t) {
  return !!(Jn(t) && t.add);
}
function iv(t, e) {
  const r = t.getValue("willChange");
  if (ree(r))
    return r.add(e);
}
function nee({ protectedKeys: t, needsAnimating: e }, r) {
  const n = t.hasOwnProperty(r) && e[r] !== !0;
  return e[r] = !1, n;
}
function T7(t, e, { delay: r = 0, transitionOverride: n, type: i } = {}) {
  var s;
  let { transition: o = t.getDefaultTransition(), transitionEnd: a, ...u } = e;
  n && (o = n);
  const l = [], d = i && t.animationState && t.animationState.getState()[i];
  for (const p in u) {
    const w = t.getValue(p, (s = t.latestValues[p]) !== null && s !== void 0 ? s : null), P = u[p];
    if (P === void 0 || d && nee(d, p))
      continue;
    const A = {
      delay: r,
      ...Cb(o || {}, p)
    };
    let N = !1;
    if (window.MotionHandoffAnimation) {
      const F = C7(t);
      if (F) {
        const $ = window.MotionHandoffAnimation(F, p, Lr);
        $ !== null && (A.startTime = $, N = !0);
      }
    }
    iv(t, p), w.start(zb(p, w, P, t.shouldReduceMotion && Sc.has(p) ? { type: !1 } : A, t, N));
    const L = w.animation;
    L && l.push(L);
  }
  return a && Promise.all(l).then(() => {
    Lr.update(() => {
      a && eee(t, a);
    });
  }), l;
}
function sv(t, e, r = {}) {
  var n;
  const i = bp(t, e, r.type === "exit" ? (n = t.presenceContext) === null || n === void 0 ? void 0 : n.custom : void 0);
  let { transition: s = t.getDefaultTransition() || {} } = i || {};
  r.transitionOverride && (s = r.transitionOverride);
  const o = i ? () => Promise.all(T7(t, i, r)) : () => Promise.resolve(), a = t.variantChildren && t.variantChildren.size ? (l = 0) => {
    const { delayChildren: d = 0, staggerChildren: p, staggerDirection: w } = s;
    return iee(t, e, d + l, p, w, r);
  } : () => Promise.resolve(), { when: u } = s;
  if (u) {
    const [l, d] = u === "beforeChildren" ? [o, a] : [a, o];
    return l().then(() => d());
  } else
    return Promise.all([o(), a(r.delay)]);
}
function iee(t, e, r = 0, n = 0, i = 1, s) {
  const o = [], a = (t.variantChildren.size - 1) * n, u = i === 1 ? (l = 0) => l * n : (l = 0) => a - l * n;
  return Array.from(t.variantChildren).sort(see).forEach((l, d) => {
    l.notify("AnimationStart", e), o.push(sv(l, e, {
      ...s,
      delay: r + u(d)
    }).then(() => l.notify("AnimationComplete", e)));
  }), Promise.all(o);
}
function see(t, e) {
  return t.sortNodePosition(e);
}
function oee(t, e, r = {}) {
  t.notify("AnimationStart", e);
  let n;
  if (Array.isArray(e)) {
    const i = e.map((s) => sv(t, s, r));
    n = Promise.all(i);
  } else if (typeof e == "string")
    n = sv(t, e, r);
  else {
    const i = typeof e == "function" ? bp(t, e, r.custom) : e;
    n = Promise.all(T7(t, i, r));
  }
  return n.then(() => {
    t.notify("AnimationComplete", e);
  });
}
const aee = Ib.length;
function R7(t) {
  if (!t)
    return;
  if (!t.isControllingVariants) {
    const r = t.parent ? R7(t.parent) || {} : {};
    return t.props.initial !== void 0 && (r.initial = t.props.initial), r;
  }
  const e = {};
  for (let r = 0; r < aee; r++) {
    const n = Ib[r], i = t.props[n];
    (Ml(i) || i === !1) && (e[n] = i);
  }
  return e;
}
const cee = [...Mb].reverse(), uee = Mb.length;
function fee(t) {
  return (e) => Promise.all(e.map(({ animation: r, options: n }) => oee(t, r, n)));
}
function lee(t) {
  let e = fee(t), r = l6(), n = !0;
  const i = (u) => (l, d) => {
    var p;
    const w = bp(t, d, u === "exit" ? (p = t.presenceContext) === null || p === void 0 ? void 0 : p.custom : void 0);
    if (w) {
      const { transition: P, transitionEnd: A, ...N } = w;
      l = { ...l, ...N, ...A };
    }
    return l;
  };
  function s(u) {
    e = u(t);
  }
  function o(u) {
    const { props: l } = t, d = R7(t.parent) || {}, p = [], w = /* @__PURE__ */ new Set();
    let P = {}, A = 1 / 0;
    for (let L = 0; L < uee; L++) {
      const F = cee[L], $ = r[F], K = l[F] !== void 0 ? l[F] : d[F], H = Ml(K), V = F === u ? $.isActive : null;
      V === !1 && (A = L);
      let te = K === d[F] && K !== l[F] && H;
      if (te && n && t.manuallyAnimateOnMount && (te = !1), $.protectedKeys = { ...P }, // If it isn't active and hasn't *just* been set as inactive
      !$.isActive && V === null || // If we didn't and don't have any defined prop for this animation type
      !K && !$.prevProp || // Or if the prop doesn't define an animation
      vp(K) || typeof K == "boolean")
        continue;
      const R = hee($.prevProp, K);
      let W = R || // If we're making this variant active, we want to always make it active
      F === u && $.isActive && !te && H || // If we removed a higher-priority variant (i is in reverse order)
      L > A && H, pe = !1;
      const Ee = Array.isArray(K) ? K : [K];
      let Y = Ee.reduce(i(F), {});
      V === !1 && (Y = {});
      const { prevResolvedValues: S = {} } = $, m = {
        ...S,
        ...Y
      }, f = (x) => {
        W = !0, w.has(x) && (pe = !0, w.delete(x)), $.needsAnimating[x] = !0;
        const _ = t.getValue(x);
        _ && (_.liveStyle = !1);
      };
      for (const x in m) {
        const _ = Y[x], E = S[x];
        if (P.hasOwnProperty(x))
          continue;
        let v = !1;
        J1(_) && J1(E) ? v = !KS(_, E) : v = _ !== E, v ? _ != null ? f(x) : w.add(x) : _ !== void 0 && w.has(x) ? f(x) : $.protectedKeys[x] = !0;
      }
      $.prevProp = K, $.prevResolvedValues = Y, $.isActive && (P = { ...P, ...Y }), n && t.blockInitialAnimation && (W = !1), W && (!(te && R) || pe) && p.push(...Ee.map((x) => ({
        animation: x,
        options: { type: F }
      })));
    }
    if (w.size) {
      const L = {};
      w.forEach((F) => {
        const $ = t.getBaseTarget(F), K = t.getValue(F);
        K && (K.liveStyle = !0), L[F] = $ ?? null;
      }), p.push({ animation: L });
    }
    let N = !!p.length;
    return n && (l.initial === !1 || l.initial === l.animate) && !t.manuallyAnimateOnMount && (N = !1), n = !1, N ? e(p) : Promise.resolve();
  }
  function a(u, l) {
    var d;
    if (r[u].isActive === l)
      return Promise.resolve();
    (d = t.variantChildren) === null || d === void 0 || d.forEach((w) => {
      var P;
      return (P = w.animationState) === null || P === void 0 ? void 0 : P.setActive(u, l);
    }), r[u].isActive = l;
    const p = o(u);
    for (const w in r)
      r[w].protectedKeys = {};
    return p;
  }
  return {
    animateChanges: o,
    setActive: a,
    setAnimateFunction: s,
    getState: () => r,
    reset: () => {
      r = l6(), n = !0;
    }
  };
}
function hee(t, e) {
  return typeof e == "string" ? e !== t : Array.isArray(e) ? !KS(e, t) : !1;
}
function Ka(t = !1) {
  return {
    isActive: t,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function l6() {
  return {
    animate: Ka(!0),
    whileInView: Ka(),
    whileHover: Ka(),
    whileTap: Ka(),
    whileDrag: Ka(),
    whileFocus: Ka(),
    exit: Ka()
  };
}
class Ta {
  constructor(e) {
    this.isMounted = !1, this.node = e;
  }
  update() {
  }
}
class dee extends Ta {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(e) {
    super(e), e.animationState || (e.animationState = lee(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    vp(e) && (this.unmountControls = e.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(), { animate: r } = this.node.prevProps || {};
    e !== r && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var e;
    this.node.animationState.reset(), (e = this.unmountControls) === null || e === void 0 || e.call(this);
  }
}
let pee = 0;
class gee extends Ta {
  constructor() {
    super(...arguments), this.id = pee++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: e, onExitComplete: r } = this.node.presenceContext, { isPresent: n } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === n)
      return;
    const i = this.node.animationState.setActive("exit", !e);
    r && !e && i.then(() => r(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {
  }
}
const mee = {
  animation: {
    Feature: dee
  },
  exit: {
    Feature: gee
  }
}, D7 = (t) => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1;
function wp(t, e = "page") {
  return {
    point: {
      x: t[`${e}X`],
      y: t[`${e}Y`]
    }
  };
}
const vee = (t) => (e) => D7(e) && t(e, wp(e));
function Po(t, e, r, n = { passive: !0 }) {
  return t.addEventListener(e, r, n), () => t.removeEventListener(e, r);
}
function Ro(t, e, r, n) {
  return Po(t, e, vee(r), n);
}
const h6 = (t, e) => Math.abs(t - e);
function bee(t, e) {
  const r = h6(t.x, e.x), n = h6(t.y, e.y);
  return Math.sqrt(r ** 2 + n ** 2);
}
class O7 {
  constructor(e, r, { transformPagePoint: n, contextWindow: i, dragSnapToOrigin: s = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const p = Fm(this.lastMoveEventInfo, this.history), w = this.startEvent !== null, P = bee(p.offset, { x: 0, y: 0 }) >= 3;
      if (!w && !P)
        return;
      const { point: A } = p, { timestamp: N } = Fn;
      this.history.push({ ...A, timestamp: N });
      const { onStart: L, onMove: F } = this.handlers;
      w || (L && L(this.lastMoveEvent, p), this.startEvent = this.lastMoveEvent), F && F(this.lastMoveEvent, p);
    }, this.handlePointerMove = (p, w) => {
      this.lastMoveEvent = p, this.lastMoveEventInfo = $m(w, this.transformPagePoint), Lr.update(this.updatePoint, !0);
    }, this.handlePointerUp = (p, w) => {
      this.end();
      const { onEnd: P, onSessionEnd: A, resumeAnimation: N } = this.handlers;
      if (this.dragSnapToOrigin && N && N(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const L = Fm(p.type === "pointercancel" ? this.lastMoveEventInfo : $m(w, this.transformPagePoint), this.history);
      this.startEvent && P && P(p, L), A && A(p, L);
    }, !D7(e))
      return;
    this.dragSnapToOrigin = s, this.handlers = r, this.transformPagePoint = n, this.contextWindow = i || window;
    const o = wp(e), a = $m(o, this.transformPagePoint), { point: u } = a, { timestamp: l } = Fn;
    this.history = [{ ...u, timestamp: l }];
    const { onSessionStart: d } = r;
    d && d(e, Fm(a, this.history)), this.removeListeners = To(Ro(this.contextWindow, "pointermove", this.handlePointerMove), Ro(this.contextWindow, "pointerup", this.handlePointerUp), Ro(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), wa(this.updatePoint);
  }
}
function $m(t, e) {
  return e ? { point: e(t.point) } : t;
}
function d6(t, e) {
  return { x: t.x - e.x, y: t.y - e.y };
}
function Fm({ point: t }, e) {
  return {
    point: t,
    delta: d6(t, N7(e)),
    offset: d6(t, yee(e)),
    velocity: wee(e, 0.1)
  };
}
function yee(t) {
  return t[0];
}
function N7(t) {
  return t[t.length - 1];
}
function wee(t, e) {
  if (t.length < 2)
    return { x: 0, y: 0 };
  let r = t.length - 1, n = null;
  const i = N7(t);
  for (; r >= 0 && (n = t[r], !(i.timestamp - n.timestamp > Ks(e))); )
    r--;
  if (!n)
    return { x: 0, y: 0 };
  const s = Co(i.timestamp - n.timestamp);
  if (s === 0)
    return { x: 0, y: 0 };
  const o = {
    x: (i.x - n.x) / s,
    y: (i.y - n.y) / s
  };
  return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o;
}
function L7(t) {
  let e = null;
  return () => {
    const r = () => {
      e = null;
    };
    return e === null ? (e = t, r) : !1;
  };
}
const p6 = L7("dragHorizontal"), g6 = L7("dragVertical");
function k7(t) {
  let e = !1;
  if (t === "y")
    e = g6();
  else if (t === "x")
    e = p6();
  else {
    const r = p6(), n = g6();
    r && n ? e = () => {
      r(), n();
    } : (r && r(), n && n());
  }
  return e;
}
function $7() {
  const t = k7(!0);
  return t ? (t(), !1) : !0;
}
function eu(t) {
  return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current");
}
const F7 = 1e-4, xee = 1 - F7, _ee = 1 + F7, B7 = 0.01, Eee = 0 - B7, See = 0 + B7;
function Li(t) {
  return t.max - t.min;
}
function Aee(t, e, r) {
  return Math.abs(t - e) <= r;
}
function m6(t, e, r, n = 0.5) {
  t.origin = n, t.originPoint = Qr(e.min, e.max, t.origin), t.scale = Li(r) / Li(e), t.translate = Qr(r.min, r.max, t.origin) - t.originPoint, (t.scale >= xee && t.scale <= _ee || isNaN(t.scale)) && (t.scale = 1), (t.translate >= Eee && t.translate <= See || isNaN(t.translate)) && (t.translate = 0);
}
function Yf(t, e, r, n) {
  m6(t.x, e.x, r.x, n ? n.originX : void 0), m6(t.y, e.y, r.y, n ? n.originY : void 0);
}
function v6(t, e, r) {
  t.min = r.min + e.min, t.max = t.min + Li(e);
}
function Pee(t, e, r) {
  v6(t.x, e.x, r.x), v6(t.y, e.y, r.y);
}
function b6(t, e, r) {
  t.min = e.min - r.min, t.max = t.min + Li(e);
}
function Jf(t, e, r) {
  b6(t.x, e.x, r.x), b6(t.y, e.y, r.y);
}
function Mee(t, { min: e, max: r }, n) {
  return e !== void 0 && t < e ? t = n ? Qr(e, t, n.min) : Math.max(t, e) : r !== void 0 && t > r && (t = n ? Qr(r, t, n.max) : Math.min(t, r)), t;
}
function y6(t, e, r) {
  return {
    min: e !== void 0 ? t.min + e : void 0,
    max: r !== void 0 ? t.max + r - (t.max - t.min) : void 0
  };
}
function Iee(t, { top: e, left: r, bottom: n, right: i }) {
  return {
    x: y6(t.x, r, i),
    y: y6(t.y, e, n)
  };
}
function w6(t, e) {
  let r = e.min - t.min, n = e.max - t.max;
  return e.max - e.min < t.max - t.min && ([r, n] = [n, r]), { min: r, max: n };
}
function Cee(t, e) {
  return {
    x: w6(t.x, e.x),
    y: w6(t.y, e.y)
  };
}
function Tee(t, e) {
  let r = 0.5;
  const n = Li(t), i = Li(e);
  return i > n ? r = Mu(e.min, e.max - n, t.min) : n > i && (r = Mu(t.min, t.max - i, e.min)), xa(0, 1, r);
}
function Ree(t, e) {
  const r = {};
  return e.min !== void 0 && (r.min = e.min - t.min), e.max !== void 0 && (r.max = e.max - t.min), r;
}
const ov = 0.35;
function Dee(t = ov) {
  return t === !1 ? t = 0 : t === !0 && (t = ov), {
    x: x6(t, "left", "right"),
    y: x6(t, "top", "bottom")
  };
}
function x6(t, e, r) {
  return {
    min: _6(t, e),
    max: _6(t, r)
  };
}
function _6(t, e) {
  return typeof t == "number" ? t : t[e] || 0;
}
const E6 = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), tu = () => ({
  x: E6(),
  y: E6()
}), S6 = () => ({ min: 0, max: 0 }), ln = () => ({
  x: S6(),
  y: S6()
});
function Xi(t) {
  return [t("x"), t("y")];
}
function U7({ top: t, left: e, right: r, bottom: n }) {
  return {
    x: { min: e, max: r },
    y: { min: t, max: n }
  };
}
function Oee({ x: t, y: e }) {
  return { top: e.min, right: t.max, bottom: e.max, left: t.min };
}
function Nee(t, e) {
  if (!e)
    return t;
  const r = e({ x: t.left, y: t.top }), n = e({ x: t.right, y: t.bottom });
  return {
    top: r.y,
    left: r.x,
    bottom: n.y,
    right: n.x
  };
}
function Bm(t) {
  return t === void 0 || t === 1;
}
function av({ scale: t, scaleX: e, scaleY: r }) {
  return !Bm(t) || !Bm(e) || !Bm(r);
}
function Ga(t) {
  return av(t) || j7(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY;
}
function j7(t) {
  return A6(t.x) || A6(t.y);
}
function A6(t) {
  return t && t !== "0%";
}
function w0(t, e, r) {
  const n = t - r, i = e * n;
  return r + i;
}
function P6(t, e, r, n, i) {
  return i !== void 0 && (t = w0(t, i, n)), w0(t, r, n) + e;
}
function cv(t, e = 0, r = 1, n, i) {
  t.min = P6(t.min, e, r, n, i), t.max = P6(t.max, e, r, n, i);
}
function q7(t, { x: e, y: r }) {
  cv(t.x, e.translate, e.scale, e.originPoint), cv(t.y, r.translate, r.scale, r.originPoint);
}
const M6 = 0.999999999999, I6 = 1.0000000000001;
function Lee(t, e, r, n = !1) {
  const i = r.length;
  if (!i)
    return;
  e.x = e.y = 1;
  let s, o;
  for (let a = 0; a < i; a++) {
    s = r[a], o = s.projectionDelta;
    const { visualElement: u } = s.options;
    u && u.props.style && u.props.style.display === "contents" || (n && s.options.layoutScroll && s.scroll && s !== s.root && nu(t, {
      x: -s.scroll.offset.x,
      y: -s.scroll.offset.y
    }), o && (e.x *= o.x.scale, e.y *= o.y.scale, q7(t, o)), n && Ga(s.latestValues) && nu(t, s.latestValues));
  }
  e.x < I6 && e.x > M6 && (e.x = 1), e.y < I6 && e.y > M6 && (e.y = 1);
}
function ru(t, e) {
  t.min = t.min + e, t.max = t.max + e;
}
function C6(t, e, r, n, i = 0.5) {
  const s = Qr(t.min, t.max, i);
  cv(t, e, r, s, n);
}
function nu(t, e) {
  C6(t.x, e.x, e.scaleX, e.scale, e.originX), C6(t.y, e.y, e.scaleY, e.scale, e.originY);
}
function z7(t, e) {
  return U7(Nee(t.getBoundingClientRect(), e));
}
function kee(t, e, r) {
  const n = z7(t, r), { scroll: i } = e;
  return i && (ru(n.x, i.offset.x), ru(n.y, i.offset.y)), n;
}
const H7 = ({ current: t }) => t ? t.ownerDocument.defaultView : null, $ee = /* @__PURE__ */ new WeakMap();
class Fee {
  constructor(e) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = ln(), this.visualElement = e;
  }
  start(e, { snapToCursor: r = !1 } = {}) {
    const { presenceContext: n } = this.visualElement;
    if (n && n.isPresent === !1)
      return;
    const i = (d) => {
      const { dragSnapToOrigin: p } = this.getProps();
      p ? this.pauseAnimation() : this.stopAnimation(), r && this.snapToCursor(wp(d, "page").point);
    }, s = (d, p) => {
      const { drag: w, dragPropagation: P, onDragStart: A } = this.getProps();
      if (w && !P && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = k7(w), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Xi((L) => {
        let F = this.getAxisMotionValue(L).get() || 0;
        if (Vs.test(F)) {
          const { projection: $ } = this.visualElement;
          if ($ && $.layout) {
            const K = $.layout.layoutBox[L];
            K && (F = Li(K) * (parseFloat(F) / 100));
          }
        }
        this.originPoint[L] = F;
      }), A && Lr.postRender(() => A(d, p)), iv(this.visualElement, "transform");
      const { animationState: N } = this.visualElement;
      N && N.setActive("whileDrag", !0);
    }, o = (d, p) => {
      const { dragPropagation: w, dragDirectionLock: P, onDirectionLock: A, onDrag: N } = this.getProps();
      if (!w && !this.openGlobalLock)
        return;
      const { offset: L } = p;
      if (P && this.currentDirection === null) {
        this.currentDirection = Bee(L), this.currentDirection !== null && A && A(this.currentDirection);
        return;
      }
      this.updateAxis("x", p.point, L), this.updateAxis("y", p.point, L), this.visualElement.render(), N && N(d, p);
    }, a = (d, p) => this.stop(d, p), u = () => Xi((d) => {
      var p;
      return this.getAnimationState(d) === "paused" && ((p = this.getAxisMotionValue(d).animation) === null || p === void 0 ? void 0 : p.play());
    }), { dragSnapToOrigin: l } = this.getProps();
    this.panSession = new O7(e, {
      onSessionStart: i,
      onStart: s,
      onMove: o,
      onSessionEnd: a,
      resumeAnimation: u
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: l,
      contextWindow: H7(this.visualElement)
    });
  }
  stop(e, r) {
    const n = this.isDragging;
    if (this.cancel(), !n)
      return;
    const { velocity: i } = r;
    this.startAnimation(i);
    const { onDragEnd: s } = this.getProps();
    s && Lr.postRender(() => s(e, r));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: r } = this.visualElement;
    e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: n } = this.getProps();
    !n && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), r && r.setActive("whileDrag", !1);
  }
  updateAxis(e, r, n) {
    const { drag: i } = this.getProps();
    if (!n || !md(e, i, this.currentDirection))
      return;
    const s = this.getAxisMotionValue(e);
    let o = this.originPoint[e] + n[e];
    this.constraints && this.constraints[e] && (o = Mee(o, this.constraints[e], this.elastic[e])), s.set(o);
  }
  resolveConstraints() {
    var e;
    const { dragConstraints: r, dragElastic: n } = this.getProps(), i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout, s = this.constraints;
    r && eu(r) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : r && i ? this.constraints = Iee(i.layoutBox, r) : this.constraints = !1, this.elastic = Dee(n), s !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && Xi((o) => {
      this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = Ree(i.layoutBox[o], this.constraints[o]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: r } = this.getProps();
    if (!e || !eu(e))
      return !1;
    const n = e.current;
    Uo(n !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: i } = this.visualElement;
    if (!i || !i.layout)
      return !1;
    const s = kee(n, i.root, this.visualElement.getTransformPagePoint());
    let o = Cee(i.layout.layoutBox, s);
    if (r) {
      const a = r(Oee(o));
      this.hasMutatedConstraints = !!a, a && (o = U7(a));
    }
    return o;
  }
  startAnimation(e) {
    const { drag: r, dragMomentum: n, dragElastic: i, dragTransition: s, dragSnapToOrigin: o, onDragTransitionEnd: a } = this.getProps(), u = this.constraints || {}, l = Xi((d) => {
      if (!md(d, r, this.currentDirection))
        return;
      let p = u && u[d] || {};
      o && (p = { min: 0, max: 0 });
      const w = i ? 200 : 1e6, P = i ? 40 : 1e7, A = {
        type: "inertia",
        velocity: n ? e[d] : 0,
        bounceStiffness: w,
        bounceDamping: P,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...s,
        ...p
      };
      return this.startAxisValueAnimation(d, A);
    });
    return Promise.all(l).then(a);
  }
  startAxisValueAnimation(e, r) {
    const n = this.getAxisMotionValue(e);
    return iv(this.visualElement, e), n.start(zb(e, n, 0, r, this.visualElement, !1));
  }
  stopAnimation() {
    Xi((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    Xi((e) => {
      var r;
      return (r = this.getAxisMotionValue(e).animation) === null || r === void 0 ? void 0 : r.pause();
    });
  }
  getAnimationState(e) {
    var r;
    return (r = this.getAxisMotionValue(e).animation) === null || r === void 0 ? void 0 : r.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(e) {
    const r = `_drag${e.toUpperCase()}`, n = this.visualElement.getProps(), i = n[r];
    return i || this.visualElement.getValue(e, (n.initial ? n.initial[e] : void 0) || 0);
  }
  snapToCursor(e) {
    Xi((r) => {
      const { drag: n } = this.getProps();
      if (!md(r, n, this.currentDirection))
        return;
      const { projection: i } = this.visualElement, s = this.getAxisMotionValue(r);
      if (i && i.layout) {
        const { min: o, max: a } = i.layout.layoutBox[r];
        s.set(e[r] - Qr(o, a, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: e, dragConstraints: r } = this.getProps(), { projection: n } = this.visualElement;
    if (!eu(r) || !n || !this.constraints)
      return;
    this.stopAnimation();
    const i = { x: 0, y: 0 };
    Xi((o) => {
      const a = this.getAxisMotionValue(o);
      if (a && this.constraints !== !1) {
        const u = a.get();
        i[o] = Tee({ min: u, max: u }, this.constraints[o]);
      }
    });
    const { transformTemplate: s } = this.visualElement.getProps();
    this.visualElement.current.style.transform = s ? s({}, "") : "none", n.root && n.root.updateScroll(), n.updateLayout(), this.resolveConstraints(), Xi((o) => {
      if (!md(o, e, null))
        return;
      const a = this.getAxisMotionValue(o), { min: u, max: l } = this.constraints[o];
      a.set(Qr(u, l, i[o]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    $ee.set(this.visualElement, this);
    const e = this.visualElement.current, r = Ro(e, "pointerdown", (u) => {
      const { drag: l, dragListener: d = !0 } = this.getProps();
      l && d && this.start(u);
    }), n = () => {
      const { dragConstraints: u } = this.getProps();
      eu(u) && u.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: i } = this.visualElement, s = i.addEventListener("measure", n);
    i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), Lr.read(n);
    const o = Po(window, "resize", () => this.scalePositionWithinConstraints()), a = i.addEventListener("didUpdate", ({ delta: u, hasLayoutChanged: l }) => {
      this.isDragging && l && (Xi((d) => {
        const p = this.getAxisMotionValue(d);
        p && (this.originPoint[d] += u[d].translate, p.set(p.get() + u[d].translate));
      }), this.visualElement.render());
    });
    return () => {
      o(), r(), s(), a && a();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(), { drag: r = !1, dragDirectionLock: n = !1, dragPropagation: i = !1, dragConstraints: s = !1, dragElastic: o = ov, dragMomentum: a = !0 } = e;
    return {
      ...e,
      drag: r,
      dragDirectionLock: n,
      dragPropagation: i,
      dragConstraints: s,
      dragElastic: o,
      dragMomentum: a
    };
  }
}
function md(t, e, r) {
  return (e === !0 || e === t) && (r === null || r === t);
}
function Bee(t, e = 10) {
  let r = null;
  return Math.abs(t.y) > e ? r = "y" : Math.abs(t.x) > e && (r = "x"), r;
}
class Uee extends Ta {
  constructor(e) {
    super(e), this.removeGroupControls = Un, this.removeListeners = Un, this.controls = new Fee(e);
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Un;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const T6 = (t) => (e, r) => {
  t && Lr.postRender(() => t(e, r));
};
class jee extends Ta {
  constructor() {
    super(...arguments), this.removePointerDownListener = Un;
  }
  onPointerDown(e) {
    this.session = new O7(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: H7(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: e, onPanStart: r, onPan: n, onPanEnd: i } = this.node.getProps();
    return {
      onSessionStart: T6(e),
      onStart: T6(r),
      onMove: n,
      onEnd: (s, o) => {
        delete this.session, i && Lr.postRender(() => i(s, o));
      }
    };
  }
  mount() {
    this.removePointerDownListener = Ro(this.node.current, "pointerdown", (e) => this.onPointerDown(e));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const xp = Sa(null);
function qee() {
  const t = Tn(xp);
  if (t === null)
    return [!0, null];
  const { isPresent: e, onExitComplete: r, register: n } = t, i = mv();
  Xn(() => n(i), []);
  const s = vv(() => r && r(i), [i, r]);
  return !e && r ? [!1, s] : [!0];
}
const Gb = Sa({}), W7 = Sa({}), Bd = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function R6(t, e) {
  return e.max === e.min ? 0 : t / (e.max - e.min) * 100;
}
const Df = {
  correct: (t, e) => {
    if (!e.target)
      return t;
    if (typeof t == "string")
      if (Vt.test(t))
        t = parseFloat(t);
      else
        return t;
    const r = R6(t, e.target.x), n = R6(t, e.target.y);
    return `${r}% ${n}%`;
  }
}, zee = {
  correct: (t, { treeScale: e, projectionDelta: r }) => {
    const n = t, i = _a.parse(t);
    if (i.length > 5)
      return n;
    const s = _a.createTransformer(t), o = typeof i[0] != "number" ? 1 : 0, a = r.x.scale * e.x, u = r.y.scale * e.y;
    i[0 + o] /= a, i[1 + o] /= u;
    const l = Qr(a, u, 0.5);
    return typeof i[2 + o] == "number" && (i[2 + o] /= l), typeof i[3 + o] == "number" && (i[3 + o] /= l), s(i);
  }
}, x0 = {};
function Hee(t) {
  Object.assign(x0, t);
}
const { schedule: Yb } = VS(queueMicrotask, !1);
class Wee extends AR {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: e, layoutGroup: r, switchLayoutGroup: n, layoutId: i } = this.props, { projection: s } = e;
    Hee(Kee), s && (r.group && r.group.add(s), n && n.register && i && n.register(s), s.root.didUpdate(), s.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), s.setOptions({
      ...s.options,
      onExitComplete: () => this.safeToRemove()
    })), Bd.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(e) {
    const { layoutDependency: r, visualElement: n, drag: i, isPresent: s } = this.props, o = n.projection;
    return o && (o.isPresent = s, i || e.layoutDependency !== r || r === void 0 ? o.willUpdate() : this.safeToRemove(), e.isPresent !== s && (s ? o.promote() : o.relegate() || Lr.postRender(() => {
      const a = o.getStack();
      (!a || !a.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e && (e.root.didUpdate(), Yb.postRender(() => {
      !e.currentAnimation && e.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: e, layoutGroup: r, switchLayoutGroup: n } = this.props, { projection: i } = e;
    i && (i.scheduleCheckAfterUnmount(), r && r.group && r.group.remove(i), n && n.deregister && n.deregister(i));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function K7(t) {
  const [e, r] = qee(), n = Tn(Gb);
  return me.jsx(Wee, { ...t, layoutGroup: n, switchLayoutGroup: Tn(W7), isPresent: e, safeToRemove: r });
}
const Kee = {
  borderRadius: {
    ...Df,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: Df,
  borderTopRightRadius: Df,
  borderBottomLeftRadius: Df,
  borderBottomRightRadius: Df,
  boxShadow: zee
}, V7 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], Vee = V7.length, D6 = (t) => typeof t == "string" ? parseFloat(t) : t, O6 = (t) => typeof t == "number" || Vt.test(t);
function Gee(t, e, r, n, i, s) {
  i ? (t.opacity = Qr(
    0,
    // TODO Reinstate this if only child
    r.opacity !== void 0 ? r.opacity : 1,
    Yee(n)
  ), t.opacityExit = Qr(e.opacity !== void 0 ? e.opacity : 1, 0, Jee(n))) : s && (t.opacity = Qr(e.opacity !== void 0 ? e.opacity : 1, r.opacity !== void 0 ? r.opacity : 1, n));
  for (let o = 0; o < Vee; o++) {
    const a = `border${V7[o]}Radius`;
    let u = N6(e, a), l = N6(r, a);
    if (u === void 0 && l === void 0)
      continue;
    u || (u = 0), l || (l = 0), u === 0 || l === 0 || O6(u) === O6(l) ? (t[a] = Math.max(Qr(D6(u), D6(l), n), 0), (Vs.test(l) || Vs.test(u)) && (t[a] += "%")) : t[a] = l;
  }
  (e.rotate || r.rotate) && (t.rotate = Qr(e.rotate || 0, r.rotate || 0, n));
}
function N6(t, e) {
  return t[e] !== void 0 ? t[e] : t.borderRadius;
}
const Yee = /* @__PURE__ */ G7(0, 0.5, e7), Jee = /* @__PURE__ */ G7(0.5, 0.95, Un);
function G7(t, e, r) {
  return (n) => n < t ? 0 : n > e ? 1 : r(Mu(t, e, n));
}
function L6(t, e) {
  t.min = e.min, t.max = e.max;
}
function Yi(t, e) {
  L6(t.x, e.x), L6(t.y, e.y);
}
function k6(t, e) {
  t.translate = e.translate, t.scale = e.scale, t.originPoint = e.originPoint, t.origin = e.origin;
}
function $6(t, e, r, n, i) {
  return t -= e, t = w0(t, 1 / r, n), i !== void 0 && (t = w0(t, 1 / i, n)), t;
}
function Xee(t, e = 0, r = 1, n = 0.5, i, s = t, o = t) {
  if (Vs.test(e) && (e = parseFloat(e), e = Qr(o.min, o.max, e / 100) - o.min), typeof e != "number")
    return;
  let a = Qr(s.min, s.max, n);
  t === s && (a -= e), t.min = $6(t.min, e, r, a, i), t.max = $6(t.max, e, r, a, i);
}
function F6(t, e, [r, n, i], s, o) {
  Xee(t, e[r], e[n], e[i], e.scale, s, o);
}
const Zee = ["x", "scaleX", "originX"], Qee = ["y", "scaleY", "originY"];
function B6(t, e, r, n) {
  F6(t.x, e, Zee, r ? r.x : void 0, n ? n.x : void 0), F6(t.y, e, Qee, r ? r.y : void 0, n ? n.y : void 0);
}
function U6(t) {
  return t.translate === 0 && t.scale === 1;
}
function Y7(t) {
  return U6(t.x) && U6(t.y);
}
function j6(t, e) {
  return t.min === e.min && t.max === e.max;
}
function ete(t, e) {
  return j6(t.x, e.x) && j6(t.y, e.y);
}
function q6(t, e) {
  return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max);
}
function J7(t, e) {
  return q6(t.x, e.x) && q6(t.y, e.y);
}
function z6(t) {
  return Li(t.x) / Li(t.y);
}
function H6(t, e) {
  return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint;
}
class tte {
  constructor() {
    this.members = [];
  }
  add(e) {
    Hb(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (Wb(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
      const r = this.members[this.members.length - 1];
      r && this.promote(r);
    }
  }
  relegate(e) {
    const r = this.members.findIndex((i) => e === i);
    if (r === 0)
      return !1;
    let n;
    for (let i = r; i >= 0; i--) {
      const s = this.members[i];
      if (s.isPresent !== !1) {
        n = s;
        break;
      }
    }
    return n ? (this.promote(n), !0) : !1;
  }
  promote(e, r) {
    const n = this.lead;
    if (e !== n && (this.prevLead = n, this.lead = e, e.show(), n)) {
      n.instance && n.scheduleRender(), e.scheduleRender(), e.resumeFrom = n, r && (e.resumeFrom.preserveOpacity = !0), n.snapshot && (e.snapshot = n.snapshot, e.snapshot.latestValues = n.animationValues || n.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: i } = e.options;
      i === !1 && n.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: r, resumingFrom: n } = e;
      r.onExitComplete && r.onExitComplete(), n && n.options.onExitComplete && n.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function rte(t, e, r) {
  let n = "";
  const i = t.x.translate / e.x, s = t.y.translate / e.y, o = (r == null ? void 0 : r.z) || 0;
  if ((i || s || o) && (n = `translate3d(${i}px, ${s}px, ${o}px) `), (e.x !== 1 || e.y !== 1) && (n += `scale(${1 / e.x}, ${1 / e.y}) `), r) {
    const { transformPerspective: l, rotate: d, rotateX: p, rotateY: w, skewX: P, skewY: A } = r;
    l && (n = `perspective(${l}px) ${n}`), d && (n += `rotate(${d}deg) `), p && (n += `rotateX(${p}deg) `), w && (n += `rotateY(${w}deg) `), P && (n += `skewX(${P}deg) `), A && (n += `skewY(${A}deg) `);
  }
  const a = t.x.scale * e.x, u = t.y.scale * e.y;
  return (a !== 1 || u !== 1) && (n += `scale(${a}, ${u})`), n || "none";
}
const nte = (t, e) => t.depth - e.depth;
class ite {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(e) {
    Hb(this.children, e), this.isDirty = !0;
  }
  remove(e) {
    Wb(this.children, e), this.isDirty = !0;
  }
  forEach(e) {
    this.isDirty && this.children.sort(nte), this.isDirty = !1, this.children.forEach(e);
  }
}
function Ud(t) {
  const e = Jn(t) ? t.get() : t;
  return YQ(e) ? e.toValue() : e;
}
function ste(t, e) {
  const r = Gs.now(), n = ({ timestamp: i }) => {
    const s = i - r;
    s >= e && (wa(n), t(s - e));
  };
  return Lr.read(n, !0), () => wa(n);
}
function ote(t) {
  return t instanceof SVGElement && t.tagName !== "svg";
}
function ate(t, e, r) {
  const n = Jn(t) ? t : Tl(t);
  return n.start(zb("", n, e, r)), n.animation;
}
const Ya = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
}, Uf = typeof window < "u" && window.MotionDebug !== void 0, Um = ["", "X", "Y", "Z"], cte = { visibility: "hidden" }, W6 = 1e3;
let ute = 0;
function jm(t, e, r, n) {
  const { latestValues: i } = e;
  i[t] && (r[t] = i[t], e.setStaticValue(t, 0), n && (n[t] = 0));
}
function X7(t) {
  if (t.hasCheckedOptimisedAppear = !0, t.root === t)
    return;
  const { visualElement: e } = t.options;
  if (!e)
    return;
  const r = C7(e);
  if (window.MotionHasOptimisedAnimation(r, "transform")) {
    const { layout: i, layoutId: s } = t.options;
    window.MotionCancelOptimisedAnimation(r, "transform", Lr, !(i || s));
  }
  const { parent: n } = t;
  n && !n.hasCheckedOptimisedAppear && X7(n);
}
function Z7({ attachResizeListener: t, defaultParent: e, measureScroll: r, checkIsScrollRoot: n, resetTransform: i }) {
  return class {
    constructor(o = {}, a = e == null ? void 0 : e()) {
      this.id = ute++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, Uf && (Ya.totalNodes = Ya.resolvedTargetDeltas = Ya.recalculatedProjection = 0), this.nodes.forEach(hte), this.nodes.forEach(vte), this.nodes.forEach(bte), this.nodes.forEach(dte), Uf && window.MotionDebug.record(Ya);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = o, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
      for (let u = 0; u < this.path.length; u++)
        this.path[u].shouldResetTransform = !0;
      this.root === this && (this.nodes = new ite());
    }
    addEventListener(o, a) {
      return this.eventHandlers.has(o) || this.eventHandlers.set(o, new Kb()), this.eventHandlers.get(o).add(a);
    }
    notifyListeners(o, ...a) {
      const u = this.eventHandlers.get(o);
      u && u.notify(...a);
    }
    hasListeners(o) {
      return this.eventHandlers.has(o);
    }
    /**
     * Lifecycles
     */
    mount(o, a = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = ote(o), this.instance = o;
      const { layoutId: u, layout: l, visualElement: d } = this.options;
      if (d && !d.current && d.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (l || u) && (this.isLayoutDirty = !0), t) {
        let p;
        const w = () => this.root.updateBlockedByResize = !1;
        t(o, () => {
          this.root.updateBlockedByResize = !0, p && p(), p = ste(w, 250), Bd.hasAnimatedSinceResize && (Bd.hasAnimatedSinceResize = !1, this.nodes.forEach(V6));
        });
      }
      u && this.root.registerSharedNode(u, this), this.options.animate !== !1 && d && (u || l) && this.addEventListener("didUpdate", ({ delta: p, hasLayoutChanged: w, hasRelativeTargetChanged: P, layout: A }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const N = this.options.transition || d.getDefaultTransition() || Ete, { onLayoutAnimationStart: L, onLayoutAnimationComplete: F } = d.getProps(), $ = !this.targetLayout || !J7(this.targetLayout, A) || P, K = !w && P;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || K || w && ($ || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(p, K);
          const H = {
            ...Cb(N, "layout"),
            onPlay: L,
            onComplete: F
          };
          (d.shouldReduceMotion || this.options.layoutRoot) && (H.delay = 0, H.type = !1), this.startAnimation(H);
        } else
          w || V6(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = A;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const o = this.getStack();
      o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, wa(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(yte), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: o } = this.options;
      return o && o.getProps().transformTemplate;
    }
    willUpdate(o = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && X7(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let d = 0; d < this.path.length; d++) {
        const p = this.path[d];
        p.shouldResetTransform = !0, p.updateScroll("snapshot"), p.options.layoutRoot && p.willUpdate(!1);
      }
      const { layoutId: a, layout: u } = this.options;
      if (a === void 0 && !u)
        return;
      const l = this.getTransformTemplate();
      this.prevTransformTemplateValue = l ? l(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(K6);
        return;
      }
      this.isUpdating || this.nodes.forEach(gte), this.isUpdating = !1, this.nodes.forEach(mte), this.nodes.forEach(fte), this.nodes.forEach(lte), this.clearAllSnapshots();
      const a = Gs.now();
      Fn.delta = xa(0, 1e3 / 60, a - Fn.timestamp), Fn.timestamp = a, Fn.isProcessing = !0, Dm.update.process(Fn), Dm.preRender.process(Fn), Dm.render.process(Fn), Fn.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, Yb.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(pte), this.sharedNodes.forEach(wte);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Lr.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      Lr.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let u = 0; u < this.path.length; u++)
          this.path[u].updateScroll();
      const o = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = ln(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0);
    }
    updateScroll(o = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a) {
        const u = n(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: o,
          isRoot: u,
          offset: r(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : u
        };
      }
    }
    resetTransform() {
      if (!i)
        return;
      const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !Y7(this.projectionDelta), u = this.getTransformTemplate(), l = u ? u(this.latestValues, "") : void 0, d = l !== this.prevTransformTemplateValue;
      o && (a || Ga(this.latestValues) || d) && (i(this.instance, l), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(o = !0) {
      const a = this.measurePageBox();
      let u = this.removeElementScroll(a);
      return o && (u = this.removeTransform(u)), Ste(u), {
        animationId: this.root.animationId,
        measuredBox: a,
        layoutBox: u,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var o;
      const { visualElement: a } = this.options;
      if (!a)
        return ln();
      const u = a.measureViewportBox();
      if (!(((o = this.scroll) === null || o === void 0 ? void 0 : o.wasRoot) || this.path.some(Ate))) {
        const { scroll: d } = this.root;
        d && (ru(u.x, d.offset.x), ru(u.y, d.offset.y));
      }
      return u;
    }
    removeElementScroll(o) {
      var a;
      const u = ln();
      if (Yi(u, o), !((a = this.scroll) === null || a === void 0) && a.wasRoot)
        return u;
      for (let l = 0; l < this.path.length; l++) {
        const d = this.path[l], { scroll: p, options: w } = d;
        d !== this.root && p && w.layoutScroll && (p.wasRoot && Yi(u, o), ru(u.x, p.offset.x), ru(u.y, p.offset.y));
      }
      return u;
    }
    applyTransform(o, a = !1) {
      const u = ln();
      Yi(u, o);
      for (let l = 0; l < this.path.length; l++) {
        const d = this.path[l];
        !a && d.options.layoutScroll && d.scroll && d !== d.root && nu(u, {
          x: -d.scroll.offset.x,
          y: -d.scroll.offset.y
        }), Ga(d.latestValues) && nu(u, d.latestValues);
      }
      return Ga(this.latestValues) && nu(u, this.latestValues), u;
    }
    removeTransform(o) {
      const a = ln();
      Yi(a, o);
      for (let u = 0; u < this.path.length; u++) {
        const l = this.path[u];
        if (!l.instance || !Ga(l.latestValues))
          continue;
        av(l.latestValues) && l.updateSnapshot();
        const d = ln(), p = l.measurePageBox();
        Yi(d, p), B6(a, l.latestValues, l.snapshot ? l.snapshot.layoutBox : void 0, d);
      }
      return Ga(this.latestValues) && B6(a, this.latestValues), a;
    }
    setTargetDelta(o) {
      this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(o) {
      this.options = {
        ...this.options,
        ...o,
        crossfade: o.crossfade !== void 0 ? o.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Fn.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(o = !1) {
      var a;
      const u = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = u.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = u.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = u.isSharedProjectionDirty);
      const l = !!this.resumingFrom || this !== u;
      if (!(o || l && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: p, layoutId: w } = this.options;
      if (!(!this.layout || !(p || w))) {
        if (this.resolvedRelativeTargetAt = Fn.timestamp, !this.targetDelta && !this.relativeTarget) {
          const P = this.getClosestProjectingParent();
          P && P.layout && this.animationProgress !== 1 ? (this.relativeParent = P, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ln(), this.relativeTargetOrigin = ln(), Jf(this.relativeTargetOrigin, this.layout.layoutBox, P.layout.layoutBox), Yi(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = ln(), this.targetWithTransforms = ln()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), Pee(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Yi(this.target, this.layout.layoutBox), q7(this.target, this.targetDelta)) : Yi(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const P = this.getClosestProjectingParent();
            P && !!P.resumingFrom == !!this.resumingFrom && !P.options.layoutScroll && P.target && this.animationProgress !== 1 ? (this.relativeParent = P, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ln(), this.relativeTargetOrigin = ln(), Jf(this.relativeTargetOrigin, this.target, P.target), Yi(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          Uf && Ya.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || av(this.parent.latestValues) || j7(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var o;
      const a = this.getLead(), u = !!this.resumingFrom || this !== a;
      let l = !0;
      if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (l = !1), u && (this.isSharedProjectionDirty || this.isTransformDirty) && (l = !1), this.resolvedRelativeTargetAt === Fn.timestamp && (l = !1), l)
        return;
      const { layout: d, layoutId: p } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(d || p))
        return;
      Yi(this.layoutCorrected, this.layout.layoutBox);
      const w = this.treeScale.x, P = this.treeScale.y;
      Lee(this.layoutCorrected, this.treeScale, this.path, u), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = ln());
      const { target: A } = a;
      if (!A) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (k6(this.prevProjectionDelta.x, this.projectionDelta.x), k6(this.prevProjectionDelta.y, this.projectionDelta.y)), Yf(this.projectionDelta, this.layoutCorrected, A, this.latestValues), (this.treeScale.x !== w || this.treeScale.y !== P || !H6(this.projectionDelta.x, this.prevProjectionDelta.x) || !H6(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", A)), Uf && Ya.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(o = !0) {
      var a;
      if ((a = this.options.visualElement) === null || a === void 0 || a.scheduleRender(), o) {
        const u = this.getStack();
        u && u.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = tu(), this.projectionDelta = tu(), this.projectionDeltaWithTransform = tu();
    }
    setAnimationOrigin(o, a = !1) {
      const u = this.snapshot, l = u ? u.latestValues : {}, d = { ...this.latestValues }, p = tu();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
      const w = ln(), P = u ? u.source : void 0, A = this.layout ? this.layout.source : void 0, N = P !== A, L = this.getStack(), F = !L || L.members.length <= 1, $ = !!(N && !F && this.options.crossfade === !0 && !this.path.some(_te));
      this.animationProgress = 0;
      let K;
      this.mixTargetDelta = (H) => {
        const V = H / 1e3;
        G6(p.x, o.x, V), G6(p.y, o.y, V), this.setTargetDelta(p), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Jf(w, this.layout.layoutBox, this.relativeParent.layout.layoutBox), xte(this.relativeTarget, this.relativeTargetOrigin, w, V), K && ete(this.relativeTarget, K) && (this.isProjectionDirty = !1), K || (K = ln()), Yi(K, this.relativeTarget)), N && (this.animationValues = d, Gee(d, l, this.latestValues, V, $, F)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = V;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(o) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (wa(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Lr.update(() => {
        Bd.hasAnimatedSinceResize = !0, this.currentAnimation = ate(0, W6, {
          ...o,
          onUpdate: (a) => {
            this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a);
          },
          onComplete: () => {
            o.onComplete && o.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const o = this.getStack();
      o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(W6), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const o = this.getLead();
      let { targetWithTransforms: a, target: u, layout: l, latestValues: d } = o;
      if (!(!a || !u || !l)) {
        if (this !== o && this.layout && l && Q7(this.options.animationType, this.layout.layoutBox, l.layoutBox)) {
          u = this.target || ln();
          const p = Li(this.layout.layoutBox.x);
          u.x.min = o.target.x.min, u.x.max = u.x.min + p;
          const w = Li(this.layout.layoutBox.y);
          u.y.min = o.target.y.min, u.y.max = u.y.min + w;
        }
        Yi(a, u), nu(a, d), Yf(this.projectionDeltaWithTransform, this.layoutCorrected, a, d);
      }
    }
    registerSharedNode(o, a) {
      this.sharedNodes.has(o) || this.sharedNodes.set(o, new tte()), this.sharedNodes.get(o).add(a);
      const l = a.options.initialPromotionConfig;
      a.promote({
        transition: l ? l.transition : void 0,
        preserveFollowOpacity: l && l.shouldPreserveFollowOpacity ? l.shouldPreserveFollowOpacity(a) : void 0
      });
    }
    isLead() {
      const o = this.getStack();
      return o ? o.lead === this : !0;
    }
    getLead() {
      var o;
      const { layoutId: a } = this.options;
      return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this;
    }
    getPrevLead() {
      var o;
      const { layoutId: a } = this.options;
      return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0;
    }
    getStack() {
      const { layoutId: o } = this.options;
      if (o)
        return this.root.sharedNodes.get(o);
    }
    promote({ needsReset: o, transition: a, preserveFollowOpacity: u } = {}) {
      const l = this.getStack();
      l && l.promote(this, u), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a });
    }
    relegate() {
      const o = this.getStack();
      return o ? o.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: o } = this.options;
      if (!o)
        return;
      let a = !1;
      const { latestValues: u } = o;
      if ((u.z || u.rotate || u.rotateX || u.rotateY || u.rotateZ || u.skewX || u.skewY) && (a = !0), !a)
        return;
      const l = {};
      u.z && jm("z", o, l, this.animationValues);
      for (let d = 0; d < Um.length; d++)
        jm(`rotate${Um[d]}`, o, l, this.animationValues), jm(`skew${Um[d]}`, o, l, this.animationValues);
      o.render();
      for (const d in l)
        o.setStaticValue(d, l[d]), this.animationValues && (this.animationValues[d] = l[d]);
      o.scheduleRender();
    }
    getProjectionStyles(o) {
      var a, u;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return cte;
      const l = {
        visibility: ""
      }, d = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, l.opacity = "", l.pointerEvents = Ud(o == null ? void 0 : o.pointerEvents) || "", l.transform = d ? d(this.latestValues, "") : "none", l;
      const p = this.getLead();
      if (!this.projectionDelta || !this.layout || !p.target) {
        const N = {};
        return this.options.layoutId && (N.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, N.pointerEvents = Ud(o == null ? void 0 : o.pointerEvents) || ""), this.hasProjected && !Ga(this.latestValues) && (N.transform = d ? d({}, "") : "none", this.hasProjected = !1), N;
      }
      const w = p.animationValues || p.latestValues;
      this.applyTransformsToTarget(), l.transform = rte(this.projectionDeltaWithTransform, this.treeScale, w), d && (l.transform = d(w, l.transform));
      const { x: P, y: A } = this.projectionDelta;
      l.transformOrigin = `${P.origin * 100}% ${A.origin * 100}% 0`, p.animationValues ? l.opacity = p === this ? (u = (a = w.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && u !== void 0 ? u : 1 : this.preserveOpacity ? this.latestValues.opacity : w.opacityExit : l.opacity = p === this ? w.opacity !== void 0 ? w.opacity : "" : w.opacityExit !== void 0 ? w.opacityExit : 0;
      for (const N in x0) {
        if (w[N] === void 0)
          continue;
        const { correct: L, applyTo: F } = x0[N], $ = l.transform === "none" ? w[N] : L(w[N], p);
        if (F) {
          const K = F.length;
          for (let H = 0; H < K; H++)
            l[F[H]] = $;
        } else
          l[N] = $;
      }
      return this.options.layoutId && (l.pointerEvents = p === this ? Ud(o == null ? void 0 : o.pointerEvents) || "" : "none"), l;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((o) => {
        var a;
        return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop();
      }), this.root.nodes.forEach(K6), this.root.sharedNodes.clear();
    }
  };
}
function fte(t) {
  t.updateLayout();
}
function lte(t) {
  var e;
  const r = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot;
  if (t.isLead() && t.layout && r && t.hasListeners("didUpdate")) {
    const { layoutBox: n, measuredBox: i } = t.layout, { animationType: s } = t.options, o = r.source !== t.layout.source;
    s === "size" ? Xi((p) => {
      const w = o ? r.measuredBox[p] : r.layoutBox[p], P = Li(w);
      w.min = n[p].min, w.max = w.min + P;
    }) : Q7(s, r.layoutBox, n) && Xi((p) => {
      const w = o ? r.measuredBox[p] : r.layoutBox[p], P = Li(n[p]);
      w.max = w.min + P, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[p].max = t.relativeTarget[p].min + P);
    });
    const a = tu();
    Yf(a, n, r.layoutBox);
    const u = tu();
    o ? Yf(u, t.applyTransform(i, !0), r.measuredBox) : Yf(u, n, r.layoutBox);
    const l = !Y7(a);
    let d = !1;
    if (!t.resumeFrom) {
      const p = t.getClosestProjectingParent();
      if (p && !p.resumeFrom) {
        const { snapshot: w, layout: P } = p;
        if (w && P) {
          const A = ln();
          Jf(A, r.layoutBox, w.layoutBox);
          const N = ln();
          Jf(N, n, P.layoutBox), J7(A, N) || (d = !0), p.options.layoutRoot && (t.relativeTarget = N, t.relativeTargetOrigin = A, t.relativeParent = p);
        }
      }
    }
    t.notifyListeners("didUpdate", {
      layout: n,
      snapshot: r,
      delta: u,
      layoutDelta: a,
      hasLayoutChanged: l,
      hasRelativeTargetChanged: d
    });
  } else if (t.isLead()) {
    const { onExitComplete: n } = t.options;
    n && n();
  }
  t.options.transition = void 0;
}
function hte(t) {
  Uf && Ya.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty));
}
function dte(t) {
  t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1;
}
function pte(t) {
  t.clearSnapshot();
}
function K6(t) {
  t.clearMeasurements();
}
function gte(t) {
  t.isLayoutDirty = !1;
}
function mte(t) {
  const { visualElement: e } = t.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform();
}
function V6(t) {
  t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0;
}
function vte(t) {
  t.resolveTargetDelta();
}
function bte(t) {
  t.calcProjection();
}
function yte(t) {
  t.resetSkewAndRotation();
}
function wte(t) {
  t.removeLeadSnapshot();
}
function G6(t, e, r) {
  t.translate = Qr(e.translate, 0, r), t.scale = Qr(e.scale, 1, r), t.origin = e.origin, t.originPoint = e.originPoint;
}
function Y6(t, e, r, n) {
  t.min = Qr(e.min, r.min, n), t.max = Qr(e.max, r.max, n);
}
function xte(t, e, r, n) {
  Y6(t.x, e.x, r.x, n), Y6(t.y, e.y, r.y, n);
}
function _te(t) {
  return t.animationValues && t.animationValues.opacityExit !== void 0;
}
const Ete = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, J6 = (t) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), X6 = J6("applewebkit/") && !J6("chrome/") ? Math.round : Un;
function Z6(t) {
  t.min = X6(t.min), t.max = X6(t.max);
}
function Ste(t) {
  Z6(t.x), Z6(t.y);
}
function Q7(t, e, r) {
  return t === "position" || t === "preserve-aspect" && !Aee(z6(e), z6(r), 0.2);
}
function Ate(t) {
  var e;
  return t !== t.root && ((e = t.scroll) === null || e === void 0 ? void 0 : e.wasRoot);
}
const Pte = Z7({
  attachResizeListener: (t, e) => Po(t, "resize", e),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), qm = {
  current: void 0
}, e9 = Z7({
  measureScroll: (t) => ({
    x: t.scrollLeft,
    y: t.scrollTop
  }),
  defaultParent: () => {
    if (!qm.current) {
      const t = new Pte({});
      t.mount(window), t.setOptions({ layoutScroll: !0 }), qm.current = t;
    }
    return qm.current;
  },
  resetTransform: (t, e) => {
    t.style.transform = e !== void 0 ? e : "none";
  },
  checkIsScrollRoot: (t) => window.getComputedStyle(t).position === "fixed"
}), Mte = {
  pan: {
    Feature: jee
  },
  drag: {
    Feature: Uee,
    ProjectionNode: e9,
    MeasureLayout: K7
  }
};
function Q6(t, e) {
  const r = e ? "pointerenter" : "pointerleave", n = e ? "onHoverStart" : "onHoverEnd", i = (s, o) => {
    if (s.pointerType === "touch" || $7())
      return;
    const a = t.getProps();
    t.animationState && a.whileHover && t.animationState.setActive("whileHover", e);
    const u = a[n];
    u && Lr.postRender(() => u(s, o));
  };
  return Ro(t.current, r, i, {
    passive: !t.getProps()[n]
  });
}
class Ite extends Ta {
  mount() {
    this.unmount = To(Q6(this.node, !0), Q6(this.node, !1));
  }
  unmount() {
  }
}
class Cte extends Ta {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = To(Po(this.node.current, "focus", () => this.onFocus()), Po(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const t9 = (t, e) => e ? t === e ? !0 : t9(t, e.parentElement) : !1;
function zm(t, e) {
  if (!e)
    return;
  const r = new PointerEvent("pointer" + t);
  e(r, wp(r));
}
class Tte extends Ta {
  constructor() {
    super(...arguments), this.removeStartListeners = Un, this.removeEndListeners = Un, this.removeAccessibleListeners = Un, this.startPointerPress = (e, r) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const n = this.node.getProps(), s = Ro(window, "pointerup", (a, u) => {
        if (!this.checkPressEnd())
          return;
        const { onTap: l, onTapCancel: d, globalTapTarget: p } = this.node.getProps(), w = !p && !t9(this.node.current, a.target) ? d : l;
        w && Lr.update(() => w(a, u));
      }, {
        passive: !(n.onTap || n.onPointerUp)
      }), o = Ro(window, "pointercancel", (a, u) => this.cancelPress(a, u), {
        passive: !(n.onTapCancel || n.onPointerCancel)
      });
      this.removeEndListeners = To(s, o), this.startPress(e, r);
    }, this.startAccessiblePress = () => {
      const e = (s) => {
        if (s.key !== "Enter" || this.isPressing)
          return;
        const o = (a) => {
          a.key !== "Enter" || !this.checkPressEnd() || zm("up", (u, l) => {
            const { onTap: d } = this.node.getProps();
            d && Lr.postRender(() => d(u, l));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = Po(this.node.current, "keyup", o), zm("down", (a, u) => {
          this.startPress(a, u);
        });
      }, r = Po(this.node.current, "keydown", e), n = () => {
        this.isPressing && zm("cancel", (s, o) => this.cancelPress(s, o));
      }, i = Po(this.node.current, "blur", n);
      this.removeAccessibleListeners = To(r, i);
    };
  }
  startPress(e, r) {
    this.isPressing = !0;
    const { onTapStart: n, whileTap: i } = this.node.getProps();
    i && this.node.animationState && this.node.animationState.setActive("whileTap", !0), n && Lr.postRender(() => n(e, r));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !$7();
  }
  cancelPress(e, r) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel: n } = this.node.getProps();
    n && Lr.postRender(() => n(e, r));
  }
  mount() {
    const e = this.node.getProps(), r = Ro(e.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
      passive: !(e.onTapStart || e.onPointerStart)
    }), n = Po(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = To(r, n);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const uv = /* @__PURE__ */ new WeakMap(), Hm = /* @__PURE__ */ new WeakMap(), Rte = (t) => {
  const e = uv.get(t.target);
  e && e(t);
}, Dte = (t) => {
  t.forEach(Rte);
};
function Ote({ root: t, ...e }) {
  const r = t || document;
  Hm.has(r) || Hm.set(r, {});
  const n = Hm.get(r), i = JSON.stringify(e);
  return n[i] || (n[i] = new IntersectionObserver(Dte, { root: t, ...e })), n[i];
}
function Nte(t, e, r) {
  const n = Ote(e);
  return uv.set(t, r), n.observe(t), () => {
    uv.delete(t), n.unobserve(t);
  };
}
const Lte = {
  some: 0,
  all: 1
};
class kte extends Ta {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(), { root: r, margin: n, amount: i = "some", once: s } = e, o = {
      root: r ? r.current : void 0,
      rootMargin: n,
      threshold: typeof i == "number" ? i : Lte[i]
    }, a = (u) => {
      const { isIntersecting: l } = u;
      if (this.isInView === l || (this.isInView = l, s && !l && this.hasEnteredView))
        return;
      l && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", l);
      const { onViewportEnter: d, onViewportLeave: p } = this.node.getProps(), w = l ? d : p;
      w && w(u);
    };
    return Nte(this.node.current, o, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: e, prevProps: r } = this.node;
    ["amount", "margin", "root"].some($te(e, r)) && this.startObserver();
  }
  unmount() {
  }
}
function $te({ viewport: t = {} }, { viewport: e = {} } = {}) {
  return (r) => t[r] !== e[r];
}
const Fte = {
  inView: {
    Feature: kte
  },
  tap: {
    Feature: Tte
  },
  focus: {
    Feature: Cte
  },
  hover: {
    Feature: Ite
  }
}, Bte = {
  layout: {
    ProjectionNode: e9,
    MeasureLayout: K7
  }
}, Jb = Sa({
  transformPagePoint: (t) => t,
  isStatic: !1,
  reducedMotion: "never"
}), _p = Sa({}), Xb = typeof window < "u", r9 = Xb ? PR : Xn, n9 = Sa({ strict: !1 });
function Ute(t, e, r, n, i) {
  var s, o;
  const { visualElement: a } = Tn(_p), u = Tn(n9), l = Tn(xp), d = Tn(Jb).reducedMotion, p = bi();
  n = n || u.renderer, !p.current && n && (p.current = n(t, {
    visualState: e,
    parent: a,
    props: r,
    presenceContext: l,
    blockInitialAnimation: l ? l.initial === !1 : !1,
    reducedMotionConfig: d
  }));
  const w = p.current, P = Tn(W7);
  w && !w.projection && i && (w.type === "html" || w.type === "svg") && jte(p.current, r, i, P);
  const A = bi(!1);
  v5(() => {
    w && A.current && w.update(r, l);
  });
  const N = r[I7], L = bi(!!N && !(!((s = window.MotionHandoffIsComplete) === null || s === void 0) && s.call(window, N)) && ((o = window.MotionHasOptimisedAnimation) === null || o === void 0 ? void 0 : o.call(window, N)));
  return r9(() => {
    w && (A.current = !0, window.MotionIsMounted = !0, w.updateFeatures(), Yb.render(w.render), L.current && w.animationState && w.animationState.animateChanges());
  }), Xn(() => {
    w && (!L.current && w.animationState && w.animationState.animateChanges(), L.current && (queueMicrotask(() => {
      var F;
      (F = window.MotionHandoffMarkAsComplete) === null || F === void 0 || F.call(window, N);
    }), L.current = !1));
  }), w;
}
function jte(t, e, r, n) {
  const { layoutId: i, layout: s, drag: o, dragConstraints: a, layoutScroll: u, layoutRoot: l } = e;
  t.projection = new r(t.latestValues, e["data-framer-portal-id"] ? void 0 : i9(t.parent)), t.projection.setOptions({
    layoutId: i,
    layout: s,
    alwaysMeasureLayout: !!o || a && eu(a),
    visualElement: t,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof s == "string" ? s : "both",
    initialPromotionConfig: n,
    layoutScroll: u,
    layoutRoot: l
  });
}
function i9(t) {
  if (t)
    return t.options.allowProjection !== !1 ? t.projection : i9(t.parent);
}
function qte(t, e, r) {
  return vv(
    (n) => {
      n && t.mount && t.mount(n), e && (n ? e.mount(n) : e.unmount()), r && (typeof r == "function" ? r(n) : eu(r) && (r.current = n));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [e]
  );
}
function Ep(t) {
  return vp(t.animate) || Ib.some((e) => Ml(t[e]));
}
function s9(t) {
  return !!(Ep(t) || t.variants);
}
function zte(t, e) {
  if (Ep(t)) {
    const { initial: r, animate: n } = t;
    return {
      initial: r === !1 || Ml(r) ? r : void 0,
      animate: Ml(n) ? n : void 0
    };
  }
  return t.inherit !== !1 ? e : {};
}
function Hte(t) {
  const { initial: e, animate: r } = zte(t, Tn(_p));
  return Oi(() => ({ initial: e, animate: r }), [e5(e), e5(r)]);
}
function e5(t) {
  return Array.isArray(t) ? t.join(" ") : t;
}
const t5 = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, Iu = {};
for (const t in t5)
  Iu[t] = {
    isEnabled: (e) => t5[t].some((r) => !!e[r])
  };
function Wte(t) {
  for (const e in t)
    Iu[e] = {
      ...Iu[e],
      ...t[e]
    };
}
const Kte = Symbol.for("motionComponentSymbol");
function Vte({ preloadedFeatures: t, createVisualElement: e, useRender: r, useVisualState: n, Component: i }) {
  t && Wte(t);
  function s(a, u) {
    let l;
    const d = {
      ...Tn(Jb),
      ...a,
      layoutId: Gte(a)
    }, { isStatic: p } = d, w = Hte(a), P = n(a, p);
    if (!p && Xb) {
      Yte(d, t);
      const A = Jte(d);
      l = A.MeasureLayout, w.visualElement = Ute(i, P, d, e, A.ProjectionNode);
    }
    return me.jsxs(_p.Provider, { value: w, children: [l && w.visualElement ? me.jsx(l, { visualElement: w.visualElement, ...d }) : null, r(i, a, qte(P, w.visualElement, u), P, p, w.visualElement)] });
  }
  const o = gv(s);
  return o[Kte] = i, o;
}
function Gte({ layoutId: t }) {
  const e = Tn(Gb).id;
  return e && t !== void 0 ? e + "-" + t : t;
}
function Yte(t, e) {
  const r = Tn(n9).strict;
  if (process.env.NODE_ENV !== "production" && e && r) {
    const n = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    t.ignoreStrict ? Wu(!1, n) : Uo(!1, n);
  }
}
function Jte(t) {
  const { drag: e, layout: r } = Iu;
  if (!e && !r)
    return {};
  const n = { ...e, ...r };
  return {
    MeasureLayout: e != null && e.isEnabled(t) || r != null && r.isEnabled(t) ? n.MeasureLayout : void 0,
    ProjectionNode: n.ProjectionNode
  };
}
const Xte = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function Zb(t) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof t != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    t.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(Xte.indexOf(t) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(t))
    )
  );
}
function o9(t, { style: e, vars: r }, n, i) {
  Object.assign(t.style, e, i && i.getProjectionStyles(n));
  for (const s in r)
    t.style.setProperty(s, r[s]);
}
const a9 = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function c9(t, e, r, n) {
  o9(t, e, void 0, n);
  for (const i in e.attrs)
    t.setAttribute(a9.has(i) ? i : Vb(i), e.attrs[i]);
}
function u9(t, { layout: e, layoutId: r }) {
  return Sc.has(t) || t.startsWith("origin") || (e || r !== void 0) && (!!x0[t] || t === "opacity");
}
function Qb(t, e, r) {
  var n;
  const { style: i } = t, s = {};
  for (const o in i)
    (Jn(i[o]) || e.style && Jn(e.style[o]) || u9(o, t) || ((n = r == null ? void 0 : r.getValue(o)) === null || n === void 0 ? void 0 : n.liveStyle) !== void 0) && (s[o] = i[o]);
  return s;
}
function f9(t, e, r) {
  const n = Qb(t, e, r);
  for (const i in t)
    if (Jn(t[i]) || Jn(e[i])) {
      const s = oh.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
      n[s] = t[i];
    }
  return n;
}
function ey(t) {
  const e = bi(null);
  return e.current === null && (e.current = t()), e.current;
}
function Zte({ scrapeMotionValuesFromProps: t, createRenderState: e, onMount: r }, n, i, s) {
  const o = {
    latestValues: Qte(n, i, s, t),
    renderState: e()
  };
  return r && (o.mount = (a) => r(n, a, o)), o;
}
const l9 = (t) => (e, r) => {
  const n = Tn(_p), i = Tn(xp), s = () => Zte(t, e, n, i);
  return r ? s() : ey(s);
};
function Qte(t, e, r, n) {
  const i = {}, s = n(t, {});
  for (const w in s)
    i[w] = Ud(s[w]);
  let { initial: o, animate: a } = t;
  const u = Ep(t), l = s9(t);
  e && l && !u && t.inherit !== !1 && (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate));
  let d = r ? r.initial === !1 : !1;
  d = d || o === !1;
  const p = d ? a : o;
  if (p && typeof p != "boolean" && !vp(p)) {
    const w = Array.isArray(p) ? p : [p];
    for (let P = 0; P < w.length; P++) {
      const A = Pb(t, w[P]);
      if (A) {
        const { transitionEnd: N, transition: L, ...F } = A;
        for (const $ in F) {
          let K = F[$];
          if (Array.isArray(K)) {
            const H = d ? K.length - 1 : 0;
            K = K[H];
          }
          K !== null && (i[$] = K);
        }
        for (const $ in N)
          i[$] = N[$];
      }
    }
  }
  return i;
}
const ty = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
}), h9 = () => ({
  ...ty(),
  attrs: {}
}), d9 = (t, e) => e && typeof t == "number" ? e.transform(t) : t, ere = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, tre = oh.length;
function rre(t, e, r) {
  let n = "", i = !0;
  for (let s = 0; s < tre; s++) {
    const o = oh[s], a = t[o];
    if (a === void 0)
      continue;
    let u = !0;
    if (typeof a == "number" ? u = a === (o.startsWith("scale") ? 1 : 0) : u = parseFloat(a) === 0, !u || r) {
      const l = d9(a, kb[o]);
      if (!u) {
        i = !1;
        const d = ere[o] || o;
        n += `${d}(${l}) `;
      }
      r && (e[o] = l);
    }
  }
  return n = n.trim(), r ? n = r(e, i ? "" : n) : i && (n = "none"), n;
}
function ry(t, e, r) {
  const { style: n, vars: i, transformOrigin: s } = t;
  let o = !1, a = !1;
  for (const u in e) {
    const l = e[u];
    if (Sc.has(u)) {
      o = !0;
      continue;
    } else if (s7(u)) {
      i[u] = l;
      continue;
    } else {
      const d = d9(l, kb[u]);
      u.startsWith("origin") ? (a = !0, s[u] = d) : n[u] = d;
    }
  }
  if (e.transform || (o || r ? n.transform = rre(e, t.transform, r) : n.transform && (n.transform = "none")), a) {
    const { originX: u = "50%", originY: l = "50%", originZ: d = 0 } = s;
    n.transformOrigin = `${u} ${l} ${d}`;
  }
}
function r5(t, e, r) {
  return typeof t == "string" ? t : Vt.transform(e + r * t);
}
function nre(t, e, r) {
  const n = r5(e, t.x, t.width), i = r5(r, t.y, t.height);
  return `${n} ${i}`;
}
const ire = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, sre = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function ore(t, e, r = 1, n = 0, i = !0) {
  t.pathLength = 1;
  const s = i ? ire : sre;
  t[s.offset] = Vt.transform(-n);
  const o = Vt.transform(e), a = Vt.transform(r);
  t[s.array] = `${o} ${a}`;
}
function ny(t, {
  attrX: e,
  attrY: r,
  attrScale: n,
  originX: i,
  originY: s,
  pathLength: o,
  pathSpacing: a = 1,
  pathOffset: u = 0,
  // This is object creation, which we try to avoid per-frame.
  ...l
}, d, p) {
  if (ry(t, l, p), d) {
    t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
    return;
  }
  t.attrs = t.style, t.style = {};
  const { attrs: w, style: P, dimensions: A } = t;
  w.transform && (A && (P.transform = w.transform), delete w.transform), A && (i !== void 0 || s !== void 0 || P.transform) && (P.transformOrigin = nre(A, i !== void 0 ? i : 0.5, s !== void 0 ? s : 0.5)), e !== void 0 && (w.x = e), r !== void 0 && (w.y = r), n !== void 0 && (w.scale = n), o !== void 0 && ore(w, o, a, u, !1);
}
const iy = (t) => typeof t == "string" && t.toLowerCase() === "svg", are = {
  useVisualState: l9({
    scrapeMotionValuesFromProps: f9,
    createRenderState: h9,
    onMount: (t, e, { renderState: r, latestValues: n }) => {
      Lr.read(() => {
        try {
          r.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect();
        } catch {
          r.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      }), Lr.render(() => {
        ny(r, n, iy(e.tagName), t.transformTemplate), c9(e, r);
      });
    }
  })
}, cre = {
  useVisualState: l9({
    scrapeMotionValuesFromProps: Qb,
    createRenderState: ty
  })
};
function p9(t, e, r) {
  for (const n in e)
    !Jn(e[n]) && !u9(n, r) && (t[n] = e[n]);
}
function ure({ transformTemplate: t }, e) {
  return Oi(() => {
    const r = ty();
    return ry(r, e, t), Object.assign({}, r.vars, r.style);
  }, [e]);
}
function fre(t, e) {
  const r = t.style || {}, n = {};
  return p9(n, r, t), Object.assign(n, ure(t, e)), n;
}
function lre(t, e) {
  const r = {}, n = fre(t, e);
  return t.drag && t.dragListener !== !1 && (r.draggable = !1, n.userSelect = n.WebkitUserSelect = n.WebkitTouchCallout = "none", n.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (r.tabIndex = 0), r.style = n, r;
}
const hre = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function _0(t) {
  return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || hre.has(t);
}
let g9 = (t) => !_0(t);
function dre(t) {
  t && (g9 = (e) => e.startsWith("on") ? !_0(e) : t(e));
}
try {
  dre(require("@emotion/is-prop-valid").default);
} catch {
}
function pre(t, e, r) {
  const n = {};
  for (const i in t)
    i === "values" && typeof t.values == "object" || (g9(i) || r === !0 && _0(i) || !e && !_0(i) || // If trying to use native HTML drag events, forward drag listeners
    t.draggable && i.startsWith("onDrag")) && (n[i] = t[i]);
  return n;
}
function gre(t, e, r, n) {
  const i = Oi(() => {
    const s = h9();
    return ny(s, e, iy(n), t.transformTemplate), {
      ...s.attrs,
      style: { ...s.style }
    };
  }, [e]);
  if (t.style) {
    const s = {};
    p9(s, t.style, t), i.style = { ...s, ...i.style };
  }
  return i;
}
function mre(t = !1) {
  return (r, n, i, { latestValues: s }, o) => {
    const u = (Zb(r) ? gre : lre)(n, s, o, r), l = pre(n, typeof r == "string", t), d = r !== b5 ? { ...l, ...u, ref: i } : {}, { children: p } = n, w = Oi(() => Jn(p) ? p.get() : p, [p]);
    return jd(r, {
      ...d,
      children: w
    });
  };
}
function vre(t, e) {
  return function(n, { forwardMotionProps: i } = { forwardMotionProps: !1 }) {
    const o = {
      ...Zb(n) ? are : cre,
      preloadedFeatures: t,
      useRender: mre(i),
      createVisualElement: e,
      Component: n
    };
    return Vte(o);
  };
}
const fv = { current: null }, m9 = { current: !1 };
function bre() {
  if (m9.current = !0, !!Xb)
    if (window.matchMedia) {
      const t = window.matchMedia("(prefers-reduced-motion)"), e = () => fv.current = t.matches;
      t.addListener(e), e();
    } else
      fv.current = !1;
}
function yre(t, e, r) {
  for (const n in e) {
    const i = e[n], s = r[n];
    if (Jn(i))
      t.addValue(n, i), process.env.NODE_ENV === "development" && mp(i.version === "11.11.17", `Attempting to mix Motion versions ${i.version} with 11.11.17 may not work as expected.`);
    else if (Jn(s))
      t.addValue(n, Tl(i, { owner: t }));
    else if (s !== i)
      if (t.hasValue(n)) {
        const o = t.getValue(n);
        o.liveStyle === !0 ? o.jump(i) : o.hasAnimated || o.set(i);
      } else {
        const o = t.getStaticValue(n);
        t.addValue(n, Tl(o !== void 0 ? o : i, { owner: t }));
      }
  }
  for (const n in r)
    e[n] === void 0 && t.removeValue(n);
  return e;
}
const n5 = /* @__PURE__ */ new WeakMap(), wre = [...c7, Gn, _a], xre = (t) => wre.find(a7(t)), i5 = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class _re {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(e, r, n) {
    return {};
  }
  constructor({ parent: e, props: r, presenceContext: n, reducedMotionConfig: i, blockInitialAnimation: s, visualState: o }, a = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = Ob, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const w = Gs.now();
      this.renderScheduledAt < w && (this.renderScheduledAt = w, Lr.render(this.render, !1, !0));
    };
    const { latestValues: u, renderState: l } = o;
    this.latestValues = u, this.baseTarget = { ...u }, this.initialValues = r.initial ? { ...u } : {}, this.renderState = l, this.parent = e, this.props = r, this.presenceContext = n, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = i, this.options = a, this.blockInitialAnimation = !!s, this.isControllingVariants = Ep(r), this.isVariantNode = s9(r), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(e && e.current);
    const { willChange: d, ...p } = this.scrapeMotionValuesFromProps(r, {}, this);
    for (const w in p) {
      const P = p[w];
      u[w] !== void 0 && Jn(P) && P.set(u[w], !1);
    }
  }
  mount(e) {
    this.current = e, n5.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((r, n) => this.bindToMotionValue(n, r)), m9.current || bre(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : fv.current, process.env.NODE_ENV !== "production" && mp(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    n5.delete(this.current), this.projection && this.projection.unmount(), wa(this.notifyUpdate), wa(this.render), this.valueSubscriptions.forEach((e) => e()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const e in this.events)
      this.events[e].clear();
    for (const e in this.features) {
      const r = this.features[e];
      r && (r.unmount(), r.isMounted = !1);
    }
    this.current = null;
  }
  bindToMotionValue(e, r) {
    this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
    const n = Sc.has(e), i = r.on("change", (a) => {
      this.latestValues[e] = a, this.props.onUpdate && Lr.preRender(this.notifyUpdate), n && this.projection && (this.projection.isTransformDirty = !0);
    }), s = r.on("renderRequest", this.scheduleRender);
    let o;
    window.MotionCheckAppearSync && (o = window.MotionCheckAppearSync(this, e, r)), this.valueSubscriptions.set(e, () => {
      i(), s(), o && o(), r.owner && r.stop();
    });
  }
  sortNodePosition(e) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current);
  }
  updateFeatures() {
    let e = "animation";
    for (e in Iu) {
      const r = Iu[e];
      if (!r)
        continue;
      const { isEnabled: n, Feature: i } = r;
      if (!this.features[e] && i && n(this.props) && (this.features[e] = new i(this)), this.features[e]) {
        const s = this.features[e];
        s.isMounted ? s.update() : (s.mount(), s.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : ln();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, r) {
    this.latestValues[e] = r;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(e, r) {
    (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = r;
    for (let n = 0; n < i5.length; n++) {
      const i = i5[n];
      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
      const s = "on" + i, o = e[s];
      o && (this.propEventSubscriptions[i] = this.on(i, o));
    }
    this.prevMotionValues = yre(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(e) {
    const r = this.getClosestVariantNode();
    if (r)
      return r.variantChildren && r.variantChildren.add(e), () => r.variantChildren.delete(e);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(e, r) {
    const n = this.values.get(e);
    r !== n && (n && this.removeValue(e), this.bindToMotionValue(e, r), this.values.set(e, r), this.latestValues[e] = r.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(e) {
    this.values.delete(e);
    const r = this.valueSubscriptions.get(e);
    r && (r(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, r) {
    if (this.props.values && this.props.values[e])
      return this.props.values[e];
    let n = this.values.get(e);
    return n === void 0 && r !== void 0 && (n = Tl(r === null ? void 0 : r, { owner: this }), this.addValue(e, n)), n;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(e, r) {
    var n;
    let i = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (n = this.getBaseTargetFromProps(this.props, e)) !== null && n !== void 0 ? n : this.readValueFromInstance(this.current, e, this.options);
    return i != null && (typeof i == "string" && (n7(i) || r7(i)) ? i = parseFloat(i) : !xre(i) && _a.test(r) && (i = m7(e, r)), this.setBaseTarget(e, Jn(i) ? i.get() : i)), Jn(i) ? i.get() : i;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(e, r) {
    this.baseTarget[e] = r;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(e) {
    var r;
    const { initial: n } = this.props;
    let i;
    if (typeof n == "string" || typeof n == "object") {
      const o = Pb(this.props, n, (r = this.presenceContext) === null || r === void 0 ? void 0 : r.custom);
      o && (i = o[e]);
    }
    if (n && i !== void 0)
      return i;
    const s = this.getBaseTargetFromProps(this.props, e);
    return s !== void 0 && !Jn(s) ? s : this.initialValues[e] !== void 0 && i === void 0 ? void 0 : this.baseTarget[e];
  }
  on(e, r) {
    return this.events[e] || (this.events[e] = new Kb()), this.events[e].add(r);
  }
  notify(e, ...r) {
    this.events[e] && this.events[e].notify(...r);
  }
}
class v9 extends _re {
  constructor() {
    super(...arguments), this.KeyframeResolver = v7;
  }
  sortInstanceNodePosition(e, r) {
    return e.compareDocumentPosition(r) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, r) {
    return e.style ? e.style[r] : void 0;
  }
  removeValueFromRenderState(e, { vars: r, style: n }) {
    delete r[e], delete n[e];
  }
}
function Ere(t) {
  return window.getComputedStyle(t);
}
class Sre extends v9 {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = o9;
  }
  readValueFromInstance(e, r) {
    if (Sc.has(r)) {
      const n = $b(r);
      return n && n.default || 0;
    } else {
      const n = Ere(e), i = (s7(r) ? n.getPropertyValue(r) : n[r]) || 0;
      return typeof i == "string" ? i.trim() : i;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: r }) {
    return z7(e, r);
  }
  build(e, r, n) {
    ry(e, r, n.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, r, n) {
    return Qb(e, r, n);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    Jn(e) && (this.childSubscription = e.on("change", (r) => {
      this.current && (this.current.textContent = `${r}`);
    }));
  }
}
class Are extends v9 {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = ln;
  }
  getBaseTargetFromProps(e, r) {
    return e[r];
  }
  readValueFromInstance(e, r) {
    if (Sc.has(r)) {
      const n = $b(r);
      return n && n.default || 0;
    }
    return r = a9.has(r) ? r : Vb(r), e.getAttribute(r);
  }
  scrapeMotionValuesFromProps(e, r, n) {
    return f9(e, r, n);
  }
  build(e, r, n) {
    ny(e, r, this.isSVGTag, n.transformTemplate);
  }
  renderInstance(e, r, n, i) {
    c9(e, r, n, i);
  }
  mount(e) {
    this.isSVGTag = iy(e.tagName), super.mount(e);
  }
}
const Pre = (t, e) => Zb(t) ? new Are(e) : new Sre(e, {
  allowProjection: t !== b5
}), Mre = /* @__PURE__ */ vre({
  ...mee,
  ...Fte,
  ...Mte,
  ...Bte
}, Pre), Ire = /* @__PURE__ */ aZ(Mre);
class Cre extends Gt.Component {
  getSnapshotBeforeUpdate(e) {
    const r = this.props.childRef.current;
    if (r && e.isPresent && !this.props.isPresent) {
      const n = this.props.sizeRef.current;
      n.height = r.offsetHeight || 0, n.width = r.offsetWidth || 0, n.top = r.offsetTop, n.left = r.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function Tre({ children: t, isPresent: e }) {
  const r = mv(), n = bi(null), i = bi({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), { nonce: s } = Tn(Jb);
  return v5(() => {
    const { width: o, height: a, top: u, left: l } = i.current;
    if (e || !n.current || !o || !a)
      return;
    n.current.dataset.motionPopId = r;
    const d = document.createElement("style");
    return s && (d.nonce = s), document.head.appendChild(d), d.sheet && d.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${o}px !important;
            height: ${a}px !important;
            top: ${u}px !important;
            left: ${l}px !important;
          }
        `), () => {
      document.head.removeChild(d);
    };
  }, [e]), me.jsx(Cre, { isPresent: e, childRef: n, sizeRef: i, children: Gt.cloneElement(t, { ref: n }) });
}
const Rre = ({ children: t, initial: e, isPresent: r, onExitComplete: n, custom: i, presenceAffectsLayout: s, mode: o }) => {
  const a = ey(Dre), u = mv(), l = vv((p) => {
    a.set(p, !0);
    for (const w of a.values())
      if (!w)
        return;
    n && n();
  }, [a, n]), d = Oi(
    () => ({
      id: u,
      initial: e,
      isPresent: r,
      custom: i,
      onExitComplete: l,
      register: (p) => (a.set(p, !1), () => a.delete(p))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    s ? [Math.random(), l] : [r, l]
  );
  return Oi(() => {
    a.forEach((p, w) => a.set(w, !1));
  }, [r]), Gt.useEffect(() => {
    !r && !a.size && n && n();
  }, [r]), o === "popLayout" && (t = me.jsx(Tre, { isPresent: r, children: t })), me.jsx(xp.Provider, { value: d, children: t });
};
function Dre() {
  return /* @__PURE__ */ new Map();
}
const vd = (t) => t.key || "";
function s5(t) {
  const e = [];
  return MR.forEach(t, (r) => {
    IR(r) && e.push(r);
  }), e;
}
const Ore = ({ children: t, exitBeforeEnter: e, custom: r, initial: n = !0, onExitComplete: i, presenceAffectsLayout: s = !0, mode: o = "sync" }) => {
  Uo(!e, "Replace exitBeforeEnter with mode='wait'");
  const a = Oi(() => s5(t), [t]), u = a.map(vd), l = bi(!0), d = bi(a), p = ey(() => /* @__PURE__ */ new Map()), [w, P] = fr(a), [A, N] = fr(a);
  r9(() => {
    l.current = !1, d.current = a;
    for (let $ = 0; $ < A.length; $++) {
      const K = vd(A[$]);
      u.includes(K) ? p.delete(K) : p.get(K) !== !0 && p.set(K, !1);
    }
  }, [A, u.length, u.join("-")]);
  const L = [];
  if (a !== w) {
    let $ = [...a];
    for (let K = 0; K < A.length; K++) {
      const H = A[K], V = vd(H);
      u.includes(V) || ($.splice(K, 0, H), L.push(H));
    }
    o === "wait" && L.length && ($ = L), N(s5($)), P(a);
    return;
  }
  process.env.NODE_ENV !== "production" && o === "wait" && A.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
  const { forceRender: F } = Tn(Gb);
  return me.jsx(me.Fragment, { children: A.map(($) => {
    const K = vd($), H = a === A || u.includes(K), V = () => {
      if (p.has(K))
        p.set(K, !0);
      else
        return;
      let te = !0;
      p.forEach((R) => {
        R || (te = !1);
      }), te && (F == null || F(), N(d.current), i && i());
    };
    return me.jsx(Rre, { isPresent: H, initial: !l.current || n ? void 0 : !1, custom: H ? void 0 : r, presenceAffectsLayout: s, mode: o, onExitComplete: H ? void 0 : V, children: $ }, K);
  }) });
}, Ac = (t) => /* @__PURE__ */ me.jsx(Ore, { children: /* @__PURE__ */ me.jsx(
  Ire.div,
  {
    initial: { x: 0, opacity: 0 },
    animate: { x: 0, opacity: 1 },
    exit: { x: 30, opacity: 0 },
    transition: { duration: 0.3 },
    className: t.className,
    children: t.children
  }
) });
function sy(t) {
  const { icon: e, title: r, extra: n, onClick: i } = t;
  function s() {
    i && i();
  }
  return /* @__PURE__ */ me.jsxs(
    "div",
    {
      className: "xc-rounded-lg xc-group xc-flex xc-cursor-pointer xc-items-center xc-gap-2 xc-border xc-border-white xc-border-opacity-15 xc-px-4 xc-py-2 xc-transition-all hover:xc-shadow-lg",
      onClick: s,
      children: [
        e,
        r,
        /* @__PURE__ */ me.jsxs("div", { className: "xc-relative xc-ml-auto xc-h-6", children: [
          /* @__PURE__ */ me.jsx("div", { className: "xc-relative xc-left-0 xc-opacity-100 xc-transition-all group-hover:xc-left-2 group-hover:xc-opacity-0", children: n }),
          /* @__PURE__ */ me.jsx("div", { className: "xc-absolute xc-right-2 xc-top-0 xc-text-gray-400 xc-opacity-0 xc-transition-all group-hover:xc-right-0 group-hover:xc-opacity-100", children: /* @__PURE__ */ me.jsx(tZ, {}) })
        ] })
      ]
    }
  );
}
function Nre(t) {
  return t.lastUsed ? /* @__PURE__ */ me.jsxs("div", { className: "xc-flex xc-items-center xc-gap-2 xc-rounded-full xc-py-1 xc-text-xs xc-text-gray-500", children: [
    /* @__PURE__ */ me.jsx("div", { className: "xc-h-1 xc-w-1 xc-rounded-full xc-bg-[#009E8C]" }),
    "Last Used"
  ] }) : t.installed ? /* @__PURE__ */ me.jsxs("div", { className: "xc-flex xc-items-center xc-gap-2 xc-rounded-full xc-py-1 xc-text-xs xc-text-gray-500", children: [
    /* @__PURE__ */ me.jsx("div", { className: "xc-h-1 xc-w-1 xc-rounded-full xc-bg-[#2596FF]" }),
    "Installed"
  ] }) : null;
}
function b9(t) {
  var o, a;
  const { wallet: e, onClick: r } = t, n = /* @__PURE__ */ me.jsx("img", { className: "xc-rounded-md xc-h-5 xc-w-5", src: (o = e.config) == null ? void 0 : o.image }), i = ((a = e.config) == null ? void 0 : a.name) || "", s = Oi(() => Nre(e), [e]);
  return /* @__PURE__ */ me.jsx(sy, { icon: n, title: i, extra: s, onClick: () => r(e) });
}
function y9(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number") n += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var i = t.length;
    for (e = 0; e < i; e++) t[e] && (r = y9(t[e])) && (n && (n += " "), n += r);
  } else for (r in t) t[r] && (n && (n += " "), n += r);
  return n;
}
function Lre() {
  for (var t, e, r = 0, n = "", i = arguments.length; r < i; r++) (t = arguments[r]) && (e = y9(t)) && (n && (n += " "), n += e);
  return n;
}
const kre = Lre, oy = "-", $re = (t) => {
  const e = Bre(t), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: n
  } = t;
  return {
    getClassGroupId: (o) => {
      const a = o.split(oy);
      return a[0] === "" && a.length !== 1 && a.shift(), w9(a, e) || Fre(o);
    },
    getConflictingClassGroupIds: (o, a) => {
      const u = r[o] || [];
      return a && n[o] ? [...u, ...n[o]] : u;
    }
  };
}, w9 = (t, e) => {
  var o;
  if (t.length === 0)
    return e.classGroupId;
  const r = t[0], n = e.nextPart.get(r), i = n ? w9(t.slice(1), n) : void 0;
  if (i)
    return i;
  if (e.validators.length === 0)
    return;
  const s = t.join(oy);
  return (o = e.validators.find(({
    validator: a
  }) => a(s))) == null ? void 0 : o.classGroupId;
}, o5 = /^\[(.+)\]$/, Fre = (t) => {
  if (o5.test(t)) {
    const e = o5.exec(t)[1], r = e == null ? void 0 : e.substring(0, e.indexOf(":"));
    if (r)
      return "arbitrary.." + r;
  }
}, Bre = (t) => {
  const {
    theme: e,
    prefix: r
  } = t, n = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return jre(Object.entries(t.classGroups), r).forEach(([s, o]) => {
    lv(o, n, s, e);
  }), n;
}, lv = (t, e, r, n) => {
  t.forEach((i) => {
    if (typeof i == "string") {
      const s = i === "" ? e : a5(e, i);
      s.classGroupId = r;
      return;
    }
    if (typeof i == "function") {
      if (Ure(i)) {
        lv(i(n), e, r, n);
        return;
      }
      e.validators.push({
        validator: i,
        classGroupId: r
      });
      return;
    }
    Object.entries(i).forEach(([s, o]) => {
      lv(o, a5(e, s), r, n);
    });
  });
}, a5 = (t, e) => {
  let r = t;
  return e.split(oy).forEach((n) => {
    r.nextPart.has(n) || r.nextPart.set(n, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), r = r.nextPart.get(n);
  }), r;
}, Ure = (t) => t.isThemeGetter, jre = (t, e) => e ? t.map(([r, n]) => {
  const i = n.map((s) => typeof s == "string" ? e + s : typeof s == "object" ? Object.fromEntries(Object.entries(s).map(([o, a]) => [e + o, a])) : s);
  return [r, i];
}) : t, qre = (t) => {
  if (t < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  const i = (s, o) => {
    r.set(s, o), e++, e > t && (e = 0, n = r, r = /* @__PURE__ */ new Map());
  };
  return {
    get(s) {
      let o = r.get(s);
      if (o !== void 0)
        return o;
      if ((o = n.get(s)) !== void 0)
        return i(s, o), o;
    },
    set(s, o) {
      r.has(s) ? r.set(s, o) : i(s, o);
    }
  };
}, x9 = "!", zre = (t) => {
  const {
    separator: e,
    experimentalParseClassName: r
  } = t, n = e.length === 1, i = e[0], s = e.length, o = (a) => {
    const u = [];
    let l = 0, d = 0, p;
    for (let L = 0; L < a.length; L++) {
      let F = a[L];
      if (l === 0) {
        if (F === i && (n || a.slice(L, L + s) === e)) {
          u.push(a.slice(d, L)), d = L + s;
          continue;
        }
        if (F === "/") {
          p = L;
          continue;
        }
      }
      F === "[" ? l++ : F === "]" && l--;
    }
    const w = u.length === 0 ? a : a.substring(d), P = w.startsWith(x9), A = P ? w.substring(1) : w, N = p && p > d ? p - d : void 0;
    return {
      modifiers: u,
      hasImportantModifier: P,
      baseClassName: A,
      maybePostfixModifierPosition: N
    };
  };
  return r ? (a) => r({
    className: a,
    parseClassName: o
  }) : o;
}, Hre = (t) => {
  if (t.length <= 1)
    return t;
  const e = [];
  let r = [];
  return t.forEach((n) => {
    n[0] === "[" ? (e.push(...r.sort(), n), r = []) : r.push(n);
  }), e.push(...r.sort()), e;
}, Wre = (t) => ({
  cache: qre(t.cacheSize),
  parseClassName: zre(t),
  ...$re(t)
}), Kre = /\s+/, Vre = (t, e) => {
  const {
    parseClassName: r,
    getClassGroupId: n,
    getConflictingClassGroupIds: i
  } = e, s = [], o = t.trim().split(Kre);
  let a = "";
  for (let u = o.length - 1; u >= 0; u -= 1) {
    const l = o[u], {
      modifiers: d,
      hasImportantModifier: p,
      baseClassName: w,
      maybePostfixModifierPosition: P
    } = r(l);
    let A = !!P, N = n(A ? w.substring(0, P) : w);
    if (!N) {
      if (!A) {
        a = l + (a.length > 0 ? " " + a : a);
        continue;
      }
      if (N = n(w), !N) {
        a = l + (a.length > 0 ? " " + a : a);
        continue;
      }
      A = !1;
    }
    const L = Hre(d).join(":"), F = p ? L + x9 : L, $ = F + N;
    if (s.includes($))
      continue;
    s.push($);
    const K = i(N, A);
    for (let H = 0; H < K.length; ++H) {
      const V = K[H];
      s.push(F + V);
    }
    a = l + (a.length > 0 ? " " + a : a);
  }
  return a;
};
function Gre() {
  let t = 0, e, r, n = "";
  for (; t < arguments.length; )
    (e = arguments[t++]) && (r = _9(e)) && (n && (n += " "), n += r);
  return n;
}
const _9 = (t) => {
  if (typeof t == "string")
    return t;
  let e, r = "";
  for (let n = 0; n < t.length; n++)
    t[n] && (e = _9(t[n])) && (r && (r += " "), r += e);
  return r;
};
function Yre(t, ...e) {
  let r, n, i, s = o;
  function o(u) {
    const l = e.reduce((d, p) => p(d), t());
    return r = Wre(l), n = r.cache.get, i = r.cache.set, s = a, a(u);
  }
  function a(u) {
    const l = n(u);
    if (l)
      return l;
    const d = Vre(u, r);
    return i(u, d), d;
  }
  return function() {
    return s(Gre.apply(null, arguments));
  };
}
const Gr = (t) => {
  const e = (r) => r[t] || [];
  return e.isThemeGetter = !0, e;
}, E9 = /^\[(?:([a-z-]+):)?(.+)\]$/i, Jre = /^\d+\/\d+$/, Xre = /* @__PURE__ */ new Set(["px", "full", "screen"]), Zre = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, Qre = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, ene = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, tne = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, rne = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, vo = (t) => gu(t) || Xre.has(t) || Jre.test(t), ra = (t) => Vu(t, "length", fne), gu = (t) => !!t && !Number.isNaN(Number(t)), Wm = (t) => Vu(t, "number", gu), Of = (t) => !!t && Number.isInteger(Number(t)), nne = (t) => t.endsWith("%") && gu(t.slice(0, -1)), cr = (t) => E9.test(t), na = (t) => Zre.test(t), ine = /* @__PURE__ */ new Set(["length", "size", "percentage"]), sne = (t) => Vu(t, ine, S9), one = (t) => Vu(t, "position", S9), ane = /* @__PURE__ */ new Set(["image", "url"]), cne = (t) => Vu(t, ane, hne), une = (t) => Vu(t, "", lne), Nf = () => !0, Vu = (t, e, r) => {
  const n = E9.exec(t);
  return n ? n[1] ? typeof e == "string" ? n[1] === e : e.has(n[1]) : r(n[2]) : !1;
}, fne = (t) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  Qre.test(t) && !ene.test(t)
), S9 = () => !1, lne = (t) => tne.test(t), hne = (t) => rne.test(t), dne = () => {
  const t = Gr("colors"), e = Gr("spacing"), r = Gr("blur"), n = Gr("brightness"), i = Gr("borderColor"), s = Gr("borderRadius"), o = Gr("borderSpacing"), a = Gr("borderWidth"), u = Gr("contrast"), l = Gr("grayscale"), d = Gr("hueRotate"), p = Gr("invert"), w = Gr("gap"), P = Gr("gradientColorStops"), A = Gr("gradientColorStopPositions"), N = Gr("inset"), L = Gr("margin"), F = Gr("opacity"), $ = Gr("padding"), K = Gr("saturate"), H = Gr("scale"), V = Gr("sepia"), te = Gr("skew"), R = Gr("space"), W = Gr("translate"), pe = () => ["auto", "contain", "none"], Ee = () => ["auto", "hidden", "clip", "visible", "scroll"], Y = () => ["auto", cr, e], S = () => [cr, e], m = () => ["", vo, ra], f = () => ["auto", gu, cr], g = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], b = () => ["solid", "dashed", "dotted", "double", "none"], x = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], _ = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], E = () => ["", "0", cr], v = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], M = () => [gu, cr];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Nf],
      spacing: [vo, ra],
      blur: ["none", "", na, cr],
      brightness: M(),
      borderColor: [t],
      borderRadius: ["none", "", "full", na, cr],
      borderSpacing: S(),
      borderWidth: m(),
      contrast: M(),
      grayscale: E(),
      hueRotate: M(),
      invert: E(),
      gap: S(),
      gradientColorStops: [t],
      gradientColorStopPositions: [nne, ra],
      inset: Y(),
      margin: Y(),
      opacity: M(),
      padding: S(),
      saturate: M(),
      scale: M(),
      sepia: E(),
      skew: M(),
      space: S(),
      translate: S()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", cr]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [na]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": v()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": v()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...g(), cr]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: Ee()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": Ee()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": Ee()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: pe()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": pe()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": pe()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [N]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [N]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [N]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [N]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [N]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [N]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [N]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [N]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [N]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Of, cr]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: Y()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", cr]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: E()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: E()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Of, cr]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Nf]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Of, cr]
        }, cr]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": f()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": f()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Nf]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Of, cr]
        }, cr]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": f()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": f()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", cr]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", cr]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [w]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [w]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [w]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ..._()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ..._(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [..._(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [$]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [$]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [$]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [$]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [$]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [$]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [$]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [$]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [$]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [L]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [L]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [L]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [L]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [L]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [L]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [L]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [L]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [L]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [R]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [R]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", cr, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [cr, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [cr, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [na]
        }, na]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [cr, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [cr, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [cr, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [cr, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", na, ra]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Wm]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Nf]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", cr]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", gu, Wm]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", vo, cr]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", cr]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", cr]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [t]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [F]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [t]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [F]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...b(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", vo, ra]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", vo, cr]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [t]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: S()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", cr]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", cr]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [F]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...g(), one]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", sne]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, cne]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [t]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [A]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [A]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [A]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [P]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [P]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [P]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [s]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [s]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [s]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [s]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [s]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [s]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [s]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [s]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [s]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [s]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [s]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [s]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [s]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [s]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [s]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [a]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [a]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [a]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [a]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [a]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [a]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [a]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [a]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [a]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [F]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...b(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [a]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [a]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [F]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: b()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [i]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [i]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [i]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [i]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [i]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [i]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [i]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [i]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [i]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [i]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...b()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [vo, cr]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [vo, ra]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [t]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: m()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [t]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [F]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [vo, ra]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [t]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", na, une]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Nf]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [F]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...x(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": x()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [r]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [n]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [u]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", na, cr]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [l]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [d]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [p]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [K]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [V]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [r]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [n]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [u]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [l]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [d]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [p]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [F]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [K]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [V]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [o]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [o]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [o]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", cr]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: M()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", cr]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: M()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", cr]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [H]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [H]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [H]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Of, cr]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [W]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [W]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [te]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [te]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", cr]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", t]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", cr]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [t]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": S()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": S()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": S()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": S()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": S()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": S()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": S()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": S()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": S()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": S()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": S()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": S()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": S()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": S()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": S()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": S()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": S()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": S()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", cr]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [t, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [vo, ra, Wm]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [t, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, pne = /* @__PURE__ */ Yre(dne);
function Do(...t) {
  return pne(kre(t));
}
function A9(t) {
  const { className: e } = t;
  return /* @__PURE__ */ me.jsxs("div", { className: Do("xc-flex xc-items-center xc-gap-2"), children: [
    /* @__PURE__ */ me.jsx("hr", { className: Do("xc-flex-1 xc-border-gray-200", e) }),
    /* @__PURE__ */ me.jsx("div", { className: "xc-shrink-0", children: t.children }),
    /* @__PURE__ */ me.jsx("hr", { className: Do("xc-flex-1 xc-border-gray-200", e) })
  ] });
}
const gne = "https://static.codatta.io/codatta-connect/wallet-icons.svg?v=2#ton";
function mne(t) {
  const { onClick: e } = t;
  function r() {
    e && e();
  }
  return /* @__PURE__ */ me.jsx(A9, { className: "xc-opacity-20", children: /* @__PURE__ */ me.jsxs("div", { className: "xc-flex xc-items-center xc-gap-2 xc-cursor-pointer", onClick: r, children: [
    /* @__PURE__ */ me.jsx("span", { className: "xc-text-sm", children: "View more wallets" }),
    /* @__PURE__ */ me.jsx(zS, { size: 16 })
  ] }) });
}
function vne(t) {
  const [e, r] = fr(""), { featuredWallets: n } = gp(), { onEmailConfirm: i, onSelectWallet: s, onSelectMoreWallets: o, onSelectTonConnect: a, config: u } = t, l = Oi(() => {
    const A = /[\u4e00-\u9fff]|[\u3400-\u4dbf]|[\u{20000}-\u{2a6df}]|[\u{2a700}-\u{2b73f}]|[\u{2b740}-\u{2b81f}]|[\u{2b820}-\u{2ceaf}]|[\uf900-\ufaff]|[\u3300-\u33ff]|[\ufe30-\ufe4f]/gu, N = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return !A.test(e) && N.test(e);
  }, [e]);
  function d(A) {
    s(A);
  }
  function p(A) {
    r(A.target.value);
  }
  async function w() {
    i(e);
  }
  function P(A) {
    A.key === "Enter" && l && w();
  }
  return /* @__PURE__ */ me.jsxs(Ac, { children: [
    t.header || /* @__PURE__ */ me.jsx("div", { className: "xc-mb-6 xc-text-xl xc-font-bold", children: "Log in or sign up" }),
    u.showEmailSignIn && /* @__PURE__ */ me.jsxs("div", { className: "xc-mb-4", children: [
      /* @__PURE__ */ me.jsx("input", { className: "xc-w-full xc-bg-transparent xc-border-white xc-border xc-border-opacity-15 xc-h-10 xc-rounded-lg xc-px-3 xc-mb-3", placeholder: "Enter your email", type: "email", onChange: p, onKeyDown: P }),
      /* @__PURE__ */ me.jsx("button", { disabled: !l, className: "xc-bg-[rgb(135,93,255)] xc-text-white xc-w-full xc-rounded-lg xc-py-2 disabled:xc-bg-opacity-10 disabled:xc-text-opacity-50 disabled:xc-bg-white xc-transition-all", onClick: w, children: "Continue" })
    ] }),
    u.showEmailSignIn && (u.showFeaturedWallets || u.showTonConnect) && /* @__PURE__ */ me.jsx("div", { className: "xc-mb-4", children: /* @__PURE__ */ me.jsxs(A9, { className: "xc-opacity-20", children: [
      " ",
      /* @__PURE__ */ me.jsx("span", { className: "xc-text-sm xc-opacity-20", children: "OR" })
    ] }) }),
    /* @__PURE__ */ me.jsxs("div", { children: [
      /* @__PURE__ */ me.jsxs("div", { className: "xc-mb-4 xc-flex xc-max-h-[309px] xc-flex-col xc-gap-4 xc-overflow-scroll no-scrollbar", children: [
        u.showFeaturedWallets && n && n.map((A) => /* @__PURE__ */ me.jsx(
          b9,
          {
            wallet: A,
            onClick: d
          },
          `feature-${A.key}`
        )),
        u.showTonConnect && /* @__PURE__ */ me.jsx(
          sy,
          {
            icon: /* @__PURE__ */ me.jsx("img", { className: "xc-h-5 xc-w-5", src: gne }),
            title: "TON Connect",
            onClick: a
          }
        )
      ] }),
      u.showMoreWallets && /* @__PURE__ */ me.jsx(mne, { onClick: o })
    ] })
  ] });
}
function uh(t) {
  const { title: e } = t;
  return /* @__PURE__ */ me.jsxs("div", { className: "xc-flex xc-items-center xc-gap-2", children: [
    /* @__PURE__ */ me.jsx(eZ, { onClick: t.onBack, size: 20, className: "xc-cursor-pointer" }),
    /* @__PURE__ */ me.jsx("span", { children: e })
  ] });
}
var bne = Object.defineProperty, yne = Object.defineProperties, wne = Object.getOwnPropertyDescriptors, E0 = Object.getOwnPropertySymbols, P9 = Object.prototype.hasOwnProperty, M9 = Object.prototype.propertyIsEnumerable, c5 = (t, e, r) => e in t ? bne(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, xne = (t, e) => {
  for (var r in e || (e = {})) P9.call(e, r) && c5(t, r, e[r]);
  if (E0) for (var r of E0(e)) M9.call(e, r) && c5(t, r, e[r]);
  return t;
}, _ne = (t, e) => yne(t, wne(e)), Ene = (t, e) => {
  var r = {};
  for (var n in t) P9.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && E0) for (var n of E0(t)) e.indexOf(n) < 0 && M9.call(t, n) && (r[n] = t[n]);
  return r;
};
function Sne(t) {
  let e = setTimeout(t, 0), r = setTimeout(t, 10), n = setTimeout(t, 50);
  return [e, r, n];
}
function Ane(t) {
  let e = Gt.useRef();
  return Gt.useEffect(() => {
    e.current = t;
  }), e.current;
}
var Pne = 18, I9 = 40, Mne = `${I9}px`, Ine = ["[data-lastpass-icon-root]", "com-1password-button", "[data-dashlanecreated]", '[style$="2147483647 !important;"]'].join(",");
function Cne({ containerRef: t, inputRef: e, pushPasswordManagerStrategy: r, isFocused: n }) {
  let [i, s] = Gt.useState(!1), [o, a] = Gt.useState(!1), [u, l] = Gt.useState(!1), d = Gt.useMemo(() => r === "none" ? !1 : (r === "increase-width" || r === "experimental-no-flickering") && i && o, [i, o, r]), p = Gt.useCallback(() => {
    let w = t.current, P = e.current;
    if (!w || !P || u || r === "none") return;
    let A = w, N = A.getBoundingClientRect().left + A.offsetWidth, L = A.getBoundingClientRect().top + A.offsetHeight / 2, F = N - Pne, $ = L;
    document.querySelectorAll(Ine).length === 0 && document.elementFromPoint(F, $) === w || (s(!0), l(!0));
  }, [t, e, u, r]);
  return Gt.useEffect(() => {
    let w = t.current;
    if (!w || r === "none") return;
    function P() {
      let N = window.innerWidth - w.getBoundingClientRect().right;
      a(N >= I9);
    }
    P();
    let A = setInterval(P, 1e3);
    return () => {
      clearInterval(A);
    };
  }, [t, r]), Gt.useEffect(() => {
    let w = n || document.activeElement === e.current;
    if (r === "none" || !w) return;
    let P = setTimeout(p, 0), A = setTimeout(p, 2e3), N = setTimeout(p, 5e3), L = setTimeout(() => {
      l(!0);
    }, 6e3);
    return () => {
      clearTimeout(P), clearTimeout(A), clearTimeout(N), clearTimeout(L);
    };
  }, [e, n, r, p]), { hasPWMBadge: i, willPushPWMBadge: d, PWM_BADGE_SPACE_WIDTH: Mne };
}
var C9 = Gt.createContext({}), T9 = Gt.forwardRef((t, e) => {
  var r = t, { value: n, onChange: i, maxLength: s, textAlign: o = "left", pattern: a, placeholder: u, inputMode: l = "numeric", onComplete: d, pushPasswordManagerStrategy: p = "increase-width", pasteTransformer: w, containerClassName: P, noScriptCSSFallback: A = Tne, render: N, children: L } = r, F = Ene(r, ["value", "onChange", "maxLength", "textAlign", "pattern", "placeholder", "inputMode", "onComplete", "pushPasswordManagerStrategy", "pasteTransformer", "containerClassName", "noScriptCSSFallback", "render", "children"]), $, K, H, V, te;
  let [R, W] = Gt.useState(typeof F.defaultValue == "string" ? F.defaultValue : ""), pe = n ?? R, Ee = Ane(pe), Y = Gt.useCallback((ie) => {
    i == null || i(ie), W(ie);
  }, [i]), S = Gt.useMemo(() => a ? typeof a == "string" ? new RegExp(a) : a : null, [a]), m = Gt.useRef(null), f = Gt.useRef(null), g = Gt.useRef({ value: pe, onChange: Y, isIOS: typeof window < "u" && ((K = ($ = window == null ? void 0 : window.CSS) == null ? void 0 : $.supports) == null ? void 0 : K.call($, "-webkit-touch-callout", "none")) }), b = Gt.useRef({ prev: [(H = m.current) == null ? void 0 : H.selectionStart, (V = m.current) == null ? void 0 : V.selectionEnd, (te = m.current) == null ? void 0 : te.selectionDirection] });
  Gt.useImperativeHandle(e, () => m.current, []), Gt.useEffect(() => {
    let ie = m.current, ue = f.current;
    if (!ie || !ue) return;
    g.current.value !== ie.value && g.current.onChange(ie.value), b.current.prev = [ie.selectionStart, ie.selectionEnd, ie.selectionDirection];
    function ve() {
      if (document.activeElement !== ie) {
        I(null), ce(null);
        return;
      }
      let Ce = ie.selectionStart, $e = ie.selectionEnd, Me = ie.selectionDirection, Ne = ie.maxLength, Ke = ie.value, Le = b.current.prev, qe = -1, ze = -1, _e;
      if (Ke.length !== 0 && Ce !== null && $e !== null) {
        let Qe = Ce === $e, tt = Ce === Ke.length && Ke.length < Ne;
        if (Qe && !tt) {
          let Ye = Ce;
          if (Ye === 0) qe = 0, ze = 1, _e = "forward";
          else if (Ye === Ne) qe = Ye - 1, ze = Ye, _e = "backward";
          else if (Ne > 1 && Ke.length > 1) {
            let dt = 0;
            if (Le[0] !== null && Le[1] !== null) {
              _e = Ye < Le[1] ? "backward" : "forward";
              let lt = Le[0] === Le[1] && Le[0] < Ne;
              _e === "backward" && !lt && (dt = -1);
            }
            qe = dt + Ye, ze = dt + Ye + 1;
          }
        }
        qe !== -1 && ze !== -1 && qe !== ze && m.current.setSelectionRange(qe, ze, _e);
      }
      let Ze = qe !== -1 ? qe : Ce, at = ze !== -1 ? ze : $e, ke = _e ?? Me;
      I(Ze), ce(at), b.current.prev = [Ze, at, ke];
    }
    if (document.addEventListener("selectionchange", ve, { capture: !0 }), ve(), document.activeElement === ie && v(!0), !document.getElementById("input-otp-style")) {
      let Ce = document.createElement("style");
      if (Ce.id = "input-otp-style", document.head.appendChild(Ce), Ce.sheet) {
        let $e = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
        Lf(Ce.sheet, "[data-input-otp]::selection { background: transparent !important; color: transparent !important; }"), Lf(Ce.sheet, `[data-input-otp]:autofill { ${$e} }`), Lf(Ce.sheet, `[data-input-otp]:-webkit-autofill { ${$e} }`), Lf(Ce.sheet, "@supports (-webkit-touch-callout: none) { [data-input-otp] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"), Lf(Ce.sheet, "[data-input-otp] + * { pointer-events: all !important; }");
      }
    }
    let Pe = () => {
      ue && ue.style.setProperty("--root-height", `${ie.clientHeight}px`);
    };
    Pe();
    let De = new ResizeObserver(Pe);
    return De.observe(ie), () => {
      document.removeEventListener("selectionchange", ve, { capture: !0 }), De.disconnect();
    };
  }, []);
  let [x, _] = Gt.useState(!1), [E, v] = Gt.useState(!1), [M, I] = Gt.useState(null), [B, ce] = Gt.useState(null);
  Gt.useEffect(() => {
    Sne(() => {
      var ie, ue, ve, Pe;
      (ie = m.current) == null || ie.dispatchEvent(new Event("input"));
      let De = (ue = m.current) == null ? void 0 : ue.selectionStart, Ce = (ve = m.current) == null ? void 0 : ve.selectionEnd, $e = (Pe = m.current) == null ? void 0 : Pe.selectionDirection;
      De !== null && Ce !== null && (I(De), ce(Ce), b.current.prev = [De, Ce, $e]);
    });
  }, [pe, E]), Gt.useEffect(() => {
    Ee !== void 0 && pe !== Ee && Ee.length < s && pe.length === s && (d == null || d(pe));
  }, [s, d, Ee, pe]);
  let D = Cne({ containerRef: f, inputRef: m, pushPasswordManagerStrategy: p, isFocused: E }), oe = Gt.useCallback((ie) => {
    let ue = ie.currentTarget.value.slice(0, s);
    if (ue.length > 0 && S && !S.test(ue)) {
      ie.preventDefault();
      return;
    }
    typeof Ee == "string" && ue.length < Ee.length && document.dispatchEvent(new Event("selectionchange")), Y(ue);
  }, [s, Y, Ee, S]), Z = Gt.useCallback(() => {
    var ie;
    if (m.current) {
      let ue = Math.min(m.current.value.length, s - 1), ve = m.current.value.length;
      (ie = m.current) == null || ie.setSelectionRange(ue, ve), I(ue), ce(ve);
    }
    v(!0);
  }, [s]), J = Gt.useCallback((ie) => {
    var ue, ve;
    let Pe = m.current;
    if (!w && (!g.current.isIOS || !ie.clipboardData || !Pe)) return;
    let De = ie.clipboardData.getData("text/plain"), Ce = w ? w(De) : De;
    console.log({ _content: De, content: Ce }), ie.preventDefault();
    let $e = (ue = m.current) == null ? void 0 : ue.selectionStart, Me = (ve = m.current) == null ? void 0 : ve.selectionEnd, Ne = ($e !== Me ? pe.slice(0, $e) + Ce + pe.slice(Me) : pe.slice(0, $e) + Ce + pe.slice($e)).slice(0, s);
    if (Ne.length > 0 && S && !S.test(Ne)) return;
    Pe.value = Ne, Y(Ne);
    let Ke = Math.min(Ne.length, s - 1), Le = Ne.length;
    Pe.setSelectionRange(Ke, Le), I(Ke), ce(Le);
  }, [s, Y, S, pe]), Q = Gt.useMemo(() => ({ position: "relative", cursor: F.disabled ? "default" : "text", userSelect: "none", WebkitUserSelect: "none", pointerEvents: "none" }), [F.disabled]), T = Gt.useMemo(() => ({ position: "absolute", inset: 0, width: D.willPushPWMBadge ? `calc(100% + ${D.PWM_BADGE_SPACE_WIDTH})` : "100%", clipPath: D.willPushPWMBadge ? `inset(0 ${D.PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0, height: "100%", display: "flex", textAlign: o, opacity: "1", color: "transparent", pointerEvents: "all", background: "transparent", caretColor: "transparent", border: "0 solid transparent", outline: "0 solid transparent", boxShadow: "none", lineHeight: "1", letterSpacing: "-.5em", fontSize: "var(--root-height)", fontFamily: "monospace", fontVariantNumeric: "tabular-nums" }), [D.PWM_BADGE_SPACE_WIDTH, D.willPushPWMBadge, o]), X = Gt.useMemo(() => Gt.createElement("input", _ne(xne({ autoComplete: F.autoComplete || "one-time-code" }, F), { "data-input-otp": !0, "data-input-otp-placeholder-shown": pe.length === 0 || void 0, "data-input-otp-mss": M, "data-input-otp-mse": B, inputMode: l, pattern: S == null ? void 0 : S.source, "aria-placeholder": u, style: T, maxLength: s, value: pe, ref: m, onPaste: (ie) => {
    var ue;
    J(ie), (ue = F.onPaste) == null || ue.call(F, ie);
  }, onChange: oe, onMouseOver: (ie) => {
    var ue;
    _(!0), (ue = F.onMouseOver) == null || ue.call(F, ie);
  }, onMouseLeave: (ie) => {
    var ue;
    _(!1), (ue = F.onMouseLeave) == null || ue.call(F, ie);
  }, onFocus: (ie) => {
    var ue;
    Z(), (ue = F.onFocus) == null || ue.call(F, ie);
  }, onBlur: (ie) => {
    var ue;
    v(!1), (ue = F.onBlur) == null || ue.call(F, ie);
  } })), [oe, Z, J, l, T, s, B, M, F, S == null ? void 0 : S.source, pe]), re = Gt.useMemo(() => ({ slots: Array.from({ length: s }).map((ie, ue) => {
    var ve;
    let Pe = E && M !== null && B !== null && (M === B && ue === M || ue >= M && ue < B), De = pe[ue] !== void 0 ? pe[ue] : null, Ce = pe[0] !== void 0 ? null : (ve = u == null ? void 0 : u[ue]) != null ? ve : null;
    return { char: De, placeholderChar: Ce, isActive: Pe, hasFakeCaret: Pe && De === null };
  }), isFocused: E, isHovering: !F.disabled && x }), [E, x, s, B, M, F.disabled, pe]), de = Gt.useMemo(() => N ? N(re) : Gt.createElement(C9.Provider, { value: re }, L), [L, re, N]);
  return Gt.createElement(Gt.Fragment, null, A !== null && Gt.createElement("noscript", null, Gt.createElement("style", null, A)), Gt.createElement("div", { ref: f, "data-input-otp-container": !0, style: Q, className: P }, de, Gt.createElement("div", { style: { position: "absolute", inset: 0, pointerEvents: "none" } }, X)));
});
T9.displayName = "Input";
function Lf(t, e) {
  try {
    t.insertRule(e);
  } catch {
    console.error("input-otp could not insert CSS rule:", e);
  }
}
var Tne = `
[data-input-otp] {
  --nojs-bg: white !important;
  --nojs-fg: black !important;

  background-color: var(--nojs-bg) !important;
  color: var(--nojs-fg) !important;
  caret-color: var(--nojs-fg) !important;
  letter-spacing: .25em !important;
  text-align: center !important;
  border: 1px solid var(--nojs-fg) !important;
  border-radius: 4px !important;
  width: 100% !important;
}
@media (prefers-color-scheme: dark) {
  [data-input-otp] {
    --nojs-bg: black !important;
    --nojs-fg: white !important;
  }
}`;
const R9 = Gt.forwardRef(({ className: t, containerClassName: e, ...r }, n) => /* @__PURE__ */ me.jsx(
  T9,
  {
    ref: n,
    containerClassName: Do(
      "xc-flex xc-items-center xc-gap-2 xc-has-[:disabled]:opacity-50",
      e
    ),
    className: Do("disabled:xc-cursor-not-allowed", t),
    ...r
  }
));
R9.displayName = "InputOTP";
const D9 = Gt.forwardRef(({ className: t, ...e }, r) => /* @__PURE__ */ me.jsx("div", { ref: r, className: Do("xc-flex xc-items-center", t), ...e }));
D9.displayName = "InputOTPGroup";
const Ja = Gt.forwardRef(({ index: t, className: e, ...r }, n) => {
  const i = Gt.useContext(C9), { char: s, hasFakeCaret: o, isActive: a } = i.slots[t];
  return /* @__PURE__ */ me.jsxs(
    "div",
    {
      ref: n,
      className: Do(
        "xc-relative xc-rounded-xl xc-text-2xl xc-flex xc-h-12 xc-w-12 xc-items-center xc-justify-center xc-border xc-border-white xc-border-opacity-20 xc-transition-all",
        a && "xc-z-10 xc-ring-2 xc-ring-ring xc-ring-[rgb(135,93,255)] xc-ring-offset-background",
        e
      ),
      ...r,
      children: [
        s,
        o && /* @__PURE__ */ me.jsx("div", { className: "xc-pointer-events-none xc-absolute xc-inset-0 xc-flex xc-items-center xc-justify-center", children: /* @__PURE__ */ me.jsx("div", { className: "xc-h-4 xc-w-px xc-animate-caret-blink xc-bg-foreground xc-duration-1000" }) })
      ]
    }
  );
});
Ja.displayName = "InputOTPSlot";
function Rne(t) {
  const { spinning: e, children: r, className: n } = t;
  return /* @__PURE__ */ me.jsxs("div", { className: "xc-inline-block xc-relative", children: [
    r,
    e && /* @__PURE__ */ me.jsx("div", { className: Do("xc-absolute xc-top-0 xc-left-0 xc-w-full xc-h-full xc-bg-black xc-bg-opacity-10 xc-flex xc-items-center xc-justify-center", n), children: /* @__PURE__ */ me.jsx(gc, { className: "xc-animate-spin" }) })
  ] });
}
const O9 = Sa({
  channel: "",
  device: "WEB",
  app: "",
  inviterCode: "",
  relateInfo: {}
});
function ay() {
  return Tn(O9);
}
function Dne(t) {
  const { config: e } = t, [r, n] = fr(e.channel), [i, s] = fr(e.device), [o, a] = fr(e.app), [u, l] = fr(e.inviterCode), [d, p] = fr(e.relateInfo);
  return Xn(() => {
    n(e.channel), s(e.device), a(e.app), l(e.inviterCode), p(e.relateInfo);
  }, [e]), /* @__PURE__ */ me.jsx(
    O9.Provider,
    {
      value: {
        channel: r,
        device: i,
        app: o,
        inviterCode: u,
        relateInfo: d
      },
      children: t.children
    }
  );
}
function One(t) {
  const { email: e } = t, [r, n] = fr(0), [i, s] = fr(!1), [o, a] = fr(!1), [u, l] = fr(""), d = ay();
  async function p() {
    n(60);
    const A = setInterval(() => {
      n((N) => N === 0 ? (clearInterval(A), 0) : N - 1);
    }, 1e3);
  }
  async function w(A) {
    a(!0);
    try {
      await ya.getEmailCode({ account_type: "email", email: A }), p();
    } catch (N) {
      l(N.message);
    }
    a(!1);
  }
  Xn(() => {
    e && w(e);
  }, [e]);
  async function P(A) {
    if (l(""), !(A.length < 6)) {
      s(!0);
      try {
        const N = await ya.emailLogin({
          account_type: "email",
          connector: "codatta_email",
          account_enum: "C",
          email_code: A,
          email: e,
          inviter_code: d.inviterCode,
          source: {
            device: d.device,
            channel: d.channel,
            app: d.app
          },
          related_info: d.relateInfo
        });
        t.onLogin(N.data);
      } catch (N) {
        l(N.message);
      }
      s(!1);
    }
  }
  return /* @__PURE__ */ me.jsxs(Ac, { children: [
    /* @__PURE__ */ me.jsx("div", { className: "xc-mb-12", children: /* @__PURE__ */ me.jsx(uh, { title: "Sign in with email", onBack: t.onBack }) }),
    /* @__PURE__ */ me.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center xc-justify-center xc-mb-12", children: [
      /* @__PURE__ */ me.jsx(oZ, { className: "xc-mb-4", size: 60 }),
      /* @__PURE__ */ me.jsx("div", { className: "xc-flex xc-flex-col xc-items-center xc-justify-center xc-mb-8 xc-h-16", children: o ? /* @__PURE__ */ me.jsx(gc, { className: "xc-animate-spin" }) : /* @__PURE__ */ me.jsxs(me.Fragment, { children: [
        /* @__PURE__ */ me.jsx("p", { className: "xc-text-lg xc-mb-1", children: "Weve sent a verification code to" }),
        /* @__PURE__ */ me.jsx("p", { className: "xc-font-bold xc-text-center", children: e })
      ] }) }),
      /* @__PURE__ */ me.jsx("div", { className: "xc-mb-2 xc-h-12", children: /* @__PURE__ */ me.jsx(Rne, { spinning: i, className: "xc-rounded-xl", children: /* @__PURE__ */ me.jsx(R9, { maxLength: 6, onChange: P, disabled: i, className: "disabled:xc-opacity-20", children: /* @__PURE__ */ me.jsx(D9, { children: /* @__PURE__ */ me.jsxs("div", { className: Do("xc-flex xc-gap-2", i ? "xc-opacity-20" : ""), children: [
        /* @__PURE__ */ me.jsx(Ja, { index: 0 }),
        /* @__PURE__ */ me.jsx(Ja, { index: 1 }),
        /* @__PURE__ */ me.jsx(Ja, { index: 2 }),
        /* @__PURE__ */ me.jsx(Ja, { index: 3 }),
        /* @__PURE__ */ me.jsx(Ja, { index: 4 }),
        /* @__PURE__ */ me.jsx(Ja, { index: 5 })
      ] }) }) }) }) }),
      u && /* @__PURE__ */ me.jsx("div", { className: "xc-text-[#ff0000]", children: /* @__PURE__ */ me.jsx("p", { children: u }) })
    ] }),
    /* @__PURE__ */ me.jsxs("div", { className: "xc-text-center xc-text-sm xc-text-gray-400", children: [
      "Not get it? ",
      r ? `Recend in ${r}s` : /* @__PURE__ */ me.jsx("button", { onClick: () => w(e), children: "Send again" })
    ] })
  ] });
}
var N9 = { exports: {} };
(function(t, e) {
  (function(r, n) {
    t.exports = n();
  })(gn, () => (() => {
    var r = { 873: (o, a) => {
      var u, l, d = function() {
        var p = function(f, g) {
          var b = f, x = F[g], _ = null, E = 0, v = null, M = [], I = {}, B = function(re, de) {
            _ = function(ie) {
              for (var ue = new Array(ie), ve = 0; ve < ie; ve += 1) {
                ue[ve] = new Array(ie);
                for (var Pe = 0; Pe < ie; Pe += 1) ue[ve][Pe] = null;
              }
              return ue;
            }(E = 4 * b + 17), ce(0, 0), ce(E - 7, 0), ce(0, E - 7), oe(), D(), J(re, de), b >= 7 && Z(re), v == null && (v = T(b, x, M)), Q(v, de);
          }, ce = function(re, de) {
            for (var ie = -1; ie <= 7; ie += 1) if (!(re + ie <= -1 || E <= re + ie)) for (var ue = -1; ue <= 7; ue += 1) de + ue <= -1 || E <= de + ue || (_[re + ie][de + ue] = 0 <= ie && ie <= 6 && (ue == 0 || ue == 6) || 0 <= ue && ue <= 6 && (ie == 0 || ie == 6) || 2 <= ie && ie <= 4 && 2 <= ue && ue <= 4);
          }, D = function() {
            for (var re = 8; re < E - 8; re += 1) _[re][6] == null && (_[re][6] = re % 2 == 0);
            for (var de = 8; de < E - 8; de += 1) _[6][de] == null && (_[6][de] = de % 2 == 0);
          }, oe = function() {
            for (var re = $.getPatternPosition(b), de = 0; de < re.length; de += 1) for (var ie = 0; ie < re.length; ie += 1) {
              var ue = re[de], ve = re[ie];
              if (_[ue][ve] == null) for (var Pe = -2; Pe <= 2; Pe += 1) for (var De = -2; De <= 2; De += 1) _[ue + Pe][ve + De] = Pe == -2 || Pe == 2 || De == -2 || De == 2 || Pe == 0 && De == 0;
            }
          }, Z = function(re) {
            for (var de = $.getBCHTypeNumber(b), ie = 0; ie < 18; ie += 1) {
              var ue = !re && (de >> ie & 1) == 1;
              _[Math.floor(ie / 3)][ie % 3 + E - 8 - 3] = ue;
            }
            for (ie = 0; ie < 18; ie += 1) ue = !re && (de >> ie & 1) == 1, _[ie % 3 + E - 8 - 3][Math.floor(ie / 3)] = ue;
          }, J = function(re, de) {
            for (var ie = x << 3 | de, ue = $.getBCHTypeInfo(ie), ve = 0; ve < 15; ve += 1) {
              var Pe = !re && (ue >> ve & 1) == 1;
              ve < 6 ? _[ve][8] = Pe : ve < 8 ? _[ve + 1][8] = Pe : _[E - 15 + ve][8] = Pe;
            }
            for (ve = 0; ve < 15; ve += 1) Pe = !re && (ue >> ve & 1) == 1, ve < 8 ? _[8][E - ve - 1] = Pe : ve < 9 ? _[8][15 - ve - 1 + 1] = Pe : _[8][15 - ve - 1] = Pe;
            _[E - 8][8] = !re;
          }, Q = function(re, de) {
            for (var ie = -1, ue = E - 1, ve = 7, Pe = 0, De = $.getMaskFunction(de), Ce = E - 1; Ce > 0; Ce -= 2) for (Ce == 6 && (Ce -= 1); ; ) {
              for (var $e = 0; $e < 2; $e += 1) if (_[ue][Ce - $e] == null) {
                var Me = !1;
                Pe < re.length && (Me = (re[Pe] >>> ve & 1) == 1), De(ue, Ce - $e) && (Me = !Me), _[ue][Ce - $e] = Me, (ve -= 1) == -1 && (Pe += 1, ve = 7);
              }
              if ((ue += ie) < 0 || E <= ue) {
                ue -= ie, ie = -ie;
                break;
              }
            }
          }, T = function(re, de, ie) {
            for (var ue = V.getRSBlocks(re, de), ve = te(), Pe = 0; Pe < ie.length; Pe += 1) {
              var De = ie[Pe];
              ve.put(De.getMode(), 4), ve.put(De.getLength(), $.getLengthInBits(De.getMode(), re)), De.write(ve);
            }
            var Ce = 0;
            for (Pe = 0; Pe < ue.length; Pe += 1) Ce += ue[Pe].dataCount;
            if (ve.getLengthInBits() > 8 * Ce) throw "code length overflow. (" + ve.getLengthInBits() + ">" + 8 * Ce + ")";
            for (ve.getLengthInBits() + 4 <= 8 * Ce && ve.put(0, 4); ve.getLengthInBits() % 8 != 0; ) ve.putBit(!1);
            for (; !(ve.getLengthInBits() >= 8 * Ce || (ve.put(236, 8), ve.getLengthInBits() >= 8 * Ce)); ) ve.put(17, 8);
            return function($e, Me) {
              for (var Ne = 0, Ke = 0, Le = 0, qe = new Array(Me.length), ze = new Array(Me.length), _e = 0; _e < Me.length; _e += 1) {
                var Ze = Me[_e].dataCount, at = Me[_e].totalCount - Ze;
                Ke = Math.max(Ke, Ze), Le = Math.max(Le, at), qe[_e] = new Array(Ze);
                for (var ke = 0; ke < qe[_e].length; ke += 1) qe[_e][ke] = 255 & $e.getBuffer()[ke + Ne];
                Ne += Ze;
                var Qe = $.getErrorCorrectPolynomial(at), tt = H(qe[_e], Qe.getLength() - 1).mod(Qe);
                for (ze[_e] = new Array(Qe.getLength() - 1), ke = 0; ke < ze[_e].length; ke += 1) {
                  var Ye = ke + tt.getLength() - ze[_e].length;
                  ze[_e][ke] = Ye >= 0 ? tt.getAt(Ye) : 0;
                }
              }
              var dt = 0;
              for (ke = 0; ke < Me.length; ke += 1) dt += Me[ke].totalCount;
              var lt = new Array(dt), ct = 0;
              for (ke = 0; ke < Ke; ke += 1) for (_e = 0; _e < Me.length; _e += 1) ke < qe[_e].length && (lt[ct] = qe[_e][ke], ct += 1);
              for (ke = 0; ke < Le; ke += 1) for (_e = 0; _e < Me.length; _e += 1) ke < ze[_e].length && (lt[ct] = ze[_e][ke], ct += 1);
              return lt;
            }(ve, ue);
          };
          I.addData = function(re, de) {
            var ie = null;
            switch (de = de || "Byte") {
              case "Numeric":
                ie = R(re);
                break;
              case "Alphanumeric":
                ie = W(re);
                break;
              case "Byte":
                ie = pe(re);
                break;
              case "Kanji":
                ie = Ee(re);
                break;
              default:
                throw "mode:" + de;
            }
            M.push(ie), v = null;
          }, I.isDark = function(re, de) {
            if (re < 0 || E <= re || de < 0 || E <= de) throw re + "," + de;
            return _[re][de];
          }, I.getModuleCount = function() {
            return E;
          }, I.make = function() {
            if (b < 1) {
              for (var re = 1; re < 40; re++) {
                for (var de = V.getRSBlocks(re, x), ie = te(), ue = 0; ue < M.length; ue++) {
                  var ve = M[ue];
                  ie.put(ve.getMode(), 4), ie.put(ve.getLength(), $.getLengthInBits(ve.getMode(), re)), ve.write(ie);
                }
                var Pe = 0;
                for (ue = 0; ue < de.length; ue++) Pe += de[ue].dataCount;
                if (ie.getLengthInBits() <= 8 * Pe) break;
              }
              b = re;
            }
            B(!1, function() {
              for (var De = 0, Ce = 0, $e = 0; $e < 8; $e += 1) {
                B(!0, $e);
                var Me = $.getLostPoint(I);
                ($e == 0 || De > Me) && (De = Me, Ce = $e);
              }
              return Ce;
            }());
          }, I.createTableTag = function(re, de) {
            re = re || 2;
            var ie = "";
            ie += '<table style="', ie += " border-width: 0px; border-style: none;", ie += " border-collapse: collapse;", ie += " padding: 0px; margin: " + (de = de === void 0 ? 4 * re : de) + "px;", ie += '">', ie += "<tbody>";
            for (var ue = 0; ue < I.getModuleCount(); ue += 1) {
              ie += "<tr>";
              for (var ve = 0; ve < I.getModuleCount(); ve += 1) ie += '<td style="', ie += " border-width: 0px; border-style: none;", ie += " border-collapse: collapse;", ie += " padding: 0px; margin: 0px;", ie += " width: " + re + "px;", ie += " height: " + re + "px;", ie += " background-color: ", ie += I.isDark(ue, ve) ? "#000000" : "#ffffff", ie += ";", ie += '"/>';
              ie += "</tr>";
            }
            return (ie += "</tbody>") + "</table>";
          }, I.createSvgTag = function(re, de, ie, ue) {
            var ve = {};
            typeof arguments[0] == "object" && (re = (ve = arguments[0]).cellSize, de = ve.margin, ie = ve.alt, ue = ve.title), re = re || 2, de = de === void 0 ? 4 * re : de, (ie = typeof ie == "string" ? { text: ie } : ie || {}).text = ie.text || null, ie.id = ie.text ? ie.id || "qrcode-description" : null, (ue = typeof ue == "string" ? { text: ue } : ue || {}).text = ue.text || null, ue.id = ue.text ? ue.id || "qrcode-title" : null;
            var Pe, De, Ce, $e, Me = I.getModuleCount() * re + 2 * de, Ne = "";
            for ($e = "l" + re + ",0 0," + re + " -" + re + ",0 0,-" + re + "z ", Ne += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"', Ne += ve.scalable ? "" : ' width="' + Me + 'px" height="' + Me + 'px"', Ne += ' viewBox="0 0 ' + Me + " " + Me + '" ', Ne += ' preserveAspectRatio="xMinYMin meet"', Ne += ue.text || ie.text ? ' role="img" aria-labelledby="' + X([ue.id, ie.id].join(" ").trim()) + '"' : "", Ne += ">", Ne += ue.text ? '<title id="' + X(ue.id) + '">' + X(ue.text) + "</title>" : "", Ne += ie.text ? '<description id="' + X(ie.id) + '">' + X(ie.text) + "</description>" : "", Ne += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>', Ne += '<path d="', De = 0; De < I.getModuleCount(); De += 1) for (Ce = De * re + de, Pe = 0; Pe < I.getModuleCount(); Pe += 1) I.isDark(De, Pe) && (Ne += "M" + (Pe * re + de) + "," + Ce + $e);
            return (Ne += '" stroke="transparent" fill="black"/>') + "</svg>";
          }, I.createDataURL = function(re, de) {
            re = re || 2, de = de === void 0 ? 4 * re : de;
            var ie = I.getModuleCount() * re + 2 * de, ue = de, ve = ie - de;
            return m(ie, ie, function(Pe, De) {
              if (ue <= Pe && Pe < ve && ue <= De && De < ve) {
                var Ce = Math.floor((Pe - ue) / re), $e = Math.floor((De - ue) / re);
                return I.isDark($e, Ce) ? 0 : 1;
              }
              return 1;
            });
          }, I.createImgTag = function(re, de, ie) {
            re = re || 2, de = de === void 0 ? 4 * re : de;
            var ue = I.getModuleCount() * re + 2 * de, ve = "";
            return ve += "<img", ve += ' src="', ve += I.createDataURL(re, de), ve += '"', ve += ' width="', ve += ue, ve += '"', ve += ' height="', ve += ue, ve += '"', ie && (ve += ' alt="', ve += X(ie), ve += '"'), ve + "/>";
          };
          var X = function(re) {
            for (var de = "", ie = 0; ie < re.length; ie += 1) {
              var ue = re.charAt(ie);
              switch (ue) {
                case "<":
                  de += "&lt;";
                  break;
                case ">":
                  de += "&gt;";
                  break;
                case "&":
                  de += "&amp;";
                  break;
                case '"':
                  de += "&quot;";
                  break;
                default:
                  de += ue;
              }
            }
            return de;
          };
          return I.createASCII = function(re, de) {
            if ((re = re || 1) < 2) return function(qe) {
              qe = qe === void 0 ? 2 : qe;
              var ze, _e, Ze, at, ke, Qe = 1 * I.getModuleCount() + 2 * qe, tt = qe, Ye = Qe - qe, dt = { "": "", " ": "", " ": "", "  ": " " }, lt = { "": "", " ": "", " ": " ", "  ": " " }, ct = "";
              for (ze = 0; ze < Qe; ze += 2) {
                for (Ze = Math.floor((ze - tt) / 1), at = Math.floor((ze + 1 - tt) / 1), _e = 0; _e < Qe; _e += 1) ke = "", tt <= _e && _e < Ye && tt <= ze && ze < Ye && I.isDark(Ze, Math.floor((_e - tt) / 1)) && (ke = " "), tt <= _e && _e < Ye && tt <= ze + 1 && ze + 1 < Ye && I.isDark(at, Math.floor((_e - tt) / 1)) ? ke += " " : ke += "", ct += qe < 1 && ze + 1 >= Ye ? lt[ke] : dt[ke];
                ct += `
`;
              }
              return Qe % 2 && qe > 0 ? ct.substring(0, ct.length - Qe - 1) + Array(Qe + 1).join("") : ct.substring(0, ct.length - 1);
            }(de);
            re -= 1, de = de === void 0 ? 2 * re : de;
            var ie, ue, ve, Pe, De = I.getModuleCount() * re + 2 * de, Ce = de, $e = De - de, Me = Array(re + 1).join(""), Ne = Array(re + 1).join("  "), Ke = "", Le = "";
            for (ie = 0; ie < De; ie += 1) {
              for (ve = Math.floor((ie - Ce) / re), Le = "", ue = 0; ue < De; ue += 1) Pe = 1, Ce <= ue && ue < $e && Ce <= ie && ie < $e && I.isDark(ve, Math.floor((ue - Ce) / re)) && (Pe = 0), Le += Pe ? Me : Ne;
              for (ve = 0; ve < re; ve += 1) Ke += Le + `
`;
            }
            return Ke.substring(0, Ke.length - 1);
          }, I.renderTo2dContext = function(re, de) {
            de = de || 2;
            for (var ie = I.getModuleCount(), ue = 0; ue < ie; ue++) for (var ve = 0; ve < ie; ve++) re.fillStyle = I.isDark(ue, ve) ? "black" : "white", re.fillRect(ue * de, ve * de, de, de);
          }, I;
        };
        p.stringToBytes = (p.stringToBytesFuncs = { default: function(f) {
          for (var g = [], b = 0; b < f.length; b += 1) {
            var x = f.charCodeAt(b);
            g.push(255 & x);
          }
          return g;
        } }).default, p.createStringToBytes = function(f, g) {
          var b = function() {
            for (var _ = S(f), E = function() {
              var D = _.read();
              if (D == -1) throw "eof";
              return D;
            }, v = 0, M = {}; ; ) {
              var I = _.read();
              if (I == -1) break;
              var B = E(), ce = E() << 8 | E();
              M[String.fromCharCode(I << 8 | B)] = ce, v += 1;
            }
            if (v != g) throw v + " != " + g;
            return M;
          }(), x = 63;
          return function(_) {
            for (var E = [], v = 0; v < _.length; v += 1) {
              var M = _.charCodeAt(v);
              if (M < 128) E.push(M);
              else {
                var I = b[_.charAt(v)];
                typeof I == "number" ? (255 & I) == I ? E.push(I) : (E.push(I >>> 8), E.push(255 & I)) : E.push(x);
              }
            }
            return E;
          };
        };
        var w, P, A, N, L, F = { L: 1, M: 0, Q: 3, H: 2 }, $ = (w = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], P = 1335, A = 7973, L = function(f) {
          for (var g = 0; f != 0; ) g += 1, f >>>= 1;
          return g;
        }, (N = {}).getBCHTypeInfo = function(f) {
          for (var g = f << 10; L(g) - L(P) >= 0; ) g ^= P << L(g) - L(P);
          return 21522 ^ (f << 10 | g);
        }, N.getBCHTypeNumber = function(f) {
          for (var g = f << 12; L(g) - L(A) >= 0; ) g ^= A << L(g) - L(A);
          return f << 12 | g;
        }, N.getPatternPosition = function(f) {
          return w[f - 1];
        }, N.getMaskFunction = function(f) {
          switch (f) {
            case 0:
              return function(g, b) {
                return (g + b) % 2 == 0;
              };
            case 1:
              return function(g, b) {
                return g % 2 == 0;
              };
            case 2:
              return function(g, b) {
                return b % 3 == 0;
              };
            case 3:
              return function(g, b) {
                return (g + b) % 3 == 0;
              };
            case 4:
              return function(g, b) {
                return (Math.floor(g / 2) + Math.floor(b / 3)) % 2 == 0;
              };
            case 5:
              return function(g, b) {
                return g * b % 2 + g * b % 3 == 0;
              };
            case 6:
              return function(g, b) {
                return (g * b % 2 + g * b % 3) % 2 == 0;
              };
            case 7:
              return function(g, b) {
                return (g * b % 3 + (g + b) % 2) % 2 == 0;
              };
            default:
              throw "bad maskPattern:" + f;
          }
        }, N.getErrorCorrectPolynomial = function(f) {
          for (var g = H([1], 0), b = 0; b < f; b += 1) g = g.multiply(H([1, K.gexp(b)], 0));
          return g;
        }, N.getLengthInBits = function(f, g) {
          if (1 <= g && g < 10) switch (f) {
            case 1:
              return 10;
            case 2:
              return 9;
            case 4:
            case 8:
              return 8;
            default:
              throw "mode:" + f;
          }
          else if (g < 27) switch (f) {
            case 1:
              return 12;
            case 2:
              return 11;
            case 4:
              return 16;
            case 8:
              return 10;
            default:
              throw "mode:" + f;
          }
          else {
            if (!(g < 41)) throw "type:" + g;
            switch (f) {
              case 1:
                return 14;
              case 2:
                return 13;
              case 4:
                return 16;
              case 8:
                return 12;
              default:
                throw "mode:" + f;
            }
          }
        }, N.getLostPoint = function(f) {
          for (var g = f.getModuleCount(), b = 0, x = 0; x < g; x += 1) for (var _ = 0; _ < g; _ += 1) {
            for (var E = 0, v = f.isDark(x, _), M = -1; M <= 1; M += 1) if (!(x + M < 0 || g <= x + M)) for (var I = -1; I <= 1; I += 1) _ + I < 0 || g <= _ + I || M == 0 && I == 0 || v == f.isDark(x + M, _ + I) && (E += 1);
            E > 5 && (b += 3 + E - 5);
          }
          for (x = 0; x < g - 1; x += 1) for (_ = 0; _ < g - 1; _ += 1) {
            var B = 0;
            f.isDark(x, _) && (B += 1), f.isDark(x + 1, _) && (B += 1), f.isDark(x, _ + 1) && (B += 1), f.isDark(x + 1, _ + 1) && (B += 1), B != 0 && B != 4 || (b += 3);
          }
          for (x = 0; x < g; x += 1) for (_ = 0; _ < g - 6; _ += 1) f.isDark(x, _) && !f.isDark(x, _ + 1) && f.isDark(x, _ + 2) && f.isDark(x, _ + 3) && f.isDark(x, _ + 4) && !f.isDark(x, _ + 5) && f.isDark(x, _ + 6) && (b += 40);
          for (_ = 0; _ < g; _ += 1) for (x = 0; x < g - 6; x += 1) f.isDark(x, _) && !f.isDark(x + 1, _) && f.isDark(x + 2, _) && f.isDark(x + 3, _) && f.isDark(x + 4, _) && !f.isDark(x + 5, _) && f.isDark(x + 6, _) && (b += 40);
          var ce = 0;
          for (_ = 0; _ < g; _ += 1) for (x = 0; x < g; x += 1) f.isDark(x, _) && (ce += 1);
          return b + Math.abs(100 * ce / g / g - 50) / 5 * 10;
        }, N), K = function() {
          for (var f = new Array(256), g = new Array(256), b = 0; b < 8; b += 1) f[b] = 1 << b;
          for (b = 8; b < 256; b += 1) f[b] = f[b - 4] ^ f[b - 5] ^ f[b - 6] ^ f[b - 8];
          for (b = 0; b < 255; b += 1) g[f[b]] = b;
          return { glog: function(x) {
            if (x < 1) throw "glog(" + x + ")";
            return g[x];
          }, gexp: function(x) {
            for (; x < 0; ) x += 255;
            for (; x >= 256; ) x -= 255;
            return f[x];
          } };
        }();
        function H(f, g) {
          if (f.length === void 0) throw f.length + "/" + g;
          var b = function() {
            for (var _ = 0; _ < f.length && f[_] == 0; ) _ += 1;
            for (var E = new Array(f.length - _ + g), v = 0; v < f.length - _; v += 1) E[v] = f[v + _];
            return E;
          }(), x = { getAt: function(_) {
            return b[_];
          }, getLength: function() {
            return b.length;
          }, multiply: function(_) {
            for (var E = new Array(x.getLength() + _.getLength() - 1), v = 0; v < x.getLength(); v += 1) for (var M = 0; M < _.getLength(); M += 1) E[v + M] ^= K.gexp(K.glog(x.getAt(v)) + K.glog(_.getAt(M)));
            return H(E, 0);
          }, mod: function(_) {
            if (x.getLength() - _.getLength() < 0) return x;
            for (var E = K.glog(x.getAt(0)) - K.glog(_.getAt(0)), v = new Array(x.getLength()), M = 0; M < x.getLength(); M += 1) v[M] = x.getAt(M);
            for (M = 0; M < _.getLength(); M += 1) v[M] ^= K.gexp(K.glog(_.getAt(M)) + E);
            return H(v, 0).mod(_);
          } };
          return x;
        }
        var V = /* @__PURE__ */ function() {
          var f = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]], g = function(x, _) {
            var E = {};
            return E.totalCount = x, E.dataCount = _, E;
          }, b = { getRSBlocks: function(x, _) {
            var E = function(Z, J) {
              switch (J) {
                case F.L:
                  return f[4 * (Z - 1) + 0];
                case F.M:
                  return f[4 * (Z - 1) + 1];
                case F.Q:
                  return f[4 * (Z - 1) + 2];
                case F.H:
                  return f[4 * (Z - 1) + 3];
                default:
                  return;
              }
            }(x, _);
            if (E === void 0) throw "bad rs block @ typeNumber:" + x + "/errorCorrectionLevel:" + _;
            for (var v = E.length / 3, M = [], I = 0; I < v; I += 1) for (var B = E[3 * I + 0], ce = E[3 * I + 1], D = E[3 * I + 2], oe = 0; oe < B; oe += 1) M.push(g(ce, D));
            return M;
          } };
          return b;
        }(), te = function() {
          var f = [], g = 0, b = { getBuffer: function() {
            return f;
          }, getAt: function(x) {
            var _ = Math.floor(x / 8);
            return (f[_] >>> 7 - x % 8 & 1) == 1;
          }, put: function(x, _) {
            for (var E = 0; E < _; E += 1) b.putBit((x >>> _ - E - 1 & 1) == 1);
          }, getLengthInBits: function() {
            return g;
          }, putBit: function(x) {
            var _ = Math.floor(g / 8);
            f.length <= _ && f.push(0), x && (f[_] |= 128 >>> g % 8), g += 1;
          } };
          return b;
        }, R = function(f) {
          var g = f, b = { getMode: function() {
            return 1;
          }, getLength: function(E) {
            return g.length;
          }, write: function(E) {
            for (var v = g, M = 0; M + 2 < v.length; ) E.put(x(v.substring(M, M + 3)), 10), M += 3;
            M < v.length && (v.length - M == 1 ? E.put(x(v.substring(M, M + 1)), 4) : v.length - M == 2 && E.put(x(v.substring(M, M + 2)), 7));
          } }, x = function(E) {
            for (var v = 0, M = 0; M < E.length; M += 1) v = 10 * v + _(E.charAt(M));
            return v;
          }, _ = function(E) {
            if ("0" <= E && E <= "9") return E.charCodeAt(0) - 48;
            throw "illegal char :" + E;
          };
          return b;
        }, W = function(f) {
          var g = f, b = { getMode: function() {
            return 2;
          }, getLength: function(_) {
            return g.length;
          }, write: function(_) {
            for (var E = g, v = 0; v + 1 < E.length; ) _.put(45 * x(E.charAt(v)) + x(E.charAt(v + 1)), 11), v += 2;
            v < E.length && _.put(x(E.charAt(v)), 6);
          } }, x = function(_) {
            if ("0" <= _ && _ <= "9") return _.charCodeAt(0) - 48;
            if ("A" <= _ && _ <= "Z") return _.charCodeAt(0) - 65 + 10;
            switch (_) {
              case " ":
                return 36;
              case "$":
                return 37;
              case "%":
                return 38;
              case "*":
                return 39;
              case "+":
                return 40;
              case "-":
                return 41;
              case ".":
                return 42;
              case "/":
                return 43;
              case ":":
                return 44;
              default:
                throw "illegal char :" + _;
            }
          };
          return b;
        }, pe = function(f) {
          var g = p.stringToBytes(f);
          return { getMode: function() {
            return 4;
          }, getLength: function(b) {
            return g.length;
          }, write: function(b) {
            for (var x = 0; x < g.length; x += 1) b.put(g[x], 8);
          } };
        }, Ee = function(f) {
          var g = p.stringToBytesFuncs.SJIS;
          if (!g) throw "sjis not supported.";
          (function() {
            var _ = g("");
            if (_.length != 2 || (_[0] << 8 | _[1]) != 38726) throw "sjis not supported.";
          })();
          var b = g(f), x = { getMode: function() {
            return 8;
          }, getLength: function(_) {
            return ~~(b.length / 2);
          }, write: function(_) {
            for (var E = b, v = 0; v + 1 < E.length; ) {
              var M = (255 & E[v]) << 8 | 255 & E[v + 1];
              if (33088 <= M && M <= 40956) M -= 33088;
              else {
                if (!(57408 <= M && M <= 60351)) throw "illegal char at " + (v + 1) + "/" + M;
                M -= 49472;
              }
              M = 192 * (M >>> 8 & 255) + (255 & M), _.put(M, 13), v += 2;
            }
            if (v < E.length) throw "illegal char at " + (v + 1);
          } };
          return x;
        }, Y = function() {
          var f = [], g = { writeByte: function(b) {
            f.push(255 & b);
          }, writeShort: function(b) {
            g.writeByte(b), g.writeByte(b >>> 8);
          }, writeBytes: function(b, x, _) {
            x = x || 0, _ = _ || b.length;
            for (var E = 0; E < _; E += 1) g.writeByte(b[E + x]);
          }, writeString: function(b) {
            for (var x = 0; x < b.length; x += 1) g.writeByte(b.charCodeAt(x));
          }, toByteArray: function() {
            return f;
          }, toString: function() {
            var b = "";
            b += "[";
            for (var x = 0; x < f.length; x += 1) x > 0 && (b += ","), b += f[x];
            return b + "]";
          } };
          return g;
        }, S = function(f) {
          var g = f, b = 0, x = 0, _ = 0, E = { read: function() {
            for (; _ < 8; ) {
              if (b >= g.length) {
                if (_ == 0) return -1;
                throw "unexpected end of file./" + _;
              }
              var M = g.charAt(b);
              if (b += 1, M == "=") return _ = 0, -1;
              M.match(/^\s$/) || (x = x << 6 | v(M.charCodeAt(0)), _ += 6);
            }
            var I = x >>> _ - 8 & 255;
            return _ -= 8, I;
          } }, v = function(M) {
            if (65 <= M && M <= 90) return M - 65;
            if (97 <= M && M <= 122) return M - 97 + 26;
            if (48 <= M && M <= 57) return M - 48 + 52;
            if (M == 43) return 62;
            if (M == 47) return 63;
            throw "c:" + M;
          };
          return E;
        }, m = function(f, g, b) {
          for (var x = function(ce, D) {
            var oe = ce, Z = D, J = new Array(ce * D), Q = { setPixel: function(re, de, ie) {
              J[de * oe + re] = ie;
            }, write: function(re) {
              re.writeString("GIF87a"), re.writeShort(oe), re.writeShort(Z), re.writeByte(128), re.writeByte(0), re.writeByte(0), re.writeByte(0), re.writeByte(0), re.writeByte(0), re.writeByte(255), re.writeByte(255), re.writeByte(255), re.writeString(","), re.writeShort(0), re.writeShort(0), re.writeShort(oe), re.writeShort(Z), re.writeByte(0);
              var de = T(2);
              re.writeByte(2);
              for (var ie = 0; de.length - ie > 255; ) re.writeByte(255), re.writeBytes(de, ie, 255), ie += 255;
              re.writeByte(de.length - ie), re.writeBytes(de, ie, de.length - ie), re.writeByte(0), re.writeString(";");
            } }, T = function(re) {
              for (var de = 1 << re, ie = 1 + (1 << re), ue = re + 1, ve = X(), Pe = 0; Pe < de; Pe += 1) ve.add(String.fromCharCode(Pe));
              ve.add(String.fromCharCode(de)), ve.add(String.fromCharCode(ie));
              var De, Ce, $e, Me = Y(), Ne = (De = Me, Ce = 0, $e = 0, { write: function(ze, _e) {
                if (ze >>> _e) throw "length over";
                for (; Ce + _e >= 8; ) De.writeByte(255 & (ze << Ce | $e)), _e -= 8 - Ce, ze >>>= 8 - Ce, $e = 0, Ce = 0;
                $e |= ze << Ce, Ce += _e;
              }, flush: function() {
                Ce > 0 && De.writeByte($e);
              } });
              Ne.write(de, ue);
              var Ke = 0, Le = String.fromCharCode(J[Ke]);
              for (Ke += 1; Ke < J.length; ) {
                var qe = String.fromCharCode(J[Ke]);
                Ke += 1, ve.contains(Le + qe) ? Le += qe : (Ne.write(ve.indexOf(Le), ue), ve.size() < 4095 && (ve.size() == 1 << ue && (ue += 1), ve.add(Le + qe)), Le = qe);
              }
              return Ne.write(ve.indexOf(Le), ue), Ne.write(ie, ue), Ne.flush(), Me.toByteArray();
            }, X = function() {
              var re = {}, de = 0, ie = { add: function(ue) {
                if (ie.contains(ue)) throw "dup key:" + ue;
                re[ue] = de, de += 1;
              }, size: function() {
                return de;
              }, indexOf: function(ue) {
                return re[ue];
              }, contains: function(ue) {
                return re[ue] !== void 0;
              } };
              return ie;
            };
            return Q;
          }(f, g), _ = 0; _ < g; _ += 1) for (var E = 0; E < f; E += 1) x.setPixel(E, _, b(E, _));
          var v = Y();
          x.write(v);
          for (var M = function() {
            var ce = 0, D = 0, oe = 0, Z = "", J = {}, Q = function(X) {
              Z += String.fromCharCode(T(63 & X));
            }, T = function(X) {
              if (!(X < 0)) {
                if (X < 26) return 65 + X;
                if (X < 52) return X - 26 + 97;
                if (X < 62) return X - 52 + 48;
                if (X == 62) return 43;
                if (X == 63) return 47;
              }
              throw "n:" + X;
            };
            return J.writeByte = function(X) {
              for (ce = ce << 8 | 255 & X, D += 8, oe += 1; D >= 6; ) Q(ce >>> D - 6), D -= 6;
            }, J.flush = function() {
              if (D > 0 && (Q(ce << 6 - D), ce = 0, D = 0), oe % 3 != 0) for (var X = 3 - oe % 3, re = 0; re < X; re += 1) Z += "=";
            }, J.toString = function() {
              return Z;
            }, J;
          }(), I = v.toByteArray(), B = 0; B < I.length; B += 1) M.writeByte(I[B]);
          return M.flush(), "data:image/gif;base64," + M;
        };
        return p;
      }();
      d.stringToBytesFuncs["UTF-8"] = function(p) {
        return function(w) {
          for (var P = [], A = 0; A < w.length; A++) {
            var N = w.charCodeAt(A);
            N < 128 ? P.push(N) : N < 2048 ? P.push(192 | N >> 6, 128 | 63 & N) : N < 55296 || N >= 57344 ? P.push(224 | N >> 12, 128 | N >> 6 & 63, 128 | 63 & N) : (A++, N = 65536 + ((1023 & N) << 10 | 1023 & w.charCodeAt(A)), P.push(240 | N >> 18, 128 | N >> 12 & 63, 128 | N >> 6 & 63, 128 | 63 & N));
          }
          return P;
        }(p);
      }, (l = typeof (u = function() {
        return d;
      }) == "function" ? u.apply(a, []) : u) === void 0 || (o.exports = l);
    } }, n = {};
    function i(o) {
      var a = n[o];
      if (a !== void 0) return a.exports;
      var u = n[o] = { exports: {} };
      return r[o](u, u.exports, i), u.exports;
    }
    i.n = (o) => {
      var a = o && o.__esModule ? () => o.default : () => o;
      return i.d(a, { a }), a;
    }, i.d = (o, a) => {
      for (var u in a) i.o(a, u) && !i.o(o, u) && Object.defineProperty(o, u, { enumerable: !0, get: a[u] });
    }, i.o = (o, a) => Object.prototype.hasOwnProperty.call(o, a);
    var s = {};
    return (() => {
      i.d(s, { default: () => Y });
      const o = (S) => !!S && typeof S == "object" && !Array.isArray(S);
      function a(S, ...m) {
        if (!m.length) return S;
        const f = m.shift();
        return f !== void 0 && o(S) && o(f) ? (S = Object.assign({}, S), Object.keys(f).forEach((g) => {
          const b = S[g], x = f[g];
          Array.isArray(b) && Array.isArray(x) ? S[g] = x : o(b) && o(x) ? S[g] = a(Object.assign({}, b), x) : S[g] = x;
        }), a(S, ...m)) : S;
      }
      function u(S, m) {
        const f = document.createElement("a");
        f.download = m, f.href = S, document.body.appendChild(f), f.click(), document.body.removeChild(f);
      }
      const l = { L: 0.07, M: 0.15, Q: 0.25, H: 0.3 };
      class d {
        constructor({ svg: m, type: f, window: g }) {
          this._svg = m, this._type = f, this._window = g;
        }
        draw(m, f, g, b) {
          let x;
          switch (this._type) {
            case "dots":
              x = this._drawDot;
              break;
            case "classy":
              x = this._drawClassy;
              break;
            case "classy-rounded":
              x = this._drawClassyRounded;
              break;
            case "rounded":
              x = this._drawRounded;
              break;
            case "extra-rounded":
              x = this._drawExtraRounded;
              break;
            default:
              x = this._drawSquare;
          }
          x.call(this, { x: m, y: f, size: g, getNeighbor: b });
        }
        _rotateFigure({ x: m, y: f, size: g, rotation: b = 0, draw: x }) {
          var _;
          const E = m + g / 2, v = f + g / 2;
          x(), (_ = this._element) === null || _ === void 0 || _.setAttribute("transform", `rotate(${180 * b / Math.PI},${E},${v})`);
        }
        _basicDot(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "circle"), this._element.setAttribute("cx", String(g + f / 2)), this._element.setAttribute("cy", String(b + f / 2)), this._element.setAttribute("r", String(f / 2));
          } }));
        }
        _basicSquare(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect"), this._element.setAttribute("x", String(g)), this._element.setAttribute("y", String(b)), this._element.setAttribute("width", String(f)), this._element.setAttribute("height", String(f));
          } }));
        }
        _basicSideRounded(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${g} ${b}v ${f}h ` + f / 2 + `a ${f / 2} ${f / 2}, 0, 0, 0, 0 ${-f}`);
          } }));
        }
        _basicCornerRounded(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${g} ${b}v ${f}h ${f}v ` + -f / 2 + `a ${f / 2} ${f / 2}, 0, 0, 0, ${-f / 2} ${-f / 2}`);
          } }));
        }
        _basicCornerExtraRounded(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${g} ${b}v ${f}h ${f}a ${f} ${f}, 0, 0, 0, ${-f} ${-f}`);
          } }));
        }
        _basicCornersRounded(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${g} ${b}v ` + f / 2 + `a ${f / 2} ${f / 2}, 0, 0, 0, ${f / 2} ${f / 2}h ` + f / 2 + "v " + -f / 2 + `a ${f / 2} ${f / 2}, 0, 0, 0, ${-f / 2} ${-f / 2}`);
          } }));
        }
        _drawDot({ x: m, y: f, size: g }) {
          this._basicDot({ x: m, y: f, size: g, rotation: 0 });
        }
        _drawSquare({ x: m, y: f, size: g }) {
          this._basicSquare({ x: m, y: f, size: g, rotation: 0 });
        }
        _drawRounded({ x: m, y: f, size: g, getNeighbor: b }) {
          const x = b ? +b(-1, 0) : 0, _ = b ? +b(1, 0) : 0, E = b ? +b(0, -1) : 0, v = b ? +b(0, 1) : 0, M = x + _ + E + v;
          if (M !== 0) if (M > 2 || x && _ || E && v) this._basicSquare({ x: m, y: f, size: g, rotation: 0 });
          else {
            if (M === 2) {
              let I = 0;
              return x && E ? I = Math.PI / 2 : E && _ ? I = Math.PI : _ && v && (I = -Math.PI / 2), void this._basicCornerRounded({ x: m, y: f, size: g, rotation: I });
            }
            if (M === 1) {
              let I = 0;
              return E ? I = Math.PI / 2 : _ ? I = Math.PI : v && (I = -Math.PI / 2), void this._basicSideRounded({ x: m, y: f, size: g, rotation: I });
            }
          }
          else this._basicDot({ x: m, y: f, size: g, rotation: 0 });
        }
        _drawExtraRounded({ x: m, y: f, size: g, getNeighbor: b }) {
          const x = b ? +b(-1, 0) : 0, _ = b ? +b(1, 0) : 0, E = b ? +b(0, -1) : 0, v = b ? +b(0, 1) : 0, M = x + _ + E + v;
          if (M !== 0) if (M > 2 || x && _ || E && v) this._basicSquare({ x: m, y: f, size: g, rotation: 0 });
          else {
            if (M === 2) {
              let I = 0;
              return x && E ? I = Math.PI / 2 : E && _ ? I = Math.PI : _ && v && (I = -Math.PI / 2), void this._basicCornerExtraRounded({ x: m, y: f, size: g, rotation: I });
            }
            if (M === 1) {
              let I = 0;
              return E ? I = Math.PI / 2 : _ ? I = Math.PI : v && (I = -Math.PI / 2), void this._basicSideRounded({ x: m, y: f, size: g, rotation: I });
            }
          }
          else this._basicDot({ x: m, y: f, size: g, rotation: 0 });
        }
        _drawClassy({ x: m, y: f, size: g, getNeighbor: b }) {
          const x = b ? +b(-1, 0) : 0, _ = b ? +b(1, 0) : 0, E = b ? +b(0, -1) : 0, v = b ? +b(0, 1) : 0;
          x + _ + E + v !== 0 ? x || E ? _ || v ? this._basicSquare({ x: m, y: f, size: g, rotation: 0 }) : this._basicCornerRounded({ x: m, y: f, size: g, rotation: Math.PI / 2 }) : this._basicCornerRounded({ x: m, y: f, size: g, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: m, y: f, size: g, rotation: Math.PI / 2 });
        }
        _drawClassyRounded({ x: m, y: f, size: g, getNeighbor: b }) {
          const x = b ? +b(-1, 0) : 0, _ = b ? +b(1, 0) : 0, E = b ? +b(0, -1) : 0, v = b ? +b(0, 1) : 0;
          x + _ + E + v !== 0 ? x || E ? _ || v ? this._basicSquare({ x: m, y: f, size: g, rotation: 0 }) : this._basicCornerExtraRounded({ x: m, y: f, size: g, rotation: Math.PI / 2 }) : this._basicCornerExtraRounded({ x: m, y: f, size: g, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: m, y: f, size: g, rotation: Math.PI / 2 });
        }
      }
      class p {
        constructor({ svg: m, type: f, window: g }) {
          this._svg = m, this._type = f, this._window = g;
        }
        draw(m, f, g, b) {
          let x;
          switch (this._type) {
            case "square":
              x = this._drawSquare;
              break;
            case "extra-rounded":
              x = this._drawExtraRounded;
              break;
            default:
              x = this._drawDot;
          }
          x.call(this, { x: m, y: f, size: g, rotation: b });
        }
        _rotateFigure({ x: m, y: f, size: g, rotation: b = 0, draw: x }) {
          var _;
          const E = m + g / 2, v = f + g / 2;
          x(), (_ = this._element) === null || _ === void 0 || _.setAttribute("transform", `rotate(${180 * b / Math.PI},${E},${v})`);
        }
        _basicDot(m) {
          const { size: f, x: g, y: b } = m, x = f / 7;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${g + f / 2} ${b}a ${f / 2} ${f / 2} 0 1 0 0.1 0zm 0 ${x}a ${f / 2 - x} ${f / 2 - x} 0 1 1 -0.1 0Z`);
          } }));
        }
        _basicSquare(m) {
          const { size: f, x: g, y: b } = m, x = f / 7;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${g} ${b}v ${f}h ${f}v ` + -f + `zM ${g + x} ${b + x}h ` + (f - 2 * x) + "v " + (f - 2 * x) + "h " + (2 * x - f) + "z");
          } }));
        }
        _basicExtraRounded(m) {
          const { size: f, x: g, y: b } = m, x = f / 7;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${g} ${b + 2.5 * x}v ` + 2 * x + `a ${2.5 * x} ${2.5 * x}, 0, 0, 0, ${2.5 * x} ${2.5 * x}h ` + 2 * x + `a ${2.5 * x} ${2.5 * x}, 0, 0, 0, ${2.5 * x} ${2.5 * -x}v ` + -2 * x + `a ${2.5 * x} ${2.5 * x}, 0, 0, 0, ${2.5 * -x} ${2.5 * -x}h ` + -2 * x + `a ${2.5 * x} ${2.5 * x}, 0, 0, 0, ${2.5 * -x} ${2.5 * x}M ${g + 2.5 * x} ${b + x}h ` + 2 * x + `a ${1.5 * x} ${1.5 * x}, 0, 0, 1, ${1.5 * x} ${1.5 * x}v ` + 2 * x + `a ${1.5 * x} ${1.5 * x}, 0, 0, 1, ${1.5 * -x} ${1.5 * x}h ` + -2 * x + `a ${1.5 * x} ${1.5 * x}, 0, 0, 1, ${1.5 * -x} ${1.5 * -x}v ` + -2 * x + `a ${1.5 * x} ${1.5 * x}, 0, 0, 1, ${1.5 * x} ${1.5 * -x}`);
          } }));
        }
        _drawDot({ x: m, y: f, size: g, rotation: b }) {
          this._basicDot({ x: m, y: f, size: g, rotation: b });
        }
        _drawSquare({ x: m, y: f, size: g, rotation: b }) {
          this._basicSquare({ x: m, y: f, size: g, rotation: b });
        }
        _drawExtraRounded({ x: m, y: f, size: g, rotation: b }) {
          this._basicExtraRounded({ x: m, y: f, size: g, rotation: b });
        }
      }
      class w {
        constructor({ svg: m, type: f, window: g }) {
          this._svg = m, this._type = f, this._window = g;
        }
        draw(m, f, g, b) {
          let x;
          x = this._type === "square" ? this._drawSquare : this._drawDot, x.call(this, { x: m, y: f, size: g, rotation: b });
        }
        _rotateFigure({ x: m, y: f, size: g, rotation: b = 0, draw: x }) {
          var _;
          const E = m + g / 2, v = f + g / 2;
          x(), (_ = this._element) === null || _ === void 0 || _.setAttribute("transform", `rotate(${180 * b / Math.PI},${E},${v})`);
        }
        _basicDot(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "circle"), this._element.setAttribute("cx", String(g + f / 2)), this._element.setAttribute("cy", String(b + f / 2)), this._element.setAttribute("r", String(f / 2));
          } }));
        }
        _basicSquare(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect"), this._element.setAttribute("x", String(g)), this._element.setAttribute("y", String(b)), this._element.setAttribute("width", String(f)), this._element.setAttribute("height", String(f));
          } }));
        }
        _drawDot({ x: m, y: f, size: g, rotation: b }) {
          this._basicDot({ x: m, y: f, size: g, rotation: b });
        }
        _drawSquare({ x: m, y: f, size: g, rotation: b }) {
          this._basicSquare({ x: m, y: f, size: g, rotation: b });
        }
      }
      const P = "circle", A = [[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]], N = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]];
      class L {
        constructor(m, f) {
          this._roundSize = (g) => this._options.dotsOptions.roundSize ? Math.floor(g) : g, this._window = f, this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._element.setAttribute("width", String(m.width)), this._element.setAttribute("height", String(m.height)), this._element.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), m.dotsOptions.roundSize || this._element.setAttribute("shape-rendering", "crispEdges"), this._element.setAttribute("viewBox", `0 0 ${m.width} ${m.height}`), this._defs = this._window.document.createElementNS("http://www.w3.org/2000/svg", "defs"), this._element.appendChild(this._defs), this._imageUri = m.image, this._instanceId = L.instanceCount++, this._options = m;
        }
        get width() {
          return this._options.width;
        }
        get height() {
          return this._options.height;
        }
        getElement() {
          return this._element;
        }
        async drawQR(m) {
          const f = m.getModuleCount(), g = Math.min(this._options.width, this._options.height) - 2 * this._options.margin, b = this._options.shape === P ? g / Math.sqrt(2) : g, x = this._roundSize(b / f);
          let _ = { hideXDots: 0, hideYDots: 0, width: 0, height: 0 };
          if (this._qr = m, this._options.image) {
            if (await this.loadImage(), !this._image) return;
            const { imageOptions: E, qrOptions: v } = this._options, M = E.imageSize * l[v.errorCorrectionLevel], I = Math.floor(M * f * f);
            _ = function({ originalHeight: B, originalWidth: ce, maxHiddenDots: D, maxHiddenAxisDots: oe, dotSize: Z }) {
              const J = { x: 0, y: 0 }, Q = { x: 0, y: 0 };
              if (B <= 0 || ce <= 0 || D <= 0 || Z <= 0) return { height: 0, width: 0, hideYDots: 0, hideXDots: 0 };
              const T = B / ce;
              return J.x = Math.floor(Math.sqrt(D / T)), J.x <= 0 && (J.x = 1), oe && oe < J.x && (J.x = oe), J.x % 2 == 0 && J.x--, Q.x = J.x * Z, J.y = 1 + 2 * Math.ceil((J.x * T - 1) / 2), Q.y = Math.round(Q.x * T), (J.y * J.x > D || oe && oe < J.y) && (oe && oe < J.y ? (J.y = oe, J.y % 2 == 0 && J.x--) : J.y -= 2, Q.y = J.y * Z, J.x = 1 + 2 * Math.ceil((J.y / T - 1) / 2), Q.x = Math.round(Q.y / T)), { height: Q.y, width: Q.x, hideYDots: J.y, hideXDots: J.x };
            }({ originalWidth: this._image.width, originalHeight: this._image.height, maxHiddenDots: I, maxHiddenAxisDots: f - 14, dotSize: x });
          }
          this.drawBackground(), this.drawDots((E, v) => {
            var M, I, B, ce, D, oe;
            return !(this._options.imageOptions.hideBackgroundDots && E >= (f - _.hideYDots) / 2 && E < (f + _.hideYDots) / 2 && v >= (f - _.hideXDots) / 2 && v < (f + _.hideXDots) / 2 || !((M = A[E]) === null || M === void 0) && M[v] || !((I = A[E - f + 7]) === null || I === void 0) && I[v] || !((B = A[E]) === null || B === void 0) && B[v - f + 7] || !((ce = N[E]) === null || ce === void 0) && ce[v] || !((D = N[E - f + 7]) === null || D === void 0) && D[v] || !((oe = N[E]) === null || oe === void 0) && oe[v - f + 7]);
          }), this.drawCorners(), this._options.image && await this.drawImage({ width: _.width, height: _.height, count: f, dotSize: x });
        }
        drawBackground() {
          var m, f, g;
          const b = this._element, x = this._options;
          if (b) {
            const _ = (m = x.backgroundOptions) === null || m === void 0 ? void 0 : m.gradient, E = (f = x.backgroundOptions) === null || f === void 0 ? void 0 : f.color;
            let v = x.height, M = x.width;
            if (_ || E) {
              const I = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
              this._backgroundClipPath = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._backgroundClipPath.setAttribute("id", `clip-path-background-color-${this._instanceId}`), this._defs.appendChild(this._backgroundClipPath), !((g = x.backgroundOptions) === null || g === void 0) && g.round && (v = M = Math.min(x.width, x.height), I.setAttribute("rx", String(v / 2 * x.backgroundOptions.round))), I.setAttribute("x", String(this._roundSize((x.width - M) / 2))), I.setAttribute("y", String(this._roundSize((x.height - v) / 2))), I.setAttribute("width", String(M)), I.setAttribute("height", String(v)), this._backgroundClipPath.appendChild(I), this._createColor({ options: _, color: E, additionalRotation: 0, x: 0, y: 0, height: x.height, width: x.width, name: `background-color-${this._instanceId}` });
            }
          }
        }
        drawDots(m) {
          var f, g;
          if (!this._qr) throw "QR code is not defined";
          const b = this._options, x = this._qr.getModuleCount();
          if (x > b.width || x > b.height) throw "The canvas is too small.";
          const _ = Math.min(b.width, b.height) - 2 * b.margin, E = b.shape === P ? _ / Math.sqrt(2) : _, v = this._roundSize(E / x), M = this._roundSize((b.width - x * v) / 2), I = this._roundSize((b.height - x * v) / 2), B = new d({ svg: this._element, type: b.dotsOptions.type, window: this._window });
          this._dotsClipPath = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._dotsClipPath.setAttribute("id", `clip-path-dot-color-${this._instanceId}`), this._defs.appendChild(this._dotsClipPath), this._createColor({ options: (f = b.dotsOptions) === null || f === void 0 ? void 0 : f.gradient, color: b.dotsOptions.color, additionalRotation: 0, x: 0, y: 0, height: b.height, width: b.width, name: `dot-color-${this._instanceId}` });
          for (let ce = 0; ce < x; ce++) for (let D = 0; D < x; D++) m && !m(ce, D) || !((g = this._qr) === null || g === void 0) && g.isDark(ce, D) && (B.draw(M + D * v, I + ce * v, v, (oe, Z) => !(D + oe < 0 || ce + Z < 0 || D + oe >= x || ce + Z >= x) && !(m && !m(ce + Z, D + oe)) && !!this._qr && this._qr.isDark(ce + Z, D + oe)), B._element && this._dotsClipPath && this._dotsClipPath.appendChild(B._element));
          if (b.shape === P) {
            const ce = this._roundSize((_ / v - x) / 2), D = x + 2 * ce, oe = M - ce * v, Z = I - ce * v, J = [], Q = this._roundSize(D / 2);
            for (let T = 0; T < D; T++) {
              J[T] = [];
              for (let X = 0; X < D; X++) T >= ce - 1 && T <= D - ce && X >= ce - 1 && X <= D - ce || Math.sqrt((T - Q) * (T - Q) + (X - Q) * (X - Q)) > Q ? J[T][X] = 0 : J[T][X] = this._qr.isDark(X - 2 * ce < 0 ? X : X >= x ? X - 2 * ce : X - ce, T - 2 * ce < 0 ? T : T >= x ? T - 2 * ce : T - ce) ? 1 : 0;
            }
            for (let T = 0; T < D; T++) for (let X = 0; X < D; X++) J[T][X] && (B.draw(oe + X * v, Z + T * v, v, (re, de) => {
              var ie;
              return !!(!((ie = J[T + de]) === null || ie === void 0) && ie[X + re]);
            }), B._element && this._dotsClipPath && this._dotsClipPath.appendChild(B._element));
          }
        }
        drawCorners() {
          if (!this._qr) throw "QR code is not defined";
          const m = this._element, f = this._options;
          if (!m) throw "Element code is not defined";
          const g = this._qr.getModuleCount(), b = Math.min(f.width, f.height) - 2 * f.margin, x = f.shape === P ? b / Math.sqrt(2) : b, _ = this._roundSize(x / g), E = 7 * _, v = 3 * _, M = this._roundSize((f.width - g * _) / 2), I = this._roundSize((f.height - g * _) / 2);
          [[0, 0, 0], [1, 0, Math.PI / 2], [0, 1, -Math.PI / 2]].forEach(([B, ce, D]) => {
            var oe, Z, J, Q, T, X, re, de, ie, ue, ve, Pe;
            const De = M + B * _ * (g - 7), Ce = I + ce * _ * (g - 7);
            let $e = this._dotsClipPath, Me = this._dotsClipPath;
            if ((!((oe = f.cornersSquareOptions) === null || oe === void 0) && oe.gradient || !((Z = f.cornersSquareOptions) === null || Z === void 0) && Z.color) && ($e = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), $e.setAttribute("id", `clip-path-corners-square-color-${B}-${ce}-${this._instanceId}`), this._defs.appendChild($e), this._cornersSquareClipPath = this._cornersDotClipPath = Me = $e, this._createColor({ options: (J = f.cornersSquareOptions) === null || J === void 0 ? void 0 : J.gradient, color: (Q = f.cornersSquareOptions) === null || Q === void 0 ? void 0 : Q.color, additionalRotation: D, x: De, y: Ce, height: E, width: E, name: `corners-square-color-${B}-${ce}-${this._instanceId}` })), (T = f.cornersSquareOptions) === null || T === void 0 ? void 0 : T.type) {
              const Ne = new p({ svg: this._element, type: f.cornersSquareOptions.type, window: this._window });
              Ne.draw(De, Ce, E, D), Ne._element && $e && $e.appendChild(Ne._element);
            } else {
              const Ne = new d({ svg: this._element, type: f.dotsOptions.type, window: this._window });
              for (let Ke = 0; Ke < A.length; Ke++) for (let Le = 0; Le < A[Ke].length; Le++) !((X = A[Ke]) === null || X === void 0) && X[Le] && (Ne.draw(De + Le * _, Ce + Ke * _, _, (qe, ze) => {
                var _e;
                return !!(!((_e = A[Ke + ze]) === null || _e === void 0) && _e[Le + qe]);
              }), Ne._element && $e && $e.appendChild(Ne._element));
            }
            if ((!((re = f.cornersDotOptions) === null || re === void 0) && re.gradient || !((de = f.cornersDotOptions) === null || de === void 0) && de.color) && (Me = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), Me.setAttribute("id", `clip-path-corners-dot-color-${B}-${ce}-${this._instanceId}`), this._defs.appendChild(Me), this._cornersDotClipPath = Me, this._createColor({ options: (ie = f.cornersDotOptions) === null || ie === void 0 ? void 0 : ie.gradient, color: (ue = f.cornersDotOptions) === null || ue === void 0 ? void 0 : ue.color, additionalRotation: D, x: De + 2 * _, y: Ce + 2 * _, height: v, width: v, name: `corners-dot-color-${B}-${ce}-${this._instanceId}` })), (ve = f.cornersDotOptions) === null || ve === void 0 ? void 0 : ve.type) {
              const Ne = new w({ svg: this._element, type: f.cornersDotOptions.type, window: this._window });
              Ne.draw(De + 2 * _, Ce + 2 * _, v, D), Ne._element && Me && Me.appendChild(Ne._element);
            } else {
              const Ne = new d({ svg: this._element, type: f.dotsOptions.type, window: this._window });
              for (let Ke = 0; Ke < N.length; Ke++) for (let Le = 0; Le < N[Ke].length; Le++) !((Pe = N[Ke]) === null || Pe === void 0) && Pe[Le] && (Ne.draw(De + Le * _, Ce + Ke * _, _, (qe, ze) => {
                var _e;
                return !!(!((_e = N[Ke + ze]) === null || _e === void 0) && _e[Le + qe]);
              }), Ne._element && Me && Me.appendChild(Ne._element));
            }
          });
        }
        loadImage() {
          return new Promise((m, f) => {
            var g;
            const b = this._options;
            if (!b.image) return f("Image is not defined");
            if (!((g = b.nodeCanvas) === null || g === void 0) && g.loadImage) b.nodeCanvas.loadImage(b.image).then((x) => {
              var _, E;
              if (this._image = x, this._options.imageOptions.saveAsBlob) {
                const v = (_ = b.nodeCanvas) === null || _ === void 0 ? void 0 : _.createCanvas(this._image.width, this._image.height);
                (E = v == null ? void 0 : v.getContext("2d")) === null || E === void 0 || E.drawImage(x, 0, 0), this._imageUri = v == null ? void 0 : v.toDataURL();
              }
              m();
            }).catch(f);
            else {
              const x = new this._window.Image();
              typeof b.imageOptions.crossOrigin == "string" && (x.crossOrigin = b.imageOptions.crossOrigin), this._image = x, x.onload = async () => {
                this._options.imageOptions.saveAsBlob && (this._imageUri = await async function(_, E) {
                  return new Promise((v) => {
                    const M = new E.XMLHttpRequest();
                    M.onload = function() {
                      const I = new E.FileReader();
                      I.onloadend = function() {
                        v(I.result);
                      }, I.readAsDataURL(M.response);
                    }, M.open("GET", _), M.responseType = "blob", M.send();
                  });
                }(b.image || "", this._window)), m();
              }, x.src = b.image;
            }
          });
        }
        async drawImage({ width: m, height: f, count: g, dotSize: b }) {
          const x = this._options, _ = this._roundSize((x.width - g * b) / 2), E = this._roundSize((x.height - g * b) / 2), v = _ + this._roundSize(x.imageOptions.margin + (g * b - m) / 2), M = E + this._roundSize(x.imageOptions.margin + (g * b - f) / 2), I = m - 2 * x.imageOptions.margin, B = f - 2 * x.imageOptions.margin, ce = this._window.document.createElementNS("http://www.w3.org/2000/svg", "image");
          ce.setAttribute("href", this._imageUri || ""), ce.setAttribute("x", String(v)), ce.setAttribute("y", String(M)), ce.setAttribute("width", `${I}px`), ce.setAttribute("height", `${B}px`), this._element.appendChild(ce);
        }
        _createColor({ options: m, color: f, additionalRotation: g, x: b, y: x, height: _, width: E, name: v }) {
          const M = E > _ ? E : _, I = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
          if (I.setAttribute("x", String(b)), I.setAttribute("y", String(x)), I.setAttribute("height", String(_)), I.setAttribute("width", String(E)), I.setAttribute("clip-path", `url('#clip-path-${v}')`), m) {
            let B;
            if (m.type === "radial") B = this._window.document.createElementNS("http://www.w3.org/2000/svg", "radialGradient"), B.setAttribute("id", v), B.setAttribute("gradientUnits", "userSpaceOnUse"), B.setAttribute("fx", String(b + E / 2)), B.setAttribute("fy", String(x + _ / 2)), B.setAttribute("cx", String(b + E / 2)), B.setAttribute("cy", String(x + _ / 2)), B.setAttribute("r", String(M / 2));
            else {
              const ce = ((m.rotation || 0) + g) % (2 * Math.PI), D = (ce + 2 * Math.PI) % (2 * Math.PI);
              let oe = b + E / 2, Z = x + _ / 2, J = b + E / 2, Q = x + _ / 2;
              D >= 0 && D <= 0.25 * Math.PI || D > 1.75 * Math.PI && D <= 2 * Math.PI ? (oe -= E / 2, Z -= _ / 2 * Math.tan(ce), J += E / 2, Q += _ / 2 * Math.tan(ce)) : D > 0.25 * Math.PI && D <= 0.75 * Math.PI ? (Z -= _ / 2, oe -= E / 2 / Math.tan(ce), Q += _ / 2, J += E / 2 / Math.tan(ce)) : D > 0.75 * Math.PI && D <= 1.25 * Math.PI ? (oe += E / 2, Z += _ / 2 * Math.tan(ce), J -= E / 2, Q -= _ / 2 * Math.tan(ce)) : D > 1.25 * Math.PI && D <= 1.75 * Math.PI && (Z += _ / 2, oe += E / 2 / Math.tan(ce), Q -= _ / 2, J -= E / 2 / Math.tan(ce)), B = this._window.document.createElementNS("http://www.w3.org/2000/svg", "linearGradient"), B.setAttribute("id", v), B.setAttribute("gradientUnits", "userSpaceOnUse"), B.setAttribute("x1", String(Math.round(oe))), B.setAttribute("y1", String(Math.round(Z))), B.setAttribute("x2", String(Math.round(J))), B.setAttribute("y2", String(Math.round(Q)));
            }
            m.colorStops.forEach(({ offset: ce, color: D }) => {
              const oe = this._window.document.createElementNS("http://www.w3.org/2000/svg", "stop");
              oe.setAttribute("offset", 100 * ce + "%"), oe.setAttribute("stop-color", D), B.appendChild(oe);
            }), I.setAttribute("fill", `url('#${v}')`), this._defs.appendChild(B);
          } else f && I.setAttribute("fill", f);
          this._element.appendChild(I);
        }
      }
      L.instanceCount = 0;
      const F = L, $ = "canvas", K = {};
      for (let S = 0; S <= 40; S++) K[S] = S;
      const H = { type: $, shape: "square", width: 300, height: 300, data: "", margin: 0, qrOptions: { typeNumber: K[0], mode: void 0, errorCorrectionLevel: "Q" }, imageOptions: { saveAsBlob: !0, hideBackgroundDots: !0, imageSize: 0.4, crossOrigin: void 0, margin: 0 }, dotsOptions: { type: "square", color: "#000", roundSize: !0 }, backgroundOptions: { round: 0, color: "#fff" } };
      function V(S) {
        const m = Object.assign({}, S);
        if (!m.colorStops || !m.colorStops.length) throw "Field 'colorStops' is required in gradient";
        return m.rotation ? m.rotation = Number(m.rotation) : m.rotation = 0, m.colorStops = m.colorStops.map((f) => Object.assign(Object.assign({}, f), { offset: Number(f.offset) })), m;
      }
      function te(S) {
        const m = Object.assign({}, S);
        return m.width = Number(m.width), m.height = Number(m.height), m.margin = Number(m.margin), m.imageOptions = Object.assign(Object.assign({}, m.imageOptions), { hideBackgroundDots: !!m.imageOptions.hideBackgroundDots, imageSize: Number(m.imageOptions.imageSize), margin: Number(m.imageOptions.margin) }), m.margin > Math.min(m.width, m.height) && (m.margin = Math.min(m.width, m.height)), m.dotsOptions = Object.assign({}, m.dotsOptions), m.dotsOptions.gradient && (m.dotsOptions.gradient = V(m.dotsOptions.gradient)), m.cornersSquareOptions && (m.cornersSquareOptions = Object.assign({}, m.cornersSquareOptions), m.cornersSquareOptions.gradient && (m.cornersSquareOptions.gradient = V(m.cornersSquareOptions.gradient))), m.cornersDotOptions && (m.cornersDotOptions = Object.assign({}, m.cornersDotOptions), m.cornersDotOptions.gradient && (m.cornersDotOptions.gradient = V(m.cornersDotOptions.gradient))), m.backgroundOptions && (m.backgroundOptions = Object.assign({}, m.backgroundOptions), m.backgroundOptions.gradient && (m.backgroundOptions.gradient = V(m.backgroundOptions.gradient))), m;
      }
      var R = i(873), W = i.n(R);
      function pe(S) {
        if (!S) throw new Error("Extension must be defined");
        S[0] === "." && (S = S.substring(1));
        const m = { bmp: "image/bmp", gif: "image/gif", ico: "image/vnd.microsoft.icon", jpeg: "image/jpeg", jpg: "image/jpeg", png: "image/png", svg: "image/svg+xml", tif: "image/tiff", tiff: "image/tiff", webp: "image/webp", pdf: "application/pdf" }[S.toLowerCase()];
        if (!m) throw new Error(`Extension "${S}" is not supported`);
        return m;
      }
      class Ee {
        constructor(m) {
          m != null && m.jsdom ? this._window = new m.jsdom("", { resources: "usable" }).window : this._window = window, this._options = m ? te(a(H, m)) : H, this.update();
        }
        static _clearContainer(m) {
          m && (m.innerHTML = "");
        }
        _setupSvg() {
          if (!this._qr) return;
          const m = new F(this._options, this._window);
          this._svg = m.getElement(), this._svgDrawingPromise = m.drawQR(this._qr).then(() => {
            var f;
            this._svg && ((f = this._extension) === null || f === void 0 || f.call(this, m.getElement(), this._options));
          });
        }
        _setupCanvas() {
          var m, f;
          this._qr && (!((m = this._options.nodeCanvas) === null || m === void 0) && m.createCanvas ? (this._nodeCanvas = this._options.nodeCanvas.createCanvas(this._options.width, this._options.height), this._nodeCanvas.width = this._options.width, this._nodeCanvas.height = this._options.height) : (this._domCanvas = document.createElement("canvas"), this._domCanvas.width = this._options.width, this._domCanvas.height = this._options.height), this._setupSvg(), this._canvasDrawingPromise = (f = this._svgDrawingPromise) === null || f === void 0 ? void 0 : f.then(() => {
            var g;
            if (!this._svg) return;
            const b = this._svg, x = new this._window.XMLSerializer().serializeToString(b), _ = btoa(x), E = `data:${pe("svg")};base64,${_}`;
            if (!((g = this._options.nodeCanvas) === null || g === void 0) && g.loadImage) return this._options.nodeCanvas.loadImage(E).then((v) => {
              var M, I;
              v.width = this._options.width, v.height = this._options.height, (I = (M = this._nodeCanvas) === null || M === void 0 ? void 0 : M.getContext("2d")) === null || I === void 0 || I.drawImage(v, 0, 0);
            });
            {
              const v = new this._window.Image();
              return new Promise((M) => {
                v.onload = () => {
                  var I, B;
                  (B = (I = this._domCanvas) === null || I === void 0 ? void 0 : I.getContext("2d")) === null || B === void 0 || B.drawImage(v, 0, 0), M();
                }, v.src = E;
              });
            }
          }));
        }
        async _getElement(m = "png") {
          if (!this._qr) throw "QR code is empty";
          return m.toLowerCase() === "svg" ? (this._svg && this._svgDrawingPromise || this._setupSvg(), await this._svgDrawingPromise, this._svg) : ((this._domCanvas || this._nodeCanvas) && this._canvasDrawingPromise || this._setupCanvas(), await this._canvasDrawingPromise, this._domCanvas || this._nodeCanvas);
        }
        update(m) {
          Ee._clearContainer(this._container), this._options = m ? te(a(this._options, m)) : this._options, this._options.data && (this._qr = W()(this._options.qrOptions.typeNumber, this._options.qrOptions.errorCorrectionLevel), this._qr.addData(this._options.data, this._options.qrOptions.mode || function(f) {
            switch (!0) {
              case /^[0-9]*$/.test(f):
                return "Numeric";
              case /^[0-9A-Z $%*+\-./:]*$/.test(f):
                return "Alphanumeric";
              default:
                return "Byte";
            }
          }(this._options.data)), this._qr.make(), this._options.type === $ ? this._setupCanvas() : this._setupSvg(), this.append(this._container));
        }
        append(m) {
          if (m) {
            if (typeof m.appendChild != "function") throw "Container should be a single DOM node";
            this._options.type === $ ? this._domCanvas && m.appendChild(this._domCanvas) : this._svg && m.appendChild(this._svg), this._container = m;
          }
        }
        applyExtension(m) {
          if (!m) throw "Extension function should be defined.";
          this._extension = m, this.update();
        }
        deleteExtension() {
          this._extension = void 0, this.update();
        }
        async getRawData(m = "png") {
          if (!this._qr) throw "QR code is empty";
          const f = await this._getElement(m), g = pe(m);
          if (!f) return null;
          if (m.toLowerCase() === "svg") {
            const b = `<?xml version="1.0" standalone="no"?>\r
${new this._window.XMLSerializer().serializeToString(f)}`;
            return typeof Blob > "u" || this._options.jsdom ? Buffer.from(b) : new Blob([b], { type: g });
          }
          return new Promise((b) => {
            const x = f;
            if ("toBuffer" in x) if (g === "image/png") b(x.toBuffer(g));
            else if (g === "image/jpeg") b(x.toBuffer(g));
            else {
              if (g !== "application/pdf") throw Error("Unsupported extension");
              b(x.toBuffer(g));
            }
            else "toBlob" in x && x.toBlob(b, g, 1);
          });
        }
        async download(m) {
          if (!this._qr) throw "QR code is empty";
          if (typeof Blob > "u") throw "Cannot download in Node.js, call getRawData instead.";
          let f = "png", g = "qr";
          typeof m == "string" ? (f = m, console.warn("Extension is deprecated as argument for 'download' method, please pass object { name: '...', extension: '...' } as argument")) : typeof m == "object" && m !== null && (m.name && (g = m.name), m.extension && (f = m.extension));
          const b = await this._getElement(f);
          if (b) if (f.toLowerCase() === "svg") {
            let x = new XMLSerializer().serializeToString(b);
            x = `<?xml version="1.0" standalone="no"?>\r
` + x, u(`data:${pe(f)};charset=utf-8,${encodeURIComponent(x)}`, `${g}.svg`);
          } else u(b.toDataURL(pe(f)), `${g}.${f}`);
        }
      }
      const Y = Ee;
    })(), s.default;
  })());
})(N9);
var Nne = N9.exports;
const L9 = /* @__PURE__ */ ts(Nne);
class ia extends yt {
  constructor(e) {
    const { docsPath: r, field: n, metaMessages: i } = e;
    super(`Invalid Sign-In with Ethereum message field "${n}".`, {
      docsPath: r,
      metaMessages: i,
      name: "SiweInvalidMessageFieldError"
    });
  }
}
function u5(t) {
  if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(t) || /%[^0-9a-f]/i.test(t) || /%[0-9a-f](:?[^0-9a-f]|$)/i.test(t))
    return !1;
  const e = Lne(t), r = e[1], n = e[2], i = e[3], s = e[4], o = e[5];
  if (!(r != null && r.length && i.length >= 0))
    return !1;
  if (n != null && n.length) {
    if (!(i.length === 0 || /^\//.test(i)))
      return !1;
  } else if (/^\/\//.test(i))
    return !1;
  if (!/^[a-z][a-z0-9\+\-\.]*$/.test(r.toLowerCase()))
    return !1;
  let a = "";
  return a += `${r}:`, n != null && n.length && (a += `//${n}`), a += i, s != null && s.length && (a += `?${s}`), o != null && o.length && (a += `#${o}`), a;
}
function Lne(t) {
  return t.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
}
function k9(t) {
  const { chainId: e, domain: r, expirationTime: n, issuedAt: i = /* @__PURE__ */ new Date(), nonce: s, notBefore: o, requestId: a, resources: u, scheme: l, uri: d, version: p } = t;
  {
    if (e !== Math.floor(e))
      throw new ia({
        field: "chainId",
        metaMessages: [
          "- Chain ID must be a EIP-155 chain ID.",
          "- See https://eips.ethereum.org/EIPS/eip-155",
          "",
          `Provided value: ${e}`
        ]
      });
    if (!(kne.test(r) || $ne.test(r) || Fne.test(r)))
      throw new ia({
        field: "domain",
        metaMessages: [
          "- Domain must be an RFC 3986 authority.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${r}`
        ]
      });
    if (!Bne.test(s))
      throw new ia({
        field: "nonce",
        metaMessages: [
          "- Nonce must be at least 8 characters.",
          "- Nonce must be alphanumeric.",
          "",
          `Provided value: ${s}`
        ]
      });
    if (!u5(d))
      throw new ia({
        field: "uri",
        metaMessages: [
          "- URI must be a RFC 3986 URI referring to the resource that is the subject of the signing.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${d}`
        ]
      });
    if (p !== "1")
      throw new ia({
        field: "version",
        metaMessages: [
          "- Version must be '1'.",
          "",
          `Provided value: ${p}`
        ]
      });
    if (l && !Une.test(l))
      throw new ia({
        field: "scheme",
        metaMessages: [
          "- Scheme must be an RFC 3986 URI scheme.",
          "- See https://www.rfc-editor.org/rfc/rfc3986#section-3.1",
          "",
          `Provided value: ${l}`
        ]
      });
    const F = t.statement;
    if (F != null && F.includes(`
`))
      throw new ia({
        field: "statement",
        metaMessages: [
          "- Statement must not include '\\n'.",
          "",
          `Provided value: ${F}`
        ]
      });
  }
  const w = k5(t.address), P = l ? `${l}://${r}` : r, A = t.statement ? `${t.statement}
` : "", N = `${P} wants you to sign in with your Ethereum account:
${w}

${A}`;
  let L = `URI: ${d}
Version: ${p}
Chain ID: ${e}
Nonce: ${s}
Issued At: ${i.toISOString()}`;
  if (n && (L += `
Expiration Time: ${n.toISOString()}`), o && (L += `
Not Before: ${o.toISOString()}`), a && (L += `
Request ID: ${a}`), u) {
    let F = `
Resources:`;
    for (const $ of u) {
      if (!u5($))
        throw new ia({
          field: "resources",
          metaMessages: [
            "- Every resource must be a RFC 3986 URI.",
            "- See https://www.rfc-editor.org/rfc/rfc3986",
            "",
            `Provided value: ${$}`
          ]
        });
      F += `
- ${$}`;
    }
    L += F;
  }
  return `${N}
${L}`;
}
const kne = /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}(:[0-9]{1,5})?$/, $ne = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(:[0-9]{1,5})?$/, Fne = /^localhost(:[0-9]{1,5})?$/, Bne = /^[a-zA-Z0-9]{8,}$/, Une = /^([a-zA-Z][a-zA-Z0-9+-.]*)$/, $9 = "7a4434fefbcc9af474fb5c995e47d286", jne = {
  projectId: $9,
  metadata: {
    name: "codatta",
    description: "codatta",
    url: "https://codatta.io/",
    icons: ["https://avatars.githubusercontent.com/u/171659315"]
  }
}, qne = {
  namespaces: {
    eip155: {
      methods: [
        "eth_sendTransaction",
        "eth_signTransaction",
        "eth_sign",
        "personal_sign",
        "eth_signTypedData"
      ],
      chains: ["eip155:1"],
      events: ["chainChanged", "accountsChanged", "disconnect"],
      rpcMap: {
        1: `https://rpc.walletconnect.com?chainId=eip155:1&projectId=${$9}`
      }
    }
  },
  skipPairing: !1
};
function zne(t, e) {
  const r = window.location.host, n = window.location.href;
  return k9({
    address: t,
    chainId: 1,
    domain: r,
    nonce: e,
    uri: n,
    version: "1"
  });
}
function Hne(t) {
  var pe, Ee, Y;
  const e = bi(null), { wallet: r, onGetExtension: n, onSignFinish: i } = t, [s, o] = fr(""), [a, u] = fr(!1), [l, d] = fr(""), [p, w] = fr("scan"), P = bi(), [A, N] = fr((pe = r.config) == null ? void 0 : pe.image), [L, F] = fr(!1), { saveLastUsedWallet: $ } = gp();
  async function K(S) {
    var f, g, b, x;
    u(!0);
    const m = await CG.init(jne);
    m.session && await m.disconnect();
    try {
      if (w("scan"), m.on("display_uri", (ce) => {
        console.log("display_uri", ce), o(ce), u(!1), w("scan");
      }), m.on("error", (ce) => {
        console.log(ce);
      }), m.on("session_update", (ce) => {
        console.log("session_update", ce);
      }), !await m.connect(qne)) throw new Error("Walletconnect init failed");
      const E = new ml(m);
      N(((f = E.config) == null ? void 0 : f.image) || ((g = S.config) == null ? void 0 : g.image));
      const v = await E.getAddress(), M = await ya.getNonce({ account_type: "block_chain" });
      console.log("get nonce", M);
      const I = zne(v, M);
      w("sign");
      const B = await E.signMessage(I, v);
      w("waiting"), await i(E, {
        message: I,
        nonce: M,
        signature: B,
        address: v,
        wallet_name: ((b = E.config) == null ? void 0 : b.name) || ((x = S.config) == null ? void 0 : x.name) || ""
      }), $(E);
    } catch (_) {
      console.log("err", _), d(_.details || _.message);
    }
  }
  function H() {
    P.current = new L9({
      width: 264,
      height: 264,
      margin: 0,
      type: "svg",
      // image: wallet.config?.image,
      qrOptions: {
        errorCorrectionLevel: "M"
      },
      dotsOptions: {
        color: "black",
        type: "rounded"
      },
      backgroundOptions: {
        color: "transparent"
      }
    }), P.current.append(e.current);
  }
  function V(S) {
    var m;
    console.log(P.current), (m = P.current) == null || m.update({
      data: S
    });
  }
  Xn(() => {
    s && V(s);
  }, [s]), Xn(() => {
    K(r);
  }, [r]), Xn(() => {
    H();
  }, []);
  function te() {
    d(""), V(""), K(r);
  }
  function R() {
    F(!0), navigator.clipboard.writeText(s), setTimeout(() => {
      F(!1);
    }, 2500);
  }
  function W() {
    var f;
    const S = (f = r.config) == null ? void 0 : f.desktop_link;
    if (!S) return;
    const m = `${S}?uri=${encodeURIComponent(s)}`;
    window.open(m, "_blank");
  }
  return /* @__PURE__ */ me.jsxs("div", { children: [
    /* @__PURE__ */ me.jsx("div", { className: "xc-text-center", children: /* @__PURE__ */ me.jsxs("div", { className: "xc-relative xc-mx-auto xc-mb-6 xc-block xc-max-h-[272px] xc-max-w-[272px] xc-rounded-xl xc-bg-white xc-p-1", children: [
      /* @__PURE__ */ me.jsx("div", { className: "xc-aspect-[1/1] xc-flex xc-h-full xc-w-full xc-justify-center", ref: e }),
      /* @__PURE__ */ me.jsx("div", { className: "xc-absolute xc-left-0 xc-top-0 xc-flex xc-h-full xc-w-full xc-items-center xc-justify-center", children: a ? /* @__PURE__ */ me.jsx(gc, { className: "xc-h-6 xc-w-6 xc-animate-spin xc-text-black", size: 20 }) : /* @__PURE__ */ me.jsx("img", { className: "xc-h-10 xc-w-10", src: A }) })
    ] }) }),
    /* @__PURE__ */ me.jsxs("div", { className: "xc-m-auto xc-mb-6 xc-flex xc-max-w-[400px] xc-flex-wrap xc-items-center xc-justify-between xc-gap-3", children: [
      /* @__PURE__ */ me.jsx(
        "button",
        {
          disabled: !s,
          onClick: R,
          className: "xc-disabled:hover-text-white xc-flex xc-min-w-[160px] xc-flex-1 xc-shrink-0 xc-items-center xc-justify-center xc-gap-2 xc-rounded-full xc-border xc-py-2 xc-text-sm xc-transition-all xc-hover:bg-white xc-hover:text-black xc-disabled:cursor-not-allowed xc-disabled:opacity-40 xc-disabled:hover:bg-transparent",
          children: L ? /* @__PURE__ */ me.jsxs(me.Fragment, { children: [
            " ",
            /* @__PURE__ */ me.jsx(rZ, {}),
            " Copied!"
          ] }) : /* @__PURE__ */ me.jsxs(me.Fragment, { children: [
            /* @__PURE__ */ me.jsx(sZ, {}),
            "Copy QR URL"
          ] })
        }
      ),
      ((Ee = r.config) == null ? void 0 : Ee.getWallet) && /* @__PURE__ */ me.jsxs(
        "button",
        {
          className: "xc-rounded-2 xc-flex xc-min-w-[160px] xc-flex-1 xc-shrink-0 xc-items-center xc-justify-center xc-gap-2 xc-rounded-full xc-border xc-py-2 xc-text-sm xc-transition-all xc-hover:bg-white xc-hover:text-black",
          onClick: n,
          children: [
            /* @__PURE__ */ me.jsx(nZ, {}),
            "Get Extension"
          ]
        }
      ),
      ((Y = r.config) == null ? void 0 : Y.desktop_link) && /* @__PURE__ */ me.jsxs(
        "button",
        {
          className: "xc-rounded-2 xc-flex xc-min-w-[160px] xc-flex-1 xc-shrink-0 xc-items-center xc-justify-center xc-gap-2 xc-rounded-full xc-border xc-py-2 xc-text-sm xc-transition-all xc-hover:bg-white xc-hover:text-black",
          onClick: W,
          children: [
            /* @__PURE__ */ me.jsx(HS, {}),
            "Desktop"
          ]
        }
      )
    ] }),
    /* @__PURE__ */ me.jsx("div", { className: "xc-text-center", children: l ? /* @__PURE__ */ me.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center", children: [
      /* @__PURE__ */ me.jsx("p", { className: "xc-text-danger xc-mb-2 xc-text-center", children: l }),
      /* @__PURE__ */ me.jsx("button", { className: "xc-rounded-full xc-bg-white xc-bg-opacity-10 xc-px-6 xc-py-1", onClick: te, children: "Retry" })
    ] }) : /* @__PURE__ */ me.jsxs(me.Fragment, { children: [
      p === "scan" && /* @__PURE__ */ me.jsx("p", { children: "Scan this QR code from your mobile wallet or phone's camera to connect." }),
      p === "connect" && /* @__PURE__ */ me.jsx("p", { children: "Click connect in your wallet app" }),
      p === "sign" && /* @__PURE__ */ me.jsx("p", { children: "Click sign-in in your wallet to confirm you own this wallet." }),
      p === "waiting" && /* @__PURE__ */ me.jsx("div", { className: "xc-text-center", children: /* @__PURE__ */ me.jsx(gc, { className: "xc-inline-block xc-animate-spin" }) })
    ] }) })
  ] });
}
const Wne = "Accept connection request in the wallet", Kne = "Accept sign-in request in your wallet";
function Vne(t, e) {
  const r = window.location.host, n = window.location.href;
  return k9({
    address: t,
    chainId: 1,
    domain: r,
    nonce: e,
    uri: n,
    version: "1"
  });
}
function Gne(t) {
  var p;
  const [e, r] = fr(), { wallet: n, onSignFinish: i } = t, s = bi(), [o, a] = fr("connect"), { saveLastUsedWallet: u } = gp();
  async function l(w) {
    var P;
    try {
      a("connect");
      const A = await n.connect();
      if (!A || A.length === 0)
        throw new Error("Wallet connect error");
      const N = Vne(A[0], w);
      a("sign");
      const L = await n.signMessage(N, A[0]);
      if (!L || L.length === 0)
        throw new Error("user sign error");
      a("waiting"), await i(n, { address: A[0], signature: L, message: N, nonce: w, wallet_name: ((P = n.config) == null ? void 0 : P.name) || "" }), u(n);
    } catch (A) {
      console.log(A.details), r(A.details || A.message);
    }
  }
  async function d() {
    try {
      r("");
      const w = await ya.getNonce({ account_type: "block_chain" });
      s.current = w, l(s.current);
    } catch (w) {
      console.log(w.details), r(w.message);
    }
  }
  return Xn(() => {
    d();
  }, []), /* @__PURE__ */ me.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center xc-justify-center xc-gap-4", children: [
    /* @__PURE__ */ me.jsx("img", { className: "xc-rounded-md xc-h-16 xc-w-16", src: (p = n.config) == null ? void 0 : p.image, alt: "" }),
    e && /* @__PURE__ */ me.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center", children: [
      /* @__PURE__ */ me.jsx("p", { className: "xc-text-danger xc-mb-2 xc-text-center", children: e }),
      /* @__PURE__ */ me.jsx("div", { className: "xc-flex xc-gap-2", children: /* @__PURE__ */ me.jsx("button", { className: "xc-rounded-full xc-bg-white xc-bg-opacity-10 xc-px-6 xc-py-1", onClick: d, children: "Retry" }) })
    ] }),
    !e && /* @__PURE__ */ me.jsxs(me.Fragment, { children: [
      o === "connect" && /* @__PURE__ */ me.jsx("span", { className: "xc-text-center", children: Wne }),
      o === "sign" && /* @__PURE__ */ me.jsx("span", { className: "xc-text-center", children: Kne }),
      o === "waiting" && /* @__PURE__ */ me.jsx("span", { className: "xc-text-center", children: /* @__PURE__ */ me.jsx(gc, { className: "xc-animate-spin" }) })
    ] })
  ] });
}
const Vc = "https://static.codatta.io/codatta-connect/wallet-icons.svg", Yne = "https://itunes.apple.com/app/", Jne = "https://play.google.com/store/apps/details?id=", Xne = "https://chromewebstore.google.com/detail/", Zne = "https://chromewebstore.google.com/detail/", Qne = "https://addons.mozilla.org/en-US/firefox/addon/", eie = "https://microsoftedge.microsoft.com/addons/detail/";
function Gc(t) {
  const { icon: e, title: r, link: n } = t;
  return /* @__PURE__ */ me.jsxs(
    "a",
    {
      href: n,
      target: "_blank",
      className: "xc-flex xc-w-full xc-cursor-pointer xc-items-center xc-gap-2 xc-rounded-full xc-border xc-border-white xc-border-opacity-15 xc-px-6 xc-py-3 xc-transition-all xc-hover:bg-white xc-hover:bg-opacity-5",
      children: [
        /* @__PURE__ */ me.jsx("img", { className: "xc-rounded-1 xc-h-6 xc-w-6", src: e, alt: "" }),
        r,
        /* @__PURE__ */ me.jsx(zS, { className: "xc-ml-auto xc-text-gray-400" })
      ]
    }
  );
}
function tie(t) {
  const e = {
    appStoreLink: "",
    playStoreLink: "",
    chromeStoreLink: "",
    braveStoreLink: "",
    firefoxStoreLink: "",
    edgeStoreLink: ""
  };
  return t != null && t.app_store_id && (e.appStoreLink = `${Yne}${t.app_store_id}`), t != null && t.play_store_id && (e.playStoreLink = `${Jne}${t.play_store_id}`), t != null && t.chrome_store_id && (e.chromeStoreLink = `${Xne}${t.chrome_store_id}`), t != null && t.brave_store_id && (e.braveStoreLink = `${Zne}${t.brave_store_id}`), t != null && t.firefox_addon_id && (e.firefoxStoreLink = `${Qne}${t.firefox_addon_id}`), t != null && t.edge_addon_id && (e.edgeStoreLink = `${eie}${t.edge_addon_id}`), e;
}
function rie(t) {
  var i, s, o;
  const { wallet: e } = t, r = (i = e.config) == null ? void 0 : i.getWallet, n = tie(r);
  return /* @__PURE__ */ me.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center", children: [
    /* @__PURE__ */ me.jsx("img", { className: "xc-rounded-md xc-mb-2 xc-h-12 xc-w-12", src: (s = e.config) == null ? void 0 : s.image, alt: "" }),
    /* @__PURE__ */ me.jsxs("p", { className: "xc-text-lg xc-font-bold", children: [
      "Install ",
      (o = e.config) == null ? void 0 : o.name,
      " to connect"
    ] }),
    /* @__PURE__ */ me.jsx("p", { className: "xc-mb-6 xc-text-sm xc-text-gray-500", children: "Select from your preferred options below:" }),
    /* @__PURE__ */ me.jsxs("div", { className: "xc-grid xc-w-full xc-grid-cols-1 xc-gap-3", children: [
      (r == null ? void 0 : r.chrome_store_id) && /* @__PURE__ */ me.jsx(
        Gc,
        {
          link: n.chromeStoreLink,
          icon: `${Vc}#chrome`,
          title: "Google Play Store"
        }
      ),
      (r == null ? void 0 : r.app_store_id) && /* @__PURE__ */ me.jsx(
        Gc,
        {
          link: n.appStoreLink,
          icon: `${Vc}#apple-dark`,
          title: "Apple App Store"
        }
      ),
      (r == null ? void 0 : r.play_store_id) && /* @__PURE__ */ me.jsx(
        Gc,
        {
          link: n.playStoreLink,
          icon: `${Vc}#android`,
          title: "Google Play Store"
        }
      ),
      (r == null ? void 0 : r.edge_addon_id) && /* @__PURE__ */ me.jsx(
        Gc,
        {
          link: n.edgeStoreLink,
          icon: `${Vc}#edge`,
          title: "Microsoft Edge"
        }
      ),
      (r == null ? void 0 : r.brave_store_id) && /* @__PURE__ */ me.jsx(
        Gc,
        {
          link: n.braveStoreLink,
          icon: `${Vc}#brave`,
          title: "Brave extension"
        }
      ),
      (r == null ? void 0 : r.firefox_addon_id) && /* @__PURE__ */ me.jsx(
        Gc,
        {
          link: n.firefoxStoreLink,
          icon: `${Vc}#firefox`,
          title: "Mozilla Firefox"
        }
      )
    ] })
  ] });
}
function nie(t) {
  const { wallet: e } = t, [r, n] = fr(e.installed ? "connect" : "qr"), i = ay();
  async function s(o, a) {
    var l;
    const u = await ya.walletLogin({
      account_type: "block_chain",
      account_enum: "C",
      connector: "codatta_wallet",
      inviter_code: i.inviterCode,
      wallet_name: ((l = o.config) == null ? void 0 : l.name) || o.key,
      address: await o.getAddress(),
      chain: (await o.getChain()).toString(),
      nonce: a.nonce,
      signature: a.signature,
      message: a.message,
      source: {
        device: i.device,
        channel: i.channel,
        app: i.app
      }
    });
    await t.onLogin(u.data);
  }
  return /* @__PURE__ */ me.jsxs(Ac, { children: [
    /* @__PURE__ */ me.jsx("div", { className: "xc-mb-6", children: /* @__PURE__ */ me.jsx(uh, { title: "Connect wallet", onBack: t.onBack }) }),
    r === "qr" && /* @__PURE__ */ me.jsx(
      Hne,
      {
        wallet: e,
        onGetExtension: () => n("get-extension"),
        onSignFinish: s
      }
    ),
    r === "connect" && /* @__PURE__ */ me.jsx(
      Gne,
      {
        onShowQrCode: () => n("qr"),
        wallet: e,
        onSignFinish: s
      }
    ),
    r === "get-extension" && /* @__PURE__ */ me.jsx(rie, { wallet: e })
  ] });
}
function iie(t) {
  const { wallet: e, onClick: r } = t, n = /* @__PURE__ */ me.jsx("img", { className: "xc-rounded-md xc-h-5 xc-w-5", src: e.imageUrl }), i = e.name || "";
  return /* @__PURE__ */ me.jsx(sy, { icon: n, title: i, onClick: () => r(e) });
}
function sie(t) {
  const { connector: e } = t, [r, n] = fr(), [i, s] = fr([]), o = Oi(() => r ? i.filter((d) => d.name.toLowerCase().includes(r.toLowerCase())) : i, [r, i]);
  function a(d) {
    n(d.target.value);
  }
  async function u() {
    const d = await e.getWallets();
    s(d), console.log(d);
  }
  Xn(() => {
    u();
  }, []);
  function l(d) {
    t.onSelect(d);
  }
  return /* @__PURE__ */ me.jsxs(Ac, { children: [
    /* @__PURE__ */ me.jsx("div", { className: "xc-mb-6", children: /* @__PURE__ */ me.jsx(uh, { title: "Select wallet", onBack: t.onBack }) }),
    /* @__PURE__ */ me.jsxs("div", { className: "xc-mb-6 xc-flex xc-gap-3 xc-px-4 xc-py-2 xc-border xc-rounded-xl xc-w-full xc-overflow-hidden xc-items-center xc-border-opacity-15 xc-border-white focus-within:xc-border-opacity-40", children: [
      /* @__PURE__ */ me.jsx(WS, { className: "xc-shrink-0 xc-opacity-50" }),
      /* @__PURE__ */ me.jsx("input", { type: "text", className: "xc-flex-1 xc-bg-transparent xc-appearance-none xc-outline-none", placeholder: "Search wallet", onInput: a })
    ] }),
    /* @__PURE__ */ me.jsx("div", { className: "xc-mb-4 xc-flex xc-h-[309px] xc-flex-col xc-gap-4 xc-overflow-scroll no-scrollbar", children: o == null ? void 0 : o.map((d) => /* @__PURE__ */ me.jsx(iie, { wallet: d, onClick: l }, d.name)) })
  ] });
}
var F9 = { exports: {} };
(function(t) {
  (function(e, r) {
    t.exports ? t.exports = r() : (e.nacl || (e.nacl = {}), e.nacl.util = r());
  })(gn, function() {
    var e = {};
    function r(n) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(n))
        throw new TypeError("invalid encoding");
    }
    return e.decodeUTF8 = function(n) {
      if (typeof n != "string") throw new TypeError("expected string");
      var i, s = unescape(encodeURIComponent(n)), o = new Uint8Array(s.length);
      for (i = 0; i < s.length; i++) o[i] = s.charCodeAt(i);
      return o;
    }, e.encodeUTF8 = function(n) {
      var i, s = [];
      for (i = 0; i < n.length; i++) s.push(String.fromCharCode(n[i]));
      return decodeURIComponent(escape(s.join("")));
    }, typeof atob > "u" ? typeof Buffer.from < "u" ? (e.encodeBase64 = function(n) {
      return Buffer.from(n).toString("base64");
    }, e.decodeBase64 = function(n) {
      return r(n), new Uint8Array(Array.prototype.slice.call(Buffer.from(n, "base64"), 0));
    }) : (e.encodeBase64 = function(n) {
      return new Buffer(n).toString("base64");
    }, e.decodeBase64 = function(n) {
      return r(n), new Uint8Array(Array.prototype.slice.call(new Buffer(n, "base64"), 0));
    }) : (e.encodeBase64 = function(n) {
      var i, s = [], o = n.length;
      for (i = 0; i < o; i++) s.push(String.fromCharCode(n[i]));
      return btoa(s.join(""));
    }, e.decodeBase64 = function(n) {
      r(n);
      var i, s = atob(n), o = new Uint8Array(s.length);
      for (i = 0; i < s.length; i++) o[i] = s.charCodeAt(i);
      return o;
    }), e;
  });
})(F9);
var oie = F9.exports;
const Rl = /* @__PURE__ */ ts(oie);
var B9 = { exports: {} };
(function(t) {
  (function(e) {
    var r = function(k) {
      var j, z = new Float64Array(16);
      if (k) for (j = 0; j < k.length; j++) z[j] = k[j];
      return z;
    }, n = function() {
      throw new Error("no PRNG");
    }, i = new Uint8Array(16), s = new Uint8Array(32);
    s[0] = 9;
    var o = r(), a = r([1]), u = r([56129, 1]), l = r([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), d = r([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), p = r([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), w = r([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), P = r([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function A(k, j, z, C) {
      k[j] = z >> 24 & 255, k[j + 1] = z >> 16 & 255, k[j + 2] = z >> 8 & 255, k[j + 3] = z & 255, k[j + 4] = C >> 24 & 255, k[j + 5] = C >> 16 & 255, k[j + 6] = C >> 8 & 255, k[j + 7] = C & 255;
    }
    function N(k, j, z, C, G) {
      var U, se = 0;
      for (U = 0; U < G; U++) se |= k[j + U] ^ z[C + U];
      return (1 & se - 1 >>> 8) - 1;
    }
    function L(k, j, z, C) {
      return N(k, j, z, C, 16);
    }
    function F(k, j, z, C) {
      return N(k, j, z, C, 32);
    }
    function $(k, j, z, C) {
      for (var G = C[0] & 255 | (C[1] & 255) << 8 | (C[2] & 255) << 16 | (C[3] & 255) << 24, U = z[0] & 255 | (z[1] & 255) << 8 | (z[2] & 255) << 16 | (z[3] & 255) << 24, se = z[4] & 255 | (z[5] & 255) << 8 | (z[6] & 255) << 16 | (z[7] & 255) << 24, he = z[8] & 255 | (z[9] & 255) << 8 | (z[10] & 255) << 16 | (z[11] & 255) << 24, xe = z[12] & 255 | (z[13] & 255) << 8 | (z[14] & 255) << 16 | (z[15] & 255) << 24, Te = C[4] & 255 | (C[5] & 255) << 8 | (C[6] & 255) << 16 | (C[7] & 255) << 24, Re = j[0] & 255 | (j[1] & 255) << 8 | (j[2] & 255) << 16 | (j[3] & 255) << 24, nt = j[4] & 255 | (j[5] & 255) << 8 | (j[6] & 255) << 16 | (j[7] & 255) << 24, Ue = j[8] & 255 | (j[9] & 255) << 8 | (j[10] & 255) << 16 | (j[11] & 255) << 24, pt = j[12] & 255 | (j[13] & 255) << 8 | (j[14] & 255) << 16 | (j[15] & 255) << 24, it = C[8] & 255 | (C[9] & 255) << 8 | (C[10] & 255) << 16 | (C[11] & 255) << 24, et = z[16] & 255 | (z[17] & 255) << 8 | (z[18] & 255) << 16 | (z[19] & 255) << 24, St = z[20] & 255 | (z[21] & 255) << 8 | (z[22] & 255) << 16 | (z[23] & 255) << 24, Tt = z[24] & 255 | (z[25] & 255) << 8 | (z[26] & 255) << 16 | (z[27] & 255) << 24, At = z[28] & 255 | (z[29] & 255) << 8 | (z[30] & 255) << 16 | (z[31] & 255) << 24, _t = C[12] & 255 | (C[13] & 255) << 8 | (C[14] & 255) << 16 | (C[15] & 255) << 24, ht = G, xt = U, st = se, bt = he, ut = xe, ot = Te, Se = Re, Ae = nt, Ve = Ue, Be = pt, je = it, Je = et, Lt = St, zt = Tt, Xt = At, Ht = _t, le, tr = 0; tr < 20; tr += 2)
        le = ht + Lt | 0, ut ^= le << 7 | le >>> 25, le = ut + ht | 0, Ve ^= le << 9 | le >>> 23, le = Ve + ut | 0, Lt ^= le << 13 | le >>> 19, le = Lt + Ve | 0, ht ^= le << 18 | le >>> 14, le = ot + xt | 0, Be ^= le << 7 | le >>> 25, le = Be + ot | 0, zt ^= le << 9 | le >>> 23, le = zt + Be | 0, xt ^= le << 13 | le >>> 19, le = xt + zt | 0, ot ^= le << 18 | le >>> 14, le = je + Se | 0, Xt ^= le << 7 | le >>> 25, le = Xt + je | 0, st ^= le << 9 | le >>> 23, le = st + Xt | 0, Se ^= le << 13 | le >>> 19, le = Se + st | 0, je ^= le << 18 | le >>> 14, le = Ht + Je | 0, bt ^= le << 7 | le >>> 25, le = bt + Ht | 0, Ae ^= le << 9 | le >>> 23, le = Ae + bt | 0, Je ^= le << 13 | le >>> 19, le = Je + Ae | 0, Ht ^= le << 18 | le >>> 14, le = ht + bt | 0, xt ^= le << 7 | le >>> 25, le = xt + ht | 0, st ^= le << 9 | le >>> 23, le = st + xt | 0, bt ^= le << 13 | le >>> 19, le = bt + st | 0, ht ^= le << 18 | le >>> 14, le = ot + ut | 0, Se ^= le << 7 | le >>> 25, le = Se + ot | 0, Ae ^= le << 9 | le >>> 23, le = Ae + Se | 0, ut ^= le << 13 | le >>> 19, le = ut + Ae | 0, ot ^= le << 18 | le >>> 14, le = je + Be | 0, Je ^= le << 7 | le >>> 25, le = Je + je | 0, Ve ^= le << 9 | le >>> 23, le = Ve + Je | 0, Be ^= le << 13 | le >>> 19, le = Be + Ve | 0, je ^= le << 18 | le >>> 14, le = Ht + Xt | 0, Lt ^= le << 7 | le >>> 25, le = Lt + Ht | 0, zt ^= le << 9 | le >>> 23, le = zt + Lt | 0, Xt ^= le << 13 | le >>> 19, le = Xt + zt | 0, Ht ^= le << 18 | le >>> 14;
      ht = ht + G | 0, xt = xt + U | 0, st = st + se | 0, bt = bt + he | 0, ut = ut + xe | 0, ot = ot + Te | 0, Se = Se + Re | 0, Ae = Ae + nt | 0, Ve = Ve + Ue | 0, Be = Be + pt | 0, je = je + it | 0, Je = Je + et | 0, Lt = Lt + St | 0, zt = zt + Tt | 0, Xt = Xt + At | 0, Ht = Ht + _t | 0, k[0] = ht >>> 0 & 255, k[1] = ht >>> 8 & 255, k[2] = ht >>> 16 & 255, k[3] = ht >>> 24 & 255, k[4] = xt >>> 0 & 255, k[5] = xt >>> 8 & 255, k[6] = xt >>> 16 & 255, k[7] = xt >>> 24 & 255, k[8] = st >>> 0 & 255, k[9] = st >>> 8 & 255, k[10] = st >>> 16 & 255, k[11] = st >>> 24 & 255, k[12] = bt >>> 0 & 255, k[13] = bt >>> 8 & 255, k[14] = bt >>> 16 & 255, k[15] = bt >>> 24 & 255, k[16] = ut >>> 0 & 255, k[17] = ut >>> 8 & 255, k[18] = ut >>> 16 & 255, k[19] = ut >>> 24 & 255, k[20] = ot >>> 0 & 255, k[21] = ot >>> 8 & 255, k[22] = ot >>> 16 & 255, k[23] = ot >>> 24 & 255, k[24] = Se >>> 0 & 255, k[25] = Se >>> 8 & 255, k[26] = Se >>> 16 & 255, k[27] = Se >>> 24 & 255, k[28] = Ae >>> 0 & 255, k[29] = Ae >>> 8 & 255, k[30] = Ae >>> 16 & 255, k[31] = Ae >>> 24 & 255, k[32] = Ve >>> 0 & 255, k[33] = Ve >>> 8 & 255, k[34] = Ve >>> 16 & 255, k[35] = Ve >>> 24 & 255, k[36] = Be >>> 0 & 255, k[37] = Be >>> 8 & 255, k[38] = Be >>> 16 & 255, k[39] = Be >>> 24 & 255, k[40] = je >>> 0 & 255, k[41] = je >>> 8 & 255, k[42] = je >>> 16 & 255, k[43] = je >>> 24 & 255, k[44] = Je >>> 0 & 255, k[45] = Je >>> 8 & 255, k[46] = Je >>> 16 & 255, k[47] = Je >>> 24 & 255, k[48] = Lt >>> 0 & 255, k[49] = Lt >>> 8 & 255, k[50] = Lt >>> 16 & 255, k[51] = Lt >>> 24 & 255, k[52] = zt >>> 0 & 255, k[53] = zt >>> 8 & 255, k[54] = zt >>> 16 & 255, k[55] = zt >>> 24 & 255, k[56] = Xt >>> 0 & 255, k[57] = Xt >>> 8 & 255, k[58] = Xt >>> 16 & 255, k[59] = Xt >>> 24 & 255, k[60] = Ht >>> 0 & 255, k[61] = Ht >>> 8 & 255, k[62] = Ht >>> 16 & 255, k[63] = Ht >>> 24 & 255;
    }
    function K(k, j, z, C) {
      for (var G = C[0] & 255 | (C[1] & 255) << 8 | (C[2] & 255) << 16 | (C[3] & 255) << 24, U = z[0] & 255 | (z[1] & 255) << 8 | (z[2] & 255) << 16 | (z[3] & 255) << 24, se = z[4] & 255 | (z[5] & 255) << 8 | (z[6] & 255) << 16 | (z[7] & 255) << 24, he = z[8] & 255 | (z[9] & 255) << 8 | (z[10] & 255) << 16 | (z[11] & 255) << 24, xe = z[12] & 255 | (z[13] & 255) << 8 | (z[14] & 255) << 16 | (z[15] & 255) << 24, Te = C[4] & 255 | (C[5] & 255) << 8 | (C[6] & 255) << 16 | (C[7] & 255) << 24, Re = j[0] & 255 | (j[1] & 255) << 8 | (j[2] & 255) << 16 | (j[3] & 255) << 24, nt = j[4] & 255 | (j[5] & 255) << 8 | (j[6] & 255) << 16 | (j[7] & 255) << 24, Ue = j[8] & 255 | (j[9] & 255) << 8 | (j[10] & 255) << 16 | (j[11] & 255) << 24, pt = j[12] & 255 | (j[13] & 255) << 8 | (j[14] & 255) << 16 | (j[15] & 255) << 24, it = C[8] & 255 | (C[9] & 255) << 8 | (C[10] & 255) << 16 | (C[11] & 255) << 24, et = z[16] & 255 | (z[17] & 255) << 8 | (z[18] & 255) << 16 | (z[19] & 255) << 24, St = z[20] & 255 | (z[21] & 255) << 8 | (z[22] & 255) << 16 | (z[23] & 255) << 24, Tt = z[24] & 255 | (z[25] & 255) << 8 | (z[26] & 255) << 16 | (z[27] & 255) << 24, At = z[28] & 255 | (z[29] & 255) << 8 | (z[30] & 255) << 16 | (z[31] & 255) << 24, _t = C[12] & 255 | (C[13] & 255) << 8 | (C[14] & 255) << 16 | (C[15] & 255) << 24, ht = G, xt = U, st = se, bt = he, ut = xe, ot = Te, Se = Re, Ae = nt, Ve = Ue, Be = pt, je = it, Je = et, Lt = St, zt = Tt, Xt = At, Ht = _t, le, tr = 0; tr < 20; tr += 2)
        le = ht + Lt | 0, ut ^= le << 7 | le >>> 25, le = ut + ht | 0, Ve ^= le << 9 | le >>> 23, le = Ve + ut | 0, Lt ^= le << 13 | le >>> 19, le = Lt + Ve | 0, ht ^= le << 18 | le >>> 14, le = ot + xt | 0, Be ^= le << 7 | le >>> 25, le = Be + ot | 0, zt ^= le << 9 | le >>> 23, le = zt + Be | 0, xt ^= le << 13 | le >>> 19, le = xt + zt | 0, ot ^= le << 18 | le >>> 14, le = je + Se | 0, Xt ^= le << 7 | le >>> 25, le = Xt + je | 0, st ^= le << 9 | le >>> 23, le = st + Xt | 0, Se ^= le << 13 | le >>> 19, le = Se + st | 0, je ^= le << 18 | le >>> 14, le = Ht + Je | 0, bt ^= le << 7 | le >>> 25, le = bt + Ht | 0, Ae ^= le << 9 | le >>> 23, le = Ae + bt | 0, Je ^= le << 13 | le >>> 19, le = Je + Ae | 0, Ht ^= le << 18 | le >>> 14, le = ht + bt | 0, xt ^= le << 7 | le >>> 25, le = xt + ht | 0, st ^= le << 9 | le >>> 23, le = st + xt | 0, bt ^= le << 13 | le >>> 19, le = bt + st | 0, ht ^= le << 18 | le >>> 14, le = ot + ut | 0, Se ^= le << 7 | le >>> 25, le = Se + ot | 0, Ae ^= le << 9 | le >>> 23, le = Ae + Se | 0, ut ^= le << 13 | le >>> 19, le = ut + Ae | 0, ot ^= le << 18 | le >>> 14, le = je + Be | 0, Je ^= le << 7 | le >>> 25, le = Je + je | 0, Ve ^= le << 9 | le >>> 23, le = Ve + Je | 0, Be ^= le << 13 | le >>> 19, le = Be + Ve | 0, je ^= le << 18 | le >>> 14, le = Ht + Xt | 0, Lt ^= le << 7 | le >>> 25, le = Lt + Ht | 0, zt ^= le << 9 | le >>> 23, le = zt + Lt | 0, Xt ^= le << 13 | le >>> 19, le = Xt + zt | 0, Ht ^= le << 18 | le >>> 14;
      k[0] = ht >>> 0 & 255, k[1] = ht >>> 8 & 255, k[2] = ht >>> 16 & 255, k[3] = ht >>> 24 & 255, k[4] = ot >>> 0 & 255, k[5] = ot >>> 8 & 255, k[6] = ot >>> 16 & 255, k[7] = ot >>> 24 & 255, k[8] = je >>> 0 & 255, k[9] = je >>> 8 & 255, k[10] = je >>> 16 & 255, k[11] = je >>> 24 & 255, k[12] = Ht >>> 0 & 255, k[13] = Ht >>> 8 & 255, k[14] = Ht >>> 16 & 255, k[15] = Ht >>> 24 & 255, k[16] = Se >>> 0 & 255, k[17] = Se >>> 8 & 255, k[18] = Se >>> 16 & 255, k[19] = Se >>> 24 & 255, k[20] = Ae >>> 0 & 255, k[21] = Ae >>> 8 & 255, k[22] = Ae >>> 16 & 255, k[23] = Ae >>> 24 & 255, k[24] = Ve >>> 0 & 255, k[25] = Ve >>> 8 & 255, k[26] = Ve >>> 16 & 255, k[27] = Ve >>> 24 & 255, k[28] = Be >>> 0 & 255, k[29] = Be >>> 8 & 255, k[30] = Be >>> 16 & 255, k[31] = Be >>> 24 & 255;
    }
    function H(k, j, z, C) {
      $(k, j, z, C);
    }
    function V(k, j, z, C) {
      K(k, j, z, C);
    }
    var te = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function R(k, j, z, C, G, U, se) {
      var he = new Uint8Array(16), xe = new Uint8Array(64), Te, Re;
      for (Re = 0; Re < 16; Re++) he[Re] = 0;
      for (Re = 0; Re < 8; Re++) he[Re] = U[Re];
      for (; G >= 64; ) {
        for (H(xe, he, se, te), Re = 0; Re < 64; Re++) k[j + Re] = z[C + Re] ^ xe[Re];
        for (Te = 1, Re = 8; Re < 16; Re++)
          Te = Te + (he[Re] & 255) | 0, he[Re] = Te & 255, Te >>>= 8;
        G -= 64, j += 64, C += 64;
      }
      if (G > 0)
        for (H(xe, he, se, te), Re = 0; Re < G; Re++) k[j + Re] = z[C + Re] ^ xe[Re];
      return 0;
    }
    function W(k, j, z, C, G) {
      var U = new Uint8Array(16), se = new Uint8Array(64), he, xe;
      for (xe = 0; xe < 16; xe++) U[xe] = 0;
      for (xe = 0; xe < 8; xe++) U[xe] = C[xe];
      for (; z >= 64; ) {
        for (H(se, U, G, te), xe = 0; xe < 64; xe++) k[j + xe] = se[xe];
        for (he = 1, xe = 8; xe < 16; xe++)
          he = he + (U[xe] & 255) | 0, U[xe] = he & 255, he >>>= 8;
        z -= 64, j += 64;
      }
      if (z > 0)
        for (H(se, U, G, te), xe = 0; xe < z; xe++) k[j + xe] = se[xe];
      return 0;
    }
    function pe(k, j, z, C, G) {
      var U = new Uint8Array(32);
      V(U, C, G, te);
      for (var se = new Uint8Array(8), he = 0; he < 8; he++) se[he] = C[he + 16];
      return W(k, j, z, se, U);
    }
    function Ee(k, j, z, C, G, U, se) {
      var he = new Uint8Array(32);
      V(he, U, se, te);
      for (var xe = new Uint8Array(8), Te = 0; Te < 8; Te++) xe[Te] = U[Te + 16];
      return R(k, j, z, C, G, xe, he);
    }
    var Y = function(k) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var j, z, C, G, U, se, he, xe;
      j = k[0] & 255 | (k[1] & 255) << 8, this.r[0] = j & 8191, z = k[2] & 255 | (k[3] & 255) << 8, this.r[1] = (j >>> 13 | z << 3) & 8191, C = k[4] & 255 | (k[5] & 255) << 8, this.r[2] = (z >>> 10 | C << 6) & 7939, G = k[6] & 255 | (k[7] & 255) << 8, this.r[3] = (C >>> 7 | G << 9) & 8191, U = k[8] & 255 | (k[9] & 255) << 8, this.r[4] = (G >>> 4 | U << 12) & 255, this.r[5] = U >>> 1 & 8190, se = k[10] & 255 | (k[11] & 255) << 8, this.r[6] = (U >>> 14 | se << 2) & 8191, he = k[12] & 255 | (k[13] & 255) << 8, this.r[7] = (se >>> 11 | he << 5) & 8065, xe = k[14] & 255 | (k[15] & 255) << 8, this.r[8] = (he >>> 8 | xe << 8) & 8191, this.r[9] = xe >>> 5 & 127, this.pad[0] = k[16] & 255 | (k[17] & 255) << 8, this.pad[1] = k[18] & 255 | (k[19] & 255) << 8, this.pad[2] = k[20] & 255 | (k[21] & 255) << 8, this.pad[3] = k[22] & 255 | (k[23] & 255) << 8, this.pad[4] = k[24] & 255 | (k[25] & 255) << 8, this.pad[5] = k[26] & 255 | (k[27] & 255) << 8, this.pad[6] = k[28] & 255 | (k[29] & 255) << 8, this.pad[7] = k[30] & 255 | (k[31] & 255) << 8;
    };
    Y.prototype.blocks = function(k, j, z) {
      for (var C = this.fin ? 0 : 2048, G, U, se, he, xe, Te, Re, nt, Ue, pt, it, et, St, Tt, At, _t, ht, xt, st, bt = this.h[0], ut = this.h[1], ot = this.h[2], Se = this.h[3], Ae = this.h[4], Ve = this.h[5], Be = this.h[6], je = this.h[7], Je = this.h[8], Lt = this.h[9], zt = this.r[0], Xt = this.r[1], Ht = this.r[2], le = this.r[3], tr = this.r[4], dr = this.r[5], pr = this.r[6], Zt = this.r[7], gr = this.r[8], lr = this.r[9]; z >= 16; )
        G = k[j + 0] & 255 | (k[j + 1] & 255) << 8, bt += G & 8191, U = k[j + 2] & 255 | (k[j + 3] & 255) << 8, ut += (G >>> 13 | U << 3) & 8191, se = k[j + 4] & 255 | (k[j + 5] & 255) << 8, ot += (U >>> 10 | se << 6) & 8191, he = k[j + 6] & 255 | (k[j + 7] & 255) << 8, Se += (se >>> 7 | he << 9) & 8191, xe = k[j + 8] & 255 | (k[j + 9] & 255) << 8, Ae += (he >>> 4 | xe << 12) & 8191, Ve += xe >>> 1 & 8191, Te = k[j + 10] & 255 | (k[j + 11] & 255) << 8, Be += (xe >>> 14 | Te << 2) & 8191, Re = k[j + 12] & 255 | (k[j + 13] & 255) << 8, je += (Te >>> 11 | Re << 5) & 8191, nt = k[j + 14] & 255 | (k[j + 15] & 255) << 8, Je += (Re >>> 8 | nt << 8) & 8191, Lt += nt >>> 5 | C, Ue = 0, pt = Ue, pt += bt * zt, pt += ut * (5 * lr), pt += ot * (5 * gr), pt += Se * (5 * Zt), pt += Ae * (5 * pr), Ue = pt >>> 13, pt &= 8191, pt += Ve * (5 * dr), pt += Be * (5 * tr), pt += je * (5 * le), pt += Je * (5 * Ht), pt += Lt * (5 * Xt), Ue += pt >>> 13, pt &= 8191, it = Ue, it += bt * Xt, it += ut * zt, it += ot * (5 * lr), it += Se * (5 * gr), it += Ae * (5 * Zt), Ue = it >>> 13, it &= 8191, it += Ve * (5 * pr), it += Be * (5 * dr), it += je * (5 * tr), it += Je * (5 * le), it += Lt * (5 * Ht), Ue += it >>> 13, it &= 8191, et = Ue, et += bt * Ht, et += ut * Xt, et += ot * zt, et += Se * (5 * lr), et += Ae * (5 * gr), Ue = et >>> 13, et &= 8191, et += Ve * (5 * Zt), et += Be * (5 * pr), et += je * (5 * dr), et += Je * (5 * tr), et += Lt * (5 * le), Ue += et >>> 13, et &= 8191, St = Ue, St += bt * le, St += ut * Ht, St += ot * Xt, St += Se * zt, St += Ae * (5 * lr), Ue = St >>> 13, St &= 8191, St += Ve * (5 * gr), St += Be * (5 * Zt), St += je * (5 * pr), St += Je * (5 * dr), St += Lt * (5 * tr), Ue += St >>> 13, St &= 8191, Tt = Ue, Tt += bt * tr, Tt += ut * le, Tt += ot * Ht, Tt += Se * Xt, Tt += Ae * zt, Ue = Tt >>> 13, Tt &= 8191, Tt += Ve * (5 * lr), Tt += Be * (5 * gr), Tt += je * (5 * Zt), Tt += Je * (5 * pr), Tt += Lt * (5 * dr), Ue += Tt >>> 13, Tt &= 8191, At = Ue, At += bt * dr, At += ut * tr, At += ot * le, At += Se * Ht, At += Ae * Xt, Ue = At >>> 13, At &= 8191, At += Ve * zt, At += Be * (5 * lr), At += je * (5 * gr), At += Je * (5 * Zt), At += Lt * (5 * pr), Ue += At >>> 13, At &= 8191, _t = Ue, _t += bt * pr, _t += ut * dr, _t += ot * tr, _t += Se * le, _t += Ae * Ht, Ue = _t >>> 13, _t &= 8191, _t += Ve * Xt, _t += Be * zt, _t += je * (5 * lr), _t += Je * (5 * gr), _t += Lt * (5 * Zt), Ue += _t >>> 13, _t &= 8191, ht = Ue, ht += bt * Zt, ht += ut * pr, ht += ot * dr, ht += Se * tr, ht += Ae * le, Ue = ht >>> 13, ht &= 8191, ht += Ve * Ht, ht += Be * Xt, ht += je * zt, ht += Je * (5 * lr), ht += Lt * (5 * gr), Ue += ht >>> 13, ht &= 8191, xt = Ue, xt += bt * gr, xt += ut * Zt, xt += ot * pr, xt += Se * dr, xt += Ae * tr, Ue = xt >>> 13, xt &= 8191, xt += Ve * le, xt += Be * Ht, xt += je * Xt, xt += Je * zt, xt += Lt * (5 * lr), Ue += xt >>> 13, xt &= 8191, st = Ue, st += bt * lr, st += ut * gr, st += ot * Zt, st += Se * pr, st += Ae * dr, Ue = st >>> 13, st &= 8191, st += Ve * tr, st += Be * le, st += je * Ht, st += Je * Xt, st += Lt * zt, Ue += st >>> 13, st &= 8191, Ue = (Ue << 2) + Ue | 0, Ue = Ue + pt | 0, pt = Ue & 8191, Ue = Ue >>> 13, it += Ue, bt = pt, ut = it, ot = et, Se = St, Ae = Tt, Ve = At, Be = _t, je = ht, Je = xt, Lt = st, j += 16, z -= 16;
      this.h[0] = bt, this.h[1] = ut, this.h[2] = ot, this.h[3] = Se, this.h[4] = Ae, this.h[5] = Ve, this.h[6] = Be, this.h[7] = je, this.h[8] = Je, this.h[9] = Lt;
    }, Y.prototype.finish = function(k, j) {
      var z = new Uint16Array(10), C, G, U, se;
      if (this.leftover) {
        for (se = this.leftover, this.buffer[se++] = 1; se < 16; se++) this.buffer[se] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (C = this.h[1] >>> 13, this.h[1] &= 8191, se = 2; se < 10; se++)
        this.h[se] += C, C = this.h[se] >>> 13, this.h[se] &= 8191;
      for (this.h[0] += C * 5, C = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += C, C = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += C, z[0] = this.h[0] + 5, C = z[0] >>> 13, z[0] &= 8191, se = 1; se < 10; se++)
        z[se] = this.h[se] + C, C = z[se] >>> 13, z[se] &= 8191;
      for (z[9] -= 8192, G = (C ^ 1) - 1, se = 0; se < 10; se++) z[se] &= G;
      for (G = ~G, se = 0; se < 10; se++) this.h[se] = this.h[se] & G | z[se];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, U = this.h[0] + this.pad[0], this.h[0] = U & 65535, se = 1; se < 8; se++)
        U = (this.h[se] + this.pad[se] | 0) + (U >>> 16) | 0, this.h[se] = U & 65535;
      k[j + 0] = this.h[0] >>> 0 & 255, k[j + 1] = this.h[0] >>> 8 & 255, k[j + 2] = this.h[1] >>> 0 & 255, k[j + 3] = this.h[1] >>> 8 & 255, k[j + 4] = this.h[2] >>> 0 & 255, k[j + 5] = this.h[2] >>> 8 & 255, k[j + 6] = this.h[3] >>> 0 & 255, k[j + 7] = this.h[3] >>> 8 & 255, k[j + 8] = this.h[4] >>> 0 & 255, k[j + 9] = this.h[4] >>> 8 & 255, k[j + 10] = this.h[5] >>> 0 & 255, k[j + 11] = this.h[5] >>> 8 & 255, k[j + 12] = this.h[6] >>> 0 & 255, k[j + 13] = this.h[6] >>> 8 & 255, k[j + 14] = this.h[7] >>> 0 & 255, k[j + 15] = this.h[7] >>> 8 & 255;
    }, Y.prototype.update = function(k, j, z) {
      var C, G;
      if (this.leftover) {
        for (G = 16 - this.leftover, G > z && (G = z), C = 0; C < G; C++)
          this.buffer[this.leftover + C] = k[j + C];
        if (z -= G, j += G, this.leftover += G, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (z >= 16 && (G = z - z % 16, this.blocks(k, j, G), j += G, z -= G), z) {
        for (C = 0; C < z; C++)
          this.buffer[this.leftover + C] = k[j + C];
        this.leftover += z;
      }
    };
    function S(k, j, z, C, G, U) {
      var se = new Y(U);
      return se.update(z, C, G), se.finish(k, j), 0;
    }
    function m(k, j, z, C, G, U) {
      var se = new Uint8Array(16);
      return S(se, 0, z, C, G, U), L(k, j, se, 0);
    }
    function f(k, j, z, C, G) {
      var U;
      if (z < 32) return -1;
      for (Ee(k, 0, j, 0, z, C, G), S(k, 16, k, 32, z - 32, k), U = 0; U < 16; U++) k[U] = 0;
      return 0;
    }
    function g(k, j, z, C, G) {
      var U, se = new Uint8Array(32);
      if (z < 32 || (pe(se, 0, 32, C, G), m(j, 16, j, 32, z - 32, se) !== 0)) return -1;
      for (Ee(k, 0, j, 0, z, C, G), U = 0; U < 32; U++) k[U] = 0;
      return 0;
    }
    function b(k, j) {
      var z;
      for (z = 0; z < 16; z++) k[z] = j[z] | 0;
    }
    function x(k) {
      var j, z, C = 1;
      for (j = 0; j < 16; j++)
        z = k[j] + C + 65535, C = Math.floor(z / 65536), k[j] = z - C * 65536;
      k[0] += C - 1 + 37 * (C - 1);
    }
    function _(k, j, z) {
      for (var C, G = ~(z - 1), U = 0; U < 16; U++)
        C = G & (k[U] ^ j[U]), k[U] ^= C, j[U] ^= C;
    }
    function E(k, j) {
      var z, C, G, U = r(), se = r();
      for (z = 0; z < 16; z++) se[z] = j[z];
      for (x(se), x(se), x(se), C = 0; C < 2; C++) {
        for (U[0] = se[0] - 65517, z = 1; z < 15; z++)
          U[z] = se[z] - 65535 - (U[z - 1] >> 16 & 1), U[z - 1] &= 65535;
        U[15] = se[15] - 32767 - (U[14] >> 16 & 1), G = U[15] >> 16 & 1, U[14] &= 65535, _(se, U, 1 - G);
      }
      for (z = 0; z < 16; z++)
        k[2 * z] = se[z] & 255, k[2 * z + 1] = se[z] >> 8;
    }
    function v(k, j) {
      var z = new Uint8Array(32), C = new Uint8Array(32);
      return E(z, k), E(C, j), F(z, 0, C, 0);
    }
    function M(k) {
      var j = new Uint8Array(32);
      return E(j, k), j[0] & 1;
    }
    function I(k, j) {
      var z;
      for (z = 0; z < 16; z++) k[z] = j[2 * z] + (j[2 * z + 1] << 8);
      k[15] &= 32767;
    }
    function B(k, j, z) {
      for (var C = 0; C < 16; C++) k[C] = j[C] + z[C];
    }
    function ce(k, j, z) {
      for (var C = 0; C < 16; C++) k[C] = j[C] - z[C];
    }
    function D(k, j, z) {
      var C, G, U = 0, se = 0, he = 0, xe = 0, Te = 0, Re = 0, nt = 0, Ue = 0, pt = 0, it = 0, et = 0, St = 0, Tt = 0, At = 0, _t = 0, ht = 0, xt = 0, st = 0, bt = 0, ut = 0, ot = 0, Se = 0, Ae = 0, Ve = 0, Be = 0, je = 0, Je = 0, Lt = 0, zt = 0, Xt = 0, Ht = 0, le = z[0], tr = z[1], dr = z[2], pr = z[3], Zt = z[4], gr = z[5], lr = z[6], Rr = z[7], mr = z[8], yr = z[9], $r = z[10], Fr = z[11], Ir = z[12], nn = z[13], sn = z[14], on = z[15];
      C = j[0], U += C * le, se += C * tr, he += C * dr, xe += C * pr, Te += C * Zt, Re += C * gr, nt += C * lr, Ue += C * Rr, pt += C * mr, it += C * yr, et += C * $r, St += C * Fr, Tt += C * Ir, At += C * nn, _t += C * sn, ht += C * on, C = j[1], se += C * le, he += C * tr, xe += C * dr, Te += C * pr, Re += C * Zt, nt += C * gr, Ue += C * lr, pt += C * Rr, it += C * mr, et += C * yr, St += C * $r, Tt += C * Fr, At += C * Ir, _t += C * nn, ht += C * sn, xt += C * on, C = j[2], he += C * le, xe += C * tr, Te += C * dr, Re += C * pr, nt += C * Zt, Ue += C * gr, pt += C * lr, it += C * Rr, et += C * mr, St += C * yr, Tt += C * $r, At += C * Fr, _t += C * Ir, ht += C * nn, xt += C * sn, st += C * on, C = j[3], xe += C * le, Te += C * tr, Re += C * dr, nt += C * pr, Ue += C * Zt, pt += C * gr, it += C * lr, et += C * Rr, St += C * mr, Tt += C * yr, At += C * $r, _t += C * Fr, ht += C * Ir, xt += C * nn, st += C * sn, bt += C * on, C = j[4], Te += C * le, Re += C * tr, nt += C * dr, Ue += C * pr, pt += C * Zt, it += C * gr, et += C * lr, St += C * Rr, Tt += C * mr, At += C * yr, _t += C * $r, ht += C * Fr, xt += C * Ir, st += C * nn, bt += C * sn, ut += C * on, C = j[5], Re += C * le, nt += C * tr, Ue += C * dr, pt += C * pr, it += C * Zt, et += C * gr, St += C * lr, Tt += C * Rr, At += C * mr, _t += C * yr, ht += C * $r, xt += C * Fr, st += C * Ir, bt += C * nn, ut += C * sn, ot += C * on, C = j[6], nt += C * le, Ue += C * tr, pt += C * dr, it += C * pr, et += C * Zt, St += C * gr, Tt += C * lr, At += C * Rr, _t += C * mr, ht += C * yr, xt += C * $r, st += C * Fr, bt += C * Ir, ut += C * nn, ot += C * sn, Se += C * on, C = j[7], Ue += C * le, pt += C * tr, it += C * dr, et += C * pr, St += C * Zt, Tt += C * gr, At += C * lr, _t += C * Rr, ht += C * mr, xt += C * yr, st += C * $r, bt += C * Fr, ut += C * Ir, ot += C * nn, Se += C * sn, Ae += C * on, C = j[8], pt += C * le, it += C * tr, et += C * dr, St += C * pr, Tt += C * Zt, At += C * gr, _t += C * lr, ht += C * Rr, xt += C * mr, st += C * yr, bt += C * $r, ut += C * Fr, ot += C * Ir, Se += C * nn, Ae += C * sn, Ve += C * on, C = j[9], it += C * le, et += C * tr, St += C * dr, Tt += C * pr, At += C * Zt, _t += C * gr, ht += C * lr, xt += C * Rr, st += C * mr, bt += C * yr, ut += C * $r, ot += C * Fr, Se += C * Ir, Ae += C * nn, Ve += C * sn, Be += C * on, C = j[10], et += C * le, St += C * tr, Tt += C * dr, At += C * pr, _t += C * Zt, ht += C * gr, xt += C * lr, st += C * Rr, bt += C * mr, ut += C * yr, ot += C * $r, Se += C * Fr, Ae += C * Ir, Ve += C * nn, Be += C * sn, je += C * on, C = j[11], St += C * le, Tt += C * tr, At += C * dr, _t += C * pr, ht += C * Zt, xt += C * gr, st += C * lr, bt += C * Rr, ut += C * mr, ot += C * yr, Se += C * $r, Ae += C * Fr, Ve += C * Ir, Be += C * nn, je += C * sn, Je += C * on, C = j[12], Tt += C * le, At += C * tr, _t += C * dr, ht += C * pr, xt += C * Zt, st += C * gr, bt += C * lr, ut += C * Rr, ot += C * mr, Se += C * yr, Ae += C * $r, Ve += C * Fr, Be += C * Ir, je += C * nn, Je += C * sn, Lt += C * on, C = j[13], At += C * le, _t += C * tr, ht += C * dr, xt += C * pr, st += C * Zt, bt += C * gr, ut += C * lr, ot += C * Rr, Se += C * mr, Ae += C * yr, Ve += C * $r, Be += C * Fr, je += C * Ir, Je += C * nn, Lt += C * sn, zt += C * on, C = j[14], _t += C * le, ht += C * tr, xt += C * dr, st += C * pr, bt += C * Zt, ut += C * gr, ot += C * lr, Se += C * Rr, Ae += C * mr, Ve += C * yr, Be += C * $r, je += C * Fr, Je += C * Ir, Lt += C * nn, zt += C * sn, Xt += C * on, C = j[15], ht += C * le, xt += C * tr, st += C * dr, bt += C * pr, ut += C * Zt, ot += C * gr, Se += C * lr, Ae += C * Rr, Ve += C * mr, Be += C * yr, je += C * $r, Je += C * Fr, Lt += C * Ir, zt += C * nn, Xt += C * sn, Ht += C * on, U += 38 * xt, se += 38 * st, he += 38 * bt, xe += 38 * ut, Te += 38 * ot, Re += 38 * Se, nt += 38 * Ae, Ue += 38 * Ve, pt += 38 * Be, it += 38 * je, et += 38 * Je, St += 38 * Lt, Tt += 38 * zt, At += 38 * Xt, _t += 38 * Ht, G = 1, C = U + G + 65535, G = Math.floor(C / 65536), U = C - G * 65536, C = se + G + 65535, G = Math.floor(C / 65536), se = C - G * 65536, C = he + G + 65535, G = Math.floor(C / 65536), he = C - G * 65536, C = xe + G + 65535, G = Math.floor(C / 65536), xe = C - G * 65536, C = Te + G + 65535, G = Math.floor(C / 65536), Te = C - G * 65536, C = Re + G + 65535, G = Math.floor(C / 65536), Re = C - G * 65536, C = nt + G + 65535, G = Math.floor(C / 65536), nt = C - G * 65536, C = Ue + G + 65535, G = Math.floor(C / 65536), Ue = C - G * 65536, C = pt + G + 65535, G = Math.floor(C / 65536), pt = C - G * 65536, C = it + G + 65535, G = Math.floor(C / 65536), it = C - G * 65536, C = et + G + 65535, G = Math.floor(C / 65536), et = C - G * 65536, C = St + G + 65535, G = Math.floor(C / 65536), St = C - G * 65536, C = Tt + G + 65535, G = Math.floor(C / 65536), Tt = C - G * 65536, C = At + G + 65535, G = Math.floor(C / 65536), At = C - G * 65536, C = _t + G + 65535, G = Math.floor(C / 65536), _t = C - G * 65536, C = ht + G + 65535, G = Math.floor(C / 65536), ht = C - G * 65536, U += G - 1 + 37 * (G - 1), G = 1, C = U + G + 65535, G = Math.floor(C / 65536), U = C - G * 65536, C = se + G + 65535, G = Math.floor(C / 65536), se = C - G * 65536, C = he + G + 65535, G = Math.floor(C / 65536), he = C - G * 65536, C = xe + G + 65535, G = Math.floor(C / 65536), xe = C - G * 65536, C = Te + G + 65535, G = Math.floor(C / 65536), Te = C - G * 65536, C = Re + G + 65535, G = Math.floor(C / 65536), Re = C - G * 65536, C = nt + G + 65535, G = Math.floor(C / 65536), nt = C - G * 65536, C = Ue + G + 65535, G = Math.floor(C / 65536), Ue = C - G * 65536, C = pt + G + 65535, G = Math.floor(C / 65536), pt = C - G * 65536, C = it + G + 65535, G = Math.floor(C / 65536), it = C - G * 65536, C = et + G + 65535, G = Math.floor(C / 65536), et = C - G * 65536, C = St + G + 65535, G = Math.floor(C / 65536), St = C - G * 65536, C = Tt + G + 65535, G = Math.floor(C / 65536), Tt = C - G * 65536, C = At + G + 65535, G = Math.floor(C / 65536), At = C - G * 65536, C = _t + G + 65535, G = Math.floor(C / 65536), _t = C - G * 65536, C = ht + G + 65535, G = Math.floor(C / 65536), ht = C - G * 65536, U += G - 1 + 37 * (G - 1), k[0] = U, k[1] = se, k[2] = he, k[3] = xe, k[4] = Te, k[5] = Re, k[6] = nt, k[7] = Ue, k[8] = pt, k[9] = it, k[10] = et, k[11] = St, k[12] = Tt, k[13] = At, k[14] = _t, k[15] = ht;
    }
    function oe(k, j) {
      D(k, j, j);
    }
    function Z(k, j) {
      var z = r(), C;
      for (C = 0; C < 16; C++) z[C] = j[C];
      for (C = 253; C >= 0; C--)
        oe(z, z), C !== 2 && C !== 4 && D(z, z, j);
      for (C = 0; C < 16; C++) k[C] = z[C];
    }
    function J(k, j) {
      var z = r(), C;
      for (C = 0; C < 16; C++) z[C] = j[C];
      for (C = 250; C >= 0; C--)
        oe(z, z), C !== 1 && D(z, z, j);
      for (C = 0; C < 16; C++) k[C] = z[C];
    }
    function Q(k, j, z) {
      var C = new Uint8Array(32), G = new Float64Array(80), U, se, he = r(), xe = r(), Te = r(), Re = r(), nt = r(), Ue = r();
      for (se = 0; se < 31; se++) C[se] = j[se];
      for (C[31] = j[31] & 127 | 64, C[0] &= 248, I(G, z), se = 0; se < 16; se++)
        xe[se] = G[se], Re[se] = he[se] = Te[se] = 0;
      for (he[0] = Re[0] = 1, se = 254; se >= 0; --se)
        U = C[se >>> 3] >>> (se & 7) & 1, _(he, xe, U), _(Te, Re, U), B(nt, he, Te), ce(he, he, Te), B(Te, xe, Re), ce(xe, xe, Re), oe(Re, nt), oe(Ue, he), D(he, Te, he), D(Te, xe, nt), B(nt, he, Te), ce(he, he, Te), oe(xe, he), ce(Te, Re, Ue), D(he, Te, u), B(he, he, Re), D(Te, Te, he), D(he, Re, Ue), D(Re, xe, G), oe(xe, nt), _(he, xe, U), _(Te, Re, U);
      for (se = 0; se < 16; se++)
        G[se + 16] = he[se], G[se + 32] = Te[se], G[se + 48] = xe[se], G[se + 64] = Re[se];
      var pt = G.subarray(32), it = G.subarray(16);
      return Z(pt, pt), D(it, it, pt), E(k, it), 0;
    }
    function T(k, j) {
      return Q(k, j, s);
    }
    function X(k, j) {
      return n(j, 32), T(k, j);
    }
    function re(k, j, z) {
      var C = new Uint8Array(32);
      return Q(C, z, j), V(k, i, C, te);
    }
    var de = f, ie = g;
    function ue(k, j, z, C, G, U) {
      var se = new Uint8Array(32);
      return re(se, G, U), de(k, j, z, C, se);
    }
    function ve(k, j, z, C, G, U) {
      var se = new Uint8Array(32);
      return re(se, G, U), ie(k, j, z, C, se);
    }
    var Pe = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function De(k, j, z, C) {
      for (var G = new Int32Array(16), U = new Int32Array(16), se, he, xe, Te, Re, nt, Ue, pt, it, et, St, Tt, At, _t, ht, xt, st, bt, ut, ot, Se, Ae, Ve, Be, je, Je, Lt = k[0], zt = k[1], Xt = k[2], Ht = k[3], le = k[4], tr = k[5], dr = k[6], pr = k[7], Zt = j[0], gr = j[1], lr = j[2], Rr = j[3], mr = j[4], yr = j[5], $r = j[6], Fr = j[7], Ir = 0; C >= 128; ) {
        for (ut = 0; ut < 16; ut++)
          ot = 8 * ut + Ir, G[ut] = z[ot + 0] << 24 | z[ot + 1] << 16 | z[ot + 2] << 8 | z[ot + 3], U[ut] = z[ot + 4] << 24 | z[ot + 5] << 16 | z[ot + 6] << 8 | z[ot + 7];
        for (ut = 0; ut < 80; ut++)
          if (se = Lt, he = zt, xe = Xt, Te = Ht, Re = le, nt = tr, Ue = dr, pt = pr, it = Zt, et = gr, St = lr, Tt = Rr, At = mr, _t = yr, ht = $r, xt = Fr, Se = pr, Ae = Fr, Ve = Ae & 65535, Be = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = (le >>> 14 | mr << 18) ^ (le >>> 18 | mr << 14) ^ (mr >>> 9 | le << 23), Ae = (mr >>> 14 | le << 18) ^ (mr >>> 18 | le << 14) ^ (le >>> 9 | mr << 23), Ve += Ae & 65535, Be += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Se = le & tr ^ ~le & dr, Ae = mr & yr ^ ~mr & $r, Ve += Ae & 65535, Be += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Se = Pe[ut * 2], Ae = Pe[ut * 2 + 1], Ve += Ae & 65535, Be += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Se = G[ut % 16], Ae = U[ut % 16], Ve += Ae & 65535, Be += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Be += Ve >>> 16, je += Be >>> 16, Je += je >>> 16, st = je & 65535 | Je << 16, bt = Ve & 65535 | Be << 16, Se = st, Ae = bt, Ve = Ae & 65535, Be = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = (Lt >>> 28 | Zt << 4) ^ (Zt >>> 2 | Lt << 30) ^ (Zt >>> 7 | Lt << 25), Ae = (Zt >>> 28 | Lt << 4) ^ (Lt >>> 2 | Zt << 30) ^ (Lt >>> 7 | Zt << 25), Ve += Ae & 65535, Be += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Se = Lt & zt ^ Lt & Xt ^ zt & Xt, Ae = Zt & gr ^ Zt & lr ^ gr & lr, Ve += Ae & 65535, Be += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Be += Ve >>> 16, je += Be >>> 16, Je += je >>> 16, pt = je & 65535 | Je << 16, xt = Ve & 65535 | Be << 16, Se = Te, Ae = Tt, Ve = Ae & 65535, Be = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = st, Ae = bt, Ve += Ae & 65535, Be += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Be += Ve >>> 16, je += Be >>> 16, Je += je >>> 16, Te = je & 65535 | Je << 16, Tt = Ve & 65535 | Be << 16, zt = se, Xt = he, Ht = xe, le = Te, tr = Re, dr = nt, pr = Ue, Lt = pt, gr = it, lr = et, Rr = St, mr = Tt, yr = At, $r = _t, Fr = ht, Zt = xt, ut % 16 === 15)
            for (ot = 0; ot < 16; ot++)
              Se = G[ot], Ae = U[ot], Ve = Ae & 65535, Be = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = G[(ot + 9) % 16], Ae = U[(ot + 9) % 16], Ve += Ae & 65535, Be += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, st = G[(ot + 1) % 16], bt = U[(ot + 1) % 16], Se = (st >>> 1 | bt << 31) ^ (st >>> 8 | bt << 24) ^ st >>> 7, Ae = (bt >>> 1 | st << 31) ^ (bt >>> 8 | st << 24) ^ (bt >>> 7 | st << 25), Ve += Ae & 65535, Be += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, st = G[(ot + 14) % 16], bt = U[(ot + 14) % 16], Se = (st >>> 19 | bt << 13) ^ (bt >>> 29 | st << 3) ^ st >>> 6, Ae = (bt >>> 19 | st << 13) ^ (st >>> 29 | bt << 3) ^ (bt >>> 6 | st << 26), Ve += Ae & 65535, Be += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Be += Ve >>> 16, je += Be >>> 16, Je += je >>> 16, G[ot] = je & 65535 | Je << 16, U[ot] = Ve & 65535 | Be << 16;
        Se = Lt, Ae = Zt, Ve = Ae & 65535, Be = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = k[0], Ae = j[0], Ve += Ae & 65535, Be += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Be += Ve >>> 16, je += Be >>> 16, Je += je >>> 16, k[0] = Lt = je & 65535 | Je << 16, j[0] = Zt = Ve & 65535 | Be << 16, Se = zt, Ae = gr, Ve = Ae & 65535, Be = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = k[1], Ae = j[1], Ve += Ae & 65535, Be += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Be += Ve >>> 16, je += Be >>> 16, Je += je >>> 16, k[1] = zt = je & 65535 | Je << 16, j[1] = gr = Ve & 65535 | Be << 16, Se = Xt, Ae = lr, Ve = Ae & 65535, Be = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = k[2], Ae = j[2], Ve += Ae & 65535, Be += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Be += Ve >>> 16, je += Be >>> 16, Je += je >>> 16, k[2] = Xt = je & 65535 | Je << 16, j[2] = lr = Ve & 65535 | Be << 16, Se = Ht, Ae = Rr, Ve = Ae & 65535, Be = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = k[3], Ae = j[3], Ve += Ae & 65535, Be += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Be += Ve >>> 16, je += Be >>> 16, Je += je >>> 16, k[3] = Ht = je & 65535 | Je << 16, j[3] = Rr = Ve & 65535 | Be << 16, Se = le, Ae = mr, Ve = Ae & 65535, Be = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = k[4], Ae = j[4], Ve += Ae & 65535, Be += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Be += Ve >>> 16, je += Be >>> 16, Je += je >>> 16, k[4] = le = je & 65535 | Je << 16, j[4] = mr = Ve & 65535 | Be << 16, Se = tr, Ae = yr, Ve = Ae & 65535, Be = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = k[5], Ae = j[5], Ve += Ae & 65535, Be += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Be += Ve >>> 16, je += Be >>> 16, Je += je >>> 16, k[5] = tr = je & 65535 | Je << 16, j[5] = yr = Ve & 65535 | Be << 16, Se = dr, Ae = $r, Ve = Ae & 65535, Be = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = k[6], Ae = j[6], Ve += Ae & 65535, Be += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Be += Ve >>> 16, je += Be >>> 16, Je += je >>> 16, k[6] = dr = je & 65535 | Je << 16, j[6] = $r = Ve & 65535 | Be << 16, Se = pr, Ae = Fr, Ve = Ae & 65535, Be = Ae >>> 16, je = Se & 65535, Je = Se >>> 16, Se = k[7], Ae = j[7], Ve += Ae & 65535, Be += Ae >>> 16, je += Se & 65535, Je += Se >>> 16, Be += Ve >>> 16, je += Be >>> 16, Je += je >>> 16, k[7] = pr = je & 65535 | Je << 16, j[7] = Fr = Ve & 65535 | Be << 16, Ir += 128, C -= 128;
      }
      return C;
    }
    function Ce(k, j, z) {
      var C = new Int32Array(8), G = new Int32Array(8), U = new Uint8Array(256), se, he = z;
      for (C[0] = 1779033703, C[1] = 3144134277, C[2] = 1013904242, C[3] = 2773480762, C[4] = 1359893119, C[5] = 2600822924, C[6] = 528734635, C[7] = 1541459225, G[0] = 4089235720, G[1] = 2227873595, G[2] = 4271175723, G[3] = 1595750129, G[4] = 2917565137, G[5] = 725511199, G[6] = 4215389547, G[7] = 327033209, De(C, G, j, z), z %= 128, se = 0; se < z; se++) U[se] = j[he - z + se];
      for (U[z] = 128, z = 256 - 128 * (z < 112 ? 1 : 0), U[z - 9] = 0, A(U, z - 8, he / 536870912 | 0, he << 3), De(C, G, U, z), se = 0; se < 8; se++) A(k, 8 * se, C[se], G[se]);
      return 0;
    }
    function $e(k, j) {
      var z = r(), C = r(), G = r(), U = r(), se = r(), he = r(), xe = r(), Te = r(), Re = r();
      ce(z, k[1], k[0]), ce(Re, j[1], j[0]), D(z, z, Re), B(C, k[0], k[1]), B(Re, j[0], j[1]), D(C, C, Re), D(G, k[3], j[3]), D(G, G, d), D(U, k[2], j[2]), B(U, U, U), ce(se, C, z), ce(he, U, G), B(xe, U, G), B(Te, C, z), D(k[0], se, he), D(k[1], Te, xe), D(k[2], xe, he), D(k[3], se, Te);
    }
    function Me(k, j, z) {
      var C;
      for (C = 0; C < 4; C++)
        _(k[C], j[C], z);
    }
    function Ne(k, j) {
      var z = r(), C = r(), G = r();
      Z(G, j[2]), D(z, j[0], G), D(C, j[1], G), E(k, C), k[31] ^= M(z) << 7;
    }
    function Ke(k, j, z) {
      var C, G;
      for (b(k[0], o), b(k[1], a), b(k[2], a), b(k[3], o), G = 255; G >= 0; --G)
        C = z[G / 8 | 0] >> (G & 7) & 1, Me(k, j, C), $e(j, k), $e(k, k), Me(k, j, C);
    }
    function Le(k, j) {
      var z = [r(), r(), r(), r()];
      b(z[0], p), b(z[1], w), b(z[2], a), D(z[3], p, w), Ke(k, z, j);
    }
    function qe(k, j, z) {
      var C = new Uint8Array(64), G = [r(), r(), r(), r()], U;
      for (z || n(j, 32), Ce(C, j, 32), C[0] &= 248, C[31] &= 127, C[31] |= 64, Le(G, C), Ne(k, G), U = 0; U < 32; U++) j[U + 32] = k[U];
      return 0;
    }
    var ze = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function _e(k, j) {
      var z, C, G, U;
      for (C = 63; C >= 32; --C) {
        for (z = 0, G = C - 32, U = C - 12; G < U; ++G)
          j[G] += z - 16 * j[C] * ze[G - (C - 32)], z = Math.floor((j[G] + 128) / 256), j[G] -= z * 256;
        j[G] += z, j[C] = 0;
      }
      for (z = 0, G = 0; G < 32; G++)
        j[G] += z - (j[31] >> 4) * ze[G], z = j[G] >> 8, j[G] &= 255;
      for (G = 0; G < 32; G++) j[G] -= z * ze[G];
      for (C = 0; C < 32; C++)
        j[C + 1] += j[C] >> 8, k[C] = j[C] & 255;
    }
    function Ze(k) {
      var j = new Float64Array(64), z;
      for (z = 0; z < 64; z++) j[z] = k[z];
      for (z = 0; z < 64; z++) k[z] = 0;
      _e(k, j);
    }
    function at(k, j, z, C) {
      var G = new Uint8Array(64), U = new Uint8Array(64), se = new Uint8Array(64), he, xe, Te = new Float64Array(64), Re = [r(), r(), r(), r()];
      Ce(G, C, 32), G[0] &= 248, G[31] &= 127, G[31] |= 64;
      var nt = z + 64;
      for (he = 0; he < z; he++) k[64 + he] = j[he];
      for (he = 0; he < 32; he++) k[32 + he] = G[32 + he];
      for (Ce(se, k.subarray(32), z + 32), Ze(se), Le(Re, se), Ne(k, Re), he = 32; he < 64; he++) k[he] = C[he];
      for (Ce(U, k, z + 64), Ze(U), he = 0; he < 64; he++) Te[he] = 0;
      for (he = 0; he < 32; he++) Te[he] = se[he];
      for (he = 0; he < 32; he++)
        for (xe = 0; xe < 32; xe++)
          Te[he + xe] += U[he] * G[xe];
      return _e(k.subarray(32), Te), nt;
    }
    function ke(k, j) {
      var z = r(), C = r(), G = r(), U = r(), se = r(), he = r(), xe = r();
      return b(k[2], a), I(k[1], j), oe(G, k[1]), D(U, G, l), ce(G, G, k[2]), B(U, k[2], U), oe(se, U), oe(he, se), D(xe, he, se), D(z, xe, G), D(z, z, U), J(z, z), D(z, z, G), D(z, z, U), D(z, z, U), D(k[0], z, U), oe(C, k[0]), D(C, C, U), v(C, G) && D(k[0], k[0], P), oe(C, k[0]), D(C, C, U), v(C, G) ? -1 : (M(k[0]) === j[31] >> 7 && ce(k[0], o, k[0]), D(k[3], k[0], k[1]), 0);
    }
    function Qe(k, j, z, C) {
      var G, U = new Uint8Array(32), se = new Uint8Array(64), he = [r(), r(), r(), r()], xe = [r(), r(), r(), r()];
      if (z < 64 || ke(xe, C)) return -1;
      for (G = 0; G < z; G++) k[G] = j[G];
      for (G = 0; G < 32; G++) k[G + 32] = C[G];
      if (Ce(se, k, z), Ze(se), Ke(he, xe, se), Le(xe, j.subarray(32)), $e(he, xe), Ne(U, he), z -= 64, F(j, 0, U, 0)) {
        for (G = 0; G < z; G++) k[G] = 0;
        return -1;
      }
      for (G = 0; G < z; G++) k[G] = j[G + 64];
      return z;
    }
    var tt = 32, Ye = 24, dt = 32, lt = 16, ct = 32, qt = 32, Yt = 32, Et = 32, Qt = 32, Jt = Ye, Dt = dt, kt = lt, Ct = 64, gt = 32, Rt = 64, Nt = 32, vt = 64;
    e.lowlevel = {
      crypto_core_hsalsa20: V,
      crypto_stream_xor: Ee,
      crypto_stream: pe,
      crypto_stream_salsa20_xor: R,
      crypto_stream_salsa20: W,
      crypto_onetimeauth: S,
      crypto_onetimeauth_verify: m,
      crypto_verify_16: L,
      crypto_verify_32: F,
      crypto_secretbox: f,
      crypto_secretbox_open: g,
      crypto_scalarmult: Q,
      crypto_scalarmult_base: T,
      crypto_box_beforenm: re,
      crypto_box_afternm: de,
      crypto_box: ue,
      crypto_box_open: ve,
      crypto_box_keypair: X,
      crypto_hash: Ce,
      crypto_sign: at,
      crypto_sign_keypair: qe,
      crypto_sign_open: Qe,
      crypto_secretbox_KEYBYTES: tt,
      crypto_secretbox_NONCEBYTES: Ye,
      crypto_secretbox_ZEROBYTES: dt,
      crypto_secretbox_BOXZEROBYTES: lt,
      crypto_scalarmult_BYTES: ct,
      crypto_scalarmult_SCALARBYTES: qt,
      crypto_box_PUBLICKEYBYTES: Yt,
      crypto_box_SECRETKEYBYTES: Et,
      crypto_box_BEFORENMBYTES: Qt,
      crypto_box_NONCEBYTES: Jt,
      crypto_box_ZEROBYTES: Dt,
      crypto_box_BOXZEROBYTES: kt,
      crypto_sign_BYTES: Ct,
      crypto_sign_PUBLICKEYBYTES: gt,
      crypto_sign_SECRETKEYBYTES: Rt,
      crypto_sign_SEEDBYTES: Nt,
      crypto_hash_BYTES: vt,
      gf: r,
      D: l,
      L: ze,
      pack25519: E,
      unpack25519: I,
      M: D,
      A: B,
      S: oe,
      Z: ce,
      pow2523: J,
      add: $e,
      set25519: b,
      modL: _e,
      scalarmult: Ke,
      scalarbase: Le
    };
    function $t(k, j) {
      if (k.length !== tt) throw new Error("bad key size");
      if (j.length !== Ye) throw new Error("bad nonce size");
    }
    function Bt(k, j) {
      if (k.length !== Yt) throw new Error("bad public key size");
      if (j.length !== Et) throw new Error("bad secret key size");
    }
    function rt() {
      for (var k = 0; k < arguments.length; k++)
        if (!(arguments[k] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function Ft(k) {
      for (var j = 0; j < k.length; j++) k[j] = 0;
    }
    e.randomBytes = function(k) {
      var j = new Uint8Array(k);
      return n(j, k), j;
    }, e.secretbox = function(k, j, z) {
      rt(k, j, z), $t(z, j);
      for (var C = new Uint8Array(dt + k.length), G = new Uint8Array(C.length), U = 0; U < k.length; U++) C[U + dt] = k[U];
      return f(G, C, C.length, j, z), G.subarray(lt);
    }, e.secretbox.open = function(k, j, z) {
      rt(k, j, z), $t(z, j);
      for (var C = new Uint8Array(lt + k.length), G = new Uint8Array(C.length), U = 0; U < k.length; U++) C[U + lt] = k[U];
      return C.length < 32 || g(G, C, C.length, j, z) !== 0 ? null : G.subarray(dt);
    }, e.secretbox.keyLength = tt, e.secretbox.nonceLength = Ye, e.secretbox.overheadLength = lt, e.scalarMult = function(k, j) {
      if (rt(k, j), k.length !== qt) throw new Error("bad n size");
      if (j.length !== ct) throw new Error("bad p size");
      var z = new Uint8Array(ct);
      return Q(z, k, j), z;
    }, e.scalarMult.base = function(k) {
      if (rt(k), k.length !== qt) throw new Error("bad n size");
      var j = new Uint8Array(ct);
      return T(j, k), j;
    }, e.scalarMult.scalarLength = qt, e.scalarMult.groupElementLength = ct, e.box = function(k, j, z, C) {
      var G = e.box.before(z, C);
      return e.secretbox(k, j, G);
    }, e.box.before = function(k, j) {
      rt(k, j), Bt(k, j);
      var z = new Uint8Array(Qt);
      return re(z, k, j), z;
    }, e.box.after = e.secretbox, e.box.open = function(k, j, z, C) {
      var G = e.box.before(z, C);
      return e.secretbox.open(k, j, G);
    }, e.box.open.after = e.secretbox.open, e.box.keyPair = function() {
      var k = new Uint8Array(Yt), j = new Uint8Array(Et);
      return X(k, j), { publicKey: k, secretKey: j };
    }, e.box.keyPair.fromSecretKey = function(k) {
      if (rt(k), k.length !== Et)
        throw new Error("bad secret key size");
      var j = new Uint8Array(Yt);
      return T(j, k), { publicKey: j, secretKey: new Uint8Array(k) };
    }, e.box.publicKeyLength = Yt, e.box.secretKeyLength = Et, e.box.sharedKeyLength = Qt, e.box.nonceLength = Jt, e.box.overheadLength = e.secretbox.overheadLength, e.sign = function(k, j) {
      if (rt(k, j), j.length !== Rt)
        throw new Error("bad secret key size");
      var z = new Uint8Array(Ct + k.length);
      return at(z, k, k.length, j), z;
    }, e.sign.open = function(k, j) {
      if (rt(k, j), j.length !== gt)
        throw new Error("bad public key size");
      var z = new Uint8Array(k.length), C = Qe(z, k, k.length, j);
      if (C < 0) return null;
      for (var G = new Uint8Array(C), U = 0; U < G.length; U++) G[U] = z[U];
      return G;
    }, e.sign.detached = function(k, j) {
      for (var z = e.sign(k, j), C = new Uint8Array(Ct), G = 0; G < C.length; G++) C[G] = z[G];
      return C;
    }, e.sign.detached.verify = function(k, j, z) {
      if (rt(k, j, z), j.length !== Ct)
        throw new Error("bad signature size");
      if (z.length !== gt)
        throw new Error("bad public key size");
      var C = new Uint8Array(Ct + k.length), G = new Uint8Array(Ct + k.length), U;
      for (U = 0; U < Ct; U++) C[U] = j[U];
      for (U = 0; U < k.length; U++) C[U + Ct] = k[U];
      return Qe(G, C, C.length, z) >= 0;
    }, e.sign.keyPair = function() {
      var k = new Uint8Array(gt), j = new Uint8Array(Rt);
      return qe(k, j), { publicKey: k, secretKey: j };
    }, e.sign.keyPair.fromSecretKey = function(k) {
      if (rt(k), k.length !== Rt)
        throw new Error("bad secret key size");
      for (var j = new Uint8Array(gt), z = 0; z < j.length; z++) j[z] = k[32 + z];
      return { publicKey: j, secretKey: new Uint8Array(k) };
    }, e.sign.keyPair.fromSeed = function(k) {
      if (rt(k), k.length !== Nt)
        throw new Error("bad seed size");
      for (var j = new Uint8Array(gt), z = new Uint8Array(Rt), C = 0; C < 32; C++) z[C] = k[C];
      return qe(j, z, !0), { publicKey: j, secretKey: z };
    }, e.sign.publicKeyLength = gt, e.sign.secretKeyLength = Rt, e.sign.seedLength = Nt, e.sign.signatureLength = Ct, e.hash = function(k) {
      rt(k);
      var j = new Uint8Array(vt);
      return Ce(j, k, k.length), j;
    }, e.hash.hashLength = vt, e.verify = function(k, j) {
      return rt(k, j), k.length === 0 || j.length === 0 || k.length !== j.length ? !1 : N(k, 0, j, 0, k.length) === 0;
    }, e.setPRNG = function(k) {
      n = k;
    }, function() {
      var k = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (k && k.getRandomValues) {
        var j = 65536;
        e.setPRNG(function(z, C) {
          var G, U = new Uint8Array(C);
          for (G = 0; G < C; G += j)
            k.getRandomValues(U.subarray(G, G + Math.min(C - G, j)));
          for (G = 0; G < C; G++) z[G] = U[G];
          Ft(U);
        });
      } else typeof A4 < "u" && (k = zl, k && k.randomBytes && e.setPRNG(function(z, C) {
        var G, U = k.randomBytes(C);
        for (G = 0; G < C; G++) z[G] = U[G];
        Ft(U);
      }));
    }();
  })(t.exports ? t.exports : self.nacl = self.nacl || {});
})(B9);
var aie = B9.exports;
const bd = /* @__PURE__ */ ts(aie);
var ua;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR", t[t.MANIFEST_NOT_FOUND_ERROR = 2] = "MANIFEST_NOT_FOUND_ERROR", t[t.MANIFEST_CONTENT_ERROR = 3] = "MANIFEST_CONTENT_ERROR", t[t.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR", t[t.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(ua || (ua = {}));
var f5;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(f5 || (f5 = {}));
var iu;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR", t[t.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR", t[t.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(iu || (iu = {}));
var l5;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR", t[t.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR", t[t.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(l5 || (l5 = {}));
var h5;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR", t[t.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(h5 || (h5 = {}));
var d5;
(function(t) {
  t.MAINNET = "-239", t.TESTNET = "-3";
})(d5 || (d5 = {}));
function cie(t, e) {
  const r = Rl.encodeBase64(t);
  return e ? encodeURIComponent(r) : r;
}
function uie(t, e) {
  return e && (t = decodeURIComponent(t)), Rl.decodeBase64(t);
}
function fie(t, e = !1) {
  let r;
  return t instanceof Uint8Array ? r = t : (typeof t != "string" && (t = JSON.stringify(t)), r = Rl.decodeUTF8(t)), cie(r, e);
}
function lie(t, e = !1) {
  const r = uie(t, e);
  return {
    toString() {
      return Rl.encodeUTF8(r);
    },
    toObject() {
      try {
        return JSON.parse(Rl.encodeUTF8(r));
      } catch {
        return null;
      }
    },
    toUint8Array() {
      return r;
    }
  };
}
const U9 = {
  encode: fie,
  decode: lie
};
function hie(t, e) {
  const r = new Uint8Array(t.length + e.length);
  return r.set(t), r.set(e, t.length), r;
}
function die(t, e) {
  if (e >= t.length)
    throw new Error("Index is out of buffer");
  const r = t.slice(0, e), n = t.slice(e);
  return [r, n];
}
function Km(t) {
  let e = "";
  return t.forEach((r) => {
    e += ("0" + (r & 255).toString(16)).slice(-2);
  }), e;
}
function S0(t) {
  if (t.length % 2 !== 0)
    throw new Error(`Cannot convert ${t} to bytesArray`);
  const e = new Uint8Array(t.length / 2);
  for (let r = 0; r < t.length; r += 2)
    e[r / 2] = parseInt(t.slice(r, r + 2), 16);
  return e;
}
class hv {
  constructor(e) {
    this.nonceLength = 24, this.keyPair = e ? this.createKeypairFromString(e) : this.createKeypair(), this.sessionId = Km(this.keyPair.publicKey);
  }
  createKeypair() {
    return bd.box.keyPair();
  }
  createKeypairFromString(e) {
    return {
      publicKey: S0(e.publicKey),
      secretKey: S0(e.secretKey)
    };
  }
  createNonce() {
    return bd.randomBytes(this.nonceLength);
  }
  encrypt(e, r) {
    const n = new TextEncoder().encode(e), i = this.createNonce(), s = bd.box(n, i, r, this.keyPair.secretKey);
    return hie(i, s);
  }
  decrypt(e, r) {
    const [n, i] = die(e, this.nonceLength), s = bd.box.open(i, n, r, this.keyPair.secretKey);
    if (!s)
      throw new Error(`Decryption error: 
 message: ${e.toString()} 
 sender pubkey: ${r.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`);
    return new TextDecoder().decode(s);
  }
  stringifyKeypair() {
    return {
      publicKey: Km(this.keyPair.publicKey),
      secretKey: Km(this.keyPair.secretKey)
    };
  }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function pie(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
  return r;
}
function Mt(t, e, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function a(d) {
      try {
        l(n.next(d));
      } catch (p) {
        o(p);
      }
    }
    function u(d) {
      try {
        l(n.throw(d));
      } catch (p) {
        o(p);
      }
    }
    function l(d) {
      d.done ? s(d.value) : i(d.value).then(a, u);
    }
    l((n = n.apply(t, [])).next());
  });
}
class Ut extends Error {
  constructor(e, r) {
    super(e, r), this.message = `${Ut.prefix} ${this.constructor.name}${this.info ? ": " + this.info : ""}${e ? `
` + e : ""}`, Object.setPrototypeOf(this, Ut.prototype);
  }
  get info() {
    return "";
  }
}
Ut.prefix = "[TON_CONNECT_SDK_ERROR]";
class cy extends Ut {
  get info() {
    return "Passed DappMetadata is in incorrect format.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, cy.prototype);
  }
}
class Sp extends Ut {
  get info() {
    return "Passed `tonconnect-manifest.json` contains errors. Check format of your manifest. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Sp.prototype);
  }
}
class Ap extends Ut {
  get info() {
    return "Manifest not found. Make sure you added `tonconnect-manifest.json` to the root of your app or passed correct manifestUrl. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Ap.prototype);
  }
}
class uy extends Ut {
  get info() {
    return "Wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, uy.prototype);
  }
}
class A0 extends Ut {
  get info() {
    return "Send transaction or other protocol methods called while wallet is not connected.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, A0.prototype);
  }
}
function gie(t) {
  return "jsBridgeKey" in t;
}
class Pp extends Ut {
  get info() {
    return "User rejects the action in the wallet.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Pp.prototype);
  }
}
class Mp extends Ut {
  get info() {
    return "Request to the wallet contains errors.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Mp.prototype);
  }
}
class Ip extends Ut {
  get info() {
    return "App tries to send rpc request to the injected wallet while not connected.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Ip.prototype);
  }
}
class fy extends Ut {
  get info() {
    return "There is an attempt to connect to the injected wallet while it is not exists in the webpage.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, fy.prototype);
  }
}
class ly extends Ut {
  get info() {
    return "An error occurred while fetching the wallets list.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, ly.prototype);
  }
}
class Ea extends Ut {
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Ea.prototype);
  }
}
const p5 = {
  [ua.UNKNOWN_ERROR]: Ea,
  [ua.USER_REJECTS_ERROR]: Pp,
  [ua.BAD_REQUEST_ERROR]: Mp,
  [ua.UNKNOWN_APP_ERROR]: Ip,
  [ua.MANIFEST_NOT_FOUND_ERROR]: Ap,
  [ua.MANIFEST_CONTENT_ERROR]: Sp
};
class mie {
  parseError(e) {
    let r = Ea;
    return e.code in p5 && (r = p5[e.code] || Ea), new r(e.message);
  }
}
const vie = new mie();
class bie {
  isError(e) {
    return "error" in e;
  }
}
const g5 = {
  [iu.UNKNOWN_ERROR]: Ea,
  [iu.USER_REJECTS_ERROR]: Pp,
  [iu.BAD_REQUEST_ERROR]: Mp,
  [iu.UNKNOWN_APP_ERROR]: Ip
};
class yie extends bie {
  convertToRpcRequest(e) {
    return {
      method: "sendTransaction",
      params: [JSON.stringify(e)]
    };
  }
  parseAndThrowError(e) {
    let r = Ea;
    throw e.error.code in g5 && (r = g5[e.error.code] || Ea), new r(e.error.message);
  }
  convertFromRpcResponse(e) {
    return {
      boc: e.result
    };
  }
}
const yd = new yie();
class wie {
  constructor(e, r) {
    this.storage = e, this.storeKey = "ton-connect-storage_http-bridge-gateway::" + r;
  }
  storeLastEventId(e) {
    return Mt(this, void 0, void 0, function* () {
      return this.storage.setItem(this.storeKey, e);
    });
  }
  removeLastEventId() {
    return Mt(this, void 0, void 0, function* () {
      return this.storage.removeItem(this.storeKey);
    });
  }
  getLastEventId() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.storage.getItem(this.storeKey);
      return e || null;
    });
  }
}
function xie(t) {
  return t.slice(-1) === "/" ? t.slice(0, -1) : t;
}
function j9(t, e) {
  return xie(t) + "/" + e;
}
function _ie(t) {
  if (!t)
    return !1;
  const e = new URL(t);
  return e.protocol === "tg:" || e.hostname === "t.me";
}
function Eie(t) {
  return t.replaceAll(".", "%2E").replaceAll("-", "%2D").replaceAll("_", "%5F").replaceAll("&", "-").replaceAll("=", "__").replaceAll("%", "--");
}
function q9(t, e) {
  return Mt(this, void 0, void 0, function* () {
    return new Promise((r, n) => {
      var i, s;
      if (!((i = void 0) === null || i === void 0) && i.aborted) {
        n(new Ut("Delay aborted"));
        return;
      }
      const o = setTimeout(() => r(), t);
      (s = void 0) === null || s === void 0 || s.addEventListener("abort", () => {
        clearTimeout(o), n(new Ut("Delay aborted"));
      });
    });
  });
}
function xs(t) {
  const e = new AbortController();
  return t != null && t.aborted ? e.abort() : t == null || t.addEventListener("abort", () => e.abort(), { once: !0 }), e;
}
function Xf(t, e) {
  var r, n;
  return Mt(this, void 0, void 0, function* () {
    const i = (r = e == null ? void 0 : e.attempts) !== null && r !== void 0 ? r : 10, s = (n = e == null ? void 0 : e.delayMs) !== null && n !== void 0 ? n : 200, o = xs(e == null ? void 0 : e.signal);
    if (typeof t != "function")
      throw new Ut(`Expected a function, got ${typeof t}`);
    let a = 0, u;
    for (; a < i; ) {
      if (o.signal.aborted)
        throw new Ut(`Aborted after attempts ${a}`);
      try {
        return yield t({ signal: o.signal });
      } catch (l) {
        u = l, a++, a < i && (yield q9(s));
      }
    }
    throw u;
  });
}
function Sn(...t) {
  try {
    console.debug("[TON_CONNECT_SDK]", ...t);
  } catch {
  }
}
function Oo(...t) {
  try {
    console.error("[TON_CONNECT_SDK]", ...t);
  } catch {
  }
}
function Sie(...t) {
  try {
    console.warn("[TON_CONNECT_SDK]", ...t);
  } catch {
  }
}
function Aie(t, e) {
  let r = null, n = null, i = null, s = null, o = null;
  const a = (p, ...w) => Mt(this, void 0, void 0, function* () {
    if (s = p ?? null, o == null || o.abort(), o = xs(p), o.signal.aborted)
      throw new Ut("Resource creation was aborted");
    n = w ?? null;
    const P = t(o.signal, ...w);
    i = P;
    const A = yield P;
    if (i !== P && A !== r)
      throw yield e(A), new Ut("Resource creation was aborted by a new resource creation");
    return r = A, r;
  });
  return {
    create: a,
    current: () => r ?? null,
    dispose: () => Mt(this, void 0, void 0, function* () {
      try {
        const p = r;
        r = null;
        const w = i;
        i = null;
        try {
          o == null || o.abort();
        } catch {
        }
        yield Promise.allSettled([
          p ? e(p) : Promise.resolve(),
          w ? e(yield w) : Promise.resolve()
        ]);
      } catch {
      }
    }),
    recreate: (p) => Mt(this, void 0, void 0, function* () {
      const w = r, P = i, A = n, N = s;
      if (yield q9(p), w === r && P === i && A === n && N === s)
        return yield a(s, ...A ?? []);
      throw new Ut("Resource recreation was aborted by a new resource creation");
    })
  };
}
function Pie(t, e) {
  const r = e == null ? void 0 : e.timeout, n = e == null ? void 0 : e.signal, i = xs(n);
  return new Promise((s, o) => Mt(this, void 0, void 0, function* () {
    if (i.signal.aborted) {
      o(new Ut("Operation aborted"));
      return;
    }
    let a;
    typeof r < "u" && (a = setTimeout(() => {
      i.abort(), o(new Ut(`Timeout after ${r}ms`));
    }, r)), i.signal.addEventListener("abort", () => {
      clearTimeout(a), o(new Ut("Operation aborted"));
    }, { once: !0 });
    const u = { timeout: r, abort: i.signal };
    yield t((...l) => {
      clearTimeout(a), s(...l);
    }, () => {
      clearTimeout(a), o();
    }, u);
  }));
}
class Vm {
  constructor(e, r, n, i, s) {
    this.bridgeUrl = r, this.sessionId = n, this.listener = i, this.errorsListener = s, this.ssePath = "events", this.postPath = "message", this.heartbeatMessage = "heartbeat", this.defaultTtl = 300, this.defaultReconnectDelay = 2e3, this.defaultResendDelay = 5e3, this.eventSource = Aie((o, a) => Mt(this, void 0, void 0, function* () {
      const u = {
        bridgeUrl: this.bridgeUrl,
        ssePath: this.ssePath,
        sessionId: this.sessionId,
        bridgeGatewayStorage: this.bridgeGatewayStorage,
        errorHandler: this.errorsHandler.bind(this),
        messageHandler: this.messagesHandler.bind(this),
        signal: o,
        openingDeadlineMS: a
      };
      return yield Mie(u);
    }), (o) => Mt(this, void 0, void 0, function* () {
      o.close();
    })), this.bridgeGatewayStorage = new wie(e, r);
  }
  get isReady() {
    const e = this.eventSource.current();
    return (e == null ? void 0 : e.readyState) === EventSource.OPEN;
  }
  get isClosed() {
    const e = this.eventSource.current();
    return (e == null ? void 0 : e.readyState) !== EventSource.OPEN;
  }
  get isConnecting() {
    const e = this.eventSource.current();
    return (e == null ? void 0 : e.readyState) === EventSource.CONNECTING;
  }
  registerSession(e) {
    return Mt(this, void 0, void 0, function* () {
      yield this.eventSource.create(e == null ? void 0 : e.signal, e == null ? void 0 : e.openingDeadlineMS);
    });
  }
  send(e, r, n, i) {
    var s;
    return Mt(this, void 0, void 0, function* () {
      const o = {};
      typeof i == "number" ? o.ttl = i : (o.ttl = i == null ? void 0 : i.ttl, o.signal = i == null ? void 0 : i.signal, o.attempts = i == null ? void 0 : i.attempts);
      const a = new URL(j9(this.bridgeUrl, this.postPath));
      a.searchParams.append("client_id", this.sessionId), a.searchParams.append("to", r), a.searchParams.append("ttl", ((o == null ? void 0 : o.ttl) || this.defaultTtl).toString()), a.searchParams.append("topic", n);
      const u = U9.encode(e);
      yield Xf((l) => Mt(this, void 0, void 0, function* () {
        const d = yield this.post(a, u, l.signal);
        if (!d.ok)
          throw new Ut(`Bridge send failed, status ${d.status}`);
      }), {
        attempts: (s = o == null ? void 0 : o.attempts) !== null && s !== void 0 ? s : Number.MAX_SAFE_INTEGER,
        delayMs: this.defaultResendDelay,
        signal: o == null ? void 0 : o.signal
      });
    });
  }
  pause() {
    this.eventSource.dispose().catch((e) => Oo(`Bridge pause failed, ${e}`));
  }
  unPause() {
    return Mt(this, void 0, void 0, function* () {
      yield this.eventSource.recreate(0);
    });
  }
  close() {
    return Mt(this, void 0, void 0, function* () {
      yield this.eventSource.dispose().catch((e) => Oo(`Bridge close failed, ${e}`));
    });
  }
  setListener(e) {
    this.listener = e;
  }
  setErrorsListener(e) {
    this.errorsListener = e;
  }
  post(e, r, n) {
    return Mt(this, void 0, void 0, function* () {
      const i = yield fetch(e, {
        method: "post",
        body: r,
        signal: n
      });
      if (!i.ok)
        throw new Ut(`Bridge send failed, status ${i.status}`);
      return i;
    });
  }
  errorsHandler(e, r) {
    return Mt(this, void 0, void 0, function* () {
      if (this.isConnecting)
        throw e.close(), new Ut("Bridge error, failed to connect");
      if (this.isReady) {
        try {
          this.errorsListener(r);
        } catch {
        }
        return;
      }
      if (this.isClosed)
        return e.close(), Sn(`Bridge reconnecting, ${this.defaultReconnectDelay}ms delay`), yield this.eventSource.recreate(this.defaultReconnectDelay);
      throw new Ut("Bridge error, unknown state");
    });
  }
  messagesHandler(e) {
    return Mt(this, void 0, void 0, function* () {
      if (e.data === this.heartbeatMessage || (yield this.bridgeGatewayStorage.storeLastEventId(e.lastEventId), this.isClosed))
        return;
      let r;
      try {
        r = JSON.parse(e.data);
      } catch (n) {
        throw new Ut(`Bridge message parse failed, message ${n.data}`);
      }
      this.listener(r);
    });
  }
}
function Mie(t) {
  return Mt(this, void 0, void 0, function* () {
    return yield Pie((e, r, n) => Mt(this, void 0, void 0, function* () {
      var i;
      const o = xs(n.signal).signal;
      if (o.aborted) {
        r(new Ut("Bridge connection aborted"));
        return;
      }
      const a = new URL(j9(t.bridgeUrl, t.ssePath));
      a.searchParams.append("client_id", t.sessionId);
      const u = yield t.bridgeGatewayStorage.getLastEventId();
      if (u && a.searchParams.append("last_event_id", u), o.aborted) {
        r(new Ut("Bridge connection aborted"));
        return;
      }
      const l = new EventSource(a.toString());
      l.onerror = (d) => Mt(this, void 0, void 0, function* () {
        if (o.aborted) {
          l.close(), r(new Ut("Bridge connection aborted"));
          return;
        }
        try {
          const p = yield t.errorHandler(l, d);
          p !== l && l.close(), p && p !== l && e(p);
        } catch (p) {
          l.close(), r(p);
        }
      }), l.onopen = () => {
        if (o.aborted) {
          l.close(), r(new Ut("Bridge connection aborted"));
          return;
        }
        e(l);
      }, l.onmessage = (d) => {
        if (o.aborted) {
          l.close(), r(new Ut("Bridge connection aborted"));
          return;
        }
        t.messageHandler(d);
      }, (i = t.signal) === null || i === void 0 || i.addEventListener("abort", () => {
        l.close(), r(new Ut("Bridge connection aborted"));
      });
    }), { timeout: t.openingDeadlineMS, signal: t.signal });
  });
}
function Zf(t) {
  return !("connectEvent" in t);
}
class Dl {
  constructor(e) {
    this.storage = e, this.storeKey = "ton-connect-storage_bridge-connection";
  }
  storeConnection(e) {
    return Mt(this, void 0, void 0, function* () {
      if (e.type === "injected")
        return this.storage.setItem(this.storeKey, JSON.stringify(e));
      if (!Zf(e)) {
        const n = {
          sessionKeyPair: e.session.sessionCrypto.stringifyKeypair(),
          walletPublicKey: e.session.walletPublicKey,
          bridgeUrl: e.session.bridgeUrl
        }, i = {
          type: "http",
          connectEvent: e.connectEvent,
          session: n,
          lastWalletEventId: e.lastWalletEventId,
          nextRpcRequestId: e.nextRpcRequestId
        };
        return this.storage.setItem(this.storeKey, JSON.stringify(i));
      }
      const r = {
        type: "http",
        connectionSource: e.connectionSource,
        sessionCrypto: e.sessionCrypto.stringifyKeypair()
      };
      return this.storage.setItem(this.storeKey, JSON.stringify(r));
    });
  }
  removeConnection() {
    return Mt(this, void 0, void 0, function* () {
      return this.storage.removeItem(this.storeKey);
    });
  }
  getConnection() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.storage.getItem(this.storeKey);
      if (!e)
        return null;
      const r = JSON.parse(e);
      if (r.type === "injected")
        return r;
      if ("connectEvent" in r) {
        const n = new hv(r.session.sessionKeyPair);
        return {
          type: "http",
          connectEvent: r.connectEvent,
          lastWalletEventId: r.lastWalletEventId,
          nextRpcRequestId: r.nextRpcRequestId,
          session: {
            sessionCrypto: n,
            bridgeUrl: r.session.bridgeUrl,
            walletPublicKey: r.session.walletPublicKey
          }
        };
      }
      return {
        type: "http",
        sessionCrypto: new hv(r.sessionCrypto),
        connectionSource: r.connectionSource
      };
    });
  }
  getHttpConnection() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (!e)
        throw new Ut("Trying to read HTTP connection source while nothing is stored");
      if (e.type === "injected")
        throw new Ut("Trying to read HTTP connection source while injected connection is stored");
      return e;
    });
  }
  getHttpPendingConnection() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (!e)
        throw new Ut("Trying to read HTTP connection source while nothing is stored");
      if (e.type === "injected")
        throw new Ut("Trying to read HTTP connection source while injected connection is stored");
      if (!Zf(e))
        throw new Ut("Trying to read HTTP-pending connection while http connection is stored");
      return e;
    });
  }
  getInjectedConnection() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (!e)
        throw new Ut("Trying to read Injected bridge connection source while nothing is stored");
      if ((e == null ? void 0 : e.type) === "http")
        throw new Ut("Trying to read Injected bridge connection source while HTTP connection is stored");
      return e;
    });
  }
  storedConnectionType() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.storage.getItem(this.storeKey);
      return e ? JSON.parse(e).type : null;
    });
  }
  storeLastWalletEventId(e) {
    return Mt(this, void 0, void 0, function* () {
      const r = yield this.getConnection();
      if (r && r.type === "http" && !Zf(r))
        return r.lastWalletEventId = e, this.storeConnection(r);
    });
  }
  getLastWalletEventId() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (e && "lastWalletEventId" in e)
        return e.lastWalletEventId;
    });
  }
  increaseNextRpcRequestId() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (e && "nextRpcRequestId" in e) {
        const r = e.nextRpcRequestId || 0;
        return e.nextRpcRequestId = r + 1, this.storeConnection(e);
      }
    });
  }
  getNextRpcRequestId() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      return e && "nextRpcRequestId" in e && e.nextRpcRequestId || 0;
    });
  }
}
const z9 = 2;
class Ol {
  constructor(e, r) {
    this.storage = e, this.walletConnectionSource = r, this.type = "http", this.standardUniversalLink = "tc://", this.pendingRequests = /* @__PURE__ */ new Map(), this.session = null, this.gateway = null, this.pendingGateways = [], this.listeners = [], this.defaultOpeningDeadlineMS = 12e3, this.defaultRetryTimeoutMS = 2e3, this.connectionStorage = new Dl(e);
  }
  static fromStorage(e) {
    return Mt(this, void 0, void 0, function* () {
      const n = yield new Dl(e).getHttpConnection();
      return Zf(n) ? new Ol(e, n.connectionSource) : new Ol(e, { bridgeUrl: n.session.bridgeUrl });
    });
  }
  connect(e, r) {
    var n;
    const i = xs(r == null ? void 0 : r.signal);
    (n = this.abortController) === null || n === void 0 || n.abort(), this.abortController = i, this.closeGateways();
    const s = new hv();
    this.session = {
      sessionCrypto: s,
      bridgeUrl: "bridgeUrl" in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
    }, this.connectionStorage.storeConnection({
      type: "http",
      connectionSource: this.walletConnectionSource,
      sessionCrypto: s
    }).then(() => Mt(this, void 0, void 0, function* () {
      i.signal.aborted || (yield Xf((a) => {
        var u;
        return this.openGateways(s, {
          openingDeadlineMS: (u = r == null ? void 0 : r.openingDeadlineMS) !== null && u !== void 0 ? u : this.defaultOpeningDeadlineMS,
          signal: a == null ? void 0 : a.signal
        });
      }, {
        attempts: Number.MAX_SAFE_INTEGER,
        delayMs: this.defaultRetryTimeoutMS,
        signal: i.signal
      }));
    }));
    const o = "universalLink" in this.walletConnectionSource && this.walletConnectionSource.universalLink ? this.walletConnectionSource.universalLink : this.standardUniversalLink;
    return this.generateUniversalLink(o, e);
  }
  restoreConnection(e) {
    var r, n;
    return Mt(this, void 0, void 0, function* () {
      const i = xs(e == null ? void 0 : e.signal);
      if ((r = this.abortController) === null || r === void 0 || r.abort(), this.abortController = i, i.signal.aborted)
        return;
      this.closeGateways();
      const s = yield this.connectionStorage.getHttpConnection();
      if (!s || i.signal.aborted)
        return;
      const o = (n = e == null ? void 0 : e.openingDeadlineMS) !== null && n !== void 0 ? n : this.defaultOpeningDeadlineMS;
      if (Zf(s))
        return this.session = {
          sessionCrypto: s.sessionCrypto,
          bridgeUrl: "bridgeUrl" in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
        }, yield this.openGateways(s.sessionCrypto, {
          openingDeadlineMS: o,
          signal: i == null ? void 0 : i.signal
        });
      if (Array.isArray(this.walletConnectionSource))
        throw new Ut("Internal error. Connection source is array while WalletConnectionSourceHTTP was expected.");
      if (this.session = s.session, this.gateway && (Sn("Gateway is already opened, closing previous gateway"), yield this.gateway.close()), this.gateway = new Vm(this.storage, this.walletConnectionSource.bridgeUrl, s.session.sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this)), !i.signal.aborted) {
        this.listeners.forEach((a) => a(s.connectEvent));
        try {
          yield Xf((a) => this.gateway.registerSession({
            openingDeadlineMS: o,
            signal: a.signal
          }), {
            attempts: Number.MAX_SAFE_INTEGER,
            delayMs: this.defaultRetryTimeoutMS,
            signal: i.signal
          });
        } catch {
          yield this.disconnect({ signal: i.signal });
          return;
        }
      }
    });
  }
  sendRequest(e, r) {
    const n = {};
    return typeof r == "function" ? n.onRequestSent = r : (n.onRequestSent = r == null ? void 0 : r.onRequestSent, n.signal = r == null ? void 0 : r.signal, n.attempts = r == null ? void 0 : r.attempts), new Promise((i, s) => Mt(this, void 0, void 0, function* () {
      var o;
      if (!this.gateway || !this.session || !("walletPublicKey" in this.session))
        throw new Ut("Trying to send bridge request without session");
      const a = (yield this.connectionStorage.getNextRpcRequestId()).toString();
      yield this.connectionStorage.increaseNextRpcRequestId(), Sn("Send http-bridge request:", Object.assign(Object.assign({}, e), { id: a }));
      const u = this.session.sessionCrypto.encrypt(JSON.stringify(Object.assign(Object.assign({}, e), { id: a })), S0(this.session.walletPublicKey));
      try {
        yield this.gateway.send(u, this.session.walletPublicKey, e.method, { attempts: n == null ? void 0 : n.attempts, signal: n == null ? void 0 : n.signal }), (o = n == null ? void 0 : n.onRequestSent) === null || o === void 0 || o.call(n), this.pendingRequests.set(a.toString(), i);
      } catch (l) {
        s(l);
      }
    }));
  }
  closeConnection() {
    this.closeGateways(), this.listeners = [], this.session = null, this.gateway = null;
  }
  disconnect(e) {
    return Mt(this, void 0, void 0, function* () {
      return new Promise((r) => Mt(this, void 0, void 0, function* () {
        let n = !1, i = null;
        const s = () => {
          n || (n = !0, this.removeBridgeAndSession().then(r));
        };
        try {
          this.closeGateways();
          const o = xs(e == null ? void 0 : e.signal);
          i = setTimeout(() => {
            o.abort();
          }, this.defaultOpeningDeadlineMS), yield this.sendRequest({ method: "disconnect", params: [] }, {
            onRequestSent: s,
            signal: o.signal,
            attempts: 1
          });
        } catch (o) {
          Sn("Disconnect error:", o), n || this.removeBridgeAndSession().then(r);
        } finally {
          i && clearTimeout(i), s();
        }
      }));
    });
  }
  listen(e) {
    return this.listeners.push(e), () => this.listeners = this.listeners.filter((r) => r !== e);
  }
  pause() {
    var e;
    (e = this.gateway) === null || e === void 0 || e.pause(), this.pendingGateways.forEach((r) => r.pause());
  }
  unPause() {
    return Mt(this, void 0, void 0, function* () {
      const e = this.pendingGateways.map((r) => r.unPause());
      this.gateway && e.push(this.gateway.unPause()), yield Promise.all(e);
    });
  }
  pendingGatewaysListener(e, r, n) {
    return Mt(this, void 0, void 0, function* () {
      if (!this.pendingGateways.includes(e)) {
        yield e.close();
        return;
      }
      return this.closeGateways({ except: e }), this.gateway && (Sn("Gateway is already opened, closing previous gateway"), yield this.gateway.close()), this.session.bridgeUrl = r, this.gateway = e, this.gateway.setErrorsListener(this.gatewayErrorsListener.bind(this)), this.gateway.setListener(this.gatewayListener.bind(this)), this.gatewayListener(n);
    });
  }
  gatewayListener(e) {
    return Mt(this, void 0, void 0, function* () {
      const r = JSON.parse(this.session.sessionCrypto.decrypt(U9.decode(e.message).toUint8Array(), S0(e.from)));
      if (Sn("Wallet message received:", r), !("event" in r)) {
        const i = r.id.toString(), s = this.pendingRequests.get(i);
        if (!s) {
          Sn(`Response id ${i} doesn't match any request's id`);
          return;
        }
        s(r), this.pendingRequests.delete(i);
        return;
      }
      if (r.id !== void 0) {
        const i = yield this.connectionStorage.getLastWalletEventId();
        if (i !== void 0 && r.id <= i) {
          Oo(`Received event id (=${r.id}) must be greater than stored last wallet event id (=${i}) `);
          return;
        }
        r.event !== "connect" && (yield this.connectionStorage.storeLastWalletEventId(r.id));
      }
      const n = this.listeners;
      r.event === "connect" && (yield this.updateSession(r, e.from)), r.event === "disconnect" && (Sn("Removing bridge and session: received disconnect event"), yield this.removeBridgeAndSession()), n.forEach((i) => i(r));
    });
  }
  gatewayErrorsListener(e) {
    return Mt(this, void 0, void 0, function* () {
      throw new Ut(`Bridge error ${JSON.stringify(e)}`);
    });
  }
  updateSession(e, r) {
    return Mt(this, void 0, void 0, function* () {
      this.session = Object.assign(Object.assign({}, this.session), { walletPublicKey: r });
      const n = e.payload.items.find((s) => s.name === "ton_addr"), i = Object.assign(Object.assign({}, e), { payload: Object.assign(Object.assign({}, e.payload), { items: [n] }) });
      yield this.connectionStorage.storeConnection({
        type: "http",
        session: this.session,
        lastWalletEventId: e.id,
        connectEvent: i,
        nextRpcRequestId: 0
      });
    });
  }
  removeBridgeAndSession() {
    return Mt(this, void 0, void 0, function* () {
      this.closeConnection(), yield this.connectionStorage.removeConnection();
    });
  }
  generateUniversalLink(e, r) {
    return _ie(e) ? this.generateTGUniversalLink(e, r) : this.generateRegularUniversalLink(e, r);
  }
  generateRegularUniversalLink(e, r) {
    const n = new URL(e);
    return n.searchParams.append("v", z9.toString()), n.searchParams.append("id", this.session.sessionCrypto.sessionId), n.searchParams.append("r", JSON.stringify(r)), n.toString();
  }
  generateTGUniversalLink(e, r) {
    const i = this.generateRegularUniversalLink("about:blank", r).split("?")[1], s = "tonconnect-" + Eie(i), o = this.convertToDirectLink(e), a = new URL(o);
    return a.searchParams.append("startapp", s), a.toString();
  }
  // TODO: Remove this method after all dApps and the wallets-list.json have been updated
  convertToDirectLink(e) {
    const r = new URL(e);
    return r.searchParams.has("attach") && (r.searchParams.delete("attach"), r.pathname += "/start"), r.toString();
  }
  openGateways(e, r) {
    return Mt(this, void 0, void 0, function* () {
      if (Array.isArray(this.walletConnectionSource)) {
        this.pendingGateways.map((n) => n.close().catch()), this.pendingGateways = this.walletConnectionSource.map((n) => {
          const i = new Vm(this.storage, n.bridgeUrl, e.sessionId, () => {
          }, () => {
          });
          return i.setListener((s) => this.pendingGatewaysListener(i, n.bridgeUrl, s)), i;
        }), yield Promise.allSettled(this.pendingGateways.map((n) => Xf((i) => {
          var s;
          return this.pendingGateways.some((o) => o === n) ? n.registerSession({
            openingDeadlineMS: (s = r == null ? void 0 : r.openingDeadlineMS) !== null && s !== void 0 ? s : this.defaultOpeningDeadlineMS,
            signal: i.signal
          }) : n.close();
        }, {
          attempts: Number.MAX_SAFE_INTEGER,
          delayMs: this.defaultRetryTimeoutMS,
          signal: r == null ? void 0 : r.signal
        })));
        return;
      } else
        return this.gateway && (Sn("Gateway is already opened, closing previous gateway"), yield this.gateway.close()), this.gateway = new Vm(this.storage, this.walletConnectionSource.bridgeUrl, e.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this)), yield this.gateway.registerSession({
          openingDeadlineMS: r == null ? void 0 : r.openingDeadlineMS,
          signal: r == null ? void 0 : r.signal
        });
    });
  }
  closeGateways(e) {
    var r;
    (r = this.gateway) === null || r === void 0 || r.close(), this.pendingGateways.filter((n) => n !== (e == null ? void 0 : e.except)).forEach((n) => n.close()), this.pendingGateways = [];
  }
}
function m5(t, e) {
  return H9(t, [e]);
}
function H9(t, e) {
  return !t || typeof t != "object" ? !1 : e.every((r) => r in t);
}
function Iie(t) {
  try {
    return !m5(t, "tonconnect") || !m5(t.tonconnect, "walletInfo") ? !1 : H9(t.tonconnect.walletInfo, [
      "name",
      "app_name",
      "image",
      "about_url",
      "platforms"
    ]);
  } catch {
    return !1;
  }
}
class su {
  constructor() {
    this.storage = {};
  }
  static getInstance() {
    return su.instance || (su.instance = new su()), su.instance;
  }
  get length() {
    return Object.keys(this.storage).length;
  }
  clear() {
    this.storage = {};
  }
  getItem(e) {
    var r;
    return (r = this.storage[e]) !== null && r !== void 0 ? r : null;
  }
  key(e) {
    var r;
    const n = Object.keys(this.storage);
    return e < 0 || e >= n.length ? null : (r = n[e]) !== null && r !== void 0 ? r : null;
  }
  removeItem(e) {
    delete this.storage[e];
  }
  setItem(e, r) {
    this.storage[e] = r;
  }
}
function Cp() {
  if (!(typeof window > "u"))
    return window;
}
function Cie() {
  const t = Cp();
  if (!t)
    return [];
  try {
    return Object.keys(t);
  } catch {
    return [];
  }
}
function Tie() {
  if (!(typeof document > "u"))
    return document;
}
function Rie() {
  var t;
  const e = (t = Cp()) === null || t === void 0 ? void 0 : t.location.origin;
  return e ? e + "/tonconnect-manifest.json" : "";
}
function Die() {
  if (Oie())
    return localStorage;
  if (Nie())
    throw new Ut("`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector");
  return su.getInstance();
}
function Oie() {
  try {
    return typeof localStorage < "u";
  } catch {
    return !1;
  }
}
function Nie() {
  return typeof process < "u" && process.versions != null && process.versions.node != null;
}
class mi {
  constructor(e, r) {
    this.injectedWalletKey = r, this.type = "injected", this.unsubscribeCallback = null, this.listenSubscriptions = !1, this.listeners = [];
    const n = mi.window;
    if (!mi.isWindowContainsWallet(n, r))
      throw new fy();
    this.connectionStorage = new Dl(e), this.injectedWallet = n[r].tonconnect;
  }
  static fromStorage(e) {
    return Mt(this, void 0, void 0, function* () {
      const n = yield new Dl(e).getInjectedConnection();
      return new mi(e, n.jsBridgeKey);
    });
  }
  static isWalletInjected(e) {
    return mi.isWindowContainsWallet(this.window, e);
  }
  static isInsideWalletBrowser(e) {
    return mi.isWindowContainsWallet(this.window, e) ? this.window[e].tonconnect.isWalletBrowser : !1;
  }
  static getCurrentlyInjectedWallets() {
    return this.window ? Cie().filter(([n, i]) => Iie(i)).map(([n, i]) => ({
      name: i.tonconnect.walletInfo.name,
      appName: i.tonconnect.walletInfo.app_name,
      aboutUrl: i.tonconnect.walletInfo.about_url,
      imageUrl: i.tonconnect.walletInfo.image,
      tondns: i.tonconnect.walletInfo.tondns,
      jsBridgeKey: n,
      injected: !0,
      embedded: i.tonconnect.isWalletBrowser,
      platforms: i.tonconnect.walletInfo.platforms
    })) : [];
  }
  static isWindowContainsWallet(e, r) {
    return !!e && r in e && typeof e[r] == "object" && "tonconnect" in e[r];
  }
  connect(e) {
    this._connect(z9, e);
  }
  restoreConnection() {
    return Mt(this, void 0, void 0, function* () {
      try {
        Sn("Injected Provider restoring connection...");
        const e = yield this.injectedWallet.restoreConnection();
        Sn("Injected Provider restoring connection response", e), e.event === "connect" ? (this.makeSubscriptions(), this.listeners.forEach((r) => r(e))) : yield this.connectionStorage.removeConnection();
      } catch (e) {
        yield this.connectionStorage.removeConnection(), console.error(e);
      }
    });
  }
  closeConnection() {
    this.listenSubscriptions && this.injectedWallet.disconnect(), this.closeAllListeners();
  }
  disconnect() {
    return Mt(this, void 0, void 0, function* () {
      return new Promise((e) => {
        const r = () => {
          this.closeAllListeners(), this.connectionStorage.removeConnection().then(e);
        };
        try {
          this.injectedWallet.disconnect(), r();
        } catch (n) {
          Sn(n), this.sendRequest({
            method: "disconnect",
            params: []
          }, r);
        }
      });
    });
  }
  closeAllListeners() {
    var e;
    this.listenSubscriptions = !1, this.listeners = [], (e = this.unsubscribeCallback) === null || e === void 0 || e.call(this);
  }
  listen(e) {
    return this.listeners.push(e), () => this.listeners = this.listeners.filter((r) => r !== e);
  }
  sendRequest(e, r) {
    var n;
    return Mt(this, void 0, void 0, function* () {
      const i = {};
      typeof r == "function" ? i.onRequestSent = r : (i.onRequestSent = r == null ? void 0 : r.onRequestSent, i.signal = r == null ? void 0 : r.signal);
      const s = (yield this.connectionStorage.getNextRpcRequestId()).toString();
      yield this.connectionStorage.increaseNextRpcRequestId(), Sn("Send injected-bridge request:", Object.assign(Object.assign({}, e), { id: s }));
      const o = this.injectedWallet.send(Object.assign(Object.assign({}, e), { id: s }));
      return o.then((a) => Sn("Wallet message received:", a)), (n = i == null ? void 0 : i.onRequestSent) === null || n === void 0 || n.call(i), o;
    });
  }
  _connect(e, r) {
    return Mt(this, void 0, void 0, function* () {
      try {
        Sn(`Injected Provider connect request: protocolVersion: ${e}, message:`, r);
        const n = yield this.injectedWallet.connect(e, r);
        Sn("Injected Provider connect response:", n), n.event === "connect" && (yield this.updateSession(), this.makeSubscriptions()), this.listeners.forEach((i) => i(n));
      } catch (n) {
        Sn("Injected Provider connect error:", n);
        const i = {
          event: "connect_error",
          payload: {
            code: 0,
            message: n == null ? void 0 : n.toString()
          }
        };
        this.listeners.forEach((s) => s(i));
      }
    });
  }
  makeSubscriptions() {
    this.listenSubscriptions = !0, this.unsubscribeCallback = this.injectedWallet.listen((e) => {
      Sn("Wallet message received:", e), this.listenSubscriptions && this.listeners.forEach((r) => r(e)), e.event === "disconnect" && this.disconnect();
    });
  }
  updateSession() {
    return this.connectionStorage.storeConnection({
      type: "injected",
      jsBridgeKey: this.injectedWalletKey,
      nextRpcRequestId: 0
    });
  }
}
mi.window = Cp();
class Lie {
  constructor() {
    this.localStorage = Die();
  }
  getItem(e) {
    return Mt(this, void 0, void 0, function* () {
      return this.localStorage.getItem(e);
    });
  }
  removeItem(e) {
    return Mt(this, void 0, void 0, function* () {
      this.localStorage.removeItem(e);
    });
  }
  setItem(e, r) {
    return Mt(this, void 0, void 0, function* () {
      this.localStorage.setItem(e, r);
    });
  }
}
function W9(t) {
  return $ie(t) && t.injected;
}
function kie(t) {
  return W9(t) && t.embedded;
}
function $ie(t) {
  return "jsBridgeKey" in t;
}
const Fie = [
  {
    app_name: "telegram-wallet",
    name: "Wallet",
    image: "https://wallet.tg/images/logo-288.png",
    about_url: "https://wallet.tg/",
    universal_url: "https://t.me/wallet?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://bridge.ton.space/bridge"
      }
    ],
    platforms: ["ios", "android", "macos", "windows", "linux"]
  },
  {
    app_name: "tonkeeper",
    name: "Tonkeeper",
    image: "https://tonkeeper.com/assets/tonconnect-icon.png",
    tondns: "tonkeeper.ton",
    about_url: "https://tonkeeper.com",
    universal_url: "https://app.tonkeeper.com/ton-connect",
    deepLink: "tonkeeper-tc://",
    bridge: [
      {
        type: "sse",
        url: "https://bridge.tonapi.io/bridge"
      },
      {
        type: "js",
        key: "tonkeeper"
      }
    ],
    platforms: ["ios", "android", "chrome", "firefox", "macos"]
  },
  {
    app_name: "mytonwallet",
    name: "MyTonWallet",
    image: "https://static.mytonwallet.io/icon-256.png",
    about_url: "https://mytonwallet.io",
    universal_url: "https://connect.mytonwallet.org",
    bridge: [
      {
        type: "js",
        key: "mytonwallet"
      },
      {
        type: "sse",
        url: "https://tonconnectbridge.mytonwallet.org/bridge/"
      }
    ],
    platforms: ["chrome", "windows", "macos", "linux", "ios", "android", "firefox"]
  },
  {
    app_name: "openmask",
    name: "OpenMask",
    image: "https://raw.githubusercontent.com/OpenProduct/openmask-extension/main/public/openmask-logo-288.png",
    about_url: "https://www.openmask.app/",
    bridge: [
      {
        type: "js",
        key: "openmask"
      }
    ],
    platforms: ["chrome"]
  },
  {
    app_name: "tonhub",
    name: "Tonhub",
    image: "https://tonhub.com/tonconnect_logo.png",
    about_url: "https://tonhub.com",
    universal_url: "https://tonhub.com/ton-connect",
    bridge: [
      {
        type: "js",
        key: "tonhub"
      },
      {
        type: "sse",
        url: "https://connect.tonhubapi.com/tonconnect"
      }
    ],
    platforms: ["ios", "android"]
  },
  {
    app_name: "dewallet",
    name: "DeWallet",
    image: "https://raw.githubusercontent.com/delab-team/manifests-images/main/WalletAvatar.png",
    about_url: "https://delabwallet.com",
    universal_url: "https://t.me/dewallet?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://sse-bridge.delab.team/bridge"
      }
    ],
    platforms: ["ios", "android"]
  },
  {
    app_name: "xtonwallet",
    name: "XTONWallet",
    image: "https://xtonwallet.com/assets/img/icon-256-back.png",
    about_url: "https://xtonwallet.com",
    bridge: [
      {
        type: "js",
        key: "xtonwallet"
      }
    ],
    platforms: ["chrome", "firefox"]
  },
  {
    app_name: "tonwallet",
    name: "TON Wallet",
    image: "https://wallet.ton.org/assets/ui/qr-logo.png",
    about_url: "https://chrome.google.com/webstore/detail/ton-wallet/nphplpgoakhhjchkkhmiggakijnkhfnd",
    bridge: [
      {
        type: "js",
        key: "tonwallet"
      }
    ],
    platforms: ["chrome"]
  },
  {
    app_name: "bitgetTonWallet",
    name: "Bitget Wallet",
    image: "https://raw.githubusercontent.com/bitkeepwallet/download/main/logo/png/bitget_wallet_logo_0_gas_fee.png",
    about_url: "https://web3.bitget.com",
    deepLink: "bitkeep://",
    bridge: [
      {
        type: "js",
        key: "bitgetTonWallet"
      },
      {
        type: "sse",
        url: "https://bridge.tonapi.io/bridge"
      }
    ],
    platforms: ["ios", "android", "chrome"],
    universal_url: "https://bkcode.vip/ton-connect"
  },
  {
    app_name: "safepalwallet",
    name: "SafePal",
    image: "https://s.pvcliping.com/web/public_image/SafePal_x288.png",
    tondns: "",
    about_url: "https://www.safepal.com",
    universal_url: "https://link.safepal.io/ton-connect",
    deepLink: "safepal-tc://",
    bridge: [
      {
        type: "sse",
        url: "https://ton-bridge.safepal.com/tonbridge/v1/bridge"
      },
      {
        type: "js",
        key: "safepalwallet"
      }
    ],
    platforms: ["ios", "android", "chrome", "firefox"]
  },
  {
    app_name: "okxTonWallet",
    name: "OKX Wallet",
    image: "https://static.okx.com/cdn/assets/imgs/247/58E63FEA47A2B7D7.png",
    about_url: "https://www.okx.com/web3",
    universal_url: "https://www.okx.com/download?appendQuery=true&deeplink=okx://web3/wallet/tonconnect",
    bridge: [
      {
        type: "js",
        key: "okxTonWallet"
      },
      {
        type: "sse",
        url: "https://www.okx.com/tonbridge/discover/rpc/bridge"
      }
    ],
    platforms: ["chrome", "safari", "firefox", "ios", "android"]
  },
  {
    app_name: "okxTonWalletTr",
    name: "OKX TR Wallet",
    image: "https://static.okx.com/cdn/assets/imgs/247/587A8296F0BB640F.png",
    about_url: "https://tr.okx.com/web3",
    universal_url: "https://tr.okx.com/download?appendQuery=true&deeplink=okxtr://web3/wallet/tonconnect",
    bridge: [
      {
        type: "js",
        key: "okxTonWallet"
      },
      {
        type: "sse",
        url: "https://www.okx.com/tonbridge/discover/rpc/bridge"
      }
    ],
    platforms: ["chrome", "safari", "firefox", "ios", "android"]
  }
];
class dv {
  constructor(e) {
    this.walletsListCache = null, this.walletsListCacheCreationTimestamp = null, this.walletsListSource = "https://raw.githubusercontent.com/ton-blockchain/wallets-list/main/wallets-v2.json", e != null && e.walletsListSource && (this.walletsListSource = e.walletsListSource), e != null && e.cacheTTLMs && (this.cacheTTLMs = e.cacheTTLMs);
  }
  getWallets() {
    return Mt(this, void 0, void 0, function* () {
      return this.cacheTTLMs && this.walletsListCacheCreationTimestamp && Date.now() > this.walletsListCacheCreationTimestamp + this.cacheTTLMs && (this.walletsListCache = null), this.walletsListCache || (this.walletsListCache = this.fetchWalletsList(), this.walletsListCache.then(() => {
        this.walletsListCacheCreationTimestamp = Date.now();
      }).catch(() => {
        this.walletsListCache = null, this.walletsListCacheCreationTimestamp = null;
      })), this.walletsListCache;
    });
  }
  getEmbeddedWallet() {
    return Mt(this, void 0, void 0, function* () {
      const r = (yield this.getWallets()).filter(kie);
      return r.length !== 1 ? null : r[0];
    });
  }
  fetchWalletsList() {
    return Mt(this, void 0, void 0, function* () {
      let e = [];
      try {
        if (e = yield (yield fetch(this.walletsListSource)).json(), !Array.isArray(e))
          throw new ly("Wrong wallets list format, wallets list must be an array.");
        const i = e.filter((s) => !this.isCorrectWalletConfigDTO(s));
        i.length && (Oo(`Wallet(s) ${i.map((s) => s.name).join(", ")} config format is wrong. They were removed from the wallets list.`), e = e.filter((s) => this.isCorrectWalletConfigDTO(s)));
      } catch (n) {
        Oo(n), e = Fie;
      }
      let r = [];
      try {
        r = mi.getCurrentlyInjectedWallets();
      } catch (n) {
        Oo(n);
      }
      return this.mergeWalletsLists(this.walletConfigDTOListToWalletConfigList(e), r);
    });
  }
  walletConfigDTOListToWalletConfigList(e) {
    return e.map((r) => {
      const i = {
        name: r.name,
        appName: r.app_name,
        imageUrl: r.image,
        aboutUrl: r.about_url,
        tondns: r.tondns,
        platforms: r.platforms
      };
      return r.bridge.forEach((s) => {
        if (s.type === "sse" && (i.bridgeUrl = s.url, i.universalLink = r.universal_url, i.deepLink = r.deepLink), s.type === "js") {
          const o = s.key;
          i.jsBridgeKey = o, i.injected = mi.isWalletInjected(o), i.embedded = mi.isInsideWalletBrowser(o);
        }
      }), i;
    });
  }
  mergeWalletsLists(e, r) {
    return [...new Set(e.concat(r).map((i) => i.name)).values()].map((i) => {
      const s = e.find((a) => a.name === i), o = r.find((a) => a.name === i);
      return Object.assign(Object.assign({}, s && Object.assign({}, s)), o && Object.assign({}, o));
    });
  }
  // eslint-disable-next-line complexity
  isCorrectWalletConfigDTO(e) {
    if (!e || typeof e != "object")
      return !1;
    const r = "name" in e, n = "app_name" in e, i = "image" in e, s = "about_url" in e, o = "platforms" in e;
    if (!r || !i || !s || !o || !n || !e.platforms || !Array.isArray(e.platforms) || !e.platforms.length || !("bridge" in e) || !Array.isArray(e.bridge) || !e.bridge.length)
      return !1;
    const a = e.bridge;
    if (a.some((d) => !d || typeof d != "object" || !("type" in d)))
      return !1;
    const u = a.find((d) => d.type === "sse");
    if (u && (!("url" in u) || !u.url || !e.universal_url))
      return !1;
    const l = a.find((d) => d.type === "js");
    return !(l && (!("key" in l) || !l.key));
  }
}
class P0 extends Ut {
  get info() {
    return "Wallet doesn't support requested feature method.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, P0.prototype);
  }
}
function Bie(t, e) {
  const r = t.includes("SendTransaction"), n = t.find((i) => i && typeof i == "object" && i.name === "SendTransaction");
  if (!r && !n)
    throw new P0("Wallet doesn't support SendTransaction feature.");
  if (n && n.maxMessages !== void 0) {
    if (n.maxMessages < e.requiredMessagesNumber)
      throw new P0(`Wallet is not able to handle such SendTransaction request. Max support messages number is ${n.maxMessages}, but ${e.requiredMessagesNumber} is required.`);
    return;
  }
  Sie("Connected wallet didn't provide information about max allowed messages in the SendTransaction request. Request may be rejected by the wallet.");
}
function Uie() {
  return {
    type: "request-version"
  };
}
function jie(t) {
  return {
    type: "response-version",
    version: t
  };
}
function Gu(t) {
  return {
    ton_connect_sdk_lib: t.ton_connect_sdk_lib,
    ton_connect_ui_lib: t.ton_connect_ui_lib
  };
}
function Yu(t, e) {
  var r, n, i, s, o, a, u, l;
  const p = ((r = e == null ? void 0 : e.connectItems) === null || r === void 0 ? void 0 : r.tonProof) && "proof" in e.connectItems.tonProof ? "ton_proof" : "ton_addr";
  return {
    wallet_address: (i = (n = e == null ? void 0 : e.account) === null || n === void 0 ? void 0 : n.address) !== null && i !== void 0 ? i : null,
    wallet_type: (s = e == null ? void 0 : e.device.appName) !== null && s !== void 0 ? s : null,
    wallet_version: (o = e == null ? void 0 : e.device.appVersion) !== null && o !== void 0 ? o : null,
    auth_type: p,
    custom_data: Object.assign({ chain_id: (u = (a = e == null ? void 0 : e.account) === null || a === void 0 ? void 0 : a.chain) !== null && u !== void 0 ? u : null, provider: (l = e == null ? void 0 : e.provider) !== null && l !== void 0 ? l : null }, Gu(t))
  };
}
function qie(t) {
  return {
    type: "connection-started",
    custom_data: Gu(t)
  };
}
function zie(t, e) {
  return Object.assign({ type: "connection-completed", is_success: !0 }, Yu(t, e));
}
function Hie(t, e, r) {
  return {
    type: "connection-error",
    is_success: !1,
    error_message: e,
    error_code: r ?? null,
    custom_data: Gu(t)
  };
}
function Wie(t) {
  return {
    type: "connection-restoring-started",
    custom_data: Gu(t)
  };
}
function Kie(t, e) {
  return Object.assign({ type: "connection-restoring-completed", is_success: !0 }, Yu(t, e));
}
function Vie(t, e) {
  return {
    type: "connection-restoring-error",
    is_success: !1,
    error_message: e,
    custom_data: Gu(t)
  };
}
function hy(t, e) {
  var r, n, i, s;
  return {
    valid_until: (r = String(e.validUntil)) !== null && r !== void 0 ? r : null,
    from: (s = (n = e.from) !== null && n !== void 0 ? n : (i = t == null ? void 0 : t.account) === null || i === void 0 ? void 0 : i.address) !== null && s !== void 0 ? s : null,
    messages: e.messages.map((o) => {
      var a, u;
      return {
        address: (a = o.address) !== null && a !== void 0 ? a : null,
        amount: (u = o.amount) !== null && u !== void 0 ? u : null
      };
    })
  };
}
function Gie(t, e, r) {
  return Object.assign(Object.assign({ type: "transaction-sent-for-signature" }, Yu(t, e)), hy(e, r));
}
function Yie(t, e, r, n) {
  return Object.assign(Object.assign({ type: "transaction-signed", is_success: !0, signed_transaction: n.boc }, Yu(t, e)), hy(e, r));
}
function Jie(t, e, r, n, i) {
  return Object.assign(Object.assign({ type: "transaction-signing-failed", is_success: !1, error_message: n, error_code: i ?? null }, Yu(t, e)), hy(e, r));
}
function Xie(t, e, r) {
  return Object.assign({ type: "disconnection", scope: r }, Yu(t, e));
}
class Zie {
  constructor() {
    this.window = Cp();
  }
  /**
   * Dispatches an event with the given name and details to the browser window.
   * @param eventName - The name of the event to dispatch.
   * @param eventDetails - The details of the event to dispatch.
   * @returns A promise that resolves when the event has been dispatched.
   */
  dispatchEvent(e, r) {
    var n;
    return Mt(this, void 0, void 0, function* () {
      const i = new CustomEvent(e, { detail: r });
      (n = this.window) === null || n === void 0 || n.dispatchEvent(i);
    });
  }
  /**
   * Adds an event listener to the browser window.
   * @param eventName - The name of the event to listen for.
   * @param listener - The listener to add.
   * @param options - The options for the listener.
   * @returns A function that removes the listener.
   */
  addEventListener(e, r, n) {
    var i;
    return Mt(this, void 0, void 0, function* () {
      return (i = this.window) === null || i === void 0 || i.addEventListener(e, r, n), () => {
        var s;
        return (s = this.window) === null || s === void 0 ? void 0 : s.removeEventListener(e, r);
      };
    });
  }
}
class Qie {
  constructor(e) {
    var r;
    this.eventPrefix = "ton-connect-", this.tonConnectUiVersion = null, this.eventDispatcher = (r = e == null ? void 0 : e.eventDispatcher) !== null && r !== void 0 ? r : new Zie(), this.tonConnectSdkVersion = e.tonConnectSdkVersion, this.init().catch();
  }
  /**
   * Version of the library.
   */
  get version() {
    return Gu({
      ton_connect_sdk_lib: this.tonConnectSdkVersion,
      ton_connect_ui_lib: this.tonConnectUiVersion
    });
  }
  /**
   * Called once when the tracker is created and request version other libraries.
   */
  init() {
    return Mt(this, void 0, void 0, function* () {
      try {
        yield this.setRequestVersionHandler(), this.tonConnectUiVersion = yield this.requestTonConnectUiVersion();
      } catch {
      }
    });
  }
  /**
   * Set request version handler.
   * @private
   */
  setRequestVersionHandler() {
    return Mt(this, void 0, void 0, function* () {
      yield this.eventDispatcher.addEventListener("ton-connect-request-version", () => Mt(this, void 0, void 0, function* () {
        yield this.eventDispatcher.dispatchEvent("ton-connect-response-version", jie(this.tonConnectSdkVersion));
      }));
    });
  }
  /**
   * Request TonConnect UI version.
   * @private
   */
  requestTonConnectUiVersion() {
    return Mt(this, void 0, void 0, function* () {
      return new Promise((e, r) => Mt(this, void 0, void 0, function* () {
        try {
          yield this.eventDispatcher.addEventListener("ton-connect-ui-response-version", (n) => {
            e(n.detail.version);
          }, { once: !0 }), yield this.eventDispatcher.dispatchEvent("ton-connect-ui-request-version", Uie());
        } catch (n) {
          r(n);
        }
      }));
    });
  }
  /**
   * Emit user action event to the window.
   * @param eventDetails
   * @private
   */
  dispatchUserActionEvent(e) {
    try {
      this.eventDispatcher.dispatchEvent(`${this.eventPrefix}${e.type}`, e).catch();
    } catch {
    }
  }
  /**
   * Track connection init event.
   * @param args
   */
  trackConnectionStarted(...e) {
    try {
      const r = qie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection success event.
   * @param args
   */
  trackConnectionCompleted(...e) {
    try {
      const r = zie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection error event.
   * @param args
   */
  trackConnectionError(...e) {
    try {
      const r = Hie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection restoring init event.
   * @param args
   */
  trackConnectionRestoringStarted(...e) {
    try {
      const r = Wie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection restoring success event.
   * @param args
   */
  trackConnectionRestoringCompleted(...e) {
    try {
      const r = Kie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection restoring error event.
   * @param args
   */
  trackConnectionRestoringError(...e) {
    try {
      const r = Vie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track disconnect event.
   * @param args
   */
  trackDisconnection(...e) {
    try {
      const r = Xie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track transaction init event.
   * @param args
   */
  trackTransactionSentForSignature(...e) {
    try {
      const r = Gie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track transaction signed event.
   * @param args
   */
  trackTransactionSigned(...e) {
    try {
      const r = Yie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track transaction error event.
   * @param args
   */
  trackTransactionSigningFailed(...e) {
    try {
      const r = Jie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
}
const ese = "3.0.5";
class Tp {
  constructor(e) {
    if (this.walletsList = new dv(), this._wallet = null, this.provider = null, this.statusChangeSubscriptions = [], this.statusChangeErrorSubscriptions = [], this.dappSettings = {
      manifestUrl: (e == null ? void 0 : e.manifestUrl) || Rie(),
      storage: (e == null ? void 0 : e.storage) || new Lie()
    }, this.walletsList = new dv({
      walletsListSource: e == null ? void 0 : e.walletsListSource,
      cacheTTLMs: e == null ? void 0 : e.walletsListCacheTTLMs
    }), this.tracker = new Qie({
      eventDispatcher: e == null ? void 0 : e.eventDispatcher,
      tonConnectSdkVersion: ese
    }), !this.dappSettings.manifestUrl)
      throw new cy("Dapp tonconnect-manifest.json must be specified if window.location.origin is undefined. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest");
    this.bridgeConnectionStorage = new Dl(this.dappSettings.storage), e != null && e.disableAutoPauseConnection || this.addWindowFocusAndBlurSubscriptions();
  }
  /**
   * Returns available wallets list.
   */
  static getWallets() {
    return this.walletsList.getWallets();
  }
  /**
   * Shows if the wallet is connected right now.
   */
  get connected() {
    return this._wallet !== null;
  }
  /**
   * Current connected account or null if no account is connected.
   */
  get account() {
    var e;
    return ((e = this._wallet) === null || e === void 0 ? void 0 : e.account) || null;
  }
  /**
   * Current connected wallet or null if no account is connected.
   */
  get wallet() {
    return this._wallet;
  }
  set wallet(e) {
    this._wallet = e, this.statusChangeSubscriptions.forEach((r) => r(this._wallet));
  }
  /**
   * Returns available wallets list.
   */
  getWallets() {
    return this.walletsList.getWallets();
  }
  /**
   * Allows to subscribe to connection status changes and handle connection errors.
   * @param callback will be called after connections status changes with actual wallet or null.
   * @param errorsHandler (optional) will be called with some instance of TonConnectError when connect error is received.
   * @returns unsubscribe callback.
   */
  onStatusChange(e, r) {
    return this.statusChangeSubscriptions.push(e), r && this.statusChangeErrorSubscriptions.push(r), () => {
      this.statusChangeSubscriptions = this.statusChangeSubscriptions.filter((n) => n !== e), r && (this.statusChangeErrorSubscriptions = this.statusChangeErrorSubscriptions.filter((n) => n !== r));
    };
  }
  connect(e, r) {
    var n, i;
    const s = {};
    if (typeof r == "object" && "tonProof" in r && (s.request = r), typeof r == "object" && ("openingDeadlineMS" in r || "signal" in r || "request" in r) && (s.request = r == null ? void 0 : r.request, s.openingDeadlineMS = r == null ? void 0 : r.openingDeadlineMS, s.signal = r == null ? void 0 : r.signal), this.connected)
      throw new uy();
    const o = xs(s == null ? void 0 : s.signal);
    if ((n = this.abortController) === null || n === void 0 || n.abort(), this.abortController = o, o.signal.aborted)
      throw new Ut("Connection was aborted");
    return (i = this.provider) === null || i === void 0 || i.closeConnection(), this.provider = this.createProvider(e), o.signal.addEventListener("abort", () => {
      var a;
      (a = this.provider) === null || a === void 0 || a.closeConnection(), this.provider = null;
    }), this.tracker.trackConnectionStarted(), this.provider.connect(this.createConnectRequest(s == null ? void 0 : s.request), {
      openingDeadlineMS: s == null ? void 0 : s.openingDeadlineMS,
      signal: o.signal
    });
  }
  /**
   * Try to restore existing session and reconnect to the corresponding wallet. Call it immediately when your app is loaded.
   */
  restoreConnection(e) {
    var r, n;
    return Mt(this, void 0, void 0, function* () {
      this.tracker.trackConnectionRestoringStarted();
      const i = xs(e == null ? void 0 : e.signal);
      if ((r = this.abortController) === null || r === void 0 || r.abort(), this.abortController = i, i.signal.aborted) {
        this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
        return;
      }
      const [s, o] = yield Promise.all([
        this.bridgeConnectionStorage.storedConnectionType(),
        this.walletsList.getEmbeddedWallet()
      ]);
      if (i.signal.aborted) {
        this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
        return;
      }
      let a = null;
      try {
        switch (s) {
          case "http":
            a = yield Ol.fromStorage(this.dappSettings.storage);
            break;
          case "injected":
            a = yield mi.fromStorage(this.dappSettings.storage);
            break;
          default:
            if (o)
              a = this.createProvider(o);
            else
              return;
        }
      } catch {
        this.tracker.trackConnectionRestoringError("Provider is not restored"), yield this.bridgeConnectionStorage.removeConnection(), a == null || a.closeConnection(), a = null;
        return;
      }
      if (i.signal.aborted) {
        a == null || a.closeConnection(), this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
        return;
      }
      if (!a) {
        Oo("Provider is not restored"), this.tracker.trackConnectionRestoringError("Provider is not restored");
        return;
      }
      (n = this.provider) === null || n === void 0 || n.closeConnection(), this.provider = a, a.listen(this.walletEventsListener.bind(this));
      const u = () => {
        this.tracker.trackConnectionRestoringError("Connection restoring was aborted"), a == null || a.closeConnection(), a = null;
      };
      i.signal.addEventListener("abort", u);
      const l = Xf((p) => Mt(this, void 0, void 0, function* () {
        yield a == null ? void 0 : a.restoreConnection({
          openingDeadlineMS: e == null ? void 0 : e.openingDeadlineMS,
          signal: p.signal
        }), i.signal.removeEventListener("abort", u), this.connected ? this.tracker.trackConnectionRestoringCompleted(this.wallet) : this.tracker.trackConnectionRestoringError("Connection restoring failed");
      }), {
        attempts: Number.MAX_SAFE_INTEGER,
        delayMs: 2e3,
        signal: e == null ? void 0 : e.signal
      }), d = new Promise(
        (p) => setTimeout(() => p(), 12e3)
        // connection deadline
      );
      return Promise.race([l, d]);
    });
  }
  sendTransaction(e, r) {
    return Mt(this, void 0, void 0, function* () {
      const n = {};
      typeof r == "function" ? n.onRequestSent = r : (n.onRequestSent = r == null ? void 0 : r.onRequestSent, n.signal = r == null ? void 0 : r.signal);
      const i = xs(n == null ? void 0 : n.signal);
      if (i.signal.aborted)
        throw new Ut("Transaction sending was aborted");
      this.checkConnection(), Bie(this.wallet.device.features, {
        requiredMessagesNumber: e.messages.length
      }), this.tracker.trackTransactionSentForSignature(this.wallet, e);
      const { validUntil: s } = e, o = pie(e, ["validUntil"]), a = e.from || this.account.address, u = e.network || this.account.chain, l = yield this.provider.sendRequest(yd.convertToRpcRequest(Object.assign(Object.assign({}, o), {
        valid_until: s,
        from: a,
        network: u
      })), { onRequestSent: n.onRequestSent, signal: i.signal });
      if (yd.isError(l))
        return this.tracker.trackTransactionSigningFailed(this.wallet, e, l.error.message, l.error.code), yd.parseAndThrowError(l);
      const d = yd.convertFromRpcResponse(l);
      return this.tracker.trackTransactionSigned(this.wallet, e, d), d;
    });
  }
  /**
   * Disconnect form thw connected wallet and drop current session.
   */
  disconnect(e) {
    var r;
    return Mt(this, void 0, void 0, function* () {
      if (!this.connected)
        throw new A0();
      const n = xs(e == null ? void 0 : e.signal), i = this.abortController;
      if (this.abortController = n, n.signal.aborted)
        throw new Ut("Disconnect was aborted");
      this.onWalletDisconnected("dapp"), yield (r = this.provider) === null || r === void 0 ? void 0 : r.disconnect({
        signal: n.signal
      }), i == null || i.abort();
    });
  }
  /**
   * Pause bridge HTTP connection. Might be helpful, if you want to pause connections while browser tab is unfocused,
   * or if you use SDK with NodeJS and want to save server resources.
   */
  pauseConnection() {
    var e;
    ((e = this.provider) === null || e === void 0 ? void 0 : e.type) === "http" && this.provider.pause();
  }
  /**
   * Unpause bridge HTTP connection if it is paused.
   */
  unPauseConnection() {
    var e;
    return ((e = this.provider) === null || e === void 0 ? void 0 : e.type) !== "http" ? Promise.resolve() : this.provider.unPause();
  }
  addWindowFocusAndBlurSubscriptions() {
    const e = Tie();
    if (e)
      try {
        e.addEventListener("visibilitychange", () => {
          e.hidden ? this.pauseConnection() : this.unPauseConnection().catch();
        });
      } catch (r) {
        Oo("Cannot subscribe to the document.visibilitychange: ", r);
      }
  }
  createProvider(e) {
    let r;
    return !Array.isArray(e) && gie(e) ? r = new mi(this.dappSettings.storage, e.jsBridgeKey) : r = new Ol(this.dappSettings.storage, e), r.listen(this.walletEventsListener.bind(this)), r;
  }
  walletEventsListener(e) {
    switch (e.event) {
      case "connect":
        this.onWalletConnected(e.payload);
        break;
      case "connect_error":
        this.onWalletConnectError(e.payload);
        break;
      case "disconnect":
        this.onWalletDisconnected("wallet");
    }
  }
  onWalletConnected(e) {
    const r = e.items.find((s) => s.name === "ton_addr"), n = e.items.find((s) => s.name === "ton_proof");
    if (!r)
      throw new Ut("ton_addr connection item was not found");
    const i = {
      device: e.device,
      provider: this.provider.type,
      account: {
        address: r.address,
        chain: r.network,
        walletStateInit: r.walletStateInit,
        publicKey: r.publicKey
      }
    };
    n && (i.connectItems = {
      tonProof: n
    }), this.wallet = i, this.tracker.trackConnectionCompleted(i);
  }
  onWalletConnectError(e) {
    const r = vie.parseError(e);
    if (this.statusChangeErrorSubscriptions.forEach((n) => n(r)), Sn(r), this.tracker.trackConnectionError(e.message, e.code), r instanceof Ap || r instanceof Sp)
      throw Oo(r), r;
  }
  onWalletDisconnected(e) {
    this.tracker.trackDisconnection(this.wallet, e), this.wallet = null;
  }
  checkConnection() {
    if (!this.connected)
      throw new A0();
  }
  createConnectRequest(e) {
    const r = [
      {
        name: "ton_addr"
      }
    ];
    return e != null && e.tonProof && r.push({
      name: "ton_proof",
      payload: e.tonProof
    }), {
      manifestUrl: this.dappSettings.manifestUrl,
      items: r
    };
  }
}
Tp.walletsList = new dv();
Tp.isWalletInjected = (t) => mi.isWalletInjected(t);
Tp.isInsideWalletBrowser = (t) => mi.isInsideWalletBrowser(t);
for (let t = 0; t <= 255; t++) {
  let e = t.toString(16);
  e.length < 2 && (e = "0" + e);
}
function Gm(t) {
  const { children: e, onClick: r } = t;
  return /* @__PURE__ */ me.jsx("button", { onClick: r, className: "xc-border xc-px-4 xc-py-2 xc-rounded-full xc-text-sm xc-flex xc-gap-2 xc-items-center", children: e });
}
function tse(t) {
  const { wallet: e, connector: r, loading: n } = t, i = bi(null), s = bi(), [o, a] = fr(), [u, l] = fr(), [d, p] = fr("connect"), [w, P] = fr(!1), [A, N] = fr();
  function L(W) {
    var pe;
    (pe = s.current) == null || pe.update({
      data: W
    });
  }
  async function F() {
    P(!0);
    try {
      a("");
      const W = await ya.getNonce({ account_type: "block_chain" });
      if ("universalLink" in e && e.universalLink) {
        const pe = r.connect({
          universalLink: e.universalLink,
          bridgeUrl: e.bridgeUrl
        }, {
          request: { tonProof: W }
        });
        if (!pe) return;
        N(pe), L(pe), l(W);
      }
    } catch (W) {
      a(W.message);
    }
    P(!1);
  }
  function $() {
    s.current = new L9({
      width: 264,
      height: 264,
      margin: 0,
      type: "svg",
      qrOptions: {
        errorCorrectionLevel: "M"
      },
      dotsOptions: {
        color: "black",
        type: "rounded"
      },
      backgroundOptions: {
        color: "transparent"
      }
    }), s.current.append(i.current);
  }
  function K() {
    r.connect(e, {
      request: { tonProof: u }
    });
  }
  function H() {
    if ("deepLink" in e) {
      if (!e.deepLink || !A) return;
      const W = new URL(A), pe = `${e.deepLink}${W.search}`;
      window.open(pe);
    }
  }
  function V() {
    "universalLink" in e && e.universalLink && /t.me/.test(e.universalLink) && window.open(A);
  }
  const te = Oi(() => !!("deepLink" in e && e.deepLink), [e]), R = Oi(() => !!("universalLink" in e && e.universalLink && /t.me/.test(e.universalLink)), [e]);
  return Xn(() => {
    $(), F();
  }, []), /* @__PURE__ */ me.jsxs(Ac, { children: [
    /* @__PURE__ */ me.jsx("div", { className: "xc-mb-6", children: /* @__PURE__ */ me.jsx(uh, { title: "Connect wallet", onBack: t.onBack }) }),
    /* @__PURE__ */ me.jsxs("div", { className: "xc-text-center xc-mb-6", children: [
      /* @__PURE__ */ me.jsxs("div", { className: "xc-relative xc-mx-auto xc-mb-6 xc-block xc-max-h-[272px] xc-max-w-[272px] xc-rounded-xl xc-bg-white xc-p-1", children: [
        /* @__PURE__ */ me.jsx("div", { className: "xc-aspect-[1/1] xc-flex xc-h-full xc-w-full xc-justify-center", ref: i }),
        /* @__PURE__ */ me.jsx("div", { className: "xc-absolute xc-left-0 xc-top-0 xc-flex xc-h-full xc-w-full xc-items-center xc-justify-center", children: w ? /* @__PURE__ */ me.jsx(gc, { className: "xc-h-6 xc-w-6 xc-animate-spin xc-text-black", size: 20 }) : /* @__PURE__ */ me.jsx("img", { className: "xc-h-10 xc-w-10 xc-rounded-md", src: e.imageUrl }) })
      ] }),
      /* @__PURE__ */ me.jsx("p", { className: "xc-text-center", children: "Scan the QR code below with your phone's camera. " })
    ] }),
    /* @__PURE__ */ me.jsxs("div", { className: "xc-flex xc-justify-center xc-gap-2", children: [
      n && /* @__PURE__ */ me.jsx(gc, { className: "xc-animate-spin" }),
      !w && !n && /* @__PURE__ */ me.jsxs(me.Fragment, { children: [
        W9(e) && /* @__PURE__ */ me.jsxs(Gm, { onClick: K, children: [
          /* @__PURE__ */ me.jsx(iZ, { className: "xc-opacity-80" }),
          "Extension"
        ] }),
        te && /* @__PURE__ */ me.jsxs(Gm, { onClick: H, children: [
          /* @__PURE__ */ me.jsx(HS, { className: "xc-opacity-80" }),
          "Desktop"
        ] }),
        R && /* @__PURE__ */ me.jsx(Gm, { onClick: V, children: "Telegram Mini App" })
      ] })
    ] })
  ] });
}
function rse(t) {
  const [e, r] = fr(""), [n, i] = fr(), [s, o] = fr(), a = ay(), [u, l] = fr(!1);
  async function d(w) {
    var A, N;
    if (!w || !((A = w.connectItems) != null && A.tonProof)) return;
    l(!0);
    const P = await ya.tonLogin({
      account_type: "block_chain",
      connector: "codatta_ton",
      account_enum: "C",
      wallet_name: w == null ? void 0 : w.device.appName,
      inviter_code: a.inviterCode,
      address: w.account.address,
      chain: w.account.chain,
      connect_info: [
        { name: "ton_addr", network: w.account.chain, ...w.account },
        (N = w.connectItems) == null ? void 0 : N.tonProof
      ],
      source: {
        device: a.device,
        channel: a.channel,
        app: a.app
      },
      related_info: a.relateInfo
    });
    await t.onLogin(P.data), l(!1);
  }
  Xn(() => {
    const w = new Tp({
      manifestUrl: "https://static.codatta.io/static/tonconnect-manifest.json?v=2"
    }), P = w.onStatusChange(d);
    return o(w), r("select"), P;
  }, []);
  function p(w) {
    r("connect"), i(w);
  }
  return /* @__PURE__ */ me.jsxs(Ac, { children: [
    e === "select" && /* @__PURE__ */ me.jsx(
      sie,
      {
        connector: s,
        onSelect: p,
        onBack: t.onBack
      }
    ),
    e === "connect" && /* @__PURE__ */ me.jsx(
      tse,
      {
        connector: s,
        wallet: n,
        onBack: t.onBack,
        loading: u
      }
    )
  ] });
}
function nse(t) {
  const { children: e, className: r } = t, n = bi(null), [i, s] = pv.useState(0);
  function o() {
    var a;
    try {
      const u = ((a = n.current) == null ? void 0 : a.children) || [];
      let l = 0;
      for (let d = 0; d < u.length; d++)
        l += u[d].offsetHeight;
      s(l);
    } catch (u) {
      console.error(u);
    }
  }
  return Xn(() => {
    const a = new MutationObserver(o);
    return a.observe(n.current, { childList: !0, subtree: !0 }), () => a.disconnect();
  }, []), Xn(() => {
    console.log("maxHeight", i);
  }, [i]), /* @__PURE__ */ me.jsx(
    "div",
    {
      ref: n,
      className: r,
      style: {
        transition: "all 0.2s ease-in-out",
        overflow: "hidden",
        height: i
      },
      children: e
    }
  );
}
function ise() {
  return /* @__PURE__ */ me.jsxs("svg", { width: "121", height: "120", viewBox: "0 0 121 120", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ me.jsx("rect", { x: "0.5", width: "120", height: "120", rx: "60", fill: "#404049" }),
    /* @__PURE__ */ me.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M52.8709 61.106C52.8208 61.4482 52.7948 61.7979 52.7948 62.1535C52.7948 66.2529 56.2445 69.5761 60.5 69.5761C64.7554 69.5761 68.2052 66.2529 68.2052 62.1535C68.2052 61.7979 68.1792 61.4482 68.129 61.106H86.826V77.6174C86.826 78.6422 85.9636 79.473 84.8997 79.473H36.1002C35.0364 79.473 34.174 78.6422 34.174 77.6174V61.106H52.8709Z", fill: "#252532" }),
    /* @__PURE__ */ me.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M69.061 60.9416C69.061 65.6697 65.2281 69.5026 60.5 69.5026C55.7719 69.5026 51.939 65.6697 51.939 60.9416C51.939 60.7884 51.943 60.6362 51.951 60.485H33.5L39.7959 41.8696C40.0673 41.0671 40.8202 40.527 41.6674 40.527H79.3326C80.1798 40.527 80.9327 41.0671 81.2041 41.8696L87.5 60.485H69.049C69.057 60.6362 69.061 60.7884 69.061 60.9416Z", fill: "#252532" }),
    /* @__PURE__ */ me.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M67.8081 61.5708C67.8081 65.2243 64.5361 68.8446 60.4999 68.8446C56.4637 68.8446 53.1918 65.2243 53.1918 61.5708C53.1918 61.4524 53.1952 60.6762 53.202 60.5594H39.4268L44.8013 47.4919C45.033 46.8717 45.6757 46.4543 46.3989 46.4543H74.601C75.3242 46.4543 75.9669 46.8717 76.1986 47.4919L81.5731 60.5594H67.7979C67.8046 60.6762 67.8081 61.4524 67.8081 61.5708Z", fill: "#404049" }),
    /* @__PURE__ */ me.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M34.3232 60.6199V78.063C34.3232 78.6995 34.8392 79.2155 35.4757 79.2155H85.5245C86.1609 79.2155 86.6769 78.6995 86.6769 78.063V60.6199L80.4244 42.1328C80.2661 41.6647 79.8269 41.3496 79.3327 41.3496H41.6674C41.1733 41.3496 40.7341 41.6647 40.5758 42.1328L34.3232 60.6199Z", stroke: "#77777D", "stroke-width": "2" }),
    /* @__PURE__ */ me.jsx("path", { d: "M34.817 60.2823C37.4094 60.2823 48.1095 60.2823 51.1124 60.2823C52.348 60.2823 52.348 61.1507 52.348 61.5994C52.348 65.9638 55.9675 69.5019 60.4323 69.5019C64.8971 69.5019 68.5165 65.9638 68.5165 61.5994C68.5165 61.1507 68.5165 60.2823 69.7521 60.2823H86.1829", stroke: "#77777D", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" })
  ] });
}
function sse(t) {
  const { wallets: e } = gp(), [r, n] = fr(), i = Oi(() => r ? e.filter((a) => a.key.toLowerCase().includes(r.toLowerCase())) : e, [r]);
  function s(a) {
    t.onSelectWallet(a);
  }
  function o(a) {
    n(a.target.value);
  }
  return /* @__PURE__ */ me.jsxs(Ac, { children: [
    /* @__PURE__ */ me.jsx("div", { className: "xc-mb-6", children: /* @__PURE__ */ me.jsx(uh, { title: "Select wallet", onBack: t.onBack }) }),
    /* @__PURE__ */ me.jsxs("div", { className: "xc-mb-6 xc-flex xc-gap-3 xc-px-4 xc-py-2 xc-border xc-rounded-xl xc-w-full xc-overflow-hidden xc-items-center xc-border-opacity-15 xc-border-white focus-within:xc-border-opacity-40", children: [
      /* @__PURE__ */ me.jsx(WS, { className: "xc-shrink-0 xc-opacity-50" }),
      /* @__PURE__ */ me.jsx("input", { type: "text", className: "xc-flex-1 xc-bg-transparent xc-appearance-none xc-outline-none", placeholder: "Search wallet", onInput: o })
    ] }),
    /* @__PURE__ */ me.jsx("div", { className: "xc-mb-4 xc-flex xc-h-[309px] xc-flex-col xc-gap-4 xc-overflow-scroll no-scrollbar", children: i.length ? i.map((a) => /* @__PURE__ */ me.jsx(
      b9,
      {
        wallet: a,
        onClick: s
      },
      `feature-${a.key}`
    )) : /* @__PURE__ */ me.jsx(ise, {}) })
  ] });
}
function doe(t) {
  const { onLogin: e, header: r, showEmailSignIn: n = !0, showMoreWallets: i = !0, showTonConnect: s = !0, showFeaturedWallets: o = !0 } = t, [a, u] = fr(""), [l, d] = fr(null), [p, w] = fr("");
  function P(F) {
    d(F), u("evm-wallet");
  }
  function A(F) {
    u("email"), w(F);
  }
  async function N(F) {
    await e(F);
  }
  function L() {
    u("ton-wallet");
  }
  return Xn(() => {
    u("index");
  }, []), /* @__PURE__ */ me.jsx(Dne, { config: t.config, children: /* @__PURE__ */ me.jsxs(nse, { className: "xc-rounded-2xl xc-transition-height xc-box-content xc-w-full xc-min-w-[277px] xc-max-w-[420px] xc-p-6 xc-bg-[rgb(28,28,38)] xc-text-white", children: [
    a === "evm-wallet" && /* @__PURE__ */ me.jsx(
      nie,
      {
        onBack: () => u("index"),
        onLogin: N,
        wallet: l
      }
    ),
    a === "ton-wallet" && /* @__PURE__ */ me.jsx(
      rse,
      {
        onBack: () => u("index"),
        onLogin: N
      }
    ),
    a === "email" && /* @__PURE__ */ me.jsx(One, { email: p, onBack: () => u("index"), onLogin: N }),
    a === "index" && /* @__PURE__ */ me.jsx(
      vne,
      {
        header: r,
        onEmailConfirm: A,
        onSelectWallet: P,
        onSelectMoreWallets: () => {
          u("all-wallet");
        },
        onSelectTonConnect: L,
        config: {
          showEmailSignIn: n,
          showFeaturedWallets: o,
          showMoreWallets: i,
          showTonConnect: s
        }
      }
    ),
    a === "all-wallet" && /* @__PURE__ */ me.jsx(
      sse,
      {
        onBack: () => u("index"),
        onSelectWallet: P
      }
    )
  ] }) });
}
export {
  loe as C,
  M5 as H,
  JX as a,
  Nl as b,
  use as c,
  doe as d,
  Hd as e,
  cse as h,
  fse as r,
  r4 as s,
  I0 as t,
  gp as u
};
