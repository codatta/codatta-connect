var cD = Object.defineProperty;
var uD = (t, e, r) => e in t ? cD(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var vs = (t, e, r) => uD(t, typeof e != "symbol" ? e + "" : e, r);
import * as Gt from "react";
import Rv, { createContext as Ta, useContext as Tn, useState as Yt, useEffect as Dn, forwardRef as Dv, createElement as e0, useId as Ov, useCallback as Nv, Component as fD, useLayoutEffect as lD, useRef as Qn, useInsertionEffect as L5, useMemo as wi, Fragment as k5, Children as hD, isValidElement as dD } from "react";
import "https://o.alicdn.com/captcha-frontend/aliyunCaptcha/AliyunCaptcha.js";
var gn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ns(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function Lv(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(t, n);
    Object.defineProperty(r, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[n];
      }
    });
  }), r;
}
var u1 = { exports: {} }, _f = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var I2;
function pD() {
  if (I2) return _f;
  I2 = 1;
  var t = Rv, e = Symbol.for("react.element"), r = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(a, u, l) {
    var d, p = {}, w = null, _ = null;
    l !== void 0 && (w = "" + l), u.key !== void 0 && (w = "" + u.key), u.ref !== void 0 && (_ = u.ref);
    for (d in u) n.call(u, d) && !s.hasOwnProperty(d) && (p[d] = u[d]);
    if (a && a.defaultProps) for (d in u = a.defaultProps, u) p[d] === void 0 && (p[d] = u[d]);
    return { $$typeof: e, type: a, key: w, ref: _, props: p, _owner: i.current };
  }
  return _f.Fragment = r, _f.jsx = o, _f.jsxs = o, _f;
}
var Ef = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var C2;
function gD() {
  return C2 || (C2 = 1, process.env.NODE_ENV !== "production" && function() {
    var t = Rv, e = Symbol.for("react.element"), r = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), a = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), w = Symbol.for("react.lazy"), _ = Symbol.for("react.offscreen"), P = Symbol.iterator, O = "@@iterator";
    function L(j) {
      if (j === null || typeof j != "object")
        return null;
      var se = P && j[P] || j[O];
      return typeof se == "function" ? se : null;
    }
    var B = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function k(j) {
      {
        for (var se = arguments.length, de = new Array(se > 1 ? se - 1 : 0), xe = 1; xe < se; xe++)
          de[xe - 1] = arguments[xe];
        q("error", j, de);
      }
    }
    function q(j, se, de) {
      {
        var xe = B.ReactDebugCurrentFrame, Te = xe.getStackAddendum();
        Te !== "" && (se += "%s", de = de.concat([Te]));
        var Re = de.map(function(nt) {
          return String(nt);
        });
        Re.unshift("Warning: " + se), Function.prototype.apply.call(console[j], console, Re);
      }
    }
    var U = !1, V = !1, Q = !1, R = !1, K = !1, ge;
    ge = Symbol.for("react.module.reference");
    function Ee(j) {
      return !!(typeof j == "string" || typeof j == "function" || j === n || j === s || K || j === i || j === l || j === d || R || j === _ || U || V || Q || typeof j == "object" && j !== null && (j.$$typeof === w || j.$$typeof === p || j.$$typeof === o || j.$$typeof === a || j.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      j.$$typeof === ge || j.getModuleId !== void 0));
    }
    function Y(j, se, de) {
      var xe = j.displayName;
      if (xe)
        return xe;
      var Te = se.displayName || se.name || "";
      return Te !== "" ? de + "(" + Te + ")" : de;
    }
    function A(j) {
      return j.displayName || "Context";
    }
    function m(j) {
      if (j == null)
        return null;
      if (typeof j.tag == "number" && k("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof j == "function")
        return j.displayName || j.name || null;
      if (typeof j == "string")
        return j;
      switch (j) {
        case n:
          return "Fragment";
        case r:
          return "Portal";
        case s:
          return "Profiler";
        case i:
          return "StrictMode";
        case l:
          return "Suspense";
        case d:
          return "SuspenseList";
      }
      if (typeof j == "object")
        switch (j.$$typeof) {
          case a:
            var se = j;
            return A(se) + ".Consumer";
          case o:
            var de = j;
            return A(de._context) + ".Provider";
          case u:
            return Y(j, j.render, "ForwardRef");
          case p:
            var xe = j.displayName || null;
            return xe !== null ? xe : m(j.type) || "Memo";
          case w: {
            var Te = j, Re = Te._payload, nt = Te._init;
            try {
              return m(nt(Re));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var f = Object.assign, g = 0, b, x, E, S, v, M, I;
    function F() {
    }
    F.__reactDisabledLog = !0;
    function ce() {
      {
        if (g === 0) {
          b = console.log, x = console.info, E = console.warn, S = console.error, v = console.group, M = console.groupCollapsed, I = console.groupEnd;
          var j = {
            configurable: !0,
            enumerable: !0,
            value: F,
            writable: !0
          };
          Object.defineProperties(console, {
            info: j,
            log: j,
            warn: j,
            error: j,
            group: j,
            groupCollapsed: j,
            groupEnd: j
          });
        }
        g++;
      }
    }
    function D() {
      {
        if (g--, g === 0) {
          var j = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: f({}, j, {
              value: b
            }),
            info: f({}, j, {
              value: x
            }),
            warn: f({}, j, {
              value: E
            }),
            error: f({}, j, {
              value: S
            }),
            group: f({}, j, {
              value: v
            }),
            groupCollapsed: f({}, j, {
              value: M
            }),
            groupEnd: f({}, j, {
              value: I
            })
          });
        }
        g < 0 && k("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var oe = B.ReactCurrentDispatcher, Z;
    function J(j, se, de) {
      {
        if (Z === void 0)
          try {
            throw Error();
          } catch (Te) {
            var xe = Te.stack.trim().match(/\n( *(at )?)/);
            Z = xe && xe[1] || "";
          }
        return `
` + Z + j;
      }
    }
    var ee = !1, T;
    {
      var X = typeof WeakMap == "function" ? WeakMap : Map;
      T = new X();
    }
    function re(j, se) {
      if (!j || ee)
        return "";
      {
        var de = T.get(j);
        if (de !== void 0)
          return de;
      }
      var xe;
      ee = !0;
      var Te = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Re;
      Re = oe.current, oe.current = null, ce();
      try {
        if (se) {
          var nt = function() {
            throw Error();
          };
          if (Object.defineProperty(nt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(nt, []);
            } catch (_t) {
              xe = _t;
            }
            Reflect.construct(j, [], nt);
          } else {
            try {
              nt.call();
            } catch (_t) {
              xe = _t;
            }
            j.call(nt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (_t) {
            xe = _t;
          }
          j();
        }
      } catch (_t) {
        if (_t && xe && typeof _t.stack == "string") {
          for (var je = _t.stack.split(`
`), pt = xe.stack.split(`
`), it = je.length - 1, et = pt.length - 1; it >= 1 && et >= 0 && je[it] !== pt[et]; )
            et--;
          for (; it >= 1 && et >= 0; it--, et--)
            if (je[it] !== pt[et]) {
              if (it !== 1 || et !== 1)
                do
                  if (it--, et--, et < 0 || je[it] !== pt[et]) {
                    var St = `
` + je[it].replace(" at new ", " at ");
                    return j.displayName && St.includes("<anonymous>") && (St = St.replace("<anonymous>", j.displayName)), typeof j == "function" && T.set(j, St), St;
                  }
                while (it >= 1 && et >= 0);
              break;
            }
        }
      } finally {
        ee = !1, oe.current = Re, D(), Error.prepareStackTrace = Te;
      }
      var Tt = j ? j.displayName || j.name : "", At = Tt ? J(Tt) : "";
      return typeof j == "function" && T.set(j, At), At;
    }
    function pe(j, se, de) {
      return re(j, !1);
    }
    function ie(j) {
      var se = j.prototype;
      return !!(se && se.isReactComponent);
    }
    function ue(j, se, de) {
      if (j == null)
        return "";
      if (typeof j == "function")
        return re(j, ie(j));
      if (typeof j == "string")
        return J(j);
      switch (j) {
        case l:
          return J("Suspense");
        case d:
          return J("SuspenseList");
      }
      if (typeof j == "object")
        switch (j.$$typeof) {
          case u:
            return pe(j.render);
          case p:
            return ue(j.type, se, de);
          case w: {
            var xe = j, Te = xe._payload, Re = xe._init;
            try {
              return ue(Re(Te), se, de);
            } catch {
            }
          }
        }
      return "";
    }
    var ve = Object.prototype.hasOwnProperty, Pe = {}, De = B.ReactDebugCurrentFrame;
    function Ce(j) {
      if (j) {
        var se = j._owner, de = ue(j.type, j._source, se ? se.type : null);
        De.setExtraStackFrame(de);
      } else
        De.setExtraStackFrame(null);
    }
    function $e(j, se, de, xe, Te) {
      {
        var Re = Function.call.bind(ve);
        for (var nt in j)
          if (Re(j, nt)) {
            var je = void 0;
            try {
              if (typeof j[nt] != "function") {
                var pt = Error((xe || "React class") + ": " + de + " type `" + nt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof j[nt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw pt.name = "Invariant Violation", pt;
              }
              je = j[nt](se, nt, xe, de, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (it) {
              je = it;
            }
            je && !(je instanceof Error) && (Ce(Te), k("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", xe || "React class", de, nt, typeof je), Ce(null)), je instanceof Error && !(je.message in Pe) && (Pe[je.message] = !0, Ce(Te), k("Failed %s type: %s", de, je.message), Ce(null));
          }
      }
    }
    var Me = Array.isArray;
    function Ne(j) {
      return Me(j);
    }
    function Ke(j) {
      {
        var se = typeof Symbol == "function" && Symbol.toStringTag, de = se && j[Symbol.toStringTag] || j.constructor.name || "Object";
        return de;
      }
    }
    function Le(j) {
      try {
        return qe(j), !1;
      } catch {
        return !0;
      }
    }
    function qe(j) {
      return "" + j;
    }
    function ze(j) {
      if (Le(j))
        return k("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ke(j)), qe(j);
    }
    var _e = B.ReactCurrentOwner, Ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, at, ke, Qe;
    Qe = {};
    function tt(j) {
      if (ve.call(j, "ref")) {
        var se = Object.getOwnPropertyDescriptor(j, "ref").get;
        if (se && se.isReactWarning)
          return !1;
      }
      return j.ref !== void 0;
    }
    function Ye(j) {
      if (ve.call(j, "key")) {
        var se = Object.getOwnPropertyDescriptor(j, "key").get;
        if (se && se.isReactWarning)
          return !1;
      }
      return j.key !== void 0;
    }
    function dt(j, se) {
      if (typeof j.ref == "string" && _e.current && se && _e.current.stateNode !== se) {
        var de = m(_e.current.type);
        Qe[de] || (k('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', m(_e.current.type), j.ref), Qe[de] = !0);
      }
    }
    function lt(j, se) {
      {
        var de = function() {
          at || (at = !0, k("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", se));
        };
        de.isReactWarning = !0, Object.defineProperty(j, "key", {
          get: de,
          configurable: !0
        });
      }
    }
    function ct(j, se) {
      {
        var de = function() {
          ke || (ke = !0, k("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", se));
        };
        de.isReactWarning = !0, Object.defineProperty(j, "ref", {
          get: de,
          configurable: !0
        });
      }
    }
    var qt = function(j, se, de, xe, Te, Re, nt) {
      var je = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: j,
        key: se,
        ref: de,
        props: nt,
        // Record the component responsible for creating this element.
        _owner: Re
      };
      return je._store = {}, Object.defineProperty(je._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(je, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: xe
      }), Object.defineProperty(je, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Te
      }), Object.freeze && (Object.freeze(je.props), Object.freeze(je)), je;
    };
    function Jt(j, se, de, xe, Te) {
      {
        var Re, nt = {}, je = null, pt = null;
        de !== void 0 && (ze(de), je = "" + de), Ye(se) && (ze(se.key), je = "" + se.key), tt(se) && (pt = se.ref, dt(se, Te));
        for (Re in se)
          ve.call(se, Re) && !Ze.hasOwnProperty(Re) && (nt[Re] = se[Re]);
        if (j && j.defaultProps) {
          var it = j.defaultProps;
          for (Re in it)
            nt[Re] === void 0 && (nt[Re] = it[Re]);
        }
        if (je || pt) {
          var et = typeof j == "function" ? j.displayName || j.name || "Unknown" : j;
          je && lt(nt, et), pt && ct(nt, et);
        }
        return qt(j, je, pt, Te, xe, _e.current, nt);
      }
    }
    var Et = B.ReactCurrentOwner, er = B.ReactDebugCurrentFrame;
    function Xt(j) {
      if (j) {
        var se = j._owner, de = ue(j.type, j._source, se ? se.type : null);
        er.setExtraStackFrame(de);
      } else
        er.setExtraStackFrame(null);
    }
    var Dt;
    Dt = !1;
    function kt(j) {
      return typeof j == "object" && j !== null && j.$$typeof === e;
    }
    function Ct() {
      {
        if (Et.current) {
          var j = m(Et.current.type);
          if (j)
            return `

Check the render method of \`` + j + "`.";
        }
        return "";
      }
    }
    function mt(j) {
      return "";
    }
    var Rt = {};
    function Nt(j) {
      {
        var se = Ct();
        if (!se) {
          var de = typeof j == "string" ? j : j.displayName || j.name;
          de && (se = `

Check the top-level render call using <` + de + ">.");
        }
        return se;
      }
    }
    function bt(j, se) {
      {
        if (!j._store || j._store.validated || j.key != null)
          return;
        j._store.validated = !0;
        var de = Nt(se);
        if (Rt[de])
          return;
        Rt[de] = !0;
        var xe = "";
        j && j._owner && j._owner !== Et.current && (xe = " It was passed a child from " + m(j._owner.type) + "."), Xt(j), k('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', de, xe), Xt(null);
      }
    }
    function $t(j, se) {
      {
        if (typeof j != "object")
          return;
        if (Ne(j))
          for (var de = 0; de < j.length; de++) {
            var xe = j[de];
            kt(xe) && bt(xe, se);
          }
        else if (kt(j))
          j._store && (j._store.validated = !0);
        else if (j) {
          var Te = L(j);
          if (typeof Te == "function" && Te !== j.entries)
            for (var Re = Te.call(j), nt; !(nt = Re.next()).done; )
              kt(nt.value) && bt(nt.value, se);
        }
      }
    }
    function Ft(j) {
      {
        var se = j.type;
        if (se == null || typeof se == "string")
          return;
        var de;
        if (typeof se == "function")
          de = se.propTypes;
        else if (typeof se == "object" && (se.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        se.$$typeof === p))
          de = se.propTypes;
        else
          return;
        if (de) {
          var xe = m(se);
          $e(de, j.props, "prop", xe, j);
        } else if (se.PropTypes !== void 0 && !Dt) {
          Dt = !0;
          var Te = m(se);
          k("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Te || "Unknown");
        }
        typeof se.getDefaultProps == "function" && !se.getDefaultProps.isReactClassApproved && k("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function rt(j) {
      {
        for (var se = Object.keys(j.props), de = 0; de < se.length; de++) {
          var xe = se[de];
          if (xe !== "children" && xe !== "key") {
            Xt(j), k("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", xe), Xt(null);
            break;
          }
        }
        j.ref !== null && (Xt(j), k("Invalid attribute `ref` supplied to `React.Fragment`."), Xt(null));
      }
    }
    var Bt = {};
    function $(j, se, de, xe, Te, Re) {
      {
        var nt = Ee(j);
        if (!nt) {
          var je = "";
          (j === void 0 || typeof j == "object" && j !== null && Object.keys(j).length === 0) && (je += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var pt = mt();
          pt ? je += pt : je += Ct();
          var it;
          j === null ? it = "null" : Ne(j) ? it = "array" : j !== void 0 && j.$$typeof === e ? (it = "<" + (m(j.type) || "Unknown") + " />", je = " Did you accidentally export a JSX literal instead of a component?") : it = typeof j, k("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", it, je);
        }
        var et = Jt(j, se, de, Te, Re);
        if (et == null)
          return et;
        if (nt) {
          var St = se.children;
          if (St !== void 0)
            if (xe)
              if (Ne(St)) {
                for (var Tt = 0; Tt < St.length; Tt++)
                  $t(St[Tt], j);
                Object.freeze && Object.freeze(St);
              } else
                k("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              $t(St, j);
        }
        if (ve.call(se, "key")) {
          var At = m(j), _t = Object.keys(se).filter(function(st) {
            return st !== "key";
          }), ht = _t.length > 0 ? "{key: someKey, " + _t.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Bt[At + ht]) {
            var xt = _t.length > 0 ? "{" + _t.join(": ..., ") + ": ...}" : "{}";
            k(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ht, At, xt, At), Bt[At + ht] = !0;
          }
        }
        return j === n ? rt(et) : Ft(et), et;
      }
    }
    function z(j, se, de) {
      return $(j, se, de, !0);
    }
    function H(j, se, de) {
      return $(j, se, de, !1);
    }
    var C = H, G = z;
    Ef.Fragment = n, Ef.jsx = C, Ef.jsxs = G;
  }()), Ef;
}
process.env.NODE_ENV === "production" ? u1.exports = pD() : u1.exports = gD();
var le = u1.exports;
const ks = "https://static.codatta.io/codatta-connect/wallet-icons.svg?v=2", mD = [
  {
    featured: !0,
    name: "MetaMask",
    rdns: "io.metamask",
    image: `${ks}#metamask`,
    getWallet: {
      chrome_store_id: "nkbihfbeogaeaoehlefnkodbefgpgknn",
      brave_store_id: "nkbihfbeogaeaoehlefnkodbefgpgknn",
      edge_addon_id: "ejbalbakoplchlghecdalmeeeajnimhm",
      firefox_addon_id: "ether-metamask",
      play_store_id: "io.metamask",
      app_store_id: "id1438144202"
    },
    deep_link: "metamask://wc",
    universal_link: "https://metamask.app.link/wc"
  },
  {
    featured: !0,
    name: "OKX Wallet",
    rdns: "com.okex.wallet",
    image: `${ks}#okx`,
    getWallet: {
      chrome_store_id: "mcohilncbfahbmgdjkbpemcciiolgcge",
      brave_store_id: "mcohilncbfahbmgdjkbpemcciiolgcge",
      edge_addon_id: "pbpjkcldjiffchgbbndmhojiacbgflha",
      play_store_id: "com.okinc.okex.gp",
      app_store_id: "id1327268470"
    },
    deep_link: "okex://main/wc",
    universal_link: "okex://main/wc"
  },
  {
    featured: !0,
    name: "WalletConnect",
    image: `${ks}#walletconnect`
  },
  {
    featured: !1,
    name: "Coinbase Wallet",
    image: `${ks}#coinbase`
  },
  {
    featured: !1,
    name: "GateWallet",
    rdns: "io.gate.wallet",
    image: `${ks}#6e528abf-7a7d-47bd-d84d-481f169b1200`,
    getWallet: {
      chrome_store_id: "cpmkedoipcpimgecpmgpldfpohjplkpp",
      brave_store_id: "cpmkedoipcpimgecpmgpldfpohjplkpp",
      play_store_id: "com.gateio.gateio",
      app_store_id: "id1294998195",
      mac_app_store_id: "id1609559473"
    },
    deep_link: "https://www.gate.io/mobileapp",
    universal_link: "https://www.gate.io/mobileapp"
  },
  {
    featured: !1,
    name: "Onekey",
    rdns: "so.onekey.app.wallet",
    image: `${ks}#onekey`,
    getWallet: {
      chrome_store_id: "jnmbobjmhlngoefaiojfljckilhhlhcj",
      brave_store_id: "jnmbobjmhlngoefaiojfljckilhhlhcj",
      play_store_id: "so.onekey.app.wallet",
      app_store_id: "id1609559473"
    },
    deep_link: "onekey-wallet://",
    universal_link: "onekey://wc"
  },
  {
    featured: !1,
    name: "Infinity Wallet",
    image: `${ks}#9f259366-0bcd-4817-0af9-f78773e41900`,
    desktop_link: "infinity://wc"
  },
  {
    name: "Rabby Wallet",
    rdns: "io.rabby",
    featured: !1,
    image: `${ks}#rabby`,
    getWallet: {
      chrome_store_id: "acmacodkjbdgmoleebolmdjonilkdbch",
      brave_store_id: "acmacodkjbdgmoleebolmdjonilkdbch",
      play_store_id: "com.debank.rabbymobile",
      app_store_id: "id6474381673"
    }
  },
  {
    name: "Binance Web3 Wallet",
    featured: !1,
    image: `${ks}#ebac7b39-688c-41e3-7912-a4fefba74600`,
    getWallet: {
      play_store_id: "com.binance.dev",
      app_store_id: "id1436799971"
    }
  },
  {
    name: "Rainbow Wallet",
    rdns: "me.rainbow",
    featured: !1,
    image: `${ks}#rainbow`,
    getWallet: {
      chrome_store_id: "opfgelmcmbiajamepnmloijbpoleiama",
      edge_addon_id: "cpojfbodiccabbabgimdeohkkpjfpbnf",
      firefox_addon_id: "rainbow-extension",
      app_store_id: "id1457119021",
      play_store_id: "me.rainbow"
    }
  }
];
function vD(t, e) {
  const r = t.exec(e);
  return r == null ? void 0 : r.groups;
}
const T2 = /^tuple(?<array>(\[(\d*)\])*)$/;
function f1(t) {
  let e = t.type;
  if (T2.test(t.type) && "components" in t) {
    e = "(";
    const r = t.components.length;
    for (let i = 0; i < r; i++) {
      const s = t.components[i];
      e += f1(s), i < r - 1 && (e += ", ");
    }
    const n = vD(T2, t.type);
    return e += `)${(n == null ? void 0 : n.array) ?? ""}`, f1({
      ...t,
      type: e
    });
  }
  return "indexed" in t && t.indexed && (e = `${e} indexed`), t.name ? `${e} ${t.name}` : e;
}
function Sf(t) {
  let e = "";
  const r = t.length;
  for (let n = 0; n < r; n++) {
    const i = t[n];
    e += f1(i), n !== r - 1 && (e += ", ");
  }
  return e;
}
function bD(t) {
  var e;
  return t.type === "function" ? `function ${t.name}(${Sf(t.inputs)})${t.stateMutability && t.stateMutability !== "nonpayable" ? ` ${t.stateMutability}` : ""}${(e = t.outputs) != null && e.length ? ` returns (${Sf(t.outputs)})` : ""}` : t.type === "event" ? `event ${t.name}(${Sf(t.inputs)})` : t.type === "error" ? `error ${t.name}(${Sf(t.inputs)})` : t.type === "constructor" ? `constructor(${Sf(t.inputs)})${t.stateMutability === "payable" ? " payable" : ""}` : t.type === "fallback" ? `fallback() external${t.stateMutability === "payable" ? " payable" : ""}` : "receive() external payable";
}
function Xn(t, e, r) {
  const n = t[e.name];
  if (typeof n == "function")
    return n;
  const i = t[r];
  return typeof i == "function" ? i : (s) => e(t, s);
}
function Mu(t, { includeName: e = !1 } = {}) {
  if (t.type !== "function" && t.type !== "event" && t.type !== "error")
    throw new TD(t.type);
  return `${t.name}(${kv(t.inputs, { includeName: e })})`;
}
function kv(t, { includeName: e = !1 } = {}) {
  return t ? t.map((r) => yD(r, { includeName: e })).join(e ? ", " : ",") : "";
}
function yD(t, { includeName: e }) {
  return t.type.startsWith("tuple") ? `(${kv(t.components, { includeName: e })})${t.type.slice(5)}` : t.type + (e && t.name ? ` ${t.name}` : "");
}
function ya(t, { strict: e = !0 } = {}) {
  return !t || typeof t != "string" ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(t) : t.startsWith("0x");
}
function xn(t) {
  return ya(t, { strict: !1 }) ? Math.ceil((t.length - 2) / 2) : t.length;
}
const $5 = "2.31.3";
let Af = {
  getDocsUrl: ({ docsBaseUrl: t, docsPath: e = "", docsSlug: r }) => e ? `${t ?? "https://viem.sh"}${e}${r ? `#${r}` : ""}` : void 0,
  version: `viem@${$5}`
};
class gt extends Error {
  constructor(e, r = {}) {
    var a;
    const n = (() => {
      var u;
      return r.cause instanceof gt ? r.cause.details : (u = r.cause) != null && u.message ? r.cause.message : r.details;
    })(), i = r.cause instanceof gt && r.cause.docsPath || r.docsPath, s = (a = Af.getDocsUrl) == null ? void 0 : a.call(Af, { ...r, docsPath: i }), o = [
      e || "An error occurred.",
      "",
      ...r.metaMessages ? [...r.metaMessages, ""] : [],
      ...s ? [`Docs: ${s}`] : [],
      ...n ? [`Details: ${n}`] : [],
      ...Af.version ? [`Version: ${Af.version}`] : []
    ].join(`
`);
    super(o, r.cause ? { cause: r.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = n, this.docsPath = i, this.metaMessages = r.metaMessages, this.name = r.name ?? this.name, this.shortMessage = e, this.version = $5;
  }
  walk(e) {
    return B5(this, e);
  }
}
function B5(t, e) {
  return e != null && e(t) ? t : t && typeof t == "object" && "cause" in t && t.cause !== void 0 ? B5(t.cause, e) : e ? null : t;
}
class wD extends gt {
  constructor({ docsPath: e }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join(`
`), {
      docsPath: e,
      name: "AbiConstructorNotFoundError"
    });
  }
}
class R2 extends gt {
  constructor({ docsPath: e }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join(`
`), {
      docsPath: e,
      name: "AbiConstructorParamsNotFoundError"
    });
  }
}
class xD extends gt {
  constructor({ data: e, params: r, size: n }) {
    super([`Data size of ${n} bytes is too small for given parameters.`].join(`
`), {
      metaMessages: [
        `Params: (${kv(r, { includeName: !0 })})`,
        `Data:   ${e} (${n} bytes)`
      ],
      name: "AbiDecodingDataSizeTooSmallError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = e, this.params = r, this.size = n;
  }
}
class $v extends gt {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.', {
      name: "AbiDecodingZeroDataError"
    });
  }
}
class _D extends gt {
  constructor({ expectedLength: e, givenLength: r, type: n }) {
    super([
      `ABI encoding array length mismatch for type ${n}.`,
      `Expected length: ${e}`,
      `Given length: ${r}`
    ].join(`
`), { name: "AbiEncodingArrayLengthMismatchError" });
  }
}
class ED extends gt {
  constructor({ expectedSize: e, value: r }) {
    super(`Size of bytes "${r}" (bytes${xn(r)}) does not match expected size (bytes${e}).`, { name: "AbiEncodingBytesSizeMismatchError" });
  }
}
class SD extends gt {
  constructor({ expectedLength: e, givenLength: r }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${e}`,
      `Given length (values): ${r}`
    ].join(`
`), { name: "AbiEncodingLengthMismatchError" });
  }
}
class F5 extends gt {
  constructor(e, { docsPath: r }) {
    super([
      `Encoded error signature "${e}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${e}.`
    ].join(`
`), {
      docsPath: r,
      name: "AbiErrorSignatureNotFoundError"
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.signature = e;
  }
}
class D2 extends gt {
  constructor(e, { docsPath: r } = {}) {
    super([
      `Function ${e ? `"${e}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: r,
      name: "AbiFunctionNotFoundError"
    });
  }
}
class AD extends gt {
  constructor(e, r) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${e.type}\` in \`${Mu(e.abiItem)}\`, and`,
        `\`${r.type}\` in \`${Mu(r.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ],
      name: "AbiItemAmbiguityError"
    });
  }
}
class PD extends gt {
  constructor({ expectedSize: e, givenSize: r }) {
    super(`Expected bytes${e}, got bytes${r}.`, {
      name: "BytesSizeMismatchError"
    });
  }
}
class MD extends gt {
  constructor(e, { docsPath: r }) {
    super([
      `Type "${e}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: r, name: "InvalidAbiEncodingType" });
  }
}
class ID extends gt {
  constructor(e, { docsPath: r }) {
    super([
      `Type "${e}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: r, name: "InvalidAbiDecodingType" });
  }
}
class CD extends gt {
  constructor(e) {
    super([`Value "${e}" is not a valid array.`].join(`
`), {
      name: "InvalidArrayError"
    });
  }
}
class TD extends gt {
  constructor(e) {
    super([
      `"${e}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join(`
`), { name: "InvalidDefinitionTypeError" });
  }
}
class j5 extends gt {
  constructor({ offset: e, position: r, size: n }) {
    super(`Slice ${r === "start" ? "starting" : "ending"} at offset "${e}" is out-of-bounds (size: ${n}).`, { name: "SliceOffsetOutOfBoundsError" });
  }
}
class U5 extends gt {
  constructor({ size: e, targetSize: r, type: n }) {
    super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${e}) exceeds padding size (${r}).`, { name: "SizeExceedsPaddingSizeError" });
  }
}
class O2 extends gt {
  constructor({ size: e, targetSize: r, type: n }) {
    super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} is expected to be ${r} ${n} long, but is ${e} ${n} long.`, { name: "InvalidBytesLengthError" });
  }
}
function Fu(t, { dir: e, size: r = 32 } = {}) {
  return typeof t == "string" ? ba(t, { dir: e, size: r }) : RD(t, { dir: e, size: r });
}
function ba(t, { dir: e, size: r = 32 } = {}) {
  if (r === null)
    return t;
  const n = t.replace("0x", "");
  if (n.length > r * 2)
    throw new U5({
      size: Math.ceil(n.length / 2),
      targetSize: r,
      type: "hex"
    });
  return `0x${n[e === "right" ? "padEnd" : "padStart"](r * 2, "0")}`;
}
function RD(t, { dir: e, size: r = 32 } = {}) {
  if (r === null)
    return t;
  if (t.length > r)
    throw new U5({
      size: t.length,
      targetSize: r,
      type: "bytes"
    });
  const n = new Uint8Array(r);
  for (let i = 0; i < r; i++) {
    const s = e === "right";
    n[s ? i : r - i - 1] = t[s ? i : t.length - i - 1];
  }
  return n;
}
class q5 extends gt {
  constructor({ max: e, min: r, signed: n, size: i, value: s }) {
    super(`Number "${s}" is not in safe ${i ? `${i * 8}-bit ${n ? "signed" : "unsigned"} ` : ""}integer range ${e ? `(${r} to ${e})` : `(above ${r})`}`, { name: "IntegerOutOfRangeError" });
  }
}
class DD extends gt {
  constructor(e) {
    super(`Bytes value "${e}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
      name: "InvalidBytesBooleanError"
    });
  }
}
class OD extends gt {
  constructor({ givenSize: e, maxSize: r }) {
    super(`Size cannot exceed ${r} bytes. Given size: ${e} bytes.`, { name: "SizeOverflowError" });
  }
}
function j0(t, { dir: e = "left" } = {}) {
  let r = typeof t == "string" ? t.replace("0x", "") : t, n = 0;
  for (let i = 0; i < r.length - 1 && r[e === "left" ? i : r.length - i - 1].toString() === "0"; i++)
    n++;
  return r = e === "left" ? r.slice(n) : r.slice(0, r.length - n), typeof t == "string" ? (r.length === 1 && e === "right" && (r = `${r}0`), `0x${r.length % 2 === 1 ? `0${r}` : r}`) : r;
}
function io(t, { size: e }) {
  if (xn(t) > e)
    throw new OD({
      givenSize: xn(t),
      maxSize: e
    });
}
function wa(t, e = {}) {
  const { signed: r } = e;
  e.size && io(t, { size: e.size });
  const n = BigInt(t);
  if (!r)
    return n;
  const i = (t.length - 2) / 2, s = (1n << BigInt(i) * 8n - 1n) - 1n;
  return n <= s ? n : n - BigInt(`0x${"f".padStart(i * 2, "f")}`) - 1n;
}
function xa(t, e = {}) {
  return Number(wa(t, e));
}
const ND = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function t0(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint" ? vr(t, e) : typeof t == "string" ? U0(t, e) : typeof t == "boolean" ? z5(t, e) : xi(t, e);
}
function z5(t, e = {}) {
  const r = `0x${Number(t)}`;
  return typeof e.size == "number" ? (io(r, { size: e.size }), Fu(r, { size: e.size })) : r;
}
function xi(t, e = {}) {
  let r = "";
  for (let i = 0; i < t.length; i++)
    r += ND[t[i]];
  const n = `0x${r}`;
  return typeof e.size == "number" ? (io(n, { size: e.size }), Fu(n, { dir: "right", size: e.size })) : n;
}
function vr(t, e = {}) {
  const { signed: r, size: n } = e, i = BigInt(t);
  let s;
  n ? r ? s = (1n << BigInt(n) * 8n - 1n) - 1n : s = 2n ** (BigInt(n) * 8n) - 1n : typeof t == "number" && (s = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof s == "bigint" && r ? -s - 1n : 0;
  if (s && i > s || i < o) {
    const u = typeof t == "bigint" ? "n" : "";
    throw new q5({
      max: s ? `${s}${u}` : void 0,
      min: `${o}${u}`,
      signed: r,
      size: n,
      value: `${t}${u}`
    });
  }
  const a = `0x${(r && i < 0 ? (1n << BigInt(n * 8)) + BigInt(i) : i).toString(16)}`;
  return n ? Fu(a, { size: n }) : a;
}
const LD = /* @__PURE__ */ new TextEncoder();
function U0(t, e = {}) {
  const r = LD.encode(t);
  return xi(r, e);
}
const kD = /* @__PURE__ */ new TextEncoder();
function Bv(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint" ? BD(t, e) : typeof t == "boolean" ? $D(t, e) : ya(t) ? Fo(t, e) : W5(t, e);
}
function $D(t, e = {}) {
  const r = new Uint8Array(1);
  return r[0] = Number(t), typeof e.size == "number" ? (io(r, { size: e.size }), Fu(r, { size: e.size })) : r;
}
const bo = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function N2(t) {
  if (t >= bo.zero && t <= bo.nine)
    return t - bo.zero;
  if (t >= bo.A && t <= bo.F)
    return t - (bo.A - 10);
  if (t >= bo.a && t <= bo.f)
    return t - (bo.a - 10);
}
function Fo(t, e = {}) {
  let r = t;
  e.size && (io(r, { size: e.size }), r = Fu(r, { dir: "right", size: e.size }));
  let n = r.slice(2);
  n.length % 2 && (n = `0${n}`);
  const i = n.length / 2, s = new Uint8Array(i);
  for (let o = 0, a = 0; o < i; o++) {
    const u = N2(n.charCodeAt(a++)), l = N2(n.charCodeAt(a++));
    if (u === void 0 || l === void 0)
      throw new gt(`Invalid byte sequence ("${n[a - 2]}${n[a - 1]}" in "${n}").`);
    s[o] = u * 16 + l;
  }
  return s;
}
function BD(t, e) {
  const r = vr(t, e);
  return Fo(r);
}
function W5(t, e = {}) {
  const r = kD.encode(t);
  return typeof e.size == "number" ? (io(r, { size: e.size }), Fu(r, { dir: "right", size: e.size })) : r;
}
const ld = /* @__PURE__ */ BigInt(2 ** 32 - 1), L2 = /* @__PURE__ */ BigInt(32);
function FD(t, e = !1) {
  return e ? { h: Number(t & ld), l: Number(t >> L2 & ld) } : { h: Number(t >> L2 & ld) | 0, l: Number(t & ld) | 0 };
}
function jD(t, e = !1) {
  const r = t.length;
  let n = new Uint32Array(r), i = new Uint32Array(r);
  for (let s = 0; s < r; s++) {
    const { h: o, l: a } = FD(t[s], e);
    [n[s], i[s]] = [o, a];
  }
  return [n, i];
}
const UD = (t, e, r) => t << r | e >>> 32 - r, qD = (t, e, r) => e << r | t >>> 32 - r, zD = (t, e, r) => e << r - 32 | t >>> 64 - r, WD = (t, e, r) => t << r - 32 | e >>> 64 - r, Zc = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function HD(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function r0(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error("positive integer expected, got " + t);
}
function mc(t, ...e) {
  if (!HD(t))
    throw new Error("Uint8Array expected");
  e.length > 0;
}
function Yse(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.createHasher");
  r0(t.outputLen), r0(t.blockLen);
}
function n0(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function H5(t, e) {
  mc(t);
  const r = e.outputLen;
  if (t.length < r)
    throw new Error("digestInto() expects output buffer of length at least " + r);
}
function KD(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function al(...t) {
  for (let e = 0; e < t.length; e++)
    t[e].fill(0);
}
function Zg(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function $s(t, e) {
  return t << 32 - e | t >>> e;
}
const VD = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function GD(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
function YD(t) {
  for (let e = 0; e < t.length; e++)
    t[e] = GD(t[e]);
  return t;
}
const k2 = VD ? (t) => t : YD, K5 = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == "function" && typeof Uint8Array.fromHex == "function", JD = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function XD(t) {
  if (mc(t), K5)
    return t.toHex();
  let e = "";
  for (let r = 0; r < t.length; r++)
    e += JD[t[r]];
  return e;
}
const yo = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function $2(t) {
  if (t >= yo._0 && t <= yo._9)
    return t - yo._0;
  if (t >= yo.A && t <= yo.F)
    return t - (yo.A - 10);
  if (t >= yo.a && t <= yo.f)
    return t - (yo.a - 10);
}
function Jse(t) {
  if (typeof t != "string")
    throw new Error("hex string expected, got " + typeof t);
  if (K5)
    return Uint8Array.fromHex(t);
  const e = t.length, r = e / 2;
  if (e % 2)
    throw new Error("hex string expected, got unpadded hex of length " + e);
  const n = new Uint8Array(r);
  for (let i = 0, s = 0; i < r; i++, s += 2) {
    const o = $2(t.charCodeAt(s)), a = $2(t.charCodeAt(s + 1));
    if (o === void 0 || a === void 0) {
      const u = t[s] + t[s + 1];
      throw new Error('hex string expected, got non-hex character "' + u + '" at index ' + s);
    }
    n[i] = o * 16 + a;
  }
  return n;
}
function ZD(t) {
  if (typeof t != "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function q0(t) {
  return typeof t == "string" && (t = ZD(t)), mc(t), t;
}
function Xse(...t) {
  let e = 0;
  for (let n = 0; n < t.length; n++) {
    const i = t[n];
    mc(i), e += i.length;
  }
  const r = new Uint8Array(e);
  for (let n = 0, i = 0; n < t.length; n++) {
    const s = t[n];
    r.set(s, i), i += s.length;
  }
  return r;
}
class V5 {
}
function G5(t) {
  const e = (n) => t().update(q0(n)).digest(), r = t();
  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e;
}
function QD(t) {
  const e = (n, i) => t(i).update(q0(n)).digest(), r = t({});
  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = (n) => t(n), e;
}
function Zse(t = 32) {
  if (Zc && typeof Zc.getRandomValues == "function")
    return Zc.getRandomValues(new Uint8Array(t));
  if (Zc && typeof Zc.randomBytes == "function")
    return Uint8Array.from(Zc.randomBytes(t));
  throw new Error("crypto.getRandomValues must be defined");
}
const eO = BigInt(0), Pf = BigInt(1), tO = BigInt(2), rO = BigInt(7), nO = BigInt(256), iO = BigInt(113), Y5 = [], J5 = [], X5 = [];
for (let t = 0, e = Pf, r = 1, n = 0; t < 24; t++) {
  [r, n] = [n, (2 * r + 3 * n) % 5], Y5.push(2 * (5 * n + r)), J5.push((t + 1) * (t + 2) / 2 % 64);
  let i = eO;
  for (let s = 0; s < 7; s++)
    e = (e << Pf ^ (e >> rO) * iO) % nO, e & tO && (i ^= Pf << (Pf << /* @__PURE__ */ BigInt(s)) - Pf);
  X5.push(i);
}
const Z5 = jD(X5, !0), sO = Z5[0], oO = Z5[1], B2 = (t, e, r) => r > 32 ? zD(t, e, r) : UD(t, e, r), F2 = (t, e, r) => r > 32 ? WD(t, e, r) : qD(t, e, r);
function Q5(t, e = 24) {
  const r = new Uint32Array(10);
  for (let n = 24 - e; n < 24; n++) {
    for (let o = 0; o < 10; o++)
      r[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10, u = (o + 2) % 10, l = r[u], d = r[u + 1], p = B2(l, d, 1) ^ r[a], w = F2(l, d, 1) ^ r[a + 1];
      for (let _ = 0; _ < 50; _ += 10)
        t[o + _] ^= p, t[o + _ + 1] ^= w;
    }
    let i = t[2], s = t[3];
    for (let o = 0; o < 24; o++) {
      const a = J5[o], u = B2(i, s, a), l = F2(i, s, a), d = Y5[o];
      i = t[d], s = t[d + 1], t[d] = u, t[d + 1] = l;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++)
        r[a] = t[o + a];
      for (let a = 0; a < 10; a++)
        t[o + a] ^= ~r[(a + 2) % 10] & r[(a + 4) % 10];
    }
    t[0] ^= sO[n], t[1] ^= oO[n];
  }
  al(r);
}
class Kl extends V5 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, r, n, i = !1, s = 24) {
    if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = e, this.suffix = r, this.outputLen = n, this.enableXOF = i, this.rounds = s, r0(n), !(0 < e && e < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200), this.state32 = KD(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    k2(this.state32), Q5(this.state32, this.rounds), k2(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    n0(this), e = q0(e), mc(e);
    const { blockLen: r, state: n } = this, i = e.length;
    for (let s = 0; s < i; ) {
      const o = Math.min(r - this.pos, i - s);
      for (let a = 0; a < o; a++)
        n[this.pos++] ^= e[s++];
      this.pos === r && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: r, pos: n, blockLen: i } = this;
    e[n] ^= r, r & 128 && n === i - 1 && this.keccak(), e[i - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    n0(this, !1), mc(e), this.finish();
    const r = this.state, { blockLen: n } = this;
    for (let i = 0, s = e.length; i < s; ) {
      this.posOut >= n && this.keccak();
      const o = Math.min(n - this.posOut, s - i);
      e.set(r.subarray(this.posOut, this.posOut + o), i), this.posOut += o, i += o;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return r0(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (H5(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, al(this.state);
  }
  _cloneInto(e) {
    const { blockLen: r, suffix: n, outputLen: i, rounds: s, enableXOF: o } = this;
    return e || (e = new Kl(r, n, i, o, s)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = s, e.suffix = n, e.outputLen = i, e.enableXOF = o, e.destroyed = this.destroyed, e;
  }
}
const Ra = (t, e, r) => G5(() => new Kl(e, t, r)), aO = Ra(6, 144, 224 / 8), cO = Ra(6, 136, 256 / 8), uO = Ra(6, 104, 384 / 8), fO = Ra(6, 72, 512 / 8), lO = Ra(1, 144, 224 / 8), e4 = Ra(1, 136, 256 / 8), hO = Ra(1, 104, 384 / 8), dO = Ra(1, 72, 512 / 8), t4 = (t, e, r) => QD((n = {}) => new Kl(e, t, n.dkLen === void 0 ? r : n.dkLen, !0)), pO = t4(31, 168, 128 / 8), gO = t4(31, 136, 256 / 8), mO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Keccak: Kl,
  keccakP: Q5,
  keccak_224: lO,
  keccak_256: e4,
  keccak_384: hO,
  keccak_512: dO,
  sha3_224: aO,
  sha3_256: cO,
  sha3_384: uO,
  sha3_512: fO,
  shake128: pO,
  shake256: gO
}, Symbol.toStringTag, { value: "Module" }));
function z0(t, e) {
  const r = e || "hex", n = e4(ya(t, { strict: !1 }) ? Bv(t) : t);
  return r === "bytes" ? n : t0(n);
}
const vO = (t) => z0(Bv(t));
function bO(t) {
  return vO(t);
}
function yO(t) {
  let e = !0, r = "", n = 0, i = "", s = !1;
  for (let o = 0; o < t.length; o++) {
    const a = t[o];
    if (["(", ")", ","].includes(a) && (e = !0), a === "(" && n++, a === ")" && n--, !!e) {
      if (n === 0) {
        if (a === " " && ["event", "function", ""].includes(i))
          i = "";
        else if (i += a, a === ")") {
          s = !0;
          break;
        }
        continue;
      }
      if (a === " ") {
        t[o - 1] !== "," && r !== "," && r !== ",(" && (r = "", e = !1);
        continue;
      }
      i += a, r += a;
    }
  }
  if (!s)
    throw new gt("Unable to normalize signature.");
  return i;
}
const wO = (t) => {
  const e = typeof t == "string" ? t : bD(t);
  return yO(e);
};
function r4(t) {
  return bO(wO(t));
}
const xO = r4;
class _a extends gt {
  constructor({ address: e }) {
    super(`Address "${e}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
}
class W0 extends Map {
  constructor(e) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = e;
  }
  get(e) {
    const r = super.get(e);
    return super.has(e) && r !== void 0 && (this.delete(e), super.set(e, r)), r;
  }
  set(e, r) {
    if (super.set(e, r), this.maxSize && this.size > this.maxSize) {
      const n = this.keys().next().value;
      n && this.delete(n);
    }
    return this;
  }
}
const Qg = /* @__PURE__ */ new W0(8192);
function Vl(t, e) {
  if (Qg.has(`${t}.${e}`))
    return Qg.get(`${t}.${e}`);
  const r = t.substring(2).toLowerCase(), n = z0(W5(r), "bytes"), i = r.split("");
  for (let o = 0; o < 40; o += 2)
    n[o >> 1] >> 4 >= 8 && i[o] && (i[o] = i[o].toUpperCase()), (n[o >> 1] & 15) >= 8 && i[o + 1] && (i[o + 1] = i[o + 1].toUpperCase());
  const s = `0x${i.join("")}`;
  return Qg.set(`${t}.${e}`, s), s;
}
function Fv(t, e) {
  if (!Ms(t, { strict: !1 }))
    throw new _a({ address: t });
  return Vl(t, e);
}
const _O = /^0x[a-fA-F0-9]{40}$/, em = /* @__PURE__ */ new W0(8192);
function Ms(t, e) {
  const { strict: r = !0 } = e ?? {}, n = `${t}.${r}`;
  if (em.has(n))
    return em.get(n);
  const i = _O.test(t) ? t.toLowerCase() === t ? !0 : r ? Vl(t) === t : !0 : !1;
  return em.set(n, i), i;
}
function Ea(t) {
  return typeof t[0] == "string" ? H0(t) : EO(t);
}
function EO(t) {
  let e = 0;
  for (const i of t)
    e += i.length;
  const r = new Uint8Array(e);
  let n = 0;
  for (const i of t)
    r.set(i, n), n += i.length;
  return r;
}
function H0(t) {
  return `0x${t.reduce((e, r) => e + r.replace("0x", ""), "")}`;
}
function i0(t, e, r, { strict: n } = {}) {
  return ya(t, { strict: !1 }) ? l1(t, e, r, {
    strict: n
  }) : s4(t, e, r, {
    strict: n
  });
}
function n4(t, e) {
  if (typeof e == "number" && e > 0 && e > xn(t) - 1)
    throw new j5({
      offset: e,
      position: "start",
      size: xn(t)
    });
}
function i4(t, e, r) {
  if (typeof e == "number" && typeof r == "number" && xn(t) !== r - e)
    throw new j5({
      offset: r,
      position: "end",
      size: xn(t)
    });
}
function s4(t, e, r, { strict: n } = {}) {
  n4(t, e);
  const i = t.slice(e, r);
  return n && i4(i, e, r), i;
}
function l1(t, e, r, { strict: n } = {}) {
  n4(t, e);
  const i = `0x${t.replace("0x", "").slice((e ?? 0) * 2, (r ?? t.length) * 2)}`;
  return n && i4(i, e, r), i;
}
const SO = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, o4 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function a4(t, e) {
  if (t.length !== e.length)
    throw new SD({
      expectedLength: t.length,
      givenLength: e.length
    });
  const r = AO({
    params: t,
    values: e
  }), n = Uv(r);
  return n.length === 0 ? "0x" : n;
}
function AO({ params: t, values: e }) {
  const r = [];
  for (let n = 0; n < t.length; n++)
    r.push(jv({ param: t[n], value: e[n] }));
  return r;
}
function jv({ param: t, value: e }) {
  const r = qv(t.type);
  if (r) {
    const [n, i] = r;
    return MO(e, { length: n, param: { ...t, type: i } });
  }
  if (t.type === "tuple")
    return DO(e, {
      param: t
    });
  if (t.type === "address")
    return PO(e);
  if (t.type === "bool")
    return CO(e);
  if (t.type.startsWith("uint") || t.type.startsWith("int")) {
    const n = t.type.startsWith("int"), [, , i = "256"] = o4.exec(t.type) ?? [];
    return TO(e, {
      signed: n,
      size: Number(i)
    });
  }
  if (t.type.startsWith("bytes"))
    return IO(e, { param: t });
  if (t.type === "string")
    return RO(e);
  throw new MD(t.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function Uv(t) {
  let e = 0;
  for (let s = 0; s < t.length; s++) {
    const { dynamic: o, encoded: a } = t[s];
    o ? e += 32 : e += xn(a);
  }
  const r = [], n = [];
  let i = 0;
  for (let s = 0; s < t.length; s++) {
    const { dynamic: o, encoded: a } = t[s];
    o ? (r.push(vr(e + i, { size: 32 })), n.push(a), i += xn(a)) : r.push(a);
  }
  return Ea([...r, ...n]);
}
function PO(t) {
  if (!Ms(t))
    throw new _a({ address: t });
  return { dynamic: !1, encoded: ba(t.toLowerCase()) };
}
function MO(t, { length: e, param: r }) {
  const n = e === null;
  if (!Array.isArray(t))
    throw new CD(t);
  if (!n && t.length !== e)
    throw new _D({
      expectedLength: e,
      givenLength: t.length,
      type: `${r.type}[${e}]`
    });
  let i = !1;
  const s = [];
  for (let o = 0; o < t.length; o++) {
    const a = jv({ param: r, value: t[o] });
    a.dynamic && (i = !0), s.push(a);
  }
  if (n || i) {
    const o = Uv(s);
    if (n) {
      const a = vr(s.length, { size: 32 });
      return {
        dynamic: !0,
        encoded: s.length > 0 ? Ea([a, o]) : a
      };
    }
    if (i)
      return { dynamic: !0, encoded: o };
  }
  return {
    dynamic: !1,
    encoded: Ea(s.map(({ encoded: o }) => o))
  };
}
function IO(t, { param: e }) {
  const [, r] = e.type.split("bytes"), n = xn(t);
  if (!r) {
    let i = t;
    return n % 32 !== 0 && (i = ba(i, {
      dir: "right",
      size: Math.ceil((t.length - 2) / 2 / 32) * 32
    })), {
      dynamic: !0,
      encoded: Ea([ba(vr(n, { size: 32 })), i])
    };
  }
  if (n !== Number.parseInt(r))
    throw new ED({
      expectedSize: Number.parseInt(r),
      value: t
    });
  return { dynamic: !1, encoded: ba(t, { dir: "right" }) };
}
function CO(t) {
  if (typeof t != "boolean")
    throw new gt(`Invalid boolean value: "${t}" (type: ${typeof t}). Expected: \`true\` or \`false\`.`);
  return { dynamic: !1, encoded: ba(z5(t)) };
}
function TO(t, { signed: e, size: r = 256 }) {
  if (typeof r == "number") {
    const n = 2n ** (BigInt(r) - (e ? 1n : 0n)) - 1n, i = e ? -n - 1n : 0n;
    if (t > n || t < i)
      throw new q5({
        max: n.toString(),
        min: i.toString(),
        signed: e,
        size: r / 8,
        value: t.toString()
      });
  }
  return {
    dynamic: !1,
    encoded: vr(t, {
      size: 32,
      signed: e
    })
  };
}
function RO(t) {
  const e = U0(t), r = Math.ceil(xn(e) / 32), n = [];
  for (let i = 0; i < r; i++)
    n.push(ba(i0(e, i * 32, (i + 1) * 32), {
      dir: "right"
    }));
  return {
    dynamic: !0,
    encoded: Ea([
      ba(vr(xn(e), { size: 32 })),
      ...n
    ])
  };
}
function DO(t, { param: e }) {
  let r = !1;
  const n = [];
  for (let i = 0; i < e.components.length; i++) {
    const s = e.components[i], o = Array.isArray(t) ? i : s.name, a = jv({
      param: s,
      value: t[o]
    });
    n.push(a), a.dynamic && (r = !0);
  }
  return {
    dynamic: r,
    encoded: r ? Uv(n) : Ea(n.map(({ encoded: i }) => i))
  };
}
function qv(t) {
  const e = t.match(/^(.*)\[(\d+)?\]$/);
  return e ? (
    // Return `null` if the array is dynamic.
    [e[2] ? Number(e[2]) : null, e[1]]
  ) : void 0;
}
const zv = (t) => i0(r4(t), 0, 4);
function c4(t) {
  const { abi: e, args: r = [], name: n } = t, i = ya(n, { strict: !1 }), s = e.filter((a) => i ? a.type === "function" ? zv(a) === n : a.type === "event" ? xO(a) === n : !1 : "name" in a && a.name === n);
  if (s.length === 0)
    return;
  if (s.length === 1)
    return s[0];
  let o;
  for (const a of s) {
    if (!("inputs" in a))
      continue;
    if (!r || r.length === 0) {
      if (!a.inputs || a.inputs.length === 0)
        return a;
      continue;
    }
    if (!a.inputs || a.inputs.length === 0 || a.inputs.length !== r.length)
      continue;
    if (r.every((l, d) => {
      const p = "inputs" in a && a.inputs[d];
      return p ? h1(l, p) : !1;
    })) {
      if (o && "inputs" in o && o.inputs) {
        const l = u4(a.inputs, o.inputs, r);
        if (l)
          throw new AD({
            abiItem: a,
            type: l[0]
          }, {
            abiItem: o,
            type: l[1]
          });
      }
      o = a;
    }
  }
  return o || s[0];
}
function h1(t, e) {
  const r = typeof t, n = e.type;
  switch (n) {
    case "address":
      return Ms(t, { strict: !1 });
    case "bool":
      return r === "boolean";
    case "function":
      return r === "string";
    case "string":
      return r === "string";
    default:
      return n === "tuple" && "components" in e ? Object.values(e.components).every((i, s) => h1(Object.values(t)[s], i)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(n) ? r === "number" || r === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(n) ? r === "string" || t instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(n) ? Array.isArray(t) && t.every((i) => h1(i, {
        ...e,
        // Pop off `[]` or `[M]` from end of type
        type: n.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1;
  }
}
function u4(t, e, r) {
  for (const n in t) {
    const i = t[n], s = e[n];
    if (i.type === "tuple" && s.type === "tuple" && "components" in i && "components" in s)
      return u4(i.components, s.components, r[n]);
    const o = [i.type, s.type];
    if (o.includes("address") && o.includes("bytes20") ? !0 : o.includes("address") && o.includes("string") ? Ms(r[n], { strict: !1 }) : o.includes("address") && o.includes("bytes") ? Ms(r[n], { strict: !1 }) : !1)
      return o;
  }
}
function _i(t) {
  return typeof t == "string" ? { address: t, type: "json-rpc" } : t;
}
const j2 = "/docs/contract/encodeFunctionData";
function OO(t) {
  const { abi: e, args: r, functionName: n } = t;
  let i = e[0];
  if (n) {
    const s = c4({
      abi: e,
      args: r,
      name: n
    });
    if (!s)
      throw new D2(n, { docsPath: j2 });
    i = s;
  }
  if (i.type !== "function")
    throw new D2(void 0, { docsPath: j2 });
  return {
    abi: [i],
    functionName: zv(Mu(i))
  };
}
function f4(t) {
  const { args: e } = t, { abi: r, functionName: n } = (() => {
    var a;
    return t.abi.length === 1 && ((a = t.functionName) != null && a.startsWith("0x")) ? t : OO(t);
  })(), i = r[0], s = n, o = "inputs" in i && i.inputs ? a4(i.inputs, e ?? []) : void 0;
  return H0([s, o ?? "0x"]);
}
const NO = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
}, LO = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
}, kO = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
class U2 extends gt {
  constructor({ offset: e }) {
    super(`Offset \`${e}\` cannot be negative.`, {
      name: "NegativeOffsetError"
    });
  }
}
class $O extends gt {
  constructor({ length: e, position: r }) {
    super(`Position \`${r}\` is out of bounds (\`0 < position < ${e}\`).`, { name: "PositionOutOfBoundsError" });
  }
}
class BO extends gt {
  constructor({ count: e, limit: r }) {
    super(`Recursive read limit of \`${r}\` exceeded (recursive read count: \`${e}\`).`, { name: "RecursiveReadLimitExceededError" });
  }
}
const FO = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new BO({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(t) {
    if (t < 0 || t > this.bytes.length - 1)
      throw new $O({
        length: this.bytes.length,
        position: t
      });
  },
  decrementPosition(t) {
    if (t < 0)
      throw new U2({ offset: t });
    const e = this.position - t;
    this.assertPosition(e), this.position = e;
  },
  getReadCount(t) {
    return this.positionReadCount.get(t || this.position) || 0;
  },
  incrementPosition(t) {
    if (t < 0)
      throw new U2({ offset: t });
    const e = this.position + t;
    this.assertPosition(e), this.position = e;
  },
  inspectByte(t) {
    const e = t ?? this.position;
    return this.assertPosition(e), this.bytes[e];
  },
  inspectBytes(t, e) {
    const r = e ?? this.position;
    return this.assertPosition(r + t - 1), this.bytes.subarray(r, r + t);
  },
  inspectUint8(t) {
    const e = t ?? this.position;
    return this.assertPosition(e), this.bytes[e];
  },
  inspectUint16(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 1), this.dataView.getUint16(e);
  },
  inspectUint24(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 2), (this.dataView.getUint16(e) << 8) + this.dataView.getUint8(e + 2);
  },
  inspectUint32(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 3), this.dataView.getUint32(e);
  },
  pushByte(t) {
    this.assertPosition(this.position), this.bytes[this.position] = t, this.position++;
  },
  pushBytes(t) {
    this.assertPosition(this.position + t.length - 1), this.bytes.set(t, this.position), this.position += t.length;
  },
  pushUint8(t) {
    this.assertPosition(this.position), this.bytes[this.position] = t, this.position++;
  },
  pushUint16(t) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, t), this.position += 2;
  },
  pushUint24(t) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, t >> 8), this.dataView.setUint8(this.position + 2, t & 255), this.position += 3;
  },
  pushUint32(t) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, t), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectByte();
    return this.position++, t;
  },
  readBytes(t, e) {
    this.assertReadLimit(), this._touch();
    const r = this.inspectBytes(t);
    return this.position += e ?? t, r;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint8();
    return this.position += 1, t;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint16();
    return this.position += 2, t;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint24();
    return this.position += 3, t;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint32();
    return this.position += 4, t;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(t) {
    const e = this.position;
    return this.assertPosition(t), this.position = t, () => this.position = e;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const t = this.getReadCount();
    this.positionReadCount.set(this.position, t + 1), t > 0 && this.recursiveReadCount++;
  }
};
function Wv(t, { recursiveReadLimit: e = 8192 } = {}) {
  const r = Object.create(FO);
  return r.bytes = t, r.dataView = new DataView(t.buffer, t.byteOffset, t.byteLength), r.positionReadCount = /* @__PURE__ */ new Map(), r.recursiveReadLimit = e, r;
}
function jO(t, e = {}) {
  typeof e.size < "u" && io(t, { size: e.size });
  const r = xi(t, e);
  return wa(r, e);
}
function UO(t, e = {}) {
  let r = t;
  if (typeof e.size < "u" && (io(r, { size: e.size }), r = j0(r)), r.length > 1 || r[0] > 1)
    throw new DD(r);
  return !!r[0];
}
function Do(t, e = {}) {
  typeof e.size < "u" && io(t, { size: e.size });
  const r = xi(t, e);
  return xa(r, e);
}
function qO(t, e = {}) {
  let r = t;
  return typeof e.size < "u" && (io(r, { size: e.size }), r = j0(r, { dir: "right" })), new TextDecoder().decode(r);
}
function zO(t, e) {
  const r = typeof e == "string" ? Fo(e) : e, n = Wv(r);
  if (xn(r) === 0 && t.length > 0)
    throw new $v();
  if (xn(e) && xn(e) < 32)
    throw new xD({
      data: typeof e == "string" ? e : xi(e),
      params: t,
      size: xn(e)
    });
  let i = 0;
  const s = [];
  for (let o = 0; o < t.length; ++o) {
    const a = t[o];
    n.setPosition(i);
    const [u, l] = vu(n, a, {
      staticPosition: 0
    });
    i += l, s.push(u);
  }
  return s;
}
function vu(t, e, { staticPosition: r }) {
  const n = qv(e.type);
  if (n) {
    const [i, s] = n;
    return HO(t, { ...e, type: s }, { length: i, staticPosition: r });
  }
  if (e.type === "tuple")
    return YO(t, e, { staticPosition: r });
  if (e.type === "address")
    return WO(t);
  if (e.type === "bool")
    return KO(t);
  if (e.type.startsWith("bytes"))
    return VO(t, e, { staticPosition: r });
  if (e.type.startsWith("uint") || e.type.startsWith("int"))
    return GO(t, e);
  if (e.type === "string")
    return JO(t, { staticPosition: r });
  throw new ID(e.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
const q2 = 32, d1 = 32;
function WO(t) {
  const e = t.readBytes(32);
  return [Vl(xi(s4(e, -20))), 32];
}
function HO(t, e, { length: r, staticPosition: n }) {
  if (!r) {
    const o = Do(t.readBytes(d1)), a = n + o, u = a + q2;
    t.setPosition(a);
    const l = Do(t.readBytes(q2)), d = cl(e);
    let p = 0;
    const w = [];
    for (let _ = 0; _ < l; ++_) {
      t.setPosition(u + (d ? _ * 32 : p));
      const [P, O] = vu(t, e, {
        staticPosition: u
      });
      p += O, w.push(P);
    }
    return t.setPosition(n + 32), [w, 32];
  }
  if (cl(e)) {
    const o = Do(t.readBytes(d1)), a = n + o, u = [];
    for (let l = 0; l < r; ++l) {
      t.setPosition(a + l * 32);
      const [d] = vu(t, e, {
        staticPosition: a
      });
      u.push(d);
    }
    return t.setPosition(n + 32), [u, 32];
  }
  let i = 0;
  const s = [];
  for (let o = 0; o < r; ++o) {
    const [a, u] = vu(t, e, {
      staticPosition: n + i
    });
    i += u, s.push(a);
  }
  return [s, i];
}
function KO(t) {
  return [UO(t.readBytes(32), { size: 32 }), 32];
}
function VO(t, e, { staticPosition: r }) {
  const [n, i] = e.type.split("bytes");
  if (!i) {
    const o = Do(t.readBytes(32));
    t.setPosition(r + o);
    const a = Do(t.readBytes(32));
    if (a === 0)
      return t.setPosition(r + 32), ["0x", 32];
    const u = t.readBytes(a);
    return t.setPosition(r + 32), [xi(u), 32];
  }
  return [xi(t.readBytes(Number.parseInt(i), 32)), 32];
}
function GO(t, e) {
  const r = e.type.startsWith("int"), n = Number.parseInt(e.type.split("int")[1] || "256"), i = t.readBytes(32);
  return [
    n > 48 ? jO(i, { signed: r }) : Do(i, { signed: r }),
    32
  ];
}
function YO(t, e, { staticPosition: r }) {
  const n = e.components.length === 0 || e.components.some(({ name: o }) => !o), i = n ? [] : {};
  let s = 0;
  if (cl(e)) {
    const o = Do(t.readBytes(d1)), a = r + o;
    for (let u = 0; u < e.components.length; ++u) {
      const l = e.components[u];
      t.setPosition(a + s);
      const [d, p] = vu(t, l, {
        staticPosition: a
      });
      s += p, i[n ? u : l == null ? void 0 : l.name] = d;
    }
    return t.setPosition(r + 32), [i, 32];
  }
  for (let o = 0; o < e.components.length; ++o) {
    const a = e.components[o], [u, l] = vu(t, a, {
      staticPosition: r
    });
    i[n ? o : a == null ? void 0 : a.name] = u, s += l;
  }
  return [i, s];
}
function JO(t, { staticPosition: e }) {
  const r = Do(t.readBytes(32)), n = e + r;
  t.setPosition(n);
  const i = Do(t.readBytes(32));
  if (i === 0)
    return t.setPosition(e + 32), ["", 32];
  const s = t.readBytes(i, 32), o = qO(j0(s));
  return t.setPosition(e + 32), [o, 32];
}
function cl(t) {
  var n;
  const { type: e } = t;
  if (e === "string" || e === "bytes" || e.endsWith("[]"))
    return !0;
  if (e === "tuple")
    return (n = t.components) == null ? void 0 : n.some(cl);
  const r = qv(t.type);
  return !!(r && cl({ ...t, type: r[1] }));
}
function XO(t) {
  const { abi: e, data: r } = t, n = i0(r, 0, 4);
  if (n === "0x")
    throw new $v();
  const s = [...e || [], LO, kO].find((o) => o.type === "error" && n === zv(Mu(o)));
  if (!s)
    throw new F5(n, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem: s,
    args: "inputs" in s && s.inputs && s.inputs.length > 0 ? zO(s.inputs, i0(r, 4)) : void 0,
    errorName: s.name
  };
}
const Ac = (t, e, r) => JSON.stringify(t, (n, i) => typeof i == "bigint" ? i.toString() : i, r);
function l4({ abiItem: t, args: e, includeFunctionName: r = !0, includeName: n = !1 }) {
  if ("name" in t && "inputs" in t && t.inputs)
    return `${r ? t.name : ""}(${t.inputs.map((i, s) => `${n && i.name ? `${i.name}: ` : ""}${typeof e[s] == "object" ? Ac(e[s]) : e[s]}`).join(", ")})`;
}
const ZO = {
  gwei: 9,
  wei: 18
}, QO = {
  ether: -9,
  wei: 9
};
function h4(t, e) {
  let r = t.toString();
  const n = r.startsWith("-");
  n && (r = r.slice(1)), r = r.padStart(e, "0");
  let [i, s] = [
    r.slice(0, r.length - e),
    r.slice(r.length - e)
  ];
  return s = s.replace(/(0+)$/, ""), `${n ? "-" : ""}${i || "0"}${s ? `.${s}` : ""}`;
}
function d4(t, e = "wei") {
  return h4(t, ZO[e]);
}
function Ps(t, e = "wei") {
  return h4(t, QO[e]);
}
class eN extends gt {
  constructor({ address: e }) {
    super(`State for account "${e}" is set multiple times.`, {
      name: "AccountStateConflictError"
    });
  }
}
class tN extends gt {
  constructor() {
    super("state and stateDiff are set on the same account.", {
      name: "StateAssignmentConflictError"
    });
  }
}
function K0(t) {
  const e = Object.entries(t).map(([n, i]) => i === void 0 || i === !1 ? null : [n, i]).filter(Boolean), r = e.reduce((n, [i]) => Math.max(n, i.length), 0);
  return e.map(([n, i]) => `  ${`${n}:`.padEnd(r + 1)}  ${i}`).join(`
`);
}
class rN extends gt {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join(`
`), { name: "FeeConflictError" });
  }
}
class nN extends gt {
  constructor({ transaction: e }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        K0(e),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- an EIP-7702 Transaction with `authorizationList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ],
      name: "InvalidSerializableTransactionError"
    });
  }
}
class iN extends gt {
  constructor(e, { account: r, docsPath: n, chain: i, data: s, gas: o, gasPrice: a, maxFeePerGas: u, maxPriorityFeePerGas: l, nonce: d, to: p, value: w }) {
    var P;
    const _ = K0({
      chain: i && `${i == null ? void 0 : i.name} (id: ${i == null ? void 0 : i.id})`,
      from: r == null ? void 0 : r.address,
      to: p,
      value: typeof w < "u" && `${d4(w)} ${((P = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : P.symbol) || "ETH"}`,
      data: s,
      gas: o,
      gasPrice: typeof a < "u" && `${Ps(a)} gwei`,
      maxFeePerGas: typeof u < "u" && `${Ps(u)} gwei`,
      maxPriorityFeePerGas: typeof l < "u" && `${Ps(l)} gwei`,
      nonce: d
    });
    super(e.shortMessage, {
      cause: e,
      docsPath: n,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        "Request Arguments:",
        _
      ].filter(Boolean),
      name: "TransactionExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = e;
  }
}
const sN = (t) => t, p4 = (t) => t;
class oN extends gt {
  constructor(e, { abi: r, args: n, contractAddress: i, docsPath: s, functionName: o, sender: a }) {
    const u = c4({ abi: r, args: n, name: o }), l = u ? l4({
      abiItem: u,
      args: n,
      includeFunctionName: !1,
      includeName: !1
    }) : void 0, d = u ? Mu(u, { includeName: !0 }) : void 0, p = K0({
      address: i && sN(i),
      function: d,
      args: l && l !== "()" && `${[...Array((o == null ? void 0 : o.length) ?? 0).keys()].map(() => " ").join("")}${l}`,
      sender: a
    });
    super(e.shortMessage || `An unknown error occurred while executing the contract function "${o}".`, {
      cause: e,
      docsPath: s,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        p && "Contract Call:",
        p
      ].filter(Boolean),
      name: "ContractFunctionExecutionError"
    }), Object.defineProperty(this, "abi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "args", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "contractAddress", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "formattedArgs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "functionName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sender", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abi = r, this.args = n, this.cause = e, this.contractAddress = i, this.functionName = o, this.sender = a;
  }
}
class aN extends gt {
  constructor({ abi: e, data: r, functionName: n, message: i }) {
    let s, o, a, u;
    if (r && r !== "0x")
      try {
        o = XO({ abi: e, data: r });
        const { abiItem: d, errorName: p, args: w } = o;
        if (p === "Error")
          u = w[0];
        else if (p === "Panic") {
          const [_] = w;
          u = NO[_];
        } else {
          const _ = d ? Mu(d, { includeName: !0 }) : void 0, P = d && w ? l4({
            abiItem: d,
            args: w,
            includeFunctionName: !1,
            includeName: !1
          }) : void 0;
          a = [
            _ ? `Error: ${_}` : "",
            P && P !== "()" ? `       ${[...Array((p == null ? void 0 : p.length) ?? 0).keys()].map(() => " ").join("")}${P}` : ""
          ];
        }
      } catch (d) {
        s = d;
      }
    else i && (u = i);
    let l;
    s instanceof F5 && (l = s.signature, a = [
      `Unable to decode signature "${l}" as it was not found on the provided ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${l}.`
    ]), super(u && u !== "execution reverted" || l ? [
      `The contract function "${n}" reverted with the following ${l ? "signature" : "reason"}:`,
      u || l
    ].join(`
`) : `The contract function "${n}" reverted.`, {
      cause: s,
      metaMessages: a,
      name: "ContractFunctionRevertedError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "raw", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reason", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = o, this.raw = r, this.reason = u, this.signature = l;
  }
}
class cN extends gt {
  constructor({ functionName: e }) {
    super(`The contract function "${e}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${e}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ],
      name: "ContractFunctionZeroDataError"
    });
  }
}
class uN extends gt {
  constructor({ data: e, message: r }) {
    super(r || "", { name: "RawContractError" }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = e;
  }
}
class g4 extends gt {
  constructor({ body: e, cause: r, details: n, headers: i, status: s, url: o }) {
    super("HTTP request failed.", {
      cause: r,
      details: n,
      metaMessages: [
        s && `Status: ${s}`,
        `URL: ${p4(o)}`,
        e && `Request body: ${Ac(e)}`
      ].filter(Boolean),
      name: "HttpRequestError"
    }), Object.defineProperty(this, "body", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "url", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.body = e, this.headers = i, this.status = s, this.url = o;
  }
}
class m4 extends gt {
  constructor({ body: e, error: r, url: n }) {
    super("RPC Request failed.", {
      cause: r,
      details: r.message,
      metaMessages: [`URL: ${p4(n)}`, `Request body: ${Ac(e)}`],
      name: "RpcRequestError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.code = r.code, this.data = r.data;
  }
}
const fN = -1;
class Ai extends gt {
  constructor(e, { code: r, docsPath: n, metaMessages: i, name: s, shortMessage: o }) {
    super(o, {
      cause: e,
      docsPath: n,
      metaMessages: i || (e == null ? void 0 : e.metaMessages),
      name: s || "RpcError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = s || e.name, this.code = e instanceof m4 ? e.code : r ?? fN;
  }
}
class $i extends Ai {
  constructor(e, r) {
    super(e, r), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = r.data;
  }
}
class ul extends Ai {
  constructor(e) {
    super(e, {
      code: ul.code,
      name: "ParseRpcError",
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    });
  }
}
Object.defineProperty(ul, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32700
});
class fl extends Ai {
  constructor(e) {
    super(e, {
      code: fl.code,
      name: "InvalidRequestRpcError",
      shortMessage: "JSON is not a valid request object."
    });
  }
}
Object.defineProperty(fl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32600
});
class ll extends Ai {
  constructor(e, { method: r } = {}) {
    super(e, {
      code: ll.code,
      name: "MethodNotFoundRpcError",
      shortMessage: `The method${r ? ` "${r}"` : ""} does not exist / is not available.`
    });
  }
}
Object.defineProperty(ll, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32601
});
class hl extends Ai {
  constructor(e) {
    super(e, {
      code: hl.code,
      name: "InvalidParamsRpcError",
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    });
  }
}
Object.defineProperty(hl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602
});
class vc extends Ai {
  constructor(e) {
    super(e, {
      code: vc.code,
      name: "InternalRpcError",
      shortMessage: "An internal error was received."
    });
  }
}
Object.defineProperty(vc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603
});
class dl extends Ai {
  constructor(e) {
    super(e, {
      code: dl.code,
      name: "InvalidInputRpcError",
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    });
  }
}
Object.defineProperty(dl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32e3
});
class pl extends Ai {
  constructor(e) {
    super(e, {
      code: pl.code,
      name: "ResourceNotFoundRpcError",
      shortMessage: "Requested resource not found."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty(pl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32001
});
class gl extends Ai {
  constructor(e) {
    super(e, {
      code: gl.code,
      name: "ResourceUnavailableRpcError",
      shortMessage: "Requested resource not available."
    });
  }
}
Object.defineProperty(gl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32002
});
class ml extends Ai {
  constructor(e) {
    super(e, {
      code: ml.code,
      name: "TransactionRejectedRpcError",
      shortMessage: "Transaction creation failed."
    });
  }
}
Object.defineProperty(ml, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32003
});
class cc extends Ai {
  constructor(e, { method: r } = {}) {
    super(e, {
      code: cc.code,
      name: "MethodNotSupportedRpcError",
      shortMessage: `Method${r ? ` "${r}"` : ""} is not supported.`
    });
  }
}
Object.defineProperty(cc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32004
});
class Iu extends Ai {
  constructor(e) {
    super(e, {
      code: Iu.code,
      name: "LimitExceededRpcError",
      shortMessage: "Request exceeds defined limit."
    });
  }
}
Object.defineProperty(Iu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32005
});
class vl extends Ai {
  constructor(e) {
    super(e, {
      code: vl.code,
      name: "JsonRpcVersionUnsupportedError",
      shortMessage: "Version of JSON-RPC protocol is not supported."
    });
  }
}
Object.defineProperty(vl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32006
});
class bu extends $i {
  constructor(e) {
    super(e, {
      code: bu.code,
      name: "UserRejectedRequestError",
      shortMessage: "User rejected the request."
    });
  }
}
Object.defineProperty(bu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4001
});
class bl extends $i {
  constructor(e) {
    super(e, {
      code: bl.code,
      name: "UnauthorizedProviderError",
      shortMessage: "The requested method and/or account has not been authorized by the user."
    });
  }
}
Object.defineProperty(bl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4100
});
class yl extends $i {
  constructor(e, { method: r } = {}) {
    super(e, {
      code: yl.code,
      name: "UnsupportedProviderMethodError",
      shortMessage: `The Provider does not support the requested method${r ? ` " ${r}"` : ""}.`
    });
  }
}
Object.defineProperty(yl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4200
});
class wl extends $i {
  constructor(e) {
    super(e, {
      code: wl.code,
      name: "ProviderDisconnectedError",
      shortMessage: "The Provider is disconnected from all chains."
    });
  }
}
Object.defineProperty(wl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4900
});
class xl extends $i {
  constructor(e) {
    super(e, {
      code: xl.code,
      name: "ChainDisconnectedError",
      shortMessage: "The Provider is not connected to the requested chain."
    });
  }
}
Object.defineProperty(xl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4901
});
class _l extends $i {
  constructor(e) {
    super(e, {
      code: _l.code,
      name: "SwitchChainError",
      shortMessage: "An error occurred when attempting to switch chain."
    });
  }
}
Object.defineProperty(_l, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4902
});
class Cu extends $i {
  constructor(e) {
    super(e, {
      code: Cu.code,
      name: "UnsupportedNonOptionalCapabilityError",
      shortMessage: "This Wallet does not support a capability that was not marked as optional."
    });
  }
}
Object.defineProperty(Cu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5700
});
class El extends $i {
  constructor(e) {
    super(e, {
      code: El.code,
      name: "UnsupportedChainIdError",
      shortMessage: "This Wallet does not support the requested chain ID."
    });
  }
}
Object.defineProperty(El, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5710
});
class Sl extends $i {
  constructor(e) {
    super(e, {
      code: Sl.code,
      name: "DuplicateIdError",
      shortMessage: "There is already a bundle submitted with this ID."
    });
  }
}
Object.defineProperty(Sl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5720
});
class Al extends $i {
  constructor(e) {
    super(e, {
      code: Al.code,
      name: "UnknownBundleIdError",
      shortMessage: "This bundle id is unknown / has not been submitted"
    });
  }
}
Object.defineProperty(Al, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5730
});
class Pl extends $i {
  constructor(e) {
    super(e, {
      code: Pl.code,
      name: "BundleTooLargeError",
      shortMessage: "The call bundle is too large for the Wallet to process."
    });
  }
}
Object.defineProperty(Pl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5740
});
class Ml extends $i {
  constructor(e) {
    super(e, {
      code: Ml.code,
      name: "AtomicReadyWalletRejectedUpgradeError",
      shortMessage: "The Wallet can support atomicity after an upgrade, but the user rejected the upgrade."
    });
  }
}
Object.defineProperty(Ml, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5750
});
class Tu extends $i {
  constructor(e) {
    super(e, {
      code: Tu.code,
      name: "AtomicityNotSupportedError",
      shortMessage: "The wallet does not support atomic execution but the request requires it."
    });
  }
}
Object.defineProperty(Tu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 5760
});
class lN extends Ai {
  constructor(e) {
    super(e, {
      name: "UnknownRpcError",
      shortMessage: "An unknown RPC error occurred."
    });
  }
}
const hN = 3;
function dN(t, { abi: e, address: r, args: n, docsPath: i, functionName: s, sender: o }) {
  const a = t instanceof uN ? t : t instanceof gt ? t.walk((P) => "data" in P) || t.walk() : {}, { code: u, data: l, details: d, message: p, shortMessage: w } = a, _ = t instanceof $v ? new cN({ functionName: s }) : [hN, vc.code].includes(u) && (l || d || p || w) ? new aN({
    abi: e,
    data: typeof l == "object" ? l.data : l,
    functionName: s,
    message: a instanceof m4 ? d : w ?? p
  }) : t;
  return new oN(_, {
    abi: e,
    args: n,
    contractAddress: r,
    docsPath: i,
    functionName: s,
    sender: o
  });
}
function pN(t) {
  const e = z0(`0x${t.substring(4)}`).substring(26);
  return Vl(`0x${e}`);
}
async function gN({ hash: t, signature: e }) {
  const r = ya(t) ? t : t0(t), { secp256k1: n } = await import("./secp256k1-D5_JzNmG.js");
  return `0x${(() => {
    if (typeof e == "object" && "r" in e && "s" in e) {
      const { r: l, s: d, v: p, yParity: w } = e, _ = Number(w ?? p), P = z2(_);
      return new n.Signature(wa(l), wa(d)).addRecoveryBit(P);
    }
    const o = ya(e) ? e : t0(e);
    if (xn(o) !== 65)
      throw new Error("invalid signature length");
    const a = xa(`0x${o.slice(130)}`), u = z2(a);
    return n.Signature.fromCompact(o.substring(2, 130)).addRecoveryBit(u);
  })().recoverPublicKey(r.substring(2)).toHex(!1)}`;
}
function z2(t) {
  if (t === 0 || t === 1)
    return t;
  if (t === 27)
    return 0;
  if (t === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}
async function mN({ hash: t, signature: e }) {
  return pN(await gN({ hash: t, signature: e }));
}
function vN(t, e = "hex") {
  const r = v4(t), n = Wv(new Uint8Array(r.length));
  return r.encode(n), e === "hex" ? xi(n.bytes) : n.bytes;
}
function v4(t) {
  return Array.isArray(t) ? bN(t.map((e) => v4(e))) : yN(t);
}
function bN(t) {
  const e = t.reduce((i, s) => i + s.length, 0), r = b4(e);
  return {
    length: e <= 55 ? 1 + e : 1 + r + e,
    encode(i) {
      e <= 55 ? i.pushByte(192 + e) : (i.pushByte(247 + r), r === 1 ? i.pushUint8(e) : r === 2 ? i.pushUint16(e) : r === 3 ? i.pushUint24(e) : i.pushUint32(e));
      for (const { encode: s } of t)
        s(i);
    }
  };
}
function yN(t) {
  const e = typeof t == "string" ? Fo(t) : t, r = b4(e.length);
  return {
    length: e.length === 1 && e[0] < 128 ? 1 : e.length <= 55 ? 1 + e.length : 1 + r + e.length,
    encode(i) {
      e.length === 1 && e[0] < 128 ? i.pushBytes(e) : e.length <= 55 ? (i.pushByte(128 + e.length), i.pushBytes(e)) : (i.pushByte(183 + r), r === 1 ? i.pushUint8(e.length) : r === 2 ? i.pushUint16(e.length) : r === 3 ? i.pushUint24(e.length) : i.pushUint32(e.length), i.pushBytes(e));
    }
  };
}
function b4(t) {
  if (t < 2 ** 8)
    return 1;
  if (t < 2 ** 16)
    return 2;
  if (t < 2 ** 24)
    return 3;
  if (t < 2 ** 32)
    return 4;
  throw new gt("Length is too large.");
}
function wN(t) {
  const { chainId: e, nonce: r, to: n } = t, i = t.contractAddress ?? t.address, s = z0(H0([
    "0x05",
    vN([
      e ? vr(e) : "0x",
      i,
      r ? vr(r) : "0x"
    ])
  ]));
  return n === "bytes" ? Fo(s) : s;
}
async function y4(t) {
  const { authorization: e, signature: r } = t;
  return mN({
    hash: wN(e),
    signature: r ?? e
  });
}
class xN extends gt {
  constructor(e, { account: r, docsPath: n, chain: i, data: s, gas: o, gasPrice: a, maxFeePerGas: u, maxPriorityFeePerGas: l, nonce: d, to: p, value: w }) {
    var P;
    const _ = K0({
      from: r == null ? void 0 : r.address,
      to: p,
      value: typeof w < "u" && `${d4(w)} ${((P = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : P.symbol) || "ETH"}`,
      data: s,
      gas: o,
      gasPrice: typeof a < "u" && `${Ps(a)} gwei`,
      maxFeePerGas: typeof u < "u" && `${Ps(u)} gwei`,
      maxPriorityFeePerGas: typeof l < "u" && `${Ps(l)} gwei`,
      nonce: d
    });
    super(e.shortMessage, {
      cause: e,
      docsPath: n,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        _
      ].filter(Boolean),
      name: "EstimateGasExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = e;
  }
}
class cu extends gt {
  constructor({ cause: e, message: r } = {}) {
    var i;
    const n = (i = r == null ? void 0 : r.replace("execution reverted: ", "")) == null ? void 0 : i.replace("execution reverted", "");
    super(`Execution reverted ${n ? `with reason: ${n}` : "for an unknown reason"}.`, {
      cause: e,
      name: "ExecutionRevertedError"
    });
  }
}
Object.defineProperty(cu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3
});
Object.defineProperty(cu, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class s0 extends gt {
  constructor({ cause: e, maxFeePerGas: r } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${r ? ` = ${Ps(r)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: e,
      name: "FeeCapTooHighError"
    });
  }
}
Object.defineProperty(s0, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class p1 extends gt {
  constructor({ cause: e, maxFeePerGas: r } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${r ? ` = ${Ps(r)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause: e,
      name: "FeeCapTooLowError"
    });
  }
}
Object.defineProperty(p1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class g1 extends gt {
  constructor({ cause: e, nonce: r } = {}) {
    super(`Nonce provided for the transaction ${r ? `(${r}) ` : ""}is higher than the next one expected.`, { cause: e, name: "NonceTooHighError" });
  }
}
Object.defineProperty(g1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/
});
class m1 extends gt {
  constructor({ cause: e, nonce: r } = {}) {
    super([
      `Nonce provided for the transaction ${r ? `(${r}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join(`
`), { cause: e, name: "NonceTooLowError" });
  }
}
Object.defineProperty(m1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/
});
class v1 extends gt {
  constructor({ cause: e, nonce: r } = {}) {
    super(`Nonce provided for the transaction ${r ? `(${r}) ` : ""}exceeds the maximum allowed nonce.`, { cause: e, name: "NonceMaxValueError" });
  }
}
Object.defineProperty(v1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/
});
class b1 extends gt {
  constructor({ cause: e } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join(`
`), {
      cause: e,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ],
      name: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(b1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds|exceeds transaction sender account balance/
});
class y1 extends gt {
  constructor({ cause: e, gas: r } = {}) {
    super(`The amount of gas ${r ? `(${r}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause: e,
      name: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(y1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/
});
class w1 extends gt {
  constructor({ cause: e, gas: r } = {}) {
    super(`The amount of gas ${r ? `(${r}) ` : ""}provided for the transaction is too low.`, {
      cause: e,
      name: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(w1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/
});
class x1 extends gt {
  constructor({ cause: e }) {
    super("The transaction type is not supported for this chain.", {
      cause: e,
      name: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(x1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/
});
class o0 extends gt {
  constructor({ cause: e, maxPriorityFeePerGas: r, maxFeePerGas: n } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${r ? ` = ${Ps(r)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${n ? ` = ${Ps(n)} gwei` : ""}).`
    ].join(`
`), {
      cause: e,
      name: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(o0, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class Hv extends gt {
  constructor({ cause: e }) {
    super(`An error occurred while executing: ${e == null ? void 0 : e.shortMessage}`, {
      cause: e,
      name: "UnknownNodeError"
    });
  }
}
function w4(t, e) {
  const r = (t.details || "").toLowerCase(), n = t instanceof gt ? t.walk((i) => (i == null ? void 0 : i.code) === cu.code) : t;
  return n instanceof gt ? new cu({
    cause: t,
    message: n.details
  }) : cu.nodeMessage.test(r) ? new cu({
    cause: t,
    message: t.details
  }) : s0.nodeMessage.test(r) ? new s0({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas
  }) : p1.nodeMessage.test(r) ? new p1({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas
  }) : g1.nodeMessage.test(r) ? new g1({ cause: t, nonce: e == null ? void 0 : e.nonce }) : m1.nodeMessage.test(r) ? new m1({ cause: t, nonce: e == null ? void 0 : e.nonce }) : v1.nodeMessage.test(r) ? new v1({ cause: t, nonce: e == null ? void 0 : e.nonce }) : b1.nodeMessage.test(r) ? new b1({ cause: t }) : y1.nodeMessage.test(r) ? new y1({ cause: t, gas: e == null ? void 0 : e.gas }) : w1.nodeMessage.test(r) ? new w1({ cause: t, gas: e == null ? void 0 : e.gas }) : x1.nodeMessage.test(r) ? new x1({ cause: t }) : o0.nodeMessage.test(r) ? new o0({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas,
    maxPriorityFeePerGas: e == null ? void 0 : e.maxPriorityFeePerGas
  }) : new Hv({
    cause: t
  });
}
function _N(t, { docsPath: e, ...r }) {
  const n = (() => {
    const i = w4(t, r);
    return i instanceof Hv ? t : i;
  })();
  return new xN(n, {
    docsPath: e,
    ...r
  });
}
function x4(t, { format: e }) {
  if (!e)
    return {};
  const r = {};
  function n(s) {
    const o = Object.keys(s);
    for (const a of o)
      a in t && (r[a] = t[a]), s[a] && typeof s[a] == "object" && !Array.isArray(s[a]) && n(s[a]);
  }
  const i = e(t || {});
  return n(i), r;
}
const EN = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
function Kv(t) {
  const e = {};
  return typeof t.authorizationList < "u" && (e.authorizationList = SN(t.authorizationList)), typeof t.accessList < "u" && (e.accessList = t.accessList), typeof t.blobVersionedHashes < "u" && (e.blobVersionedHashes = t.blobVersionedHashes), typeof t.blobs < "u" && (typeof t.blobs[0] != "string" ? e.blobs = t.blobs.map((r) => xi(r)) : e.blobs = t.blobs), typeof t.data < "u" && (e.data = t.data), typeof t.from < "u" && (e.from = t.from), typeof t.gas < "u" && (e.gas = vr(t.gas)), typeof t.gasPrice < "u" && (e.gasPrice = vr(t.gasPrice)), typeof t.maxFeePerBlobGas < "u" && (e.maxFeePerBlobGas = vr(t.maxFeePerBlobGas)), typeof t.maxFeePerGas < "u" && (e.maxFeePerGas = vr(t.maxFeePerGas)), typeof t.maxPriorityFeePerGas < "u" && (e.maxPriorityFeePerGas = vr(t.maxPriorityFeePerGas)), typeof t.nonce < "u" && (e.nonce = vr(t.nonce)), typeof t.to < "u" && (e.to = t.to), typeof t.type < "u" && (e.type = EN[t.type]), typeof t.value < "u" && (e.value = vr(t.value)), e;
}
function SN(t) {
  return t.map((e) => ({
    address: e.address,
    r: e.r ? vr(BigInt(e.r)) : e.r,
    s: e.s ? vr(BigInt(e.s)) : e.s,
    chainId: vr(e.chainId),
    nonce: vr(e.nonce),
    ...typeof e.yParity < "u" ? { yParity: vr(e.yParity) } : {},
    ...typeof e.v < "u" && typeof e.yParity > "u" ? { v: vr(e.v) } : {}
  }));
}
function W2(t) {
  if (!(!t || t.length === 0))
    return t.reduce((e, { slot: r, value: n }) => {
      if (r.length !== 66)
        throw new O2({
          size: r.length,
          targetSize: 66,
          type: "hex"
        });
      if (n.length !== 66)
        throw new O2({
          size: n.length,
          targetSize: 66,
          type: "hex"
        });
      return e[r] = n, e;
    }, {});
}
function AN(t) {
  const { balance: e, nonce: r, state: n, stateDiff: i, code: s } = t, o = {};
  if (s !== void 0 && (o.code = s), e !== void 0 && (o.balance = vr(e)), r !== void 0 && (o.nonce = vr(r)), n !== void 0 && (o.state = W2(n)), i !== void 0) {
    if (o.state)
      throw new tN();
    o.stateDiff = W2(i);
  }
  return o;
}
function PN(t) {
  if (!t)
    return;
  const e = {};
  for (const { address: r, ...n } of t) {
    if (!Ms(r, { strict: !1 }))
      throw new _a({ address: r });
    if (e[r])
      throw new eN({ address: r });
    e[r] = AN(n);
  }
  return e;
}
const MN = 2n ** 256n - 1n;
function V0(t) {
  const { account: e, gasPrice: r, maxFeePerGas: n, maxPriorityFeePerGas: i, to: s } = t, o = e ? _i(e) : void 0;
  if (o && !Ms(o.address))
    throw new _a({ address: o.address });
  if (s && !Ms(s))
    throw new _a({ address: s });
  if (typeof r < "u" && (typeof n < "u" || typeof i < "u"))
    throw new rN();
  if (n && n > MN)
    throw new s0({ maxFeePerGas: n });
  if (i && n && i > n)
    throw new o0({ maxFeePerGas: n, maxPriorityFeePerGas: i });
}
class IN extends gt {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError"
    });
  }
}
class Vv extends gt {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError"
    });
  }
}
class CN extends gt {
  constructor({ maxPriorityFeePerGas: e }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${Ps(e)} gwei).`, { name: "MaxFeePerGasTooLowError" });
  }
}
class TN extends gt {
  constructor({ blockHash: e, blockNumber: r }) {
    let n = "Block";
    e && (n = `Block at hash "${e}"`), r && (n = `Block at number "${r}"`), super(`${n} could not be found.`, { name: "BlockNotFoundError" });
  }
}
const RN = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function DN(t) {
  const e = {
    ...t,
    blockHash: t.blockHash ? t.blockHash : null,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    chainId: t.chainId ? xa(t.chainId) : void 0,
    gas: t.gas ? BigInt(t.gas) : void 0,
    gasPrice: t.gasPrice ? BigInt(t.gasPrice) : void 0,
    maxFeePerBlobGas: t.maxFeePerBlobGas ? BigInt(t.maxFeePerBlobGas) : void 0,
    maxFeePerGas: t.maxFeePerGas ? BigInt(t.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: t.maxPriorityFeePerGas ? BigInt(t.maxPriorityFeePerGas) : void 0,
    nonce: t.nonce ? xa(t.nonce) : void 0,
    to: t.to ? t.to : null,
    transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
    type: t.type ? RN[t.type] : void 0,
    typeHex: t.type ? t.type : void 0,
    value: t.value ? BigInt(t.value) : void 0,
    v: t.v ? BigInt(t.v) : void 0
  };
  return t.authorizationList && (e.authorizationList = ON(t.authorizationList)), e.yParity = (() => {
    if (t.yParity)
      return Number(t.yParity);
    if (typeof e.v == "bigint") {
      if (e.v === 0n || e.v === 27n)
        return 0;
      if (e.v === 1n || e.v === 28n)
        return 1;
      if (e.v >= 35n)
        return e.v % 2n === 0n ? 1 : 0;
    }
  })(), e.type === "legacy" && (delete e.accessList, delete e.maxFeePerBlobGas, delete e.maxFeePerGas, delete e.maxPriorityFeePerGas, delete e.yParity), e.type === "eip2930" && (delete e.maxFeePerBlobGas, delete e.maxFeePerGas, delete e.maxPriorityFeePerGas), e.type === "eip1559" && delete e.maxFeePerBlobGas, e;
}
function ON(t) {
  return t.map((e) => ({
    address: e.address,
    chainId: Number(e.chainId),
    nonce: Number(e.nonce),
    r: e.r,
    s: e.s,
    yParity: Number(e.yParity)
  }));
}
function NN(t) {
  const e = (t.transactions ?? []).map((r) => typeof r == "string" ? r : DN(r));
  return {
    ...t,
    baseFeePerGas: t.baseFeePerGas ? BigInt(t.baseFeePerGas) : null,
    blobGasUsed: t.blobGasUsed ? BigInt(t.blobGasUsed) : void 0,
    difficulty: t.difficulty ? BigInt(t.difficulty) : void 0,
    excessBlobGas: t.excessBlobGas ? BigInt(t.excessBlobGas) : void 0,
    gasLimit: t.gasLimit ? BigInt(t.gasLimit) : void 0,
    gasUsed: t.gasUsed ? BigInt(t.gasUsed) : void 0,
    hash: t.hash ? t.hash : null,
    logsBloom: t.logsBloom ? t.logsBloom : null,
    nonce: t.nonce ? t.nonce : null,
    number: t.number ? BigInt(t.number) : null,
    size: t.size ? BigInt(t.size) : void 0,
    timestamp: t.timestamp ? BigInt(t.timestamp) : void 0,
    transactions: e,
    totalDifficulty: t.totalDifficulty ? BigInt(t.totalDifficulty) : null
  };
}
async function a0(t, { blockHash: e, blockNumber: r, blockTag: n, includeTransactions: i } = {}) {
  var d, p, w;
  const s = n ?? "latest", o = i ?? !1, a = r !== void 0 ? vr(r) : void 0;
  let u = null;
  if (e ? u = await t.request({
    method: "eth_getBlockByHash",
    params: [e, o]
  }, { dedupe: !0 }) : u = await t.request({
    method: "eth_getBlockByNumber",
    params: [a || s, o]
  }, { dedupe: !!a }), !u)
    throw new TN({ blockHash: e, blockNumber: r });
  return (((w = (p = (d = t.chain) == null ? void 0 : d.formatters) == null ? void 0 : p.block) == null ? void 0 : w.format) || NN)(u);
}
async function _4(t) {
  const e = await t.request({
    method: "eth_gasPrice"
  });
  return BigInt(e);
}
async function LN(t, e) {
  var s, o;
  const { block: r, chain: n = t.chain, request: i } = e || {};
  try {
    const a = ((s = n == null ? void 0 : n.fees) == null ? void 0 : s.maxPriorityFeePerGas) ?? ((o = n == null ? void 0 : n.fees) == null ? void 0 : o.defaultPriorityFee);
    if (typeof a == "function") {
      const l = r || await Xn(t, a0, "getBlock")({}), d = await a({
        block: l,
        client: t,
        request: i
      });
      if (d === null)
        throw new Error();
      return d;
    }
    if (typeof a < "u")
      return a;
    const u = await t.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return wa(u);
  } catch {
    const [a, u] = await Promise.all([
      r ? Promise.resolve(r) : Xn(t, a0, "getBlock")({}),
      Xn(t, _4, "getGasPrice")({})
    ]);
    if (typeof a.baseFeePerGas != "bigint")
      throw new Vv();
    const l = u - a.baseFeePerGas;
    return l < 0n ? 0n : l;
  }
}
async function H2(t, e) {
  var w, _;
  const { block: r, chain: n = t.chain, request: i, type: s = "eip1559" } = e || {}, o = await (async () => {
    var P, O;
    return typeof ((P = n == null ? void 0 : n.fees) == null ? void 0 : P.baseFeeMultiplier) == "function" ? n.fees.baseFeeMultiplier({
      block: r,
      client: t,
      request: i
    }) : ((O = n == null ? void 0 : n.fees) == null ? void 0 : O.baseFeeMultiplier) ?? 1.2;
  })();
  if (o < 1)
    throw new IN();
  const u = 10 ** (((w = o.toString().split(".")[1]) == null ? void 0 : w.length) ?? 0), l = (P) => P * BigInt(Math.ceil(o * u)) / BigInt(u), d = r || await Xn(t, a0, "getBlock")({});
  if (typeof ((_ = n == null ? void 0 : n.fees) == null ? void 0 : _.estimateFeesPerGas) == "function") {
    const P = await n.fees.estimateFeesPerGas({
      block: r,
      client: t,
      multiply: l,
      request: i,
      type: s
    });
    if (P !== null)
      return P;
  }
  if (s === "eip1559") {
    if (typeof d.baseFeePerGas != "bigint")
      throw new Vv();
    const P = typeof (i == null ? void 0 : i.maxPriorityFeePerGas) == "bigint" ? i.maxPriorityFeePerGas : await LN(t, {
      block: d,
      chain: n,
      request: i
    }), O = l(d.baseFeePerGas);
    return {
      maxFeePerGas: (i == null ? void 0 : i.maxFeePerGas) ?? O + P,
      maxPriorityFeePerGas: P
    };
  }
  return {
    gasPrice: (i == null ? void 0 : i.gasPrice) ?? l(await Xn(t, _4, "getGasPrice")({}))
  };
}
async function E4(t, { address: e, blockTag: r = "latest", blockNumber: n }) {
  const i = await t.request({
    method: "eth_getTransactionCount",
    params: [
      e,
      typeof n == "bigint" ? vr(n) : r
    ]
  }, {
    dedupe: !!n
  });
  return xa(i);
}
function S4(t) {
  const { kzg: e } = t, r = t.to ?? (typeof t.blobs[0] == "string" ? "hex" : "bytes"), n = typeof t.blobs[0] == "string" ? t.blobs.map((s) => Fo(s)) : t.blobs, i = [];
  for (const s of n)
    i.push(Uint8Array.from(e.blobToKzgCommitment(s)));
  return r === "bytes" ? i : i.map((s) => xi(s));
}
function A4(t) {
  const { kzg: e } = t, r = t.to ?? (typeof t.blobs[0] == "string" ? "hex" : "bytes"), n = typeof t.blobs[0] == "string" ? t.blobs.map((o) => Fo(o)) : t.blobs, i = typeof t.commitments[0] == "string" ? t.commitments.map((o) => Fo(o)) : t.commitments, s = [];
  for (let o = 0; o < n.length; o++) {
    const a = n[o], u = i[o];
    s.push(Uint8Array.from(e.computeBlobKzgProof(a, u)));
  }
  return r === "bytes" ? s : s.map((o) => xi(o));
}
function kN(t, e, r, n) {
  if (typeof t.setBigUint64 == "function")
    return t.setBigUint64(e, r, n);
  const i = BigInt(32), s = BigInt(4294967295), o = Number(r >> i & s), a = Number(r & s), u = n ? 4 : 0, l = n ? 0 : 4;
  t.setUint32(e + u, o, n), t.setUint32(e + l, a, n);
}
function $N(t, e, r) {
  return t & e ^ ~t & r;
}
function BN(t, e, r) {
  return t & e ^ t & r ^ e & r;
}
class FN extends V5 {
  constructor(e, r, n, i) {
    super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = e, this.outputLen = r, this.padOffset = n, this.isLE = i, this.buffer = new Uint8Array(e), this.view = Zg(this.buffer);
  }
  update(e) {
    n0(this), e = q0(e), mc(e);
    const { view: r, buffer: n, blockLen: i } = this, s = e.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const u = Zg(e);
        for (; i <= s - o; o += i)
          this.process(u, o);
        continue;
      }
      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    n0(this), H5(e, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    r[o++] = 128, al(this.buffer.subarray(o)), this.padOffset > i - o && (this.process(n, 0), o = 0);
    for (let p = o; p < i; p++)
      r[p] = 0;
    kN(n, i - 8, BigInt(this.length * 8), s), this.process(n, 0);
    const a = Zg(e), u = this.outputLen;
    if (u % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = u / 4, d = this.get();
    if (l > d.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let p = 0; p < l; p++)
      a.setUint32(4 * p, d[p], s);
  }
  digest() {
    const { buffer: e, outputLen: r } = this;
    this.digestInto(e);
    const n = e.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: s, destroyed: o, pos: a } = this;
    return e.destroyed = o, e.finished = s, e.length = i, e.pos = a, i % r && e.buffer.set(n), e;
  }
  clone() {
    return this._cloneInto();
  }
}
const ta = /* @__PURE__ */ Uint32Array.from([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), jN = /* @__PURE__ */ Uint32Array.from([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), ra = /* @__PURE__ */ new Uint32Array(64);
let UN = class extends FN {
  constructor(e = 32) {
    super(64, e, 8, !1), this.A = ta[0] | 0, this.B = ta[1] | 0, this.C = ta[2] | 0, this.D = ta[3] | 0, this.E = ta[4] | 0, this.F = ta[5] | 0, this.G = ta[6] | 0, this.H = ta[7] | 0;
  }
  get() {
    const { A: e, B: r, C: n, D: i, E: s, F: o, G: a, H: u } = this;
    return [e, r, n, i, s, o, a, u];
  }
  // prettier-ignore
  set(e, r, n, i, s, o, a, u) {
    this.A = e | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = u | 0;
  }
  process(e, r) {
    for (let p = 0; p < 16; p++, r += 4)
      ra[p] = e.getUint32(r, !1);
    for (let p = 16; p < 64; p++) {
      const w = ra[p - 15], _ = ra[p - 2], P = $s(w, 7) ^ $s(w, 18) ^ w >>> 3, O = $s(_, 17) ^ $s(_, 19) ^ _ >>> 10;
      ra[p] = O + ra[p - 7] + P + ra[p - 16] | 0;
    }
    let { A: n, B: i, C: s, D: o, E: a, F: u, G: l, H: d } = this;
    for (let p = 0; p < 64; p++) {
      const w = $s(a, 6) ^ $s(a, 11) ^ $s(a, 25), _ = d + w + $N(a, u, l) + jN[p] + ra[p] | 0, O = ($s(n, 2) ^ $s(n, 13) ^ $s(n, 22)) + BN(n, i, s) | 0;
      d = l, l = u, u = a, a = o + _ | 0, o = s, s = i, i = n, n = _ + O | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, l = l + this.G | 0, d = d + this.H | 0, this.set(n, i, s, o, a, u, l, d);
  }
  roundClean() {
    al(ra);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), al(this.buffer);
  }
};
const qN = /* @__PURE__ */ G5(() => new UN()), P4 = qN;
function zN(t, e) {
  return P4(ya(t, { strict: !1 }) ? Bv(t) : t);
}
function WN(t) {
  const { commitment: e, version: r = 1 } = t, n = t.to ?? (typeof e == "string" ? "hex" : "bytes"), i = zN(e);
  return i.set([r], 0), n === "bytes" ? i : xi(i);
}
function HN(t) {
  const { commitments: e, version: r } = t, n = t.to ?? (typeof e[0] == "string" ? "hex" : "bytes"), i = [];
  for (const s of e)
    i.push(WN({
      commitment: s,
      to: n,
      version: r
    }));
  return i;
}
const K2 = 6, M4 = 32, Gv = 4096, I4 = M4 * Gv, V2 = I4 * K2 - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * Gv * K2;
class KN extends gt {
  constructor({ maxSize: e, size: r }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${e} bytes`, `Given: ${r} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
}
class VN extends gt {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}
function GN(t) {
  const e = t.to ?? (typeof t.data == "string" ? "hex" : "bytes"), r = typeof t.data == "string" ? Fo(t.data) : t.data, n = xn(r);
  if (!n)
    throw new VN();
  if (n > V2)
    throw new KN({
      maxSize: V2,
      size: n
    });
  const i = [];
  let s = !0, o = 0;
  for (; s; ) {
    const a = Wv(new Uint8Array(I4));
    let u = 0;
    for (; u < Gv; ) {
      const l = r.slice(o, o + (M4 - 1));
      if (a.pushByte(0), a.pushBytes(l), l.length < 31) {
        a.pushByte(128), s = !1;
        break;
      }
      u++, o += 31;
    }
    i.push(a);
  }
  return e === "bytes" ? i.map((a) => a.bytes) : i.map((a) => xi(a.bytes));
}
function YN(t) {
  const { data: e, kzg: r, to: n } = t, i = t.blobs ?? GN({ data: e, to: n }), s = t.commitments ?? S4({ blobs: i, kzg: r, to: n }), o = t.proofs ?? A4({ blobs: i, commitments: s, kzg: r, to: n }), a = [];
  for (let u = 0; u < i.length; u++)
    a.push({
      blob: i[u],
      commitment: s[u],
      proof: o[u]
    });
  return a;
}
function JN(t) {
  if (t.type)
    return t.type;
  if (typeof t.authorizationList < "u")
    return "eip7702";
  if (typeof t.blobs < "u" || typeof t.blobVersionedHashes < "u" || typeof t.maxFeePerBlobGas < "u" || typeof t.sidecars < "u")
    return "eip4844";
  if (typeof t.maxFeePerGas < "u" || typeof t.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof t.gasPrice < "u")
    return typeof t.accessList < "u" ? "eip2930" : "legacy";
  throw new nN({ transaction: t });
}
async function Gl(t) {
  const e = await t.request({
    method: "eth_chainId"
  }, { dedupe: !0 });
  return xa(e);
}
const C4 = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
], G2 = /* @__PURE__ */ new Map();
async function Yv(t, e) {
  const { account: r = t.account, blobs: n, chain: i, gas: s, kzg: o, nonce: a, nonceManager: u, parameters: l = C4, type: d } = e, p = r && _i(r), w = { ...e, ...p ? { from: p == null ? void 0 : p.address } : {} };
  let _;
  async function P() {
    return _ || (_ = await Xn(t, a0, "getBlock")({ blockTag: "latest" }), _);
  }
  let O;
  async function L() {
    return O || (i ? i.id : typeof e.chainId < "u" ? e.chainId : (O = await Xn(t, Gl, "getChainId")({}), O));
  }
  if (l.includes("nonce") && typeof a > "u" && p)
    if (u) {
      const B = await L();
      w.nonce = await u.consume({
        address: p.address,
        chainId: B,
        client: t
      });
    } else
      w.nonce = await Xn(t, E4, "getTransactionCount")({
        address: p.address,
        blockTag: "pending"
      });
  if ((l.includes("blobVersionedHashes") || l.includes("sidecars")) && n && o) {
    const B = S4({ blobs: n, kzg: o });
    if (l.includes("blobVersionedHashes")) {
      const k = HN({
        commitments: B,
        to: "hex"
      });
      w.blobVersionedHashes = k;
    }
    if (l.includes("sidecars")) {
      const k = A4({ blobs: n, commitments: B, kzg: o }), q = YN({
        blobs: n,
        commitments: B,
        proofs: k,
        to: "hex"
      });
      w.sidecars = q;
    }
  }
  if (l.includes("chainId") && (w.chainId = await L()), (l.includes("fees") || l.includes("type")) && typeof d > "u")
    try {
      w.type = JN(w);
    } catch {
      let B = G2.get(t.uid);
      if (typeof B > "u") {
        const k = await P();
        B = typeof (k == null ? void 0 : k.baseFeePerGas) == "bigint", G2.set(t.uid, B);
      }
      w.type = B ? "eip1559" : "legacy";
    }
  if (l.includes("fees"))
    if (w.type !== "legacy" && w.type !== "eip2930") {
      if (typeof w.maxFeePerGas > "u" || typeof w.maxPriorityFeePerGas > "u") {
        const B = await P(), { maxFeePerGas: k, maxPriorityFeePerGas: q } = await H2(t, {
          block: B,
          chain: i,
          request: w
        });
        if (typeof e.maxPriorityFeePerGas > "u" && e.maxFeePerGas && e.maxFeePerGas < q)
          throw new CN({
            maxPriorityFeePerGas: q
          });
        w.maxPriorityFeePerGas = q, w.maxFeePerGas = k;
      }
    } else {
      if (typeof e.maxFeePerGas < "u" || typeof e.maxPriorityFeePerGas < "u")
        throw new Vv();
      if (typeof e.gasPrice > "u") {
        const B = await P(), { gasPrice: k } = await H2(t, {
          block: B,
          chain: i,
          request: w,
          type: "legacy"
        });
        w.gasPrice = k;
      }
    }
  return l.includes("gas") && typeof s > "u" && (w.gas = await Xn(t, ZN, "estimateGas")({
    ...w,
    account: p && { address: p.address, type: "json-rpc" }
  })), V0(w), delete w.parameters, w;
}
async function XN(t, { address: e, blockNumber: r, blockTag: n = "latest" }) {
  const i = typeof r == "bigint" ? vr(r) : void 0, s = await t.request({
    method: "eth_getBalance",
    params: [e, i || n]
  });
  return BigInt(s);
}
async function ZN(t, e) {
  var i, s, o;
  const { account: r = t.account } = e, n = r ? _i(r) : void 0;
  try {
    let f = function(b) {
      const { block: x, request: E, rpcStateOverride: S } = b;
      return t.request({
        method: "eth_estimateGas",
        params: S ? [E, x ?? "latest", S] : x ? [E, x] : [E]
      });
    };
    const { accessList: a, authorizationList: u, blobs: l, blobVersionedHashes: d, blockNumber: p, blockTag: w, data: _, gas: P, gasPrice: O, maxFeePerBlobGas: L, maxFeePerGas: B, maxPriorityFeePerGas: k, nonce: q, value: U, stateOverride: V, ...Q } = await Yv(t, {
      ...e,
      parameters: (
        // Some RPC Providers do not compute versioned hashes from blobs. We will need
        // to compute them.
        (n == null ? void 0 : n.type) === "local" ? void 0 : ["blobVersionedHashes"]
      )
    }), K = (typeof p == "bigint" ? vr(p) : void 0) || w, ge = PN(V), Ee = await (async () => {
      if (Q.to)
        return Q.to;
      if (u && u.length > 0)
        return await y4({
          authorization: u[0]
        }).catch(() => {
          throw new gt("`to` is required. Could not infer from `authorizationList`");
        });
    })();
    V0(e);
    const Y = (o = (s = (i = t.chain) == null ? void 0 : i.formatters) == null ? void 0 : s.transactionRequest) == null ? void 0 : o.format, m = (Y || Kv)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...x4(Q, { format: Y }),
      from: n == null ? void 0 : n.address,
      accessList: a,
      authorizationList: u,
      blobs: l,
      blobVersionedHashes: d,
      data: _,
      gas: P,
      gasPrice: O,
      maxFeePerBlobGas: L,
      maxFeePerGas: B,
      maxPriorityFeePerGas: k,
      nonce: q,
      to: Ee,
      value: U
    });
    let g = BigInt(await f({ block: K, request: m, rpcStateOverride: ge }));
    if (u) {
      const b = await XN(t, { address: m.from }), x = await Promise.all(u.map(async (E) => {
        const { address: S } = E, v = await f({
          block: K,
          request: {
            authorizationList: void 0,
            data: _,
            from: n == null ? void 0 : n.address,
            to: S,
            value: vr(b)
          },
          rpcStateOverride: ge
        }).catch(() => 100000n);
        return 2n * BigInt(v);
      }));
      g += x.reduce((E, S) => E + S, 0n);
    }
    return g;
  } catch (a) {
    throw _N(a, {
      ...e,
      account: n,
      chain: t.chain
    });
  }
}
function QN(t, e) {
  if (!Ms(t, { strict: !1 }))
    throw new _a({ address: t });
  if (!Ms(e, { strict: !1 }))
    throw new _a({ address: e });
  return t.toLowerCase() === e.toLowerCase();
}
class eL extends gt {
  constructor({ chain: e, currentChainId: r }) {
    super(`The current chain of the wallet (id: ${r}) does not match the target chain for the transaction (id: ${e.id} – ${e.name}).`, {
      metaMessages: [
        `Current Chain ID:  ${r}`,
        `Expected Chain ID: ${e.id} – ${e.name}`
      ],
      name: "ChainMismatchError"
    });
  }
}
class tL extends gt {
  constructor() {
    super([
      "No chain was provided to the request.",
      "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
    ].join(`
`), {
      name: "ChainNotFoundError"
    });
  }
}
const tm = "/docs/contract/encodeDeployData";
function rL(t) {
  const { abi: e, args: r, bytecode: n } = t;
  if (!r || r.length === 0)
    return n;
  const i = e.find((o) => "type" in o && o.type === "constructor");
  if (!i)
    throw new wD({ docsPath: tm });
  if (!("inputs" in i))
    throw new R2({ docsPath: tm });
  if (!i.inputs || i.inputs.length === 0)
    throw new R2({ docsPath: tm });
  const s = a4(i.inputs, r);
  return H0([n, s]);
}
function nL() {
  let t = () => {
  }, e = () => {
  };
  return { promise: new Promise((n, i) => {
    t = n, e = i;
  }), resolve: t, reject: e };
}
const rm = /* @__PURE__ */ new Map(), Y2 = /* @__PURE__ */ new Map();
let iL = 0;
function sL(t, e, r) {
  const n = ++iL, i = () => rm.get(t) || [], s = () => {
    const d = i();
    rm.set(t, d.filter((p) => p.id !== n));
  }, o = () => {
    const d = i();
    if (!d.some((w) => w.id === n))
      return;
    const p = Y2.get(t);
    if (d.length === 1 && p) {
      const w = p();
      w instanceof Promise && w.catch(() => {
      });
    }
    s();
  }, a = i();
  if (rm.set(t, [
    ...a,
    { id: n, fns: e }
  ]), a && a.length > 0)
    return o;
  const u = {};
  for (const d in e)
    u[d] = (...p) => {
      var _, P;
      const w = i();
      if (w.length !== 0)
        for (const O of w)
          (P = (_ = O.fns)[d]) == null || P.call(_, ...p);
    };
  const l = r(u);
  return typeof l == "function" && Y2.set(t, l), o;
}
async function _1(t) {
  return new Promise((e) => setTimeout(e, t));
}
function oL(t, { emitOnBegin: e, initialWaitTime: r, interval: n }) {
  let i = !0;
  const s = () => i = !1;
  return (async () => {
    let a;
    a = await t({ unpoll: s });
    const u = await (r == null ? void 0 : r(a)) ?? n;
    await _1(u);
    const l = async () => {
      i && (await t({ unpoll: s }), await _1(n), l());
    };
    l();
  })(), s;
}
class Pc extends gt {
  constructor({ docsPath: e } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join(`
`), {
      docsPath: e,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
}
class Dd extends gt {
  constructor({ docsPath: e, metaMessages: r, type: n }) {
    super(`Account type "${n}" is not supported.`, {
      docsPath: e,
      metaMessages: r,
      name: "AccountTypeNotSupportedError"
    });
  }
}
function T4({ chain: t, currentChainId: e }) {
  if (!t)
    throw new tL();
  if (e !== t.id)
    throw new eL({ chain: t, currentChainId: e });
}
function R4(t, { docsPath: e, ...r }) {
  const n = (() => {
    const i = w4(t, r);
    return i instanceof Hv ? t : i;
  })();
  return new iN(n, {
    docsPath: e,
    ...r
  });
}
async function D4(t, { serializedTransaction: e }) {
  return t.request({
    method: "eth_sendRawTransaction",
    params: [e]
  }, { retryCount: 0 });
}
const nm = new W0(128);
async function G0(t, e) {
  var k, q, U, V;
  const { account: r = t.account, chain: n = t.chain, accessList: i, authorizationList: s, blobs: o, data: a, gas: u, gasPrice: l, maxFeePerBlobGas: d, maxFeePerGas: p, maxPriorityFeePerGas: w, nonce: _, type: P, value: O, ...L } = e;
  if (typeof r > "u")
    throw new Pc({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const B = r ? _i(r) : null;
  try {
    V0(e);
    const Q = await (async () => {
      if (e.to)
        return e.to;
      if (e.to !== null && s && s.length > 0)
        return await y4({
          authorization: s[0]
        }).catch(() => {
          throw new gt("`to` is required. Could not infer from `authorizationList`.");
        });
    })();
    if ((B == null ? void 0 : B.type) === "json-rpc" || B === null) {
      let R;
      n !== null && (R = await Xn(t, Gl, "getChainId")({}), T4({
        currentChainId: R,
        chain: n
      }));
      const K = (U = (q = (k = t.chain) == null ? void 0 : k.formatters) == null ? void 0 : q.transactionRequest) == null ? void 0 : U.format, Ee = (K || Kv)({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...x4(L, { format: K }),
        accessList: i,
        authorizationList: s,
        blobs: o,
        chainId: R,
        data: a,
        from: B == null ? void 0 : B.address,
        gas: u,
        gasPrice: l,
        maxFeePerBlobGas: d,
        maxFeePerGas: p,
        maxPriorityFeePerGas: w,
        nonce: _,
        to: Q,
        type: P,
        value: O
      }), Y = nm.get(t.uid), A = Y ? "wallet_sendTransaction" : "eth_sendTransaction";
      try {
        return await t.request({
          method: A,
          params: [Ee]
        }, { retryCount: 0 });
      } catch (m) {
        if (Y === !1)
          throw m;
        const f = m;
        if (f.name === "InvalidInputRpcError" || f.name === "InvalidParamsRpcError" || f.name === "MethodNotFoundRpcError" || f.name === "MethodNotSupportedRpcError")
          return await t.request({
            method: "wallet_sendTransaction",
            params: [Ee]
          }, { retryCount: 0 }).then((g) => (nm.set(t.uid, !0), g)).catch((g) => {
            const b = g;
            throw b.name === "MethodNotFoundRpcError" || b.name === "MethodNotSupportedRpcError" ? (nm.set(t.uid, !1), f) : b;
          });
        throw f;
      }
    }
    if ((B == null ? void 0 : B.type) === "local") {
      const R = await Xn(t, Yv, "prepareTransactionRequest")({
        account: B,
        accessList: i,
        authorizationList: s,
        blobs: o,
        chain: n,
        data: a,
        gas: u,
        gasPrice: l,
        maxFeePerBlobGas: d,
        maxFeePerGas: p,
        maxPriorityFeePerGas: w,
        nonce: _,
        nonceManager: B.nonceManager,
        parameters: [...C4, "sidecars"],
        type: P,
        value: O,
        ...L,
        to: Q
      }), K = (V = n == null ? void 0 : n.serializers) == null ? void 0 : V.transaction, ge = await B.signTransaction(R, {
        serializer: K
      });
      return await Xn(t, D4, "sendRawTransaction")({
        serializedTransaction: ge
      });
    }
    throw (B == null ? void 0 : B.type) === "smart" ? new Dd({
      metaMessages: [
        "Consider using the `sendUserOperation` Action instead."
      ],
      docsPath: "/docs/actions/bundler/sendUserOperation",
      type: "smart"
    }) : new Dd({
      docsPath: "/docs/actions/wallet/sendTransaction",
      type: B == null ? void 0 : B.type
    });
  } catch (Q) {
    throw Q instanceof Dd ? Q : R4(Q, {
      ...e,
      account: B,
      chain: e.chain || void 0
    });
  }
}
async function aL(t, e) {
  const { abi: r, account: n = t.account, address: i, args: s, dataSuffix: o, functionName: a, ...u } = e;
  if (typeof n > "u")
    throw new Pc({
      docsPath: "/docs/contract/writeContract"
    });
  const l = n ? _i(n) : null, d = f4({
    abi: r,
    args: s,
    functionName: a
  });
  try {
    return await Xn(t, G0, "sendTransaction")({
      data: `${d}${o ? o.replace("0x", "") : ""}`,
      to: i,
      account: l,
      ...u
    });
  } catch (p) {
    throw dN(p, {
      abi: r,
      address: i,
      args: s,
      docsPath: "/docs/contract/writeContract",
      functionName: a,
      sender: l == null ? void 0 : l.address
    });
  }
}
const cL = {
  "0x0": "reverted",
  "0x1": "success"
}, O4 = "0x5792579257925792579257925792579257925792579257925792579257925792", N4 = vr(0, {
  size: 32
});
async function uL(t, e) {
  const { account: r = t.account, capabilities: n, chain: i = t.chain, experimental_fallback: s, experimental_fallbackDelay: o = 32, forceAtomic: a = !1, id: u, version: l = "2.0.0" } = e, d = r ? _i(r) : null, p = e.calls.map((w) => {
    const _ = w, P = _.abi ? f4({
      abi: _.abi,
      functionName: _.functionName,
      args: _.args
    }) : _.data;
    return {
      data: _.dataSuffix && P ? Ea([P, _.dataSuffix]) : P,
      to: _.to,
      value: _.value ? vr(_.value) : void 0
    };
  });
  try {
    const w = await t.request({
      method: "wallet_sendCalls",
      params: [
        {
          atomicRequired: a,
          calls: p,
          capabilities: n,
          chainId: vr(i.id),
          from: d == null ? void 0 : d.address,
          id: u,
          version: l
        }
      ]
    }, { retryCount: 0 });
    return typeof w == "string" ? { id: w } : w;
  } catch (w) {
    const _ = w;
    if (s && (_.name === "MethodNotFoundRpcError" || _.name === "MethodNotSupportedRpcError" || _.name === "UnknownRpcError" || _.details.toLowerCase().includes("does not exist / is not available") || _.details.toLowerCase().includes("missing or invalid. request()") || _.details.toLowerCase().includes("did not match any variant of untagged enum") || _.details.toLowerCase().includes("account upgraded to unsupported contract") || _.details.toLowerCase().includes("eip-7702 not supported") || _.details.toLowerCase().includes("unsupported wc_ method"))) {
      if (n && Object.values(n).some((k) => !k.optional)) {
        const k = "non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";
        throw new Cu(new gt(k, {
          details: k
        }));
      }
      if (a && p.length > 1) {
        const B = "`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";
        throw new Tu(new gt(B, {
          details: B
        }));
      }
      const P = [];
      for (const B of p) {
        const k = G0(t, {
          account: d,
          chain: i,
          data: B.data,
          to: B.to,
          value: B.value ? wa(B.value) : void 0
        });
        P.push(k), o > 0 && await new Promise((q) => setTimeout(q, o));
      }
      const O = await Promise.allSettled(P);
      if (O.every((B) => B.status === "rejected"))
        throw O[0].reason;
      const L = O.map((B) => B.status === "fulfilled" ? B.value : N4);
      return {
        id: Ea([
          ...L,
          vr(i.id, { size: 32 }),
          O4
        ])
      };
    }
    throw R4(w, {
      ...e,
      account: d,
      chain: e.chain
    });
  }
}
async function L4(t, e) {
  async function r(d) {
    if (d.endsWith(O4.slice(2))) {
      const w = j0(l1(d, -64, -32)), _ = l1(d, 0, -64).slice(2).match(/.{1,64}/g), P = await Promise.all(_.map((L) => N4.slice(2) !== L ? t.request({
        method: "eth_getTransactionReceipt",
        params: [`0x${L}`]
      }, { dedupe: !0 }) : void 0)), O = P.some((L) => L === null) ? 100 : P.every((L) => (L == null ? void 0 : L.status) === "0x1") ? 200 : P.every((L) => (L == null ? void 0 : L.status) === "0x0") ? 500 : 600;
      return {
        atomic: !1,
        chainId: xa(w),
        receipts: P.filter(Boolean),
        status: O,
        version: "2.0.0"
      };
    }
    return t.request({
      method: "wallet_getCallsStatus",
      params: [d]
    });
  }
  const { atomic: n = !1, chainId: i, receipts: s, version: o = "2.0.0", ...a } = await r(e.id), [u, l] = (() => {
    const d = a.status;
    return d >= 100 && d < 200 ? ["pending", d] : d >= 200 && d < 300 ? ["success", d] : d >= 300 && d < 700 ? ["failure", d] : d === "CONFIRMED" ? ["success", 200] : d === "PENDING" ? ["pending", 100] : [void 0, d];
  })();
  return {
    ...a,
    atomic: n,
    // @ts-expect-error: for backwards compatibility
    chainId: i ? xa(i) : void 0,
    receipts: (s == null ? void 0 : s.map((d) => ({
      ...d,
      blockNumber: wa(d.blockNumber),
      gasUsed: wa(d.gasUsed),
      status: cL[d.status]
    }))) ?? [],
    statusCode: l,
    status: u,
    version: o
  };
}
async function fL(t, e) {
  const { id: r, pollingInterval: n = t.pollingInterval, status: i = ({ statusCode: w }) => w >= 200, timeout: s = 6e4 } = e, o = Ac(["waitForCallsStatus", t.uid, r]), { promise: a, resolve: u, reject: l } = nL();
  let d;
  const p = sL(o, { resolve: u, reject: l }, (w) => {
    const _ = oL(async () => {
      const P = (O) => {
        clearTimeout(d), _(), O(), p();
      };
      try {
        const O = await L4(t, { id: r });
        if (!i(O))
          return;
        P(() => w.resolve(O));
      } catch (O) {
        P(() => w.reject(O));
      }
    }, {
      interval: n,
      emitOnBegin: !0
    });
    return _;
  });
  return d = s ? setTimeout(() => {
    p(), clearTimeout(d), l(new lL({ id: r }));
  }, s) : void 0, await a;
}
class lL extends gt {
  constructor({ id: e }) {
    super(`Timed out while waiting for call bundle with id "${e}" to be confirmed.`, { name: "WaitForCallsStatusTimeoutError" });
  }
}
const E1 = 256;
let hd = E1, dd;
function k4(t = 11) {
  if (!dd || hd + t > E1 * 2) {
    dd = "", hd = 0;
    for (let e = 0; e < E1; e++)
      dd += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return dd.substring(hd, hd++ + t);
}
function hL(t) {
  const { batch: e, chain: r, ccipRead: n, key: i = "base", name: s = "Base Client", type: o = "base" } = t, a = (r == null ? void 0 : r.blockTime) ?? 12e3, u = Math.min(Math.max(Math.floor(a / 2), 500), 4e3), l = t.pollingInterval ?? u, d = t.cacheTime ?? l, p = t.account ? _i(t.account) : void 0, { config: w, request: _, value: P } = t.transport({
    chain: r,
    pollingInterval: l
  }), O = { ...w, ...P }, L = {
    account: p,
    batch: e,
    cacheTime: d,
    ccipRead: n,
    chain: r,
    key: i,
    name: s,
    pollingInterval: l,
    request: _,
    transport: O,
    type: o,
    uid: k4()
  };
  function B(k) {
    return (q) => {
      const U = q(k);
      for (const Q in L)
        delete U[Q];
      const V = { ...k, ...U };
      return Object.assign(V, { extend: B(V) });
    };
  }
  return Object.assign(L, { extend: B(L) });
}
const pd = /* @__PURE__ */ new W0(8192);
function dL(t, { enabled: e = !0, id: r }) {
  if (!e || !r)
    return t();
  if (pd.get(r))
    return pd.get(r);
  const n = t().finally(() => pd.delete(r));
  return pd.set(r, n), n;
}
function pL(t, { delay: e = 100, retryCount: r = 2, shouldRetry: n = () => !0 } = {}) {
  return new Promise((i, s) => {
    const o = async ({ count: a = 0 } = {}) => {
      const u = async ({ error: l }) => {
        const d = typeof e == "function" ? e({ count: a, error: l }) : e;
        d && await _1(d), o({ count: a + 1 });
      };
      try {
        const l = await t();
        i(l);
      } catch (l) {
        if (a < r && await n({ count: a, error: l }))
          return u({ error: l });
        s(l);
      }
    };
    o();
  });
}
function gL(t, e = {}) {
  return async (r, n = {}) => {
    var p;
    const { dedupe: i = !1, methods: s, retryDelay: o = 150, retryCount: a = 3, uid: u } = {
      ...e,
      ...n
    }, { method: l } = r;
    if ((p = s == null ? void 0 : s.exclude) != null && p.includes(l))
      throw new cc(new Error("method not supported"), {
        method: l
      });
    if (s != null && s.include && !s.include.includes(l))
      throw new cc(new Error("method not supported"), {
        method: l
      });
    const d = i ? U0(`${u}.${Ac(r)}`) : void 0;
    return dL(() => pL(async () => {
      try {
        return await t(r);
      } catch (w) {
        const _ = w;
        switch (_.code) {
          case ul.code:
            throw new ul(_);
          case fl.code:
            throw new fl(_);
          case ll.code:
            throw new ll(_, { method: r.method });
          case hl.code:
            throw new hl(_);
          case vc.code:
            throw new vc(_);
          case dl.code:
            throw new dl(_);
          case pl.code:
            throw new pl(_);
          case gl.code:
            throw new gl(_);
          case ml.code:
            throw new ml(_);
          case cc.code:
            throw new cc(_, {
              method: r.method
            });
          case Iu.code:
            throw new Iu(_);
          case vl.code:
            throw new vl(_);
          case bu.code:
            throw new bu(_);
          case bl.code:
            throw new bl(_);
          case yl.code:
            throw new yl(_);
          case wl.code:
            throw new wl(_);
          case xl.code:
            throw new xl(_);
          case _l.code:
            throw new _l(_);
          case Cu.code:
            throw new Cu(_);
          case El.code:
            throw new El(_);
          case Sl.code:
            throw new Sl(_);
          case Al.code:
            throw new Al(_);
          case Pl.code:
            throw new Pl(_);
          case Ml.code:
            throw new Ml(_);
          case Tu.code:
            throw new Tu(_);
          case 5e3:
            throw new bu(_);
          default:
            throw w instanceof gt ? w : new lN(_);
        }
      }
    }, {
      delay: ({ count: w, error: _ }) => {
        var P;
        if (_ && _ instanceof g4) {
          const O = (P = _ == null ? void 0 : _.headers) == null ? void 0 : P.get("Retry-After");
          if (O != null && O.match(/\d/))
            return Number.parseInt(O) * 1e3;
        }
        return ~~(1 << w) * o;
      },
      retryCount: a,
      shouldRetry: ({ error: w }) => mL(w)
    }), { enabled: i, id: d });
  };
}
function mL(t) {
  return "code" in t && typeof t.code == "number" ? t.code === -1 || t.code === Iu.code || t.code === vc.code : t instanceof g4 && t.status ? t.status === 403 || t.status === 408 || t.status === 413 || t.status === 429 || t.status === 500 || t.status === 502 || t.status === 503 || t.status === 504 : !0;
}
function vL({ key: t, methods: e, name: r, request: n, retryCount: i = 3, retryDelay: s = 150, timeout: o, type: a }, u) {
  const l = k4();
  return {
    config: {
      key: t,
      methods: e,
      name: r,
      request: n,
      retryCount: i,
      retryDelay: s,
      timeout: o,
      type: a
    },
    request: gL(n, { methods: e, retryCount: i, retryDelay: s, uid: l }),
    value: u
  };
}
function gd(t, e = {}) {
  const { key: r = "custom", methods: n, name: i = "Custom Provider", retryDelay: s } = e;
  return ({ retryCount: o }) => vL({
    key: r,
    methods: n,
    name: i,
    request: t.request.bind(t),
    retryCount: e.retryCount ?? o,
    retryDelay: s,
    type: "custom"
  });
}
class bL extends gt {
  constructor({ domain: e }) {
    super(`Invalid domain "${Ac(e)}".`, {
      metaMessages: ["Must be a valid EIP-712 domain."]
    });
  }
}
class yL extends gt {
  constructor({ primaryType: e, types: r }) {
    super(`Invalid primary type \`${e}\` must be one of \`${JSON.stringify(Object.keys(r))}\`.`, {
      docsPath: "/api/glossary/Errors#typeddatainvalidprimarytypeerror",
      metaMessages: ["Check that the primary type is a key in `types`."]
    });
  }
}
class wL extends gt {
  constructor({ type: e }) {
    super(`Struct type "${e}" is invalid.`, {
      metaMessages: ["Struct type must not be a Solidity type."],
      name: "InvalidStructTypeError"
    });
  }
}
function xL(t) {
  const { domain: e, message: r, primaryType: n, types: i } = t, s = (u, l) => {
    const d = { ...l };
    for (const p of u) {
      const { name: w, type: _ } = p;
      _ === "address" && (d[w] = d[w].toLowerCase());
    }
    return d;
  }, o = i.EIP712Domain ? e ? s(i.EIP712Domain, e) : {} : {}, a = (() => {
    if (n !== "EIP712Domain")
      return s(i[n], r);
  })();
  return Ac({ domain: o, message: a, primaryType: n, types: i });
}
function _L(t) {
  const { domain: e, message: r, primaryType: n, types: i } = t, s = (o, a) => {
    for (const u of o) {
      const { name: l, type: d } = u, p = a[l], w = d.match(o4);
      if (w && (typeof p == "number" || typeof p == "bigint")) {
        const [O, L, B] = w;
        vr(p, {
          signed: L === "int",
          size: Number.parseInt(B) / 8
        });
      }
      if (d === "address" && typeof p == "string" && !Ms(p))
        throw new _a({ address: p });
      const _ = d.match(SO);
      if (_) {
        const [O, L] = _;
        if (L && xn(p) !== Number.parseInt(L))
          throw new PD({
            expectedSize: Number.parseInt(L),
            givenSize: xn(p)
          });
      }
      const P = i[d];
      P && (SL(d), s(P, p));
    }
  };
  if (i.EIP712Domain && e) {
    if (typeof e != "object")
      throw new bL({ domain: e });
    s(i.EIP712Domain, e);
  }
  if (n !== "EIP712Domain")
    if (i[n])
      s(i[n], r);
    else
      throw new yL({ primaryType: n, types: i });
}
function EL({ domain: t }) {
  return [
    typeof (t == null ? void 0 : t.name) == "string" && { name: "name", type: "string" },
    (t == null ? void 0 : t.version) && { name: "version", type: "string" },
    (typeof (t == null ? void 0 : t.chainId) == "number" || typeof (t == null ? void 0 : t.chainId) == "bigint") && {
      name: "chainId",
      type: "uint256"
    },
    (t == null ? void 0 : t.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (t == null ? void 0 : t.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
function SL(t) {
  if (t === "address" || t === "bool" || t === "string" || t.startsWith("bytes") || t.startsWith("uint") || t.startsWith("int"))
    throw new wL({ type: t });
}
async function AL(t, { chain: e }) {
  const { id: r, name: n, nativeCurrency: i, rpcUrls: s, blockExplorers: o } = e;
  await t.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: vr(r),
        chainName: n,
        nativeCurrency: i,
        rpcUrls: s.default.http,
        blockExplorerUrls: o ? Object.values(o).map(({ url: a }) => a) : void 0
      }
    ]
  }, { dedupe: !0, retryCount: 0 });
}
function PL(t, e) {
  const { abi: r, args: n, bytecode: i, ...s } = e, o = rL({ abi: r, args: n, bytecode: i });
  return G0(t, {
    ...s,
    ...s.authorizationList ? { to: null } : {},
    data: o
  });
}
async function ML(t) {
  var r;
  return ((r = t.account) == null ? void 0 : r.type) === "local" ? [t.account.address] : (await t.request({ method: "eth_accounts" }, { dedupe: !0 })).map((n) => Vl(n));
}
async function IL(t, e = {}) {
  const { account: r = t.account, chainId: n } = e, i = r ? _i(r) : void 0, s = n ? [i == null ? void 0 : i.address, [vr(n)]] : [i == null ? void 0 : i.address], o = await t.request({
    method: "wallet_getCapabilities",
    params: s
  }), a = {};
  for (const [u, l] of Object.entries(o)) {
    a[Number(u)] = {};
    for (let [d, p] of Object.entries(l))
      d === "addSubAccount" && (d = "unstable_addSubAccount"), a[Number(u)][d] = p;
  }
  return typeof n == "number" ? a[n] : a;
}
async function CL(t) {
  return await t.request({ method: "wallet_getPermissions" }, { dedupe: !0 });
}
async function $4(t, e) {
  var u;
  const { account: r = t.account, chainId: n, nonce: i } = e;
  if (!r)
    throw new Pc({
      docsPath: "/docs/eip7702/prepareAuthorization"
    });
  const s = _i(r), o = (() => {
    if (e.executor)
      return e.executor === "self" ? e.executor : _i(e.executor);
  })(), a = {
    address: e.contractAddress ?? e.address,
    chainId: n,
    nonce: i
  };
  return typeof a.chainId > "u" && (a.chainId = ((u = t.chain) == null ? void 0 : u.id) ?? await Xn(t, Gl, "getChainId")({})), typeof a.nonce > "u" && (a.nonce = await Xn(t, E4, "getTransactionCount")({
    address: s.address,
    blockTag: "pending"
  }), (o === "self" || o != null && o.address && QN(o.address, s.address)) && (a.nonce += 1)), a;
}
async function TL(t) {
  return (await t.request({ method: "eth_requestAccounts" }, { dedupe: !0, retryCount: 0 })).map((r) => Fv(r));
}
async function RL(t, e) {
  return t.request({
    method: "wallet_requestPermissions",
    params: [e]
  }, { retryCount: 0 });
}
async function DL(t, e) {
  const { id: r } = e;
  await t.request({
    method: "wallet_showCallsStatus",
    params: [r]
  });
}
async function OL(t, e) {
  const { account: r = t.account } = e;
  if (!r)
    throw new Pc({
      docsPath: "/docs/eip7702/signAuthorization"
    });
  const n = _i(r);
  if (!n.signAuthorization)
    throw new Dd({
      docsPath: "/docs/eip7702/signAuthorization",
      metaMessages: [
        "The `signAuthorization` Action does not support JSON-RPC Accounts."
      ],
      type: n.type
    });
  const i = await $4(t, e);
  return n.signAuthorization(i);
}
async function NL(t, { account: e = t.account, message: r }) {
  if (!e)
    throw new Pc({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const n = _i(e);
  if (n.signMessage)
    return n.signMessage({ message: r });
  const i = typeof r == "string" ? U0(r) : r.raw instanceof Uint8Array ? t0(r.raw) : r.raw;
  return t.request({
    method: "personal_sign",
    params: [i, n.address]
  }, { retryCount: 0 });
}
async function LL(t, e) {
  var l, d, p, w;
  const { account: r = t.account, chain: n = t.chain, ...i } = e;
  if (!r)
    throw new Pc({
      docsPath: "/docs/actions/wallet/signTransaction"
    });
  const s = _i(r);
  V0({
    account: s,
    ...e
  });
  const o = await Xn(t, Gl, "getChainId")({});
  n !== null && T4({
    currentChainId: o,
    chain: n
  });
  const a = (n == null ? void 0 : n.formatters) || ((l = t.chain) == null ? void 0 : l.formatters), u = ((d = a == null ? void 0 : a.transactionRequest) == null ? void 0 : d.format) || Kv;
  return s.signTransaction ? s.signTransaction({
    ...i,
    chainId: o
  }, { serializer: (w = (p = t.chain) == null ? void 0 : p.serializers) == null ? void 0 : w.transaction }) : await t.request({
    method: "eth_signTransaction",
    params: [
      {
        ...u(i),
        chainId: vr(o),
        from: s.address
      }
    ]
  }, { retryCount: 0 });
}
async function kL(t, e) {
  const { account: r = t.account, domain: n, message: i, primaryType: s } = e;
  if (!r)
    throw new Pc({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const o = _i(r), a = {
    EIP712Domain: EL({ domain: n }),
    ...e.types
  };
  if (_L({ domain: n, message: i, primaryType: s, types: a }), o.signTypedData)
    return o.signTypedData({ domain: n, message: i, primaryType: s, types: a });
  const u = xL({ domain: n, message: i, primaryType: s, types: a });
  return t.request({
    method: "eth_signTypedData_v4",
    params: [o.address, u]
  }, { retryCount: 0 });
}
async function $L(t, { id: e }) {
  await t.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: vr(e)
      }
    ]
  }, { retryCount: 0 });
}
async function BL(t, e) {
  return await t.request({
    method: "wallet_watchAsset",
    params: e
  }, { retryCount: 0 });
}
function FL(t) {
  return {
    addChain: (e) => AL(t, e),
    deployContract: (e) => PL(t, e),
    getAddresses: () => ML(t),
    getCallsStatus: (e) => L4(t, e),
    getCapabilities: (e) => IL(t, e),
    getChainId: () => Gl(t),
    getPermissions: () => CL(t),
    prepareAuthorization: (e) => $4(t, e),
    prepareTransactionRequest: (e) => Yv(t, e),
    requestAddresses: () => TL(t),
    requestPermissions: (e) => RL(t, e),
    sendCalls: (e) => uL(t, e),
    sendRawTransaction: (e) => D4(t, e),
    sendTransaction: (e) => G0(t, e),
    showCallsStatus: (e) => DL(t, e),
    signAuthorization: (e) => OL(t, e),
    signMessage: (e) => NL(t, e),
    signTransaction: (e) => LL(t, e),
    signTypedData: (e) => kL(t, e),
    switchChain: (e) => $L(t, e),
    waitForCallsStatus: (e) => fL(t, e),
    watchAsset: (e) => BL(t, e),
    writeContract: (e) => aL(t, e)
  };
}
function md(t) {
  const { key: e = "wallet", name: r = "Wallet Client", transport: n } = t;
  return hL({
    ...t,
    key: e,
    name: r,
    transport: n,
    type: "walletClient"
  }).extend(FL);
}
class Il {
  constructor(e) {
    vs(this, "_key");
    vs(this, "_config", null);
    vs(this, "_provider", null);
    vs(this, "_connected", !1);
    vs(this, "_address", null);
    vs(this, "_fatured", !1);
    vs(this, "_installed", !1);
    vs(this, "lastUsed", !1);
    vs(this, "_client", null);
    var r;
    if ("name" in e && "image" in e)
      this._key = e.name, this._config = e, this._fatured = e.featured;
    else if ("session" in e) {
      if (!e.session) throw new Error("session is null");
      this._key = (r = e.session) == null ? void 0 : r.peer.metadata.name, this._provider = e, this._client = md({ transport: gd(this._provider) }), this._config = {
        name: e.session.peer.metadata.name,
        image: e.session.peer.metadata.icons[0],
        featured: !1
      };
    } else if ("info" in e)
      this._key = e.info.name, this._provider = e.provider, this._installed = !0, this._client = md({ transport: gd(this._provider) }), this._config = {
        name: e.info.name,
        image: e.info.icon,
        featured: !1
      }, this.testConnect();
    else
      throw new Error("unknown params");
  }
  get address() {
    return this._address;
  }
  get connected() {
    return this._connected;
  }
  get featured() {
    return this._fatured;
  }
  get key() {
    return this._key;
  }
  get installed() {
    return this._installed;
  }
  get provider() {
    return this._provider;
  }
  get client() {
    return this._client ? this._client : null;
  }
  get config() {
    return this._config;
  }
  static fromWalletConfig(e) {
    return new Il(e);
  }
  EIP6963Detected(e) {
    this._provider = e.provider, this._client = md({ transport: gd(this._provider) }), this._installed = !0, this._provider.on("disconnect", this.disconnect), this._provider.on("accountsChanged", (r) => {
      this._address = r[0], this._connected = !0;
    }), this.testConnect();
  }
  setUniversalProvider(e) {
    this._provider = e, this._client = md({ transport: gd(this._provider) }), this.testConnect();
  }
  async switchChain(e) {
    var r, n, i, s;
    try {
      return await ((r = this.client) == null ? void 0 : r.getChainId()) === e.id || await ((n = this.client) == null ? void 0 : n.switchChain(e)), !0;
    } catch (o) {
      if (o.code === 4902)
        return await ((i = this.client) == null ? void 0 : i.addChain({ chain: e })), await ((s = this.client) == null ? void 0 : s.switchChain(e)), !0;
      throw o;
    }
  }
  async testConnect() {
    var r;
    const e = await ((r = this.client) == null ? void 0 : r.getAddresses());
    e && e.length > 0 ? (this._address = e[0], this._connected = !0) : (this._address = null, this._connected = !1);
  }
  async connect() {
    var r;
    const e = await ((r = this.client) == null ? void 0 : r.requestAddresses());
    if (!e) throw new Error("connect failed");
    return e;
  }
  async getAddress() {
    var r;
    const e = await ((r = this.client) == null ? void 0 : r.getAddresses());
    if (!e) throw new Error("get address failed");
    return e[0];
  }
  async getChain() {
    var r;
    const e = await ((r = this.client) == null ? void 0 : r.getChainId());
    if (!e) throw new Error("get chain failed");
    return e;
  }
  async signMessage(e, r) {
    var i;
    return await ((i = this.client) == null ? void 0 : i.signMessage({ message: e, account: r }));
  }
  async disconnect() {
    this._provider && "session" in this._provider && await this._provider.disconnect(), this._connected = !1, this._address = null;
  }
}
var Jv = { exports: {} }, yu = typeof Reflect == "object" ? Reflect : null, J2 = yu && typeof yu.apply == "function" ? yu.apply : function(e, r, n) {
  return Function.prototype.apply.call(e, r, n);
}, Od;
yu && typeof yu.ownKeys == "function" ? Od = yu.ownKeys : Object.getOwnPropertySymbols ? Od = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : Od = function(e) {
  return Object.getOwnPropertyNames(e);
};
function jL(t) {
  console && console.warn && console.warn(t);
}
var B4 = Number.isNaN || function(e) {
  return e !== e;
};
function kr() {
  kr.init.call(this);
}
Jv.exports = kr;
Jv.exports.once = WL;
kr.EventEmitter = kr;
kr.prototype._events = void 0;
kr.prototype._eventsCount = 0;
kr.prototype._maxListeners = void 0;
var X2 = 10;
function Y0(t) {
  if (typeof t != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
}
Object.defineProperty(kr, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return X2;
  },
  set: function(t) {
    if (typeof t != "number" || t < 0 || B4(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    X2 = t;
  }
});
kr.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
kr.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || B4(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function F4(t) {
  return t._maxListeners === void 0 ? kr.defaultMaxListeners : t._maxListeners;
}
kr.prototype.getMaxListeners = function() {
  return F4(this);
};
kr.prototype.emit = function(e) {
  for (var r = [], n = 1; n < arguments.length; n++) r.push(arguments[n]);
  var i = e === "error", s = this._events;
  if (s !== void 0)
    i = i && s.error === void 0;
  else if (!i)
    return !1;
  if (i) {
    var o;
    if (r.length > 0 && (o = r[0]), o instanceof Error)
      throw o;
    var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
    throw a.context = o, a;
  }
  var u = s[e];
  if (u === void 0)
    return !1;
  if (typeof u == "function")
    J2(u, this, r);
  else
    for (var l = u.length, d = W4(u, l), n = 0; n < l; ++n)
      J2(d[n], this, r);
  return !0;
};
function j4(t, e, r, n) {
  var i, s, o;
  if (Y0(r), s = t._events, s === void 0 ? (s = t._events = /* @__PURE__ */ Object.create(null), t._eventsCount = 0) : (s.newListener !== void 0 && (t.emit(
    "newListener",
    e,
    r.listener ? r.listener : r
  ), s = t._events), o = s[e]), o === void 0)
    o = s[e] = r, ++t._eventsCount;
  else if (typeof o == "function" ? o = s[e] = n ? [r, o] : [o, r] : n ? o.unshift(r) : o.push(r), i = F4(t), i > 0 && o.length > i && !o.warned) {
    o.warned = !0;
    var a = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a.name = "MaxListenersExceededWarning", a.emitter = t, a.type = e, a.count = o.length, jL(a);
  }
  return t;
}
kr.prototype.addListener = function(e, r) {
  return j4(this, e, r, !1);
};
kr.prototype.on = kr.prototype.addListener;
kr.prototype.prependListener = function(e, r) {
  return j4(this, e, r, !0);
};
function UL() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function U4(t, e, r) {
  var n = { fired: !1, wrapFn: void 0, target: t, type: e, listener: r }, i = UL.bind(n);
  return i.listener = r, n.wrapFn = i, i;
}
kr.prototype.once = function(e, r) {
  return Y0(r), this.on(e, U4(this, e, r)), this;
};
kr.prototype.prependOnceListener = function(e, r) {
  return Y0(r), this.prependListener(e, U4(this, e, r)), this;
};
kr.prototype.removeListener = function(e, r) {
  var n, i, s, o, a;
  if (Y0(r), i = this._events, i === void 0)
    return this;
  if (n = i[e], n === void 0)
    return this;
  if (n === r || n.listener === r)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || r));
  else if (typeof n != "function") {
    for (s = -1, o = n.length - 1; o >= 0; o--)
      if (n[o] === r || n[o].listener === r) {
        a = n[o].listener, s = o;
        break;
      }
    if (s < 0)
      return this;
    s === 0 ? n.shift() : qL(n, s), n.length === 1 && (i[e] = n[0]), i.removeListener !== void 0 && this.emit("removeListener", e, a || r);
  }
  return this;
};
kr.prototype.off = kr.prototype.removeListener;
kr.prototype.removeAllListeners = function(e) {
  var r, n, i;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[e]), this;
  if (arguments.length === 0) {
    var s = Object.keys(n), o;
    for (i = 0; i < s.length; ++i)
      o = s[i], o !== "removeListener" && this.removeAllListeners(o);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r = n[e], typeof r == "function")
    this.removeListener(e, r);
  else if (r !== void 0)
    for (i = r.length - 1; i >= 0; i--)
      this.removeListener(e, r[i]);
  return this;
};
function q4(t, e, r) {
  var n = t._events;
  if (n === void 0)
    return [];
  var i = n[e];
  return i === void 0 ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? zL(i) : W4(i, i.length);
}
kr.prototype.listeners = function(e) {
  return q4(this, e, !0);
};
kr.prototype.rawListeners = function(e) {
  return q4(this, e, !1);
};
kr.listenerCount = function(t, e) {
  return typeof t.listenerCount == "function" ? t.listenerCount(e) : z4.call(t, e);
};
kr.prototype.listenerCount = z4;
function z4(t) {
  var e = this._events;
  if (e !== void 0) {
    var r = e[t];
    if (typeof r == "function")
      return 1;
    if (r !== void 0)
      return r.length;
  }
  return 0;
}
kr.prototype.eventNames = function() {
  return this._eventsCount > 0 ? Od(this._events) : [];
};
function W4(t, e) {
  for (var r = new Array(e), n = 0; n < e; ++n)
    r[n] = t[n];
  return r;
}
function qL(t, e) {
  for (; e + 1 < t.length; e++)
    t[e] = t[e + 1];
  t.pop();
}
function zL(t) {
  for (var e = new Array(t.length), r = 0; r < e.length; ++r)
    e[r] = t[r].listener || t[r];
  return e;
}
function WL(t, e) {
  return new Promise(function(r, n) {
    function i(o) {
      t.removeListener(e, s), n(o);
    }
    function s() {
      typeof t.removeListener == "function" && t.removeListener("error", i), r([].slice.call(arguments));
    }
    H4(t, e, s, { once: !0 }), e !== "error" && HL(t, i, { once: !0 });
  });
}
function HL(t, e, r) {
  typeof t.on == "function" && H4(t, "error", e, r);
}
function H4(t, e, r, n) {
  if (typeof t.on == "function")
    n.once ? t.once(e, r) : t.on(e, r);
  else if (typeof t.addEventListener == "function")
    t.addEventListener(e, function i(s) {
      n.once && t.removeEventListener(e, i), r(s);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
}
var is = Jv.exports;
const Xv = /* @__PURE__ */ ns(is);
var vt = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var S1 = function(t, e) {
  return S1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var i in n) n.hasOwnProperty(i) && (r[i] = n[i]);
  }, S1(t, e);
};
function KL(t, e) {
  S1(t, e);
  function r() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
}
var A1 = function() {
  return A1 = Object.assign || function(e) {
    for (var r, n = 1, i = arguments.length; n < i; n++) {
      r = arguments[n];
      for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (e[s] = r[s]);
    }
    return e;
  }, A1.apply(this, arguments);
};
function VL(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
  return r;
}
function GL(t, e, r, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, r) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, r, n);
  else for (var a = t.length - 1; a >= 0; a--) (o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, r, s) : o(e, r)) || s);
  return i > 3 && s && Object.defineProperty(e, r, s), s;
}
function YL(t, e) {
  return function(r, n) {
    e(r, n, t);
  };
}
function JL(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(t, e);
}
function XL(t, e, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function a(d) {
      try {
        l(n.next(d));
      } catch (p) {
        o(p);
      }
    }
    function u(d) {
      try {
        l(n.throw(d));
      } catch (p) {
        o(p);
      }
    }
    function l(d) {
      d.done ? s(d.value) : i(d.value).then(a, u);
    }
    l((n = n.apply(t, e || [])).next());
  });
}
function ZL(t, e) {
  var r = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(l) {
    return function(d) {
      return u([l, d]);
    };
  }
  function u(l) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; r; ) try {
      if (n = 1, i && (s = l[0] & 2 ? i.return : l[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, l[1])).done) return s;
      switch (i = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
        case 0:
        case 1:
          s = l;
          break;
        case 4:
          return r.label++, { value: l[1], done: !1 };
        case 5:
          r.label++, i = l[1], l = [0];
          continue;
        case 7:
          l = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            r = 0;
            continue;
          }
          if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
            r.label = l[1];
            break;
          }
          if (l[0] === 6 && r.label < s[1]) {
            r.label = s[1], s = l;
            break;
          }
          if (s && r.label < s[2]) {
            r.label = s[2], r.ops.push(l);
            break;
          }
          s[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      l = e.call(t, r);
    } catch (d) {
      l = [6, d], i = 0;
    } finally {
      n = s = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function QL(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}
function ek(t, e) {
  for (var r in t) r !== "default" && !e.hasOwnProperty(r) && (e[r] = t[r]);
}
function P1(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], n = 0;
  if (r) return r.call(t);
  if (t && typeof t.length == "number") return {
    next: function() {
      return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function K4(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r) return t;
  var n = r.call(t), i, s = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) s.push(i.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (o) throw o.error;
    }
  }
  return s;
}
function tk() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(K4(arguments[e]));
  return t;
}
function rk() {
  for (var t = 0, e = 0, r = arguments.length; e < r; e++) t += arguments[e].length;
  for (var n = Array(t), i = 0, e = 0; e < r; e++)
    for (var s = arguments[e], o = 0, a = s.length; o < a; o++, i++)
      n[i] = s[o];
  return n;
}
function Cl(t) {
  return this instanceof Cl ? (this.v = t, this) : new Cl(t);
}
function nk(t, e, r) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = r.apply(t, e || []), i, s = [];
  return i = {}, o("next"), o("throw"), o("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function o(w) {
    n[w] && (i[w] = function(_) {
      return new Promise(function(P, O) {
        s.push([w, _, P, O]) > 1 || a(w, _);
      });
    });
  }
  function a(w, _) {
    try {
      u(n[w](_));
    } catch (P) {
      p(s[0][3], P);
    }
  }
  function u(w) {
    w.value instanceof Cl ? Promise.resolve(w.value.v).then(l, d) : p(s[0][2], w);
  }
  function l(w) {
    a("next", w);
  }
  function d(w) {
    a("throw", w);
  }
  function p(w, _) {
    w(_), s.shift(), s.length && a(s[0][0], s[0][1]);
  }
}
function ik(t) {
  var e, r;
  return e = {}, n("next"), n("throw", function(i) {
    throw i;
  }), n("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function n(i, s) {
    e[i] = t[i] ? function(o) {
      return (r = !r) ? { value: Cl(t[i](o)), done: i === "return" } : s ? s(o) : o;
    } : s;
  }
}
function sk(t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], r;
  return e ? e.call(t) : (t = typeof P1 == "function" ? P1(t) : t[Symbol.iterator](), r = {}, n("next"), n("throw"), n("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function n(s) {
    r[s] = t[s] && function(o) {
      return new Promise(function(a, u) {
        o = t[s](o), i(a, u, o.done, o.value);
      });
    };
  }
  function i(s, o, a, u) {
    Promise.resolve(u).then(function(l) {
      s({ value: l, done: a });
    }, o);
  }
}
function ok(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : t.raw = e, t;
}
function ak(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
  return e.default = t, e;
}
function ck(t) {
  return t && t.__esModule ? t : { default: t };
}
function uk(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function fk(t, e, r) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, r), r;
}
const lk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return A1;
  },
  __asyncDelegator: ik,
  __asyncGenerator: nk,
  __asyncValues: sk,
  __await: Cl,
  __awaiter: XL,
  __classPrivateFieldGet: uk,
  __classPrivateFieldSet: fk,
  __createBinding: QL,
  __decorate: GL,
  __exportStar: ek,
  __extends: KL,
  __generator: ZL,
  __importDefault: ck,
  __importStar: ak,
  __makeTemplateObject: ok,
  __metadata: JL,
  __param: YL,
  __read: K4,
  __rest: VL,
  __spread: tk,
  __spreadArrays: rk,
  __values: P1
}, Symbol.toStringTag, { value: "Module" })), Yl = /* @__PURE__ */ Lv(lk);
var im = {}, Mf = {}, Z2;
function hk() {
  if (Z2) return Mf;
  Z2 = 1, Object.defineProperty(Mf, "__esModule", { value: !0 }), Mf.delay = void 0;
  function t(e) {
    return new Promise((r) => {
      setTimeout(() => {
        r(!0);
      }, e);
    });
  }
  return Mf.delay = t, Mf;
}
var Ga = {}, sm = {}, Ya = {}, Q2;
function dk() {
  return Q2 || (Q2 = 1, Object.defineProperty(Ya, "__esModule", { value: !0 }), Ya.ONE_THOUSAND = Ya.ONE_HUNDRED = void 0, Ya.ONE_HUNDRED = 100, Ya.ONE_THOUSAND = 1e3), Ya;
}
var om = {}, ex;
function pk() {
  return ex || (ex = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ONE_YEAR = t.FOUR_WEEKS = t.THREE_WEEKS = t.TWO_WEEKS = t.ONE_WEEK = t.THIRTY_DAYS = t.SEVEN_DAYS = t.FIVE_DAYS = t.THREE_DAYS = t.ONE_DAY = t.TWENTY_FOUR_HOURS = t.TWELVE_HOURS = t.SIX_HOURS = t.THREE_HOURS = t.ONE_HOUR = t.SIXTY_MINUTES = t.THIRTY_MINUTES = t.TEN_MINUTES = t.FIVE_MINUTES = t.ONE_MINUTE = t.SIXTY_SECONDS = t.THIRTY_SECONDS = t.TEN_SECONDS = t.FIVE_SECONDS = t.ONE_SECOND = void 0, t.ONE_SECOND = 1, t.FIVE_SECONDS = 5, t.TEN_SECONDS = 10, t.THIRTY_SECONDS = 30, t.SIXTY_SECONDS = 60, t.ONE_MINUTE = t.SIXTY_SECONDS, t.FIVE_MINUTES = t.ONE_MINUTE * 5, t.TEN_MINUTES = t.ONE_MINUTE * 10, t.THIRTY_MINUTES = t.ONE_MINUTE * 30, t.SIXTY_MINUTES = t.ONE_MINUTE * 60, t.ONE_HOUR = t.SIXTY_MINUTES, t.THREE_HOURS = t.ONE_HOUR * 3, t.SIX_HOURS = t.ONE_HOUR * 6, t.TWELVE_HOURS = t.ONE_HOUR * 12, t.TWENTY_FOUR_HOURS = t.ONE_HOUR * 24, t.ONE_DAY = t.TWENTY_FOUR_HOURS, t.THREE_DAYS = t.ONE_DAY * 3, t.FIVE_DAYS = t.ONE_DAY * 5, t.SEVEN_DAYS = t.ONE_DAY * 7, t.THIRTY_DAYS = t.ONE_DAY * 30, t.ONE_WEEK = t.SEVEN_DAYS, t.TWO_WEEKS = t.ONE_WEEK * 2, t.THREE_WEEKS = t.ONE_WEEK * 3, t.FOUR_WEEKS = t.ONE_WEEK * 4, t.ONE_YEAR = t.ONE_DAY * 365;
  }(om)), om;
}
var tx;
function V4() {
  return tx || (tx = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const e = Yl;
    e.__exportStar(dk(), t), e.__exportStar(pk(), t);
  }(sm)), sm;
}
var rx;
function gk() {
  if (rx) return Ga;
  rx = 1, Object.defineProperty(Ga, "__esModule", { value: !0 }), Ga.fromMiliseconds = Ga.toMiliseconds = void 0;
  const t = V4();
  function e(n) {
    return n * t.ONE_THOUSAND;
  }
  Ga.toMiliseconds = e;
  function r(n) {
    return Math.floor(n / t.ONE_THOUSAND);
  }
  return Ga.fromMiliseconds = r, Ga;
}
var nx;
function mk() {
  return nx || (nx = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const e = Yl;
    e.__exportStar(hk(), t), e.__exportStar(gk(), t);
  }(im)), im;
}
var Qc = {}, ix;
function vk() {
  if (ix) return Qc;
  ix = 1, Object.defineProperty(Qc, "__esModule", { value: !0 }), Qc.Watch = void 0;
  class t {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(r) {
      if (this.timestamps.has(r))
        throw new Error(`Watch already started for label: ${r}`);
      this.timestamps.set(r, { started: Date.now() });
    }
    stop(r) {
      const n = this.get(r);
      if (typeof n.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${r}`);
      const i = Date.now() - n.started;
      this.timestamps.set(r, { started: n.started, elapsed: i });
    }
    get(r) {
      const n = this.timestamps.get(r);
      if (typeof n > "u")
        throw new Error(`No timestamp found for label: ${r}`);
      return n;
    }
    elapsed(r) {
      const n = this.get(r);
      return n.elapsed || Date.now() - n.started;
    }
  }
  return Qc.Watch = t, Qc.default = t, Qc;
}
var am = {}, If = {}, sx;
function bk() {
  if (sx) return If;
  sx = 1, Object.defineProperty(If, "__esModule", { value: !0 }), If.IWatch = void 0;
  class t {
  }
  return If.IWatch = t, If;
}
var ox;
function yk() {
  return ox || (ox = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), Yl.__exportStar(bk(), t);
  }(am)), am;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = Yl;
  e.__exportStar(mk(), t), e.__exportStar(vk(), t), e.__exportStar(yk(), t), e.__exportStar(V4(), t);
})(vt);
class Mc {
}
let wk = class extends Mc {
  constructor(e) {
    super();
  }
};
const ax = vt.FIVE_SECONDS, ju = { pulse: "heartbeat_pulse" };
let xk = class G4 extends wk {
  constructor(e) {
    super(e), this.events = new is.EventEmitter(), this.interval = ax, this.interval = (e == null ? void 0 : e.interval) || ax;
  }
  static async init(e) {
    const r = new G4(e);
    return await r.init(), r;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), vt.toMiliseconds(this.interval));
  }
  pulse() {
    this.events.emit(ju.pulse);
  }
};
const _k = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, Ek = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, Sk = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function Ak(t, e) {
  if (t === "__proto__" || t === "constructor" && e && typeof e == "object" && "prototype" in e) {
    Pk(t);
    return;
  }
  return e;
}
function Pk(t) {
  console.warn(`[destr] Dropping "${t}" key to prevent prototype pollution.`);
}
function vd(t, e = {}) {
  if (typeof t != "string")
    return t;
  const r = t.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    t[0] === '"' && t.endsWith('"') && !t.includes("\\")
  )
    return r.slice(1, -1);
  if (r.length <= 9) {
    const n = r.toLowerCase();
    if (n === "true")
      return !0;
    if (n === "false")
      return !1;
    if (n === "undefined")
      return;
    if (n === "null")
      return null;
    if (n === "nan")
      return Number.NaN;
    if (n === "infinity")
      return Number.POSITIVE_INFINITY;
    if (n === "-infinity")
      return Number.NEGATIVE_INFINITY;
  }
  if (!Sk.test(t)) {
    if (e.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return t;
  }
  try {
    if (_k.test(t) || Ek.test(t)) {
      if (e.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(t, Ak);
    }
    return JSON.parse(t);
  } catch (n) {
    if (e.strict)
      throw n;
    return t;
  }
}
function Mk(t) {
  return !t || typeof t.then != "function" ? Promise.resolve(t) : t;
}
function Cn(t, ...e) {
  try {
    return Mk(t(...e));
  } catch (r) {
    return Promise.reject(r);
  }
}
function Ik(t) {
  const e = typeof t;
  return t === null || e !== "object" && e !== "function";
}
function Ck(t) {
  const e = Object.getPrototypeOf(t);
  return !e || e.isPrototypeOf(Object);
}
function Nd(t) {
  if (Ik(t))
    return String(t);
  if (Ck(t) || Array.isArray(t))
    return JSON.stringify(t);
  if (typeof t.toJSON == "function")
    return Nd(t.toJSON());
  throw new Error("[unstorage] Cannot stringify value!");
}
function Y4() {
  if (typeof Buffer > "u")
    throw new TypeError("[unstorage] Buffer is not supported!");
}
const M1 = "base64:";
function Tk(t) {
  if (typeof t == "string")
    return t;
  Y4();
  const e = Buffer.from(t).toString("base64");
  return M1 + e;
}
function Rk(t) {
  return typeof t != "string" || !t.startsWith(M1) ? t : (Y4(), Buffer.from(t.slice(M1.length), "base64"));
}
function gi(t) {
  return t ? t.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : "";
}
function Dk(...t) {
  return gi(t.join(":"));
}
function bd(t) {
  return t = gi(t), t ? t + ":" : "";
}
const Ok = "memory", Nk = () => {
  const t = /* @__PURE__ */ new Map();
  return {
    name: Ok,
    getInstance: () => t,
    hasItem(e) {
      return t.has(e);
    },
    getItem(e) {
      return t.get(e) ?? null;
    },
    getItemRaw(e) {
      return t.get(e) ?? null;
    },
    setItem(e, r) {
      t.set(e, r);
    },
    setItemRaw(e, r) {
      t.set(e, r);
    },
    removeItem(e) {
      t.delete(e);
    },
    getKeys() {
      return [...t.keys()];
    },
    clear() {
      t.clear();
    },
    dispose() {
      t.clear();
    }
  };
};
function Lk(t = {}) {
  const e = {
    mounts: { "": t.driver || Nk() },
    mountpoints: [""],
    watching: !1,
    watchListeners: [],
    unwatch: {}
  }, r = (l) => {
    for (const d of e.mountpoints)
      if (l.startsWith(d))
        return {
          base: d,
          relativeKey: l.slice(d.length),
          driver: e.mounts[d]
        };
    return {
      base: "",
      relativeKey: l,
      driver: e.mounts[""]
    };
  }, n = (l, d) => e.mountpoints.filter(
    (p) => p.startsWith(l) || d && l.startsWith(p)
  ).map((p) => ({
    relativeBase: l.length > p.length ? l.slice(p.length) : void 0,
    mountpoint: p,
    driver: e.mounts[p]
  })), i = (l, d) => {
    if (e.watching) {
      d = gi(d);
      for (const p of e.watchListeners)
        p(l, d);
    }
  }, s = async () => {
    if (!e.watching) {
      e.watching = !0;
      for (const l in e.mounts)
        e.unwatch[l] = await cx(
          e.mounts[l],
          i,
          l
        );
    }
  }, o = async () => {
    if (e.watching) {
      for (const l in e.unwatch)
        await e.unwatch[l]();
      e.unwatch = {}, e.watching = !1;
    }
  }, a = (l, d, p) => {
    const w = /* @__PURE__ */ new Map(), _ = (P) => {
      let O = w.get(P.base);
      return O || (O = {
        driver: P.driver,
        base: P.base,
        items: []
      }, w.set(P.base, O)), O;
    };
    for (const P of l) {
      const O = typeof P == "string", L = gi(O ? P : P.key), B = O ? void 0 : P.value, k = O || !P.options ? d : { ...d, ...P.options }, q = r(L);
      _(q).items.push({
        key: L,
        value: B,
        relativeKey: q.relativeKey,
        options: k
      });
    }
    return Promise.all([...w.values()].map((P) => p(P))).then(
      (P) => P.flat()
    );
  }, u = {
    // Item
    hasItem(l, d = {}) {
      l = gi(l);
      const { relativeKey: p, driver: w } = r(l);
      return Cn(w.hasItem, p, d);
    },
    getItem(l, d = {}) {
      l = gi(l);
      const { relativeKey: p, driver: w } = r(l);
      return Cn(w.getItem, p, d).then(
        (_) => vd(_)
      );
    },
    getItems(l, d) {
      return a(l, d, (p) => p.driver.getItems ? Cn(
        p.driver.getItems,
        p.items.map((w) => ({
          key: w.relativeKey,
          options: w.options
        })),
        d
      ).then(
        (w) => w.map((_) => ({
          key: Dk(p.base, _.key),
          value: vd(_.value)
        }))
      ) : Promise.all(
        p.items.map((w) => Cn(
          p.driver.getItem,
          w.relativeKey,
          w.options
        ).then((_) => ({
          key: w.key,
          value: vd(_)
        })))
      ));
    },
    getItemRaw(l, d = {}) {
      l = gi(l);
      const { relativeKey: p, driver: w } = r(l);
      return w.getItemRaw ? Cn(w.getItemRaw, p, d) : Cn(w.getItem, p, d).then(
        (_) => Rk(_)
      );
    },
    async setItem(l, d, p = {}) {
      if (d === void 0)
        return u.removeItem(l);
      l = gi(l);
      const { relativeKey: w, driver: _ } = r(l);
      _.setItem && (await Cn(_.setItem, w, Nd(d), p), _.watch || i("update", l));
    },
    async setItems(l, d) {
      await a(l, d, async (p) => {
        if (p.driver.setItems)
          return Cn(
            p.driver.setItems,
            p.items.map((w) => ({
              key: w.relativeKey,
              value: Nd(w.value),
              options: w.options
            })),
            d
          );
        p.driver.setItem && await Promise.all(
          p.items.map((w) => Cn(
            p.driver.setItem,
            w.relativeKey,
            Nd(w.value),
            w.options
          ))
        );
      });
    },
    async setItemRaw(l, d, p = {}) {
      if (d === void 0)
        return u.removeItem(l, p);
      l = gi(l);
      const { relativeKey: w, driver: _ } = r(l);
      if (_.setItemRaw)
        await Cn(_.setItemRaw, w, d, p);
      else if (_.setItem)
        await Cn(_.setItem, w, Tk(d), p);
      else
        return;
      _.watch || i("update", l);
    },
    async removeItem(l, d = {}) {
      typeof d == "boolean" && (d = { removeMeta: d }), l = gi(l);
      const { relativeKey: p, driver: w } = r(l);
      w.removeItem && (await Cn(w.removeItem, p, d), (d.removeMeta || d.removeMata) && await Cn(w.removeItem, p + "$", d), w.watch || i("remove", l));
    },
    // Meta
    async getMeta(l, d = {}) {
      typeof d == "boolean" && (d = { nativeOnly: d }), l = gi(l);
      const { relativeKey: p, driver: w } = r(l), _ = /* @__PURE__ */ Object.create(null);
      if (w.getMeta && Object.assign(_, await Cn(w.getMeta, p, d)), !d.nativeOnly) {
        const P = await Cn(
          w.getItem,
          p + "$",
          d
        ).then((O) => vd(O));
        P && typeof P == "object" && (typeof P.atime == "string" && (P.atime = new Date(P.atime)), typeof P.mtime == "string" && (P.mtime = new Date(P.mtime)), Object.assign(_, P));
      }
      return _;
    },
    setMeta(l, d, p = {}) {
      return this.setItem(l + "$", d, p);
    },
    removeMeta(l, d = {}) {
      return this.removeItem(l + "$", d);
    },
    // Keys
    async getKeys(l, d = {}) {
      l = bd(l);
      const p = n(l, !0);
      let w = [];
      const _ = [];
      for (const P of p) {
        const O = await Cn(
          P.driver.getKeys,
          P.relativeBase,
          d
        );
        for (const L of O) {
          const B = P.mountpoint + gi(L);
          w.some((k) => B.startsWith(k)) || _.push(B);
        }
        w = [
          P.mountpoint,
          ...w.filter((L) => !L.startsWith(P.mountpoint))
        ];
      }
      return l ? _.filter(
        (P) => P.startsWith(l) && P[P.length - 1] !== "$"
      ) : _.filter((P) => P[P.length - 1] !== "$");
    },
    // Utils
    async clear(l, d = {}) {
      l = bd(l), await Promise.all(
        n(l, !1).map(async (p) => {
          if (p.driver.clear)
            return Cn(p.driver.clear, p.relativeBase, d);
          if (p.driver.removeItem) {
            const w = await p.driver.getKeys(p.relativeBase || "", d);
            return Promise.all(
              w.map((_) => p.driver.removeItem(_, d))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(e.mounts).map((l) => ux(l))
      );
    },
    async watch(l) {
      return await s(), e.watchListeners.push(l), async () => {
        e.watchListeners = e.watchListeners.filter(
          (d) => d !== l
        ), e.watchListeners.length === 0 && await o();
      };
    },
    async unwatch() {
      e.watchListeners = [], await o();
    },
    // Mount
    mount(l, d) {
      if (l = bd(l), l && e.mounts[l])
        throw new Error(`already mounted at ${l}`);
      return l && (e.mountpoints.push(l), e.mountpoints.sort((p, w) => w.length - p.length)), e.mounts[l] = d, e.watching && Promise.resolve(cx(d, i, l)).then((p) => {
        e.unwatch[l] = p;
      }).catch(console.error), u;
    },
    async unmount(l, d = !0) {
      l = bd(l), !(!l || !e.mounts[l]) && (e.watching && l in e.unwatch && (e.unwatch[l](), delete e.unwatch[l]), d && await ux(e.mounts[l]), e.mountpoints = e.mountpoints.filter((p) => p !== l), delete e.mounts[l]);
    },
    getMount(l = "") {
      l = gi(l) + ":";
      const d = r(l);
      return {
        driver: d.driver,
        base: d.base
      };
    },
    getMounts(l = "", d = {}) {
      return l = gi(l), n(l, d.parents).map((w) => ({
        driver: w.driver,
        base: w.mountpoint
      }));
    },
    // Aliases
    keys: (l, d = {}) => u.getKeys(l, d),
    get: (l, d = {}) => u.getItem(l, d),
    set: (l, d, p = {}) => u.setItem(l, d, p),
    has: (l, d = {}) => u.hasItem(l, d),
    del: (l, d = {}) => u.removeItem(l, d),
    remove: (l, d = {}) => u.removeItem(l, d)
  };
  return u;
}
function cx(t, e, r) {
  return t.watch ? t.watch((n, i) => e(n, r + i)) : () => {
  };
}
async function ux(t) {
  typeof t.dispose == "function" && await Cn(t.dispose);
}
function Ic(t) {
  return new Promise((e, r) => {
    t.oncomplete = t.onsuccess = () => e(t.result), t.onabort = t.onerror = () => r(t.error);
  });
}
function J4(t, e) {
  const r = indexedDB.open(t);
  r.onupgradeneeded = () => r.result.createObjectStore(e);
  const n = Ic(r);
  return (i, s) => n.then((o) => s(o.transaction(e, i).objectStore(e)));
}
let cm;
function Jl() {
  return cm || (cm = J4("keyval-store", "keyval")), cm;
}
function fx(t, e = Jl()) {
  return e("readonly", (r) => Ic(r.get(t)));
}
function kk(t, e, r = Jl()) {
  return r("readwrite", (n) => (n.put(e, t), Ic(n.transaction)));
}
function $k(t, e = Jl()) {
  return e("readwrite", (r) => (r.delete(t), Ic(r.transaction)));
}
function Bk(t = Jl()) {
  return t("readwrite", (e) => (e.clear(), Ic(e.transaction)));
}
function Fk(t, e) {
  return t.openCursor().onsuccess = function() {
    this.result && (e(this.result), this.result.continue());
  }, Ic(t.transaction);
}
function jk(t = Jl()) {
  return t("readonly", (e) => {
    if (e.getAllKeys)
      return Ic(e.getAllKeys());
    const r = [];
    return Fk(e, (n) => r.push(n.key)).then(() => r);
  });
}
const Uk = (t) => JSON.stringify(t, (e, r) => typeof r == "bigint" ? r.toString() + "n" : r), qk = (t) => {
  const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, r = t.replace(e, '$1"$2n"$3');
  return JSON.parse(r, (n, i) => typeof i == "string" && i.match(/^\d+n$/) ? BigInt(i.substring(0, i.length - 1)) : i);
};
function bc(t) {
  if (typeof t != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof t}`);
  try {
    return qk(t);
  } catch {
    return t;
  }
}
function jo(t) {
  return typeof t == "string" ? t : Uk(t) || "";
}
const zk = "idb-keyval";
var Wk = (t = {}) => {
  const e = t.base && t.base.length > 0 ? `${t.base}:` : "", r = (i) => e + i;
  let n;
  return t.dbName && t.storeName && (n = J4(t.dbName, t.storeName)), { name: zk, options: t, async hasItem(i) {
    return !(typeof await fx(r(i), n) > "u");
  }, async getItem(i) {
    return await fx(r(i), n) ?? null;
  }, setItem(i, s) {
    return kk(r(i), s, n);
  }, removeItem(i) {
    return $k(r(i), n);
  }, getKeys() {
    return jk(n);
  }, clear() {
    return Bk(n);
  } };
};
const Hk = "WALLET_CONNECT_V2_INDEXED_DB", Kk = "keyvaluestorage";
let Vk = class {
  constructor() {
    this.indexedDb = Lk({ driver: Wk({ dbName: Hk, storeName: Kk }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((e) => [e.key, e.value]);
  }
  async getItem(e) {
    const r = await this.indexedDb.getItem(e);
    if (r !== null) return r;
  }
  async setItem(e, r) {
    await this.indexedDb.setItem(e, jo(r));
  }
  async removeItem(e) {
    await this.indexedDb.removeItem(e);
  }
};
var um = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Ld = { exports: {} };
(function() {
  let t;
  function e() {
  }
  t = e, t.prototype.getItem = function(r) {
    return this.hasOwnProperty(r) ? String(this[r]) : null;
  }, t.prototype.setItem = function(r, n) {
    this[r] = String(n);
  }, t.prototype.removeItem = function(r) {
    delete this[r];
  }, t.prototype.clear = function() {
    const r = this;
    Object.keys(r).forEach(function(n) {
      r[n] = void 0, delete r[n];
    });
  }, t.prototype.key = function(r) {
    return r = r || 0, Object.keys(this)[r];
  }, t.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof um < "u" && um.localStorage ? Ld.exports = um.localStorage : typeof window < "u" && window.localStorage ? Ld.exports = window.localStorage : Ld.exports = new e();
})();
function Gk(t) {
  var e;
  return [t[0], bc((e = t[1]) != null ? e : "")];
}
let Yk = class {
  constructor() {
    this.localStorage = Ld.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(Gk);
  }
  async getItem(e) {
    const r = this.localStorage.getItem(e);
    if (r !== null) return bc(r);
  }
  async setItem(e, r) {
    this.localStorage.setItem(e, jo(r));
  }
  async removeItem(e) {
    this.localStorage.removeItem(e);
  }
};
const Jk = "wc_storage_version", lx = 1, Xk = async (t, e, r) => {
  const n = Jk, i = await e.getItem(n);
  if (i && i >= lx) {
    r(e);
    return;
  }
  const s = await t.getKeys();
  if (!s.length) {
    r(e);
    return;
  }
  const o = [];
  for (; s.length; ) {
    const a = s.shift();
    if (!a) continue;
    const u = a.toLowerCase();
    if (u.includes("wc@") || u.includes("walletconnect") || u.includes("wc_") || u.includes("wallet_connect")) {
      const l = await t.getItem(a);
      await e.setItem(a, l), o.push(a);
    }
  }
  await e.setItem(n, lx), r(e), Zk(t, o);
}, Zk = async (t, e) => {
  e.length && e.forEach(async (r) => {
    await t.removeItem(r);
  });
};
let Qk = class {
  constructor() {
    this.initialized = !1, this.setInitialized = (r) => {
      this.storage = r, this.initialized = !0;
    };
    const e = new Yk();
    this.storage = e;
    try {
      const r = new Vk();
      Xk(e, r, this.setInitialized);
    } catch {
      this.initialized = !0;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(e) {
    return await this.initialize(), this.storage.getItem(e);
  }
  async setItem(e, r) {
    return await this.initialize(), this.storage.setItem(e, r);
  }
  async removeItem(e) {
    return await this.initialize(), this.storage.removeItem(e);
  }
  async initialize() {
    this.initialized || await new Promise((e) => {
      const r = setInterval(() => {
        this.initialized && (clearInterval(r), e());
      }, 20);
    });
  }
};
function e$(t) {
  try {
    return JSON.stringify(t);
  } catch {
    return '"[Circular]"';
  }
}
var t$ = r$;
function r$(t, e, r) {
  var n = r && r.stringify || e$, i = 1;
  if (typeof t == "object" && t !== null) {
    var s = e.length + i;
    if (s === 1) return t;
    var o = new Array(s);
    o[0] = n(t);
    for (var a = 1; a < s; a++)
      o[a] = n(e[a]);
    return o.join(" ");
  }
  if (typeof t != "string")
    return t;
  var u = e.length;
  if (u === 0) return t;
  for (var l = "", d = 1 - i, p = -1, w = t && t.length || 0, _ = 0; _ < w; ) {
    if (t.charCodeAt(_) === 37 && _ + 1 < w) {
      switch (p = p > -1 ? p : 0, t.charCodeAt(_ + 1)) {
        case 100:
        case 102:
          if (d >= u || e[d] == null) break;
          p < _ && (l += t.slice(p, _)), l += Number(e[d]), p = _ + 2, _++;
          break;
        case 105:
          if (d >= u || e[d] == null) break;
          p < _ && (l += t.slice(p, _)), l += Math.floor(Number(e[d])), p = _ + 2, _++;
          break;
        case 79:
        case 111:
        case 106:
          if (d >= u || e[d] === void 0) break;
          p < _ && (l += t.slice(p, _));
          var P = typeof e[d];
          if (P === "string") {
            l += "'" + e[d] + "'", p = _ + 2, _++;
            break;
          }
          if (P === "function") {
            l += e[d].name || "<anonymous>", p = _ + 2, _++;
            break;
          }
          l += n(e[d]), p = _ + 2, _++;
          break;
        case 115:
          if (d >= u)
            break;
          p < _ && (l += t.slice(p, _)), l += String(e[d]), p = _ + 2, _++;
          break;
        case 37:
          p < _ && (l += t.slice(p, _)), l += "%", p = _ + 2, _++, d--;
          break;
      }
      ++d;
    }
    ++_;
  }
  return p === -1 ? t : (p < w && (l += t.slice(p)), l);
}
const hx = t$;
var ou = Uo;
const Tl = h$().console || {}, n$ = {
  mapHttpRequest: yd,
  mapHttpResponse: yd,
  wrapRequestSerializer: fm,
  wrapResponseSerializer: fm,
  wrapErrorSerializer: fm,
  req: yd,
  res: yd,
  err: c$
};
function i$(t, e) {
  return Array.isArray(t) ? t.filter(function(n) {
    return n !== "!stdSerializers.err";
  }) : t === !0 ? Object.keys(e) : !1;
}
function Uo(t) {
  t = t || {}, t.browser = t.browser || {};
  const e = t.browser.transmit;
  if (e && typeof e.send != "function")
    throw Error("pino: transmit option must have a send function");
  const r = t.browser.write || Tl;
  t.browser.write && (t.browser.asObject = !0);
  const n = t.serializers || {}, i = i$(t.browser.serialize, n);
  let s = t.browser.serialize;
  Array.isArray(t.browser.serialize) && t.browser.serialize.indexOf("!stdSerializers.err") > -1 && (s = !1);
  const o = ["error", "fatal", "warn", "info", "debug", "trace"];
  typeof r == "function" && (r.error = r.fatal = r.warn = r.info = r.debug = r.trace = r), t.enabled === !1 && (t.level = "silent");
  const a = t.level || "info", u = Object.create(r);
  u.log || (u.log = Rl), Object.defineProperty(u, "levelVal", {
    get: d
  }), Object.defineProperty(u, "level", {
    get: p,
    set: w
  });
  const l = {
    transmit: e,
    serialize: i,
    asObject: t.browser.asObject,
    levels: o,
    timestamp: u$(t)
  };
  u.levels = Uo.levels, u.level = a, u.setMaxListeners = u.getMaxListeners = u.emit = u.addListener = u.on = u.prependListener = u.once = u.prependOnceListener = u.removeListener = u.removeAllListeners = u.listeners = u.listenerCount = u.eventNames = u.write = u.flush = Rl, u.serializers = n, u._serialize = i, u._stdErrSerialize = s, u.child = _, e && (u._logEvent = I1());
  function d() {
    return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
  }
  function p() {
    return this._level;
  }
  function w(P) {
    if (P !== "silent" && !this.levels.values[P])
      throw Error("unknown level " + P);
    this._level = P, eu(l, u, "error", "log"), eu(l, u, "fatal", "error"), eu(l, u, "warn", "error"), eu(l, u, "info", "log"), eu(l, u, "debug", "log"), eu(l, u, "trace", "log");
  }
  function _(P, O) {
    if (!P)
      throw new Error("missing bindings for child Pino");
    O = O || {}, i && P.serializers && (O.serializers = P.serializers);
    const L = O.serializers;
    if (i && L) {
      var B = Object.assign({}, n, L), k = t.browser.serialize === !0 ? Object.keys(B) : i;
      delete P.serializers, J0([P], k, B, this._stdErrSerialize);
    }
    function q(U) {
      this._childLevel = (U._childLevel | 0) + 1, this.error = tu(U, P, "error"), this.fatal = tu(U, P, "fatal"), this.warn = tu(U, P, "warn"), this.info = tu(U, P, "info"), this.debug = tu(U, P, "debug"), this.trace = tu(U, P, "trace"), B && (this.serializers = B, this._serialize = k), e && (this._logEvent = I1(
        [].concat(U._logEvent.bindings, P)
      ));
    }
    return q.prototype = this, new q(this);
  }
  return u;
}
Uo.levels = {
  values: {
    fatal: 60,
    error: 50,
    warn: 40,
    info: 30,
    debug: 20,
    trace: 10
  },
  labels: {
    10: "trace",
    20: "debug",
    30: "info",
    40: "warn",
    50: "error",
    60: "fatal"
  }
};
Uo.stdSerializers = n$;
Uo.stdTimeFunctions = Object.assign({}, { nullTime: X4, epochTime: Z4, unixTime: f$, isoTime: l$ });
function eu(t, e, r, n) {
  const i = Object.getPrototypeOf(e);
  e[r] = e.levelVal > e.levels.values[r] ? Rl : i[r] ? i[r] : Tl[r] || Tl[n] || Rl, s$(t, e, r);
}
function s$(t, e, r) {
  !t.transmit && e[r] === Rl || (e[r] = /* @__PURE__ */ function(n) {
    return function() {
      const s = t.timestamp(), o = new Array(arguments.length), a = Object.getPrototypeOf && Object.getPrototypeOf(this) === Tl ? Tl : this;
      for (var u = 0; u < o.length; u++) o[u] = arguments[u];
      if (t.serialize && !t.asObject && J0(o, this._serialize, this.serializers, this._stdErrSerialize), t.asObject ? n.call(a, o$(this, r, o, s)) : n.apply(a, o), t.transmit) {
        const l = t.transmit.level || e.level, d = Uo.levels.values[l], p = Uo.levels.values[r];
        if (p < d) return;
        a$(this, {
          ts: s,
          methodLevel: r,
          methodValue: p,
          send: t.transmit.send,
          val: e.levelVal
        }, o);
      }
    };
  }(e[r]));
}
function o$(t, e, r, n) {
  t._serialize && J0(r, t._serialize, t.serializers, t._stdErrSerialize);
  const i = r.slice();
  let s = i[0];
  const o = {};
  n && (o.time = n), o.level = Uo.levels.values[e];
  let a = (t._childLevel | 0) + 1;
  if (a < 1 && (a = 1), s !== null && typeof s == "object") {
    for (; a-- && typeof i[0] == "object"; )
      Object.assign(o, i.shift());
    s = i.length ? hx(i.shift(), i) : void 0;
  } else typeof s == "string" && (s = hx(i.shift(), i));
  return s !== void 0 && (o.msg = s), o;
}
function J0(t, e, r, n) {
  for (const i in t)
    if (n && t[i] instanceof Error)
      t[i] = Uo.stdSerializers.err(t[i]);
    else if (typeof t[i] == "object" && !Array.isArray(t[i]))
      for (const s in t[i])
        e && e.indexOf(s) > -1 && s in r && (t[i][s] = r[s](t[i][s]));
}
function tu(t, e, r) {
  return function() {
    const n = new Array(1 + arguments.length);
    n[0] = e;
    for (var i = 1; i < n.length; i++)
      n[i] = arguments[i - 1];
    return t[r].apply(this, n);
  };
}
function a$(t, e, r) {
  const n = e.send, i = e.ts, s = e.methodLevel, o = e.methodValue, a = e.val, u = t._logEvent.bindings;
  J0(
    r,
    t._serialize || Object.keys(t.serializers),
    t.serializers,
    t._stdErrSerialize === void 0 ? !0 : t._stdErrSerialize
  ), t._logEvent.ts = i, t._logEvent.messages = r.filter(function(l) {
    return u.indexOf(l) === -1;
  }), t._logEvent.level.label = s, t._logEvent.level.value = o, n(s, t._logEvent, a), t._logEvent = I1(u);
}
function I1(t) {
  return {
    ts: 0,
    messages: [],
    bindings: t || [],
    level: { label: "", value: 0 }
  };
}
function c$(t) {
  const e = {
    type: t.constructor.name,
    msg: t.message,
    stack: t.stack
  };
  for (const r in t)
    e[r] === void 0 && (e[r] = t[r]);
  return e;
}
function u$(t) {
  return typeof t.timestamp == "function" ? t.timestamp : t.timestamp === !1 ? X4 : Z4;
}
function yd() {
  return {};
}
function fm(t) {
  return t;
}
function Rl() {
}
function X4() {
  return !1;
}
function Z4() {
  return Date.now();
}
function f$() {
  return Math.round(Date.now() / 1e3);
}
function l$() {
  return new Date(Date.now()).toISOString();
}
function h$() {
  function t(e) {
    return typeof e < "u" && e;
  }
  try {
    return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
      get: function() {
        return delete Object.prototype.globalThis, this.globalThis = this;
      },
      configurable: !0
    }), globalThis;
  } catch {
    return t(self) || t(window) || t(this) || {};
  }
}
const Xl = /* @__PURE__ */ ns(ou), d$ = { level: "info" }, Zl = "custom_context", Zv = 1e3 * 1024;
let p$ = class {
  constructor(e) {
    this.nodeValue = e, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
}, dx = class {
  constructor(e) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e, this.sizeInBytes = 0;
  }
  append(e) {
    const r = new p$(e);
    if (r.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${r.size}`);
    for (; this.size + r.size > this.maxSizeInBytes; ) this.shift();
    this.head ? (this.tail && (this.tail.next = r), this.tail = r) : (this.head = r, this.tail = r), this.lengthInNodes++, this.sizeInBytes += r.size;
  }
  shift() {
    if (!this.head) return;
    const e = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e.size;
  }
  toArray() {
    const e = [];
    let r = this.head;
    for (; r !== null; ) e.push(r.value), r = r.next;
    return e;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e = this.head;
    return { next: () => {
      if (!e) return { done: !0, value: null };
      const r = e.value;
      return e = e.next, { done: !1, value: r };
    } };
  }
}, Q4 = class {
  constructor(e, r = Zv) {
    this.level = e ?? "error", this.levelValue = ou.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = r, this.logs = new dx(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(e, r) {
    r === ou.levels.values.error ? console.error(e) : r === ou.levels.values.warn ? console.warn(e) : r === ou.levels.values.debug ? console.debug(e) : r === ou.levels.values.trace ? console.trace(e) : console.log(e);
  }
  appendToLogs(e) {
    this.logs.append(jo({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: e }));
    const r = typeof e == "string" ? JSON.parse(e).level : e.level;
    r >= this.levelValue && this.forwardToConsole(e, r);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new dx(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(e) {
    const r = this.getLogArray();
    return r.push(jo({ extraMetadata: e })), new Blob(r, { type: "application/json" });
  }
}, g$ = class {
  constructor(e, r = Zv) {
    this.baseChunkLogger = new Q4(e, r);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
  downloadLogsBlobInBrowser(e) {
    const r = URL.createObjectURL(this.logsToBlob(e)), n = document.createElement("a");
    n.href = r, n.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(n), n.click(), document.body.removeChild(n), URL.revokeObjectURL(r);
  }
}, m$ = class {
  constructor(e, r = Zv) {
    this.baseChunkLogger = new Q4(e, r);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
};
var v$ = Object.defineProperty, b$ = Object.defineProperties, y$ = Object.getOwnPropertyDescriptors, px = Object.getOwnPropertySymbols, w$ = Object.prototype.hasOwnProperty, x$ = Object.prototype.propertyIsEnumerable, gx = (t, e, r) => e in t ? v$(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, c0 = (t, e) => {
  for (var r in e || (e = {})) w$.call(e, r) && gx(t, r, e[r]);
  if (px) for (var r of px(e)) x$.call(e, r) && gx(t, r, e[r]);
  return t;
}, u0 = (t, e) => b$(t, y$(e));
function X0(t) {
  return u0(c0({}, t), { level: (t == null ? void 0 : t.level) || d$.level });
}
function _$(t, e = Zl) {
  return t[e] || "";
}
function E$(t, e, r = Zl) {
  return t[r] = e, t;
}
function Pi(t, e = Zl) {
  let r = "";
  return typeof t.bindings > "u" ? r = _$(t, e) : r = t.bindings().context || "", r;
}
function S$(t, e, r = Zl) {
  const n = Pi(t, r);
  return n.trim() ? `${n}/${e}` : e;
}
function ui(t, e, r = Zl) {
  const n = S$(t, e, r), i = t.child({ context: n });
  return E$(i, n, r);
}
function A$(t) {
  var e, r;
  const n = new g$((e = t.opts) == null ? void 0 : e.level, t.maxSizeInBytes);
  return { logger: Xl(u0(c0({}, t.opts), { level: "trace", browser: u0(c0({}, (r = t.opts) == null ? void 0 : r.browser), { write: (i) => n.write(i) }) })), chunkLoggerController: n };
}
function P$(t) {
  var e;
  const r = new m$((e = t.opts) == null ? void 0 : e.level, t.maxSizeInBytes);
  return { logger: Xl(u0(c0({}, t.opts), { level: "trace" }), r), chunkLoggerController: r };
}
function M$(t) {
  return typeof t.loggerOverride < "u" && typeof t.loggerOverride != "string" ? { logger: t.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? A$(t) : P$(t);
}
let I$ = class extends Mc {
  constructor(e) {
    super(), this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, C$ = class extends Mc {
  constructor(e, r) {
    super(), this.core = e, this.logger = r, this.records = /* @__PURE__ */ new Map();
  }
}, T$ = class {
  constructor(e, r) {
    this.logger = e, this.core = r;
  }
}, R$ = class extends Mc {
  constructor(e, r) {
    super(), this.relayer = e, this.logger = r;
  }
}, D$ = class extends Mc {
  constructor(e) {
    super();
  }
}, O$ = class {
  constructor(e, r, n, i) {
    this.core = e, this.logger = r, this.name = n;
  }
}, N$ = class extends Mc {
  constructor(e, r) {
    super(), this.relayer = e, this.logger = r;
  }
}, L$ = class extends Mc {
  constructor(e, r) {
    super(), this.core = e, this.logger = r;
  }
}, k$ = class {
  constructor(e, r, n) {
    this.core = e, this.logger = r, this.store = n;
  }
}, $$ = class {
  constructor(e, r) {
    this.projectId = e, this.logger = r;
  }
}, B$ = class {
  constructor(e, r, n) {
    this.core = e, this.logger = r, this.telemetryEnabled = n;
  }
}, F$ = class {
  constructor(e) {
    this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, j$ = class {
  constructor(e) {
    this.client = e;
  }
};
var Qv = {}, Da = {}, Z0 = {}, Q0 = {};
Object.defineProperty(Q0, "__esModule", { value: !0 });
Q0.BrowserRandomSource = void 0;
const mx = 65536;
class U$ {
  constructor() {
    this.isAvailable = !1, this.isInstantiated = !1;
    const e = typeof self < "u" ? self.crypto || self.msCrypto : null;
    e && e.getRandomValues !== void 0 && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Browser random byte generator is not available.");
    const r = new Uint8Array(e);
    for (let n = 0; n < r.length; n += mx)
      this._crypto.getRandomValues(r.subarray(n, n + Math.min(r.length - n, mx)));
    return r;
  }
}
Q0.BrowserRandomSource = U$;
function e8(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var ep = {}, Bi = {};
Object.defineProperty(Bi, "__esModule", { value: !0 });
function q$(t) {
  for (var e = 0; e < t.length; e++)
    t[e] = 0;
  return t;
}
Bi.wipe = q$;
const z$ = {}, W$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: z$
}, Symbol.toStringTag, { value: "Module" })), Ql = /* @__PURE__ */ Lv(W$);
Object.defineProperty(ep, "__esModule", { value: !0 });
ep.NodeRandomSource = void 0;
const H$ = Bi;
class K$ {
  constructor() {
    if (this.isAvailable = !1, this.isInstantiated = !1, typeof e8 < "u") {
      const e = Ql;
      e && e.randomBytes && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
    }
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Node.js random byte generator is not available.");
    let r = this._crypto.randomBytes(e);
    if (r.length !== e)
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    const n = new Uint8Array(e);
    for (let i = 0; i < n.length; i++)
      n[i] = r[i];
    return (0, H$.wipe)(r), n;
  }
}
ep.NodeRandomSource = K$;
Object.defineProperty(Z0, "__esModule", { value: !0 });
Z0.SystemRandomSource = void 0;
const V$ = Q0, G$ = ep;
class Y$ {
  constructor() {
    if (this.isAvailable = !1, this.name = "", this._source = new V$.BrowserRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Browser";
      return;
    }
    if (this._source = new G$.NodeRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Node";
      return;
    }
  }
  randomBytes(e) {
    if (!this.isAvailable)
      throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(e);
  }
}
Z0.SystemRandomSource = Y$;
var ar = {}, t8 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(a, u) {
    var l = a >>> 16 & 65535, d = a & 65535, p = u >>> 16 & 65535, w = u & 65535;
    return d * w + (l * w + d * p << 16 >>> 0) | 0;
  }
  t.mul = Math.imul || e;
  function r(a, u) {
    return a + u | 0;
  }
  t.add = r;
  function n(a, u) {
    return a - u | 0;
  }
  t.sub = n;
  function i(a, u) {
    return a << u | a >>> 32 - u;
  }
  t.rotl = i;
  function s(a, u) {
    return a << 32 - u | a >>> u;
  }
  t.rotr = s;
  function o(a) {
    return typeof a == "number" && isFinite(a) && Math.floor(a) === a;
  }
  t.isInteger = Number.isInteger || o, t.MAX_SAFE_INTEGER = 9007199254740991, t.isSafeInteger = function(a) {
    return t.isInteger(a) && a >= -t.MAX_SAFE_INTEGER && a <= t.MAX_SAFE_INTEGER;
  };
})(t8);
Object.defineProperty(ar, "__esModule", { value: !0 });
var r8 = t8;
function J$(t, e) {
  return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) << 16 >> 16;
}
ar.readInt16BE = J$;
function X$(t, e) {
  return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) >>> 0;
}
ar.readUint16BE = X$;
function Z$(t, e) {
  return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) << 16 >> 16;
}
ar.readInt16LE = Z$;
function Q$(t, e) {
  return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) >>> 0;
}
ar.readUint16LE = Q$;
function n8(t, e, r) {
  return e === void 0 && (e = new Uint8Array(2)), r === void 0 && (r = 0), e[r + 0] = t >>> 8, e[r + 1] = t >>> 0, e;
}
ar.writeUint16BE = n8;
ar.writeInt16BE = n8;
function i8(t, e, r) {
  return e === void 0 && (e = new Uint8Array(2)), r === void 0 && (r = 0), e[r + 0] = t >>> 0, e[r + 1] = t >>> 8, e;
}
ar.writeUint16LE = i8;
ar.writeInt16LE = i8;
function C1(t, e) {
  return e === void 0 && (e = 0), t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3];
}
ar.readInt32BE = C1;
function T1(t, e) {
  return e === void 0 && (e = 0), (t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]) >>> 0;
}
ar.readUint32BE = T1;
function R1(t, e) {
  return e === void 0 && (e = 0), t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e];
}
ar.readInt32LE = R1;
function D1(t, e) {
  return e === void 0 && (e = 0), (t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e]) >>> 0;
}
ar.readUint32LE = D1;
function f0(t, e, r) {
  return e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0), e[r + 0] = t >>> 24, e[r + 1] = t >>> 16, e[r + 2] = t >>> 8, e[r + 3] = t >>> 0, e;
}
ar.writeUint32BE = f0;
ar.writeInt32BE = f0;
function l0(t, e, r) {
  return e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0), e[r + 0] = t >>> 0, e[r + 1] = t >>> 8, e[r + 2] = t >>> 16, e[r + 3] = t >>> 24, e;
}
ar.writeUint32LE = l0;
ar.writeInt32LE = l0;
function eB(t, e) {
  e === void 0 && (e = 0);
  var r = C1(t, e), n = C1(t, e + 4);
  return r * 4294967296 + n - (n >> 31) * 4294967296;
}
ar.readInt64BE = eB;
function tB(t, e) {
  e === void 0 && (e = 0);
  var r = T1(t, e), n = T1(t, e + 4);
  return r * 4294967296 + n;
}
ar.readUint64BE = tB;
function rB(t, e) {
  e === void 0 && (e = 0);
  var r = R1(t, e), n = R1(t, e + 4);
  return n * 4294967296 + r - (r >> 31) * 4294967296;
}
ar.readInt64LE = rB;
function nB(t, e) {
  e === void 0 && (e = 0);
  var r = D1(t, e), n = D1(t, e + 4);
  return n * 4294967296 + r;
}
ar.readUint64LE = nB;
function s8(t, e, r) {
  return e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0), f0(t / 4294967296 >>> 0, e, r), f0(t >>> 0, e, r + 4), e;
}
ar.writeUint64BE = s8;
ar.writeInt64BE = s8;
function o8(t, e, r) {
  return e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0), l0(t >>> 0, e, r), l0(t / 4294967296 >>> 0, e, r + 4), e;
}
ar.writeUint64LE = o8;
ar.writeInt64LE = o8;
function iB(t, e, r) {
  if (r === void 0 && (r = 0), t % 8 !== 0)
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (t / 8 > e.length - r)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var n = 0, i = 1, s = t / 8 + r - 1; s >= r; s--)
    n += e[s] * i, i *= 256;
  return n;
}
ar.readUintBE = iB;
function sB(t, e, r) {
  if (r === void 0 && (r = 0), t % 8 !== 0)
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (t / 8 > e.length - r)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var n = 0, i = 1, s = r; s < r + t / 8; s++)
    n += e[s] * i, i *= 256;
  return n;
}
ar.readUintLE = sB;
function oB(t, e, r, n) {
  if (r === void 0 && (r = new Uint8Array(t / 8)), n === void 0 && (n = 0), t % 8 !== 0)
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!r8.isSafeInteger(e))
    throw new Error("writeUintBE value must be an integer");
  for (var i = 1, s = t / 8 + n - 1; s >= n; s--)
    r[s] = e / i & 255, i *= 256;
  return r;
}
ar.writeUintBE = oB;
function aB(t, e, r, n) {
  if (r === void 0 && (r = new Uint8Array(t / 8)), n === void 0 && (n = 0), t % 8 !== 0)
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!r8.isSafeInteger(e))
    throw new Error("writeUintLE value must be an integer");
  for (var i = 1, s = n; s < n + t / 8; s++)
    r[s] = e / i & 255, i *= 256;
  return r;
}
ar.writeUintLE = aB;
function cB(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat32(e);
}
ar.readFloat32BE = cB;
function uB(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat32(e, !0);
}
ar.readFloat32LE = uB;
function fB(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat64(e);
}
ar.readFloat64BE = fB;
function lB(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat64(e, !0);
}
ar.readFloat64LE = lB;
function hB(t, e, r) {
  e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat32(r, t), e;
}
ar.writeFloat32BE = hB;
function dB(t, e, r) {
  e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat32(r, t, !0), e;
}
ar.writeFloat32LE = dB;
function pB(t, e, r) {
  e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat64(r, t), e;
}
ar.writeFloat64BE = pB;
function gB(t, e, r) {
  e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat64(r, t, !0), e;
}
ar.writeFloat64LE = gB;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.randomStringForEntropy = t.randomString = t.randomUint32 = t.randomBytes = t.defaultRandomSource = void 0;
  const e = Z0, r = ar, n = Bi;
  t.defaultRandomSource = new e.SystemRandomSource();
  function i(l, d = t.defaultRandomSource) {
    return d.randomBytes(l);
  }
  t.randomBytes = i;
  function s(l = t.defaultRandomSource) {
    const d = i(4, l), p = (0, r.readUint32LE)(d);
    return (0, n.wipe)(d), p;
  }
  t.randomUint32 = s;
  const o = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function a(l, d = o, p = t.defaultRandomSource) {
    if (d.length < 2)
      throw new Error("randomString charset is too short");
    if (d.length > 256)
      throw new Error("randomString charset is too long");
    let w = "";
    const _ = d.length, P = 256 - 256 % _;
    for (; l > 0; ) {
      const O = i(Math.ceil(l * 256 / P), p);
      for (let L = 0; L < O.length && l > 0; L++) {
        const B = O[L];
        B < P && (w += d.charAt(B % _), l--);
      }
      (0, n.wipe)(O);
    }
    return w;
  }
  t.randomString = a;
  function u(l, d = o, p = t.defaultRandomSource) {
    const w = Math.ceil(l / (Math.log(d.length) / Math.LN2));
    return a(w, d, p);
  }
  t.randomStringForEntropy = u;
})(Da);
var a8 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = ar, r = Bi;
  t.DIGEST_LENGTH = 64, t.BLOCK_SIZE = 128;
  var n = (
    /** @class */
    function() {
      function a() {
        this.digestLength = t.DIGEST_LENGTH, this.blockSize = t.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return a.prototype._initState = function() {
        this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209;
      }, a.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, a.prototype.clean = function() {
        r.wipe(this._buffer), r.wipe(this._tempHi), r.wipe(this._tempLo), this.reset();
      }, a.prototype.update = function(u, l) {
        if (l === void 0 && (l = u.length), this._finished)
          throw new Error("SHA512: can't update because hash was finished.");
        var d = 0;
        if (this._bytesHashed += l, this._bufferLength > 0) {
          for (; this._bufferLength < t.BLOCK_SIZE && l > 0; )
            this._buffer[this._bufferLength++] = u[d++], l--;
          this._bufferLength === this.blockSize && (s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (l >= this.blockSize && (d = s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, u, d, l), l %= this.blockSize); l > 0; )
          this._buffer[this._bufferLength++] = u[d++], l--;
        return this;
      }, a.prototype.finish = function(u) {
        if (!this._finished) {
          var l = this._bytesHashed, d = this._bufferLength, p = l / 536870912 | 0, w = l << 3, _ = l % 128 < 112 ? 128 : 256;
          this._buffer[d] = 128;
          for (var P = d + 1; P < _ - 8; P++)
            this._buffer[P] = 0;
          e.writeUint32BE(p, this._buffer, _ - 8), e.writeUint32BE(w, this._buffer, _ - 4), s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, _), this._finished = !0;
        }
        for (var P = 0; P < this.digestLength / 8; P++)
          e.writeUint32BE(this._stateHi[P], u, P * 8), e.writeUint32BE(this._stateLo[P], u, P * 8 + 4);
        return this;
      }, a.prototype.digest = function() {
        var u = new Uint8Array(this.digestLength);
        return this.finish(u), u;
      }, a.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, a.prototype.restoreState = function(u) {
        return this._stateHi.set(u.stateHi), this._stateLo.set(u.stateLo), this._bufferLength = u.bufferLength, u.buffer && this._buffer.set(u.buffer), this._bytesHashed = u.bytesHashed, this._finished = !1, this;
      }, a.prototype.cleanSavedState = function(u) {
        r.wipe(u.stateHi), r.wipe(u.stateLo), u.buffer && r.wipe(u.buffer), u.bufferLength = 0, u.bytesHashed = 0;
      }, a;
    }()
  );
  t.SHA512 = n;
  var i = new Int32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  function s(a, u, l, d, p, w, _) {
    for (var P = l[0], O = l[1], L = l[2], B = l[3], k = l[4], q = l[5], U = l[6], V = l[7], Q = d[0], R = d[1], K = d[2], ge = d[3], Ee = d[4], Y = d[5], A = d[6], m = d[7], f, g, b, x, E, S, v, M; _ >= 128; ) {
      for (var I = 0; I < 16; I++) {
        var F = 8 * I + w;
        a[I] = e.readUint32BE(p, F), u[I] = e.readUint32BE(p, F + 4);
      }
      for (var I = 0; I < 80; I++) {
        var ce = P, D = O, oe = L, Z = B, J = k, ee = q, T = U, X = V, re = Q, pe = R, ie = K, ue = ge, ve = Ee, Pe = Y, De = A, Ce = m;
        if (f = V, g = m, E = g & 65535, S = g >>> 16, v = f & 65535, M = f >>> 16, f = (k >>> 14 | Ee << 18) ^ (k >>> 18 | Ee << 14) ^ (Ee >>> 9 | k << 23), g = (Ee >>> 14 | k << 18) ^ (Ee >>> 18 | k << 14) ^ (k >>> 9 | Ee << 23), E += g & 65535, S += g >>> 16, v += f & 65535, M += f >>> 16, f = k & q ^ ~k & U, g = Ee & Y ^ ~Ee & A, E += g & 65535, S += g >>> 16, v += f & 65535, M += f >>> 16, f = i[I * 2], g = i[I * 2 + 1], E += g & 65535, S += g >>> 16, v += f & 65535, M += f >>> 16, f = a[I % 16], g = u[I % 16], E += g & 65535, S += g >>> 16, v += f & 65535, M += f >>> 16, S += E >>> 16, v += S >>> 16, M += v >>> 16, b = v & 65535 | M << 16, x = E & 65535 | S << 16, f = b, g = x, E = g & 65535, S = g >>> 16, v = f & 65535, M = f >>> 16, f = (P >>> 28 | Q << 4) ^ (Q >>> 2 | P << 30) ^ (Q >>> 7 | P << 25), g = (Q >>> 28 | P << 4) ^ (P >>> 2 | Q << 30) ^ (P >>> 7 | Q << 25), E += g & 65535, S += g >>> 16, v += f & 65535, M += f >>> 16, f = P & O ^ P & L ^ O & L, g = Q & R ^ Q & K ^ R & K, E += g & 65535, S += g >>> 16, v += f & 65535, M += f >>> 16, S += E >>> 16, v += S >>> 16, M += v >>> 16, X = v & 65535 | M << 16, Ce = E & 65535 | S << 16, f = Z, g = ue, E = g & 65535, S = g >>> 16, v = f & 65535, M = f >>> 16, f = b, g = x, E += g & 65535, S += g >>> 16, v += f & 65535, M += f >>> 16, S += E >>> 16, v += S >>> 16, M += v >>> 16, Z = v & 65535 | M << 16, ue = E & 65535 | S << 16, O = ce, L = D, B = oe, k = Z, q = J, U = ee, V = T, P = X, R = re, K = pe, ge = ie, Ee = ue, Y = ve, A = Pe, m = De, Q = Ce, I % 16 === 15)
          for (var F = 0; F < 16; F++)
            f = a[F], g = u[F], E = g & 65535, S = g >>> 16, v = f & 65535, M = f >>> 16, f = a[(F + 9) % 16], g = u[(F + 9) % 16], E += g & 65535, S += g >>> 16, v += f & 65535, M += f >>> 16, b = a[(F + 1) % 16], x = u[(F + 1) % 16], f = (b >>> 1 | x << 31) ^ (b >>> 8 | x << 24) ^ b >>> 7, g = (x >>> 1 | b << 31) ^ (x >>> 8 | b << 24) ^ (x >>> 7 | b << 25), E += g & 65535, S += g >>> 16, v += f & 65535, M += f >>> 16, b = a[(F + 14) % 16], x = u[(F + 14) % 16], f = (b >>> 19 | x << 13) ^ (x >>> 29 | b << 3) ^ b >>> 6, g = (x >>> 19 | b << 13) ^ (b >>> 29 | x << 3) ^ (x >>> 6 | b << 26), E += g & 65535, S += g >>> 16, v += f & 65535, M += f >>> 16, S += E >>> 16, v += S >>> 16, M += v >>> 16, a[F] = v & 65535 | M << 16, u[F] = E & 65535 | S << 16;
      }
      f = P, g = Q, E = g & 65535, S = g >>> 16, v = f & 65535, M = f >>> 16, f = l[0], g = d[0], E += g & 65535, S += g >>> 16, v += f & 65535, M += f >>> 16, S += E >>> 16, v += S >>> 16, M += v >>> 16, l[0] = P = v & 65535 | M << 16, d[0] = Q = E & 65535 | S << 16, f = O, g = R, E = g & 65535, S = g >>> 16, v = f & 65535, M = f >>> 16, f = l[1], g = d[1], E += g & 65535, S += g >>> 16, v += f & 65535, M += f >>> 16, S += E >>> 16, v += S >>> 16, M += v >>> 16, l[1] = O = v & 65535 | M << 16, d[1] = R = E & 65535 | S << 16, f = L, g = K, E = g & 65535, S = g >>> 16, v = f & 65535, M = f >>> 16, f = l[2], g = d[2], E += g & 65535, S += g >>> 16, v += f & 65535, M += f >>> 16, S += E >>> 16, v += S >>> 16, M += v >>> 16, l[2] = L = v & 65535 | M << 16, d[2] = K = E & 65535 | S << 16, f = B, g = ge, E = g & 65535, S = g >>> 16, v = f & 65535, M = f >>> 16, f = l[3], g = d[3], E += g & 65535, S += g >>> 16, v += f & 65535, M += f >>> 16, S += E >>> 16, v += S >>> 16, M += v >>> 16, l[3] = B = v & 65535 | M << 16, d[3] = ge = E & 65535 | S << 16, f = k, g = Ee, E = g & 65535, S = g >>> 16, v = f & 65535, M = f >>> 16, f = l[4], g = d[4], E += g & 65535, S += g >>> 16, v += f & 65535, M += f >>> 16, S += E >>> 16, v += S >>> 16, M += v >>> 16, l[4] = k = v & 65535 | M << 16, d[4] = Ee = E & 65535 | S << 16, f = q, g = Y, E = g & 65535, S = g >>> 16, v = f & 65535, M = f >>> 16, f = l[5], g = d[5], E += g & 65535, S += g >>> 16, v += f & 65535, M += f >>> 16, S += E >>> 16, v += S >>> 16, M += v >>> 16, l[5] = q = v & 65535 | M << 16, d[5] = Y = E & 65535 | S << 16, f = U, g = A, E = g & 65535, S = g >>> 16, v = f & 65535, M = f >>> 16, f = l[6], g = d[6], E += g & 65535, S += g >>> 16, v += f & 65535, M += f >>> 16, S += E >>> 16, v += S >>> 16, M += v >>> 16, l[6] = U = v & 65535 | M << 16, d[6] = A = E & 65535 | S << 16, f = V, g = m, E = g & 65535, S = g >>> 16, v = f & 65535, M = f >>> 16, f = l[7], g = d[7], E += g & 65535, S += g >>> 16, v += f & 65535, M += f >>> 16, S += E >>> 16, v += S >>> 16, M += v >>> 16, l[7] = V = v & 65535 | M << 16, d[7] = m = E & 65535 | S << 16, w += 128, _ -= 128;
    }
    return w;
  }
  function o(a) {
    var u = new n();
    u.update(a);
    var l = u.digest();
    return u.clean(), l;
  }
  t.hash = o;
})(a8);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.convertSecretKeyToX25519 = t.convertPublicKeyToX25519 = t.verify = t.sign = t.extractPublicKeyFromSecretKey = t.generateKeyPair = t.generateKeyPairFromSeed = t.SEED_LENGTH = t.SECRET_KEY_LENGTH = t.PUBLIC_KEY_LENGTH = t.SIGNATURE_LENGTH = void 0;
  const e = Da, r = a8, n = Bi;
  t.SIGNATURE_LENGTH = 64, t.PUBLIC_KEY_LENGTH = 32, t.SECRET_KEY_LENGTH = 64, t.SEED_LENGTH = 32;
  function i(Z) {
    const J = new Float64Array(16);
    if (Z)
      for (let ee = 0; ee < Z.length; ee++)
        J[ee] = Z[ee];
    return J;
  }
  const s = new Uint8Array(32);
  s[0] = 9;
  const o = i(), a = i([1]), u = i([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]), l = i([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]), d = i([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]), p = i([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]), w = i([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function _(Z, J) {
    for (let ee = 0; ee < 16; ee++)
      Z[ee] = J[ee] | 0;
  }
  function P(Z) {
    let J = 1;
    for (let ee = 0; ee < 16; ee++) {
      let T = Z[ee] + J + 65535;
      J = Math.floor(T / 65536), Z[ee] = T - J * 65536;
    }
    Z[0] += J - 1 + 37 * (J - 1);
  }
  function O(Z, J, ee) {
    const T = ~(ee - 1);
    for (let X = 0; X < 16; X++) {
      const re = T & (Z[X] ^ J[X]);
      Z[X] ^= re, J[X] ^= re;
    }
  }
  function L(Z, J) {
    const ee = i(), T = i();
    for (let X = 0; X < 16; X++)
      T[X] = J[X];
    P(T), P(T), P(T);
    for (let X = 0; X < 2; X++) {
      ee[0] = T[0] - 65517;
      for (let pe = 1; pe < 15; pe++)
        ee[pe] = T[pe] - 65535 - (ee[pe - 1] >> 16 & 1), ee[pe - 1] &= 65535;
      ee[15] = T[15] - 32767 - (ee[14] >> 16 & 1);
      const re = ee[15] >> 16 & 1;
      ee[14] &= 65535, O(T, ee, 1 - re);
    }
    for (let X = 0; X < 16; X++)
      Z[2 * X] = T[X] & 255, Z[2 * X + 1] = T[X] >> 8;
  }
  function B(Z, J) {
    let ee = 0;
    for (let T = 0; T < 32; T++)
      ee |= Z[T] ^ J[T];
    return (1 & ee - 1 >>> 8) - 1;
  }
  function k(Z, J) {
    const ee = new Uint8Array(32), T = new Uint8Array(32);
    return L(ee, Z), L(T, J), B(ee, T);
  }
  function q(Z) {
    const J = new Uint8Array(32);
    return L(J, Z), J[0] & 1;
  }
  function U(Z, J) {
    for (let ee = 0; ee < 16; ee++)
      Z[ee] = J[2 * ee] + (J[2 * ee + 1] << 8);
    Z[15] &= 32767;
  }
  function V(Z, J, ee) {
    for (let T = 0; T < 16; T++)
      Z[T] = J[T] + ee[T];
  }
  function Q(Z, J, ee) {
    for (let T = 0; T < 16; T++)
      Z[T] = J[T] - ee[T];
  }
  function R(Z, J, ee) {
    let T, X, re = 0, pe = 0, ie = 0, ue = 0, ve = 0, Pe = 0, De = 0, Ce = 0, $e = 0, Me = 0, Ne = 0, Ke = 0, Le = 0, qe = 0, ze = 0, _e = 0, Ze = 0, at = 0, ke = 0, Qe = 0, tt = 0, Ye = 0, dt = 0, lt = 0, ct = 0, qt = 0, Jt = 0, Et = 0, er = 0, Xt = 0, Dt = 0, kt = ee[0], Ct = ee[1], mt = ee[2], Rt = ee[3], Nt = ee[4], bt = ee[5], $t = ee[6], Ft = ee[7], rt = ee[8], Bt = ee[9], $ = ee[10], z = ee[11], H = ee[12], C = ee[13], G = ee[14], j = ee[15];
    T = J[0], re += T * kt, pe += T * Ct, ie += T * mt, ue += T * Rt, ve += T * Nt, Pe += T * bt, De += T * $t, Ce += T * Ft, $e += T * rt, Me += T * Bt, Ne += T * $, Ke += T * z, Le += T * H, qe += T * C, ze += T * G, _e += T * j, T = J[1], pe += T * kt, ie += T * Ct, ue += T * mt, ve += T * Rt, Pe += T * Nt, De += T * bt, Ce += T * $t, $e += T * Ft, Me += T * rt, Ne += T * Bt, Ke += T * $, Le += T * z, qe += T * H, ze += T * C, _e += T * G, Ze += T * j, T = J[2], ie += T * kt, ue += T * Ct, ve += T * mt, Pe += T * Rt, De += T * Nt, Ce += T * bt, $e += T * $t, Me += T * Ft, Ne += T * rt, Ke += T * Bt, Le += T * $, qe += T * z, ze += T * H, _e += T * C, Ze += T * G, at += T * j, T = J[3], ue += T * kt, ve += T * Ct, Pe += T * mt, De += T * Rt, Ce += T * Nt, $e += T * bt, Me += T * $t, Ne += T * Ft, Ke += T * rt, Le += T * Bt, qe += T * $, ze += T * z, _e += T * H, Ze += T * C, at += T * G, ke += T * j, T = J[4], ve += T * kt, Pe += T * Ct, De += T * mt, Ce += T * Rt, $e += T * Nt, Me += T * bt, Ne += T * $t, Ke += T * Ft, Le += T * rt, qe += T * Bt, ze += T * $, _e += T * z, Ze += T * H, at += T * C, ke += T * G, Qe += T * j, T = J[5], Pe += T * kt, De += T * Ct, Ce += T * mt, $e += T * Rt, Me += T * Nt, Ne += T * bt, Ke += T * $t, Le += T * Ft, qe += T * rt, ze += T * Bt, _e += T * $, Ze += T * z, at += T * H, ke += T * C, Qe += T * G, tt += T * j, T = J[6], De += T * kt, Ce += T * Ct, $e += T * mt, Me += T * Rt, Ne += T * Nt, Ke += T * bt, Le += T * $t, qe += T * Ft, ze += T * rt, _e += T * Bt, Ze += T * $, at += T * z, ke += T * H, Qe += T * C, tt += T * G, Ye += T * j, T = J[7], Ce += T * kt, $e += T * Ct, Me += T * mt, Ne += T * Rt, Ke += T * Nt, Le += T * bt, qe += T * $t, ze += T * Ft, _e += T * rt, Ze += T * Bt, at += T * $, ke += T * z, Qe += T * H, tt += T * C, Ye += T * G, dt += T * j, T = J[8], $e += T * kt, Me += T * Ct, Ne += T * mt, Ke += T * Rt, Le += T * Nt, qe += T * bt, ze += T * $t, _e += T * Ft, Ze += T * rt, at += T * Bt, ke += T * $, Qe += T * z, tt += T * H, Ye += T * C, dt += T * G, lt += T * j, T = J[9], Me += T * kt, Ne += T * Ct, Ke += T * mt, Le += T * Rt, qe += T * Nt, ze += T * bt, _e += T * $t, Ze += T * Ft, at += T * rt, ke += T * Bt, Qe += T * $, tt += T * z, Ye += T * H, dt += T * C, lt += T * G, ct += T * j, T = J[10], Ne += T * kt, Ke += T * Ct, Le += T * mt, qe += T * Rt, ze += T * Nt, _e += T * bt, Ze += T * $t, at += T * Ft, ke += T * rt, Qe += T * Bt, tt += T * $, Ye += T * z, dt += T * H, lt += T * C, ct += T * G, qt += T * j, T = J[11], Ke += T * kt, Le += T * Ct, qe += T * mt, ze += T * Rt, _e += T * Nt, Ze += T * bt, at += T * $t, ke += T * Ft, Qe += T * rt, tt += T * Bt, Ye += T * $, dt += T * z, lt += T * H, ct += T * C, qt += T * G, Jt += T * j, T = J[12], Le += T * kt, qe += T * Ct, ze += T * mt, _e += T * Rt, Ze += T * Nt, at += T * bt, ke += T * $t, Qe += T * Ft, tt += T * rt, Ye += T * Bt, dt += T * $, lt += T * z, ct += T * H, qt += T * C, Jt += T * G, Et += T * j, T = J[13], qe += T * kt, ze += T * Ct, _e += T * mt, Ze += T * Rt, at += T * Nt, ke += T * bt, Qe += T * $t, tt += T * Ft, Ye += T * rt, dt += T * Bt, lt += T * $, ct += T * z, qt += T * H, Jt += T * C, Et += T * G, er += T * j, T = J[14], ze += T * kt, _e += T * Ct, Ze += T * mt, at += T * Rt, ke += T * Nt, Qe += T * bt, tt += T * $t, Ye += T * Ft, dt += T * rt, lt += T * Bt, ct += T * $, qt += T * z, Jt += T * H, Et += T * C, er += T * G, Xt += T * j, T = J[15], _e += T * kt, Ze += T * Ct, at += T * mt, ke += T * Rt, Qe += T * Nt, tt += T * bt, Ye += T * $t, dt += T * Ft, lt += T * rt, ct += T * Bt, qt += T * $, Jt += T * z, Et += T * H, er += T * C, Xt += T * G, Dt += T * j, re += 38 * Ze, pe += 38 * at, ie += 38 * ke, ue += 38 * Qe, ve += 38 * tt, Pe += 38 * Ye, De += 38 * dt, Ce += 38 * lt, $e += 38 * ct, Me += 38 * qt, Ne += 38 * Jt, Ke += 38 * Et, Le += 38 * er, qe += 38 * Xt, ze += 38 * Dt, X = 1, T = re + X + 65535, X = Math.floor(T / 65536), re = T - X * 65536, T = pe + X + 65535, X = Math.floor(T / 65536), pe = T - X * 65536, T = ie + X + 65535, X = Math.floor(T / 65536), ie = T - X * 65536, T = ue + X + 65535, X = Math.floor(T / 65536), ue = T - X * 65536, T = ve + X + 65535, X = Math.floor(T / 65536), ve = T - X * 65536, T = Pe + X + 65535, X = Math.floor(T / 65536), Pe = T - X * 65536, T = De + X + 65535, X = Math.floor(T / 65536), De = T - X * 65536, T = Ce + X + 65535, X = Math.floor(T / 65536), Ce = T - X * 65536, T = $e + X + 65535, X = Math.floor(T / 65536), $e = T - X * 65536, T = Me + X + 65535, X = Math.floor(T / 65536), Me = T - X * 65536, T = Ne + X + 65535, X = Math.floor(T / 65536), Ne = T - X * 65536, T = Ke + X + 65535, X = Math.floor(T / 65536), Ke = T - X * 65536, T = Le + X + 65535, X = Math.floor(T / 65536), Le = T - X * 65536, T = qe + X + 65535, X = Math.floor(T / 65536), qe = T - X * 65536, T = ze + X + 65535, X = Math.floor(T / 65536), ze = T - X * 65536, T = _e + X + 65535, X = Math.floor(T / 65536), _e = T - X * 65536, re += X - 1 + 37 * (X - 1), X = 1, T = re + X + 65535, X = Math.floor(T / 65536), re = T - X * 65536, T = pe + X + 65535, X = Math.floor(T / 65536), pe = T - X * 65536, T = ie + X + 65535, X = Math.floor(T / 65536), ie = T - X * 65536, T = ue + X + 65535, X = Math.floor(T / 65536), ue = T - X * 65536, T = ve + X + 65535, X = Math.floor(T / 65536), ve = T - X * 65536, T = Pe + X + 65535, X = Math.floor(T / 65536), Pe = T - X * 65536, T = De + X + 65535, X = Math.floor(T / 65536), De = T - X * 65536, T = Ce + X + 65535, X = Math.floor(T / 65536), Ce = T - X * 65536, T = $e + X + 65535, X = Math.floor(T / 65536), $e = T - X * 65536, T = Me + X + 65535, X = Math.floor(T / 65536), Me = T - X * 65536, T = Ne + X + 65535, X = Math.floor(T / 65536), Ne = T - X * 65536, T = Ke + X + 65535, X = Math.floor(T / 65536), Ke = T - X * 65536, T = Le + X + 65535, X = Math.floor(T / 65536), Le = T - X * 65536, T = qe + X + 65535, X = Math.floor(T / 65536), qe = T - X * 65536, T = ze + X + 65535, X = Math.floor(T / 65536), ze = T - X * 65536, T = _e + X + 65535, X = Math.floor(T / 65536), _e = T - X * 65536, re += X - 1 + 37 * (X - 1), Z[0] = re, Z[1] = pe, Z[2] = ie, Z[3] = ue, Z[4] = ve, Z[5] = Pe, Z[6] = De, Z[7] = Ce, Z[8] = $e, Z[9] = Me, Z[10] = Ne, Z[11] = Ke, Z[12] = Le, Z[13] = qe, Z[14] = ze, Z[15] = _e;
  }
  function K(Z, J) {
    R(Z, J, J);
  }
  function ge(Z, J) {
    const ee = i();
    let T;
    for (T = 0; T < 16; T++)
      ee[T] = J[T];
    for (T = 253; T >= 0; T--)
      K(ee, ee), T !== 2 && T !== 4 && R(ee, ee, J);
    for (T = 0; T < 16; T++)
      Z[T] = ee[T];
  }
  function Ee(Z, J) {
    const ee = i();
    let T;
    for (T = 0; T < 16; T++)
      ee[T] = J[T];
    for (T = 250; T >= 0; T--)
      K(ee, ee), T !== 1 && R(ee, ee, J);
    for (T = 0; T < 16; T++)
      Z[T] = ee[T];
  }
  function Y(Z, J) {
    const ee = i(), T = i(), X = i(), re = i(), pe = i(), ie = i(), ue = i(), ve = i(), Pe = i();
    Q(ee, Z[1], Z[0]), Q(Pe, J[1], J[0]), R(ee, ee, Pe), V(T, Z[0], Z[1]), V(Pe, J[0], J[1]), R(T, T, Pe), R(X, Z[3], J[3]), R(X, X, l), R(re, Z[2], J[2]), V(re, re, re), Q(pe, T, ee), Q(ie, re, X), V(ue, re, X), V(ve, T, ee), R(Z[0], pe, ie), R(Z[1], ve, ue), R(Z[2], ue, ie), R(Z[3], pe, ve);
  }
  function A(Z, J, ee) {
    for (let T = 0; T < 4; T++)
      O(Z[T], J[T], ee);
  }
  function m(Z, J) {
    const ee = i(), T = i(), X = i();
    ge(X, J[2]), R(ee, J[0], X), R(T, J[1], X), L(Z, T), Z[31] ^= q(ee) << 7;
  }
  function f(Z, J, ee) {
    _(Z[0], o), _(Z[1], a), _(Z[2], a), _(Z[3], o);
    for (let T = 255; T >= 0; --T) {
      const X = ee[T / 8 | 0] >> (T & 7) & 1;
      A(Z, J, X), Y(J, Z), Y(Z, Z), A(Z, J, X);
    }
  }
  function g(Z, J) {
    const ee = [i(), i(), i(), i()];
    _(ee[0], d), _(ee[1], p), _(ee[2], a), R(ee[3], d, p), f(Z, ee, J);
  }
  function b(Z) {
    if (Z.length !== t.SEED_LENGTH)
      throw new Error(`ed25519: seed must be ${t.SEED_LENGTH} bytes`);
    const J = (0, r.hash)(Z);
    J[0] &= 248, J[31] &= 127, J[31] |= 64;
    const ee = new Uint8Array(32), T = [i(), i(), i(), i()];
    g(T, J), m(ee, T);
    const X = new Uint8Array(64);
    return X.set(Z), X.set(ee, 32), {
      publicKey: ee,
      secretKey: X
    };
  }
  t.generateKeyPairFromSeed = b;
  function x(Z) {
    const J = (0, e.randomBytes)(32, Z), ee = b(J);
    return (0, n.wipe)(J), ee;
  }
  t.generateKeyPair = x;
  function E(Z) {
    if (Z.length !== t.SECRET_KEY_LENGTH)
      throw new Error(`ed25519: secret key must be ${t.SECRET_KEY_LENGTH} bytes`);
    return new Uint8Array(Z.subarray(32));
  }
  t.extractPublicKeyFromSecretKey = E;
  const S = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function v(Z, J) {
    let ee, T, X, re;
    for (T = 63; T >= 32; --T) {
      for (ee = 0, X = T - 32, re = T - 12; X < re; ++X)
        J[X] += ee - 16 * J[T] * S[X - (T - 32)], ee = Math.floor((J[X] + 128) / 256), J[X] -= ee * 256;
      J[X] += ee, J[T] = 0;
    }
    for (ee = 0, X = 0; X < 32; X++)
      J[X] += ee - (J[31] >> 4) * S[X], ee = J[X] >> 8, J[X] &= 255;
    for (X = 0; X < 32; X++)
      J[X] -= ee * S[X];
    for (T = 0; T < 32; T++)
      J[T + 1] += J[T] >> 8, Z[T] = J[T] & 255;
  }
  function M(Z) {
    const J = new Float64Array(64);
    for (let ee = 0; ee < 64; ee++)
      J[ee] = Z[ee];
    for (let ee = 0; ee < 64; ee++)
      Z[ee] = 0;
    v(Z, J);
  }
  function I(Z, J) {
    const ee = new Float64Array(64), T = [i(), i(), i(), i()], X = (0, r.hash)(Z.subarray(0, 32));
    X[0] &= 248, X[31] &= 127, X[31] |= 64;
    const re = new Uint8Array(64);
    re.set(X.subarray(32), 32);
    const pe = new r.SHA512();
    pe.update(re.subarray(32)), pe.update(J);
    const ie = pe.digest();
    pe.clean(), M(ie), g(T, ie), m(re, T), pe.reset(), pe.update(re.subarray(0, 32)), pe.update(Z.subarray(32)), pe.update(J);
    const ue = pe.digest();
    M(ue);
    for (let ve = 0; ve < 32; ve++)
      ee[ve] = ie[ve];
    for (let ve = 0; ve < 32; ve++)
      for (let Pe = 0; Pe < 32; Pe++)
        ee[ve + Pe] += ue[ve] * X[Pe];
    return v(re.subarray(32), ee), re;
  }
  t.sign = I;
  function F(Z, J) {
    const ee = i(), T = i(), X = i(), re = i(), pe = i(), ie = i(), ue = i();
    return _(Z[2], a), U(Z[1], J), K(X, Z[1]), R(re, X, u), Q(X, X, Z[2]), V(re, Z[2], re), K(pe, re), K(ie, pe), R(ue, ie, pe), R(ee, ue, X), R(ee, ee, re), Ee(ee, ee), R(ee, ee, X), R(ee, ee, re), R(ee, ee, re), R(Z[0], ee, re), K(T, Z[0]), R(T, T, re), k(T, X) && R(Z[0], Z[0], w), K(T, Z[0]), R(T, T, re), k(T, X) ? -1 : (q(Z[0]) === J[31] >> 7 && Q(Z[0], o, Z[0]), R(Z[3], Z[0], Z[1]), 0);
  }
  function ce(Z, J, ee) {
    const T = new Uint8Array(32), X = [i(), i(), i(), i()], re = [i(), i(), i(), i()];
    if (ee.length !== t.SIGNATURE_LENGTH)
      throw new Error(`ed25519: signature must be ${t.SIGNATURE_LENGTH} bytes`);
    if (F(re, Z))
      return !1;
    const pe = new r.SHA512();
    pe.update(ee.subarray(0, 32)), pe.update(Z), pe.update(J);
    const ie = pe.digest();
    return M(ie), f(X, re, ie), g(re, ee.subarray(32)), Y(X, re), m(T, X), !B(ee, T);
  }
  t.verify = ce;
  function D(Z) {
    let J = [i(), i(), i(), i()];
    if (F(J, Z))
      throw new Error("Ed25519: invalid public key");
    let ee = i(), T = i(), X = J[1];
    V(ee, a, X), Q(T, a, X), ge(T, T), R(ee, ee, T);
    let re = new Uint8Array(32);
    return L(re, ee), re;
  }
  t.convertPublicKeyToX25519 = D;
  function oe(Z) {
    const J = (0, r.hash)(Z.subarray(0, 32));
    J[0] &= 248, J[31] &= 127, J[31] |= 64;
    const ee = new Uint8Array(J.subarray(0, 32));
    return (0, n.wipe)(J), ee;
  }
  t.convertSecretKeyToX25519 = oe;
})(Qv);
const mB = "EdDSA", vB = "JWT", h0 = ".", tp = "base64url", c8 = "utf8", u8 = "utf8", bB = ":", yB = "did", wB = "key", vx = "base58btc", xB = "z", _B = "K36", EB = 32;
function f8(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(t) : new Uint8Array(t);
}
function kd(t, e) {
  e || (e = t.reduce((i, s) => i + s.length, 0));
  const r = f8(e);
  let n = 0;
  for (const i of t)
    r.set(i, n), n += i.length;
  return r;
}
function SB(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++)
    r[n] = 255;
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i), o = s.charCodeAt(0);
    if (r[o] !== 255)
      throw new TypeError(s + " is ambiguous");
    r[o] = i;
  }
  var a = t.length, u = t.charAt(0), l = Math.log(a) / Math.log(256), d = Math.log(256) / Math.log(a);
  function p(P) {
    if (P instanceof Uint8Array || (ArrayBuffer.isView(P) ? P = new Uint8Array(P.buffer, P.byteOffset, P.byteLength) : Array.isArray(P) && (P = Uint8Array.from(P))), !(P instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (P.length === 0)
      return "";
    for (var O = 0, L = 0, B = 0, k = P.length; B !== k && P[B] === 0; )
      B++, O++;
    for (var q = (k - B) * d + 1 >>> 0, U = new Uint8Array(q); B !== k; ) {
      for (var V = P[B], Q = 0, R = q - 1; (V !== 0 || Q < L) && R !== -1; R--, Q++)
        V += 256 * U[R] >>> 0, U[R] = V % a >>> 0, V = V / a >>> 0;
      if (V !== 0)
        throw new Error("Non-zero carry");
      L = Q, B++;
    }
    for (var K = q - L; K !== q && U[K] === 0; )
      K++;
    for (var ge = u.repeat(O); K < q; ++K)
      ge += t.charAt(U[K]);
    return ge;
  }
  function w(P) {
    if (typeof P != "string")
      throw new TypeError("Expected String");
    if (P.length === 0)
      return new Uint8Array();
    var O = 0;
    if (P[O] !== " ") {
      for (var L = 0, B = 0; P[O] === u; )
        L++, O++;
      for (var k = (P.length - O) * l + 1 >>> 0, q = new Uint8Array(k); P[O]; ) {
        var U = r[P.charCodeAt(O)];
        if (U === 255)
          return;
        for (var V = 0, Q = k - 1; (U !== 0 || V < B) && Q !== -1; Q--, V++)
          U += a * q[Q] >>> 0, q[Q] = U % 256 >>> 0, U = U / 256 >>> 0;
        if (U !== 0)
          throw new Error("Non-zero carry");
        B = V, O++;
      }
      if (P[O] !== " ") {
        for (var R = k - B; R !== k && q[R] === 0; )
          R++;
        for (var K = new Uint8Array(L + (k - R)), ge = L; R !== k; )
          K[ge++] = q[R++];
        return K;
      }
    }
  }
  function _(P) {
    var O = w(P);
    if (O)
      return O;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: p,
    decodeUnsafe: w,
    decode: _
  };
}
var AB = SB, PB = AB;
const MB = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, IB = (t) => new TextEncoder().encode(t), CB = (t) => new TextDecoder().decode(t);
class TB {
  constructor(e, r, n) {
    this.name = e, this.prefix = r, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class RB {
  constructor(e, r, n) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return l8(this, e);
  }
}
class DB {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return l8(this, e);
  }
  decode(e) {
    const r = e[0], n = this.decoders[r];
    if (n)
      return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const l8 = (t, e) => new DB({
  ...t.decoders || { [t.prefix]: t },
  ...e.decoders || { [e.prefix]: e }
});
class OB {
  constructor(e, r, n, i) {
    this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = i, this.encoder = new TB(e, r, n), this.decoder = new RB(e, r, i);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const rp = ({ name: t, prefix: e, encode: r, decode: n }) => new OB(t, e, r, n), eh = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: n, decode: i } = PB(r, e);
  return rp({
    prefix: t,
    name: e,
    encode: n,
    decode: (s) => MB(i(s))
  });
}, NB = (t, e, r, n) => {
  const i = {};
  for (let d = 0; d < e.length; ++d)
    i[e[d]] = d;
  let s = t.length;
  for (; t[s - 1] === "="; )
    --s;
  const o = new Uint8Array(s * r / 8 | 0);
  let a = 0, u = 0, l = 0;
  for (let d = 0; d < s; ++d) {
    const p = i[t[d]];
    if (p === void 0)
      throw new SyntaxError(`Non-${n} character`);
    u = u << r | p, a += r, a >= 8 && (a -= 8, o[l++] = 255 & u >> a);
  }
  if (a >= r || 255 & u << 8 - a)
    throw new SyntaxError("Unexpected end of data");
  return o;
}, LB = (t, e, r) => {
  const n = e[e.length - 1] === "=", i = (1 << r) - 1;
  let s = "", o = 0, a = 0;
  for (let u = 0; u < t.length; ++u)
    for (a = a << 8 | t[u], o += 8; o > r; )
      o -= r, s += e[i & a >> o];
  if (o && (s += e[i & a << r - o]), n)
    for (; s.length * r & 7; )
      s += "=";
  return s;
}, qn = ({ name: t, prefix: e, bitsPerChar: r, alphabet: n }) => rp({
  prefix: e,
  name: t,
  encode(i) {
    return LB(i, n, r);
  },
  decode(i) {
    return NB(i, n, r, t);
  }
}), kB = rp({
  prefix: "\0",
  name: "identity",
  encode: (t) => CB(t),
  decode: (t) => IB(t)
}), $B = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: kB
}, Symbol.toStringTag, { value: "Module" })), BB = qn({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), FB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: BB
}, Symbol.toStringTag, { value: "Module" })), jB = qn({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), UB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: jB
}, Symbol.toStringTag, { value: "Module" })), qB = eh({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), zB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: qB
}, Symbol.toStringTag, { value: "Module" })), WB = qn({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), HB = qn({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), KB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: WB,
  base16upper: HB
}, Symbol.toStringTag, { value: "Module" })), VB = qn({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), GB = qn({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), YB = qn({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), JB = qn({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), XB = qn({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), ZB = qn({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), QB = qn({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), eF = qn({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), tF = qn({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), rF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: VB,
  base32hex: XB,
  base32hexpad: QB,
  base32hexpadupper: eF,
  base32hexupper: ZB,
  base32pad: YB,
  base32padupper: JB,
  base32upper: GB,
  base32z: tF
}, Symbol.toStringTag, { value: "Module" })), nF = eh({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), iF = eh({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), sF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: nF,
  base36upper: iF
}, Symbol.toStringTag, { value: "Module" })), oF = eh({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), aF = eh({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), cF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: oF,
  base58flickr: aF
}, Symbol.toStringTag, { value: "Module" })), uF = qn({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), fF = qn({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), lF = qn({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), hF = qn({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), dF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: uF,
  base64pad: fF,
  base64url: lF,
  base64urlpad: hF
}, Symbol.toStringTag, { value: "Module" })), h8 = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), pF = h8.reduce((t, e, r) => (t[r] = e, t), []), gF = h8.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function mF(t) {
  return t.reduce((e, r) => (e += pF[r], e), "");
}
function vF(t) {
  const e = [];
  for (const r of t) {
    const n = gF[r.codePointAt(0)];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const bF = rp({
  prefix: "🚀",
  name: "base256emoji",
  encode: mF,
  decode: vF
}), yF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: bF
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const bx = {
  ...$B,
  ...FB,
  ...UB,
  ...zB,
  ...KB,
  ...rF,
  ...sF,
  ...cF,
  ...dF,
  ...yF
};
function d8(t, e, r, n) {
  return {
    name: t,
    prefix: e,
    encoder: {
      name: t,
      prefix: e,
      encode: r
    },
    decoder: { decode: n }
  };
}
const yx = d8("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), lm = d8("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = f8(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = t.charCodeAt(r);
  return e;
}), p8 = {
  utf8: yx,
  "utf-8": yx,
  hex: bx.base16,
  latin1: lm,
  ascii: lm,
  binary: lm,
  ...bx
};
function On(t, e = "utf8") {
  const r = p8[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8") : r.encoder.encode(t).substring(1);
}
function Rn(t, e = "utf8") {
  const r = p8[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t, "utf8") : r.decoder.decode(`${r.prefix}${t}`);
}
function wx(t) {
  return bc(On(Rn(t, tp), c8));
}
function d0(t) {
  return On(Rn(jo(t), c8), tp);
}
function g8(t) {
  const e = Rn(_B, vx), r = xB + On(kd([e, t]), vx);
  return [yB, wB, r].join(bB);
}
function wF(t) {
  return On(t, tp);
}
function xF(t) {
  return Rn(t, tp);
}
function _F(t) {
  return Rn([d0(t.header), d0(t.payload)].join(h0), u8);
}
function EF(t) {
  return [
    d0(t.header),
    d0(t.payload),
    wF(t.signature)
  ].join(h0);
}
function O1(t) {
  const e = t.split(h0), r = wx(e[0]), n = wx(e[1]), i = xF(e[2]), s = Rn(e.slice(0, 2).join(h0), u8);
  return { header: r, payload: n, signature: i, data: s };
}
function xx(t = Da.randomBytes(EB)) {
  return Qv.generateKeyPairFromSeed(t);
}
async function SF(t, e, r, n, i = vt.fromMiliseconds(Date.now())) {
  const s = { alg: mB, typ: vB }, o = g8(n.publicKey), a = i + r, u = { iss: o, sub: t, aud: e, iat: i, exp: a }, l = _F({ header: s, payload: u }), d = Qv.sign(n.secretKey, l);
  return EF({ header: s, payload: u, signature: d });
}
var _x = function(t, e, r) {
  if (r || arguments.length === 2) for (var n = 0, i = e.length, s; n < i; n++)
    (s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
  return t.concat(s || Array.prototype.slice.call(e));
}, AF = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e, r, n) {
      this.name = e, this.version = r, this.os = n, this.type = "browser";
    }
    return t;
  }()
), PF = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e) {
      this.version = e, this.type = "node", this.name = "node", this.os = process.platform;
    }
    return t;
  }()
), MF = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e, r, n, i) {
      this.name = e, this.version = r, this.os = n, this.bot = i, this.type = "bot-device";
    }
    return t;
  }()
), IF = (
  /** @class */
  /* @__PURE__ */ function() {
    function t() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return t;
  }()
), CF = (
  /** @class */
  /* @__PURE__ */ function() {
    function t() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return t;
  }()
), TF = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, RF = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, Ex = 3, DF = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", TF]
], Sx = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function OF(t) {
  return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new CF() : typeof navigator < "u" ? LF(navigator.userAgent) : $F();
}
function NF(t) {
  return t !== "" && DF.reduce(function(e, r) {
    var n = r[0], i = r[1];
    if (e)
      return e;
    var s = i.exec(t);
    return !!s && [n, s];
  }, !1);
}
function LF(t) {
  var e = NF(t);
  if (!e)
    return null;
  var r = e[0], n = e[1];
  if (r === "searchbot")
    return new IF();
  var i = n[1] && n[1].split(".").join("_").split("_").slice(0, 3);
  i ? i.length < Ex && (i = _x(_x([], i, !0), BF(Ex - i.length), !0)) : i = [];
  var s = i.join("."), o = kF(t), a = RF.exec(t);
  return a && a[1] ? new MF(r, s, o, a[1]) : new AF(r, s, o);
}
function kF(t) {
  for (var e = 0, r = Sx.length; e < r; e++) {
    var n = Sx[e], i = n[0], s = n[1], o = s.exec(t);
    if (o)
      return i;
  }
  return null;
}
function $F() {
  var t = typeof process < "u" && process.version;
  return t ? new PF(process.version.slice(1)) : null;
}
function BF(t) {
  for (var e = [], r = 0; r < t; r++)
    e.push("0");
  return e;
}
var Wr = {};
Object.defineProperty(Wr, "__esModule", { value: !0 });
Wr.getLocalStorage = Wr.getLocalStorageOrThrow = Wr.getCrypto = Wr.getCryptoOrThrow = m8 = Wr.getLocation = Wr.getLocationOrThrow = eb = Wr.getNavigator = Wr.getNavigatorOrThrow = th = Wr.getDocument = Wr.getDocumentOrThrow = Wr.getFromWindowOrThrow = Wr.getFromWindow = void 0;
function Cc(t) {
  let e;
  return typeof window < "u" && typeof window[t] < "u" && (e = window[t]), e;
}
Wr.getFromWindow = Cc;
function Uu(t) {
  const e = Cc(t);
  if (!e)
    throw new Error(`${t} is not defined in Window`);
  return e;
}
Wr.getFromWindowOrThrow = Uu;
function FF() {
  return Uu("document");
}
Wr.getDocumentOrThrow = FF;
function jF() {
  return Cc("document");
}
var th = Wr.getDocument = jF;
function UF() {
  return Uu("navigator");
}
Wr.getNavigatorOrThrow = UF;
function qF() {
  return Cc("navigator");
}
var eb = Wr.getNavigator = qF;
function zF() {
  return Uu("location");
}
Wr.getLocationOrThrow = zF;
function WF() {
  return Cc("location");
}
var m8 = Wr.getLocation = WF;
function HF() {
  return Uu("crypto");
}
Wr.getCryptoOrThrow = HF;
function KF() {
  return Cc("crypto");
}
Wr.getCrypto = KF;
function VF() {
  return Uu("localStorage");
}
Wr.getLocalStorageOrThrow = VF;
function GF() {
  return Cc("localStorage");
}
Wr.getLocalStorage = GF;
var tb = {};
Object.defineProperty(tb, "__esModule", { value: !0 });
var v8 = tb.getWindowMetadata = void 0;
const Ax = Wr;
function YF() {
  let t, e;
  try {
    t = Ax.getDocumentOrThrow(), e = Ax.getLocationOrThrow();
  } catch {
    return null;
  }
  function r() {
    const p = t.getElementsByTagName("link"), w = [];
    for (let _ = 0; _ < p.length; _++) {
      const P = p[_], O = P.getAttribute("rel");
      if (O && O.toLowerCase().indexOf("icon") > -1) {
        const L = P.getAttribute("href");
        if (L)
          if (L.toLowerCase().indexOf("https:") === -1 && L.toLowerCase().indexOf("http:") === -1 && L.indexOf("//") !== 0) {
            let B = e.protocol + "//" + e.host;
            if (L.indexOf("/") === 0)
              B += L;
            else {
              const k = e.pathname.split("/");
              k.pop();
              const q = k.join("/");
              B += q + "/" + L;
            }
            w.push(B);
          } else if (L.indexOf("//") === 0) {
            const B = e.protocol + L;
            w.push(B);
          } else
            w.push(L);
      }
    }
    return w;
  }
  function n(...p) {
    const w = t.getElementsByTagName("meta");
    for (let _ = 0; _ < w.length; _++) {
      const P = w[_], O = ["itemprop", "property", "name"].map((L) => P.getAttribute(L)).filter((L) => L ? p.includes(L) : !1);
      if (O.length && O) {
        const L = P.getAttribute("content");
        if (L)
          return L;
      }
    }
    return "";
  }
  function i() {
    let p = n("name", "og:site_name", "og:title", "twitter:title");
    return p || (p = t.title), p;
  }
  function s() {
    return n("description", "og:description", "twitter:description", "keywords");
  }
  const o = i(), a = s(), u = e.origin, l = r();
  return {
    description: a,
    url: u,
    icons: l,
    name: o
  };
}
v8 = tb.getWindowMetadata = YF;
var Dl = {}, JF = (t) => encodeURIComponent(t).replace(/[!'()*]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`), b8 = "%[a-f0-9]{2}", Px = new RegExp("(" + b8 + ")|([^%]+?)", "gi"), Mx = new RegExp("(" + b8 + ")+", "gi");
function N1(t, e) {
  try {
    return [decodeURIComponent(t.join(""))];
  } catch {
  }
  if (t.length === 1)
    return t;
  e = e || 1;
  var r = t.slice(0, e), n = t.slice(e);
  return Array.prototype.concat.call([], N1(r), N1(n));
}
function XF(t) {
  try {
    return decodeURIComponent(t);
  } catch {
    for (var e = t.match(Px) || [], r = 1; r < e.length; r++)
      t = N1(e, r).join(""), e = t.match(Px) || [];
    return t;
  }
}
function ZF(t) {
  for (var e = {
    "%FE%FF": "��",
    "%FF%FE": "��"
  }, r = Mx.exec(t); r; ) {
    try {
      e[r[0]] = decodeURIComponent(r[0]);
    } catch {
      var n = XF(r[0]);
      n !== r[0] && (e[r[0]] = n);
    }
    r = Mx.exec(t);
  }
  e["%C2"] = "�";
  for (var i = Object.keys(e), s = 0; s < i.length; s++) {
    var o = i[s];
    t = t.replace(new RegExp(o, "g"), e[o]);
  }
  return t;
}
var QF = function(t) {
  if (typeof t != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof t + "`");
  try {
    return t = t.replace(/\+/g, " "), decodeURIComponent(t);
  } catch {
    return ZF(t);
  }
}, ej = (t, e) => {
  if (!(typeof t == "string" && typeof e == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (e === "")
    return [t];
  const r = t.indexOf(e);
  return r === -1 ? [t] : [
    t.slice(0, r),
    t.slice(r + e.length)
  ];
}, tj = function(t, e) {
  for (var r = {}, n = Object.keys(t), i = Array.isArray(e), s = 0; s < n.length; s++) {
    var o = n[s], a = t[o];
    (i ? e.indexOf(o) !== -1 : e(o, a, t)) && (r[o] = a);
  }
  return r;
};
(function(t) {
  const e = JF, r = QF, n = ej, i = tj, s = (k) => k == null, o = Symbol("encodeFragmentIdentifier");
  function a(k) {
    switch (k.arrayFormat) {
      case "index":
        return (q) => (U, V) => {
          const Q = U.length;
          return V === void 0 || k.skipNull && V === null || k.skipEmptyString && V === "" ? U : V === null ? [...U, [d(q, k), "[", Q, "]"].join("")] : [
            ...U,
            [d(q, k), "[", d(Q, k), "]=", d(V, k)].join("")
          ];
        };
      case "bracket":
        return (q) => (U, V) => V === void 0 || k.skipNull && V === null || k.skipEmptyString && V === "" ? U : V === null ? [...U, [d(q, k), "[]"].join("")] : [...U, [d(q, k), "[]=", d(V, k)].join("")];
      case "colon-list-separator":
        return (q) => (U, V) => V === void 0 || k.skipNull && V === null || k.skipEmptyString && V === "" ? U : V === null ? [...U, [d(q, k), ":list="].join("")] : [...U, [d(q, k), ":list=", d(V, k)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const q = k.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (U) => (V, Q) => Q === void 0 || k.skipNull && Q === null || k.skipEmptyString && Q === "" ? V : (Q = Q === null ? "" : Q, V.length === 0 ? [[d(U, k), q, d(Q, k)].join("")] : [[V, d(Q, k)].join(k.arrayFormatSeparator)]);
      }
      default:
        return (q) => (U, V) => V === void 0 || k.skipNull && V === null || k.skipEmptyString && V === "" ? U : V === null ? [...U, d(q, k)] : [...U, [d(q, k), "=", d(V, k)].join("")];
    }
  }
  function u(k) {
    let q;
    switch (k.arrayFormat) {
      case "index":
        return (U, V, Q) => {
          if (q = /\[(\d*)\]$/.exec(U), U = U.replace(/\[\d*\]$/, ""), !q) {
            Q[U] = V;
            return;
          }
          Q[U] === void 0 && (Q[U] = {}), Q[U][q[1]] = V;
        };
      case "bracket":
        return (U, V, Q) => {
          if (q = /(\[\])$/.exec(U), U = U.replace(/\[\]$/, ""), !q) {
            Q[U] = V;
            return;
          }
          if (Q[U] === void 0) {
            Q[U] = [V];
            return;
          }
          Q[U] = [].concat(Q[U], V);
        };
      case "colon-list-separator":
        return (U, V, Q) => {
          if (q = /(:list)$/.exec(U), U = U.replace(/:list$/, ""), !q) {
            Q[U] = V;
            return;
          }
          if (Q[U] === void 0) {
            Q[U] = [V];
            return;
          }
          Q[U] = [].concat(Q[U], V);
        };
      case "comma":
      case "separator":
        return (U, V, Q) => {
          const R = typeof V == "string" && V.includes(k.arrayFormatSeparator), K = typeof V == "string" && !R && p(V, k).includes(k.arrayFormatSeparator);
          V = K ? p(V, k) : V;
          const ge = R || K ? V.split(k.arrayFormatSeparator).map((Ee) => p(Ee, k)) : V === null ? V : p(V, k);
          Q[U] = ge;
        };
      case "bracket-separator":
        return (U, V, Q) => {
          const R = /(\[\])$/.test(U);
          if (U = U.replace(/\[\]$/, ""), !R) {
            Q[U] = V && p(V, k);
            return;
          }
          const K = V === null ? [] : V.split(k.arrayFormatSeparator).map((ge) => p(ge, k));
          if (Q[U] === void 0) {
            Q[U] = K;
            return;
          }
          Q[U] = [].concat(Q[U], K);
        };
      default:
        return (U, V, Q) => {
          if (Q[U] === void 0) {
            Q[U] = V;
            return;
          }
          Q[U] = [].concat(Q[U], V);
        };
    }
  }
  function l(k) {
    if (typeof k != "string" || k.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function d(k, q) {
    return q.encode ? q.strict ? e(k) : encodeURIComponent(k) : k;
  }
  function p(k, q) {
    return q.decode ? r(k) : k;
  }
  function w(k) {
    return Array.isArray(k) ? k.sort() : typeof k == "object" ? w(Object.keys(k)).sort((q, U) => Number(q) - Number(U)).map((q) => k[q]) : k;
  }
  function _(k) {
    const q = k.indexOf("#");
    return q !== -1 && (k = k.slice(0, q)), k;
  }
  function P(k) {
    let q = "";
    const U = k.indexOf("#");
    return U !== -1 && (q = k.slice(U)), q;
  }
  function O(k) {
    k = _(k);
    const q = k.indexOf("?");
    return q === -1 ? "" : k.slice(q + 1);
  }
  function L(k, q) {
    return q.parseNumbers && !Number.isNaN(Number(k)) && typeof k == "string" && k.trim() !== "" ? k = Number(k) : q.parseBooleans && k !== null && (k.toLowerCase() === "true" || k.toLowerCase() === "false") && (k = k.toLowerCase() === "true"), k;
  }
  function B(k, q) {
    q = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, q), l(q.arrayFormatSeparator);
    const U = u(q), V = /* @__PURE__ */ Object.create(null);
    if (typeof k != "string" || (k = k.trim().replace(/^[?#&]/, ""), !k))
      return V;
    for (const Q of k.split("&")) {
      if (Q === "")
        continue;
      let [R, K] = n(q.decode ? Q.replace(/\+/g, " ") : Q, "=");
      K = K === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(q.arrayFormat) ? K : p(K, q), U(p(R, q), K, V);
    }
    for (const Q of Object.keys(V)) {
      const R = V[Q];
      if (typeof R == "object" && R !== null)
        for (const K of Object.keys(R))
          R[K] = L(R[K], q);
      else
        V[Q] = L(R, q);
    }
    return q.sort === !1 ? V : (q.sort === !0 ? Object.keys(V).sort() : Object.keys(V).sort(q.sort)).reduce((Q, R) => {
      const K = V[R];
      return K && typeof K == "object" && !Array.isArray(K) ? Q[R] = w(K) : Q[R] = K, Q;
    }, /* @__PURE__ */ Object.create(null));
  }
  t.extract = O, t.parse = B, t.stringify = (k, q) => {
    if (!k)
      return "";
    q = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, q), l(q.arrayFormatSeparator);
    const U = (K) => q.skipNull && s(k[K]) || q.skipEmptyString && k[K] === "", V = a(q), Q = {};
    for (const K of Object.keys(k))
      U(K) || (Q[K] = k[K]);
    const R = Object.keys(Q);
    return q.sort !== !1 && R.sort(q.sort), R.map((K) => {
      const ge = k[K];
      return ge === void 0 ? "" : ge === null ? d(K, q) : Array.isArray(ge) ? ge.length === 0 && q.arrayFormat === "bracket-separator" ? d(K, q) + "[]" : ge.reduce(V(K), []).join("&") : d(K, q) + "=" + d(ge, q);
    }).filter((K) => K.length > 0).join("&");
  }, t.parseUrl = (k, q) => {
    q = Object.assign({
      decode: !0
    }, q);
    const [U, V] = n(k, "#");
    return Object.assign(
      {
        url: U.split("?")[0] || "",
        query: B(O(k), q)
      },
      q && q.parseFragmentIdentifier && V ? { fragmentIdentifier: p(V, q) } : {}
    );
  }, t.stringifyUrl = (k, q) => {
    q = Object.assign({
      encode: !0,
      strict: !0,
      [o]: !0
    }, q);
    const U = _(k.url).split("?")[0] || "", V = t.extract(k.url), Q = t.parse(V, { sort: !1 }), R = Object.assign(Q, k.query);
    let K = t.stringify(R, q);
    K && (K = `?${K}`);
    let ge = P(k.url);
    return k.fragmentIdentifier && (ge = `#${q[o] ? d(k.fragmentIdentifier, q) : k.fragmentIdentifier}`), `${U}${K}${ge}`;
  }, t.pick = (k, q, U) => {
    U = Object.assign({
      parseFragmentIdentifier: !0,
      [o]: !1
    }, U);
    const { url: V, query: Q, fragmentIdentifier: R } = t.parseUrl(k, U);
    return t.stringifyUrl({
      url: V,
      query: i(Q, q),
      fragmentIdentifier: R
    }, U);
  }, t.exclude = (k, q, U) => {
    const V = Array.isArray(q) ? (Q) => !q.includes(Q) : (Q, R) => !q(Q, R);
    return t.pick(k, V, U);
  };
})(Dl);
var y8 = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(t) {
  (function() {
    var e = "input is invalid type", r = "finalize already called", n = typeof window == "object", i = n ? window : {};
    i.JS_SHA3_NO_WINDOW && (n = !1);
    var s = !n && typeof self == "object", o = !i.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    o ? i = gn : s && (i = self);
    var a = !i.JS_SHA3_NO_COMMON_JS && !0 && t.exports, u = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", l = "0123456789abcdef".split(""), d = [31, 7936, 2031616, 520093696], p = [4, 1024, 262144, 67108864], w = [1, 256, 65536, 16777216], _ = [6, 1536, 393216, 100663296], P = [0, 8, 16, 24], O = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ], L = [224, 256, 384, 512], B = [128, 256], k = ["hex", "buffer", "arrayBuffer", "array", "digest"], q = {
      128: 168,
      256: 136
    };
    (i.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(D) {
      return Object.prototype.toString.call(D) === "[object Array]";
    }), u && (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(D) {
      return typeof D == "object" && D.buffer && D.buffer.constructor === ArrayBuffer;
    });
    for (var U = function(D, oe, Z) {
      return function(J) {
        return new I(D, oe, D).update(J)[Z]();
      };
    }, V = function(D, oe, Z) {
      return function(J, ee) {
        return new I(D, oe, ee).update(J)[Z]();
      };
    }, Q = function(D, oe, Z) {
      return function(J, ee, T, X) {
        return f["cshake" + D].update(J, ee, T, X)[Z]();
      };
    }, R = function(D, oe, Z) {
      return function(J, ee, T, X) {
        return f["kmac" + D].update(J, ee, T, X)[Z]();
      };
    }, K = function(D, oe, Z, J) {
      for (var ee = 0; ee < k.length; ++ee) {
        var T = k[ee];
        D[T] = oe(Z, J, T);
      }
      return D;
    }, ge = function(D, oe) {
      var Z = U(D, oe, "hex");
      return Z.create = function() {
        return new I(D, oe, D);
      }, Z.update = function(J) {
        return Z.create().update(J);
      }, K(Z, U, D, oe);
    }, Ee = function(D, oe) {
      var Z = V(D, oe, "hex");
      return Z.create = function(J) {
        return new I(D, oe, J);
      }, Z.update = function(J, ee) {
        return Z.create(ee).update(J);
      }, K(Z, V, D, oe);
    }, Y = function(D, oe) {
      var Z = q[D], J = Q(D, oe, "hex");
      return J.create = function(ee, T, X) {
        return !T && !X ? f["shake" + D].create(ee) : new I(D, oe, ee).bytepad([T, X], Z);
      }, J.update = function(ee, T, X, re) {
        return J.create(T, X, re).update(ee);
      }, K(J, Q, D, oe);
    }, A = function(D, oe) {
      var Z = q[D], J = R(D, oe, "hex");
      return J.create = function(ee, T, X) {
        return new F(D, oe, T).bytepad(["KMAC", X], Z).bytepad([ee], Z);
      }, J.update = function(ee, T, X, re) {
        return J.create(ee, X, re).update(T);
      }, K(J, R, D, oe);
    }, m = [
      { name: "keccak", padding: w, bits: L, createMethod: ge },
      { name: "sha3", padding: _, bits: L, createMethod: ge },
      { name: "shake", padding: d, bits: B, createMethod: Ee },
      { name: "cshake", padding: p, bits: B, createMethod: Y },
      { name: "kmac", padding: p, bits: B, createMethod: A }
    ], f = {}, g = [], b = 0; b < m.length; ++b)
      for (var x = m[b], E = x.bits, S = 0; S < E.length; ++S) {
        var v = x.name + "_" + E[S];
        if (g.push(v), f[v] = x.createMethod(E[S], x.padding), x.name !== "sha3") {
          var M = x.name + E[S];
          g.push(M), f[M] = f[v];
        }
      }
    function I(D, oe, Z) {
      this.blocks = [], this.s = [], this.padding = oe, this.outputBits = Z, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (D << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = Z >> 5, this.extraBytes = (Z & 31) >> 3;
      for (var J = 0; J < 50; ++J)
        this.s[J] = 0;
    }
    I.prototype.update = function(D) {
      if (this.finalized)
        throw new Error(r);
      var oe, Z = typeof D;
      if (Z !== "string") {
        if (Z === "object") {
          if (D === null)
            throw new Error(e);
          if (u && D.constructor === ArrayBuffer)
            D = new Uint8Array(D);
          else if (!Array.isArray(D) && (!u || !ArrayBuffer.isView(D)))
            throw new Error(e);
        } else
          throw new Error(e);
        oe = !0;
      }
      for (var J = this.blocks, ee = this.byteCount, T = D.length, X = this.blockCount, re = 0, pe = this.s, ie, ue; re < T; ) {
        if (this.reset)
          for (this.reset = !1, J[0] = this.block, ie = 1; ie < X + 1; ++ie)
            J[ie] = 0;
        if (oe)
          for (ie = this.start; re < T && ie < ee; ++re)
            J[ie >> 2] |= D[re] << P[ie++ & 3];
        else
          for (ie = this.start; re < T && ie < ee; ++re)
            ue = D.charCodeAt(re), ue < 128 ? J[ie >> 2] |= ue << P[ie++ & 3] : ue < 2048 ? (J[ie >> 2] |= (192 | ue >> 6) << P[ie++ & 3], J[ie >> 2] |= (128 | ue & 63) << P[ie++ & 3]) : ue < 55296 || ue >= 57344 ? (J[ie >> 2] |= (224 | ue >> 12) << P[ie++ & 3], J[ie >> 2] |= (128 | ue >> 6 & 63) << P[ie++ & 3], J[ie >> 2] |= (128 | ue & 63) << P[ie++ & 3]) : (ue = 65536 + ((ue & 1023) << 10 | D.charCodeAt(++re) & 1023), J[ie >> 2] |= (240 | ue >> 18) << P[ie++ & 3], J[ie >> 2] |= (128 | ue >> 12 & 63) << P[ie++ & 3], J[ie >> 2] |= (128 | ue >> 6 & 63) << P[ie++ & 3], J[ie >> 2] |= (128 | ue & 63) << P[ie++ & 3]);
        if (this.lastByteIndex = ie, ie >= ee) {
          for (this.start = ie - ee, this.block = J[X], ie = 0; ie < X; ++ie)
            pe[ie] ^= J[ie];
          ce(pe), this.reset = !0;
        } else
          this.start = ie;
      }
      return this;
    }, I.prototype.encode = function(D, oe) {
      var Z = D & 255, J = 1, ee = [Z];
      for (D = D >> 8, Z = D & 255; Z > 0; )
        ee.unshift(Z), D = D >> 8, Z = D & 255, ++J;
      return oe ? ee.push(J) : ee.unshift(J), this.update(ee), ee.length;
    }, I.prototype.encodeString = function(D) {
      var oe, Z = typeof D;
      if (Z !== "string") {
        if (Z === "object") {
          if (D === null)
            throw new Error(e);
          if (u && D.constructor === ArrayBuffer)
            D = new Uint8Array(D);
          else if (!Array.isArray(D) && (!u || !ArrayBuffer.isView(D)))
            throw new Error(e);
        } else
          throw new Error(e);
        oe = !0;
      }
      var J = 0, ee = D.length;
      if (oe)
        J = ee;
      else
        for (var T = 0; T < D.length; ++T) {
          var X = D.charCodeAt(T);
          X < 128 ? J += 1 : X < 2048 ? J += 2 : X < 55296 || X >= 57344 ? J += 3 : (X = 65536 + ((X & 1023) << 10 | D.charCodeAt(++T) & 1023), J += 4);
        }
      return J += this.encode(J * 8), this.update(D), J;
    }, I.prototype.bytepad = function(D, oe) {
      for (var Z = this.encode(oe), J = 0; J < D.length; ++J)
        Z += this.encodeString(D[J]);
      var ee = oe - Z % oe, T = [];
      return T.length = ee, this.update(T), this;
    }, I.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var D = this.blocks, oe = this.lastByteIndex, Z = this.blockCount, J = this.s;
        if (D[oe >> 2] |= this.padding[oe & 3], this.lastByteIndex === this.byteCount)
          for (D[0] = D[Z], oe = 1; oe < Z + 1; ++oe)
            D[oe] = 0;
        for (D[Z - 1] |= 2147483648, oe = 0; oe < Z; ++oe)
          J[oe] ^= D[oe];
        ce(J);
      }
    }, I.prototype.toString = I.prototype.hex = function() {
      this.finalize();
      for (var D = this.blockCount, oe = this.s, Z = this.outputBlocks, J = this.extraBytes, ee = 0, T = 0, X = "", re; T < Z; ) {
        for (ee = 0; ee < D && T < Z; ++ee, ++T)
          re = oe[ee], X += l[re >> 4 & 15] + l[re & 15] + l[re >> 12 & 15] + l[re >> 8 & 15] + l[re >> 20 & 15] + l[re >> 16 & 15] + l[re >> 28 & 15] + l[re >> 24 & 15];
        T % D === 0 && (ce(oe), ee = 0);
      }
      return J && (re = oe[ee], X += l[re >> 4 & 15] + l[re & 15], J > 1 && (X += l[re >> 12 & 15] + l[re >> 8 & 15]), J > 2 && (X += l[re >> 20 & 15] + l[re >> 16 & 15])), X;
    }, I.prototype.arrayBuffer = function() {
      this.finalize();
      var D = this.blockCount, oe = this.s, Z = this.outputBlocks, J = this.extraBytes, ee = 0, T = 0, X = this.outputBits >> 3, re;
      J ? re = new ArrayBuffer(Z + 1 << 2) : re = new ArrayBuffer(X);
      for (var pe = new Uint32Array(re); T < Z; ) {
        for (ee = 0; ee < D && T < Z; ++ee, ++T)
          pe[T] = oe[ee];
        T % D === 0 && ce(oe);
      }
      return J && (pe[ee] = oe[ee], re = re.slice(0, X)), re;
    }, I.prototype.buffer = I.prototype.arrayBuffer, I.prototype.digest = I.prototype.array = function() {
      this.finalize();
      for (var D = this.blockCount, oe = this.s, Z = this.outputBlocks, J = this.extraBytes, ee = 0, T = 0, X = [], re, pe; T < Z; ) {
        for (ee = 0; ee < D && T < Z; ++ee, ++T)
          re = T << 2, pe = oe[ee], X[re] = pe & 255, X[re + 1] = pe >> 8 & 255, X[re + 2] = pe >> 16 & 255, X[re + 3] = pe >> 24 & 255;
        T % D === 0 && ce(oe);
      }
      return J && (re = T << 2, pe = oe[ee], X[re] = pe & 255, J > 1 && (X[re + 1] = pe >> 8 & 255), J > 2 && (X[re + 2] = pe >> 16 & 255)), X;
    };
    function F(D, oe, Z) {
      I.call(this, D, oe, Z);
    }
    F.prototype = new I(), F.prototype.finalize = function() {
      return this.encode(this.outputBits, !0), I.prototype.finalize.call(this);
    };
    var ce = function(D) {
      var oe, Z, J, ee, T, X, re, pe, ie, ue, ve, Pe, De, Ce, $e, Me, Ne, Ke, Le, qe, ze, _e, Ze, at, ke, Qe, tt, Ye, dt, lt, ct, qt, Jt, Et, er, Xt, Dt, kt, Ct, mt, Rt, Nt, bt, $t, Ft, rt, Bt, $, z, H, C, G, j, se, de, xe, Te, Re, nt, je, pt, it, et;
      for (J = 0; J < 48; J += 2)
        ee = D[0] ^ D[10] ^ D[20] ^ D[30] ^ D[40], T = D[1] ^ D[11] ^ D[21] ^ D[31] ^ D[41], X = D[2] ^ D[12] ^ D[22] ^ D[32] ^ D[42], re = D[3] ^ D[13] ^ D[23] ^ D[33] ^ D[43], pe = D[4] ^ D[14] ^ D[24] ^ D[34] ^ D[44], ie = D[5] ^ D[15] ^ D[25] ^ D[35] ^ D[45], ue = D[6] ^ D[16] ^ D[26] ^ D[36] ^ D[46], ve = D[7] ^ D[17] ^ D[27] ^ D[37] ^ D[47], Pe = D[8] ^ D[18] ^ D[28] ^ D[38] ^ D[48], De = D[9] ^ D[19] ^ D[29] ^ D[39] ^ D[49], oe = Pe ^ (X << 1 | re >>> 31), Z = De ^ (re << 1 | X >>> 31), D[0] ^= oe, D[1] ^= Z, D[10] ^= oe, D[11] ^= Z, D[20] ^= oe, D[21] ^= Z, D[30] ^= oe, D[31] ^= Z, D[40] ^= oe, D[41] ^= Z, oe = ee ^ (pe << 1 | ie >>> 31), Z = T ^ (ie << 1 | pe >>> 31), D[2] ^= oe, D[3] ^= Z, D[12] ^= oe, D[13] ^= Z, D[22] ^= oe, D[23] ^= Z, D[32] ^= oe, D[33] ^= Z, D[42] ^= oe, D[43] ^= Z, oe = X ^ (ue << 1 | ve >>> 31), Z = re ^ (ve << 1 | ue >>> 31), D[4] ^= oe, D[5] ^= Z, D[14] ^= oe, D[15] ^= Z, D[24] ^= oe, D[25] ^= Z, D[34] ^= oe, D[35] ^= Z, D[44] ^= oe, D[45] ^= Z, oe = pe ^ (Pe << 1 | De >>> 31), Z = ie ^ (De << 1 | Pe >>> 31), D[6] ^= oe, D[7] ^= Z, D[16] ^= oe, D[17] ^= Z, D[26] ^= oe, D[27] ^= Z, D[36] ^= oe, D[37] ^= Z, D[46] ^= oe, D[47] ^= Z, oe = ue ^ (ee << 1 | T >>> 31), Z = ve ^ (T << 1 | ee >>> 31), D[8] ^= oe, D[9] ^= Z, D[18] ^= oe, D[19] ^= Z, D[28] ^= oe, D[29] ^= Z, D[38] ^= oe, D[39] ^= Z, D[48] ^= oe, D[49] ^= Z, Ce = D[0], $e = D[1], rt = D[11] << 4 | D[10] >>> 28, Bt = D[10] << 4 | D[11] >>> 28, Ye = D[20] << 3 | D[21] >>> 29, dt = D[21] << 3 | D[20] >>> 29, je = D[31] << 9 | D[30] >>> 23, pt = D[30] << 9 | D[31] >>> 23, Nt = D[40] << 18 | D[41] >>> 14, bt = D[41] << 18 | D[40] >>> 14, Et = D[2] << 1 | D[3] >>> 31, er = D[3] << 1 | D[2] >>> 31, Me = D[13] << 12 | D[12] >>> 20, Ne = D[12] << 12 | D[13] >>> 20, $ = D[22] << 10 | D[23] >>> 22, z = D[23] << 10 | D[22] >>> 22, lt = D[33] << 13 | D[32] >>> 19, ct = D[32] << 13 | D[33] >>> 19, it = D[42] << 2 | D[43] >>> 30, et = D[43] << 2 | D[42] >>> 30, se = D[5] << 30 | D[4] >>> 2, de = D[4] << 30 | D[5] >>> 2, Xt = D[14] << 6 | D[15] >>> 26, Dt = D[15] << 6 | D[14] >>> 26, Ke = D[25] << 11 | D[24] >>> 21, Le = D[24] << 11 | D[25] >>> 21, H = D[34] << 15 | D[35] >>> 17, C = D[35] << 15 | D[34] >>> 17, qt = D[45] << 29 | D[44] >>> 3, Jt = D[44] << 29 | D[45] >>> 3, at = D[6] << 28 | D[7] >>> 4, ke = D[7] << 28 | D[6] >>> 4, xe = D[17] << 23 | D[16] >>> 9, Te = D[16] << 23 | D[17] >>> 9, kt = D[26] << 25 | D[27] >>> 7, Ct = D[27] << 25 | D[26] >>> 7, qe = D[36] << 21 | D[37] >>> 11, ze = D[37] << 21 | D[36] >>> 11, G = D[47] << 24 | D[46] >>> 8, j = D[46] << 24 | D[47] >>> 8, $t = D[8] << 27 | D[9] >>> 5, Ft = D[9] << 27 | D[8] >>> 5, Qe = D[18] << 20 | D[19] >>> 12, tt = D[19] << 20 | D[18] >>> 12, Re = D[29] << 7 | D[28] >>> 25, nt = D[28] << 7 | D[29] >>> 25, mt = D[38] << 8 | D[39] >>> 24, Rt = D[39] << 8 | D[38] >>> 24, _e = D[48] << 14 | D[49] >>> 18, Ze = D[49] << 14 | D[48] >>> 18, D[0] = Ce ^ ~Me & Ke, D[1] = $e ^ ~Ne & Le, D[10] = at ^ ~Qe & Ye, D[11] = ke ^ ~tt & dt, D[20] = Et ^ ~Xt & kt, D[21] = er ^ ~Dt & Ct, D[30] = $t ^ ~rt & $, D[31] = Ft ^ ~Bt & z, D[40] = se ^ ~xe & Re, D[41] = de ^ ~Te & nt, D[2] = Me ^ ~Ke & qe, D[3] = Ne ^ ~Le & ze, D[12] = Qe ^ ~Ye & lt, D[13] = tt ^ ~dt & ct, D[22] = Xt ^ ~kt & mt, D[23] = Dt ^ ~Ct & Rt, D[32] = rt ^ ~$ & H, D[33] = Bt ^ ~z & C, D[42] = xe ^ ~Re & je, D[43] = Te ^ ~nt & pt, D[4] = Ke ^ ~qe & _e, D[5] = Le ^ ~ze & Ze, D[14] = Ye ^ ~lt & qt, D[15] = dt ^ ~ct & Jt, D[24] = kt ^ ~mt & Nt, D[25] = Ct ^ ~Rt & bt, D[34] = $ ^ ~H & G, D[35] = z ^ ~C & j, D[44] = Re ^ ~je & it, D[45] = nt ^ ~pt & et, D[6] = qe ^ ~_e & Ce, D[7] = ze ^ ~Ze & $e, D[16] = lt ^ ~qt & at, D[17] = ct ^ ~Jt & ke, D[26] = mt ^ ~Nt & Et, D[27] = Rt ^ ~bt & er, D[36] = H ^ ~G & $t, D[37] = C ^ ~j & Ft, D[46] = je ^ ~it & se, D[47] = pt ^ ~et & de, D[8] = _e ^ ~Ce & Me, D[9] = Ze ^ ~$e & Ne, D[18] = qt ^ ~at & Qe, D[19] = Jt ^ ~ke & tt, D[28] = Nt ^ ~Et & Xt, D[29] = bt ^ ~er & Dt, D[38] = G ^ ~$t & rt, D[39] = j ^ ~Ft & Bt, D[48] = it ^ ~se & xe, D[49] = et ^ ~de & Te, D[0] ^= O[J], D[1] ^= O[J + 1];
    };
    if (a)
      t.exports = f;
    else
      for (b = 0; b < g.length; ++b)
        i[g[b]] = f[g[b]];
  })();
})(y8);
var rj = y8.exports;
const nj = /* @__PURE__ */ ns(rj), ij = "logger/5.7.0";
let Ix = !1, Cx = !1;
const $d = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let Tx = $d.default, hm = null;
function sj() {
  try {
    const t = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((e) => {
      try {
        if ("test".normalize(e) !== "test")
          throw new Error("bad normalize");
      } catch {
        t.push(e);
      }
    }), t.length)
      throw new Error("missing " + t.join(", "));
    if ("é".normalize("NFD") !== "é")
      throw new Error("broken implementation");
  } catch (t) {
    return t.message;
  }
  return null;
}
const Rx = sj();
var L1;
(function(t) {
  t.DEBUG = "DEBUG", t.INFO = "INFO", t.WARNING = "WARNING", t.ERROR = "ERROR", t.OFF = "OFF";
})(L1 || (L1 = {}));
var Es;
(function(t) {
  t.UNKNOWN_ERROR = "UNKNOWN_ERROR", t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", t.NETWORK_ERROR = "NETWORK_ERROR", t.SERVER_ERROR = "SERVER_ERROR", t.TIMEOUT = "TIMEOUT", t.BUFFER_OVERRUN = "BUFFER_OVERRUN", t.NUMERIC_FAULT = "NUMERIC_FAULT", t.MISSING_NEW = "MISSING_NEW", t.INVALID_ARGUMENT = "INVALID_ARGUMENT", t.MISSING_ARGUMENT = "MISSING_ARGUMENT", t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", t.CALL_EXCEPTION = "CALL_EXCEPTION", t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", t.NONCE_EXPIRED = "NONCE_EXPIRED", t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", t.ACTION_REJECTED = "ACTION_REJECTED";
})(Es || (Es = {}));
const Dx = "0123456789abcdef";
class Yr {
  constructor(e) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: e,
      writable: !1
    });
  }
  _log(e, r) {
    const n = e.toLowerCase();
    $d[n] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(Tx > $d[n]) && console.log.apply(console, r);
  }
  debug(...e) {
    this._log(Yr.levels.DEBUG, e);
  }
  info(...e) {
    this._log(Yr.levels.INFO, e);
  }
  warn(...e) {
    this._log(Yr.levels.WARNING, e);
  }
  makeError(e, r, n) {
    if (Cx)
      return this.makeError("censored error", r, {});
    r || (r = Yr.errors.UNKNOWN_ERROR), n || (n = {});
    const i = [];
    Object.keys(n).forEach((u) => {
      const l = n[u];
      try {
        if (l instanceof Uint8Array) {
          let d = "";
          for (let p = 0; p < l.length; p++)
            d += Dx[l[p] >> 4], d += Dx[l[p] & 15];
          i.push(u + "=Uint8Array(0x" + d + ")");
        } else
          i.push(u + "=" + JSON.stringify(l));
      } catch {
        i.push(u + "=" + JSON.stringify(n[u].toString()));
      }
    }), i.push(`code=${r}`), i.push(`version=${this.version}`);
    const s = e;
    let o = "";
    switch (r) {
      case Es.NUMERIC_FAULT: {
        o = "NUMERIC_FAULT";
        const u = e;
        switch (u) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            o += "-" + u;
            break;
          case "negative-power":
          case "negative-width":
            o += "-unsupported";
            break;
          case "unbound-bitwise-result":
            o += "-unbound-result";
            break;
        }
        break;
      }
      case Es.CALL_EXCEPTION:
      case Es.INSUFFICIENT_FUNDS:
      case Es.MISSING_NEW:
      case Es.NONCE_EXPIRED:
      case Es.REPLACEMENT_UNDERPRICED:
      case Es.TRANSACTION_REPLACED:
      case Es.UNPREDICTABLE_GAS_LIMIT:
        o = r;
        break;
    }
    o && (e += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), i.length && (e += " (" + i.join(", ") + ")");
    const a = new Error(e);
    return a.reason = s, a.code = r, Object.keys(n).forEach(function(u) {
      a[u] = n[u];
    }), a;
  }
  throwError(e, r, n) {
    throw this.makeError(e, r, n);
  }
  throwArgumentError(e, r, n) {
    return this.throwError(e, Yr.errors.INVALID_ARGUMENT, {
      argument: r,
      value: n
    });
  }
  assert(e, r, n, i) {
    e || this.throwError(r, n, i);
  }
  assertArgument(e, r, n, i) {
    e || this.throwArgumentError(r, n, i);
  }
  checkNormalize(e) {
    Rx && this.throwError("platform missing String.prototype.normalize", Yr.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: Rx
    });
  }
  checkSafeUint53(e, r) {
    typeof e == "number" && (r == null && (r = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(r, Yr.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: e
    }), e % 1 && this.throwError(r, Yr.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: e
    }));
  }
  checkArgumentCount(e, r, n) {
    n ? n = ": " + n : n = "", e < r && this.throwError("missing argument" + n, Yr.errors.MISSING_ARGUMENT, {
      count: e,
      expectedCount: r
    }), e > r && this.throwError("too many arguments" + n, Yr.errors.UNEXPECTED_ARGUMENT, {
      count: e,
      expectedCount: r
    });
  }
  checkNew(e, r) {
    (e === Object || e == null) && this.throwError("missing new", Yr.errors.MISSING_NEW, { name: r.name });
  }
  checkAbstract(e, r) {
    e === r ? this.throwError("cannot instantiate abstract class " + JSON.stringify(r.name) + " directly; use a sub-class", Yr.errors.UNSUPPORTED_OPERATION, { name: e.name, operation: "new" }) : (e === Object || e == null) && this.throwError("missing new", Yr.errors.MISSING_NEW, { name: r.name });
  }
  static globalLogger() {
    return hm || (hm = new Yr(ij)), hm;
  }
  static setCensorship(e, r) {
    if (!e && r && this.globalLogger().throwError("cannot permanently disable censorship", Yr.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), Ix) {
      if (!e)
        return;
      this.globalLogger().throwError("error censorship permanent", Yr.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    Cx = !!e, Ix = !!r;
  }
  static setLogLevel(e) {
    const r = $d[e.toLowerCase()];
    if (r == null) {
      Yr.globalLogger().warn("invalid log level - " + e);
      return;
    }
    Tx = r;
  }
  static from(e) {
    return new Yr(e);
  }
}
Yr.errors = Es;
Yr.levels = L1;
const oj = "bytes/5.7.0", hn = new Yr(oj);
function w8(t) {
  return !!t.toHexString;
}
function wu(t) {
  return t.slice || (t.slice = function() {
    const e = Array.prototype.slice.call(arguments);
    return wu(new Uint8Array(Array.prototype.slice.apply(t, e)));
  }), t;
}
function aj(t) {
  return Ks(t) && !(t.length % 2) || rb(t);
}
function Ox(t) {
  return typeof t == "number" && t == t && t % 1 === 0;
}
function rb(t) {
  if (t == null)
    return !1;
  if (t.constructor === Uint8Array)
    return !0;
  if (typeof t == "string" || !Ox(t.length) || t.length < 0)
    return !1;
  for (let e = 0; e < t.length; e++) {
    const r = t[e];
    if (!Ox(r) || r < 0 || r >= 256)
      return !1;
  }
  return !0;
}
function wn(t, e) {
  if (e || (e = {}), typeof t == "number") {
    hn.checkSafeUint53(t, "invalid arrayify value");
    const r = [];
    for (; t; )
      r.unshift(t & 255), t = parseInt(String(t / 256));
    return r.length === 0 && r.push(0), wu(new Uint8Array(r));
  }
  if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), w8(t) && (t = t.toHexString()), Ks(t)) {
    let r = t.substring(2);
    r.length % 2 && (e.hexPad === "left" ? r = "0" + r : e.hexPad === "right" ? r += "0" : hn.throwArgumentError("hex data is odd-length", "value", t));
    const n = [];
    for (let i = 0; i < r.length; i += 2)
      n.push(parseInt(r.substring(i, i + 2), 16));
    return wu(new Uint8Array(n));
  }
  return rb(t) ? wu(new Uint8Array(t)) : hn.throwArgumentError("invalid arrayify value", "value", t);
}
function cj(t) {
  const e = t.map((i) => wn(i)), r = e.reduce((i, s) => i + s.length, 0), n = new Uint8Array(r);
  return e.reduce((i, s) => (n.set(s, i), i + s.length), 0), wu(n);
}
function uj(t, e) {
  t = wn(t), t.length > e && hn.throwArgumentError("value out of range", "value", arguments[0]);
  const r = new Uint8Array(e);
  return r.set(t, e - t.length), wu(r);
}
function Ks(t, e) {
  return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e);
}
const dm = "0123456789abcdef";
function Di(t, e) {
  if (e || (e = {}), typeof t == "number") {
    hn.checkSafeUint53(t, "invalid hexlify value");
    let r = "";
    for (; t; )
      r = dm[t & 15] + r, t = Math.floor(t / 16);
    return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00";
  }
  if (typeof t == "bigint")
    return t = t.toString(16), t.length % 2 ? "0x0" + t : "0x" + t;
  if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), w8(t))
    return t.toHexString();
  if (Ks(t))
    return t.length % 2 && (e.hexPad === "left" ? t = "0x0" + t.substring(2) : e.hexPad === "right" ? t += "0" : hn.throwArgumentError("hex data is odd-length", "value", t)), t.toLowerCase();
  if (rb(t)) {
    let r = "0x";
    for (let n = 0; n < t.length; n++) {
      let i = t[n];
      r += dm[(i & 240) >> 4] + dm[i & 15];
    }
    return r;
  }
  return hn.throwArgumentError("invalid hexlify value", "value", t);
}
function fj(t) {
  if (typeof t != "string")
    t = Di(t);
  else if (!Ks(t) || t.length % 2)
    return null;
  return (t.length - 2) / 2;
}
function Nx(t, e, r) {
  return typeof t != "string" ? t = Di(t) : (!Ks(t) || t.length % 2) && hn.throwArgumentError("invalid hexData", "value", t), e = 2 + 2 * e, "0x" + t.substring(e);
}
function xu(t, e) {
  for (typeof t != "string" ? t = Di(t) : Ks(t) || hn.throwArgumentError("invalid hex string", "value", t), t.length > 2 * e + 2 && hn.throwArgumentError("value out of range", "value", arguments[1]); t.length < 2 * e + 2; )
    t = "0x0" + t.substring(2);
  return t;
}
function x8(t) {
  const e = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (aj(t)) {
    let r = wn(t);
    r.length === 64 ? (e.v = 27 + (r[32] >> 7), r[32] &= 127, e.r = Di(r.slice(0, 32)), e.s = Di(r.slice(32, 64))) : r.length === 65 ? (e.r = Di(r.slice(0, 32)), e.s = Di(r.slice(32, 64)), e.v = r[64]) : hn.throwArgumentError("invalid signature string", "signature", t), e.v < 27 && (e.v === 0 || e.v === 1 ? e.v += 27 : hn.throwArgumentError("signature invalid v byte", "signature", t)), e.recoveryParam = 1 - e.v % 2, e.recoveryParam && (r[32] |= 128), e._vs = Di(r.slice(32, 64));
  } else {
    if (e.r = t.r, e.s = t.s, e.v = t.v, e.recoveryParam = t.recoveryParam, e._vs = t._vs, e._vs != null) {
      const i = uj(wn(e._vs), 32);
      e._vs = Di(i);
      const s = i[0] >= 128 ? 1 : 0;
      e.recoveryParam == null ? e.recoveryParam = s : e.recoveryParam !== s && hn.throwArgumentError("signature recoveryParam mismatch _vs", "signature", t), i[0] &= 127;
      const o = Di(i);
      e.s == null ? e.s = o : e.s !== o && hn.throwArgumentError("signature v mismatch _vs", "signature", t);
    }
    if (e.recoveryParam == null)
      e.v == null ? hn.throwArgumentError("signature missing v and recoveryParam", "signature", t) : e.v === 0 || e.v === 1 ? e.recoveryParam = e.v : e.recoveryParam = 1 - e.v % 2;
    else if (e.v == null)
      e.v = 27 + e.recoveryParam;
    else {
      const i = e.v === 0 || e.v === 1 ? e.v : 1 - e.v % 2;
      e.recoveryParam !== i && hn.throwArgumentError("signature recoveryParam mismatch v", "signature", t);
    }
    e.r == null || !Ks(e.r) ? hn.throwArgumentError("signature missing or invalid r", "signature", t) : e.r = xu(e.r, 32), e.s == null || !Ks(e.s) ? hn.throwArgumentError("signature missing or invalid s", "signature", t) : e.s = xu(e.s, 32);
    const r = wn(e.s);
    r[0] >= 128 && hn.throwArgumentError("signature s out of range", "signature", t), e.recoveryParam && (r[0] |= 128);
    const n = Di(r);
    e._vs && (Ks(e._vs) || hn.throwArgumentError("signature invalid _vs", "signature", t), e._vs = xu(e._vs, 32)), e._vs == null ? e._vs = n : e._vs !== n && hn.throwArgumentError("signature _vs mismatch v and s", "signature", t);
  }
  return e.yParityAndS = e._vs, e.compact = e.r + e.yParityAndS.substring(2), e;
}
function nb(t) {
  return "0x" + nj.keccak_256(wn(t));
}
var ib = { exports: {} };
ib.exports;
(function(t) {
  (function(e, r) {
    function n(m, f) {
      if (!m) throw new Error(f || "Assertion failed");
    }
    function i(m, f) {
      m.super_ = f;
      var g = function() {
      };
      g.prototype = f.prototype, m.prototype = new g(), m.prototype.constructor = m;
    }
    function s(m, f, g) {
      if (s.isBN(m))
        return m;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, m !== null && ((f === "le" || f === "be") && (g = f, f = 10), this._init(m || 0, f || 10, g || "be"));
    }
    typeof e == "object" ? e.exports = s : r.BN = s, s.BN = s, s.wordSize = 26;
    var o;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = Ql.Buffer;
    } catch {
    }
    s.isBN = function(f) {
      return f instanceof s ? !0 : f !== null && typeof f == "object" && f.constructor.wordSize === s.wordSize && Array.isArray(f.words);
    }, s.max = function(f, g) {
      return f.cmp(g) > 0 ? f : g;
    }, s.min = function(f, g) {
      return f.cmp(g) < 0 ? f : g;
    }, s.prototype._init = function(f, g, b) {
      if (typeof f == "number")
        return this._initNumber(f, g, b);
      if (typeof f == "object")
        return this._initArray(f, g, b);
      g === "hex" && (g = 16), n(g === (g | 0) && g >= 2 && g <= 36), f = f.toString().replace(/\s+/g, "");
      var x = 0;
      f[0] === "-" && (x++, this.negative = 1), x < f.length && (g === 16 ? this._parseHex(f, x, b) : (this._parseBase(f, g, x), b === "le" && this._initArray(this.toArray(), g, b)));
    }, s.prototype._initNumber = function(f, g, b) {
      f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [f & 67108863], this.length = 1) : f < 4503599627370496 ? (this.words = [
        f & 67108863,
        f / 67108864 & 67108863
      ], this.length = 2) : (n(f < 9007199254740992), this.words = [
        f & 67108863,
        f / 67108864 & 67108863,
        1
      ], this.length = 3), b === "le" && this._initArray(this.toArray(), g, b);
    }, s.prototype._initArray = function(f, g, b) {
      if (n(typeof f.length == "number"), f.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        this.words[x] = 0;
      var E, S, v = 0;
      if (b === "be")
        for (x = f.length - 1, E = 0; x >= 0; x -= 3)
          S = f[x] | f[x - 1] << 8 | f[x - 2] << 16, this.words[E] |= S << v & 67108863, this.words[E + 1] = S >>> 26 - v & 67108863, v += 24, v >= 26 && (v -= 26, E++);
      else if (b === "le")
        for (x = 0, E = 0; x < f.length; x += 3)
          S = f[x] | f[x + 1] << 8 | f[x + 2] << 16, this.words[E] |= S << v & 67108863, this.words[E + 1] = S >>> 26 - v & 67108863, v += 24, v >= 26 && (v -= 26, E++);
      return this._strip();
    };
    function a(m, f) {
      var g = m.charCodeAt(f);
      if (g >= 48 && g <= 57)
        return g - 48;
      if (g >= 65 && g <= 70)
        return g - 55;
      if (g >= 97 && g <= 102)
        return g - 87;
      n(!1, "Invalid character in " + m);
    }
    function u(m, f, g) {
      var b = a(m, g);
      return g - 1 >= f && (b |= a(m, g - 1) << 4), b;
    }
    s.prototype._parseHex = function(f, g, b) {
      this.length = Math.ceil((f.length - g) / 6), this.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        this.words[x] = 0;
      var E = 0, S = 0, v;
      if (b === "be")
        for (x = f.length - 1; x >= g; x -= 2)
          v = u(f, g, x) << E, this.words[S] |= v & 67108863, E >= 18 ? (E -= 18, S += 1, this.words[S] |= v >>> 26) : E += 8;
      else {
        var M = f.length - g;
        for (x = M % 2 === 0 ? g + 1 : g; x < f.length; x += 2)
          v = u(f, g, x) << E, this.words[S] |= v & 67108863, E >= 18 ? (E -= 18, S += 1, this.words[S] |= v >>> 26) : E += 8;
      }
      this._strip();
    };
    function l(m, f, g, b) {
      for (var x = 0, E = 0, S = Math.min(m.length, g), v = f; v < S; v++) {
        var M = m.charCodeAt(v) - 48;
        x *= b, M >= 49 ? E = M - 49 + 10 : M >= 17 ? E = M - 17 + 10 : E = M, n(M >= 0 && E < b, "Invalid character"), x += E;
      }
      return x;
    }
    s.prototype._parseBase = function(f, g, b) {
      this.words = [0], this.length = 1;
      for (var x = 0, E = 1; E <= 67108863; E *= g)
        x++;
      x--, E = E / g | 0;
      for (var S = f.length - b, v = S % x, M = Math.min(S, S - v) + b, I = 0, F = b; F < M; F += x)
        I = l(f, F, F + x, g), this.imuln(E), this.words[0] + I < 67108864 ? this.words[0] += I : this._iaddn(I);
      if (v !== 0) {
        var ce = 1;
        for (I = l(f, F, f.length, g), F = 0; F < v; F++)
          ce *= g;
        this.imuln(ce), this.words[0] + I < 67108864 ? this.words[0] += I : this._iaddn(I);
      }
      this._strip();
    }, s.prototype.copy = function(f) {
      f.words = new Array(this.length);
      for (var g = 0; g < this.length; g++)
        f.words[g] = this.words[g];
      f.length = this.length, f.negative = this.negative, f.red = this.red;
    };
    function d(m, f) {
      m.words = f.words, m.length = f.length, m.negative = f.negative, m.red = f.red;
    }
    if (s.prototype._move = function(f) {
      d(f, this);
    }, s.prototype.clone = function() {
      var f = new s(null);
      return this.copy(f), f;
    }, s.prototype._expand = function(f) {
      for (; this.length < f; )
        this.words[this.length++] = 0;
      return this;
    }, s.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, s.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        s.prototype[Symbol.for("nodejs.util.inspect.custom")] = p;
      } catch {
        s.prototype.inspect = p;
      }
    else
      s.prototype.inspect = p;
    function p() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var w = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], _ = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], P = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    s.prototype.toString = function(f, g) {
      f = f || 10, g = g | 0 || 1;
      var b;
      if (f === 16 || f === "hex") {
        b = "";
        for (var x = 0, E = 0, S = 0; S < this.length; S++) {
          var v = this.words[S], M = ((v << x | E) & 16777215).toString(16);
          E = v >>> 24 - x & 16777215, x += 2, x >= 26 && (x -= 26, S--), E !== 0 || S !== this.length - 1 ? b = w[6 - M.length] + M + b : b = M + b;
        }
        for (E !== 0 && (b = E.toString(16) + b); b.length % g !== 0; )
          b = "0" + b;
        return this.negative !== 0 && (b = "-" + b), b;
      }
      if (f === (f | 0) && f >= 2 && f <= 36) {
        var I = _[f], F = P[f];
        b = "";
        var ce = this.clone();
        for (ce.negative = 0; !ce.isZero(); ) {
          var D = ce.modrn(F).toString(f);
          ce = ce.idivn(F), ce.isZero() ? b = D + b : b = w[I - D.length] + D + b;
        }
        for (this.isZero() && (b = "0" + b); b.length % g !== 0; )
          b = "0" + b;
        return this.negative !== 0 && (b = "-" + b), b;
      }
      n(!1, "Base should be between 2 and 36");
    }, s.prototype.toNumber = function() {
      var f = this.words[0];
      return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f : f;
    }, s.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, o && (s.prototype.toBuffer = function(f, g) {
      return this.toArrayLike(o, f, g);
    }), s.prototype.toArray = function(f, g) {
      return this.toArrayLike(Array, f, g);
    };
    var O = function(f, g) {
      return f.allocUnsafe ? f.allocUnsafe(g) : new f(g);
    };
    s.prototype.toArrayLike = function(f, g, b) {
      this._strip();
      var x = this.byteLength(), E = b || Math.max(1, x);
      n(x <= E, "byte array longer than desired length"), n(E > 0, "Requested array length <= 0");
      var S = O(f, E), v = g === "le" ? "LE" : "BE";
      return this["_toArrayLike" + v](S, x), S;
    }, s.prototype._toArrayLikeLE = function(f, g) {
      for (var b = 0, x = 0, E = 0, S = 0; E < this.length; E++) {
        var v = this.words[E] << S | x;
        f[b++] = v & 255, b < f.length && (f[b++] = v >> 8 & 255), b < f.length && (f[b++] = v >> 16 & 255), S === 6 ? (b < f.length && (f[b++] = v >> 24 & 255), x = 0, S = 0) : (x = v >>> 24, S += 2);
      }
      if (b < f.length)
        for (f[b++] = x; b < f.length; )
          f[b++] = 0;
    }, s.prototype._toArrayLikeBE = function(f, g) {
      for (var b = f.length - 1, x = 0, E = 0, S = 0; E < this.length; E++) {
        var v = this.words[E] << S | x;
        f[b--] = v & 255, b >= 0 && (f[b--] = v >> 8 & 255), b >= 0 && (f[b--] = v >> 16 & 255), S === 6 ? (b >= 0 && (f[b--] = v >> 24 & 255), x = 0, S = 0) : (x = v >>> 24, S += 2);
      }
      if (b >= 0)
        for (f[b--] = x; b >= 0; )
          f[b--] = 0;
    }, Math.clz32 ? s.prototype._countBits = function(f) {
      return 32 - Math.clz32(f);
    } : s.prototype._countBits = function(f) {
      var g = f, b = 0;
      return g >= 4096 && (b += 13, g >>>= 13), g >= 64 && (b += 7, g >>>= 7), g >= 8 && (b += 4, g >>>= 4), g >= 2 && (b += 2, g >>>= 2), b + g;
    }, s.prototype._zeroBits = function(f) {
      if (f === 0) return 26;
      var g = f, b = 0;
      return g & 8191 || (b += 13, g >>>= 13), g & 127 || (b += 7, g >>>= 7), g & 15 || (b += 4, g >>>= 4), g & 3 || (b += 2, g >>>= 2), g & 1 || b++, b;
    }, s.prototype.bitLength = function() {
      var f = this.words[this.length - 1], g = this._countBits(f);
      return (this.length - 1) * 26 + g;
    };
    function L(m) {
      for (var f = new Array(m.bitLength()), g = 0; g < f.length; g++) {
        var b = g / 26 | 0, x = g % 26;
        f[g] = m.words[b] >>> x & 1;
      }
      return f;
    }
    s.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var f = 0, g = 0; g < this.length; g++) {
        var b = this._zeroBits(this.words[g]);
        if (f += b, b !== 26) break;
      }
      return f;
    }, s.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, s.prototype.toTwos = function(f) {
      return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone();
    }, s.prototype.fromTwos = function(f) {
      return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone();
    }, s.prototype.isNeg = function() {
      return this.negative !== 0;
    }, s.prototype.neg = function() {
      return this.clone().ineg();
    }, s.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, s.prototype.iuor = function(f) {
      for (; this.length < f.length; )
        this.words[this.length++] = 0;
      for (var g = 0; g < f.length; g++)
        this.words[g] = this.words[g] | f.words[g];
      return this._strip();
    }, s.prototype.ior = function(f) {
      return n((this.negative | f.negative) === 0), this.iuor(f);
    }, s.prototype.or = function(f) {
      return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this);
    }, s.prototype.uor = function(f) {
      return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this);
    }, s.prototype.iuand = function(f) {
      var g;
      this.length > f.length ? g = f : g = this;
      for (var b = 0; b < g.length; b++)
        this.words[b] = this.words[b] & f.words[b];
      return this.length = g.length, this._strip();
    }, s.prototype.iand = function(f) {
      return n((this.negative | f.negative) === 0), this.iuand(f);
    }, s.prototype.and = function(f) {
      return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this);
    }, s.prototype.uand = function(f) {
      return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this);
    }, s.prototype.iuxor = function(f) {
      var g, b;
      this.length > f.length ? (g = this, b = f) : (g = f, b = this);
      for (var x = 0; x < b.length; x++)
        this.words[x] = g.words[x] ^ b.words[x];
      if (this !== g)
        for (; x < g.length; x++)
          this.words[x] = g.words[x];
      return this.length = g.length, this._strip();
    }, s.prototype.ixor = function(f) {
      return n((this.negative | f.negative) === 0), this.iuxor(f);
    }, s.prototype.xor = function(f) {
      return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this);
    }, s.prototype.uxor = function(f) {
      return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this);
    }, s.prototype.inotn = function(f) {
      n(typeof f == "number" && f >= 0);
      var g = Math.ceil(f / 26) | 0, b = f % 26;
      this._expand(g), b > 0 && g--;
      for (var x = 0; x < g; x++)
        this.words[x] = ~this.words[x] & 67108863;
      return b > 0 && (this.words[x] = ~this.words[x] & 67108863 >> 26 - b), this._strip();
    }, s.prototype.notn = function(f) {
      return this.clone().inotn(f);
    }, s.prototype.setn = function(f, g) {
      n(typeof f == "number" && f >= 0);
      var b = f / 26 | 0, x = f % 26;
      return this._expand(b + 1), g ? this.words[b] = this.words[b] | 1 << x : this.words[b] = this.words[b] & ~(1 << x), this._strip();
    }, s.prototype.iadd = function(f) {
      var g;
      if (this.negative !== 0 && f.negative === 0)
        return this.negative = 0, g = this.isub(f), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && f.negative !== 0)
        return f.negative = 0, g = this.isub(f), f.negative = 1, g._normSign();
      var b, x;
      this.length > f.length ? (b = this, x = f) : (b = f, x = this);
      for (var E = 0, S = 0; S < x.length; S++)
        g = (b.words[S] | 0) + (x.words[S] | 0) + E, this.words[S] = g & 67108863, E = g >>> 26;
      for (; E !== 0 && S < b.length; S++)
        g = (b.words[S] | 0) + E, this.words[S] = g & 67108863, E = g >>> 26;
      if (this.length = b.length, E !== 0)
        this.words[this.length] = E, this.length++;
      else if (b !== this)
        for (; S < b.length; S++)
          this.words[S] = b.words[S];
      return this;
    }, s.prototype.add = function(f) {
      var g;
      return f.negative !== 0 && this.negative === 0 ? (f.negative = 0, g = this.sub(f), f.negative ^= 1, g) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0, g = f.sub(this), this.negative = 1, g) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this);
    }, s.prototype.isub = function(f) {
      if (f.negative !== 0) {
        f.negative = 0;
        var g = this.iadd(f);
        return f.negative = 1, g._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
      var b = this.cmp(f);
      if (b === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var x, E;
      b > 0 ? (x = this, E = f) : (x = f, E = this);
      for (var S = 0, v = 0; v < E.length; v++)
        g = (x.words[v] | 0) - (E.words[v] | 0) + S, S = g >> 26, this.words[v] = g & 67108863;
      for (; S !== 0 && v < x.length; v++)
        g = (x.words[v] | 0) + S, S = g >> 26, this.words[v] = g & 67108863;
      if (S === 0 && v < x.length && x !== this)
        for (; v < x.length; v++)
          this.words[v] = x.words[v];
      return this.length = Math.max(this.length, v), x !== this && (this.negative = 1), this._strip();
    }, s.prototype.sub = function(f) {
      return this.clone().isub(f);
    };
    function B(m, f, g) {
      g.negative = f.negative ^ m.negative;
      var b = m.length + f.length | 0;
      g.length = b, b = b - 1 | 0;
      var x = m.words[0] | 0, E = f.words[0] | 0, S = x * E, v = S & 67108863, M = S / 67108864 | 0;
      g.words[0] = v;
      for (var I = 1; I < b; I++) {
        for (var F = M >>> 26, ce = M & 67108863, D = Math.min(I, f.length - 1), oe = Math.max(0, I - m.length + 1); oe <= D; oe++) {
          var Z = I - oe | 0;
          x = m.words[Z] | 0, E = f.words[oe] | 0, S = x * E + ce, F += S / 67108864 | 0, ce = S & 67108863;
        }
        g.words[I] = ce | 0, M = F | 0;
      }
      return M !== 0 ? g.words[I] = M | 0 : g.length--, g._strip();
    }
    var k = function(f, g, b) {
      var x = f.words, E = g.words, S = b.words, v = 0, M, I, F, ce = x[0] | 0, D = ce & 8191, oe = ce >>> 13, Z = x[1] | 0, J = Z & 8191, ee = Z >>> 13, T = x[2] | 0, X = T & 8191, re = T >>> 13, pe = x[3] | 0, ie = pe & 8191, ue = pe >>> 13, ve = x[4] | 0, Pe = ve & 8191, De = ve >>> 13, Ce = x[5] | 0, $e = Ce & 8191, Me = Ce >>> 13, Ne = x[6] | 0, Ke = Ne & 8191, Le = Ne >>> 13, qe = x[7] | 0, ze = qe & 8191, _e = qe >>> 13, Ze = x[8] | 0, at = Ze & 8191, ke = Ze >>> 13, Qe = x[9] | 0, tt = Qe & 8191, Ye = Qe >>> 13, dt = E[0] | 0, lt = dt & 8191, ct = dt >>> 13, qt = E[1] | 0, Jt = qt & 8191, Et = qt >>> 13, er = E[2] | 0, Xt = er & 8191, Dt = er >>> 13, kt = E[3] | 0, Ct = kt & 8191, mt = kt >>> 13, Rt = E[4] | 0, Nt = Rt & 8191, bt = Rt >>> 13, $t = E[5] | 0, Ft = $t & 8191, rt = $t >>> 13, Bt = E[6] | 0, $ = Bt & 8191, z = Bt >>> 13, H = E[7] | 0, C = H & 8191, G = H >>> 13, j = E[8] | 0, se = j & 8191, de = j >>> 13, xe = E[9] | 0, Te = xe & 8191, Re = xe >>> 13;
      b.negative = f.negative ^ g.negative, b.length = 19, M = Math.imul(D, lt), I = Math.imul(D, ct), I = I + Math.imul(oe, lt) | 0, F = Math.imul(oe, ct);
      var nt = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, M = Math.imul(J, lt), I = Math.imul(J, ct), I = I + Math.imul(ee, lt) | 0, F = Math.imul(ee, ct), M = M + Math.imul(D, Jt) | 0, I = I + Math.imul(D, Et) | 0, I = I + Math.imul(oe, Jt) | 0, F = F + Math.imul(oe, Et) | 0;
      var je = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, M = Math.imul(X, lt), I = Math.imul(X, ct), I = I + Math.imul(re, lt) | 0, F = Math.imul(re, ct), M = M + Math.imul(J, Jt) | 0, I = I + Math.imul(J, Et) | 0, I = I + Math.imul(ee, Jt) | 0, F = F + Math.imul(ee, Et) | 0, M = M + Math.imul(D, Xt) | 0, I = I + Math.imul(D, Dt) | 0, I = I + Math.imul(oe, Xt) | 0, F = F + Math.imul(oe, Dt) | 0;
      var pt = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, M = Math.imul(ie, lt), I = Math.imul(ie, ct), I = I + Math.imul(ue, lt) | 0, F = Math.imul(ue, ct), M = M + Math.imul(X, Jt) | 0, I = I + Math.imul(X, Et) | 0, I = I + Math.imul(re, Jt) | 0, F = F + Math.imul(re, Et) | 0, M = M + Math.imul(J, Xt) | 0, I = I + Math.imul(J, Dt) | 0, I = I + Math.imul(ee, Xt) | 0, F = F + Math.imul(ee, Dt) | 0, M = M + Math.imul(D, Ct) | 0, I = I + Math.imul(D, mt) | 0, I = I + Math.imul(oe, Ct) | 0, F = F + Math.imul(oe, mt) | 0;
      var it = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, M = Math.imul(Pe, lt), I = Math.imul(Pe, ct), I = I + Math.imul(De, lt) | 0, F = Math.imul(De, ct), M = M + Math.imul(ie, Jt) | 0, I = I + Math.imul(ie, Et) | 0, I = I + Math.imul(ue, Jt) | 0, F = F + Math.imul(ue, Et) | 0, M = M + Math.imul(X, Xt) | 0, I = I + Math.imul(X, Dt) | 0, I = I + Math.imul(re, Xt) | 0, F = F + Math.imul(re, Dt) | 0, M = M + Math.imul(J, Ct) | 0, I = I + Math.imul(J, mt) | 0, I = I + Math.imul(ee, Ct) | 0, F = F + Math.imul(ee, mt) | 0, M = M + Math.imul(D, Nt) | 0, I = I + Math.imul(D, bt) | 0, I = I + Math.imul(oe, Nt) | 0, F = F + Math.imul(oe, bt) | 0;
      var et = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, M = Math.imul($e, lt), I = Math.imul($e, ct), I = I + Math.imul(Me, lt) | 0, F = Math.imul(Me, ct), M = M + Math.imul(Pe, Jt) | 0, I = I + Math.imul(Pe, Et) | 0, I = I + Math.imul(De, Jt) | 0, F = F + Math.imul(De, Et) | 0, M = M + Math.imul(ie, Xt) | 0, I = I + Math.imul(ie, Dt) | 0, I = I + Math.imul(ue, Xt) | 0, F = F + Math.imul(ue, Dt) | 0, M = M + Math.imul(X, Ct) | 0, I = I + Math.imul(X, mt) | 0, I = I + Math.imul(re, Ct) | 0, F = F + Math.imul(re, mt) | 0, M = M + Math.imul(J, Nt) | 0, I = I + Math.imul(J, bt) | 0, I = I + Math.imul(ee, Nt) | 0, F = F + Math.imul(ee, bt) | 0, M = M + Math.imul(D, Ft) | 0, I = I + Math.imul(D, rt) | 0, I = I + Math.imul(oe, Ft) | 0, F = F + Math.imul(oe, rt) | 0;
      var St = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, M = Math.imul(Ke, lt), I = Math.imul(Ke, ct), I = I + Math.imul(Le, lt) | 0, F = Math.imul(Le, ct), M = M + Math.imul($e, Jt) | 0, I = I + Math.imul($e, Et) | 0, I = I + Math.imul(Me, Jt) | 0, F = F + Math.imul(Me, Et) | 0, M = M + Math.imul(Pe, Xt) | 0, I = I + Math.imul(Pe, Dt) | 0, I = I + Math.imul(De, Xt) | 0, F = F + Math.imul(De, Dt) | 0, M = M + Math.imul(ie, Ct) | 0, I = I + Math.imul(ie, mt) | 0, I = I + Math.imul(ue, Ct) | 0, F = F + Math.imul(ue, mt) | 0, M = M + Math.imul(X, Nt) | 0, I = I + Math.imul(X, bt) | 0, I = I + Math.imul(re, Nt) | 0, F = F + Math.imul(re, bt) | 0, M = M + Math.imul(J, Ft) | 0, I = I + Math.imul(J, rt) | 0, I = I + Math.imul(ee, Ft) | 0, F = F + Math.imul(ee, rt) | 0, M = M + Math.imul(D, $) | 0, I = I + Math.imul(D, z) | 0, I = I + Math.imul(oe, $) | 0, F = F + Math.imul(oe, z) | 0;
      var Tt = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, M = Math.imul(ze, lt), I = Math.imul(ze, ct), I = I + Math.imul(_e, lt) | 0, F = Math.imul(_e, ct), M = M + Math.imul(Ke, Jt) | 0, I = I + Math.imul(Ke, Et) | 0, I = I + Math.imul(Le, Jt) | 0, F = F + Math.imul(Le, Et) | 0, M = M + Math.imul($e, Xt) | 0, I = I + Math.imul($e, Dt) | 0, I = I + Math.imul(Me, Xt) | 0, F = F + Math.imul(Me, Dt) | 0, M = M + Math.imul(Pe, Ct) | 0, I = I + Math.imul(Pe, mt) | 0, I = I + Math.imul(De, Ct) | 0, F = F + Math.imul(De, mt) | 0, M = M + Math.imul(ie, Nt) | 0, I = I + Math.imul(ie, bt) | 0, I = I + Math.imul(ue, Nt) | 0, F = F + Math.imul(ue, bt) | 0, M = M + Math.imul(X, Ft) | 0, I = I + Math.imul(X, rt) | 0, I = I + Math.imul(re, Ft) | 0, F = F + Math.imul(re, rt) | 0, M = M + Math.imul(J, $) | 0, I = I + Math.imul(J, z) | 0, I = I + Math.imul(ee, $) | 0, F = F + Math.imul(ee, z) | 0, M = M + Math.imul(D, C) | 0, I = I + Math.imul(D, G) | 0, I = I + Math.imul(oe, C) | 0, F = F + Math.imul(oe, G) | 0;
      var At = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, M = Math.imul(at, lt), I = Math.imul(at, ct), I = I + Math.imul(ke, lt) | 0, F = Math.imul(ke, ct), M = M + Math.imul(ze, Jt) | 0, I = I + Math.imul(ze, Et) | 0, I = I + Math.imul(_e, Jt) | 0, F = F + Math.imul(_e, Et) | 0, M = M + Math.imul(Ke, Xt) | 0, I = I + Math.imul(Ke, Dt) | 0, I = I + Math.imul(Le, Xt) | 0, F = F + Math.imul(Le, Dt) | 0, M = M + Math.imul($e, Ct) | 0, I = I + Math.imul($e, mt) | 0, I = I + Math.imul(Me, Ct) | 0, F = F + Math.imul(Me, mt) | 0, M = M + Math.imul(Pe, Nt) | 0, I = I + Math.imul(Pe, bt) | 0, I = I + Math.imul(De, Nt) | 0, F = F + Math.imul(De, bt) | 0, M = M + Math.imul(ie, Ft) | 0, I = I + Math.imul(ie, rt) | 0, I = I + Math.imul(ue, Ft) | 0, F = F + Math.imul(ue, rt) | 0, M = M + Math.imul(X, $) | 0, I = I + Math.imul(X, z) | 0, I = I + Math.imul(re, $) | 0, F = F + Math.imul(re, z) | 0, M = M + Math.imul(J, C) | 0, I = I + Math.imul(J, G) | 0, I = I + Math.imul(ee, C) | 0, F = F + Math.imul(ee, G) | 0, M = M + Math.imul(D, se) | 0, I = I + Math.imul(D, de) | 0, I = I + Math.imul(oe, se) | 0, F = F + Math.imul(oe, de) | 0;
      var _t = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, M = Math.imul(tt, lt), I = Math.imul(tt, ct), I = I + Math.imul(Ye, lt) | 0, F = Math.imul(Ye, ct), M = M + Math.imul(at, Jt) | 0, I = I + Math.imul(at, Et) | 0, I = I + Math.imul(ke, Jt) | 0, F = F + Math.imul(ke, Et) | 0, M = M + Math.imul(ze, Xt) | 0, I = I + Math.imul(ze, Dt) | 0, I = I + Math.imul(_e, Xt) | 0, F = F + Math.imul(_e, Dt) | 0, M = M + Math.imul(Ke, Ct) | 0, I = I + Math.imul(Ke, mt) | 0, I = I + Math.imul(Le, Ct) | 0, F = F + Math.imul(Le, mt) | 0, M = M + Math.imul($e, Nt) | 0, I = I + Math.imul($e, bt) | 0, I = I + Math.imul(Me, Nt) | 0, F = F + Math.imul(Me, bt) | 0, M = M + Math.imul(Pe, Ft) | 0, I = I + Math.imul(Pe, rt) | 0, I = I + Math.imul(De, Ft) | 0, F = F + Math.imul(De, rt) | 0, M = M + Math.imul(ie, $) | 0, I = I + Math.imul(ie, z) | 0, I = I + Math.imul(ue, $) | 0, F = F + Math.imul(ue, z) | 0, M = M + Math.imul(X, C) | 0, I = I + Math.imul(X, G) | 0, I = I + Math.imul(re, C) | 0, F = F + Math.imul(re, G) | 0, M = M + Math.imul(J, se) | 0, I = I + Math.imul(J, de) | 0, I = I + Math.imul(ee, se) | 0, F = F + Math.imul(ee, de) | 0, M = M + Math.imul(D, Te) | 0, I = I + Math.imul(D, Re) | 0, I = I + Math.imul(oe, Te) | 0, F = F + Math.imul(oe, Re) | 0;
      var ht = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, M = Math.imul(tt, Jt), I = Math.imul(tt, Et), I = I + Math.imul(Ye, Jt) | 0, F = Math.imul(Ye, Et), M = M + Math.imul(at, Xt) | 0, I = I + Math.imul(at, Dt) | 0, I = I + Math.imul(ke, Xt) | 0, F = F + Math.imul(ke, Dt) | 0, M = M + Math.imul(ze, Ct) | 0, I = I + Math.imul(ze, mt) | 0, I = I + Math.imul(_e, Ct) | 0, F = F + Math.imul(_e, mt) | 0, M = M + Math.imul(Ke, Nt) | 0, I = I + Math.imul(Ke, bt) | 0, I = I + Math.imul(Le, Nt) | 0, F = F + Math.imul(Le, bt) | 0, M = M + Math.imul($e, Ft) | 0, I = I + Math.imul($e, rt) | 0, I = I + Math.imul(Me, Ft) | 0, F = F + Math.imul(Me, rt) | 0, M = M + Math.imul(Pe, $) | 0, I = I + Math.imul(Pe, z) | 0, I = I + Math.imul(De, $) | 0, F = F + Math.imul(De, z) | 0, M = M + Math.imul(ie, C) | 0, I = I + Math.imul(ie, G) | 0, I = I + Math.imul(ue, C) | 0, F = F + Math.imul(ue, G) | 0, M = M + Math.imul(X, se) | 0, I = I + Math.imul(X, de) | 0, I = I + Math.imul(re, se) | 0, F = F + Math.imul(re, de) | 0, M = M + Math.imul(J, Te) | 0, I = I + Math.imul(J, Re) | 0, I = I + Math.imul(ee, Te) | 0, F = F + Math.imul(ee, Re) | 0;
      var xt = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, M = Math.imul(tt, Xt), I = Math.imul(tt, Dt), I = I + Math.imul(Ye, Xt) | 0, F = Math.imul(Ye, Dt), M = M + Math.imul(at, Ct) | 0, I = I + Math.imul(at, mt) | 0, I = I + Math.imul(ke, Ct) | 0, F = F + Math.imul(ke, mt) | 0, M = M + Math.imul(ze, Nt) | 0, I = I + Math.imul(ze, bt) | 0, I = I + Math.imul(_e, Nt) | 0, F = F + Math.imul(_e, bt) | 0, M = M + Math.imul(Ke, Ft) | 0, I = I + Math.imul(Ke, rt) | 0, I = I + Math.imul(Le, Ft) | 0, F = F + Math.imul(Le, rt) | 0, M = M + Math.imul($e, $) | 0, I = I + Math.imul($e, z) | 0, I = I + Math.imul(Me, $) | 0, F = F + Math.imul(Me, z) | 0, M = M + Math.imul(Pe, C) | 0, I = I + Math.imul(Pe, G) | 0, I = I + Math.imul(De, C) | 0, F = F + Math.imul(De, G) | 0, M = M + Math.imul(ie, se) | 0, I = I + Math.imul(ie, de) | 0, I = I + Math.imul(ue, se) | 0, F = F + Math.imul(ue, de) | 0, M = M + Math.imul(X, Te) | 0, I = I + Math.imul(X, Re) | 0, I = I + Math.imul(re, Te) | 0, F = F + Math.imul(re, Re) | 0;
      var st = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, M = Math.imul(tt, Ct), I = Math.imul(tt, mt), I = I + Math.imul(Ye, Ct) | 0, F = Math.imul(Ye, mt), M = M + Math.imul(at, Nt) | 0, I = I + Math.imul(at, bt) | 0, I = I + Math.imul(ke, Nt) | 0, F = F + Math.imul(ke, bt) | 0, M = M + Math.imul(ze, Ft) | 0, I = I + Math.imul(ze, rt) | 0, I = I + Math.imul(_e, Ft) | 0, F = F + Math.imul(_e, rt) | 0, M = M + Math.imul(Ke, $) | 0, I = I + Math.imul(Ke, z) | 0, I = I + Math.imul(Le, $) | 0, F = F + Math.imul(Le, z) | 0, M = M + Math.imul($e, C) | 0, I = I + Math.imul($e, G) | 0, I = I + Math.imul(Me, C) | 0, F = F + Math.imul(Me, G) | 0, M = M + Math.imul(Pe, se) | 0, I = I + Math.imul(Pe, de) | 0, I = I + Math.imul(De, se) | 0, F = F + Math.imul(De, de) | 0, M = M + Math.imul(ie, Te) | 0, I = I + Math.imul(ie, Re) | 0, I = I + Math.imul(ue, Te) | 0, F = F + Math.imul(ue, Re) | 0;
      var yt = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, M = Math.imul(tt, Nt), I = Math.imul(tt, bt), I = I + Math.imul(Ye, Nt) | 0, F = Math.imul(Ye, bt), M = M + Math.imul(at, Ft) | 0, I = I + Math.imul(at, rt) | 0, I = I + Math.imul(ke, Ft) | 0, F = F + Math.imul(ke, rt) | 0, M = M + Math.imul(ze, $) | 0, I = I + Math.imul(ze, z) | 0, I = I + Math.imul(_e, $) | 0, F = F + Math.imul(_e, z) | 0, M = M + Math.imul(Ke, C) | 0, I = I + Math.imul(Ke, G) | 0, I = I + Math.imul(Le, C) | 0, F = F + Math.imul(Le, G) | 0, M = M + Math.imul($e, se) | 0, I = I + Math.imul($e, de) | 0, I = I + Math.imul(Me, se) | 0, F = F + Math.imul(Me, de) | 0, M = M + Math.imul(Pe, Te) | 0, I = I + Math.imul(Pe, Re) | 0, I = I + Math.imul(De, Te) | 0, F = F + Math.imul(De, Re) | 0;
      var ut = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, M = Math.imul(tt, Ft), I = Math.imul(tt, rt), I = I + Math.imul(Ye, Ft) | 0, F = Math.imul(Ye, rt), M = M + Math.imul(at, $) | 0, I = I + Math.imul(at, z) | 0, I = I + Math.imul(ke, $) | 0, F = F + Math.imul(ke, z) | 0, M = M + Math.imul(ze, C) | 0, I = I + Math.imul(ze, G) | 0, I = I + Math.imul(_e, C) | 0, F = F + Math.imul(_e, G) | 0, M = M + Math.imul(Ke, se) | 0, I = I + Math.imul(Ke, de) | 0, I = I + Math.imul(Le, se) | 0, F = F + Math.imul(Le, de) | 0, M = M + Math.imul($e, Te) | 0, I = I + Math.imul($e, Re) | 0, I = I + Math.imul(Me, Te) | 0, F = F + Math.imul(Me, Re) | 0;
      var ot = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, M = Math.imul(tt, $), I = Math.imul(tt, z), I = I + Math.imul(Ye, $) | 0, F = Math.imul(Ye, z), M = M + Math.imul(at, C) | 0, I = I + Math.imul(at, G) | 0, I = I + Math.imul(ke, C) | 0, F = F + Math.imul(ke, G) | 0, M = M + Math.imul(ze, se) | 0, I = I + Math.imul(ze, de) | 0, I = I + Math.imul(_e, se) | 0, F = F + Math.imul(_e, de) | 0, M = M + Math.imul(Ke, Te) | 0, I = I + Math.imul(Ke, Re) | 0, I = I + Math.imul(Le, Te) | 0, F = F + Math.imul(Le, Re) | 0;
      var Se = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, M = Math.imul(tt, C), I = Math.imul(tt, G), I = I + Math.imul(Ye, C) | 0, F = Math.imul(Ye, G), M = M + Math.imul(at, se) | 0, I = I + Math.imul(at, de) | 0, I = I + Math.imul(ke, se) | 0, F = F + Math.imul(ke, de) | 0, M = M + Math.imul(ze, Te) | 0, I = I + Math.imul(ze, Re) | 0, I = I + Math.imul(_e, Te) | 0, F = F + Math.imul(_e, Re) | 0;
      var Ae = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, M = Math.imul(tt, se), I = Math.imul(tt, de), I = I + Math.imul(Ye, se) | 0, F = Math.imul(Ye, de), M = M + Math.imul(at, Te) | 0, I = I + Math.imul(at, Re) | 0, I = I + Math.imul(ke, Te) | 0, F = F + Math.imul(ke, Re) | 0;
      var Ve = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, M = Math.imul(tt, Te), I = Math.imul(tt, Re), I = I + Math.imul(Ye, Te) | 0, F = Math.imul(Ye, Re);
      var Fe = (v + M | 0) + ((I & 8191) << 13) | 0;
      return v = (F + (I >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, S[0] = nt, S[1] = je, S[2] = pt, S[3] = it, S[4] = et, S[5] = St, S[6] = Tt, S[7] = At, S[8] = _t, S[9] = ht, S[10] = xt, S[11] = st, S[12] = yt, S[13] = ut, S[14] = ot, S[15] = Se, S[16] = Ae, S[17] = Ve, S[18] = Fe, v !== 0 && (S[19] = v, b.length++), b;
    };
    Math.imul || (k = B);
    function q(m, f, g) {
      g.negative = f.negative ^ m.negative, g.length = m.length + f.length;
      for (var b = 0, x = 0, E = 0; E < g.length - 1; E++) {
        var S = x;
        x = 0;
        for (var v = b & 67108863, M = Math.min(E, f.length - 1), I = Math.max(0, E - m.length + 1); I <= M; I++) {
          var F = E - I, ce = m.words[F] | 0, D = f.words[I] | 0, oe = ce * D, Z = oe & 67108863;
          S = S + (oe / 67108864 | 0) | 0, Z = Z + v | 0, v = Z & 67108863, S = S + (Z >>> 26) | 0, x += S >>> 26, S &= 67108863;
        }
        g.words[E] = v, b = S, S = x;
      }
      return b !== 0 ? g.words[E] = b : g.length--, g._strip();
    }
    function U(m, f, g) {
      return q(m, f, g);
    }
    s.prototype.mulTo = function(f, g) {
      var b, x = this.length + f.length;
      return this.length === 10 && f.length === 10 ? b = k(this, f, g) : x < 63 ? b = B(this, f, g) : x < 1024 ? b = q(this, f, g) : b = U(this, f, g), b;
    }, s.prototype.mul = function(f) {
      var g = new s(null);
      return g.words = new Array(this.length + f.length), this.mulTo(f, g);
    }, s.prototype.mulf = function(f) {
      var g = new s(null);
      return g.words = new Array(this.length + f.length), U(this, f, g);
    }, s.prototype.imul = function(f) {
      return this.clone().mulTo(f, this);
    }, s.prototype.imuln = function(f) {
      var g = f < 0;
      g && (f = -f), n(typeof f == "number"), n(f < 67108864);
      for (var b = 0, x = 0; x < this.length; x++) {
        var E = (this.words[x] | 0) * f, S = (E & 67108863) + (b & 67108863);
        b >>= 26, b += E / 67108864 | 0, b += S >>> 26, this.words[x] = S & 67108863;
      }
      return b !== 0 && (this.words[x] = b, this.length++), g ? this.ineg() : this;
    }, s.prototype.muln = function(f) {
      return this.clone().imuln(f);
    }, s.prototype.sqr = function() {
      return this.mul(this);
    }, s.prototype.isqr = function() {
      return this.imul(this.clone());
    }, s.prototype.pow = function(f) {
      var g = L(f);
      if (g.length === 0) return new s(1);
      for (var b = this, x = 0; x < g.length && g[x] === 0; x++, b = b.sqr())
        ;
      if (++x < g.length)
        for (var E = b.sqr(); x < g.length; x++, E = E.sqr())
          g[x] !== 0 && (b = b.mul(E));
      return b;
    }, s.prototype.iushln = function(f) {
      n(typeof f == "number" && f >= 0);
      var g = f % 26, b = (f - g) / 26, x = 67108863 >>> 26 - g << 26 - g, E;
      if (g !== 0) {
        var S = 0;
        for (E = 0; E < this.length; E++) {
          var v = this.words[E] & x, M = (this.words[E] | 0) - v << g;
          this.words[E] = M | S, S = v >>> 26 - g;
        }
        S && (this.words[E] = S, this.length++);
      }
      if (b !== 0) {
        for (E = this.length - 1; E >= 0; E--)
          this.words[E + b] = this.words[E];
        for (E = 0; E < b; E++)
          this.words[E] = 0;
        this.length += b;
      }
      return this._strip();
    }, s.prototype.ishln = function(f) {
      return n(this.negative === 0), this.iushln(f);
    }, s.prototype.iushrn = function(f, g, b) {
      n(typeof f == "number" && f >= 0);
      var x;
      g ? x = (g - g % 26) / 26 : x = 0;
      var E = f % 26, S = Math.min((f - E) / 26, this.length), v = 67108863 ^ 67108863 >>> E << E, M = b;
      if (x -= S, x = Math.max(0, x), M) {
        for (var I = 0; I < S; I++)
          M.words[I] = this.words[I];
        M.length = S;
      }
      if (S !== 0) if (this.length > S)
        for (this.length -= S, I = 0; I < this.length; I++)
          this.words[I] = this.words[I + S];
      else
        this.words[0] = 0, this.length = 1;
      var F = 0;
      for (I = this.length - 1; I >= 0 && (F !== 0 || I >= x); I--) {
        var ce = this.words[I] | 0;
        this.words[I] = F << 26 - E | ce >>> E, F = ce & v;
      }
      return M && F !== 0 && (M.words[M.length++] = F), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, s.prototype.ishrn = function(f, g, b) {
      return n(this.negative === 0), this.iushrn(f, g, b);
    }, s.prototype.shln = function(f) {
      return this.clone().ishln(f);
    }, s.prototype.ushln = function(f) {
      return this.clone().iushln(f);
    }, s.prototype.shrn = function(f) {
      return this.clone().ishrn(f);
    }, s.prototype.ushrn = function(f) {
      return this.clone().iushrn(f);
    }, s.prototype.testn = function(f) {
      n(typeof f == "number" && f >= 0);
      var g = f % 26, b = (f - g) / 26, x = 1 << g;
      if (this.length <= b) return !1;
      var E = this.words[b];
      return !!(E & x);
    }, s.prototype.imaskn = function(f) {
      n(typeof f == "number" && f >= 0);
      var g = f % 26, b = (f - g) / 26;
      if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= b)
        return this;
      if (g !== 0 && b++, this.length = Math.min(b, this.length), g !== 0) {
        var x = 67108863 ^ 67108863 >>> g << g;
        this.words[this.length - 1] &= x;
      }
      return this._strip();
    }, s.prototype.maskn = function(f) {
      return this.clone().imaskn(f);
    }, s.prototype.iaddn = function(f) {
      return n(typeof f == "number"), n(f < 67108864), f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f);
    }, s.prototype._iaddn = function(f) {
      this.words[0] += f;
      for (var g = 0; g < this.length && this.words[g] >= 67108864; g++)
        this.words[g] -= 67108864, g === this.length - 1 ? this.words[g + 1] = 1 : this.words[g + 1]++;
      return this.length = Math.max(this.length, g + 1), this;
    }, s.prototype.isubn = function(f) {
      if (n(typeof f == "number"), n(f < 67108864), f < 0) return this.iaddn(-f);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(f), this.negative = 1, this;
      if (this.words[0] -= f, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var g = 0; g < this.length && this.words[g] < 0; g++)
          this.words[g] += 67108864, this.words[g + 1] -= 1;
      return this._strip();
    }, s.prototype.addn = function(f) {
      return this.clone().iaddn(f);
    }, s.prototype.subn = function(f) {
      return this.clone().isubn(f);
    }, s.prototype.iabs = function() {
      return this.negative = 0, this;
    }, s.prototype.abs = function() {
      return this.clone().iabs();
    }, s.prototype._ishlnsubmul = function(f, g, b) {
      var x = f.length + b, E;
      this._expand(x);
      var S, v = 0;
      for (E = 0; E < f.length; E++) {
        S = (this.words[E + b] | 0) + v;
        var M = (f.words[E] | 0) * g;
        S -= M & 67108863, v = (S >> 26) - (M / 67108864 | 0), this.words[E + b] = S & 67108863;
      }
      for (; E < this.length - b; E++)
        S = (this.words[E + b] | 0) + v, v = S >> 26, this.words[E + b] = S & 67108863;
      if (v === 0) return this._strip();
      for (n(v === -1), v = 0, E = 0; E < this.length; E++)
        S = -(this.words[E] | 0) + v, v = S >> 26, this.words[E] = S & 67108863;
      return this.negative = 1, this._strip();
    }, s.prototype._wordDiv = function(f, g) {
      var b = this.length - f.length, x = this.clone(), E = f, S = E.words[E.length - 1] | 0, v = this._countBits(S);
      b = 26 - v, b !== 0 && (E = E.ushln(b), x.iushln(b), S = E.words[E.length - 1] | 0);
      var M = x.length - E.length, I;
      if (g !== "mod") {
        I = new s(null), I.length = M + 1, I.words = new Array(I.length);
        for (var F = 0; F < I.length; F++)
          I.words[F] = 0;
      }
      var ce = x.clone()._ishlnsubmul(E, 1, M);
      ce.negative === 0 && (x = ce, I && (I.words[M] = 1));
      for (var D = M - 1; D >= 0; D--) {
        var oe = (x.words[E.length + D] | 0) * 67108864 + (x.words[E.length + D - 1] | 0);
        for (oe = Math.min(oe / S | 0, 67108863), x._ishlnsubmul(E, oe, D); x.negative !== 0; )
          oe--, x.negative = 0, x._ishlnsubmul(E, 1, D), x.isZero() || (x.negative ^= 1);
        I && (I.words[D] = oe);
      }
      return I && I._strip(), x._strip(), g !== "div" && b !== 0 && x.iushrn(b), {
        div: I || null,
        mod: x
      };
    }, s.prototype.divmod = function(f, g, b) {
      if (n(!f.isZero()), this.isZero())
        return {
          div: new s(0),
          mod: new s(0)
        };
      var x, E, S;
      return this.negative !== 0 && f.negative === 0 ? (S = this.neg().divmod(f, g), g !== "mod" && (x = S.div.neg()), g !== "div" && (E = S.mod.neg(), b && E.negative !== 0 && E.iadd(f)), {
        div: x,
        mod: E
      }) : this.negative === 0 && f.negative !== 0 ? (S = this.divmod(f.neg(), g), g !== "mod" && (x = S.div.neg()), {
        div: x,
        mod: S.mod
      }) : this.negative & f.negative ? (S = this.neg().divmod(f.neg(), g), g !== "div" && (E = S.mod.neg(), b && E.negative !== 0 && E.isub(f)), {
        div: S.div,
        mod: E
      }) : f.length > this.length || this.cmp(f) < 0 ? {
        div: new s(0),
        mod: this
      } : f.length === 1 ? g === "div" ? {
        div: this.divn(f.words[0]),
        mod: null
      } : g === "mod" ? {
        div: null,
        mod: new s(this.modrn(f.words[0]))
      } : {
        div: this.divn(f.words[0]),
        mod: new s(this.modrn(f.words[0]))
      } : this._wordDiv(f, g);
    }, s.prototype.div = function(f) {
      return this.divmod(f, "div", !1).div;
    }, s.prototype.mod = function(f) {
      return this.divmod(f, "mod", !1).mod;
    }, s.prototype.umod = function(f) {
      return this.divmod(f, "mod", !0).mod;
    }, s.prototype.divRound = function(f) {
      var g = this.divmod(f);
      if (g.mod.isZero()) return g.div;
      var b = g.div.negative !== 0 ? g.mod.isub(f) : g.mod, x = f.ushrn(1), E = f.andln(1), S = b.cmp(x);
      return S < 0 || E === 1 && S === 0 ? g.div : g.div.negative !== 0 ? g.div.isubn(1) : g.div.iaddn(1);
    }, s.prototype.modrn = function(f) {
      var g = f < 0;
      g && (f = -f), n(f <= 67108863);
      for (var b = (1 << 26) % f, x = 0, E = this.length - 1; E >= 0; E--)
        x = (b * x + (this.words[E] | 0)) % f;
      return g ? -x : x;
    }, s.prototype.modn = function(f) {
      return this.modrn(f);
    }, s.prototype.idivn = function(f) {
      var g = f < 0;
      g && (f = -f), n(f <= 67108863);
      for (var b = 0, x = this.length - 1; x >= 0; x--) {
        var E = (this.words[x] | 0) + b * 67108864;
        this.words[x] = E / f | 0, b = E % f;
      }
      return this._strip(), g ? this.ineg() : this;
    }, s.prototype.divn = function(f) {
      return this.clone().idivn(f);
    }, s.prototype.egcd = function(f) {
      n(f.negative === 0), n(!f.isZero());
      var g = this, b = f.clone();
      g.negative !== 0 ? g = g.umod(f) : g = g.clone();
      for (var x = new s(1), E = new s(0), S = new s(0), v = new s(1), M = 0; g.isEven() && b.isEven(); )
        g.iushrn(1), b.iushrn(1), ++M;
      for (var I = b.clone(), F = g.clone(); !g.isZero(); ) {
        for (var ce = 0, D = 1; !(g.words[0] & D) && ce < 26; ++ce, D <<= 1) ;
        if (ce > 0)
          for (g.iushrn(ce); ce-- > 0; )
            (x.isOdd() || E.isOdd()) && (x.iadd(I), E.isub(F)), x.iushrn(1), E.iushrn(1);
        for (var oe = 0, Z = 1; !(b.words[0] & Z) && oe < 26; ++oe, Z <<= 1) ;
        if (oe > 0)
          for (b.iushrn(oe); oe-- > 0; )
            (S.isOdd() || v.isOdd()) && (S.iadd(I), v.isub(F)), S.iushrn(1), v.iushrn(1);
        g.cmp(b) >= 0 ? (g.isub(b), x.isub(S), E.isub(v)) : (b.isub(g), S.isub(x), v.isub(E));
      }
      return {
        a: S,
        b: v,
        gcd: b.iushln(M)
      };
    }, s.prototype._invmp = function(f) {
      n(f.negative === 0), n(!f.isZero());
      var g = this, b = f.clone();
      g.negative !== 0 ? g = g.umod(f) : g = g.clone();
      for (var x = new s(1), E = new s(0), S = b.clone(); g.cmpn(1) > 0 && b.cmpn(1) > 0; ) {
        for (var v = 0, M = 1; !(g.words[0] & M) && v < 26; ++v, M <<= 1) ;
        if (v > 0)
          for (g.iushrn(v); v-- > 0; )
            x.isOdd() && x.iadd(S), x.iushrn(1);
        for (var I = 0, F = 1; !(b.words[0] & F) && I < 26; ++I, F <<= 1) ;
        if (I > 0)
          for (b.iushrn(I); I-- > 0; )
            E.isOdd() && E.iadd(S), E.iushrn(1);
        g.cmp(b) >= 0 ? (g.isub(b), x.isub(E)) : (b.isub(g), E.isub(x));
      }
      var ce;
      return g.cmpn(1) === 0 ? ce = x : ce = E, ce.cmpn(0) < 0 && ce.iadd(f), ce;
    }, s.prototype.gcd = function(f) {
      if (this.isZero()) return f.abs();
      if (f.isZero()) return this.abs();
      var g = this.clone(), b = f.clone();
      g.negative = 0, b.negative = 0;
      for (var x = 0; g.isEven() && b.isEven(); x++)
        g.iushrn(1), b.iushrn(1);
      do {
        for (; g.isEven(); )
          g.iushrn(1);
        for (; b.isEven(); )
          b.iushrn(1);
        var E = g.cmp(b);
        if (E < 0) {
          var S = g;
          g = b, b = S;
        } else if (E === 0 || b.cmpn(1) === 0)
          break;
        g.isub(b);
      } while (!0);
      return b.iushln(x);
    }, s.prototype.invm = function(f) {
      return this.egcd(f).a.umod(f);
    }, s.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, s.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, s.prototype.andln = function(f) {
      return this.words[0] & f;
    }, s.prototype.bincn = function(f) {
      n(typeof f == "number");
      var g = f % 26, b = (f - g) / 26, x = 1 << g;
      if (this.length <= b)
        return this._expand(b + 1), this.words[b] |= x, this;
      for (var E = x, S = b; E !== 0 && S < this.length; S++) {
        var v = this.words[S] | 0;
        v += E, E = v >>> 26, v &= 67108863, this.words[S] = v;
      }
      return E !== 0 && (this.words[S] = E, this.length++), this;
    }, s.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, s.prototype.cmpn = function(f) {
      var g = f < 0;
      if (this.negative !== 0 && !g) return -1;
      if (this.negative === 0 && g) return 1;
      this._strip();
      var b;
      if (this.length > 1)
        b = 1;
      else {
        g && (f = -f), n(f <= 67108863, "Number is too big");
        var x = this.words[0] | 0;
        b = x === f ? 0 : x < f ? -1 : 1;
      }
      return this.negative !== 0 ? -b | 0 : b;
    }, s.prototype.cmp = function(f) {
      if (this.negative !== 0 && f.negative === 0) return -1;
      if (this.negative === 0 && f.negative !== 0) return 1;
      var g = this.ucmp(f);
      return this.negative !== 0 ? -g | 0 : g;
    }, s.prototype.ucmp = function(f) {
      if (this.length > f.length) return 1;
      if (this.length < f.length) return -1;
      for (var g = 0, b = this.length - 1; b >= 0; b--) {
        var x = this.words[b] | 0, E = f.words[b] | 0;
        if (x !== E) {
          x < E ? g = -1 : x > E && (g = 1);
          break;
        }
      }
      return g;
    }, s.prototype.gtn = function(f) {
      return this.cmpn(f) === 1;
    }, s.prototype.gt = function(f) {
      return this.cmp(f) === 1;
    }, s.prototype.gten = function(f) {
      return this.cmpn(f) >= 0;
    }, s.prototype.gte = function(f) {
      return this.cmp(f) >= 0;
    }, s.prototype.ltn = function(f) {
      return this.cmpn(f) === -1;
    }, s.prototype.lt = function(f) {
      return this.cmp(f) === -1;
    }, s.prototype.lten = function(f) {
      return this.cmpn(f) <= 0;
    }, s.prototype.lte = function(f) {
      return this.cmp(f) <= 0;
    }, s.prototype.eqn = function(f) {
      return this.cmpn(f) === 0;
    }, s.prototype.eq = function(f) {
      return this.cmp(f) === 0;
    }, s.red = function(f) {
      return new Y(f);
    }, s.prototype.toRed = function(f) {
      return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), f.convertTo(this)._forceRed(f);
    }, s.prototype.fromRed = function() {
      return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, s.prototype._forceRed = function(f) {
      return this.red = f, this;
    }, s.prototype.forceRed = function(f) {
      return n(!this.red, "Already a number in reduction context"), this._forceRed(f);
    }, s.prototype.redAdd = function(f) {
      return n(this.red, "redAdd works only with red numbers"), this.red.add(this, f);
    }, s.prototype.redIAdd = function(f) {
      return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f);
    }, s.prototype.redSub = function(f) {
      return n(this.red, "redSub works only with red numbers"), this.red.sub(this, f);
    }, s.prototype.redISub = function(f) {
      return n(this.red, "redISub works only with red numbers"), this.red.isub(this, f);
    }, s.prototype.redShl = function(f) {
      return n(this.red, "redShl works only with red numbers"), this.red.shl(this, f);
    }, s.prototype.redMul = function(f) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f);
    }, s.prototype.redIMul = function(f) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f);
    }, s.prototype.redSqr = function() {
      return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, s.prototype.redISqr = function() {
      return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, s.prototype.redSqrt = function() {
      return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, s.prototype.redInvm = function() {
      return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, s.prototype.redNeg = function() {
      return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, s.prototype.redPow = function(f) {
      return n(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f);
    };
    var V = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Q(m, f) {
      this.name = m, this.p = new s(f, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Q.prototype._tmp = function() {
      var f = new s(null);
      return f.words = new Array(Math.ceil(this.n / 13)), f;
    }, Q.prototype.ireduce = function(f) {
      var g = f, b;
      do
        this.split(g, this.tmp), g = this.imulK(g), g = g.iadd(this.tmp), b = g.bitLength();
      while (b > this.n);
      var x = b < this.n ? -1 : g.ucmp(this.p);
      return x === 0 ? (g.words[0] = 0, g.length = 1) : x > 0 ? g.isub(this.p) : g.strip !== void 0 ? g.strip() : g._strip(), g;
    }, Q.prototype.split = function(f, g) {
      f.iushrn(this.n, 0, g);
    }, Q.prototype.imulK = function(f) {
      return f.imul(this.k);
    };
    function R() {
      Q.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(R, Q), R.prototype.split = function(f, g) {
      for (var b = 4194303, x = Math.min(f.length, 9), E = 0; E < x; E++)
        g.words[E] = f.words[E];
      if (g.length = x, f.length <= 9) {
        f.words[0] = 0, f.length = 1;
        return;
      }
      var S = f.words[9];
      for (g.words[g.length++] = S & b, E = 10; E < f.length; E++) {
        var v = f.words[E] | 0;
        f.words[E - 10] = (v & b) << 4 | S >>> 22, S = v;
      }
      S >>>= 22, f.words[E - 10] = S, S === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9;
    }, R.prototype.imulK = function(f) {
      f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
      for (var g = 0, b = 0; b < f.length; b++) {
        var x = f.words[b] | 0;
        g += x * 977, f.words[b] = g & 67108863, g = x * 64 + (g / 67108864 | 0);
      }
      return f.words[f.length - 1] === 0 && (f.length--, f.words[f.length - 1] === 0 && f.length--), f;
    };
    function K() {
      Q.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(K, Q);
    function ge() {
      Q.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(ge, Q);
    function Ee() {
      Q.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(Ee, Q), Ee.prototype.imulK = function(f) {
      for (var g = 0, b = 0; b < f.length; b++) {
        var x = (f.words[b] | 0) * 19 + g, E = x & 67108863;
        x >>>= 26, f.words[b] = E, g = x;
      }
      return g !== 0 && (f.words[f.length++] = g), f;
    }, s._prime = function(f) {
      if (V[f]) return V[f];
      var g;
      if (f === "k256")
        g = new R();
      else if (f === "p224")
        g = new K();
      else if (f === "p192")
        g = new ge();
      else if (f === "p25519")
        g = new Ee();
      else
        throw new Error("Unknown prime " + f);
      return V[f] = g, g;
    };
    function Y(m) {
      if (typeof m == "string") {
        var f = s._prime(m);
        this.m = f.p, this.prime = f;
      } else
        n(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null;
    }
    Y.prototype._verify1 = function(f) {
      n(f.negative === 0, "red works only with positives"), n(f.red, "red works only with red numbers");
    }, Y.prototype._verify2 = function(f, g) {
      n((f.negative | g.negative) === 0, "red works only with positives"), n(
        f.red && f.red === g.red,
        "red works only with red numbers"
      );
    }, Y.prototype.imod = function(f) {
      return this.prime ? this.prime.ireduce(f)._forceRed(this) : (d(f, f.umod(this.m)._forceRed(this)), f);
    }, Y.prototype.neg = function(f) {
      return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this);
    }, Y.prototype.add = function(f, g) {
      this._verify2(f, g);
      var b = f.add(g);
      return b.cmp(this.m) >= 0 && b.isub(this.m), b._forceRed(this);
    }, Y.prototype.iadd = function(f, g) {
      this._verify2(f, g);
      var b = f.iadd(g);
      return b.cmp(this.m) >= 0 && b.isub(this.m), b;
    }, Y.prototype.sub = function(f, g) {
      this._verify2(f, g);
      var b = f.sub(g);
      return b.cmpn(0) < 0 && b.iadd(this.m), b._forceRed(this);
    }, Y.prototype.isub = function(f, g) {
      this._verify2(f, g);
      var b = f.isub(g);
      return b.cmpn(0) < 0 && b.iadd(this.m), b;
    }, Y.prototype.shl = function(f, g) {
      return this._verify1(f), this.imod(f.ushln(g));
    }, Y.prototype.imul = function(f, g) {
      return this._verify2(f, g), this.imod(f.imul(g));
    }, Y.prototype.mul = function(f, g) {
      return this._verify2(f, g), this.imod(f.mul(g));
    }, Y.prototype.isqr = function(f) {
      return this.imul(f, f.clone());
    }, Y.prototype.sqr = function(f) {
      return this.mul(f, f);
    }, Y.prototype.sqrt = function(f) {
      if (f.isZero()) return f.clone();
      var g = this.m.andln(3);
      if (n(g % 2 === 1), g === 3) {
        var b = this.m.add(new s(1)).iushrn(2);
        return this.pow(f, b);
      }
      for (var x = this.m.subn(1), E = 0; !x.isZero() && x.andln(1) === 0; )
        E++, x.iushrn(1);
      n(!x.isZero());
      var S = new s(1).toRed(this), v = S.redNeg(), M = this.m.subn(1).iushrn(1), I = this.m.bitLength();
      for (I = new s(2 * I * I).toRed(this); this.pow(I, M).cmp(v) !== 0; )
        I.redIAdd(v);
      for (var F = this.pow(I, x), ce = this.pow(f, x.addn(1).iushrn(1)), D = this.pow(f, x), oe = E; D.cmp(S) !== 0; ) {
        for (var Z = D, J = 0; Z.cmp(S) !== 0; J++)
          Z = Z.redSqr();
        n(J < oe);
        var ee = this.pow(F, new s(1).iushln(oe - J - 1));
        ce = ce.redMul(ee), F = ee.redSqr(), D = D.redMul(F), oe = J;
      }
      return ce;
    }, Y.prototype.invm = function(f) {
      var g = f._invmp(this.m);
      return g.negative !== 0 ? (g.negative = 0, this.imod(g).redNeg()) : this.imod(g);
    }, Y.prototype.pow = function(f, g) {
      if (g.isZero()) return new s(1).toRed(this);
      if (g.cmpn(1) === 0) return f.clone();
      var b = 4, x = new Array(1 << b);
      x[0] = new s(1).toRed(this), x[1] = f;
      for (var E = 2; E < x.length; E++)
        x[E] = this.mul(x[E - 1], f);
      var S = x[0], v = 0, M = 0, I = g.bitLength() % 26;
      for (I === 0 && (I = 26), E = g.length - 1; E >= 0; E--) {
        for (var F = g.words[E], ce = I - 1; ce >= 0; ce--) {
          var D = F >> ce & 1;
          if (S !== x[0] && (S = this.sqr(S)), D === 0 && v === 0) {
            M = 0;
            continue;
          }
          v <<= 1, v |= D, M++, !(M !== b && (E !== 0 || ce !== 0)) && (S = this.mul(S, x[v]), M = 0, v = 0);
        }
        I = 26;
      }
      return S;
    }, Y.prototype.convertTo = function(f) {
      var g = f.umod(this.m);
      return g === f ? g.clone() : g;
    }, Y.prototype.convertFrom = function(f) {
      var g = f.clone();
      return g.red = null, g;
    }, s.mont = function(f) {
      return new A(f);
    };
    function A(m) {
      Y.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(A, Y), A.prototype.convertTo = function(f) {
      return this.imod(f.ushln(this.shift));
    }, A.prototype.convertFrom = function(f) {
      var g = this.imod(f.mul(this.rinv));
      return g.red = null, g;
    }, A.prototype.imul = function(f, g) {
      if (f.isZero() || g.isZero())
        return f.words[0] = 0, f.length = 1, f;
      var b = f.imul(g), x = b.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), E = b.isub(x).iushrn(this.shift), S = E;
      return E.cmp(this.m) >= 0 ? S = E.isub(this.m) : E.cmpn(0) < 0 && (S = E.iadd(this.m)), S._forceRed(this);
    }, A.prototype.mul = function(f, g) {
      if (f.isZero() || g.isZero()) return new s(0)._forceRed(this);
      var b = f.mul(g), x = b.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), E = b.isub(x).iushrn(this.shift), S = E;
      return E.cmp(this.m) >= 0 ? S = E.isub(this.m) : E.cmpn(0) < 0 && (S = E.iadd(this.m)), S._forceRed(this);
    }, A.prototype.invm = function(f) {
      var g = this.imod(f._invmp(this.m).mul(this.r2));
      return g._forceRed(this);
    };
  })(t, gn);
})(ib);
var lj = ib.exports;
const sr = /* @__PURE__ */ ns(lj);
var hj = sr.BN;
function dj(t) {
  return new hj(t, 36).toString(16);
}
const pj = "strings/5.7.0", gj = new Yr(pj);
var p0;
(function(t) {
  t.current = "", t.NFC = "NFC", t.NFD = "NFD", t.NFKC = "NFKC", t.NFKD = "NFKD";
})(p0 || (p0 = {}));
var Lx;
(function(t) {
  t.UNEXPECTED_CONTINUE = "unexpected continuation byte", t.BAD_PREFIX = "bad codepoint prefix", t.OVERRUN = "string overrun", t.MISSING_CONTINUE = "missing continuation byte", t.OUT_OF_RANGE = "out of UTF-8 range", t.UTF16_SURROGATE = "UTF-16 surrogate", t.OVERLONG = "overlong representation";
})(Lx || (Lx = {}));
function pm(t, e = p0.current) {
  e != p0.current && (gj.checkNormalize(), t = t.normalize(e));
  let r = [];
  for (let n = 0; n < t.length; n++) {
    const i = t.charCodeAt(n);
    if (i < 128)
      r.push(i);
    else if (i < 2048)
      r.push(i >> 6 | 192), r.push(i & 63 | 128);
    else if ((i & 64512) == 55296) {
      n++;
      const s = t.charCodeAt(n);
      if (n >= t.length || (s & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const o = 65536 + ((i & 1023) << 10) + (s & 1023);
      r.push(o >> 18 | 240), r.push(o >> 12 & 63 | 128), r.push(o >> 6 & 63 | 128), r.push(o & 63 | 128);
    } else
      r.push(i >> 12 | 224), r.push(i >> 6 & 63 | 128), r.push(i & 63 | 128);
  }
  return wn(r);
}
const mj = `Ethereum Signed Message:
`;
function _8(t) {
  return typeof t == "string" && (t = pm(t)), nb(cj([
    pm(mj),
    pm(String(t.length)),
    t
  ]));
}
const vj = "address/5.7.0", Wf = new Yr(vj);
function kx(t) {
  Ks(t, 20) || Wf.throwArgumentError("invalid address", "address", t), t = t.toLowerCase();
  const e = t.substring(2).split(""), r = new Uint8Array(40);
  for (let i = 0; i < 40; i++)
    r[i] = e[i].charCodeAt(0);
  const n = wn(nb(r));
  for (let i = 0; i < 40; i += 2)
    n[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (n[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
  return "0x" + e.join("");
}
const bj = 9007199254740991;
function yj(t) {
  return Math.log10 ? Math.log10(t) : Math.log(t) / Math.LN10;
}
const sb = {};
for (let t = 0; t < 10; t++)
  sb[String(t)] = String(t);
for (let t = 0; t < 26; t++)
  sb[String.fromCharCode(65 + t)] = String(10 + t);
const $x = Math.floor(yj(bj));
function wj(t) {
  t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
  let e = t.split("").map((n) => sb[n]).join("");
  for (; e.length >= $x; ) {
    let n = e.substring(0, $x);
    e = parseInt(n, 10) % 97 + e.substring(n.length);
  }
  let r = String(98 - parseInt(e, 10) % 97);
  for (; r.length < 2; )
    r = "0" + r;
  return r;
}
function xj(t) {
  let e = null;
  if (typeof t != "string" && Wf.throwArgumentError("invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/))
    t.substring(0, 2) !== "0x" && (t = "0x" + t), e = kx(t), t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== t && Wf.throwArgumentError("bad address checksum", "address", t);
  else if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (t.substring(2, 4) !== wj(t) && Wf.throwArgumentError("bad icap checksum", "address", t), e = dj(t.substring(4)); e.length < 40; )
      e = "0" + e;
    e = kx("0x" + e);
  } else
    Wf.throwArgumentError("invalid address", "address", t);
  return e;
}
function Cf(t, e, r) {
  Object.defineProperty(t, e, {
    enumerable: !0,
    value: r,
    writable: !1
  });
}
var rh = {}, _r = {}, Tc = E8;
function E8(t, e) {
  if (!t)
    throw new Error(e || "Assertion failed");
}
E8.equal = function(e, r, n) {
  if (e != r)
    throw new Error(n || "Assertion failed: " + e + " != " + r);
};
var k1 = { exports: {} };
typeof Object.create == "function" ? k1.exports = function(e, r) {
  r && (e.super_ = r, e.prototype = Object.create(r.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : k1.exports = function(e, r) {
  if (r) {
    e.super_ = r;
    var n = function() {
    };
    n.prototype = r.prototype, e.prototype = new n(), e.prototype.constructor = e;
  }
};
var np = k1.exports, _j = Tc, Ej = np;
_r.inherits = Ej;
function Sj(t, e) {
  return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? !1 : (t.charCodeAt(e + 1) & 64512) === 56320;
}
function Aj(t, e) {
  if (Array.isArray(t))
    return t.slice();
  if (!t)
    return [];
  var r = [];
  if (typeof t == "string")
    if (e) {
      if (e === "hex")
        for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), i = 0; i < t.length; i += 2)
          r.push(parseInt(t[i] + t[i + 1], 16));
    } else for (var n = 0, i = 0; i < t.length; i++) {
      var s = t.charCodeAt(i);
      s < 128 ? r[n++] = s : s < 2048 ? (r[n++] = s >> 6 | 192, r[n++] = s & 63 | 128) : Sj(t, i) ? (s = 65536 + ((s & 1023) << 10) + (t.charCodeAt(++i) & 1023), r[n++] = s >> 18 | 240, r[n++] = s >> 12 & 63 | 128, r[n++] = s >> 6 & 63 | 128, r[n++] = s & 63 | 128) : (r[n++] = s >> 12 | 224, r[n++] = s >> 6 & 63 | 128, r[n++] = s & 63 | 128);
    }
  else
    for (i = 0; i < t.length; i++)
      r[i] = t[i] | 0;
  return r;
}
_r.toArray = Aj;
function Pj(t) {
  for (var e = "", r = 0; r < t.length; r++)
    e += A8(t[r].toString(16));
  return e;
}
_r.toHex = Pj;
function S8(t) {
  var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
  return e >>> 0;
}
_r.htonl = S8;
function Mj(t, e) {
  for (var r = "", n = 0; n < t.length; n++) {
    var i = t[n];
    e === "little" && (i = S8(i)), r += P8(i.toString(16));
  }
  return r;
}
_r.toHex32 = Mj;
function A8(t) {
  return t.length === 1 ? "0" + t : t;
}
_r.zero2 = A8;
function P8(t) {
  return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
}
_r.zero8 = P8;
function Ij(t, e, r, n) {
  var i = r - e;
  _j(i % 4 === 0);
  for (var s = new Array(i / 4), o = 0, a = e; o < s.length; o++, a += 4) {
    var u;
    n === "big" ? u = t[a] << 24 | t[a + 1] << 16 | t[a + 2] << 8 | t[a + 3] : u = t[a + 3] << 24 | t[a + 2] << 16 | t[a + 1] << 8 | t[a], s[o] = u >>> 0;
  }
  return s;
}
_r.join32 = Ij;
function Cj(t, e) {
  for (var r = new Array(t.length * 4), n = 0, i = 0; n < t.length; n++, i += 4) {
    var s = t[n];
    e === "big" ? (r[i] = s >>> 24, r[i + 1] = s >>> 16 & 255, r[i + 2] = s >>> 8 & 255, r[i + 3] = s & 255) : (r[i + 3] = s >>> 24, r[i + 2] = s >>> 16 & 255, r[i + 1] = s >>> 8 & 255, r[i] = s & 255);
  }
  return r;
}
_r.split32 = Cj;
function Tj(t, e) {
  return t >>> e | t << 32 - e;
}
_r.rotr32 = Tj;
function Rj(t, e) {
  return t << e | t >>> 32 - e;
}
_r.rotl32 = Rj;
function Dj(t, e) {
  return t + e >>> 0;
}
_r.sum32 = Dj;
function Oj(t, e, r) {
  return t + e + r >>> 0;
}
_r.sum32_3 = Oj;
function Nj(t, e, r, n) {
  return t + e + r + n >>> 0;
}
_r.sum32_4 = Nj;
function Lj(t, e, r, n, i) {
  return t + e + r + n + i >>> 0;
}
_r.sum32_5 = Lj;
function kj(t, e, r, n) {
  var i = t[e], s = t[e + 1], o = n + s >>> 0, a = (o < n ? 1 : 0) + r + i;
  t[e] = a >>> 0, t[e + 1] = o;
}
_r.sum64 = kj;
function $j(t, e, r, n) {
  var i = e + n >>> 0, s = (i < e ? 1 : 0) + t + r;
  return s >>> 0;
}
_r.sum64_hi = $j;
function Bj(t, e, r, n) {
  var i = e + n;
  return i >>> 0;
}
_r.sum64_lo = Bj;
function Fj(t, e, r, n, i, s, o, a) {
  var u = 0, l = e;
  l = l + n >>> 0, u += l < e ? 1 : 0, l = l + s >>> 0, u += l < s ? 1 : 0, l = l + a >>> 0, u += l < a ? 1 : 0;
  var d = t + r + i + o + u;
  return d >>> 0;
}
_r.sum64_4_hi = Fj;
function jj(t, e, r, n, i, s, o, a) {
  var u = e + n + s + a;
  return u >>> 0;
}
_r.sum64_4_lo = jj;
function Uj(t, e, r, n, i, s, o, a, u, l) {
  var d = 0, p = e;
  p = p + n >>> 0, d += p < e ? 1 : 0, p = p + s >>> 0, d += p < s ? 1 : 0, p = p + a >>> 0, d += p < a ? 1 : 0, p = p + l >>> 0, d += p < l ? 1 : 0;
  var w = t + r + i + o + u + d;
  return w >>> 0;
}
_r.sum64_5_hi = Uj;
function qj(t, e, r, n, i, s, o, a, u, l) {
  var d = e + n + s + a + l;
  return d >>> 0;
}
_r.sum64_5_lo = qj;
function zj(t, e, r) {
  var n = e << 32 - r | t >>> r;
  return n >>> 0;
}
_r.rotr64_hi = zj;
function Wj(t, e, r) {
  var n = t << 32 - r | e >>> r;
  return n >>> 0;
}
_r.rotr64_lo = Wj;
function Hj(t, e, r) {
  return t >>> r;
}
_r.shr64_hi = Hj;
function Kj(t, e, r) {
  var n = t << 32 - r | e >>> r;
  return n >>> 0;
}
_r.shr64_lo = Kj;
var qu = {}, Bx = _r, Vj = Tc;
function ip() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
qu.BlockHash = ip;
ip.prototype.update = function(e, r) {
  if (e = Bx.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
    e = this.pending;
    var n = e.length % this._delta8;
    this.pending = e.slice(e.length - n, e.length), this.pending.length === 0 && (this.pending = null), e = Bx.join32(e, 0, e.length - n, this.endian);
    for (var i = 0; i < e.length; i += this._delta32)
      this._update(e, i, i + this._delta32);
  }
  return this;
};
ip.prototype.digest = function(e) {
  return this.update(this._pad()), Vj(this.pending === null), this._digest(e);
};
ip.prototype._pad = function() {
  var e = this.pendingTotal, r = this._delta8, n = r - (e + this.padLength) % r, i = new Array(n + this.padLength);
  i[0] = 128;
  for (var s = 1; s < n; s++)
    i[s] = 0;
  if (e <<= 3, this.endian === "big") {
    for (var o = 8; o < this.padLength; o++)
      i[s++] = 0;
    i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = e >>> 24 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 8 & 255, i[s++] = e & 255;
  } else
    for (i[s++] = e & 255, i[s++] = e >>> 8 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 24 & 255, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, o = 8; o < this.padLength; o++)
      i[s++] = 0;
  return i;
};
var zu = {}, so = {}, Gj = _r, Vs = Gj.rotr32;
function Yj(t, e, r, n) {
  if (t === 0)
    return M8(e, r, n);
  if (t === 1 || t === 3)
    return C8(e, r, n);
  if (t === 2)
    return I8(e, r, n);
}
so.ft_1 = Yj;
function M8(t, e, r) {
  return t & e ^ ~t & r;
}
so.ch32 = M8;
function I8(t, e, r) {
  return t & e ^ t & r ^ e & r;
}
so.maj32 = I8;
function C8(t, e, r) {
  return t ^ e ^ r;
}
so.p32 = C8;
function Jj(t) {
  return Vs(t, 2) ^ Vs(t, 13) ^ Vs(t, 22);
}
so.s0_256 = Jj;
function Xj(t) {
  return Vs(t, 6) ^ Vs(t, 11) ^ Vs(t, 25);
}
so.s1_256 = Xj;
function Zj(t) {
  return Vs(t, 7) ^ Vs(t, 18) ^ t >>> 3;
}
so.g0_256 = Zj;
function Qj(t) {
  return Vs(t, 17) ^ Vs(t, 19) ^ t >>> 10;
}
so.g1_256 = Qj;
var Ru = _r, eU = qu, tU = so, gm = Ru.rotl32, Tf = Ru.sum32, rU = Ru.sum32_5, nU = tU.ft_1, T8 = eU.BlockHash, iU = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function Qs() {
  if (!(this instanceof Qs))
    return new Qs();
  T8.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
Ru.inherits(Qs, T8);
var sU = Qs;
Qs.blockSize = 512;
Qs.outSize = 160;
Qs.hmacStrength = 80;
Qs.padLength = 64;
Qs.prototype._update = function(e, r) {
  for (var n = this.W, i = 0; i < 16; i++)
    n[i] = e[r + i];
  for (; i < n.length; i++)
    n[i] = gm(n[i - 3] ^ n[i - 8] ^ n[i - 14] ^ n[i - 16], 1);
  var s = this.h[0], o = this.h[1], a = this.h[2], u = this.h[3], l = this.h[4];
  for (i = 0; i < n.length; i++) {
    var d = ~~(i / 20), p = rU(gm(s, 5), nU(d, o, a, u), l, n[i], iU[d]);
    l = u, u = a, a = gm(o, 30), o = s, s = p;
  }
  this.h[0] = Tf(this.h[0], s), this.h[1] = Tf(this.h[1], o), this.h[2] = Tf(this.h[2], a), this.h[3] = Tf(this.h[3], u), this.h[4] = Tf(this.h[4], l);
};
Qs.prototype._digest = function(e) {
  return e === "hex" ? Ru.toHex32(this.h, "big") : Ru.split32(this.h, "big");
};
var Du = _r, oU = qu, Wu = so, aU = Tc, bs = Du.sum32, cU = Du.sum32_4, uU = Du.sum32_5, fU = Wu.ch32, lU = Wu.maj32, hU = Wu.s0_256, dU = Wu.s1_256, pU = Wu.g0_256, gU = Wu.g1_256, R8 = oU.BlockHash, mU = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function eo() {
  if (!(this instanceof eo))
    return new eo();
  R8.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = mU, this.W = new Array(64);
}
Du.inherits(eo, R8);
var D8 = eo;
eo.blockSize = 512;
eo.outSize = 256;
eo.hmacStrength = 192;
eo.padLength = 64;
eo.prototype._update = function(e, r) {
  for (var n = this.W, i = 0; i < 16; i++)
    n[i] = e[r + i];
  for (; i < n.length; i++)
    n[i] = cU(gU(n[i - 2]), n[i - 7], pU(n[i - 15]), n[i - 16]);
  var s = this.h[0], o = this.h[1], a = this.h[2], u = this.h[3], l = this.h[4], d = this.h[5], p = this.h[6], w = this.h[7];
  for (aU(this.k.length === n.length), i = 0; i < n.length; i++) {
    var _ = uU(w, dU(l), fU(l, d, p), this.k[i], n[i]), P = bs(hU(s), lU(s, o, a));
    w = p, p = d, d = l, l = bs(u, _), u = a, a = o, o = s, s = bs(_, P);
  }
  this.h[0] = bs(this.h[0], s), this.h[1] = bs(this.h[1], o), this.h[2] = bs(this.h[2], a), this.h[3] = bs(this.h[3], u), this.h[4] = bs(this.h[4], l), this.h[5] = bs(this.h[5], d), this.h[6] = bs(this.h[6], p), this.h[7] = bs(this.h[7], w);
};
eo.prototype._digest = function(e) {
  return e === "hex" ? Du.toHex32(this.h, "big") : Du.split32(this.h, "big");
};
var $1 = _r, O8 = D8;
function qo() {
  if (!(this instanceof qo))
    return new qo();
  O8.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
$1.inherits(qo, O8);
var vU = qo;
qo.blockSize = 512;
qo.outSize = 224;
qo.hmacStrength = 192;
qo.padLength = 64;
qo.prototype._digest = function(e) {
  return e === "hex" ? $1.toHex32(this.h.slice(0, 7), "big") : $1.split32(this.h.slice(0, 7), "big");
};
var Ei = _r, bU = qu, yU = Tc, Gs = Ei.rotr64_hi, Ys = Ei.rotr64_lo, N8 = Ei.shr64_hi, L8 = Ei.shr64_lo, na = Ei.sum64, mm = Ei.sum64_hi, vm = Ei.sum64_lo, wU = Ei.sum64_4_hi, xU = Ei.sum64_4_lo, _U = Ei.sum64_5_hi, EU = Ei.sum64_5_lo, k8 = bU.BlockHash, SU = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function Is() {
  if (!(this instanceof Is))
    return new Is();
  k8.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = SU, this.W = new Array(160);
}
Ei.inherits(Is, k8);
var $8 = Is;
Is.blockSize = 1024;
Is.outSize = 512;
Is.hmacStrength = 192;
Is.padLength = 128;
Is.prototype._prepareBlock = function(e, r) {
  for (var n = this.W, i = 0; i < 32; i++)
    n[i] = e[r + i];
  for (; i < n.length; i += 2) {
    var s = LU(n[i - 4], n[i - 3]), o = kU(n[i - 4], n[i - 3]), a = n[i - 14], u = n[i - 13], l = OU(n[i - 30], n[i - 29]), d = NU(n[i - 30], n[i - 29]), p = n[i - 32], w = n[i - 31];
    n[i] = wU(
      s,
      o,
      a,
      u,
      l,
      d,
      p,
      w
    ), n[i + 1] = xU(
      s,
      o,
      a,
      u,
      l,
      d,
      p,
      w
    );
  }
};
Is.prototype._update = function(e, r) {
  this._prepareBlock(e, r);
  var n = this.W, i = this.h[0], s = this.h[1], o = this.h[2], a = this.h[3], u = this.h[4], l = this.h[5], d = this.h[6], p = this.h[7], w = this.h[8], _ = this.h[9], P = this.h[10], O = this.h[11], L = this.h[12], B = this.h[13], k = this.h[14], q = this.h[15];
  yU(this.k.length === n.length);
  for (var U = 0; U < n.length; U += 2) {
    var V = k, Q = q, R = RU(w, _), K = DU(w, _), ge = AU(w, _, P, O, L), Ee = PU(w, _, P, O, L, B), Y = this.k[U], A = this.k[U + 1], m = n[U], f = n[U + 1], g = _U(
      V,
      Q,
      R,
      K,
      ge,
      Ee,
      Y,
      A,
      m,
      f
    ), b = EU(
      V,
      Q,
      R,
      K,
      ge,
      Ee,
      Y,
      A,
      m,
      f
    );
    V = CU(i, s), Q = TU(i, s), R = MU(i, s, o, a, u), K = IU(i, s, o, a, u, l);
    var x = mm(V, Q, R, K), E = vm(V, Q, R, K);
    k = L, q = B, L = P, B = O, P = w, O = _, w = mm(d, p, g, b), _ = vm(p, p, g, b), d = u, p = l, u = o, l = a, o = i, a = s, i = mm(g, b, x, E), s = vm(g, b, x, E);
  }
  na(this.h, 0, i, s), na(this.h, 2, o, a), na(this.h, 4, u, l), na(this.h, 6, d, p), na(this.h, 8, w, _), na(this.h, 10, P, O), na(this.h, 12, L, B), na(this.h, 14, k, q);
};
Is.prototype._digest = function(e) {
  return e === "hex" ? Ei.toHex32(this.h, "big") : Ei.split32(this.h, "big");
};
function AU(t, e, r, n, i) {
  var s = t & r ^ ~t & i;
  return s < 0 && (s += 4294967296), s;
}
function PU(t, e, r, n, i, s) {
  var o = e & n ^ ~e & s;
  return o < 0 && (o += 4294967296), o;
}
function MU(t, e, r, n, i) {
  var s = t & r ^ t & i ^ r & i;
  return s < 0 && (s += 4294967296), s;
}
function IU(t, e, r, n, i, s) {
  var o = e & n ^ e & s ^ n & s;
  return o < 0 && (o += 4294967296), o;
}
function CU(t, e) {
  var r = Gs(t, e, 28), n = Gs(e, t, 2), i = Gs(e, t, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function TU(t, e) {
  var r = Ys(t, e, 28), n = Ys(e, t, 2), i = Ys(e, t, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function RU(t, e) {
  var r = Gs(t, e, 14), n = Gs(t, e, 18), i = Gs(e, t, 9), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function DU(t, e) {
  var r = Ys(t, e, 14), n = Ys(t, e, 18), i = Ys(e, t, 9), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function OU(t, e) {
  var r = Gs(t, e, 1), n = Gs(t, e, 8), i = N8(t, e, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function NU(t, e) {
  var r = Ys(t, e, 1), n = Ys(t, e, 8), i = L8(t, e, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function LU(t, e) {
  var r = Gs(t, e, 19), n = Gs(e, t, 29), i = N8(t, e, 6), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function kU(t, e) {
  var r = Ys(t, e, 19), n = Ys(e, t, 29), i = L8(t, e, 6), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
var B1 = _r, B8 = $8;
function zo() {
  if (!(this instanceof zo))
    return new zo();
  B8.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
B1.inherits(zo, B8);
var $U = zo;
zo.blockSize = 1024;
zo.outSize = 384;
zo.hmacStrength = 192;
zo.padLength = 128;
zo.prototype._digest = function(e) {
  return e === "hex" ? B1.toHex32(this.h.slice(0, 12), "big") : B1.split32(this.h.slice(0, 12), "big");
};
zu.sha1 = sU;
zu.sha224 = vU;
zu.sha256 = D8;
zu.sha384 = $U;
zu.sha512 = $8;
var F8 = {}, yc = _r, BU = qu, wd = yc.rotl32, Fx = yc.sum32, Rf = yc.sum32_3, jx = yc.sum32_4, j8 = BU.BlockHash;
function to() {
  if (!(this instanceof to))
    return new to();
  j8.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
yc.inherits(to, j8);
F8.ripemd160 = to;
to.blockSize = 512;
to.outSize = 160;
to.hmacStrength = 192;
to.padLength = 64;
to.prototype._update = function(e, r) {
  for (var n = this.h[0], i = this.h[1], s = this.h[2], o = this.h[3], a = this.h[4], u = n, l = i, d = s, p = o, w = a, _ = 0; _ < 80; _++) {
    var P = Fx(
      wd(
        jx(n, Ux(_, i, s, o), e[UU[_] + r], FU(_)),
        zU[_]
      ),
      a
    );
    n = a, a = o, o = wd(s, 10), s = i, i = P, P = Fx(
      wd(
        jx(u, Ux(79 - _, l, d, p), e[qU[_] + r], jU(_)),
        WU[_]
      ),
      w
    ), u = w, w = p, p = wd(d, 10), d = l, l = P;
  }
  P = Rf(this.h[1], s, p), this.h[1] = Rf(this.h[2], o, w), this.h[2] = Rf(this.h[3], a, u), this.h[3] = Rf(this.h[4], n, l), this.h[4] = Rf(this.h[0], i, d), this.h[0] = P;
};
to.prototype._digest = function(e) {
  return e === "hex" ? yc.toHex32(this.h, "little") : yc.split32(this.h, "little");
};
function Ux(t, e, r, n) {
  return t <= 15 ? e ^ r ^ n : t <= 31 ? e & r | ~e & n : t <= 47 ? (e | ~r) ^ n : t <= 63 ? e & n | r & ~n : e ^ (r | ~n);
}
function FU(t) {
  return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
}
function jU(t) {
  return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
}
var UU = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], qU = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], zU = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], WU = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], HU = _r, KU = Tc;
function Ou(t, e, r) {
  if (!(this instanceof Ou))
    return new Ou(t, e, r);
  this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(HU.toArray(e, r));
}
var VU = Ou;
Ou.prototype._init = function(e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), KU(e.length <= this.blockSize);
  for (var r = e.length; r < this.blockSize; r++)
    e.push(0);
  for (r = 0; r < e.length; r++)
    e[r] ^= 54;
  for (this.inner = new this.Hash().update(e), r = 0; r < e.length; r++)
    e[r] ^= 106;
  this.outer = new this.Hash().update(e);
};
Ou.prototype.update = function(e, r) {
  return this.inner.update(e, r), this;
};
Ou.prototype.digest = function(e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function(t) {
  var e = t;
  e.utils = _r, e.common = qu, e.sha = zu, e.ripemd = F8, e.hmac = VU, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160;
})(rh);
const Eo = /* @__PURE__ */ ns(rh);
function Hu(t, e, r) {
  return r = {
    path: e,
    exports: {},
    require: function(n, i) {
      return GU(n, i ?? r.path);
    }
  }, t(r, r.exports), r.exports;
}
function GU() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var ob = U8;
function U8(t, e) {
  if (!t)
    throw new Error(e || "Assertion failed");
}
U8.equal = function(e, r, n) {
  if (e != r)
    throw new Error(n || "Assertion failed: " + e + " != " + r);
};
var Ss = Hu(function(t, e) {
  var r = e;
  function n(o, a) {
    if (Array.isArray(o))
      return o.slice();
    if (!o)
      return [];
    var u = [];
    if (typeof o != "string") {
      for (var l = 0; l < o.length; l++)
        u[l] = o[l] | 0;
      return u;
    }
    if (a === "hex") {
      o = o.replace(/[^a-z0-9]+/ig, ""), o.length % 2 !== 0 && (o = "0" + o);
      for (var l = 0; l < o.length; l += 2)
        u.push(parseInt(o[l] + o[l + 1], 16));
    } else
      for (var l = 0; l < o.length; l++) {
        var d = o.charCodeAt(l), p = d >> 8, w = d & 255;
        p ? u.push(p, w) : u.push(w);
      }
    return u;
  }
  r.toArray = n;
  function i(o) {
    return o.length === 1 ? "0" + o : o;
  }
  r.zero2 = i;
  function s(o) {
    for (var a = "", u = 0; u < o.length; u++)
      a += i(o[u].toString(16));
    return a;
  }
  r.toHex = s, r.encode = function(a, u) {
    return u === "hex" ? s(a) : a;
  };
}), Fi = Hu(function(t, e) {
  var r = e;
  r.assert = ob, r.toArray = Ss.toArray, r.zero2 = Ss.zero2, r.toHex = Ss.toHex, r.encode = Ss.encode;
  function n(u, l, d) {
    var p = new Array(Math.max(u.bitLength(), d) + 1);
    p.fill(0);
    for (var w = 1 << l + 1, _ = u.clone(), P = 0; P < p.length; P++) {
      var O, L = _.andln(w - 1);
      _.isOdd() ? (L > (w >> 1) - 1 ? O = (w >> 1) - L : O = L, _.isubn(O)) : O = 0, p[P] = O, _.iushrn(1);
    }
    return p;
  }
  r.getNAF = n;
  function i(u, l) {
    var d = [
      [],
      []
    ];
    u = u.clone(), l = l.clone();
    for (var p = 0, w = 0, _; u.cmpn(-p) > 0 || l.cmpn(-w) > 0; ) {
      var P = u.andln(3) + p & 3, O = l.andln(3) + w & 3;
      P === 3 && (P = -1), O === 3 && (O = -1);
      var L;
      P & 1 ? (_ = u.andln(7) + p & 7, (_ === 3 || _ === 5) && O === 2 ? L = -P : L = P) : L = 0, d[0].push(L);
      var B;
      O & 1 ? (_ = l.andln(7) + w & 7, (_ === 3 || _ === 5) && P === 2 ? B = -O : B = O) : B = 0, d[1].push(B), 2 * p === L + 1 && (p = 1 - p), 2 * w === B + 1 && (w = 1 - w), u.iushrn(1), l.iushrn(1);
    }
    return d;
  }
  r.getJSF = i;
  function s(u, l, d) {
    var p = "_" + l;
    u.prototype[l] = function() {
      return this[p] !== void 0 ? this[p] : this[p] = d.call(this);
    };
  }
  r.cachedProperty = s;
  function o(u) {
    return typeof u == "string" ? r.toArray(u, "hex") : u;
  }
  r.parseBytes = o;
  function a(u) {
    return new sr(u, "hex", "le");
  }
  r.intFromLE = a;
}), g0 = Fi.getNAF, YU = Fi.getJSF, m0 = Fi.assert;
function Oa(t, e) {
  this.type = t, this.p = new sr(e.p, 16), this.red = e.prime ? sr.red(e.prime) : sr.mont(this.p), this.zero = new sr(0).toRed(this.red), this.one = new sr(1).toRed(this.red), this.two = new sr(2).toRed(this.red), this.n = e.n && new sr(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var r = this.n && this.p.div(this.n);
  !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var Rc = Oa;
Oa.prototype.point = function() {
  throw new Error("Not implemented");
};
Oa.prototype.validate = function() {
  throw new Error("Not implemented");
};
Oa.prototype._fixedNafMul = function(e, r) {
  m0(e.precomputed);
  var n = e._getDoubles(), i = g0(r, 1, this._bitLength), s = (1 << n.step + 1) - (n.step % 2 === 0 ? 2 : 1);
  s /= 3;
  var o = [], a, u;
  for (a = 0; a < i.length; a += n.step) {
    u = 0;
    for (var l = a + n.step - 1; l >= a; l--)
      u = (u << 1) + i[l];
    o.push(u);
  }
  for (var d = this.jpoint(null, null, null), p = this.jpoint(null, null, null), w = s; w > 0; w--) {
    for (a = 0; a < o.length; a++)
      u = o[a], u === w ? p = p.mixedAdd(n.points[a]) : u === -w && (p = p.mixedAdd(n.points[a].neg()));
    d = d.add(p);
  }
  return d.toP();
};
Oa.prototype._wnafMul = function(e, r) {
  var n = 4, i = e._getNAFPoints(n);
  n = i.wnd;
  for (var s = i.points, o = g0(r, n, this._bitLength), a = this.jpoint(null, null, null), u = o.length - 1; u >= 0; u--) {
    for (var l = 0; u >= 0 && o[u] === 0; u--)
      l++;
    if (u >= 0 && l++, a = a.dblp(l), u < 0)
      break;
    var d = o[u];
    m0(d !== 0), e.type === "affine" ? d > 0 ? a = a.mixedAdd(s[d - 1 >> 1]) : a = a.mixedAdd(s[-d - 1 >> 1].neg()) : d > 0 ? a = a.add(s[d - 1 >> 1]) : a = a.add(s[-d - 1 >> 1].neg());
  }
  return e.type === "affine" ? a.toP() : a;
};
Oa.prototype._wnafMulAdd = function(e, r, n, i, s) {
  var o = this._wnafT1, a = this._wnafT2, u = this._wnafT3, l = 0, d, p, w;
  for (d = 0; d < i; d++) {
    w = r[d];
    var _ = w._getNAFPoints(e);
    o[d] = _.wnd, a[d] = _.points;
  }
  for (d = i - 1; d >= 1; d -= 2) {
    var P = d - 1, O = d;
    if (o[P] !== 1 || o[O] !== 1) {
      u[P] = g0(n[P], o[P], this._bitLength), u[O] = g0(n[O], o[O], this._bitLength), l = Math.max(u[P].length, l), l = Math.max(u[O].length, l);
      continue;
    }
    var L = [
      r[P],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      r[O]
      /* 7 */
    ];
    r[P].y.cmp(r[O].y) === 0 ? (L[1] = r[P].add(r[O]), L[2] = r[P].toJ().mixedAdd(r[O].neg())) : r[P].y.cmp(r[O].y.redNeg()) === 0 ? (L[1] = r[P].toJ().mixedAdd(r[O]), L[2] = r[P].add(r[O].neg())) : (L[1] = r[P].toJ().mixedAdd(r[O]), L[2] = r[P].toJ().mixedAdd(r[O].neg()));
    var B = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], k = YU(n[P], n[O]);
    for (l = Math.max(k[0].length, l), u[P] = new Array(l), u[O] = new Array(l), p = 0; p < l; p++) {
      var q = k[0][p] | 0, U = k[1][p] | 0;
      u[P][p] = B[(q + 1) * 3 + (U + 1)], u[O][p] = 0, a[P] = L;
    }
  }
  var V = this.jpoint(null, null, null), Q = this._wnafT4;
  for (d = l; d >= 0; d--) {
    for (var R = 0; d >= 0; ) {
      var K = !0;
      for (p = 0; p < i; p++)
        Q[p] = u[p][d] | 0, Q[p] !== 0 && (K = !1);
      if (!K)
        break;
      R++, d--;
    }
    if (d >= 0 && R++, V = V.dblp(R), d < 0)
      break;
    for (p = 0; p < i; p++) {
      var ge = Q[p];
      ge !== 0 && (ge > 0 ? w = a[p][ge - 1 >> 1] : ge < 0 && (w = a[p][-ge - 1 >> 1].neg()), w.type === "affine" ? V = V.mixedAdd(w) : V = V.add(w));
    }
  }
  for (d = 0; d < i; d++)
    a[d] = null;
  return s ? V : V.toP();
};
function ss(t, e) {
  this.curve = t, this.type = e, this.precomputed = null;
}
Oa.BasePoint = ss;
ss.prototype.eq = function() {
  throw new Error("Not implemented");
};
ss.prototype.validate = function() {
  return this.curve.validate(this);
};
Oa.prototype.decodePoint = function(e, r) {
  e = Fi.toArray(e, r);
  var n = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * n) {
    e[0] === 6 ? m0(e[e.length - 1] % 2 === 0) : e[0] === 7 && m0(e[e.length - 1] % 2 === 1);
    var i = this.point(
      e.slice(1, 1 + n),
      e.slice(1 + n, 1 + 2 * n)
    );
    return i;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n)
    return this.pointFromX(e.slice(1, 1 + n), e[0] === 3);
  throw new Error("Unknown point format");
};
ss.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
ss.prototype._encode = function(e) {
  var r = this.curve.p.byteLength(), n = this.getX().toArray("be", r);
  return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", r));
};
ss.prototype.encode = function(e, r) {
  return Fi.encode(this._encode(r), e);
};
ss.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var r = {
    doubles: null,
    naf: null,
    beta: null
  };
  return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
};
ss.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var r = this.precomputed.doubles;
  return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : !1;
};
ss.prototype._getDoubles = function(e, r) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var n = [this], i = this, s = 0; s < r; s += e) {
    for (var o = 0; o < e; o++)
      i = i.dbl();
    n.push(i);
  }
  return {
    step: e,
    points: n
  };
};
ss.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var r = [this], n = (1 << e) - 1, i = n === 1 ? null : this.dbl(), s = 1; s < n; s++)
    r[s] = r[s - 1].add(i);
  return {
    wnd: e,
    points: r
  };
};
ss.prototype._getBeta = function() {
  return null;
};
ss.prototype.dblp = function(e) {
  for (var r = this, n = 0; n < e; n++)
    r = r.dbl();
  return r;
};
var ab = Hu(function(t) {
  typeof Object.create == "function" ? t.exports = function(r, n) {
    n && (r.super_ = n, r.prototype = Object.create(n.prototype, {
      constructor: {
        value: r,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : t.exports = function(r, n) {
    if (n) {
      r.super_ = n;
      var i = function() {
      };
      i.prototype = n.prototype, r.prototype = new i(), r.prototype.constructor = r;
    }
  };
}), JU = Fi.assert;
function os(t) {
  Rc.call(this, "short", t), this.a = new sr(t.a, 16).toRed(this.red), this.b = new sr(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
ab(os, Rc);
var XU = os;
os.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var r, n;
    if (e.beta)
      r = new sr(e.beta, 16).toRed(this.red);
    else {
      var i = this._getEndoRoots(this.p);
      r = i[0].cmp(i[1]) < 0 ? i[0] : i[1], r = r.toRed(this.red);
    }
    if (e.lambda)
      n = new sr(e.lambda, 16);
    else {
      var s = this._getEndoRoots(this.n);
      this.g.mul(s[0]).x.cmp(this.g.x.redMul(r)) === 0 ? n = s[0] : (n = s[1], JU(this.g.mul(n).x.cmp(this.g.x.redMul(r)) === 0));
    }
    var o;
    return e.basis ? o = e.basis.map(function(a) {
      return {
        a: new sr(a.a, 16),
        b: new sr(a.b, 16)
      };
    }) : o = this._getEndoBasis(n), {
      beta: r,
      lambda: n,
      basis: o
    };
  }
};
os.prototype._getEndoRoots = function(e) {
  var r = e === this.p ? this.red : sr.mont(e), n = new sr(2).toRed(r).redInvm(), i = n.redNeg(), s = new sr(3).toRed(r).redNeg().redSqrt().redMul(n), o = i.redAdd(s).fromRed(), a = i.redSub(s).fromRed();
  return [o, a];
};
os.prototype._getEndoBasis = function(e) {
  for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), n = e, i = this.n.clone(), s = new sr(1), o = new sr(0), a = new sr(0), u = new sr(1), l, d, p, w, _, P, O, L = 0, B, k; n.cmpn(0) !== 0; ) {
    var q = i.div(n);
    B = i.sub(q.mul(n)), k = a.sub(q.mul(s));
    var U = u.sub(q.mul(o));
    if (!p && B.cmp(r) < 0)
      l = O.neg(), d = s, p = B.neg(), w = k;
    else if (p && ++L === 2)
      break;
    O = B, i = n, n = B, a = s, s = k, u = o, o = U;
  }
  _ = B.neg(), P = k;
  var V = p.sqr().add(w.sqr()), Q = _.sqr().add(P.sqr());
  return Q.cmp(V) >= 0 && (_ = l, P = d), p.negative && (p = p.neg(), w = w.neg()), _.negative && (_ = _.neg(), P = P.neg()), [
    { a: p, b: w },
    { a: _, b: P }
  ];
};
os.prototype._endoSplit = function(e) {
  var r = this.endo.basis, n = r[0], i = r[1], s = i.b.mul(e).divRound(this.n), o = n.b.neg().mul(e).divRound(this.n), a = s.mul(n.a), u = o.mul(i.a), l = s.mul(n.b), d = o.mul(i.b), p = e.sub(a).sub(u), w = l.add(d).neg();
  return { k1: p, k2: w };
};
os.prototype.pointFromX = function(e, r) {
  e = new sr(e, 16), e.red || (e = e.toRed(this.red));
  var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), i = n.redSqrt();
  if (i.redSqr().redSub(n).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var s = i.fromRed().isOdd();
  return (r && !s || !r && s) && (i = i.redNeg()), this.point(e, i);
};
os.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var r = e.x, n = e.y, i = this.a.redMul(r), s = r.redSqr().redMul(r).redIAdd(i).redIAdd(this.b);
  return n.redSqr().redISub(s).cmpn(0) === 0;
};
os.prototype._endoWnafMulAdd = function(e, r, n) {
  for (var i = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < e.length; o++) {
    var a = this._endoSplit(r[o]), u = e[o], l = u._getBeta();
    a.k1.negative && (a.k1.ineg(), u = u.neg(!0)), a.k2.negative && (a.k2.ineg(), l = l.neg(!0)), i[o * 2] = u, i[o * 2 + 1] = l, s[o * 2] = a.k1, s[o * 2 + 1] = a.k2;
  }
  for (var d = this._wnafMulAdd(1, i, s, o * 2, n), p = 0; p < o * 2; p++)
    i[p] = null, s[p] = null;
  return d;
};
function kn(t, e, r, n) {
  Rc.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new sr(e, 16), this.y = new sr(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
ab(kn, Rc.BasePoint);
os.prototype.point = function(e, r, n) {
  return new kn(this, e, r, n);
};
os.prototype.pointFromJSON = function(e, r) {
  return kn.fromJSON(this, e, r);
};
kn.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var n = this.curve, i = function(s) {
        return n.point(s.x.redMul(n.endo.beta), s.y);
      };
      e.beta = r, r.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(i)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(i)
        }
      };
    }
    return r;
  }
};
kn.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
kn.fromJSON = function(e, r, n) {
  typeof r == "string" && (r = JSON.parse(r));
  var i = e.point(r[0], r[1], n);
  if (!r[2])
    return i;
  function s(a) {
    return e.point(a[0], a[1], n);
  }
  var o = r[2];
  return i.precomputed = {
    beta: null,
    doubles: o.doubles && {
      step: o.doubles.step,
      points: [i].concat(o.doubles.points.map(s))
    },
    naf: o.naf && {
      wnd: o.naf.wnd,
      points: [i].concat(o.naf.points.map(s))
    }
  }, i;
};
kn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
kn.prototype.isInfinity = function() {
  return this.inf;
};
kn.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var r = this.y.redSub(e.y);
  r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
  var n = r.redSqr().redISub(this.x).redISub(e.x), i = r.redMul(this.x.redSub(n)).redISub(this.y);
  return this.curve.point(n, i);
};
kn.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var r = this.curve.a, n = this.x.redSqr(), i = e.redInvm(), s = n.redAdd(n).redIAdd(n).redIAdd(r).redMul(i), o = s.redSqr().redISub(this.x.redAdd(this.x)), a = s.redMul(this.x.redSub(o)).redISub(this.y);
  return this.curve.point(o, a);
};
kn.prototype.getX = function() {
  return this.x.fromRed();
};
kn.prototype.getY = function() {
  return this.y.fromRed();
};
kn.prototype.mul = function(e) {
  return e = new sr(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
kn.prototype.mulAdd = function(e, r, n) {
  var i = [this, r], s = [e, n];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2);
};
kn.prototype.jmulAdd = function(e, r, n) {
  var i = [this, r], s = [e, n];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, !0) : this.curve._wnafMulAdd(1, i, s, 2, !0);
};
kn.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
kn.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var r = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var n = this.precomputed, i = function(s) {
      return s.neg();
    };
    r.precomputed = {
      naf: n.naf && {
        wnd: n.naf.wnd,
        points: n.naf.points.map(i)
      },
      doubles: n.doubles && {
        step: n.doubles.step,
        points: n.doubles.points.map(i)
      }
    };
  }
  return r;
};
kn.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function zn(t, e, r, n) {
  Rc.BasePoint.call(this, t, "jacobian"), e === null && r === null && n === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new sr(0)) : (this.x = new sr(e, 16), this.y = new sr(r, 16), this.z = new sr(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
ab(zn, Rc.BasePoint);
os.prototype.jpoint = function(e, r, n) {
  return new zn(this, e, r, n);
};
zn.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), r = e.redSqr(), n = this.x.redMul(r), i = this.y.redMul(r).redMul(e);
  return this.curve.point(n, i);
};
zn.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
zn.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var r = e.z.redSqr(), n = this.z.redSqr(), i = this.x.redMul(r), s = e.x.redMul(n), o = this.y.redMul(r.redMul(e.z)), a = e.y.redMul(n.redMul(this.z)), u = i.redSub(s), l = o.redSub(a);
  if (u.cmpn(0) === 0)
    return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var d = u.redSqr(), p = d.redMul(u), w = i.redMul(d), _ = l.redSqr().redIAdd(p).redISub(w).redISub(w), P = l.redMul(w.redISub(_)).redISub(o.redMul(p)), O = this.z.redMul(e.z).redMul(u);
  return this.curve.jpoint(_, P, O);
};
zn.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var r = this.z.redSqr(), n = this.x, i = e.x.redMul(r), s = this.y, o = e.y.redMul(r).redMul(this.z), a = n.redSub(i), u = s.redSub(o);
  if (a.cmpn(0) === 0)
    return u.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var l = a.redSqr(), d = l.redMul(a), p = n.redMul(l), w = u.redSqr().redIAdd(d).redISub(p).redISub(p), _ = u.redMul(p.redISub(w)).redISub(s.redMul(d)), P = this.z.redMul(a);
  return this.curve.jpoint(w, _, P);
};
zn.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var r;
  if (this.curve.zeroA || this.curve.threeA) {
    var n = this;
    for (r = 0; r < e; r++)
      n = n.dbl();
    return n;
  }
  var i = this.curve.a, s = this.curve.tinv, o = this.x, a = this.y, u = this.z, l = u.redSqr().redSqr(), d = a.redAdd(a);
  for (r = 0; r < e; r++) {
    var p = o.redSqr(), w = d.redSqr(), _ = w.redSqr(), P = p.redAdd(p).redIAdd(p).redIAdd(i.redMul(l)), O = o.redMul(w), L = P.redSqr().redISub(O.redAdd(O)), B = O.redISub(L), k = P.redMul(B);
    k = k.redIAdd(k).redISub(_);
    var q = d.redMul(u);
    r + 1 < e && (l = l.redMul(_)), o = L, u = q, d = k;
  }
  return this.curve.jpoint(o, d.redMul(s), u);
};
zn.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
zn.prototype._zeroDbl = function() {
  var e, r, n;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
    a = a.redIAdd(a);
    var u = i.redAdd(i).redIAdd(i), l = u.redSqr().redISub(a).redISub(a), d = o.redIAdd(o);
    d = d.redIAdd(d), d = d.redIAdd(d), e = l, r = u.redMul(a.redISub(l)).redISub(d), n = this.y.redAdd(this.y);
  } else {
    var p = this.x.redSqr(), w = this.y.redSqr(), _ = w.redSqr(), P = this.x.redAdd(w).redSqr().redISub(p).redISub(_);
    P = P.redIAdd(P);
    var O = p.redAdd(p).redIAdd(p), L = O.redSqr(), B = _.redIAdd(_);
    B = B.redIAdd(B), B = B.redIAdd(B), e = L.redISub(P).redISub(P), r = O.redMul(P.redISub(e)).redISub(B), n = this.y.redMul(this.z), n = n.redIAdd(n);
  }
  return this.curve.jpoint(e, r, n);
};
zn.prototype._threeDbl = function() {
  var e, r, n;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
    a = a.redIAdd(a);
    var u = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a), l = u.redSqr().redISub(a).redISub(a);
    e = l;
    var d = o.redIAdd(o);
    d = d.redIAdd(d), d = d.redIAdd(d), r = u.redMul(a.redISub(l)).redISub(d), n = this.y.redAdd(this.y);
  } else {
    var p = this.z.redSqr(), w = this.y.redSqr(), _ = this.x.redMul(w), P = this.x.redSub(p).redMul(this.x.redAdd(p));
    P = P.redAdd(P).redIAdd(P);
    var O = _.redIAdd(_);
    O = O.redIAdd(O);
    var L = O.redAdd(O);
    e = P.redSqr().redISub(L), n = this.y.redAdd(this.z).redSqr().redISub(w).redISub(p);
    var B = w.redSqr();
    B = B.redIAdd(B), B = B.redIAdd(B), B = B.redIAdd(B), r = P.redMul(O.redISub(e)).redISub(B);
  }
  return this.curve.jpoint(e, r, n);
};
zn.prototype._dbl = function() {
  var e = this.curve.a, r = this.x, n = this.y, i = this.z, s = i.redSqr().redSqr(), o = r.redSqr(), a = n.redSqr(), u = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(s)), l = r.redAdd(r);
  l = l.redIAdd(l);
  var d = l.redMul(a), p = u.redSqr().redISub(d.redAdd(d)), w = d.redISub(p), _ = a.redSqr();
  _ = _.redIAdd(_), _ = _.redIAdd(_), _ = _.redIAdd(_);
  var P = u.redMul(w).redISub(_), O = n.redAdd(n).redMul(i);
  return this.curve.jpoint(p, P, O);
};
zn.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr(), i = r.redSqr(), s = e.redAdd(e).redIAdd(e), o = s.redSqr(), a = this.x.redAdd(r).redSqr().redISub(e).redISub(i);
  a = a.redIAdd(a), a = a.redAdd(a).redIAdd(a), a = a.redISub(o);
  var u = a.redSqr(), l = i.redIAdd(i);
  l = l.redIAdd(l), l = l.redIAdd(l), l = l.redIAdd(l);
  var d = s.redIAdd(a).redSqr().redISub(o).redISub(u).redISub(l), p = r.redMul(d);
  p = p.redIAdd(p), p = p.redIAdd(p);
  var w = this.x.redMul(u).redISub(p);
  w = w.redIAdd(w), w = w.redIAdd(w);
  var _ = this.y.redMul(d.redMul(l.redISub(d)).redISub(a.redMul(u)));
  _ = _.redIAdd(_), _ = _.redIAdd(_), _ = _.redIAdd(_);
  var P = this.z.redAdd(a).redSqr().redISub(n).redISub(u);
  return this.curve.jpoint(w, _, P);
};
zn.prototype.mul = function(e, r) {
  return e = new sr(e, r), this.curve._wnafMul(this, e);
};
zn.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var r = this.z.redSqr(), n = e.z.redSqr();
  if (this.x.redMul(n).redISub(e.x.redMul(r)).cmpn(0) !== 0)
    return !1;
  var i = r.redMul(this.z), s = n.redMul(e.z);
  return this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0) === 0;
};
zn.prototype.eqXToP = function(e) {
  var r = this.z.redSqr(), n = e.toRed(this.curve.red).redMul(r);
  if (this.x.cmp(n) === 0)
    return !0;
  for (var i = e.clone(), s = this.curve.redN.redMul(r); ; ) {
    if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)
      return !1;
    if (n.redIAdd(s), this.x.cmp(n) === 0)
      return !0;
  }
};
zn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
zn.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var Bd = Hu(function(t, e) {
  var r = e;
  r.base = Rc, r.short = XU, r.mont = /*RicMoo:ethers:require(./mont)*/
  null, r.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
}), Fd = Hu(function(t, e) {
  var r = e, n = Fi.assert;
  function i(a) {
    a.type === "short" ? this.curve = new Bd.short(a) : a.type === "edwards" ? this.curve = new Bd.edwards(a) : this.curve = new Bd.mont(a), this.g = this.curve.g, this.n = this.curve.n, this.hash = a.hash, n(this.g.validate(), "Invalid curve"), n(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  r.PresetCurve = i;
  function s(a, u) {
    Object.defineProperty(r, a, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var l = new i(u);
        return Object.defineProperty(r, a, {
          configurable: !0,
          enumerable: !0,
          value: l
        }), l;
      }
    });
  }
  s("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: Eo.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), s("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: Eo.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), s("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: Eo.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), s("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: Eo.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), s("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: Eo.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), s("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Eo.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), s("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Eo.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var o;
  try {
    o = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch {
    o = void 0;
  }
  s("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: Eo.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      o
    ]
  });
});
function Sa(t) {
  if (!(this instanceof Sa))
    return new Sa(t);
  this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var e = Ss.toArray(t.entropy, t.entropyEnc || "hex"), r = Ss.toArray(t.nonce, t.nonceEnc || "hex"), n = Ss.toArray(t.pers, t.persEnc || "hex");
  ob(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(e, r, n);
}
var q8 = Sa;
Sa.prototype._init = function(e, r, n) {
  var i = e.concat(r).concat(n);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var s = 0; s < this.V.length; s++)
    this.K[s] = 0, this.V[s] = 1;
  this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656;
};
Sa.prototype._hmac = function() {
  return new Eo.hmac(this.hash, this.K);
};
Sa.prototype._update = function(e) {
  var r = this._hmac().update(this.V).update([0]);
  e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
Sa.prototype.reseed = function(e, r, n, i) {
  typeof r != "string" && (i = n, n = r, r = null), e = Ss.toArray(e, r), n = Ss.toArray(n, i), ob(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(n || [])), this._reseed = 1;
};
Sa.prototype.generate = function(e, r, n, i) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof r != "string" && (i = n, n = r, r = null), n && (n = Ss.toArray(n, i || "hex"), this._update(n));
  for (var s = []; s.length < e; )
    this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
  var o = s.slice(0, e);
  return this._update(n), this._reseed++, Ss.encode(o, r);
};
var F1 = Fi.assert;
function ei(t, e) {
  this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var cb = ei;
ei.fromPublic = function(e, r, n) {
  return r instanceof ei ? r : new ei(e, {
    pub: r,
    pubEnc: n
  });
};
ei.fromPrivate = function(e, r, n) {
  return r instanceof ei ? r : new ei(e, {
    priv: r,
    privEnc: n
  });
};
ei.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
ei.prototype.getPublic = function(e, r) {
  return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
};
ei.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
ei.prototype._importPrivate = function(e, r) {
  this.priv = new sr(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
ei.prototype._importPublic = function(e, r) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? F1(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && F1(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, r);
};
ei.prototype.derive = function(e) {
  return e.validate() || F1(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
ei.prototype.sign = function(e, r, n) {
  return this.ec.sign(e, this, r, n);
};
ei.prototype.verify = function(e, r) {
  return this.ec.verify(e, r, this);
};
ei.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var ZU = Fi.assert;
function sp(t, e) {
  if (t instanceof sp)
    return t;
  this._importDER(t, e) || (ZU(t.r && t.s, "Signature without r or s"), this.r = new sr(t.r, 16), this.s = new sr(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
}
var op = sp;
function QU() {
  this.place = 0;
}
function bm(t, e) {
  var r = t[e.place++];
  if (!(r & 128))
    return r;
  var n = r & 15;
  if (n === 0 || n > 4)
    return !1;
  for (var i = 0, s = 0, o = e.place; s < n; s++, o++)
    i <<= 8, i |= t[o], i >>>= 0;
  return i <= 127 ? !1 : (e.place = o, i);
}
function qx(t) {
  for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r; )
    e++;
  return e === 0 ? t : t.slice(e);
}
sp.prototype._importDER = function(e, r) {
  e = Fi.toArray(e, r);
  var n = new QU();
  if (e[n.place++] !== 48)
    return !1;
  var i = bm(e, n);
  if (i === !1 || i + n.place !== e.length || e[n.place++] !== 2)
    return !1;
  var s = bm(e, n);
  if (s === !1)
    return !1;
  var o = e.slice(n.place, s + n.place);
  if (n.place += s, e[n.place++] !== 2)
    return !1;
  var a = bm(e, n);
  if (a === !1 || e.length !== a + n.place)
    return !1;
  var u = e.slice(n.place, a + n.place);
  if (o[0] === 0)
    if (o[1] & 128)
      o = o.slice(1);
    else
      return !1;
  if (u[0] === 0)
    if (u[1] & 128)
      u = u.slice(1);
    else
      return !1;
  return this.r = new sr(o), this.s = new sr(u), this.recoveryParam = null, !0;
};
function ym(t, e) {
  if (e < 128) {
    t.push(e);
    return;
  }
  var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
  for (t.push(r | 128); --r; )
    t.push(e >>> (r << 3) & 255);
  t.push(e);
}
sp.prototype.toDER = function(e) {
  var r = this.r.toArray(), n = this.s.toArray();
  for (r[0] & 128 && (r = [0].concat(r)), n[0] & 128 && (n = [0].concat(n)), r = qx(r), n = qx(n); !n[0] && !(n[1] & 128); )
    n = n.slice(1);
  var i = [2];
  ym(i, r.length), i = i.concat(r), i.push(2), ym(i, n.length);
  var s = i.concat(n), o = [48];
  return ym(o, s.length), o = o.concat(s), Fi.encode(o, e);
};
var eq = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
), z8 = Fi.assert;
function ts(t) {
  if (!(this instanceof ts))
    return new ts(t);
  typeof t == "string" && (z8(
    Object.prototype.hasOwnProperty.call(Fd, t),
    "Unknown curve " + t
  ), t = Fd[t]), t instanceof Fd.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
}
var tq = ts;
ts.prototype.keyPair = function(e) {
  return new cb(this, e);
};
ts.prototype.keyFromPrivate = function(e, r) {
  return cb.fromPrivate(this, e, r);
};
ts.prototype.keyFromPublic = function(e, r) {
  return cb.fromPublic(this, e, r);
};
ts.prototype.genKeyPair = function(e) {
  e || (e = {});
  for (var r = new q8({
    hash: this.hash,
    pers: e.pers,
    persEnc: e.persEnc || "utf8",
    entropy: e.entropy || eq(this.hash.hmacStrength),
    entropyEnc: e.entropy && e.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), n = this.n.byteLength(), i = this.n.sub(new sr(2)); ; ) {
    var s = new sr(r.generate(n));
    if (!(s.cmp(i) > 0))
      return s.iaddn(1), this.keyFromPrivate(s);
  }
};
ts.prototype._truncateToN = function(e, r) {
  var n = e.byteLength() * 8 - this.n.bitLength();
  return n > 0 && (e = e.ushrn(n)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
};
ts.prototype.sign = function(e, r, n, i) {
  typeof n == "object" && (i = n, n = null), i || (i = {}), r = this.keyFromPrivate(r, n), e = this._truncateToN(new sr(e, 16));
  for (var s = this.n.byteLength(), o = r.getPrivate().toArray("be", s), a = e.toArray("be", s), u = new q8({
    hash: this.hash,
    entropy: o,
    nonce: a,
    pers: i.pers,
    persEnc: i.persEnc || "utf8"
  }), l = this.n.sub(new sr(1)), d = 0; ; d++) {
    var p = i.k ? i.k(d) : new sr(u.generate(this.n.byteLength()));
    if (p = this._truncateToN(p, !0), !(p.cmpn(1) <= 0 || p.cmp(l) >= 0)) {
      var w = this.g.mul(p);
      if (!w.isInfinity()) {
        var _ = w.getX(), P = _.umod(this.n);
        if (P.cmpn(0) !== 0) {
          var O = p.invm(this.n).mul(P.mul(r.getPrivate()).iadd(e));
          if (O = O.umod(this.n), O.cmpn(0) !== 0) {
            var L = (w.getY().isOdd() ? 1 : 0) | (_.cmp(P) !== 0 ? 2 : 0);
            return i.canonical && O.cmp(this.nh) > 0 && (O = this.n.sub(O), L ^= 1), new op({ r: P, s: O, recoveryParam: L });
          }
        }
      }
    }
  }
};
ts.prototype.verify = function(e, r, n, i) {
  e = this._truncateToN(new sr(e, 16)), n = this.keyFromPublic(n, i), r = new op(r, "hex");
  var s = r.r, o = r.s;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0 || o.cmpn(1) < 0 || o.cmp(this.n) >= 0)
    return !1;
  var a = o.invm(this.n), u = a.mul(e).umod(this.n), l = a.mul(s).umod(this.n), d;
  return this.curve._maxwellTrick ? (d = this.g.jmulAdd(u, n.getPublic(), l), d.isInfinity() ? !1 : d.eqXToP(s)) : (d = this.g.mulAdd(u, n.getPublic(), l), d.isInfinity() ? !1 : d.getX().umod(this.n).cmp(s) === 0);
};
ts.prototype.recoverPubKey = function(t, e, r, n) {
  z8((3 & r) === r, "The recovery param is more than two bits"), e = new op(e, n);
  var i = this.n, s = new sr(t), o = e.r, a = e.s, u = r & 1, l = r >> 1;
  if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && l)
    throw new Error("Unable to find sencond key candinate");
  l ? o = this.curve.pointFromX(o.add(this.curve.n), u) : o = this.curve.pointFromX(o, u);
  var d = e.r.invm(i), p = i.sub(s).mul(d).umod(i), w = a.mul(d).umod(i);
  return this.g.mulAdd(p, o, w);
};
ts.prototype.getKeyRecoveryParam = function(t, e, r, n) {
  if (e = new op(e, n), e.recoveryParam !== null)
    return e.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var s;
    try {
      s = this.recoverPubKey(t, e, i);
    } catch {
      continue;
    }
    if (s.eq(r))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var rq = Hu(function(t, e) {
  var r = e;
  r.version = "6.5.4", r.utils = Fi, r.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }, r.curve = Bd, r.curves = Fd, r.ec = tq, r.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
}), nq = rq.ec;
const iq = "signing-key/5.7.0", j1 = new Yr(iq);
let wm = null;
function ua() {
  return wm || (wm = new nq("secp256k1")), wm;
}
class sq {
  constructor(e) {
    Cf(this, "curve", "secp256k1"), Cf(this, "privateKey", Di(e)), fj(this.privateKey) !== 32 && j1.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    const r = ua().keyFromPrivate(wn(this.privateKey));
    Cf(this, "publicKey", "0x" + r.getPublic(!1, "hex")), Cf(this, "compressedPublicKey", "0x" + r.getPublic(!0, "hex")), Cf(this, "_isSigningKey", !0);
  }
  _addPoint(e) {
    const r = ua().keyFromPublic(wn(this.publicKey)), n = ua().keyFromPublic(wn(e));
    return "0x" + r.pub.add(n.pub).encodeCompressed("hex");
  }
  signDigest(e) {
    const r = ua().keyFromPrivate(wn(this.privateKey)), n = wn(e);
    n.length !== 32 && j1.throwArgumentError("bad digest length", "digest", e);
    const i = r.sign(n, { canonical: !0 });
    return x8({
      recoveryParam: i.recoveryParam,
      r: xu("0x" + i.r.toString(16), 32),
      s: xu("0x" + i.s.toString(16), 32)
    });
  }
  computeSharedSecret(e) {
    const r = ua().keyFromPrivate(wn(this.privateKey)), n = ua().keyFromPublic(wn(W8(e)));
    return xu("0x" + r.derive(n.getPublic()).toString(16), 32);
  }
  static isSigningKey(e) {
    return !!(e && e._isSigningKey);
  }
}
function oq(t, e) {
  const r = x8(e), n = { r: wn(r.r), s: wn(r.s) };
  return "0x" + ua().recoverPubKey(wn(t), n, r.recoveryParam).encode("hex", !1);
}
function W8(t, e) {
  const r = wn(t);
  return r.length === 32 ? new sq(r).publicKey : r.length === 33 ? "0x" + ua().keyFromPublic(r).getPublic(!1, "hex") : r.length === 65 ? Di(r) : j1.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
var zx;
(function(t) {
  t[t.legacy = 0] = "legacy", t[t.eip2930 = 1] = "eip2930", t[t.eip1559 = 2] = "eip1559";
})(zx || (zx = {}));
function aq(t) {
  const e = W8(t);
  return xj(Nx(nb(Nx(e, 1)), 12));
}
function cq(t, e) {
  return aq(oq(wn(t), e));
}
var ub = {}, ap = {};
Object.defineProperty(ap, "__esModule", { value: !0 });
var Gn = ar, U1 = Bi, uq = 20;
function fq(t, e, r) {
  for (var n = 1634760805, i = 857760878, s = 2036477234, o = 1797285236, a = r[3] << 24 | r[2] << 16 | r[1] << 8 | r[0], u = r[7] << 24 | r[6] << 16 | r[5] << 8 | r[4], l = r[11] << 24 | r[10] << 16 | r[9] << 8 | r[8], d = r[15] << 24 | r[14] << 16 | r[13] << 8 | r[12], p = r[19] << 24 | r[18] << 16 | r[17] << 8 | r[16], w = r[23] << 24 | r[22] << 16 | r[21] << 8 | r[20], _ = r[27] << 24 | r[26] << 16 | r[25] << 8 | r[24], P = r[31] << 24 | r[30] << 16 | r[29] << 8 | r[28], O = e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0], L = e[7] << 24 | e[6] << 16 | e[5] << 8 | e[4], B = e[11] << 24 | e[10] << 16 | e[9] << 8 | e[8], k = e[15] << 24 | e[14] << 16 | e[13] << 8 | e[12], q = n, U = i, V = s, Q = o, R = a, K = u, ge = l, Ee = d, Y = p, A = w, m = _, f = P, g = O, b = L, x = B, E = k, S = 0; S < uq; S += 2)
    q = q + R | 0, g ^= q, g = g >>> 16 | g << 16, Y = Y + g | 0, R ^= Y, R = R >>> 20 | R << 12, U = U + K | 0, b ^= U, b = b >>> 16 | b << 16, A = A + b | 0, K ^= A, K = K >>> 20 | K << 12, V = V + ge | 0, x ^= V, x = x >>> 16 | x << 16, m = m + x | 0, ge ^= m, ge = ge >>> 20 | ge << 12, Q = Q + Ee | 0, E ^= Q, E = E >>> 16 | E << 16, f = f + E | 0, Ee ^= f, Ee = Ee >>> 20 | Ee << 12, V = V + ge | 0, x ^= V, x = x >>> 24 | x << 8, m = m + x | 0, ge ^= m, ge = ge >>> 25 | ge << 7, Q = Q + Ee | 0, E ^= Q, E = E >>> 24 | E << 8, f = f + E | 0, Ee ^= f, Ee = Ee >>> 25 | Ee << 7, U = U + K | 0, b ^= U, b = b >>> 24 | b << 8, A = A + b | 0, K ^= A, K = K >>> 25 | K << 7, q = q + R | 0, g ^= q, g = g >>> 24 | g << 8, Y = Y + g | 0, R ^= Y, R = R >>> 25 | R << 7, q = q + K | 0, E ^= q, E = E >>> 16 | E << 16, m = m + E | 0, K ^= m, K = K >>> 20 | K << 12, U = U + ge | 0, g ^= U, g = g >>> 16 | g << 16, f = f + g | 0, ge ^= f, ge = ge >>> 20 | ge << 12, V = V + Ee | 0, b ^= V, b = b >>> 16 | b << 16, Y = Y + b | 0, Ee ^= Y, Ee = Ee >>> 20 | Ee << 12, Q = Q + R | 0, x ^= Q, x = x >>> 16 | x << 16, A = A + x | 0, R ^= A, R = R >>> 20 | R << 12, V = V + Ee | 0, b ^= V, b = b >>> 24 | b << 8, Y = Y + b | 0, Ee ^= Y, Ee = Ee >>> 25 | Ee << 7, Q = Q + R | 0, x ^= Q, x = x >>> 24 | x << 8, A = A + x | 0, R ^= A, R = R >>> 25 | R << 7, U = U + ge | 0, g ^= U, g = g >>> 24 | g << 8, f = f + g | 0, ge ^= f, ge = ge >>> 25 | ge << 7, q = q + K | 0, E ^= q, E = E >>> 24 | E << 8, m = m + E | 0, K ^= m, K = K >>> 25 | K << 7;
  Gn.writeUint32LE(q + n | 0, t, 0), Gn.writeUint32LE(U + i | 0, t, 4), Gn.writeUint32LE(V + s | 0, t, 8), Gn.writeUint32LE(Q + o | 0, t, 12), Gn.writeUint32LE(R + a | 0, t, 16), Gn.writeUint32LE(K + u | 0, t, 20), Gn.writeUint32LE(ge + l | 0, t, 24), Gn.writeUint32LE(Ee + d | 0, t, 28), Gn.writeUint32LE(Y + p | 0, t, 32), Gn.writeUint32LE(A + w | 0, t, 36), Gn.writeUint32LE(m + _ | 0, t, 40), Gn.writeUint32LE(f + P | 0, t, 44), Gn.writeUint32LE(g + O | 0, t, 48), Gn.writeUint32LE(b + L | 0, t, 52), Gn.writeUint32LE(x + B | 0, t, 56), Gn.writeUint32LE(E + k | 0, t, 60);
}
function H8(t, e, r, n, i) {
  if (i === void 0 && (i = 0), t.length !== 32)
    throw new Error("ChaCha: key size must be 32 bytes");
  if (n.length < r.length)
    throw new Error("ChaCha: destination is shorter than source");
  var s, o;
  if (i === 0) {
    if (e.length !== 8 && e.length !== 12)
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    s = new Uint8Array(16), o = s.length - e.length, s.set(e, o);
  } else {
    if (e.length !== 16)
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    s = e, o = i;
  }
  for (var a = new Uint8Array(64), u = 0; u < r.length; u += 64) {
    fq(a, s, t);
    for (var l = u; l < u + 64 && l < r.length; l++)
      n[l] = r[l] ^ a[l - u];
    hq(s, 0, o);
  }
  return U1.wipe(a), i === 0 && U1.wipe(s), n;
}
ap.streamXOR = H8;
function lq(t, e, r, n) {
  return n === void 0 && (n = 0), U1.wipe(r), H8(t, e, r, r, n);
}
ap.stream = lq;
function hq(t, e, r) {
  for (var n = 1; r--; )
    n = n + (t[e] & 255) | 0, t[e] = n & 255, n >>>= 8, e++;
  if (n > 0)
    throw new Error("ChaCha: counter overflow");
}
var K8 = {}, Na = {};
Object.defineProperty(Na, "__esModule", { value: !0 });
function dq(t, e, r) {
  return ~(t - 1) & e | t - 1 & r;
}
Na.select = dq;
function pq(t, e) {
  return (t | 0) - (e | 0) - 1 >>> 31 & 1;
}
Na.lessOrEqual = pq;
function V8(t, e) {
  if (t.length !== e.length)
    return 0;
  for (var r = 0, n = 0; n < t.length; n++)
    r |= t[n] ^ e[n];
  return 1 & r - 1 >>> 8;
}
Na.compare = V8;
function gq(t, e) {
  return t.length === 0 || e.length === 0 ? !1 : V8(t, e) !== 0;
}
Na.equal = gq;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = Na, r = Bi;
  t.DIGEST_LENGTH = 16;
  var n = (
    /** @class */
    function() {
      function o(a) {
        this.digestLength = t.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
        var u = a[0] | a[1] << 8;
        this._r[0] = u & 8191;
        var l = a[2] | a[3] << 8;
        this._r[1] = (u >>> 13 | l << 3) & 8191;
        var d = a[4] | a[5] << 8;
        this._r[2] = (l >>> 10 | d << 6) & 7939;
        var p = a[6] | a[7] << 8;
        this._r[3] = (d >>> 7 | p << 9) & 8191;
        var w = a[8] | a[9] << 8;
        this._r[4] = (p >>> 4 | w << 12) & 255, this._r[5] = w >>> 1 & 8190;
        var _ = a[10] | a[11] << 8;
        this._r[6] = (w >>> 14 | _ << 2) & 8191;
        var P = a[12] | a[13] << 8;
        this._r[7] = (_ >>> 11 | P << 5) & 8065;
        var O = a[14] | a[15] << 8;
        this._r[8] = (P >>> 8 | O << 8) & 8191, this._r[9] = O >>> 5 & 127, this._pad[0] = a[16] | a[17] << 8, this._pad[1] = a[18] | a[19] << 8, this._pad[2] = a[20] | a[21] << 8, this._pad[3] = a[22] | a[23] << 8, this._pad[4] = a[24] | a[25] << 8, this._pad[5] = a[26] | a[27] << 8, this._pad[6] = a[28] | a[29] << 8, this._pad[7] = a[30] | a[31] << 8;
      }
      return o.prototype._blocks = function(a, u, l) {
        for (var d = this._fin ? 0 : 2048, p = this._h[0], w = this._h[1], _ = this._h[2], P = this._h[3], O = this._h[4], L = this._h[5], B = this._h[6], k = this._h[7], q = this._h[8], U = this._h[9], V = this._r[0], Q = this._r[1], R = this._r[2], K = this._r[3], ge = this._r[4], Ee = this._r[5], Y = this._r[6], A = this._r[7], m = this._r[8], f = this._r[9]; l >= 16; ) {
          var g = a[u + 0] | a[u + 1] << 8;
          p += g & 8191;
          var b = a[u + 2] | a[u + 3] << 8;
          w += (g >>> 13 | b << 3) & 8191;
          var x = a[u + 4] | a[u + 5] << 8;
          _ += (b >>> 10 | x << 6) & 8191;
          var E = a[u + 6] | a[u + 7] << 8;
          P += (x >>> 7 | E << 9) & 8191;
          var S = a[u + 8] | a[u + 9] << 8;
          O += (E >>> 4 | S << 12) & 8191, L += S >>> 1 & 8191;
          var v = a[u + 10] | a[u + 11] << 8;
          B += (S >>> 14 | v << 2) & 8191;
          var M = a[u + 12] | a[u + 13] << 8;
          k += (v >>> 11 | M << 5) & 8191;
          var I = a[u + 14] | a[u + 15] << 8;
          q += (M >>> 8 | I << 8) & 8191, U += I >>> 5 | d;
          var F = 0, ce = F;
          ce += p * V, ce += w * (5 * f), ce += _ * (5 * m), ce += P * (5 * A), ce += O * (5 * Y), F = ce >>> 13, ce &= 8191, ce += L * (5 * Ee), ce += B * (5 * ge), ce += k * (5 * K), ce += q * (5 * R), ce += U * (5 * Q), F += ce >>> 13, ce &= 8191;
          var D = F;
          D += p * Q, D += w * V, D += _ * (5 * f), D += P * (5 * m), D += O * (5 * A), F = D >>> 13, D &= 8191, D += L * (5 * Y), D += B * (5 * Ee), D += k * (5 * ge), D += q * (5 * K), D += U * (5 * R), F += D >>> 13, D &= 8191;
          var oe = F;
          oe += p * R, oe += w * Q, oe += _ * V, oe += P * (5 * f), oe += O * (5 * m), F = oe >>> 13, oe &= 8191, oe += L * (5 * A), oe += B * (5 * Y), oe += k * (5 * Ee), oe += q * (5 * ge), oe += U * (5 * K), F += oe >>> 13, oe &= 8191;
          var Z = F;
          Z += p * K, Z += w * R, Z += _ * Q, Z += P * V, Z += O * (5 * f), F = Z >>> 13, Z &= 8191, Z += L * (5 * m), Z += B * (5 * A), Z += k * (5 * Y), Z += q * (5 * Ee), Z += U * (5 * ge), F += Z >>> 13, Z &= 8191;
          var J = F;
          J += p * ge, J += w * K, J += _ * R, J += P * Q, J += O * V, F = J >>> 13, J &= 8191, J += L * (5 * f), J += B * (5 * m), J += k * (5 * A), J += q * (5 * Y), J += U * (5 * Ee), F += J >>> 13, J &= 8191;
          var ee = F;
          ee += p * Ee, ee += w * ge, ee += _ * K, ee += P * R, ee += O * Q, F = ee >>> 13, ee &= 8191, ee += L * V, ee += B * (5 * f), ee += k * (5 * m), ee += q * (5 * A), ee += U * (5 * Y), F += ee >>> 13, ee &= 8191;
          var T = F;
          T += p * Y, T += w * Ee, T += _ * ge, T += P * K, T += O * R, F = T >>> 13, T &= 8191, T += L * Q, T += B * V, T += k * (5 * f), T += q * (5 * m), T += U * (5 * A), F += T >>> 13, T &= 8191;
          var X = F;
          X += p * A, X += w * Y, X += _ * Ee, X += P * ge, X += O * K, F = X >>> 13, X &= 8191, X += L * R, X += B * Q, X += k * V, X += q * (5 * f), X += U * (5 * m), F += X >>> 13, X &= 8191;
          var re = F;
          re += p * m, re += w * A, re += _ * Y, re += P * Ee, re += O * ge, F = re >>> 13, re &= 8191, re += L * K, re += B * R, re += k * Q, re += q * V, re += U * (5 * f), F += re >>> 13, re &= 8191;
          var pe = F;
          pe += p * f, pe += w * m, pe += _ * A, pe += P * Y, pe += O * Ee, F = pe >>> 13, pe &= 8191, pe += L * ge, pe += B * K, pe += k * R, pe += q * Q, pe += U * V, F += pe >>> 13, pe &= 8191, F = (F << 2) + F | 0, F = F + ce | 0, ce = F & 8191, F = F >>> 13, D += F, p = ce, w = D, _ = oe, P = Z, O = J, L = ee, B = T, k = X, q = re, U = pe, u += 16, l -= 16;
        }
        this._h[0] = p, this._h[1] = w, this._h[2] = _, this._h[3] = P, this._h[4] = O, this._h[5] = L, this._h[6] = B, this._h[7] = k, this._h[8] = q, this._h[9] = U;
      }, o.prototype.finish = function(a, u) {
        u === void 0 && (u = 0);
        var l = new Uint16Array(10), d, p, w, _;
        if (this._leftover) {
          for (_ = this._leftover, this._buffer[_++] = 1; _ < 16; _++)
            this._buffer[_] = 0;
          this._fin = 1, this._blocks(this._buffer, 0, 16);
        }
        for (d = this._h[1] >>> 13, this._h[1] &= 8191, _ = 2; _ < 10; _++)
          this._h[_] += d, d = this._h[_] >>> 13, this._h[_] &= 8191;
        for (this._h[0] += d * 5, d = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += d, d = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += d, l[0] = this._h[0] + 5, d = l[0] >>> 13, l[0] &= 8191, _ = 1; _ < 10; _++)
          l[_] = this._h[_] + d, d = l[_] >>> 13, l[_] &= 8191;
        for (l[9] -= 8192, p = (d ^ 1) - 1, _ = 0; _ < 10; _++)
          l[_] &= p;
        for (p = ~p, _ = 0; _ < 10; _++)
          this._h[_] = this._h[_] & p | l[_];
        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, w = this._h[0] + this._pad[0], this._h[0] = w & 65535, _ = 1; _ < 8; _++)
          w = (this._h[_] + this._pad[_] | 0) + (w >>> 16) | 0, this._h[_] = w & 65535;
        return a[u + 0] = this._h[0] >>> 0, a[u + 1] = this._h[0] >>> 8, a[u + 2] = this._h[1] >>> 0, a[u + 3] = this._h[1] >>> 8, a[u + 4] = this._h[2] >>> 0, a[u + 5] = this._h[2] >>> 8, a[u + 6] = this._h[3] >>> 0, a[u + 7] = this._h[3] >>> 8, a[u + 8] = this._h[4] >>> 0, a[u + 9] = this._h[4] >>> 8, a[u + 10] = this._h[5] >>> 0, a[u + 11] = this._h[5] >>> 8, a[u + 12] = this._h[6] >>> 0, a[u + 13] = this._h[6] >>> 8, a[u + 14] = this._h[7] >>> 0, a[u + 15] = this._h[7] >>> 8, this._finished = !0, this;
      }, o.prototype.update = function(a) {
        var u = 0, l = a.length, d;
        if (this._leftover) {
          d = 16 - this._leftover, d > l && (d = l);
          for (var p = 0; p < d; p++)
            this._buffer[this._leftover + p] = a[u + p];
          if (l -= d, u += d, this._leftover += d, this._leftover < 16)
            return this;
          this._blocks(this._buffer, 0, 16), this._leftover = 0;
        }
        if (l >= 16 && (d = l - l % 16, this._blocks(a, u, d), u += d, l -= d), l) {
          for (var p = 0; p < l; p++)
            this._buffer[this._leftover + p] = a[u + p];
          this._leftover += l;
        }
        return this;
      }, o.prototype.digest = function() {
        if (this._finished)
          throw new Error("Poly1305 was finished");
        var a = new Uint8Array(16);
        return this.finish(a), a;
      }, o.prototype.clean = function() {
        return r.wipe(this._buffer), r.wipe(this._r), r.wipe(this._h), r.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;
      }, o;
    }()
  );
  t.Poly1305 = n;
  function i(o, a) {
    var u = new n(o);
    u.update(a);
    var l = u.digest();
    return u.clean(), l;
  }
  t.oneTimeAuth = i;
  function s(o, a) {
    return o.length !== t.DIGEST_LENGTH || a.length !== t.DIGEST_LENGTH ? !1 : e.equal(o, a);
  }
  t.equal = s;
})(K8);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = ap, r = K8, n = Bi, i = ar, s = Na;
  t.KEY_LENGTH = 32, t.NONCE_LENGTH = 12, t.TAG_LENGTH = 16;
  var o = new Uint8Array(16), a = (
    /** @class */
    function() {
      function u(l) {
        if (this.nonceLength = t.NONCE_LENGTH, this.tagLength = t.TAG_LENGTH, l.length !== t.KEY_LENGTH)
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(l);
      }
      return u.prototype.seal = function(l, d, p, w) {
        if (l.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        var _ = new Uint8Array(16);
        _.set(l, _.length - l.length);
        var P = new Uint8Array(32);
        e.stream(this._key, _, P, 4);
        var O = d.length + this.tagLength, L;
        if (w) {
          if (w.length !== O)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          L = w;
        } else
          L = new Uint8Array(O);
        return e.streamXOR(this._key, _, d, L, 4), this._authenticate(L.subarray(L.length - this.tagLength, L.length), P, L.subarray(0, L.length - this.tagLength), p), n.wipe(_), L;
      }, u.prototype.open = function(l, d, p, w) {
        if (l.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        if (d.length < this.tagLength)
          return null;
        var _ = new Uint8Array(16);
        _.set(l, _.length - l.length);
        var P = new Uint8Array(32);
        e.stream(this._key, _, P, 4);
        var O = new Uint8Array(this.tagLength);
        if (this._authenticate(O, P, d.subarray(0, d.length - this.tagLength), p), !s.equal(O, d.subarray(d.length - this.tagLength, d.length)))
          return null;
        var L = d.length - this.tagLength, B;
        if (w) {
          if (w.length !== L)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          B = w;
        } else
          B = new Uint8Array(L);
        return e.streamXOR(this._key, _, d.subarray(0, d.length - this.tagLength), B, 4), n.wipe(_), B;
      }, u.prototype.clean = function() {
        return n.wipe(this._key), this;
      }, u.prototype._authenticate = function(l, d, p, w) {
        var _ = new r.Poly1305(d);
        w && (_.update(w), w.length % 16 > 0 && _.update(o.subarray(w.length % 16))), _.update(p), p.length % 16 > 0 && _.update(o.subarray(p.length % 16));
        var P = new Uint8Array(8);
        w && i.writeUint64LE(w.length, P), _.update(P), i.writeUint64LE(p.length, P), _.update(P);
        for (var O = _.digest(), L = 0; L < O.length; L++)
          l[L] = O[L];
        _.clean(), n.wipe(O), n.wipe(P);
      }, u;
    }()
  );
  t.ChaCha20Poly1305 = a;
})(ub);
var G8 = {}, nh = {}, fb = {};
Object.defineProperty(fb, "__esModule", { value: !0 });
function mq(t) {
  return typeof t.saveState < "u" && typeof t.restoreState < "u" && typeof t.cleanSavedState < "u";
}
fb.isSerializableHash = mq;
Object.defineProperty(nh, "__esModule", { value: !0 });
var Bs = fb, vq = Na, bq = Bi, Y8 = (
  /** @class */
  function() {
    function t(e, r) {
      this._finished = !1, this._inner = new e(), this._outer = new e(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
      var n = new Uint8Array(this.blockSize);
      r.length > this.blockSize ? this._inner.update(r).finish(n).clean() : n.set(r);
      for (var i = 0; i < n.length; i++)
        n[i] ^= 54;
      this._inner.update(n);
      for (var i = 0; i < n.length; i++)
        n[i] ^= 106;
      this._outer.update(n), Bs.isSerializableHash(this._inner) && Bs.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), bq.wipe(n);
    }
    return t.prototype.reset = function() {
      if (!Bs.isSerializableHash(this._inner) || !Bs.isSerializableHash(this._outer))
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, t.prototype.clean = function() {
      Bs.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), Bs.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();
    }, t.prototype.update = function(e) {
      return this._inner.update(e), this;
    }, t.prototype.finish = function(e) {
      return this._finished ? (this._outer.finish(e), this) : (this._inner.finish(e), this._outer.update(e.subarray(0, this.digestLength)).finish(e), this._finished = !0, this);
    }, t.prototype.digest = function() {
      var e = new Uint8Array(this.digestLength);
      return this.finish(e), e;
    }, t.prototype.saveState = function() {
      if (!Bs.isSerializableHash(this._inner))
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      return this._inner.saveState();
    }, t.prototype.restoreState = function(e) {
      if (!Bs.isSerializableHash(this._inner) || !Bs.isSerializableHash(this._outer))
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      return this._inner.restoreState(e), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, t.prototype.cleanSavedState = function(e) {
      if (!Bs.isSerializableHash(this._inner))
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      this._inner.cleanSavedState(e);
    }, t;
  }()
);
nh.HMAC = Y8;
function yq(t, e, r) {
  var n = new Y8(t, e);
  n.update(r);
  var i = n.digest();
  return n.clean(), i;
}
nh.hmac = yq;
nh.equal = vq.equal;
Object.defineProperty(G8, "__esModule", { value: !0 });
var Wx = nh, Hx = Bi, wq = (
  /** @class */
  function() {
    function t(e, r, n, i) {
      n === void 0 && (n = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = e, this._info = i;
      var s = Wx.hmac(this._hash, n, r);
      this._hmac = new Wx.HMAC(e, s), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;
    }
    return t.prototype._fillBuffer = function() {
      this._counter[0]++;
      var e = this._counter[0];
      if (e === 0)
        throw new Error("hkdf: cannot expand more");
      this._hmac.reset(), e > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;
    }, t.prototype.expand = function(e) {
      for (var r = new Uint8Array(e), n = 0; n < r.length; n++)
        this._bufpos === this._buffer.length && this._fillBuffer(), r[n] = this._buffer[this._bufpos++];
      return r;
    }, t.prototype.clean = function() {
      this._hmac.clean(), Hx.wipe(this._buffer), Hx.wipe(this._counter), this._bufpos = 0;
    }, t;
  }()
), xq = G8.HKDF = wq, ih = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = ar, r = Bi;
  t.DIGEST_LENGTH = 32, t.BLOCK_SIZE = 64;
  var n = (
    /** @class */
    function() {
      function a() {
        this.digestLength = t.DIGEST_LENGTH, this.blockSize = t.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return a.prototype._initState = function() {
        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
      }, a.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, a.prototype.clean = function() {
        r.wipe(this._buffer), r.wipe(this._temp), this.reset();
      }, a.prototype.update = function(u, l) {
        if (l === void 0 && (l = u.length), this._finished)
          throw new Error("SHA256: can't update because hash was finished.");
        var d = 0;
        if (this._bytesHashed += l, this._bufferLength > 0) {
          for (; this._bufferLength < this.blockSize && l > 0; )
            this._buffer[this._bufferLength++] = u[d++], l--;
          this._bufferLength === this.blockSize && (s(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (l >= this.blockSize && (d = s(this._temp, this._state, u, d, l), l %= this.blockSize); l > 0; )
          this._buffer[this._bufferLength++] = u[d++], l--;
        return this;
      }, a.prototype.finish = function(u) {
        if (!this._finished) {
          var l = this._bytesHashed, d = this._bufferLength, p = l / 536870912 | 0, w = l << 3, _ = l % 64 < 56 ? 64 : 128;
          this._buffer[d] = 128;
          for (var P = d + 1; P < _ - 8; P++)
            this._buffer[P] = 0;
          e.writeUint32BE(p, this._buffer, _ - 8), e.writeUint32BE(w, this._buffer, _ - 4), s(this._temp, this._state, this._buffer, 0, _), this._finished = !0;
        }
        for (var P = 0; P < this.digestLength / 4; P++)
          e.writeUint32BE(this._state[P], u, P * 4);
        return this;
      }, a.prototype.digest = function() {
        var u = new Uint8Array(this.digestLength);
        return this.finish(u), u;
      }, a.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, a.prototype.restoreState = function(u) {
        return this._state.set(u.state), this._bufferLength = u.bufferLength, u.buffer && this._buffer.set(u.buffer), this._bytesHashed = u.bytesHashed, this._finished = !1, this;
      }, a.prototype.cleanSavedState = function(u) {
        r.wipe(u.state), u.buffer && r.wipe(u.buffer), u.bufferLength = 0, u.bytesHashed = 0;
      }, a;
    }()
  );
  t.SHA256 = n;
  var i = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function s(a, u, l, d, p) {
    for (; p >= 64; ) {
      for (var w = u[0], _ = u[1], P = u[2], O = u[3], L = u[4], B = u[5], k = u[6], q = u[7], U = 0; U < 16; U++) {
        var V = d + U * 4;
        a[U] = e.readUint32BE(l, V);
      }
      for (var U = 16; U < 64; U++) {
        var Q = a[U - 2], R = (Q >>> 17 | Q << 15) ^ (Q >>> 19 | Q << 13) ^ Q >>> 10;
        Q = a[U - 15];
        var K = (Q >>> 7 | Q << 25) ^ (Q >>> 18 | Q << 14) ^ Q >>> 3;
        a[U] = (R + a[U - 7] | 0) + (K + a[U - 16] | 0);
      }
      for (var U = 0; U < 64; U++) {
        var R = (((L >>> 6 | L << 26) ^ (L >>> 11 | L << 21) ^ (L >>> 25 | L << 7)) + (L & B ^ ~L & k) | 0) + (q + (i[U] + a[U] | 0) | 0) | 0, K = ((w >>> 2 | w << 30) ^ (w >>> 13 | w << 19) ^ (w >>> 22 | w << 10)) + (w & _ ^ w & P ^ _ & P) | 0;
        q = k, k = B, B = L, L = O + R | 0, O = P, P = _, _ = w, w = R + K | 0;
      }
      u[0] += w, u[1] += _, u[2] += P, u[3] += O, u[4] += L, u[5] += B, u[6] += k, u[7] += q, d += 64, p -= 64;
    }
    return d;
  }
  function o(a) {
    var u = new n();
    u.update(a);
    var l = u.digest();
    return u.clean(), l;
  }
  t.hash = o;
})(ih);
var lb = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.sharedKey = t.generateKeyPair = t.generateKeyPairFromSeed = t.scalarMultBase = t.scalarMult = t.SHARED_KEY_LENGTH = t.SECRET_KEY_LENGTH = t.PUBLIC_KEY_LENGTH = void 0;
  const e = Da, r = Bi;
  t.PUBLIC_KEY_LENGTH = 32, t.SECRET_KEY_LENGTH = 32, t.SHARED_KEY_LENGTH = 32;
  function n(U) {
    const V = new Float64Array(16);
    if (U)
      for (let Q = 0; Q < U.length; Q++)
        V[Q] = U[Q];
    return V;
  }
  const i = new Uint8Array(32);
  i[0] = 9;
  const s = n([56129, 1]);
  function o(U) {
    let V = 1;
    for (let Q = 0; Q < 16; Q++) {
      let R = U[Q] + V + 65535;
      V = Math.floor(R / 65536), U[Q] = R - V * 65536;
    }
    U[0] += V - 1 + 37 * (V - 1);
  }
  function a(U, V, Q) {
    const R = ~(Q - 1);
    for (let K = 0; K < 16; K++) {
      const ge = R & (U[K] ^ V[K]);
      U[K] ^= ge, V[K] ^= ge;
    }
  }
  function u(U, V) {
    const Q = n(), R = n();
    for (let K = 0; K < 16; K++)
      R[K] = V[K];
    o(R), o(R), o(R);
    for (let K = 0; K < 2; K++) {
      Q[0] = R[0] - 65517;
      for (let Ee = 1; Ee < 15; Ee++)
        Q[Ee] = R[Ee] - 65535 - (Q[Ee - 1] >> 16 & 1), Q[Ee - 1] &= 65535;
      Q[15] = R[15] - 32767 - (Q[14] >> 16 & 1);
      const ge = Q[15] >> 16 & 1;
      Q[14] &= 65535, a(R, Q, 1 - ge);
    }
    for (let K = 0; K < 16; K++)
      U[2 * K] = R[K] & 255, U[2 * K + 1] = R[K] >> 8;
  }
  function l(U, V) {
    for (let Q = 0; Q < 16; Q++)
      U[Q] = V[2 * Q] + (V[2 * Q + 1] << 8);
    U[15] &= 32767;
  }
  function d(U, V, Q) {
    for (let R = 0; R < 16; R++)
      U[R] = V[R] + Q[R];
  }
  function p(U, V, Q) {
    for (let R = 0; R < 16; R++)
      U[R] = V[R] - Q[R];
  }
  function w(U, V, Q) {
    let R, K, ge = 0, Ee = 0, Y = 0, A = 0, m = 0, f = 0, g = 0, b = 0, x = 0, E = 0, S = 0, v = 0, M = 0, I = 0, F = 0, ce = 0, D = 0, oe = 0, Z = 0, J = 0, ee = 0, T = 0, X = 0, re = 0, pe = 0, ie = 0, ue = 0, ve = 0, Pe = 0, De = 0, Ce = 0, $e = Q[0], Me = Q[1], Ne = Q[2], Ke = Q[3], Le = Q[4], qe = Q[5], ze = Q[6], _e = Q[7], Ze = Q[8], at = Q[9], ke = Q[10], Qe = Q[11], tt = Q[12], Ye = Q[13], dt = Q[14], lt = Q[15];
    R = V[0], ge += R * $e, Ee += R * Me, Y += R * Ne, A += R * Ke, m += R * Le, f += R * qe, g += R * ze, b += R * _e, x += R * Ze, E += R * at, S += R * ke, v += R * Qe, M += R * tt, I += R * Ye, F += R * dt, ce += R * lt, R = V[1], Ee += R * $e, Y += R * Me, A += R * Ne, m += R * Ke, f += R * Le, g += R * qe, b += R * ze, x += R * _e, E += R * Ze, S += R * at, v += R * ke, M += R * Qe, I += R * tt, F += R * Ye, ce += R * dt, D += R * lt, R = V[2], Y += R * $e, A += R * Me, m += R * Ne, f += R * Ke, g += R * Le, b += R * qe, x += R * ze, E += R * _e, S += R * Ze, v += R * at, M += R * ke, I += R * Qe, F += R * tt, ce += R * Ye, D += R * dt, oe += R * lt, R = V[3], A += R * $e, m += R * Me, f += R * Ne, g += R * Ke, b += R * Le, x += R * qe, E += R * ze, S += R * _e, v += R * Ze, M += R * at, I += R * ke, F += R * Qe, ce += R * tt, D += R * Ye, oe += R * dt, Z += R * lt, R = V[4], m += R * $e, f += R * Me, g += R * Ne, b += R * Ke, x += R * Le, E += R * qe, S += R * ze, v += R * _e, M += R * Ze, I += R * at, F += R * ke, ce += R * Qe, D += R * tt, oe += R * Ye, Z += R * dt, J += R * lt, R = V[5], f += R * $e, g += R * Me, b += R * Ne, x += R * Ke, E += R * Le, S += R * qe, v += R * ze, M += R * _e, I += R * Ze, F += R * at, ce += R * ke, D += R * Qe, oe += R * tt, Z += R * Ye, J += R * dt, ee += R * lt, R = V[6], g += R * $e, b += R * Me, x += R * Ne, E += R * Ke, S += R * Le, v += R * qe, M += R * ze, I += R * _e, F += R * Ze, ce += R * at, D += R * ke, oe += R * Qe, Z += R * tt, J += R * Ye, ee += R * dt, T += R * lt, R = V[7], b += R * $e, x += R * Me, E += R * Ne, S += R * Ke, v += R * Le, M += R * qe, I += R * ze, F += R * _e, ce += R * Ze, D += R * at, oe += R * ke, Z += R * Qe, J += R * tt, ee += R * Ye, T += R * dt, X += R * lt, R = V[8], x += R * $e, E += R * Me, S += R * Ne, v += R * Ke, M += R * Le, I += R * qe, F += R * ze, ce += R * _e, D += R * Ze, oe += R * at, Z += R * ke, J += R * Qe, ee += R * tt, T += R * Ye, X += R * dt, re += R * lt, R = V[9], E += R * $e, S += R * Me, v += R * Ne, M += R * Ke, I += R * Le, F += R * qe, ce += R * ze, D += R * _e, oe += R * Ze, Z += R * at, J += R * ke, ee += R * Qe, T += R * tt, X += R * Ye, re += R * dt, pe += R * lt, R = V[10], S += R * $e, v += R * Me, M += R * Ne, I += R * Ke, F += R * Le, ce += R * qe, D += R * ze, oe += R * _e, Z += R * Ze, J += R * at, ee += R * ke, T += R * Qe, X += R * tt, re += R * Ye, pe += R * dt, ie += R * lt, R = V[11], v += R * $e, M += R * Me, I += R * Ne, F += R * Ke, ce += R * Le, D += R * qe, oe += R * ze, Z += R * _e, J += R * Ze, ee += R * at, T += R * ke, X += R * Qe, re += R * tt, pe += R * Ye, ie += R * dt, ue += R * lt, R = V[12], M += R * $e, I += R * Me, F += R * Ne, ce += R * Ke, D += R * Le, oe += R * qe, Z += R * ze, J += R * _e, ee += R * Ze, T += R * at, X += R * ke, re += R * Qe, pe += R * tt, ie += R * Ye, ue += R * dt, ve += R * lt, R = V[13], I += R * $e, F += R * Me, ce += R * Ne, D += R * Ke, oe += R * Le, Z += R * qe, J += R * ze, ee += R * _e, T += R * Ze, X += R * at, re += R * ke, pe += R * Qe, ie += R * tt, ue += R * Ye, ve += R * dt, Pe += R * lt, R = V[14], F += R * $e, ce += R * Me, D += R * Ne, oe += R * Ke, Z += R * Le, J += R * qe, ee += R * ze, T += R * _e, X += R * Ze, re += R * at, pe += R * ke, ie += R * Qe, ue += R * tt, ve += R * Ye, Pe += R * dt, De += R * lt, R = V[15], ce += R * $e, D += R * Me, oe += R * Ne, Z += R * Ke, J += R * Le, ee += R * qe, T += R * ze, X += R * _e, re += R * Ze, pe += R * at, ie += R * ke, ue += R * Qe, ve += R * tt, Pe += R * Ye, De += R * dt, Ce += R * lt, ge += 38 * D, Ee += 38 * oe, Y += 38 * Z, A += 38 * J, m += 38 * ee, f += 38 * T, g += 38 * X, b += 38 * re, x += 38 * pe, E += 38 * ie, S += 38 * ue, v += 38 * ve, M += 38 * Pe, I += 38 * De, F += 38 * Ce, K = 1, R = ge + K + 65535, K = Math.floor(R / 65536), ge = R - K * 65536, R = Ee + K + 65535, K = Math.floor(R / 65536), Ee = R - K * 65536, R = Y + K + 65535, K = Math.floor(R / 65536), Y = R - K * 65536, R = A + K + 65535, K = Math.floor(R / 65536), A = R - K * 65536, R = m + K + 65535, K = Math.floor(R / 65536), m = R - K * 65536, R = f + K + 65535, K = Math.floor(R / 65536), f = R - K * 65536, R = g + K + 65535, K = Math.floor(R / 65536), g = R - K * 65536, R = b + K + 65535, K = Math.floor(R / 65536), b = R - K * 65536, R = x + K + 65535, K = Math.floor(R / 65536), x = R - K * 65536, R = E + K + 65535, K = Math.floor(R / 65536), E = R - K * 65536, R = S + K + 65535, K = Math.floor(R / 65536), S = R - K * 65536, R = v + K + 65535, K = Math.floor(R / 65536), v = R - K * 65536, R = M + K + 65535, K = Math.floor(R / 65536), M = R - K * 65536, R = I + K + 65535, K = Math.floor(R / 65536), I = R - K * 65536, R = F + K + 65535, K = Math.floor(R / 65536), F = R - K * 65536, R = ce + K + 65535, K = Math.floor(R / 65536), ce = R - K * 65536, ge += K - 1 + 37 * (K - 1), K = 1, R = ge + K + 65535, K = Math.floor(R / 65536), ge = R - K * 65536, R = Ee + K + 65535, K = Math.floor(R / 65536), Ee = R - K * 65536, R = Y + K + 65535, K = Math.floor(R / 65536), Y = R - K * 65536, R = A + K + 65535, K = Math.floor(R / 65536), A = R - K * 65536, R = m + K + 65535, K = Math.floor(R / 65536), m = R - K * 65536, R = f + K + 65535, K = Math.floor(R / 65536), f = R - K * 65536, R = g + K + 65535, K = Math.floor(R / 65536), g = R - K * 65536, R = b + K + 65535, K = Math.floor(R / 65536), b = R - K * 65536, R = x + K + 65535, K = Math.floor(R / 65536), x = R - K * 65536, R = E + K + 65535, K = Math.floor(R / 65536), E = R - K * 65536, R = S + K + 65535, K = Math.floor(R / 65536), S = R - K * 65536, R = v + K + 65535, K = Math.floor(R / 65536), v = R - K * 65536, R = M + K + 65535, K = Math.floor(R / 65536), M = R - K * 65536, R = I + K + 65535, K = Math.floor(R / 65536), I = R - K * 65536, R = F + K + 65535, K = Math.floor(R / 65536), F = R - K * 65536, R = ce + K + 65535, K = Math.floor(R / 65536), ce = R - K * 65536, ge += K - 1 + 37 * (K - 1), U[0] = ge, U[1] = Ee, U[2] = Y, U[3] = A, U[4] = m, U[5] = f, U[6] = g, U[7] = b, U[8] = x, U[9] = E, U[10] = S, U[11] = v, U[12] = M, U[13] = I, U[14] = F, U[15] = ce;
  }
  function _(U, V) {
    w(U, V, V);
  }
  function P(U, V) {
    const Q = n();
    for (let R = 0; R < 16; R++)
      Q[R] = V[R];
    for (let R = 253; R >= 0; R--)
      _(Q, Q), R !== 2 && R !== 4 && w(Q, Q, V);
    for (let R = 0; R < 16; R++)
      U[R] = Q[R];
  }
  function O(U, V) {
    const Q = new Uint8Array(32), R = new Float64Array(80), K = n(), ge = n(), Ee = n(), Y = n(), A = n(), m = n();
    for (let x = 0; x < 31; x++)
      Q[x] = U[x];
    Q[31] = U[31] & 127 | 64, Q[0] &= 248, l(R, V);
    for (let x = 0; x < 16; x++)
      ge[x] = R[x];
    K[0] = Y[0] = 1;
    for (let x = 254; x >= 0; --x) {
      const E = Q[x >>> 3] >>> (x & 7) & 1;
      a(K, ge, E), a(Ee, Y, E), d(A, K, Ee), p(K, K, Ee), d(Ee, ge, Y), p(ge, ge, Y), _(Y, A), _(m, K), w(K, Ee, K), w(Ee, ge, A), d(A, K, Ee), p(K, K, Ee), _(ge, K), p(Ee, Y, m), w(K, Ee, s), d(K, K, Y), w(Ee, Ee, K), w(K, Y, m), w(Y, ge, R), _(ge, A), a(K, ge, E), a(Ee, Y, E);
    }
    for (let x = 0; x < 16; x++)
      R[x + 16] = K[x], R[x + 32] = Ee[x], R[x + 48] = ge[x], R[x + 64] = Y[x];
    const f = R.subarray(32), g = R.subarray(16);
    P(f, f), w(g, g, f);
    const b = new Uint8Array(32);
    return u(b, g), b;
  }
  t.scalarMult = O;
  function L(U) {
    return O(U, i);
  }
  t.scalarMultBase = L;
  function B(U) {
    if (U.length !== t.SECRET_KEY_LENGTH)
      throw new Error(`x25519: seed must be ${t.SECRET_KEY_LENGTH} bytes`);
    const V = new Uint8Array(U);
    return {
      publicKey: L(V),
      secretKey: V
    };
  }
  t.generateKeyPairFromSeed = B;
  function k(U) {
    const V = (0, e.randomBytes)(32, U), Q = B(V);
    return (0, r.wipe)(V), Q;
  }
  t.generateKeyPair = k;
  function q(U, V, Q = !1) {
    if (U.length !== t.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect secret key length");
    if (V.length !== t.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect public key length");
    const R = O(U, V);
    if (Q) {
      let K = 0;
      for (let ge = 0; ge < R.length; ge++)
        K |= R[ge];
      if (K === 0)
        throw new Error("X25519: invalid shared key");
    }
    return R;
  }
  t.sharedKey = q;
})(lb);
var J8 = {};
const _q = "elliptic", Eq = "6.6.0", Sq = "EC cryptography", Aq = "lib/elliptic.js", Pq = [
  "lib"
], Mq = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, Iq = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, Cq = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], Tq = "Fedor Indutny <fedor@indutny.com>", Rq = "MIT", Dq = {
  url: "https://github.com/indutny/elliptic/issues"
}, Oq = "https://github.com/indutny/elliptic", Nq = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, Lq = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, kq = {
  name: _q,
  version: Eq,
  description: Sq,
  main: Aq,
  files: Pq,
  scripts: Mq,
  repository: Iq,
  keywords: Cq,
  author: Tq,
  license: Rq,
  bugs: Dq,
  homepage: Oq,
  devDependencies: Nq,
  dependencies: Lq
};
var ji = {}, hb = { exports: {} };
hb.exports;
(function(t) {
  (function(e, r) {
    function n(Y, A) {
      if (!Y) throw new Error(A || "Assertion failed");
    }
    function i(Y, A) {
      Y.super_ = A;
      var m = function() {
      };
      m.prototype = A.prototype, Y.prototype = new m(), Y.prototype.constructor = Y;
    }
    function s(Y, A, m) {
      if (s.isBN(Y))
        return Y;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, Y !== null && ((A === "le" || A === "be") && (m = A, A = 10), this._init(Y || 0, A || 10, m || "be"));
    }
    typeof e == "object" ? e.exports = s : r.BN = s, s.BN = s, s.wordSize = 26;
    var o;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = Ql.Buffer;
    } catch {
    }
    s.isBN = function(A) {
      return A instanceof s ? !0 : A !== null && typeof A == "object" && A.constructor.wordSize === s.wordSize && Array.isArray(A.words);
    }, s.max = function(A, m) {
      return A.cmp(m) > 0 ? A : m;
    }, s.min = function(A, m) {
      return A.cmp(m) < 0 ? A : m;
    }, s.prototype._init = function(A, m, f) {
      if (typeof A == "number")
        return this._initNumber(A, m, f);
      if (typeof A == "object")
        return this._initArray(A, m, f);
      m === "hex" && (m = 16), n(m === (m | 0) && m >= 2 && m <= 36), A = A.toString().replace(/\s+/g, "");
      var g = 0;
      A[0] === "-" && (g++, this.negative = 1), g < A.length && (m === 16 ? this._parseHex(A, g, f) : (this._parseBase(A, m, g), f === "le" && this._initArray(this.toArray(), m, f)));
    }, s.prototype._initNumber = function(A, m, f) {
      A < 0 && (this.negative = 1, A = -A), A < 67108864 ? (this.words = [A & 67108863], this.length = 1) : A < 4503599627370496 ? (this.words = [
        A & 67108863,
        A / 67108864 & 67108863
      ], this.length = 2) : (n(A < 9007199254740992), this.words = [
        A & 67108863,
        A / 67108864 & 67108863,
        1
      ], this.length = 3), f === "le" && this._initArray(this.toArray(), m, f);
    }, s.prototype._initArray = function(A, m, f) {
      if (n(typeof A.length == "number"), A.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(A.length / 3), this.words = new Array(this.length);
      for (var g = 0; g < this.length; g++)
        this.words[g] = 0;
      var b, x, E = 0;
      if (f === "be")
        for (g = A.length - 1, b = 0; g >= 0; g -= 3)
          x = A[g] | A[g - 1] << 8 | A[g - 2] << 16, this.words[b] |= x << E & 67108863, this.words[b + 1] = x >>> 26 - E & 67108863, E += 24, E >= 26 && (E -= 26, b++);
      else if (f === "le")
        for (g = 0, b = 0; g < A.length; g += 3)
          x = A[g] | A[g + 1] << 8 | A[g + 2] << 16, this.words[b] |= x << E & 67108863, this.words[b + 1] = x >>> 26 - E & 67108863, E += 24, E >= 26 && (E -= 26, b++);
      return this.strip();
    };
    function a(Y, A) {
      var m = Y.charCodeAt(A);
      return m >= 65 && m <= 70 ? m - 55 : m >= 97 && m <= 102 ? m - 87 : m - 48 & 15;
    }
    function u(Y, A, m) {
      var f = a(Y, m);
      return m - 1 >= A && (f |= a(Y, m - 1) << 4), f;
    }
    s.prototype._parseHex = function(A, m, f) {
      this.length = Math.ceil((A.length - m) / 6), this.words = new Array(this.length);
      for (var g = 0; g < this.length; g++)
        this.words[g] = 0;
      var b = 0, x = 0, E;
      if (f === "be")
        for (g = A.length - 1; g >= m; g -= 2)
          E = u(A, m, g) << b, this.words[x] |= E & 67108863, b >= 18 ? (b -= 18, x += 1, this.words[x] |= E >>> 26) : b += 8;
      else {
        var S = A.length - m;
        for (g = S % 2 === 0 ? m + 1 : m; g < A.length; g += 2)
          E = u(A, m, g) << b, this.words[x] |= E & 67108863, b >= 18 ? (b -= 18, x += 1, this.words[x] |= E >>> 26) : b += 8;
      }
      this.strip();
    };
    function l(Y, A, m, f) {
      for (var g = 0, b = Math.min(Y.length, m), x = A; x < b; x++) {
        var E = Y.charCodeAt(x) - 48;
        g *= f, E >= 49 ? g += E - 49 + 10 : E >= 17 ? g += E - 17 + 10 : g += E;
      }
      return g;
    }
    s.prototype._parseBase = function(A, m, f) {
      this.words = [0], this.length = 1;
      for (var g = 0, b = 1; b <= 67108863; b *= m)
        g++;
      g--, b = b / m | 0;
      for (var x = A.length - f, E = x % g, S = Math.min(x, x - E) + f, v = 0, M = f; M < S; M += g)
        v = l(A, M, M + g, m), this.imuln(b), this.words[0] + v < 67108864 ? this.words[0] += v : this._iaddn(v);
      if (E !== 0) {
        var I = 1;
        for (v = l(A, M, A.length, m), M = 0; M < E; M++)
          I *= m;
        this.imuln(I), this.words[0] + v < 67108864 ? this.words[0] += v : this._iaddn(v);
      }
      this.strip();
    }, s.prototype.copy = function(A) {
      A.words = new Array(this.length);
      for (var m = 0; m < this.length; m++)
        A.words[m] = this.words[m];
      A.length = this.length, A.negative = this.negative, A.red = this.red;
    }, s.prototype.clone = function() {
      var A = new s(null);
      return this.copy(A), A;
    }, s.prototype._expand = function(A) {
      for (; this.length < A; )
        this.words[this.length++] = 0;
      return this;
    }, s.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, s.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, s.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var d = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], p = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], w = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    s.prototype.toString = function(A, m) {
      A = A || 10, m = m | 0 || 1;
      var f;
      if (A === 16 || A === "hex") {
        f = "";
        for (var g = 0, b = 0, x = 0; x < this.length; x++) {
          var E = this.words[x], S = ((E << g | b) & 16777215).toString(16);
          b = E >>> 24 - g & 16777215, g += 2, g >= 26 && (g -= 26, x--), b !== 0 || x !== this.length - 1 ? f = d[6 - S.length] + S + f : f = S + f;
        }
        for (b !== 0 && (f = b.toString(16) + f); f.length % m !== 0; )
          f = "0" + f;
        return this.negative !== 0 && (f = "-" + f), f;
      }
      if (A === (A | 0) && A >= 2 && A <= 36) {
        var v = p[A], M = w[A];
        f = "";
        var I = this.clone();
        for (I.negative = 0; !I.isZero(); ) {
          var F = I.modn(M).toString(A);
          I = I.idivn(M), I.isZero() ? f = F + f : f = d[v - F.length] + F + f;
        }
        for (this.isZero() && (f = "0" + f); f.length % m !== 0; )
          f = "0" + f;
        return this.negative !== 0 && (f = "-" + f), f;
      }
      n(!1, "Base should be between 2 and 36");
    }, s.prototype.toNumber = function() {
      var A = this.words[0];
      return this.length === 2 ? A += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? A += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -A : A;
    }, s.prototype.toJSON = function() {
      return this.toString(16);
    }, s.prototype.toBuffer = function(A, m) {
      return n(typeof o < "u"), this.toArrayLike(o, A, m);
    }, s.prototype.toArray = function(A, m) {
      return this.toArrayLike(Array, A, m);
    }, s.prototype.toArrayLike = function(A, m, f) {
      var g = this.byteLength(), b = f || Math.max(1, g);
      n(g <= b, "byte array longer than desired length"), n(b > 0, "Requested array length <= 0"), this.strip();
      var x = m === "le", E = new A(b), S, v, M = this.clone();
      if (x) {
        for (v = 0; !M.isZero(); v++)
          S = M.andln(255), M.iushrn(8), E[v] = S;
        for (; v < b; v++)
          E[v] = 0;
      } else {
        for (v = 0; v < b - g; v++)
          E[v] = 0;
        for (v = 0; !M.isZero(); v++)
          S = M.andln(255), M.iushrn(8), E[b - v - 1] = S;
      }
      return E;
    }, Math.clz32 ? s.prototype._countBits = function(A) {
      return 32 - Math.clz32(A);
    } : s.prototype._countBits = function(A) {
      var m = A, f = 0;
      return m >= 4096 && (f += 13, m >>>= 13), m >= 64 && (f += 7, m >>>= 7), m >= 8 && (f += 4, m >>>= 4), m >= 2 && (f += 2, m >>>= 2), f + m;
    }, s.prototype._zeroBits = function(A) {
      if (A === 0) return 26;
      var m = A, f = 0;
      return m & 8191 || (f += 13, m >>>= 13), m & 127 || (f += 7, m >>>= 7), m & 15 || (f += 4, m >>>= 4), m & 3 || (f += 2, m >>>= 2), m & 1 || f++, f;
    }, s.prototype.bitLength = function() {
      var A = this.words[this.length - 1], m = this._countBits(A);
      return (this.length - 1) * 26 + m;
    };
    function _(Y) {
      for (var A = new Array(Y.bitLength()), m = 0; m < A.length; m++) {
        var f = m / 26 | 0, g = m % 26;
        A[m] = (Y.words[f] & 1 << g) >>> g;
      }
      return A;
    }
    s.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var A = 0, m = 0; m < this.length; m++) {
        var f = this._zeroBits(this.words[m]);
        if (A += f, f !== 26) break;
      }
      return A;
    }, s.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, s.prototype.toTwos = function(A) {
      return this.negative !== 0 ? this.abs().inotn(A).iaddn(1) : this.clone();
    }, s.prototype.fromTwos = function(A) {
      return this.testn(A - 1) ? this.notn(A).iaddn(1).ineg() : this.clone();
    }, s.prototype.isNeg = function() {
      return this.negative !== 0;
    }, s.prototype.neg = function() {
      return this.clone().ineg();
    }, s.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, s.prototype.iuor = function(A) {
      for (; this.length < A.length; )
        this.words[this.length++] = 0;
      for (var m = 0; m < A.length; m++)
        this.words[m] = this.words[m] | A.words[m];
      return this.strip();
    }, s.prototype.ior = function(A) {
      return n((this.negative | A.negative) === 0), this.iuor(A);
    }, s.prototype.or = function(A) {
      return this.length > A.length ? this.clone().ior(A) : A.clone().ior(this);
    }, s.prototype.uor = function(A) {
      return this.length > A.length ? this.clone().iuor(A) : A.clone().iuor(this);
    }, s.prototype.iuand = function(A) {
      var m;
      this.length > A.length ? m = A : m = this;
      for (var f = 0; f < m.length; f++)
        this.words[f] = this.words[f] & A.words[f];
      return this.length = m.length, this.strip();
    }, s.prototype.iand = function(A) {
      return n((this.negative | A.negative) === 0), this.iuand(A);
    }, s.prototype.and = function(A) {
      return this.length > A.length ? this.clone().iand(A) : A.clone().iand(this);
    }, s.prototype.uand = function(A) {
      return this.length > A.length ? this.clone().iuand(A) : A.clone().iuand(this);
    }, s.prototype.iuxor = function(A) {
      var m, f;
      this.length > A.length ? (m = this, f = A) : (m = A, f = this);
      for (var g = 0; g < f.length; g++)
        this.words[g] = m.words[g] ^ f.words[g];
      if (this !== m)
        for (; g < m.length; g++)
          this.words[g] = m.words[g];
      return this.length = m.length, this.strip();
    }, s.prototype.ixor = function(A) {
      return n((this.negative | A.negative) === 0), this.iuxor(A);
    }, s.prototype.xor = function(A) {
      return this.length > A.length ? this.clone().ixor(A) : A.clone().ixor(this);
    }, s.prototype.uxor = function(A) {
      return this.length > A.length ? this.clone().iuxor(A) : A.clone().iuxor(this);
    }, s.prototype.inotn = function(A) {
      n(typeof A == "number" && A >= 0);
      var m = Math.ceil(A / 26) | 0, f = A % 26;
      this._expand(m), f > 0 && m--;
      for (var g = 0; g < m; g++)
        this.words[g] = ~this.words[g] & 67108863;
      return f > 0 && (this.words[g] = ~this.words[g] & 67108863 >> 26 - f), this.strip();
    }, s.prototype.notn = function(A) {
      return this.clone().inotn(A);
    }, s.prototype.setn = function(A, m) {
      n(typeof A == "number" && A >= 0);
      var f = A / 26 | 0, g = A % 26;
      return this._expand(f + 1), m ? this.words[f] = this.words[f] | 1 << g : this.words[f] = this.words[f] & ~(1 << g), this.strip();
    }, s.prototype.iadd = function(A) {
      var m;
      if (this.negative !== 0 && A.negative === 0)
        return this.negative = 0, m = this.isub(A), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && A.negative !== 0)
        return A.negative = 0, m = this.isub(A), A.negative = 1, m._normSign();
      var f, g;
      this.length > A.length ? (f = this, g = A) : (f = A, g = this);
      for (var b = 0, x = 0; x < g.length; x++)
        m = (f.words[x] | 0) + (g.words[x] | 0) + b, this.words[x] = m & 67108863, b = m >>> 26;
      for (; b !== 0 && x < f.length; x++)
        m = (f.words[x] | 0) + b, this.words[x] = m & 67108863, b = m >>> 26;
      if (this.length = f.length, b !== 0)
        this.words[this.length] = b, this.length++;
      else if (f !== this)
        for (; x < f.length; x++)
          this.words[x] = f.words[x];
      return this;
    }, s.prototype.add = function(A) {
      var m;
      return A.negative !== 0 && this.negative === 0 ? (A.negative = 0, m = this.sub(A), A.negative ^= 1, m) : A.negative === 0 && this.negative !== 0 ? (this.negative = 0, m = A.sub(this), this.negative = 1, m) : this.length > A.length ? this.clone().iadd(A) : A.clone().iadd(this);
    }, s.prototype.isub = function(A) {
      if (A.negative !== 0) {
        A.negative = 0;
        var m = this.iadd(A);
        return A.negative = 1, m._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(A), this.negative = 1, this._normSign();
      var f = this.cmp(A);
      if (f === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var g, b;
      f > 0 ? (g = this, b = A) : (g = A, b = this);
      for (var x = 0, E = 0; E < b.length; E++)
        m = (g.words[E] | 0) - (b.words[E] | 0) + x, x = m >> 26, this.words[E] = m & 67108863;
      for (; x !== 0 && E < g.length; E++)
        m = (g.words[E] | 0) + x, x = m >> 26, this.words[E] = m & 67108863;
      if (x === 0 && E < g.length && g !== this)
        for (; E < g.length; E++)
          this.words[E] = g.words[E];
      return this.length = Math.max(this.length, E), g !== this && (this.negative = 1), this.strip();
    }, s.prototype.sub = function(A) {
      return this.clone().isub(A);
    };
    function P(Y, A, m) {
      m.negative = A.negative ^ Y.negative;
      var f = Y.length + A.length | 0;
      m.length = f, f = f - 1 | 0;
      var g = Y.words[0] | 0, b = A.words[0] | 0, x = g * b, E = x & 67108863, S = x / 67108864 | 0;
      m.words[0] = E;
      for (var v = 1; v < f; v++) {
        for (var M = S >>> 26, I = S & 67108863, F = Math.min(v, A.length - 1), ce = Math.max(0, v - Y.length + 1); ce <= F; ce++) {
          var D = v - ce | 0;
          g = Y.words[D] | 0, b = A.words[ce] | 0, x = g * b + I, M += x / 67108864 | 0, I = x & 67108863;
        }
        m.words[v] = I | 0, S = M | 0;
      }
      return S !== 0 ? m.words[v] = S | 0 : m.length--, m.strip();
    }
    var O = function(A, m, f) {
      var g = A.words, b = m.words, x = f.words, E = 0, S, v, M, I = g[0] | 0, F = I & 8191, ce = I >>> 13, D = g[1] | 0, oe = D & 8191, Z = D >>> 13, J = g[2] | 0, ee = J & 8191, T = J >>> 13, X = g[3] | 0, re = X & 8191, pe = X >>> 13, ie = g[4] | 0, ue = ie & 8191, ve = ie >>> 13, Pe = g[5] | 0, De = Pe & 8191, Ce = Pe >>> 13, $e = g[6] | 0, Me = $e & 8191, Ne = $e >>> 13, Ke = g[7] | 0, Le = Ke & 8191, qe = Ke >>> 13, ze = g[8] | 0, _e = ze & 8191, Ze = ze >>> 13, at = g[9] | 0, ke = at & 8191, Qe = at >>> 13, tt = b[0] | 0, Ye = tt & 8191, dt = tt >>> 13, lt = b[1] | 0, ct = lt & 8191, qt = lt >>> 13, Jt = b[2] | 0, Et = Jt & 8191, er = Jt >>> 13, Xt = b[3] | 0, Dt = Xt & 8191, kt = Xt >>> 13, Ct = b[4] | 0, mt = Ct & 8191, Rt = Ct >>> 13, Nt = b[5] | 0, bt = Nt & 8191, $t = Nt >>> 13, Ft = b[6] | 0, rt = Ft & 8191, Bt = Ft >>> 13, $ = b[7] | 0, z = $ & 8191, H = $ >>> 13, C = b[8] | 0, G = C & 8191, j = C >>> 13, se = b[9] | 0, de = se & 8191, xe = se >>> 13;
      f.negative = A.negative ^ m.negative, f.length = 19, S = Math.imul(F, Ye), v = Math.imul(F, dt), v = v + Math.imul(ce, Ye) | 0, M = Math.imul(ce, dt);
      var Te = (E + S | 0) + ((v & 8191) << 13) | 0;
      E = (M + (v >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, S = Math.imul(oe, Ye), v = Math.imul(oe, dt), v = v + Math.imul(Z, Ye) | 0, M = Math.imul(Z, dt), S = S + Math.imul(F, ct) | 0, v = v + Math.imul(F, qt) | 0, v = v + Math.imul(ce, ct) | 0, M = M + Math.imul(ce, qt) | 0;
      var Re = (E + S | 0) + ((v & 8191) << 13) | 0;
      E = (M + (v >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, S = Math.imul(ee, Ye), v = Math.imul(ee, dt), v = v + Math.imul(T, Ye) | 0, M = Math.imul(T, dt), S = S + Math.imul(oe, ct) | 0, v = v + Math.imul(oe, qt) | 0, v = v + Math.imul(Z, ct) | 0, M = M + Math.imul(Z, qt) | 0, S = S + Math.imul(F, Et) | 0, v = v + Math.imul(F, er) | 0, v = v + Math.imul(ce, Et) | 0, M = M + Math.imul(ce, er) | 0;
      var nt = (E + S | 0) + ((v & 8191) << 13) | 0;
      E = (M + (v >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, S = Math.imul(re, Ye), v = Math.imul(re, dt), v = v + Math.imul(pe, Ye) | 0, M = Math.imul(pe, dt), S = S + Math.imul(ee, ct) | 0, v = v + Math.imul(ee, qt) | 0, v = v + Math.imul(T, ct) | 0, M = M + Math.imul(T, qt) | 0, S = S + Math.imul(oe, Et) | 0, v = v + Math.imul(oe, er) | 0, v = v + Math.imul(Z, Et) | 0, M = M + Math.imul(Z, er) | 0, S = S + Math.imul(F, Dt) | 0, v = v + Math.imul(F, kt) | 0, v = v + Math.imul(ce, Dt) | 0, M = M + Math.imul(ce, kt) | 0;
      var je = (E + S | 0) + ((v & 8191) << 13) | 0;
      E = (M + (v >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, S = Math.imul(ue, Ye), v = Math.imul(ue, dt), v = v + Math.imul(ve, Ye) | 0, M = Math.imul(ve, dt), S = S + Math.imul(re, ct) | 0, v = v + Math.imul(re, qt) | 0, v = v + Math.imul(pe, ct) | 0, M = M + Math.imul(pe, qt) | 0, S = S + Math.imul(ee, Et) | 0, v = v + Math.imul(ee, er) | 0, v = v + Math.imul(T, Et) | 0, M = M + Math.imul(T, er) | 0, S = S + Math.imul(oe, Dt) | 0, v = v + Math.imul(oe, kt) | 0, v = v + Math.imul(Z, Dt) | 0, M = M + Math.imul(Z, kt) | 0, S = S + Math.imul(F, mt) | 0, v = v + Math.imul(F, Rt) | 0, v = v + Math.imul(ce, mt) | 0, M = M + Math.imul(ce, Rt) | 0;
      var pt = (E + S | 0) + ((v & 8191) << 13) | 0;
      E = (M + (v >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, S = Math.imul(De, Ye), v = Math.imul(De, dt), v = v + Math.imul(Ce, Ye) | 0, M = Math.imul(Ce, dt), S = S + Math.imul(ue, ct) | 0, v = v + Math.imul(ue, qt) | 0, v = v + Math.imul(ve, ct) | 0, M = M + Math.imul(ve, qt) | 0, S = S + Math.imul(re, Et) | 0, v = v + Math.imul(re, er) | 0, v = v + Math.imul(pe, Et) | 0, M = M + Math.imul(pe, er) | 0, S = S + Math.imul(ee, Dt) | 0, v = v + Math.imul(ee, kt) | 0, v = v + Math.imul(T, Dt) | 0, M = M + Math.imul(T, kt) | 0, S = S + Math.imul(oe, mt) | 0, v = v + Math.imul(oe, Rt) | 0, v = v + Math.imul(Z, mt) | 0, M = M + Math.imul(Z, Rt) | 0, S = S + Math.imul(F, bt) | 0, v = v + Math.imul(F, $t) | 0, v = v + Math.imul(ce, bt) | 0, M = M + Math.imul(ce, $t) | 0;
      var it = (E + S | 0) + ((v & 8191) << 13) | 0;
      E = (M + (v >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, S = Math.imul(Me, Ye), v = Math.imul(Me, dt), v = v + Math.imul(Ne, Ye) | 0, M = Math.imul(Ne, dt), S = S + Math.imul(De, ct) | 0, v = v + Math.imul(De, qt) | 0, v = v + Math.imul(Ce, ct) | 0, M = M + Math.imul(Ce, qt) | 0, S = S + Math.imul(ue, Et) | 0, v = v + Math.imul(ue, er) | 0, v = v + Math.imul(ve, Et) | 0, M = M + Math.imul(ve, er) | 0, S = S + Math.imul(re, Dt) | 0, v = v + Math.imul(re, kt) | 0, v = v + Math.imul(pe, Dt) | 0, M = M + Math.imul(pe, kt) | 0, S = S + Math.imul(ee, mt) | 0, v = v + Math.imul(ee, Rt) | 0, v = v + Math.imul(T, mt) | 0, M = M + Math.imul(T, Rt) | 0, S = S + Math.imul(oe, bt) | 0, v = v + Math.imul(oe, $t) | 0, v = v + Math.imul(Z, bt) | 0, M = M + Math.imul(Z, $t) | 0, S = S + Math.imul(F, rt) | 0, v = v + Math.imul(F, Bt) | 0, v = v + Math.imul(ce, rt) | 0, M = M + Math.imul(ce, Bt) | 0;
      var et = (E + S | 0) + ((v & 8191) << 13) | 0;
      E = (M + (v >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, S = Math.imul(Le, Ye), v = Math.imul(Le, dt), v = v + Math.imul(qe, Ye) | 0, M = Math.imul(qe, dt), S = S + Math.imul(Me, ct) | 0, v = v + Math.imul(Me, qt) | 0, v = v + Math.imul(Ne, ct) | 0, M = M + Math.imul(Ne, qt) | 0, S = S + Math.imul(De, Et) | 0, v = v + Math.imul(De, er) | 0, v = v + Math.imul(Ce, Et) | 0, M = M + Math.imul(Ce, er) | 0, S = S + Math.imul(ue, Dt) | 0, v = v + Math.imul(ue, kt) | 0, v = v + Math.imul(ve, Dt) | 0, M = M + Math.imul(ve, kt) | 0, S = S + Math.imul(re, mt) | 0, v = v + Math.imul(re, Rt) | 0, v = v + Math.imul(pe, mt) | 0, M = M + Math.imul(pe, Rt) | 0, S = S + Math.imul(ee, bt) | 0, v = v + Math.imul(ee, $t) | 0, v = v + Math.imul(T, bt) | 0, M = M + Math.imul(T, $t) | 0, S = S + Math.imul(oe, rt) | 0, v = v + Math.imul(oe, Bt) | 0, v = v + Math.imul(Z, rt) | 0, M = M + Math.imul(Z, Bt) | 0, S = S + Math.imul(F, z) | 0, v = v + Math.imul(F, H) | 0, v = v + Math.imul(ce, z) | 0, M = M + Math.imul(ce, H) | 0;
      var St = (E + S | 0) + ((v & 8191) << 13) | 0;
      E = (M + (v >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, S = Math.imul(_e, Ye), v = Math.imul(_e, dt), v = v + Math.imul(Ze, Ye) | 0, M = Math.imul(Ze, dt), S = S + Math.imul(Le, ct) | 0, v = v + Math.imul(Le, qt) | 0, v = v + Math.imul(qe, ct) | 0, M = M + Math.imul(qe, qt) | 0, S = S + Math.imul(Me, Et) | 0, v = v + Math.imul(Me, er) | 0, v = v + Math.imul(Ne, Et) | 0, M = M + Math.imul(Ne, er) | 0, S = S + Math.imul(De, Dt) | 0, v = v + Math.imul(De, kt) | 0, v = v + Math.imul(Ce, Dt) | 0, M = M + Math.imul(Ce, kt) | 0, S = S + Math.imul(ue, mt) | 0, v = v + Math.imul(ue, Rt) | 0, v = v + Math.imul(ve, mt) | 0, M = M + Math.imul(ve, Rt) | 0, S = S + Math.imul(re, bt) | 0, v = v + Math.imul(re, $t) | 0, v = v + Math.imul(pe, bt) | 0, M = M + Math.imul(pe, $t) | 0, S = S + Math.imul(ee, rt) | 0, v = v + Math.imul(ee, Bt) | 0, v = v + Math.imul(T, rt) | 0, M = M + Math.imul(T, Bt) | 0, S = S + Math.imul(oe, z) | 0, v = v + Math.imul(oe, H) | 0, v = v + Math.imul(Z, z) | 0, M = M + Math.imul(Z, H) | 0, S = S + Math.imul(F, G) | 0, v = v + Math.imul(F, j) | 0, v = v + Math.imul(ce, G) | 0, M = M + Math.imul(ce, j) | 0;
      var Tt = (E + S | 0) + ((v & 8191) << 13) | 0;
      E = (M + (v >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, S = Math.imul(ke, Ye), v = Math.imul(ke, dt), v = v + Math.imul(Qe, Ye) | 0, M = Math.imul(Qe, dt), S = S + Math.imul(_e, ct) | 0, v = v + Math.imul(_e, qt) | 0, v = v + Math.imul(Ze, ct) | 0, M = M + Math.imul(Ze, qt) | 0, S = S + Math.imul(Le, Et) | 0, v = v + Math.imul(Le, er) | 0, v = v + Math.imul(qe, Et) | 0, M = M + Math.imul(qe, er) | 0, S = S + Math.imul(Me, Dt) | 0, v = v + Math.imul(Me, kt) | 0, v = v + Math.imul(Ne, Dt) | 0, M = M + Math.imul(Ne, kt) | 0, S = S + Math.imul(De, mt) | 0, v = v + Math.imul(De, Rt) | 0, v = v + Math.imul(Ce, mt) | 0, M = M + Math.imul(Ce, Rt) | 0, S = S + Math.imul(ue, bt) | 0, v = v + Math.imul(ue, $t) | 0, v = v + Math.imul(ve, bt) | 0, M = M + Math.imul(ve, $t) | 0, S = S + Math.imul(re, rt) | 0, v = v + Math.imul(re, Bt) | 0, v = v + Math.imul(pe, rt) | 0, M = M + Math.imul(pe, Bt) | 0, S = S + Math.imul(ee, z) | 0, v = v + Math.imul(ee, H) | 0, v = v + Math.imul(T, z) | 0, M = M + Math.imul(T, H) | 0, S = S + Math.imul(oe, G) | 0, v = v + Math.imul(oe, j) | 0, v = v + Math.imul(Z, G) | 0, M = M + Math.imul(Z, j) | 0, S = S + Math.imul(F, de) | 0, v = v + Math.imul(F, xe) | 0, v = v + Math.imul(ce, de) | 0, M = M + Math.imul(ce, xe) | 0;
      var At = (E + S | 0) + ((v & 8191) << 13) | 0;
      E = (M + (v >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, S = Math.imul(ke, ct), v = Math.imul(ke, qt), v = v + Math.imul(Qe, ct) | 0, M = Math.imul(Qe, qt), S = S + Math.imul(_e, Et) | 0, v = v + Math.imul(_e, er) | 0, v = v + Math.imul(Ze, Et) | 0, M = M + Math.imul(Ze, er) | 0, S = S + Math.imul(Le, Dt) | 0, v = v + Math.imul(Le, kt) | 0, v = v + Math.imul(qe, Dt) | 0, M = M + Math.imul(qe, kt) | 0, S = S + Math.imul(Me, mt) | 0, v = v + Math.imul(Me, Rt) | 0, v = v + Math.imul(Ne, mt) | 0, M = M + Math.imul(Ne, Rt) | 0, S = S + Math.imul(De, bt) | 0, v = v + Math.imul(De, $t) | 0, v = v + Math.imul(Ce, bt) | 0, M = M + Math.imul(Ce, $t) | 0, S = S + Math.imul(ue, rt) | 0, v = v + Math.imul(ue, Bt) | 0, v = v + Math.imul(ve, rt) | 0, M = M + Math.imul(ve, Bt) | 0, S = S + Math.imul(re, z) | 0, v = v + Math.imul(re, H) | 0, v = v + Math.imul(pe, z) | 0, M = M + Math.imul(pe, H) | 0, S = S + Math.imul(ee, G) | 0, v = v + Math.imul(ee, j) | 0, v = v + Math.imul(T, G) | 0, M = M + Math.imul(T, j) | 0, S = S + Math.imul(oe, de) | 0, v = v + Math.imul(oe, xe) | 0, v = v + Math.imul(Z, de) | 0, M = M + Math.imul(Z, xe) | 0;
      var _t = (E + S | 0) + ((v & 8191) << 13) | 0;
      E = (M + (v >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, S = Math.imul(ke, Et), v = Math.imul(ke, er), v = v + Math.imul(Qe, Et) | 0, M = Math.imul(Qe, er), S = S + Math.imul(_e, Dt) | 0, v = v + Math.imul(_e, kt) | 0, v = v + Math.imul(Ze, Dt) | 0, M = M + Math.imul(Ze, kt) | 0, S = S + Math.imul(Le, mt) | 0, v = v + Math.imul(Le, Rt) | 0, v = v + Math.imul(qe, mt) | 0, M = M + Math.imul(qe, Rt) | 0, S = S + Math.imul(Me, bt) | 0, v = v + Math.imul(Me, $t) | 0, v = v + Math.imul(Ne, bt) | 0, M = M + Math.imul(Ne, $t) | 0, S = S + Math.imul(De, rt) | 0, v = v + Math.imul(De, Bt) | 0, v = v + Math.imul(Ce, rt) | 0, M = M + Math.imul(Ce, Bt) | 0, S = S + Math.imul(ue, z) | 0, v = v + Math.imul(ue, H) | 0, v = v + Math.imul(ve, z) | 0, M = M + Math.imul(ve, H) | 0, S = S + Math.imul(re, G) | 0, v = v + Math.imul(re, j) | 0, v = v + Math.imul(pe, G) | 0, M = M + Math.imul(pe, j) | 0, S = S + Math.imul(ee, de) | 0, v = v + Math.imul(ee, xe) | 0, v = v + Math.imul(T, de) | 0, M = M + Math.imul(T, xe) | 0;
      var ht = (E + S | 0) + ((v & 8191) << 13) | 0;
      E = (M + (v >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, S = Math.imul(ke, Dt), v = Math.imul(ke, kt), v = v + Math.imul(Qe, Dt) | 0, M = Math.imul(Qe, kt), S = S + Math.imul(_e, mt) | 0, v = v + Math.imul(_e, Rt) | 0, v = v + Math.imul(Ze, mt) | 0, M = M + Math.imul(Ze, Rt) | 0, S = S + Math.imul(Le, bt) | 0, v = v + Math.imul(Le, $t) | 0, v = v + Math.imul(qe, bt) | 0, M = M + Math.imul(qe, $t) | 0, S = S + Math.imul(Me, rt) | 0, v = v + Math.imul(Me, Bt) | 0, v = v + Math.imul(Ne, rt) | 0, M = M + Math.imul(Ne, Bt) | 0, S = S + Math.imul(De, z) | 0, v = v + Math.imul(De, H) | 0, v = v + Math.imul(Ce, z) | 0, M = M + Math.imul(Ce, H) | 0, S = S + Math.imul(ue, G) | 0, v = v + Math.imul(ue, j) | 0, v = v + Math.imul(ve, G) | 0, M = M + Math.imul(ve, j) | 0, S = S + Math.imul(re, de) | 0, v = v + Math.imul(re, xe) | 0, v = v + Math.imul(pe, de) | 0, M = M + Math.imul(pe, xe) | 0;
      var xt = (E + S | 0) + ((v & 8191) << 13) | 0;
      E = (M + (v >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, S = Math.imul(ke, mt), v = Math.imul(ke, Rt), v = v + Math.imul(Qe, mt) | 0, M = Math.imul(Qe, Rt), S = S + Math.imul(_e, bt) | 0, v = v + Math.imul(_e, $t) | 0, v = v + Math.imul(Ze, bt) | 0, M = M + Math.imul(Ze, $t) | 0, S = S + Math.imul(Le, rt) | 0, v = v + Math.imul(Le, Bt) | 0, v = v + Math.imul(qe, rt) | 0, M = M + Math.imul(qe, Bt) | 0, S = S + Math.imul(Me, z) | 0, v = v + Math.imul(Me, H) | 0, v = v + Math.imul(Ne, z) | 0, M = M + Math.imul(Ne, H) | 0, S = S + Math.imul(De, G) | 0, v = v + Math.imul(De, j) | 0, v = v + Math.imul(Ce, G) | 0, M = M + Math.imul(Ce, j) | 0, S = S + Math.imul(ue, de) | 0, v = v + Math.imul(ue, xe) | 0, v = v + Math.imul(ve, de) | 0, M = M + Math.imul(ve, xe) | 0;
      var st = (E + S | 0) + ((v & 8191) << 13) | 0;
      E = (M + (v >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, S = Math.imul(ke, bt), v = Math.imul(ke, $t), v = v + Math.imul(Qe, bt) | 0, M = Math.imul(Qe, $t), S = S + Math.imul(_e, rt) | 0, v = v + Math.imul(_e, Bt) | 0, v = v + Math.imul(Ze, rt) | 0, M = M + Math.imul(Ze, Bt) | 0, S = S + Math.imul(Le, z) | 0, v = v + Math.imul(Le, H) | 0, v = v + Math.imul(qe, z) | 0, M = M + Math.imul(qe, H) | 0, S = S + Math.imul(Me, G) | 0, v = v + Math.imul(Me, j) | 0, v = v + Math.imul(Ne, G) | 0, M = M + Math.imul(Ne, j) | 0, S = S + Math.imul(De, de) | 0, v = v + Math.imul(De, xe) | 0, v = v + Math.imul(Ce, de) | 0, M = M + Math.imul(Ce, xe) | 0;
      var yt = (E + S | 0) + ((v & 8191) << 13) | 0;
      E = (M + (v >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, S = Math.imul(ke, rt), v = Math.imul(ke, Bt), v = v + Math.imul(Qe, rt) | 0, M = Math.imul(Qe, Bt), S = S + Math.imul(_e, z) | 0, v = v + Math.imul(_e, H) | 0, v = v + Math.imul(Ze, z) | 0, M = M + Math.imul(Ze, H) | 0, S = S + Math.imul(Le, G) | 0, v = v + Math.imul(Le, j) | 0, v = v + Math.imul(qe, G) | 0, M = M + Math.imul(qe, j) | 0, S = S + Math.imul(Me, de) | 0, v = v + Math.imul(Me, xe) | 0, v = v + Math.imul(Ne, de) | 0, M = M + Math.imul(Ne, xe) | 0;
      var ut = (E + S | 0) + ((v & 8191) << 13) | 0;
      E = (M + (v >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, S = Math.imul(ke, z), v = Math.imul(ke, H), v = v + Math.imul(Qe, z) | 0, M = Math.imul(Qe, H), S = S + Math.imul(_e, G) | 0, v = v + Math.imul(_e, j) | 0, v = v + Math.imul(Ze, G) | 0, M = M + Math.imul(Ze, j) | 0, S = S + Math.imul(Le, de) | 0, v = v + Math.imul(Le, xe) | 0, v = v + Math.imul(qe, de) | 0, M = M + Math.imul(qe, xe) | 0;
      var ot = (E + S | 0) + ((v & 8191) << 13) | 0;
      E = (M + (v >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, S = Math.imul(ke, G), v = Math.imul(ke, j), v = v + Math.imul(Qe, G) | 0, M = Math.imul(Qe, j), S = S + Math.imul(_e, de) | 0, v = v + Math.imul(_e, xe) | 0, v = v + Math.imul(Ze, de) | 0, M = M + Math.imul(Ze, xe) | 0;
      var Se = (E + S | 0) + ((v & 8191) << 13) | 0;
      E = (M + (v >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, S = Math.imul(ke, de), v = Math.imul(ke, xe), v = v + Math.imul(Qe, de) | 0, M = Math.imul(Qe, xe);
      var Ae = (E + S | 0) + ((v & 8191) << 13) | 0;
      return E = (M + (v >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, x[0] = Te, x[1] = Re, x[2] = nt, x[3] = je, x[4] = pt, x[5] = it, x[6] = et, x[7] = St, x[8] = Tt, x[9] = At, x[10] = _t, x[11] = ht, x[12] = xt, x[13] = st, x[14] = yt, x[15] = ut, x[16] = ot, x[17] = Se, x[18] = Ae, E !== 0 && (x[19] = E, f.length++), f;
    };
    Math.imul || (O = P);
    function L(Y, A, m) {
      m.negative = A.negative ^ Y.negative, m.length = Y.length + A.length;
      for (var f = 0, g = 0, b = 0; b < m.length - 1; b++) {
        var x = g;
        g = 0;
        for (var E = f & 67108863, S = Math.min(b, A.length - 1), v = Math.max(0, b - Y.length + 1); v <= S; v++) {
          var M = b - v, I = Y.words[M] | 0, F = A.words[v] | 0, ce = I * F, D = ce & 67108863;
          x = x + (ce / 67108864 | 0) | 0, D = D + E | 0, E = D & 67108863, x = x + (D >>> 26) | 0, g += x >>> 26, x &= 67108863;
        }
        m.words[b] = E, f = x, x = g;
      }
      return f !== 0 ? m.words[b] = f : m.length--, m.strip();
    }
    function B(Y, A, m) {
      var f = new k();
      return f.mulp(Y, A, m);
    }
    s.prototype.mulTo = function(A, m) {
      var f, g = this.length + A.length;
      return this.length === 10 && A.length === 10 ? f = O(this, A, m) : g < 63 ? f = P(this, A, m) : g < 1024 ? f = L(this, A, m) : f = B(this, A, m), f;
    };
    function k(Y, A) {
      this.x = Y, this.y = A;
    }
    k.prototype.makeRBT = function(A) {
      for (var m = new Array(A), f = s.prototype._countBits(A) - 1, g = 0; g < A; g++)
        m[g] = this.revBin(g, f, A);
      return m;
    }, k.prototype.revBin = function(A, m, f) {
      if (A === 0 || A === f - 1) return A;
      for (var g = 0, b = 0; b < m; b++)
        g |= (A & 1) << m - b - 1, A >>= 1;
      return g;
    }, k.prototype.permute = function(A, m, f, g, b, x) {
      for (var E = 0; E < x; E++)
        g[E] = m[A[E]], b[E] = f[A[E]];
    }, k.prototype.transform = function(A, m, f, g, b, x) {
      this.permute(x, A, m, f, g, b);
      for (var E = 1; E < b; E <<= 1)
        for (var S = E << 1, v = Math.cos(2 * Math.PI / S), M = Math.sin(2 * Math.PI / S), I = 0; I < b; I += S)
          for (var F = v, ce = M, D = 0; D < E; D++) {
            var oe = f[I + D], Z = g[I + D], J = f[I + D + E], ee = g[I + D + E], T = F * J - ce * ee;
            ee = F * ee + ce * J, J = T, f[I + D] = oe + J, g[I + D] = Z + ee, f[I + D + E] = oe - J, g[I + D + E] = Z - ee, D !== S && (T = v * F - M * ce, ce = v * ce + M * F, F = T);
          }
    }, k.prototype.guessLen13b = function(A, m) {
      var f = Math.max(m, A) | 1, g = f & 1, b = 0;
      for (f = f / 2 | 0; f; f = f >>> 1)
        b++;
      return 1 << b + 1 + g;
    }, k.prototype.conjugate = function(A, m, f) {
      if (!(f <= 1))
        for (var g = 0; g < f / 2; g++) {
          var b = A[g];
          A[g] = A[f - g - 1], A[f - g - 1] = b, b = m[g], m[g] = -m[f - g - 1], m[f - g - 1] = -b;
        }
    }, k.prototype.normalize13b = function(A, m) {
      for (var f = 0, g = 0; g < m / 2; g++) {
        var b = Math.round(A[2 * g + 1] / m) * 8192 + Math.round(A[2 * g] / m) + f;
        A[g] = b & 67108863, b < 67108864 ? f = 0 : f = b / 67108864 | 0;
      }
      return A;
    }, k.prototype.convert13b = function(A, m, f, g) {
      for (var b = 0, x = 0; x < m; x++)
        b = b + (A[x] | 0), f[2 * x] = b & 8191, b = b >>> 13, f[2 * x + 1] = b & 8191, b = b >>> 13;
      for (x = 2 * m; x < g; ++x)
        f[x] = 0;
      n(b === 0), n((b & -8192) === 0);
    }, k.prototype.stub = function(A) {
      for (var m = new Array(A), f = 0; f < A; f++)
        m[f] = 0;
      return m;
    }, k.prototype.mulp = function(A, m, f) {
      var g = 2 * this.guessLen13b(A.length, m.length), b = this.makeRBT(g), x = this.stub(g), E = new Array(g), S = new Array(g), v = new Array(g), M = new Array(g), I = new Array(g), F = new Array(g), ce = f.words;
      ce.length = g, this.convert13b(A.words, A.length, E, g), this.convert13b(m.words, m.length, M, g), this.transform(E, x, S, v, g, b), this.transform(M, x, I, F, g, b);
      for (var D = 0; D < g; D++) {
        var oe = S[D] * I[D] - v[D] * F[D];
        v[D] = S[D] * F[D] + v[D] * I[D], S[D] = oe;
      }
      return this.conjugate(S, v, g), this.transform(S, v, ce, x, g, b), this.conjugate(ce, x, g), this.normalize13b(ce, g), f.negative = A.negative ^ m.negative, f.length = A.length + m.length, f.strip();
    }, s.prototype.mul = function(A) {
      var m = new s(null);
      return m.words = new Array(this.length + A.length), this.mulTo(A, m);
    }, s.prototype.mulf = function(A) {
      var m = new s(null);
      return m.words = new Array(this.length + A.length), B(this, A, m);
    }, s.prototype.imul = function(A) {
      return this.clone().mulTo(A, this);
    }, s.prototype.imuln = function(A) {
      n(typeof A == "number"), n(A < 67108864);
      for (var m = 0, f = 0; f < this.length; f++) {
        var g = (this.words[f] | 0) * A, b = (g & 67108863) + (m & 67108863);
        m >>= 26, m += g / 67108864 | 0, m += b >>> 26, this.words[f] = b & 67108863;
      }
      return m !== 0 && (this.words[f] = m, this.length++), this;
    }, s.prototype.muln = function(A) {
      return this.clone().imuln(A);
    }, s.prototype.sqr = function() {
      return this.mul(this);
    }, s.prototype.isqr = function() {
      return this.imul(this.clone());
    }, s.prototype.pow = function(A) {
      var m = _(A);
      if (m.length === 0) return new s(1);
      for (var f = this, g = 0; g < m.length && m[g] === 0; g++, f = f.sqr())
        ;
      if (++g < m.length)
        for (var b = f.sqr(); g < m.length; g++, b = b.sqr())
          m[g] !== 0 && (f = f.mul(b));
      return f;
    }, s.prototype.iushln = function(A) {
      n(typeof A == "number" && A >= 0);
      var m = A % 26, f = (A - m) / 26, g = 67108863 >>> 26 - m << 26 - m, b;
      if (m !== 0) {
        var x = 0;
        for (b = 0; b < this.length; b++) {
          var E = this.words[b] & g, S = (this.words[b] | 0) - E << m;
          this.words[b] = S | x, x = E >>> 26 - m;
        }
        x && (this.words[b] = x, this.length++);
      }
      if (f !== 0) {
        for (b = this.length - 1; b >= 0; b--)
          this.words[b + f] = this.words[b];
        for (b = 0; b < f; b++)
          this.words[b] = 0;
        this.length += f;
      }
      return this.strip();
    }, s.prototype.ishln = function(A) {
      return n(this.negative === 0), this.iushln(A);
    }, s.prototype.iushrn = function(A, m, f) {
      n(typeof A == "number" && A >= 0);
      var g;
      m ? g = (m - m % 26) / 26 : g = 0;
      var b = A % 26, x = Math.min((A - b) / 26, this.length), E = 67108863 ^ 67108863 >>> b << b, S = f;
      if (g -= x, g = Math.max(0, g), S) {
        for (var v = 0; v < x; v++)
          S.words[v] = this.words[v];
        S.length = x;
      }
      if (x !== 0) if (this.length > x)
        for (this.length -= x, v = 0; v < this.length; v++)
          this.words[v] = this.words[v + x];
      else
        this.words[0] = 0, this.length = 1;
      var M = 0;
      for (v = this.length - 1; v >= 0 && (M !== 0 || v >= g); v--) {
        var I = this.words[v] | 0;
        this.words[v] = M << 26 - b | I >>> b, M = I & E;
      }
      return S && M !== 0 && (S.words[S.length++] = M), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, s.prototype.ishrn = function(A, m, f) {
      return n(this.negative === 0), this.iushrn(A, m, f);
    }, s.prototype.shln = function(A) {
      return this.clone().ishln(A);
    }, s.prototype.ushln = function(A) {
      return this.clone().iushln(A);
    }, s.prototype.shrn = function(A) {
      return this.clone().ishrn(A);
    }, s.prototype.ushrn = function(A) {
      return this.clone().iushrn(A);
    }, s.prototype.testn = function(A) {
      n(typeof A == "number" && A >= 0);
      var m = A % 26, f = (A - m) / 26, g = 1 << m;
      if (this.length <= f) return !1;
      var b = this.words[f];
      return !!(b & g);
    }, s.prototype.imaskn = function(A) {
      n(typeof A == "number" && A >= 0);
      var m = A % 26, f = (A - m) / 26;
      if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= f)
        return this;
      if (m !== 0 && f++, this.length = Math.min(f, this.length), m !== 0) {
        var g = 67108863 ^ 67108863 >>> m << m;
        this.words[this.length - 1] &= g;
      }
      return this.strip();
    }, s.prototype.maskn = function(A) {
      return this.clone().imaskn(A);
    }, s.prototype.iaddn = function(A) {
      return n(typeof A == "number"), n(A < 67108864), A < 0 ? this.isubn(-A) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < A ? (this.words[0] = A - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(A), this.negative = 1, this) : this._iaddn(A);
    }, s.prototype._iaddn = function(A) {
      this.words[0] += A;
      for (var m = 0; m < this.length && this.words[m] >= 67108864; m++)
        this.words[m] -= 67108864, m === this.length - 1 ? this.words[m + 1] = 1 : this.words[m + 1]++;
      return this.length = Math.max(this.length, m + 1), this;
    }, s.prototype.isubn = function(A) {
      if (n(typeof A == "number"), n(A < 67108864), A < 0) return this.iaddn(-A);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(A), this.negative = 1, this;
      if (this.words[0] -= A, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var m = 0; m < this.length && this.words[m] < 0; m++)
          this.words[m] += 67108864, this.words[m + 1] -= 1;
      return this.strip();
    }, s.prototype.addn = function(A) {
      return this.clone().iaddn(A);
    }, s.prototype.subn = function(A) {
      return this.clone().isubn(A);
    }, s.prototype.iabs = function() {
      return this.negative = 0, this;
    }, s.prototype.abs = function() {
      return this.clone().iabs();
    }, s.prototype._ishlnsubmul = function(A, m, f) {
      var g = A.length + f, b;
      this._expand(g);
      var x, E = 0;
      for (b = 0; b < A.length; b++) {
        x = (this.words[b + f] | 0) + E;
        var S = (A.words[b] | 0) * m;
        x -= S & 67108863, E = (x >> 26) - (S / 67108864 | 0), this.words[b + f] = x & 67108863;
      }
      for (; b < this.length - f; b++)
        x = (this.words[b + f] | 0) + E, E = x >> 26, this.words[b + f] = x & 67108863;
      if (E === 0) return this.strip();
      for (n(E === -1), E = 0, b = 0; b < this.length; b++)
        x = -(this.words[b] | 0) + E, E = x >> 26, this.words[b] = x & 67108863;
      return this.negative = 1, this.strip();
    }, s.prototype._wordDiv = function(A, m) {
      var f = this.length - A.length, g = this.clone(), b = A, x = b.words[b.length - 1] | 0, E = this._countBits(x);
      f = 26 - E, f !== 0 && (b = b.ushln(f), g.iushln(f), x = b.words[b.length - 1] | 0);
      var S = g.length - b.length, v;
      if (m !== "mod") {
        v = new s(null), v.length = S + 1, v.words = new Array(v.length);
        for (var M = 0; M < v.length; M++)
          v.words[M] = 0;
      }
      var I = g.clone()._ishlnsubmul(b, 1, S);
      I.negative === 0 && (g = I, v && (v.words[S] = 1));
      for (var F = S - 1; F >= 0; F--) {
        var ce = (g.words[b.length + F] | 0) * 67108864 + (g.words[b.length + F - 1] | 0);
        for (ce = Math.min(ce / x | 0, 67108863), g._ishlnsubmul(b, ce, F); g.negative !== 0; )
          ce--, g.negative = 0, g._ishlnsubmul(b, 1, F), g.isZero() || (g.negative ^= 1);
        v && (v.words[F] = ce);
      }
      return v && v.strip(), g.strip(), m !== "div" && f !== 0 && g.iushrn(f), {
        div: v || null,
        mod: g
      };
    }, s.prototype.divmod = function(A, m, f) {
      if (n(!A.isZero()), this.isZero())
        return {
          div: new s(0),
          mod: new s(0)
        };
      var g, b, x;
      return this.negative !== 0 && A.negative === 0 ? (x = this.neg().divmod(A, m), m !== "mod" && (g = x.div.neg()), m !== "div" && (b = x.mod.neg(), f && b.negative !== 0 && b.iadd(A)), {
        div: g,
        mod: b
      }) : this.negative === 0 && A.negative !== 0 ? (x = this.divmod(A.neg(), m), m !== "mod" && (g = x.div.neg()), {
        div: g,
        mod: x.mod
      }) : this.negative & A.negative ? (x = this.neg().divmod(A.neg(), m), m !== "div" && (b = x.mod.neg(), f && b.negative !== 0 && b.isub(A)), {
        div: x.div,
        mod: b
      }) : A.length > this.length || this.cmp(A) < 0 ? {
        div: new s(0),
        mod: this
      } : A.length === 1 ? m === "div" ? {
        div: this.divn(A.words[0]),
        mod: null
      } : m === "mod" ? {
        div: null,
        mod: new s(this.modn(A.words[0]))
      } : {
        div: this.divn(A.words[0]),
        mod: new s(this.modn(A.words[0]))
      } : this._wordDiv(A, m);
    }, s.prototype.div = function(A) {
      return this.divmod(A, "div", !1).div;
    }, s.prototype.mod = function(A) {
      return this.divmod(A, "mod", !1).mod;
    }, s.prototype.umod = function(A) {
      return this.divmod(A, "mod", !0).mod;
    }, s.prototype.divRound = function(A) {
      var m = this.divmod(A);
      if (m.mod.isZero()) return m.div;
      var f = m.div.negative !== 0 ? m.mod.isub(A) : m.mod, g = A.ushrn(1), b = A.andln(1), x = f.cmp(g);
      return x < 0 || b === 1 && x === 0 ? m.div : m.div.negative !== 0 ? m.div.isubn(1) : m.div.iaddn(1);
    }, s.prototype.modn = function(A) {
      n(A <= 67108863);
      for (var m = (1 << 26) % A, f = 0, g = this.length - 1; g >= 0; g--)
        f = (m * f + (this.words[g] | 0)) % A;
      return f;
    }, s.prototype.idivn = function(A) {
      n(A <= 67108863);
      for (var m = 0, f = this.length - 1; f >= 0; f--) {
        var g = (this.words[f] | 0) + m * 67108864;
        this.words[f] = g / A | 0, m = g % A;
      }
      return this.strip();
    }, s.prototype.divn = function(A) {
      return this.clone().idivn(A);
    }, s.prototype.egcd = function(A) {
      n(A.negative === 0), n(!A.isZero());
      var m = this, f = A.clone();
      m.negative !== 0 ? m = m.umod(A) : m = m.clone();
      for (var g = new s(1), b = new s(0), x = new s(0), E = new s(1), S = 0; m.isEven() && f.isEven(); )
        m.iushrn(1), f.iushrn(1), ++S;
      for (var v = f.clone(), M = m.clone(); !m.isZero(); ) {
        for (var I = 0, F = 1; !(m.words[0] & F) && I < 26; ++I, F <<= 1) ;
        if (I > 0)
          for (m.iushrn(I); I-- > 0; )
            (g.isOdd() || b.isOdd()) && (g.iadd(v), b.isub(M)), g.iushrn(1), b.iushrn(1);
        for (var ce = 0, D = 1; !(f.words[0] & D) && ce < 26; ++ce, D <<= 1) ;
        if (ce > 0)
          for (f.iushrn(ce); ce-- > 0; )
            (x.isOdd() || E.isOdd()) && (x.iadd(v), E.isub(M)), x.iushrn(1), E.iushrn(1);
        m.cmp(f) >= 0 ? (m.isub(f), g.isub(x), b.isub(E)) : (f.isub(m), x.isub(g), E.isub(b));
      }
      return {
        a: x,
        b: E,
        gcd: f.iushln(S)
      };
    }, s.prototype._invmp = function(A) {
      n(A.negative === 0), n(!A.isZero());
      var m = this, f = A.clone();
      m.negative !== 0 ? m = m.umod(A) : m = m.clone();
      for (var g = new s(1), b = new s(0), x = f.clone(); m.cmpn(1) > 0 && f.cmpn(1) > 0; ) {
        for (var E = 0, S = 1; !(m.words[0] & S) && E < 26; ++E, S <<= 1) ;
        if (E > 0)
          for (m.iushrn(E); E-- > 0; )
            g.isOdd() && g.iadd(x), g.iushrn(1);
        for (var v = 0, M = 1; !(f.words[0] & M) && v < 26; ++v, M <<= 1) ;
        if (v > 0)
          for (f.iushrn(v); v-- > 0; )
            b.isOdd() && b.iadd(x), b.iushrn(1);
        m.cmp(f) >= 0 ? (m.isub(f), g.isub(b)) : (f.isub(m), b.isub(g));
      }
      var I;
      return m.cmpn(1) === 0 ? I = g : I = b, I.cmpn(0) < 0 && I.iadd(A), I;
    }, s.prototype.gcd = function(A) {
      if (this.isZero()) return A.abs();
      if (A.isZero()) return this.abs();
      var m = this.clone(), f = A.clone();
      m.negative = 0, f.negative = 0;
      for (var g = 0; m.isEven() && f.isEven(); g++)
        m.iushrn(1), f.iushrn(1);
      do {
        for (; m.isEven(); )
          m.iushrn(1);
        for (; f.isEven(); )
          f.iushrn(1);
        var b = m.cmp(f);
        if (b < 0) {
          var x = m;
          m = f, f = x;
        } else if (b === 0 || f.cmpn(1) === 0)
          break;
        m.isub(f);
      } while (!0);
      return f.iushln(g);
    }, s.prototype.invm = function(A) {
      return this.egcd(A).a.umod(A);
    }, s.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, s.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, s.prototype.andln = function(A) {
      return this.words[0] & A;
    }, s.prototype.bincn = function(A) {
      n(typeof A == "number");
      var m = A % 26, f = (A - m) / 26, g = 1 << m;
      if (this.length <= f)
        return this._expand(f + 1), this.words[f] |= g, this;
      for (var b = g, x = f; b !== 0 && x < this.length; x++) {
        var E = this.words[x] | 0;
        E += b, b = E >>> 26, E &= 67108863, this.words[x] = E;
      }
      return b !== 0 && (this.words[x] = b, this.length++), this;
    }, s.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, s.prototype.cmpn = function(A) {
      var m = A < 0;
      if (this.negative !== 0 && !m) return -1;
      if (this.negative === 0 && m) return 1;
      this.strip();
      var f;
      if (this.length > 1)
        f = 1;
      else {
        m && (A = -A), n(A <= 67108863, "Number is too big");
        var g = this.words[0] | 0;
        f = g === A ? 0 : g < A ? -1 : 1;
      }
      return this.negative !== 0 ? -f | 0 : f;
    }, s.prototype.cmp = function(A) {
      if (this.negative !== 0 && A.negative === 0) return -1;
      if (this.negative === 0 && A.negative !== 0) return 1;
      var m = this.ucmp(A);
      return this.negative !== 0 ? -m | 0 : m;
    }, s.prototype.ucmp = function(A) {
      if (this.length > A.length) return 1;
      if (this.length < A.length) return -1;
      for (var m = 0, f = this.length - 1; f >= 0; f--) {
        var g = this.words[f] | 0, b = A.words[f] | 0;
        if (g !== b) {
          g < b ? m = -1 : g > b && (m = 1);
          break;
        }
      }
      return m;
    }, s.prototype.gtn = function(A) {
      return this.cmpn(A) === 1;
    }, s.prototype.gt = function(A) {
      return this.cmp(A) === 1;
    }, s.prototype.gten = function(A) {
      return this.cmpn(A) >= 0;
    }, s.prototype.gte = function(A) {
      return this.cmp(A) >= 0;
    }, s.prototype.ltn = function(A) {
      return this.cmpn(A) === -1;
    }, s.prototype.lt = function(A) {
      return this.cmp(A) === -1;
    }, s.prototype.lten = function(A) {
      return this.cmpn(A) <= 0;
    }, s.prototype.lte = function(A) {
      return this.cmp(A) <= 0;
    }, s.prototype.eqn = function(A) {
      return this.cmpn(A) === 0;
    }, s.prototype.eq = function(A) {
      return this.cmp(A) === 0;
    }, s.red = function(A) {
      return new ge(A);
    }, s.prototype.toRed = function(A) {
      return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), A.convertTo(this)._forceRed(A);
    }, s.prototype.fromRed = function() {
      return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, s.prototype._forceRed = function(A) {
      return this.red = A, this;
    }, s.prototype.forceRed = function(A) {
      return n(!this.red, "Already a number in reduction context"), this._forceRed(A);
    }, s.prototype.redAdd = function(A) {
      return n(this.red, "redAdd works only with red numbers"), this.red.add(this, A);
    }, s.prototype.redIAdd = function(A) {
      return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, A);
    }, s.prototype.redSub = function(A) {
      return n(this.red, "redSub works only with red numbers"), this.red.sub(this, A);
    }, s.prototype.redISub = function(A) {
      return n(this.red, "redISub works only with red numbers"), this.red.isub(this, A);
    }, s.prototype.redShl = function(A) {
      return n(this.red, "redShl works only with red numbers"), this.red.shl(this, A);
    }, s.prototype.redMul = function(A) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, A), this.red.mul(this, A);
    }, s.prototype.redIMul = function(A) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, A), this.red.imul(this, A);
    }, s.prototype.redSqr = function() {
      return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, s.prototype.redISqr = function() {
      return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, s.prototype.redSqrt = function() {
      return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, s.prototype.redInvm = function() {
      return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, s.prototype.redNeg = function() {
      return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, s.prototype.redPow = function(A) {
      return n(this.red && !A.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, A);
    };
    var q = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function U(Y, A) {
      this.name = Y, this.p = new s(A, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    U.prototype._tmp = function() {
      var A = new s(null);
      return A.words = new Array(Math.ceil(this.n / 13)), A;
    }, U.prototype.ireduce = function(A) {
      var m = A, f;
      do
        this.split(m, this.tmp), m = this.imulK(m), m = m.iadd(this.tmp), f = m.bitLength();
      while (f > this.n);
      var g = f < this.n ? -1 : m.ucmp(this.p);
      return g === 0 ? (m.words[0] = 0, m.length = 1) : g > 0 ? m.isub(this.p) : m.strip !== void 0 ? m.strip() : m._strip(), m;
    }, U.prototype.split = function(A, m) {
      A.iushrn(this.n, 0, m);
    }, U.prototype.imulK = function(A) {
      return A.imul(this.k);
    };
    function V() {
      U.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(V, U), V.prototype.split = function(A, m) {
      for (var f = 4194303, g = Math.min(A.length, 9), b = 0; b < g; b++)
        m.words[b] = A.words[b];
      if (m.length = g, A.length <= 9) {
        A.words[0] = 0, A.length = 1;
        return;
      }
      var x = A.words[9];
      for (m.words[m.length++] = x & f, b = 10; b < A.length; b++) {
        var E = A.words[b] | 0;
        A.words[b - 10] = (E & f) << 4 | x >>> 22, x = E;
      }
      x >>>= 22, A.words[b - 10] = x, x === 0 && A.length > 10 ? A.length -= 10 : A.length -= 9;
    }, V.prototype.imulK = function(A) {
      A.words[A.length] = 0, A.words[A.length + 1] = 0, A.length += 2;
      for (var m = 0, f = 0; f < A.length; f++) {
        var g = A.words[f] | 0;
        m += g * 977, A.words[f] = m & 67108863, m = g * 64 + (m / 67108864 | 0);
      }
      return A.words[A.length - 1] === 0 && (A.length--, A.words[A.length - 1] === 0 && A.length--), A;
    };
    function Q() {
      U.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(Q, U);
    function R() {
      U.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(R, U);
    function K() {
      U.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(K, U), K.prototype.imulK = function(A) {
      for (var m = 0, f = 0; f < A.length; f++) {
        var g = (A.words[f] | 0) * 19 + m, b = g & 67108863;
        g >>>= 26, A.words[f] = b, m = g;
      }
      return m !== 0 && (A.words[A.length++] = m), A;
    }, s._prime = function(A) {
      if (q[A]) return q[A];
      var m;
      if (A === "k256")
        m = new V();
      else if (A === "p224")
        m = new Q();
      else if (A === "p192")
        m = new R();
      else if (A === "p25519")
        m = new K();
      else
        throw new Error("Unknown prime " + A);
      return q[A] = m, m;
    };
    function ge(Y) {
      if (typeof Y == "string") {
        var A = s._prime(Y);
        this.m = A.p, this.prime = A;
      } else
        n(Y.gtn(1), "modulus must be greater than 1"), this.m = Y, this.prime = null;
    }
    ge.prototype._verify1 = function(A) {
      n(A.negative === 0, "red works only with positives"), n(A.red, "red works only with red numbers");
    }, ge.prototype._verify2 = function(A, m) {
      n((A.negative | m.negative) === 0, "red works only with positives"), n(
        A.red && A.red === m.red,
        "red works only with red numbers"
      );
    }, ge.prototype.imod = function(A) {
      return this.prime ? this.prime.ireduce(A)._forceRed(this) : A.umod(this.m)._forceRed(this);
    }, ge.prototype.neg = function(A) {
      return A.isZero() ? A.clone() : this.m.sub(A)._forceRed(this);
    }, ge.prototype.add = function(A, m) {
      this._verify2(A, m);
      var f = A.add(m);
      return f.cmp(this.m) >= 0 && f.isub(this.m), f._forceRed(this);
    }, ge.prototype.iadd = function(A, m) {
      this._verify2(A, m);
      var f = A.iadd(m);
      return f.cmp(this.m) >= 0 && f.isub(this.m), f;
    }, ge.prototype.sub = function(A, m) {
      this._verify2(A, m);
      var f = A.sub(m);
      return f.cmpn(0) < 0 && f.iadd(this.m), f._forceRed(this);
    }, ge.prototype.isub = function(A, m) {
      this._verify2(A, m);
      var f = A.isub(m);
      return f.cmpn(0) < 0 && f.iadd(this.m), f;
    }, ge.prototype.shl = function(A, m) {
      return this._verify1(A), this.imod(A.ushln(m));
    }, ge.prototype.imul = function(A, m) {
      return this._verify2(A, m), this.imod(A.imul(m));
    }, ge.prototype.mul = function(A, m) {
      return this._verify2(A, m), this.imod(A.mul(m));
    }, ge.prototype.isqr = function(A) {
      return this.imul(A, A.clone());
    }, ge.prototype.sqr = function(A) {
      return this.mul(A, A);
    }, ge.prototype.sqrt = function(A) {
      if (A.isZero()) return A.clone();
      var m = this.m.andln(3);
      if (n(m % 2 === 1), m === 3) {
        var f = this.m.add(new s(1)).iushrn(2);
        return this.pow(A, f);
      }
      for (var g = this.m.subn(1), b = 0; !g.isZero() && g.andln(1) === 0; )
        b++, g.iushrn(1);
      n(!g.isZero());
      var x = new s(1).toRed(this), E = x.redNeg(), S = this.m.subn(1).iushrn(1), v = this.m.bitLength();
      for (v = new s(2 * v * v).toRed(this); this.pow(v, S).cmp(E) !== 0; )
        v.redIAdd(E);
      for (var M = this.pow(v, g), I = this.pow(A, g.addn(1).iushrn(1)), F = this.pow(A, g), ce = b; F.cmp(x) !== 0; ) {
        for (var D = F, oe = 0; D.cmp(x) !== 0; oe++)
          D = D.redSqr();
        n(oe < ce);
        var Z = this.pow(M, new s(1).iushln(ce - oe - 1));
        I = I.redMul(Z), M = Z.redSqr(), F = F.redMul(M), ce = oe;
      }
      return I;
    }, ge.prototype.invm = function(A) {
      var m = A._invmp(this.m);
      return m.negative !== 0 ? (m.negative = 0, this.imod(m).redNeg()) : this.imod(m);
    }, ge.prototype.pow = function(A, m) {
      if (m.isZero()) return new s(1).toRed(this);
      if (m.cmpn(1) === 0) return A.clone();
      var f = 4, g = new Array(1 << f);
      g[0] = new s(1).toRed(this), g[1] = A;
      for (var b = 2; b < g.length; b++)
        g[b] = this.mul(g[b - 1], A);
      var x = g[0], E = 0, S = 0, v = m.bitLength() % 26;
      for (v === 0 && (v = 26), b = m.length - 1; b >= 0; b--) {
        for (var M = m.words[b], I = v - 1; I >= 0; I--) {
          var F = M >> I & 1;
          if (x !== g[0] && (x = this.sqr(x)), F === 0 && E === 0) {
            S = 0;
            continue;
          }
          E <<= 1, E |= F, S++, !(S !== f && (b !== 0 || I !== 0)) && (x = this.mul(x, g[E]), S = 0, E = 0);
        }
        v = 26;
      }
      return x;
    }, ge.prototype.convertTo = function(A) {
      var m = A.umod(this.m);
      return m === A ? m.clone() : m;
    }, ge.prototype.convertFrom = function(A) {
      var m = A.clone();
      return m.red = null, m;
    }, s.mont = function(A) {
      return new Ee(A);
    };
    function Ee(Y) {
      ge.call(this, Y), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(Ee, ge), Ee.prototype.convertTo = function(A) {
      return this.imod(A.ushln(this.shift));
    }, Ee.prototype.convertFrom = function(A) {
      var m = this.imod(A.mul(this.rinv));
      return m.red = null, m;
    }, Ee.prototype.imul = function(A, m) {
      if (A.isZero() || m.isZero())
        return A.words[0] = 0, A.length = 1, A;
      var f = A.imul(m), g = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), b = f.isub(g).iushrn(this.shift), x = b;
      return b.cmp(this.m) >= 0 ? x = b.isub(this.m) : b.cmpn(0) < 0 && (x = b.iadd(this.m)), x._forceRed(this);
    }, Ee.prototype.mul = function(A, m) {
      if (A.isZero() || m.isZero()) return new s(0)._forceRed(this);
      var f = A.mul(m), g = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), b = f.isub(g).iushrn(this.shift), x = b;
      return b.cmp(this.m) >= 0 ? x = b.isub(this.m) : b.cmpn(0) < 0 && (x = b.iadd(this.m)), x._forceRed(this);
    }, Ee.prototype.invm = function(A) {
      var m = this.imod(A._invmp(this.m).mul(this.r2));
      return m._forceRed(this);
    };
  })(t, gn);
})(hb);
var Ho = hb.exports, db = {};
(function(t) {
  var e = t;
  function r(s, o) {
    if (Array.isArray(s))
      return s.slice();
    if (!s)
      return [];
    var a = [];
    if (typeof s != "string") {
      for (var u = 0; u < s.length; u++)
        a[u] = s[u] | 0;
      return a;
    }
    if (o === "hex") {
      s = s.replace(/[^a-z0-9]+/ig, ""), s.length % 2 !== 0 && (s = "0" + s);
      for (var u = 0; u < s.length; u += 2)
        a.push(parseInt(s[u] + s[u + 1], 16));
    } else
      for (var u = 0; u < s.length; u++) {
        var l = s.charCodeAt(u), d = l >> 8, p = l & 255;
        d ? a.push(d, p) : a.push(p);
      }
    return a;
  }
  e.toArray = r;
  function n(s) {
    return s.length === 1 ? "0" + s : s;
  }
  e.zero2 = n;
  function i(s) {
    for (var o = "", a = 0; a < s.length; a++)
      o += n(s[a].toString(16));
    return o;
  }
  e.toHex = i, e.encode = function(o, a) {
    return a === "hex" ? i(o) : o;
  };
})(db);
(function(t) {
  var e = t, r = Ho, n = Tc, i = db;
  e.assert = n, e.toArray = i.toArray, e.zero2 = i.zero2, e.toHex = i.toHex, e.encode = i.encode;
  function s(d, p, w) {
    var _ = new Array(Math.max(d.bitLength(), w) + 1), P;
    for (P = 0; P < _.length; P += 1)
      _[P] = 0;
    var O = 1 << p + 1, L = d.clone();
    for (P = 0; P < _.length; P++) {
      var B, k = L.andln(O - 1);
      L.isOdd() ? (k > (O >> 1) - 1 ? B = (O >> 1) - k : B = k, L.isubn(B)) : B = 0, _[P] = B, L.iushrn(1);
    }
    return _;
  }
  e.getNAF = s;
  function o(d, p) {
    var w = [
      [],
      []
    ];
    d = d.clone(), p = p.clone();
    for (var _ = 0, P = 0, O; d.cmpn(-_) > 0 || p.cmpn(-P) > 0; ) {
      var L = d.andln(3) + _ & 3, B = p.andln(3) + P & 3;
      L === 3 && (L = -1), B === 3 && (B = -1);
      var k;
      L & 1 ? (O = d.andln(7) + _ & 7, (O === 3 || O === 5) && B === 2 ? k = -L : k = L) : k = 0, w[0].push(k);
      var q;
      B & 1 ? (O = p.andln(7) + P & 7, (O === 3 || O === 5) && L === 2 ? q = -B : q = B) : q = 0, w[1].push(q), 2 * _ === k + 1 && (_ = 1 - _), 2 * P === q + 1 && (P = 1 - P), d.iushrn(1), p.iushrn(1);
    }
    return w;
  }
  e.getJSF = o;
  function a(d, p, w) {
    var _ = "_" + p;
    d.prototype[p] = function() {
      return this[_] !== void 0 ? this[_] : this[_] = w.call(this);
    };
  }
  e.cachedProperty = a;
  function u(d) {
    return typeof d == "string" ? e.toArray(d, "hex") : d;
  }
  e.parseBytes = u;
  function l(d) {
    return new r(d, "hex", "le");
  }
  e.intFromLE = l;
})(ji);
var pb = { exports: {} }, xm;
pb.exports = function(e) {
  return xm || (xm = new da(null)), xm.generate(e);
};
function da(t) {
  this.rand = t;
}
pb.exports.Rand = da;
da.prototype.generate = function(e) {
  return this._rand(e);
};
da.prototype._rand = function(e) {
  if (this.rand.getBytes)
    return this.rand.getBytes(e);
  for (var r = new Uint8Array(e), n = 0; n < r.length; n++)
    r[n] = this.rand.getByte();
  return r;
};
if (typeof self == "object")
  self.crypto && self.crypto.getRandomValues ? da.prototype._rand = function(e) {
    var r = new Uint8Array(e);
    return self.crypto.getRandomValues(r), r;
  } : self.msCrypto && self.msCrypto.getRandomValues ? da.prototype._rand = function(e) {
    var r = new Uint8Array(e);
    return self.msCrypto.getRandomValues(r), r;
  } : typeof window == "object" && (da.prototype._rand = function() {
    throw new Error("Not implemented yet");
  });
else
  try {
    var Kx = Ql;
    if (typeof Kx.randomBytes != "function")
      throw new Error("Not supported");
    da.prototype._rand = function(e) {
      return Kx.randomBytes(e);
    };
  } catch {
  }
var X8 = pb.exports, gb = {}, Ja = Ho, sh = ji, v0 = sh.getNAF, $q = sh.getJSF, b0 = sh.assert;
function La(t, e) {
  this.type = t, this.p = new Ja(e.p, 16), this.red = e.prime ? Ja.red(e.prime) : Ja.mont(this.p), this.zero = new Ja(0).toRed(this.red), this.one = new Ja(1).toRed(this.red), this.two = new Ja(2).toRed(this.red), this.n = e.n && new Ja(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var r = this.n && this.p.div(this.n);
  !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var cp = La;
La.prototype.point = function() {
  throw new Error("Not implemented");
};
La.prototype.validate = function() {
  throw new Error("Not implemented");
};
La.prototype._fixedNafMul = function(e, r) {
  b0(e.precomputed);
  var n = e._getDoubles(), i = v0(r, 1, this._bitLength), s = (1 << n.step + 1) - (n.step % 2 === 0 ? 2 : 1);
  s /= 3;
  var o = [], a, u;
  for (a = 0; a < i.length; a += n.step) {
    u = 0;
    for (var l = a + n.step - 1; l >= a; l--)
      u = (u << 1) + i[l];
    o.push(u);
  }
  for (var d = this.jpoint(null, null, null), p = this.jpoint(null, null, null), w = s; w > 0; w--) {
    for (a = 0; a < o.length; a++)
      u = o[a], u === w ? p = p.mixedAdd(n.points[a]) : u === -w && (p = p.mixedAdd(n.points[a].neg()));
    d = d.add(p);
  }
  return d.toP();
};
La.prototype._wnafMul = function(e, r) {
  var n = 4, i = e._getNAFPoints(n);
  n = i.wnd;
  for (var s = i.points, o = v0(r, n, this._bitLength), a = this.jpoint(null, null, null), u = o.length - 1; u >= 0; u--) {
    for (var l = 0; u >= 0 && o[u] === 0; u--)
      l++;
    if (u >= 0 && l++, a = a.dblp(l), u < 0)
      break;
    var d = o[u];
    b0(d !== 0), e.type === "affine" ? d > 0 ? a = a.mixedAdd(s[d - 1 >> 1]) : a = a.mixedAdd(s[-d - 1 >> 1].neg()) : d > 0 ? a = a.add(s[d - 1 >> 1]) : a = a.add(s[-d - 1 >> 1].neg());
  }
  return e.type === "affine" ? a.toP() : a;
};
La.prototype._wnafMulAdd = function(e, r, n, i, s) {
  var o = this._wnafT1, a = this._wnafT2, u = this._wnafT3, l = 0, d, p, w;
  for (d = 0; d < i; d++) {
    w = r[d];
    var _ = w._getNAFPoints(e);
    o[d] = _.wnd, a[d] = _.points;
  }
  for (d = i - 1; d >= 1; d -= 2) {
    var P = d - 1, O = d;
    if (o[P] !== 1 || o[O] !== 1) {
      u[P] = v0(n[P], o[P], this._bitLength), u[O] = v0(n[O], o[O], this._bitLength), l = Math.max(u[P].length, l), l = Math.max(u[O].length, l);
      continue;
    }
    var L = [
      r[P],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      r[O]
      /* 7 */
    ];
    r[P].y.cmp(r[O].y) === 0 ? (L[1] = r[P].add(r[O]), L[2] = r[P].toJ().mixedAdd(r[O].neg())) : r[P].y.cmp(r[O].y.redNeg()) === 0 ? (L[1] = r[P].toJ().mixedAdd(r[O]), L[2] = r[P].add(r[O].neg())) : (L[1] = r[P].toJ().mixedAdd(r[O]), L[2] = r[P].toJ().mixedAdd(r[O].neg()));
    var B = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], k = $q(n[P], n[O]);
    for (l = Math.max(k[0].length, l), u[P] = new Array(l), u[O] = new Array(l), p = 0; p < l; p++) {
      var q = k[0][p] | 0, U = k[1][p] | 0;
      u[P][p] = B[(q + 1) * 3 + (U + 1)], u[O][p] = 0, a[P] = L;
    }
  }
  var V = this.jpoint(null, null, null), Q = this._wnafT4;
  for (d = l; d >= 0; d--) {
    for (var R = 0; d >= 0; ) {
      var K = !0;
      for (p = 0; p < i; p++)
        Q[p] = u[p][d] | 0, Q[p] !== 0 && (K = !1);
      if (!K)
        break;
      R++, d--;
    }
    if (d >= 0 && R++, V = V.dblp(R), d < 0)
      break;
    for (p = 0; p < i; p++) {
      var ge = Q[p];
      ge !== 0 && (ge > 0 ? w = a[p][ge - 1 >> 1] : ge < 0 && (w = a[p][-ge - 1 >> 1].neg()), w.type === "affine" ? V = V.mixedAdd(w) : V = V.add(w));
    }
  }
  for (d = 0; d < i; d++)
    a[d] = null;
  return s ? V : V.toP();
};
function as(t, e) {
  this.curve = t, this.type = e, this.precomputed = null;
}
La.BasePoint = as;
as.prototype.eq = function() {
  throw new Error("Not implemented");
};
as.prototype.validate = function() {
  return this.curve.validate(this);
};
La.prototype.decodePoint = function(e, r) {
  e = sh.toArray(e, r);
  var n = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * n) {
    e[0] === 6 ? b0(e[e.length - 1] % 2 === 0) : e[0] === 7 && b0(e[e.length - 1] % 2 === 1);
    var i = this.point(
      e.slice(1, 1 + n),
      e.slice(1 + n, 1 + 2 * n)
    );
    return i;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n)
    return this.pointFromX(e.slice(1, 1 + n), e[0] === 3);
  throw new Error("Unknown point format");
};
as.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
as.prototype._encode = function(e) {
  var r = this.curve.p.byteLength(), n = this.getX().toArray("be", r);
  return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", r));
};
as.prototype.encode = function(e, r) {
  return sh.encode(this._encode(r), e);
};
as.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var r = {
    doubles: null,
    naf: null,
    beta: null
  };
  return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
};
as.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var r = this.precomputed.doubles;
  return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : !1;
};
as.prototype._getDoubles = function(e, r) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var n = [this], i = this, s = 0; s < r; s += e) {
    for (var o = 0; o < e; o++)
      i = i.dbl();
    n.push(i);
  }
  return {
    step: e,
    points: n
  };
};
as.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var r = [this], n = (1 << e) - 1, i = n === 1 ? null : this.dbl(), s = 1; s < n; s++)
    r[s] = r[s - 1].add(i);
  return {
    wnd: e,
    points: r
  };
};
as.prototype._getBeta = function() {
  return null;
};
as.prototype.dblp = function(e) {
  for (var r = this, n = 0; n < e; n++)
    r = r.dbl();
  return r;
};
var Bq = ji, rn = Ho, mb = np, Ku = cp, Fq = Bq.assert;
function cs(t) {
  Ku.call(this, "short", t), this.a = new rn(t.a, 16).toRed(this.red), this.b = new rn(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
mb(cs, Ku);
var jq = cs;
cs.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var r, n;
    if (e.beta)
      r = new rn(e.beta, 16).toRed(this.red);
    else {
      var i = this._getEndoRoots(this.p);
      r = i[0].cmp(i[1]) < 0 ? i[0] : i[1], r = r.toRed(this.red);
    }
    if (e.lambda)
      n = new rn(e.lambda, 16);
    else {
      var s = this._getEndoRoots(this.n);
      this.g.mul(s[0]).x.cmp(this.g.x.redMul(r)) === 0 ? n = s[0] : (n = s[1], Fq(this.g.mul(n).x.cmp(this.g.x.redMul(r)) === 0));
    }
    var o;
    return e.basis ? o = e.basis.map(function(a) {
      return {
        a: new rn(a.a, 16),
        b: new rn(a.b, 16)
      };
    }) : o = this._getEndoBasis(n), {
      beta: r,
      lambda: n,
      basis: o
    };
  }
};
cs.prototype._getEndoRoots = function(e) {
  var r = e === this.p ? this.red : rn.mont(e), n = new rn(2).toRed(r).redInvm(), i = n.redNeg(), s = new rn(3).toRed(r).redNeg().redSqrt().redMul(n), o = i.redAdd(s).fromRed(), a = i.redSub(s).fromRed();
  return [o, a];
};
cs.prototype._getEndoBasis = function(e) {
  for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), n = e, i = this.n.clone(), s = new rn(1), o = new rn(0), a = new rn(0), u = new rn(1), l, d, p, w, _, P, O, L = 0, B, k; n.cmpn(0) !== 0; ) {
    var q = i.div(n);
    B = i.sub(q.mul(n)), k = a.sub(q.mul(s));
    var U = u.sub(q.mul(o));
    if (!p && B.cmp(r) < 0)
      l = O.neg(), d = s, p = B.neg(), w = k;
    else if (p && ++L === 2)
      break;
    O = B, i = n, n = B, a = s, s = k, u = o, o = U;
  }
  _ = B.neg(), P = k;
  var V = p.sqr().add(w.sqr()), Q = _.sqr().add(P.sqr());
  return Q.cmp(V) >= 0 && (_ = l, P = d), p.negative && (p = p.neg(), w = w.neg()), _.negative && (_ = _.neg(), P = P.neg()), [
    { a: p, b: w },
    { a: _, b: P }
  ];
};
cs.prototype._endoSplit = function(e) {
  var r = this.endo.basis, n = r[0], i = r[1], s = i.b.mul(e).divRound(this.n), o = n.b.neg().mul(e).divRound(this.n), a = s.mul(n.a), u = o.mul(i.a), l = s.mul(n.b), d = o.mul(i.b), p = e.sub(a).sub(u), w = l.add(d).neg();
  return { k1: p, k2: w };
};
cs.prototype.pointFromX = function(e, r) {
  e = new rn(e, 16), e.red || (e = e.toRed(this.red));
  var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), i = n.redSqrt();
  if (i.redSqr().redSub(n).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var s = i.fromRed().isOdd();
  return (r && !s || !r && s) && (i = i.redNeg()), this.point(e, i);
};
cs.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var r = e.x, n = e.y, i = this.a.redMul(r), s = r.redSqr().redMul(r).redIAdd(i).redIAdd(this.b);
  return n.redSqr().redISub(s).cmpn(0) === 0;
};
cs.prototype._endoWnafMulAdd = function(e, r, n) {
  for (var i = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < e.length; o++) {
    var a = this._endoSplit(r[o]), u = e[o], l = u._getBeta();
    a.k1.negative && (a.k1.ineg(), u = u.neg(!0)), a.k2.negative && (a.k2.ineg(), l = l.neg(!0)), i[o * 2] = u, i[o * 2 + 1] = l, s[o * 2] = a.k1, s[o * 2 + 1] = a.k2;
  }
  for (var d = this._wnafMulAdd(1, i, s, o * 2, n), p = 0; p < o * 2; p++)
    i[p] = null, s[p] = null;
  return d;
};
function $n(t, e, r, n) {
  Ku.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new rn(e, 16), this.y = new rn(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
mb($n, Ku.BasePoint);
cs.prototype.point = function(e, r, n) {
  return new $n(this, e, r, n);
};
cs.prototype.pointFromJSON = function(e, r) {
  return $n.fromJSON(this, e, r);
};
$n.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var n = this.curve, i = function(s) {
        return n.point(s.x.redMul(n.endo.beta), s.y);
      };
      e.beta = r, r.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(i)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(i)
        }
      };
    }
    return r;
  }
};
$n.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
$n.fromJSON = function(e, r, n) {
  typeof r == "string" && (r = JSON.parse(r));
  var i = e.point(r[0], r[1], n);
  if (!r[2])
    return i;
  function s(a) {
    return e.point(a[0], a[1], n);
  }
  var o = r[2];
  return i.precomputed = {
    beta: null,
    doubles: o.doubles && {
      step: o.doubles.step,
      points: [i].concat(o.doubles.points.map(s))
    },
    naf: o.naf && {
      wnd: o.naf.wnd,
      points: [i].concat(o.naf.points.map(s))
    }
  }, i;
};
$n.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
$n.prototype.isInfinity = function() {
  return this.inf;
};
$n.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var r = this.y.redSub(e.y);
  r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
  var n = r.redSqr().redISub(this.x).redISub(e.x), i = r.redMul(this.x.redSub(n)).redISub(this.y);
  return this.curve.point(n, i);
};
$n.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var r = this.curve.a, n = this.x.redSqr(), i = e.redInvm(), s = n.redAdd(n).redIAdd(n).redIAdd(r).redMul(i), o = s.redSqr().redISub(this.x.redAdd(this.x)), a = s.redMul(this.x.redSub(o)).redISub(this.y);
  return this.curve.point(o, a);
};
$n.prototype.getX = function() {
  return this.x.fromRed();
};
$n.prototype.getY = function() {
  return this.y.fromRed();
};
$n.prototype.mul = function(e) {
  return e = new rn(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
$n.prototype.mulAdd = function(e, r, n) {
  var i = [this, r], s = [e, n];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2);
};
$n.prototype.jmulAdd = function(e, r, n) {
  var i = [this, r], s = [e, n];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, !0) : this.curve._wnafMulAdd(1, i, s, 2, !0);
};
$n.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
$n.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var r = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var n = this.precomputed, i = function(s) {
      return s.neg();
    };
    r.precomputed = {
      naf: n.naf && {
        wnd: n.naf.wnd,
        points: n.naf.points.map(i)
      },
      doubles: n.doubles && {
        step: n.doubles.step,
        points: n.doubles.points.map(i)
      }
    };
  }
  return r;
};
$n.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function Wn(t, e, r, n) {
  Ku.BasePoint.call(this, t, "jacobian"), e === null && r === null && n === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new rn(0)) : (this.x = new rn(e, 16), this.y = new rn(r, 16), this.z = new rn(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
mb(Wn, Ku.BasePoint);
cs.prototype.jpoint = function(e, r, n) {
  return new Wn(this, e, r, n);
};
Wn.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), r = e.redSqr(), n = this.x.redMul(r), i = this.y.redMul(r).redMul(e);
  return this.curve.point(n, i);
};
Wn.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
Wn.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var r = e.z.redSqr(), n = this.z.redSqr(), i = this.x.redMul(r), s = e.x.redMul(n), o = this.y.redMul(r.redMul(e.z)), a = e.y.redMul(n.redMul(this.z)), u = i.redSub(s), l = o.redSub(a);
  if (u.cmpn(0) === 0)
    return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var d = u.redSqr(), p = d.redMul(u), w = i.redMul(d), _ = l.redSqr().redIAdd(p).redISub(w).redISub(w), P = l.redMul(w.redISub(_)).redISub(o.redMul(p)), O = this.z.redMul(e.z).redMul(u);
  return this.curve.jpoint(_, P, O);
};
Wn.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var r = this.z.redSqr(), n = this.x, i = e.x.redMul(r), s = this.y, o = e.y.redMul(r).redMul(this.z), a = n.redSub(i), u = s.redSub(o);
  if (a.cmpn(0) === 0)
    return u.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var l = a.redSqr(), d = l.redMul(a), p = n.redMul(l), w = u.redSqr().redIAdd(d).redISub(p).redISub(p), _ = u.redMul(p.redISub(w)).redISub(s.redMul(d)), P = this.z.redMul(a);
  return this.curve.jpoint(w, _, P);
};
Wn.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var r;
  if (this.curve.zeroA || this.curve.threeA) {
    var n = this;
    for (r = 0; r < e; r++)
      n = n.dbl();
    return n;
  }
  var i = this.curve.a, s = this.curve.tinv, o = this.x, a = this.y, u = this.z, l = u.redSqr().redSqr(), d = a.redAdd(a);
  for (r = 0; r < e; r++) {
    var p = o.redSqr(), w = d.redSqr(), _ = w.redSqr(), P = p.redAdd(p).redIAdd(p).redIAdd(i.redMul(l)), O = o.redMul(w), L = P.redSqr().redISub(O.redAdd(O)), B = O.redISub(L), k = P.redMul(B);
    k = k.redIAdd(k).redISub(_);
    var q = d.redMul(u);
    r + 1 < e && (l = l.redMul(_)), o = L, u = q, d = k;
  }
  return this.curve.jpoint(o, d.redMul(s), u);
};
Wn.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
Wn.prototype._zeroDbl = function() {
  var e, r, n;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
    a = a.redIAdd(a);
    var u = i.redAdd(i).redIAdd(i), l = u.redSqr().redISub(a).redISub(a), d = o.redIAdd(o);
    d = d.redIAdd(d), d = d.redIAdd(d), e = l, r = u.redMul(a.redISub(l)).redISub(d), n = this.y.redAdd(this.y);
  } else {
    var p = this.x.redSqr(), w = this.y.redSqr(), _ = w.redSqr(), P = this.x.redAdd(w).redSqr().redISub(p).redISub(_);
    P = P.redIAdd(P);
    var O = p.redAdd(p).redIAdd(p), L = O.redSqr(), B = _.redIAdd(_);
    B = B.redIAdd(B), B = B.redIAdd(B), e = L.redISub(P).redISub(P), r = O.redMul(P.redISub(e)).redISub(B), n = this.y.redMul(this.z), n = n.redIAdd(n);
  }
  return this.curve.jpoint(e, r, n);
};
Wn.prototype._threeDbl = function() {
  var e, r, n;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
    a = a.redIAdd(a);
    var u = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a), l = u.redSqr().redISub(a).redISub(a);
    e = l;
    var d = o.redIAdd(o);
    d = d.redIAdd(d), d = d.redIAdd(d), r = u.redMul(a.redISub(l)).redISub(d), n = this.y.redAdd(this.y);
  } else {
    var p = this.z.redSqr(), w = this.y.redSqr(), _ = this.x.redMul(w), P = this.x.redSub(p).redMul(this.x.redAdd(p));
    P = P.redAdd(P).redIAdd(P);
    var O = _.redIAdd(_);
    O = O.redIAdd(O);
    var L = O.redAdd(O);
    e = P.redSqr().redISub(L), n = this.y.redAdd(this.z).redSqr().redISub(w).redISub(p);
    var B = w.redSqr();
    B = B.redIAdd(B), B = B.redIAdd(B), B = B.redIAdd(B), r = P.redMul(O.redISub(e)).redISub(B);
  }
  return this.curve.jpoint(e, r, n);
};
Wn.prototype._dbl = function() {
  var e = this.curve.a, r = this.x, n = this.y, i = this.z, s = i.redSqr().redSqr(), o = r.redSqr(), a = n.redSqr(), u = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(s)), l = r.redAdd(r);
  l = l.redIAdd(l);
  var d = l.redMul(a), p = u.redSqr().redISub(d.redAdd(d)), w = d.redISub(p), _ = a.redSqr();
  _ = _.redIAdd(_), _ = _.redIAdd(_), _ = _.redIAdd(_);
  var P = u.redMul(w).redISub(_), O = n.redAdd(n).redMul(i);
  return this.curve.jpoint(p, P, O);
};
Wn.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr(), i = r.redSqr(), s = e.redAdd(e).redIAdd(e), o = s.redSqr(), a = this.x.redAdd(r).redSqr().redISub(e).redISub(i);
  a = a.redIAdd(a), a = a.redAdd(a).redIAdd(a), a = a.redISub(o);
  var u = a.redSqr(), l = i.redIAdd(i);
  l = l.redIAdd(l), l = l.redIAdd(l), l = l.redIAdd(l);
  var d = s.redIAdd(a).redSqr().redISub(o).redISub(u).redISub(l), p = r.redMul(d);
  p = p.redIAdd(p), p = p.redIAdd(p);
  var w = this.x.redMul(u).redISub(p);
  w = w.redIAdd(w), w = w.redIAdd(w);
  var _ = this.y.redMul(d.redMul(l.redISub(d)).redISub(a.redMul(u)));
  _ = _.redIAdd(_), _ = _.redIAdd(_), _ = _.redIAdd(_);
  var P = this.z.redAdd(a).redSqr().redISub(n).redISub(u);
  return this.curve.jpoint(w, _, P);
};
Wn.prototype.mul = function(e, r) {
  return e = new rn(e, r), this.curve._wnafMul(this, e);
};
Wn.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var r = this.z.redSqr(), n = e.z.redSqr();
  if (this.x.redMul(n).redISub(e.x.redMul(r)).cmpn(0) !== 0)
    return !1;
  var i = r.redMul(this.z), s = n.redMul(e.z);
  return this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0) === 0;
};
Wn.prototype.eqXToP = function(e) {
  var r = this.z.redSqr(), n = e.toRed(this.curve.red).redMul(r);
  if (this.x.cmp(n) === 0)
    return !0;
  for (var i = e.clone(), s = this.curve.redN.redMul(r); ; ) {
    if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)
      return !1;
    if (n.redIAdd(s), this.x.cmp(n) === 0)
      return !0;
  }
};
Wn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
Wn.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var uu = Ho, Z8 = np, up = cp, Uq = ji;
function Vu(t) {
  up.call(this, "mont", t), this.a = new uu(t.a, 16).toRed(this.red), this.b = new uu(t.b, 16).toRed(this.red), this.i4 = new uu(4).toRed(this.red).redInvm(), this.two = new uu(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
Z8(Vu, up);
var qq = Vu;
Vu.prototype.validate = function(e) {
  var r = e.normalize().x, n = r.redSqr(), i = n.redMul(r).redAdd(n.redMul(this.a)).redAdd(r), s = i.redSqrt();
  return s.redSqr().cmp(i) === 0;
};
function Ln(t, e, r) {
  up.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new uu(e, 16), this.z = new uu(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
Z8(Ln, up.BasePoint);
Vu.prototype.decodePoint = function(e, r) {
  return this.point(Uq.toArray(e, r), 1);
};
Vu.prototype.point = function(e, r) {
  return new Ln(this, e, r);
};
Vu.prototype.pointFromJSON = function(e) {
  return Ln.fromJSON(this, e);
};
Ln.prototype.precompute = function() {
};
Ln.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Ln.fromJSON = function(e, r) {
  return new Ln(e, r[0], r[1] || e.one);
};
Ln.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Ln.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
Ln.prototype.dbl = function() {
  var e = this.x.redAdd(this.z), r = e.redSqr(), n = this.x.redSub(this.z), i = n.redSqr(), s = r.redSub(i), o = r.redMul(i), a = s.redMul(i.redAdd(this.curve.a24.redMul(s)));
  return this.curve.point(o, a);
};
Ln.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
Ln.prototype.diffAdd = function(e, r) {
  var n = this.x.redAdd(this.z), i = this.x.redSub(this.z), s = e.x.redAdd(e.z), o = e.x.redSub(e.z), a = o.redMul(n), u = s.redMul(i), l = r.z.redMul(a.redAdd(u).redSqr()), d = r.x.redMul(a.redISub(u).redSqr());
  return this.curve.point(l, d);
};
Ln.prototype.mul = function(e) {
  for (var r = e.clone(), n = this, i = this.curve.point(null, null), s = this, o = []; r.cmpn(0) !== 0; r.iushrn(1))
    o.push(r.andln(1));
  for (var a = o.length - 1; a >= 0; a--)
    o[a] === 0 ? (n = n.diffAdd(i, s), i = i.dbl()) : (i = n.diffAdd(i, s), n = n.dbl());
  return i;
};
Ln.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Ln.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Ln.prototype.eq = function(e) {
  return this.getX().cmp(e.getX()) === 0;
};
Ln.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Ln.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var zq = ji, Io = Ho, Q8 = np, fp = cp, Wq = zq.assert;
function oo(t) {
  this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, fp.call(this, "edwards", t), this.a = new Io(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new Io(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new Io(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), Wq(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
}
Q8(oo, fp);
var Hq = oo;
oo.prototype._mulA = function(e) {
  return this.mOneA ? e.redNeg() : this.a.redMul(e);
};
oo.prototype._mulC = function(e) {
  return this.oneC ? e : this.c.redMul(e);
};
oo.prototype.jpoint = function(e, r, n, i) {
  return this.point(e, r, n, i);
};
oo.prototype.pointFromX = function(e, r) {
  e = new Io(e, 16), e.red || (e = e.toRed(this.red));
  var n = e.redSqr(), i = this.c2.redSub(this.a.redMul(n)), s = this.one.redSub(this.c2.redMul(this.d).redMul(n)), o = i.redMul(s.redInvm()), a = o.redSqrt();
  if (a.redSqr().redSub(o).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var u = a.fromRed().isOdd();
  return (r && !u || !r && u) && (a = a.redNeg()), this.point(e, a);
};
oo.prototype.pointFromY = function(e, r) {
  e = new Io(e, 16), e.red || (e = e.toRed(this.red));
  var n = e.redSqr(), i = n.redSub(this.c2), s = n.redMul(this.d).redMul(this.c2).redSub(this.a), o = i.redMul(s.redInvm());
  if (o.cmp(this.zero) === 0) {
    if (r)
      throw new Error("invalid point");
    return this.point(this.zero, e);
  }
  var a = o.redSqrt();
  if (a.redSqr().redSub(o).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return a.fromRed().isOdd() !== r && (a = a.redNeg()), this.point(a, e);
};
oo.prototype.validate = function(e) {
  if (e.isInfinity())
    return !0;
  e.normalize();
  var r = e.x.redSqr(), n = e.y.redSqr(), i = r.redMul(this.a).redAdd(n), s = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(n)));
  return i.cmp(s) === 0;
};
function Hr(t, e, r, n, i) {
  fp.BasePoint.call(this, t, "projective"), e === null && r === null && n === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new Io(e, 16), this.y = new Io(r, 16), this.z = n ? new Io(n, 16) : this.curve.one, this.t = i && new Io(i, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
Q8(Hr, fp.BasePoint);
oo.prototype.pointFromJSON = function(e) {
  return Hr.fromJSON(this, e);
};
oo.prototype.point = function(e, r, n, i) {
  return new Hr(this, e, r, n, i);
};
Hr.fromJSON = function(e, r) {
  return new Hr(e, r[0], r[1], r[2]);
};
Hr.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Hr.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Hr.prototype._extDbl = function() {
  var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr();
  n = n.redIAdd(n);
  var i = this.curve._mulA(e), s = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r), o = i.redAdd(r), a = o.redSub(n), u = i.redSub(r), l = s.redMul(a), d = o.redMul(u), p = s.redMul(u), w = a.redMul(o);
  return this.curve.point(l, d, w, p);
};
Hr.prototype._projDbl = function() {
  var e = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), n = this.y.redSqr(), i, s, o, a, u, l;
  if (this.curve.twisted) {
    a = this.curve._mulA(r);
    var d = a.redAdd(n);
    this.zOne ? (i = e.redSub(r).redSub(n).redMul(d.redSub(this.curve.two)), s = d.redMul(a.redSub(n)), o = d.redSqr().redSub(d).redSub(d)) : (u = this.z.redSqr(), l = d.redSub(u).redISub(u), i = e.redSub(r).redISub(n).redMul(l), s = d.redMul(a.redSub(n)), o = d.redMul(l));
  } else
    a = r.redAdd(n), u = this.curve._mulC(this.z).redSqr(), l = a.redSub(u).redSub(u), i = this.curve._mulC(e.redISub(a)).redMul(l), s = this.curve._mulC(a).redMul(r.redISub(n)), o = a.redMul(l);
  return this.curve.point(i, s, o);
};
Hr.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Hr.prototype._extAdd = function(e) {
  var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), n = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), i = this.t.redMul(this.curve.dd).redMul(e.t), s = this.z.redMul(e.z.redAdd(e.z)), o = n.redSub(r), a = s.redSub(i), u = s.redAdd(i), l = n.redAdd(r), d = o.redMul(a), p = u.redMul(l), w = o.redMul(l), _ = a.redMul(u);
  return this.curve.point(d, p, _, w);
};
Hr.prototype._projAdd = function(e) {
  var r = this.z.redMul(e.z), n = r.redSqr(), i = this.x.redMul(e.x), s = this.y.redMul(e.y), o = this.curve.d.redMul(i).redMul(s), a = n.redSub(o), u = n.redAdd(o), l = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(i).redISub(s), d = r.redMul(a).redMul(l), p, w;
  return this.curve.twisted ? (p = r.redMul(u).redMul(s.redSub(this.curve._mulA(i))), w = a.redMul(u)) : (p = r.redMul(u).redMul(s.redSub(i)), w = this.curve._mulC(a).redMul(u)), this.curve.point(d, p, w);
};
Hr.prototype.add = function(e) {
  return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
};
Hr.prototype.mul = function(e) {
  return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
};
Hr.prototype.mulAdd = function(e, r, n) {
  return this.curve._wnafMulAdd(1, [this, r], [e, n], 2, !1);
};
Hr.prototype.jmulAdd = function(e, r, n) {
  return this.curve._wnafMulAdd(1, [this, r], [e, n], 2, !0);
};
Hr.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var e = this.z.redInvm();
  return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this;
};
Hr.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Hr.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
Hr.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
Hr.prototype.eq = function(e) {
  return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
};
Hr.prototype.eqXToP = function(e) {
  var r = e.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(r) === 0)
    return !0;
  for (var n = e.clone(), i = this.curve.redN.redMul(this.z); ; ) {
    if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0)
      return !1;
    if (r.redIAdd(i), this.x.cmp(r) === 0)
      return !0;
  }
};
Hr.prototype.toP = Hr.prototype.normalize;
Hr.prototype.mixedAdd = Hr.prototype.add;
(function(t) {
  var e = t;
  e.base = cp, e.short = jq, e.mont = qq, e.edwards = Hq;
})(gb);
var lp = {}, _m, Vx;
function Kq() {
  return Vx || (Vx = 1, _m = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), _m;
}
(function(t) {
  var e = t, r = rh, n = gb, i = ji, s = i.assert;
  function o(l) {
    l.type === "short" ? this.curve = new n.short(l) : l.type === "edwards" ? this.curve = new n.edwards(l) : this.curve = new n.mont(l), this.g = this.curve.g, this.n = this.curve.n, this.hash = l.hash, s(this.g.validate(), "Invalid curve"), s(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  e.PresetCurve = o;
  function a(l, d) {
    Object.defineProperty(e, l, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var p = new o(d);
        return Object.defineProperty(e, l, {
          configurable: !0,
          enumerable: !0,
          value: p
        }), p;
      }
    });
  }
  a("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: r.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), a("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: r.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), a("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: r.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), a("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: r.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), a("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: r.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), a("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: r.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), a("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: r.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var u;
  try {
    u = Kq();
  } catch {
    u = void 0;
  }
  a("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: r.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      u
    ]
  });
})(lp);
var Vq = rh, dc = db, eE = Tc;
function Aa(t) {
  if (!(this instanceof Aa))
    return new Aa(t);
  this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var e = dc.toArray(t.entropy, t.entropyEnc || "hex"), r = dc.toArray(t.nonce, t.nonceEnc || "hex"), n = dc.toArray(t.pers, t.persEnc || "hex");
  eE(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(e, r, n);
}
var Gq = Aa;
Aa.prototype._init = function(e, r, n) {
  var i = e.concat(r).concat(n);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var s = 0; s < this.V.length; s++)
    this.K[s] = 0, this.V[s] = 1;
  this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656;
};
Aa.prototype._hmac = function() {
  return new Vq.hmac(this.hash, this.K);
};
Aa.prototype._update = function(e) {
  var r = this._hmac().update(this.V).update([0]);
  e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
Aa.prototype.reseed = function(e, r, n, i) {
  typeof r != "string" && (i = n, n = r, r = null), e = dc.toArray(e, r), n = dc.toArray(n, i), eE(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(n || [])), this._reseed = 1;
};
Aa.prototype.generate = function(e, r, n, i) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof r != "string" && (i = n, n = r, r = null), n && (n = dc.toArray(n, i || "hex"), this._update(n));
  for (var s = []; s.length < e; )
    this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
  var o = s.slice(0, e);
  return this._update(n), this._reseed++, dc.encode(o, r);
};
var Yq = Ho, Jq = ji, q1 = Jq.assert;
function ti(t, e) {
  this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var Xq = ti;
ti.fromPublic = function(e, r, n) {
  return r instanceof ti ? r : new ti(e, {
    pub: r,
    pubEnc: n
  });
};
ti.fromPrivate = function(e, r, n) {
  return r instanceof ti ? r : new ti(e, {
    priv: r,
    privEnc: n
  });
};
ti.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
ti.prototype.getPublic = function(e, r) {
  return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
};
ti.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
ti.prototype._importPrivate = function(e, r) {
  this.priv = new Yq(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
ti.prototype._importPublic = function(e, r) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? q1(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && q1(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, r);
};
ti.prototype.derive = function(e) {
  return e.validate() || q1(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
ti.prototype.sign = function(e, r, n) {
  return this.ec.sign(e, this, r, n);
};
ti.prototype.verify = function(e, r, n) {
  return this.ec.verify(e, r, this, void 0, n);
};
ti.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var y0 = Ho, vb = ji, Zq = vb.assert;
function hp(t, e) {
  if (t instanceof hp)
    return t;
  this._importDER(t, e) || (Zq(t.r && t.s, "Signature without r or s"), this.r = new y0(t.r, 16), this.s = new y0(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
}
var Qq = hp;
function ez() {
  this.place = 0;
}
function Em(t, e) {
  var r = t[e.place++];
  if (!(r & 128))
    return r;
  var n = r & 15;
  if (n === 0 || n > 4 || t[e.place] === 0)
    return !1;
  for (var i = 0, s = 0, o = e.place; s < n; s++, o++)
    i <<= 8, i |= t[o], i >>>= 0;
  return i <= 127 ? !1 : (e.place = o, i);
}
function Gx(t) {
  for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r; )
    e++;
  return e === 0 ? t : t.slice(e);
}
hp.prototype._importDER = function(e, r) {
  e = vb.toArray(e, r);
  var n = new ez();
  if (e[n.place++] !== 48)
    return !1;
  var i = Em(e, n);
  if (i === !1 || i + n.place !== e.length || e[n.place++] !== 2)
    return !1;
  var s = Em(e, n);
  if (s === !1 || e[n.place] & 128)
    return !1;
  var o = e.slice(n.place, s + n.place);
  if (n.place += s, e[n.place++] !== 2)
    return !1;
  var a = Em(e, n);
  if (a === !1 || e.length !== a + n.place || e[n.place] & 128)
    return !1;
  var u = e.slice(n.place, a + n.place);
  if (o[0] === 0)
    if (o[1] & 128)
      o = o.slice(1);
    else
      return !1;
  if (u[0] === 0)
    if (u[1] & 128)
      u = u.slice(1);
    else
      return !1;
  return this.r = new y0(o), this.s = new y0(u), this.recoveryParam = null, !0;
};
function Sm(t, e) {
  if (e < 128) {
    t.push(e);
    return;
  }
  var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
  for (t.push(r | 128); --r; )
    t.push(e >>> (r << 3) & 255);
  t.push(e);
}
hp.prototype.toDER = function(e) {
  var r = this.r.toArray(), n = this.s.toArray();
  for (r[0] & 128 && (r = [0].concat(r)), n[0] & 128 && (n = [0].concat(n)), r = Gx(r), n = Gx(n); !n[0] && !(n[1] & 128); )
    n = n.slice(1);
  var i = [2];
  Sm(i, r.length), i = i.concat(r), i.push(2), Sm(i, n.length);
  var s = i.concat(n), o = [48];
  return Sm(o, s.length), o = o.concat(s), vb.encode(o, e);
};
var Co = Ho, tE = Gq, tz = ji, Am = lp, rz = X8, rE = tz.assert, bb = Xq, dp = Qq;
function rs(t) {
  if (!(this instanceof rs))
    return new rs(t);
  typeof t == "string" && (rE(
    Object.prototype.hasOwnProperty.call(Am, t),
    "Unknown curve " + t
  ), t = Am[t]), t instanceof Am.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
}
var nz = rs;
rs.prototype.keyPair = function(e) {
  return new bb(this, e);
};
rs.prototype.keyFromPrivate = function(e, r) {
  return bb.fromPrivate(this, e, r);
};
rs.prototype.keyFromPublic = function(e, r) {
  return bb.fromPublic(this, e, r);
};
rs.prototype.genKeyPair = function(e) {
  e || (e = {});
  for (var r = new tE({
    hash: this.hash,
    pers: e.pers,
    persEnc: e.persEnc || "utf8",
    entropy: e.entropy || rz(this.hash.hmacStrength),
    entropyEnc: e.entropy && e.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), n = this.n.byteLength(), i = this.n.sub(new Co(2)); ; ) {
    var s = new Co(r.generate(n));
    if (!(s.cmp(i) > 0))
      return s.iaddn(1), this.keyFromPrivate(s);
  }
};
rs.prototype._truncateToN = function(e, r, n) {
  var i;
  if (Co.isBN(e) || typeof e == "number")
    e = new Co(e, 16), i = e.byteLength();
  else if (typeof e == "object")
    i = e.length, e = new Co(e, 16);
  else {
    var s = e.toString();
    i = s.length + 1 >>> 1, e = new Co(s, 16);
  }
  typeof n != "number" && (n = i * 8);
  var o = n - this.n.bitLength();
  return o > 0 && (e = e.ushrn(o)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
};
rs.prototype.sign = function(e, r, n, i) {
  typeof n == "object" && (i = n, n = null), i || (i = {}), r = this.keyFromPrivate(r, n), e = this._truncateToN(e, !1, i.msgBitLength);
  for (var s = this.n.byteLength(), o = r.getPrivate().toArray("be", s), a = e.toArray("be", s), u = new tE({
    hash: this.hash,
    entropy: o,
    nonce: a,
    pers: i.pers,
    persEnc: i.persEnc || "utf8"
  }), l = this.n.sub(new Co(1)), d = 0; ; d++) {
    var p = i.k ? i.k(d) : new Co(u.generate(this.n.byteLength()));
    if (p = this._truncateToN(p, !0), !(p.cmpn(1) <= 0 || p.cmp(l) >= 0)) {
      var w = this.g.mul(p);
      if (!w.isInfinity()) {
        var _ = w.getX(), P = _.umod(this.n);
        if (P.cmpn(0) !== 0) {
          var O = p.invm(this.n).mul(P.mul(r.getPrivate()).iadd(e));
          if (O = O.umod(this.n), O.cmpn(0) !== 0) {
            var L = (w.getY().isOdd() ? 1 : 0) | (_.cmp(P) !== 0 ? 2 : 0);
            return i.canonical && O.cmp(this.nh) > 0 && (O = this.n.sub(O), L ^= 1), new dp({ r: P, s: O, recoveryParam: L });
          }
        }
      }
    }
  }
};
rs.prototype.verify = function(e, r, n, i, s) {
  s || (s = {}), e = this._truncateToN(e, !1, s.msgBitLength), n = this.keyFromPublic(n, i), r = new dp(r, "hex");
  var o = r.r, a = r.s;
  if (o.cmpn(1) < 0 || o.cmp(this.n) >= 0 || a.cmpn(1) < 0 || a.cmp(this.n) >= 0)
    return !1;
  var u = a.invm(this.n), l = u.mul(e).umod(this.n), d = u.mul(o).umod(this.n), p;
  return this.curve._maxwellTrick ? (p = this.g.jmulAdd(l, n.getPublic(), d), p.isInfinity() ? !1 : p.eqXToP(o)) : (p = this.g.mulAdd(l, n.getPublic(), d), p.isInfinity() ? !1 : p.getX().umod(this.n).cmp(o) === 0);
};
rs.prototype.recoverPubKey = function(t, e, r, n) {
  rE((3 & r) === r, "The recovery param is more than two bits"), e = new dp(e, n);
  var i = this.n, s = new Co(t), o = e.r, a = e.s, u = r & 1, l = r >> 1;
  if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && l)
    throw new Error("Unable to find sencond key candinate");
  l ? o = this.curve.pointFromX(o.add(this.curve.n), u) : o = this.curve.pointFromX(o, u);
  var d = e.r.invm(i), p = i.sub(s).mul(d).umod(i), w = a.mul(d).umod(i);
  return this.g.mulAdd(p, o, w);
};
rs.prototype.getKeyRecoveryParam = function(t, e, r, n) {
  if (e = new dp(e, n), e.recoveryParam !== null)
    return e.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var s;
    try {
      s = this.recoverPubKey(t, e, i);
    } catch {
      continue;
    }
    if (s.eq(r))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var oh = ji, nE = oh.assert, Yx = oh.parseBytes, Gu = oh.cachedProperty;
function Nn(t, e) {
  this.eddsa = t, this._secret = Yx(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = Yx(e.pub);
}
Nn.fromPublic = function(e, r) {
  return r instanceof Nn ? r : new Nn(e, { pub: r });
};
Nn.fromSecret = function(e, r) {
  return r instanceof Nn ? r : new Nn(e, { secret: r });
};
Nn.prototype.secret = function() {
  return this._secret;
};
Gu(Nn, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
Gu(Nn, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
Gu(Nn, "privBytes", function() {
  var e = this.eddsa, r = this.hash(), n = e.encodingLength - 1, i = r.slice(0, e.encodingLength);
  return i[0] &= 248, i[n] &= 127, i[n] |= 64, i;
});
Gu(Nn, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
Gu(Nn, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
Gu(Nn, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
Nn.prototype.sign = function(e) {
  return nE(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
};
Nn.prototype.verify = function(e, r) {
  return this.eddsa.verify(e, r, this);
};
Nn.prototype.getSecret = function(e) {
  return nE(this._secret, "KeyPair is public only"), oh.encode(this.secret(), e);
};
Nn.prototype.getPublic = function(e) {
  return oh.encode(this.pubBytes(), e);
};
var iz = Nn, sz = Ho, pp = ji, Jx = pp.assert, gp = pp.cachedProperty, oz = pp.parseBytes;
function Dc(t, e) {
  this.eddsa = t, typeof e != "object" && (e = oz(e)), Array.isArray(e) && (Jx(e.length === t.encodingLength * 2, "Signature has invalid size"), e = {
    R: e.slice(0, t.encodingLength),
    S: e.slice(t.encodingLength)
  }), Jx(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof sz && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
}
gp(Dc, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
gp(Dc, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
gp(Dc, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
gp(Dc, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
Dc.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
Dc.prototype.toHex = function() {
  return pp.encode(this.toBytes(), "hex").toUpperCase();
};
var az = Dc, cz = rh, uz = lp, Nu = ji, fz = Nu.assert, iE = Nu.parseBytes, sE = iz, Xx = az;
function Si(t) {
  if (fz(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof Si))
    return new Si(t);
  t = uz[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = cz.sha512;
}
var lz = Si;
Si.prototype.sign = function(e, r) {
  e = iE(e);
  var n = this.keyFromSecret(r), i = this.hashInt(n.messagePrefix(), e), s = this.g.mul(i), o = this.encodePoint(s), a = this.hashInt(o, n.pubBytes(), e).mul(n.priv()), u = i.add(a).umod(this.curve.n);
  return this.makeSignature({ R: s, S: u, Rencoded: o });
};
Si.prototype.verify = function(e, r, n) {
  if (e = iE(e), r = this.makeSignature(r), r.S().gte(r.eddsa.curve.n) || r.S().isNeg())
    return !1;
  var i = this.keyFromPublic(n), s = this.hashInt(r.Rencoded(), i.pubBytes(), e), o = this.g.mul(r.S()), a = r.R().add(i.pub().mul(s));
  return a.eq(o);
};
Si.prototype.hashInt = function() {
  for (var e = this.hash(), r = 0; r < arguments.length; r++)
    e.update(arguments[r]);
  return Nu.intFromLE(e.digest()).umod(this.curve.n);
};
Si.prototype.keyFromPublic = function(e) {
  return sE.fromPublic(this, e);
};
Si.prototype.keyFromSecret = function(e) {
  return sE.fromSecret(this, e);
};
Si.prototype.makeSignature = function(e) {
  return e instanceof Xx ? e : new Xx(this, e);
};
Si.prototype.encodePoint = function(e) {
  var r = e.getY().toArray("le", this.encodingLength);
  return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r;
};
Si.prototype.decodePoint = function(e) {
  e = Nu.parseBytes(e);
  var r = e.length - 1, n = e.slice(0, r).concat(e[r] & -129), i = (e[r] & 128) !== 0, s = Nu.intFromLE(n);
  return this.curve.pointFromY(s, i);
};
Si.prototype.encodeInt = function(e) {
  return e.toArray("le", this.encodingLength);
};
Si.prototype.decodeInt = function(e) {
  return Nu.intFromLE(e);
};
Si.prototype.isPoint = function(e) {
  return e instanceof this.pointClass;
};
(function(t) {
  var e = t;
  e.version = kq.version, e.utils = ji, e.rand = X8, e.curve = gb, e.curves = lp, e.ec = nz, e.eddsa = lz;
})(J8);
const hz = { waku: { publish: "waku_publish", batchPublish: "waku_batchPublish", subscribe: "waku_subscribe", batchSubscribe: "waku_batchSubscribe", subscription: "waku_subscription", unsubscribe: "waku_unsubscribe", batchUnsubscribe: "waku_batchUnsubscribe", batchFetchMessages: "waku_batchFetchMessages" }, irn: { publish: "irn_publish", batchPublish: "irn_batchPublish", subscribe: "irn_subscribe", batchSubscribe: "irn_batchSubscribe", subscription: "irn_subscription", unsubscribe: "irn_unsubscribe", batchUnsubscribe: "irn_batchUnsubscribe", batchFetchMessages: "irn_batchFetchMessages" }, iridium: { publish: "iridium_publish", batchPublish: "iridium_batchPublish", subscribe: "iridium_subscribe", batchSubscribe: "iridium_batchSubscribe", subscription: "iridium_subscription", unsubscribe: "iridium_unsubscribe", batchUnsubscribe: "iridium_batchUnsubscribe", batchFetchMessages: "iridium_batchFetchMessages" } }, dz = ":";
function _u(t) {
  const [e, r] = t.split(dz);
  return { namespace: e, reference: r };
}
function oE(t, e) {
  return t.includes(":") ? [t] : e.chains || [];
}
var pz = Object.defineProperty, Zx = Object.getOwnPropertySymbols, gz = Object.prototype.hasOwnProperty, mz = Object.prototype.propertyIsEnumerable, Qx = (t, e, r) => e in t ? pz(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, e3 = (t, e) => {
  for (var r in e || (e = {})) gz.call(e, r) && Qx(t, r, e[r]);
  if (Zx) for (var r of Zx(e)) mz.call(e, r) && Qx(t, r, e[r]);
  return t;
};
const vz = "ReactNative", Oi = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, bz = "js";
function w0() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function Yu() {
  return !th() && !!eb() && navigator.product === vz;
}
function ah() {
  return !w0() && !!eb() && !!th();
}
function ch() {
  return Yu() ? Oi.reactNative : w0() ? Oi.node : ah() ? Oi.browser : Oi.unknown;
}
function yz() {
  var t;
  try {
    return Yu() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (t = global.Application) == null ? void 0 : t.applicationId : void 0;
  } catch {
    return;
  }
}
function wz(t, e) {
  let r = Dl.parse(t);
  return r = e3(e3({}, r), e), t = Dl.stringify(r), t;
}
function aE() {
  return v8() || { name: "", description: "", url: "", icons: [""] };
}
function xz() {
  if (ch() === Oi.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: r, Version: n } = global.Platform;
    return [r, n].join("-");
  }
  const t = OF();
  if (t === null) return "unknown";
  const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
  return t.type === "browser" ? [e, t.name, t.version].join("-") : [e, t.version].join("-");
}
function _z() {
  var t;
  const e = ch();
  return e === Oi.browser ? [e, ((t = m8()) == null ? void 0 : t.host) || "unknown"].join(":") : e;
}
function cE(t, e, r) {
  const n = xz(), i = _z();
  return [[t, e].join("-"), [bz, r].join("-"), n, i].join("/");
}
function Ez({ protocol: t, version: e, relayUrl: r, sdkVersion: n, auth: i, projectId: s, useOnCloseEvent: o, bundleId: a }) {
  const u = r.split("?"), l = cE(t, e, n), d = { auth: i, ua: l, projectId: s, useOnCloseEvent: o, origin: a || void 0 }, p = wz(u[1] || "", d);
  return u[0] + "?" + p;
}
function uc(t, e) {
  return t.filter((r) => e.includes(r)).length === t.length;
}
function uE(t) {
  return Object.fromEntries(t.entries());
}
function fE(t) {
  return new Map(Object.entries(t));
}
function ec(t = vt.FIVE_MINUTES, e) {
  const r = vt.toMiliseconds(t || vt.FIVE_MINUTES);
  let n, i, s;
  return { resolve: (o) => {
    s && n && (clearTimeout(s), n(o));
  }, reject: (o) => {
    s && i && (clearTimeout(s), i(o));
  }, done: () => new Promise((o, a) => {
    s = setTimeout(() => {
      a(new Error(e));
    }, r), n = o, i = a;
  }) };
}
function Eu(t, e, r) {
  return new Promise(async (n, i) => {
    const s = setTimeout(() => i(new Error(r)), e);
    try {
      const o = await t;
      n(o);
    } catch (o) {
      i(o);
    }
    clearTimeout(s);
  });
}
function lE(t, e) {
  if (typeof e == "string" && e.startsWith(`${t}:`)) return e;
  if (t.toLowerCase() === "topic") {
    if (typeof e != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (t.toLowerCase() === "id") {
    if (typeof e != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${t}`);
}
function Sz(t) {
  return lE("topic", t);
}
function Az(t) {
  return lE("id", t);
}
function hE(t) {
  const [e, r] = t.split(":"), n = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof r == "string") n.topic = r;
  else if (e === "id" && Number.isInteger(Number(r))) n.id = Number(r);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${r}`);
  return n;
}
function Sn(t, e) {
  return vt.fromMiliseconds(Date.now() + vt.toMiliseconds(t));
}
function fa(t) {
  return Date.now() >= vt.toMiliseconds(t);
}
function yr(t, e) {
  return `${t}${e ? `:${e}` : ""}`;
}
function jd(t = [], e = []) {
  return [.../* @__PURE__ */ new Set([...t, ...e])];
}
async function Pz({ id: t, topic: e, wcDeepLink: r }) {
  var n;
  try {
    if (!r) return;
    const i = typeof r == "string" ? JSON.parse(r) : r, s = i == null ? void 0 : i.href;
    if (typeof s != "string") return;
    const o = Mz(s, t, e), a = ch();
    if (a === Oi.browser) {
      if (!((n = th()) != null && n.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      o.startsWith("https://") || o.startsWith("http://") ? window.open(o, "_blank", "noreferrer noopener") : window.open(o, Cz() ? "_blank" : "_self", "noreferrer noopener");
    } else a === Oi.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(o);
  } catch (i) {
    console.error(i);
  }
}
function Mz(t, e, r) {
  const n = `requestId=${e}&sessionTopic=${r}`;
  t.endsWith("/") && (t = t.slice(0, -1));
  let i = `${t}`;
  if (t.startsWith("https://t.me")) {
    const s = t.includes("?") ? "&startapp=" : "?startapp=";
    i = `${i}${s}${Tz(n, !0)}`;
  } else i = `${i}/wc?${n}`;
  return i;
}
async function Iz(t, e) {
  let r = "";
  try {
    if (ah() && (r = localStorage.getItem(e), r)) return r;
    r = await t.getItem(e);
  } catch (n) {
    console.error(n);
  }
  return r;
}
function t3(t, e) {
  if (!t.includes(e)) return null;
  const r = t.split(/([&,?,=])/), n = r.indexOf(e);
  return r[n + 2];
}
function r3() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t) => {
    const e = Math.random() * 16 | 0;
    return (t === "x" ? e : e & 3 | 8).toString(16);
  });
}
function yb() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function Cz() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function Tz(t, e = !1) {
  const r = Buffer.from(t).toString("base64");
  return e ? r.replace(/[=]/g, "") : r;
}
function dE(t) {
  return Buffer.from(t, "base64").toString("utf-8");
}
const Rz = "https://rpc.walletconnect.org/v1";
async function Dz(t, e, r, n, i, s) {
  switch (r.t) {
    case "eip191":
      return Oz(t, e, r.s);
    case "eip1271":
      return await Nz(t, e, r.s, n, i, s);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${r.t}`);
  }
}
function Oz(t, e, r) {
  return cq(_8(e), r).toLowerCase() === t.toLowerCase();
}
async function Nz(t, e, r, n, i, s) {
  const o = _u(n);
  if (!o.namespace || !o.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${n}`);
  try {
    const a = "0x1626ba7e", u = "0000000000000000000000000000000000000000000000000000000000000040", l = "0000000000000000000000000000000000000000000000000000000000000041", d = r.substring(2), p = _8(e).substring(2), w = a + p + u + l + d, _ = await fetch(`${s || Rz}/?chainId=${n}&projectId=${i}`, { method: "POST", body: JSON.stringify({ id: Lz(), jsonrpc: "2.0", method: "eth_call", params: [{ to: t, data: w }, "latest"] }) }), { result: P } = await _.json();
    return P ? P.slice(0, a.length).toLowerCase() === a.toLowerCase() : !1;
  } catch (a) {
    return console.error("isValidEip1271Signature: ", a), !1;
  }
}
function Lz() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
var kz = Object.defineProperty, $z = Object.defineProperties, Bz = Object.getOwnPropertyDescriptors, n3 = Object.getOwnPropertySymbols, Fz = Object.prototype.hasOwnProperty, jz = Object.prototype.propertyIsEnumerable, i3 = (t, e, r) => e in t ? kz(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Uz = (t, e) => {
  for (var r in e || (e = {})) Fz.call(e, r) && i3(t, r, e[r]);
  if (n3) for (var r of n3(e)) jz.call(e, r) && i3(t, r, e[r]);
  return t;
}, qz = (t, e) => $z(t, Bz(e));
const zz = "did:pkh:", wb = (t) => t == null ? void 0 : t.split(":"), Wz = (t) => {
  const e = t && wb(t);
  if (e) return t.includes(zz) ? e[3] : e[1];
}, z1 = (t) => {
  const e = t && wb(t);
  if (e) return e[2] + ":" + e[3];
}, x0 = (t) => {
  const e = t && wb(t);
  if (e) return e.pop();
};
async function s3(t) {
  const { cacao: e, projectId: r } = t, { s: n, p: i } = e, s = pE(i, i.iss), o = x0(i.iss);
  return await Dz(o, s, n, z1(i.iss), r);
}
const pE = (t, e) => {
  const r = `${t.domain} wants you to sign in with your Ethereum account:`, n = x0(e);
  if (!t.aud && !t.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let i = t.statement || void 0;
  const s = `URI: ${t.aud || t.uri}`, o = `Version: ${t.version}`, a = `Chain ID: ${Wz(e)}`, u = `Nonce: ${t.nonce}`, l = `Issued At: ${t.iat}`, d = t.exp ? `Expiration Time: ${t.exp}` : void 0, p = t.nbf ? `Not Before: ${t.nbf}` : void 0, w = t.requestId ? `Request ID: ${t.requestId}` : void 0, _ = t.resources ? `Resources:${t.resources.map((O) => `
- ${O}`).join("")}` : void 0, P = Ud(t.resources);
  if (P) {
    const O = Ol(P);
    i = Qz(i, O);
  }
  return [r, n, "", i, "", s, o, a, u, l, d, p, w, _].filter((O) => O != null).join(`
`);
};
function Hz(t) {
  return Buffer.from(JSON.stringify(t)).toString("base64");
}
function Kz(t) {
  return JSON.parse(Buffer.from(t, "base64").toString("utf-8"));
}
function wc(t) {
  if (!t) throw new Error("No recap provided, value is undefined");
  if (!t.att) throw new Error("No `att` property found");
  const e = Object.keys(t.att);
  if (!(e != null && e.length)) throw new Error("No resources found in `att` property");
  e.forEach((r) => {
    const n = t.att[r];
    if (Array.isArray(n)) throw new Error(`Resource must be an object: ${r}`);
    if (typeof n != "object") throw new Error(`Resource must be an object: ${r}`);
    if (!Object.keys(n).length) throw new Error(`Resource object is empty: ${r}`);
    Object.keys(n).forEach((i) => {
      const s = n[i];
      if (!Array.isArray(s)) throw new Error(`Ability limits ${i} must be an array of objects, found: ${s}`);
      if (!s.length) throw new Error(`Value of ${i} is empty array, must be an array with objects`);
      s.forEach((o) => {
        if (typeof o != "object") throw new Error(`Ability limits (${i}) must be an array of objects, found: ${o}`);
      });
    });
  });
}
function Vz(t, e, r, n = {}) {
  return r == null || r.sort((i, s) => i.localeCompare(s)), { att: { [t]: Gz(e, r, n) } };
}
function Gz(t, e, r = {}) {
  e = e == null ? void 0 : e.sort((i, s) => i.localeCompare(s));
  const n = e.map((i) => ({ [`${t}/${i}`]: [r] }));
  return Object.assign({}, ...n);
}
function gE(t) {
  return wc(t), `urn:recap:${Hz(t).replace(/=/g, "")}`;
}
function Ol(t) {
  const e = Kz(t.replace("urn:recap:", ""));
  return wc(e), e;
}
function Yz(t, e, r) {
  const n = Vz(t, e, r);
  return gE(n);
}
function Jz(t) {
  return t && t.includes("urn:recap:");
}
function Xz(t, e) {
  const r = Ol(t), n = Ol(e), i = Zz(r, n);
  return gE(i);
}
function Zz(t, e) {
  wc(t), wc(e);
  const r = Object.keys(t.att).concat(Object.keys(e.att)).sort((i, s) => i.localeCompare(s)), n = { att: {} };
  return r.forEach((i) => {
    var s, o;
    Object.keys(((s = t.att) == null ? void 0 : s[i]) || {}).concat(Object.keys(((o = e.att) == null ? void 0 : o[i]) || {})).sort((a, u) => a.localeCompare(u)).forEach((a) => {
      var u, l;
      n.att[i] = qz(Uz({}, n.att[i]), { [a]: ((u = t.att[i]) == null ? void 0 : u[a]) || ((l = e.att[i]) == null ? void 0 : l[a]) });
    });
  }), n;
}
function Qz(t = "", e) {
  wc(e);
  const r = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (t.includes(r)) return t;
  const n = [];
  let i = 0;
  Object.keys(e.att).forEach((a) => {
    const u = Object.keys(e.att[a]).map((p) => ({ ability: p.split("/")[0], action: p.split("/")[1] }));
    u.sort((p, w) => p.action.localeCompare(w.action));
    const l = {};
    u.forEach((p) => {
      l[p.ability] || (l[p.ability] = []), l[p.ability].push(p.action);
    });
    const d = Object.keys(l).map((p) => (i++, `(${i}) '${p}': '${l[p].join("', '")}' for '${a}'.`));
    n.push(d.join(", ").replace(".,", "."));
  });
  const s = n.join(" "), o = `${r}${s}`;
  return `${t ? t + " " : ""}${o}`;
}
function o3(t) {
  var e;
  const r = Ol(t);
  wc(r);
  const n = (e = r.att) == null ? void 0 : e.eip155;
  return n ? Object.keys(n).map((i) => i.split("/")[1]) : [];
}
function a3(t) {
  const e = Ol(t);
  wc(e);
  const r = [];
  return Object.values(e.att).forEach((n) => {
    Object.values(n).forEach((i) => {
      var s;
      (s = i == null ? void 0 : i[0]) != null && s.chains && r.push(i[0].chains);
    });
  }), [...new Set(r.flat())];
}
function Ud(t) {
  if (!t) return;
  const e = t == null ? void 0 : t[t.length - 1];
  return Jz(e) ? e : void 0;
}
const mE = "base10", ci = "base16", pa = "base64pad", Df = "base64url", uh = "utf8", vE = 0, Oo = 1, fh = 2, eW = 0, c3 = 1, Yf = 12, xb = 32;
function tW() {
  const t = lb.generateKeyPair();
  return { privateKey: On(t.secretKey, ci), publicKey: On(t.publicKey, ci) };
}
function W1() {
  const t = Da.randomBytes(xb);
  return On(t, ci);
}
function rW(t, e) {
  const r = lb.sharedKey(Rn(t, ci), Rn(e, ci), !0), n = new xq(ih.SHA256, r).expand(xb);
  return On(n, ci);
}
function qd(t) {
  const e = ih.hash(Rn(t, ci));
  return On(e, ci);
}
function Ao(t) {
  const e = ih.hash(Rn(t, uh));
  return On(e, ci);
}
function bE(t) {
  return Rn(`${t}`, mE);
}
function xc(t) {
  return Number(On(t, mE));
}
function nW(t) {
  const e = bE(typeof t.type < "u" ? t.type : vE);
  if (xc(e) === Oo && typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const r = typeof t.senderPublicKey < "u" ? Rn(t.senderPublicKey, ci) : void 0, n = typeof t.iv < "u" ? Rn(t.iv, ci) : Da.randomBytes(Yf), i = new ub.ChaCha20Poly1305(Rn(t.symKey, ci)).seal(n, Rn(t.message, uh));
  return yE({ type: e, sealed: i, iv: n, senderPublicKey: r, encoding: t.encoding });
}
function iW(t, e) {
  const r = bE(fh), n = Da.randomBytes(Yf), i = Rn(t, uh);
  return yE({ type: r, sealed: i, iv: n, encoding: e });
}
function sW(t) {
  const e = new ub.ChaCha20Poly1305(Rn(t.symKey, ci)), { sealed: r, iv: n } = Nl({ encoded: t.encoded, encoding: t == null ? void 0 : t.encoding }), i = e.open(n, r);
  if (i === null) throw new Error("Failed to decrypt");
  return On(i, uh);
}
function oW(t, e) {
  const { sealed: r } = Nl({ encoded: t, encoding: e });
  return On(r, uh);
}
function yE(t) {
  const { encoding: e = pa } = t;
  if (xc(t.type) === fh) return On(kd([t.type, t.sealed]), e);
  if (xc(t.type) === Oo) {
    if (typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return On(kd([t.type, t.senderPublicKey, t.iv, t.sealed]), e);
  }
  return On(kd([t.type, t.iv, t.sealed]), e);
}
function Nl(t) {
  const { encoded: e, encoding: r = pa } = t, n = Rn(e, r), i = n.slice(eW, c3), s = c3;
  if (xc(i) === Oo) {
    const l = s + xb, d = l + Yf, p = n.slice(s, l), w = n.slice(l, d), _ = n.slice(d);
    return { type: i, sealed: _, iv: w, senderPublicKey: p };
  }
  if (xc(i) === fh) {
    const l = n.slice(s), d = Da.randomBytes(Yf);
    return { type: i, sealed: l, iv: d };
  }
  const o = s + Yf, a = n.slice(s, o), u = n.slice(o);
  return { type: i, sealed: u, iv: a };
}
function aW(t, e) {
  const r = Nl({ encoded: t, encoding: e == null ? void 0 : e.encoding });
  return wE({ type: xc(r.type), senderPublicKey: typeof r.senderPublicKey < "u" ? On(r.senderPublicKey, ci) : void 0, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey });
}
function wE(t) {
  const e = (t == null ? void 0 : t.type) || vE;
  if (e === Oo) {
    if (typeof (t == null ? void 0 : t.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (t == null ? void 0 : t.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: t == null ? void 0 : t.senderPublicKey, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey };
}
function u3(t) {
  return t.type === Oo && typeof t.senderPublicKey == "string" && typeof t.receiverPublicKey == "string";
}
function f3(t) {
  return t.type === fh;
}
function cW(t) {
  return new J8.ec("p256").keyFromPublic({ x: Buffer.from(t.x, "base64").toString("hex"), y: Buffer.from(t.y, "base64").toString("hex") }, "hex");
}
function uW(t) {
  let e = t.replace(/-/g, "+").replace(/_/g, "/");
  const r = e.length % 4;
  return r > 0 && (e += "=".repeat(4 - r)), e;
}
function fW(t) {
  return Buffer.from(uW(t), "base64");
}
function lW(t, e) {
  const [r, n, i] = t.split("."), s = fW(i);
  if (s.length !== 64) throw new Error("Invalid signature length");
  const o = s.slice(0, 32).toString("hex"), a = s.slice(32, 64).toString("hex"), u = `${r}.${n}`, l = new ih.SHA256().update(Buffer.from(u)).digest(), d = cW(e), p = Buffer.from(l).toString("hex");
  if (!d.verify(p, { r: o, s: a })) throw new Error("Invalid signature");
  return O1(t).payload;
}
const hW = "irn";
function H1(t) {
  return (t == null ? void 0 : t.relay) || { protocol: hW };
}
function Hf(t) {
  const e = hz[t];
  if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${t}`);
  return e;
}
var dW = Object.defineProperty, pW = Object.defineProperties, gW = Object.getOwnPropertyDescriptors, l3 = Object.getOwnPropertySymbols, mW = Object.prototype.hasOwnProperty, vW = Object.prototype.propertyIsEnumerable, h3 = (t, e, r) => e in t ? dW(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, d3 = (t, e) => {
  for (var r in e || (e = {})) mW.call(e, r) && h3(t, r, e[r]);
  if (l3) for (var r of l3(e)) vW.call(e, r) && h3(t, r, e[r]);
  return t;
}, bW = (t, e) => pW(t, gW(e));
function yW(t, e = "-") {
  const r = {}, n = "relay" + e;
  return Object.keys(t).forEach((i) => {
    if (i.startsWith(n)) {
      const s = i.replace(n, ""), o = t[i];
      r[s] = o;
    }
  }), r;
}
function p3(t) {
  if (!t.includes("wc:")) {
    const u = dE(t);
    u != null && u.includes("wc:") && (t = u);
  }
  t = t.includes("wc://") ? t.replace("wc://", "") : t, t = t.includes("wc:") ? t.replace("wc:", "") : t;
  const e = t.indexOf(":"), r = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0, n = t.substring(0, e), i = t.substring(e + 1, r).split("@"), s = typeof r < "u" ? t.substring(r) : "", o = Dl.parse(s), a = typeof o.methods == "string" ? o.methods.split(",") : void 0;
  return { protocol: n, topic: wW(i[0]), version: parseInt(i[1], 10), symKey: o.symKey, relay: yW(o), methods: a, expiryTimestamp: o.expiryTimestamp ? parseInt(o.expiryTimestamp, 10) : void 0 };
}
function wW(t) {
  return t.startsWith("//") ? t.substring(2) : t;
}
function xW(t, e = "-") {
  const r = "relay", n = {};
  return Object.keys(t).forEach((i) => {
    const s = r + e + i;
    t[i] && (n[s] = t[i]);
  }), n;
}
function g3(t) {
  return `${t.protocol}:${t.topic}@${t.version}?` + Dl.stringify(d3(bW(d3({ symKey: t.symKey }, xW(t.relay)), { expiryTimestamp: t.expiryTimestamp }), t.methods ? { methods: t.methods.join(",") } : {}));
}
function xd(t, e, r) {
  return `${t}?wc_ev=${r}&topic=${e}`;
}
function Ju(t) {
  const e = [];
  return t.forEach((r) => {
    const [n, i] = r.split(":");
    e.push(`${n}:${i}`);
  }), e;
}
function _W(t) {
  const e = [];
  return Object.values(t).forEach((r) => {
    e.push(...Ju(r.accounts));
  }), e;
}
function EW(t, e) {
  const r = [];
  return Object.values(t).forEach((n) => {
    Ju(n.accounts).includes(e) && r.push(...n.methods);
  }), r;
}
function SW(t, e) {
  const r = [];
  return Object.values(t).forEach((n) => {
    Ju(n.accounts).includes(e) && r.push(...n.events);
  }), r;
}
function _b(t) {
  return t.includes(":");
}
function Kf(t) {
  return _b(t) ? t.split(":")[0] : t;
}
function AW(t) {
  const e = {};
  return t == null || t.forEach((r) => {
    const [n, i] = r.split(":");
    e[n] || (e[n] = { accounts: [], chains: [], events: [] }), e[n].accounts.push(r), e[n].chains.push(`${n}:${i}`);
  }), e;
}
function m3(t, e) {
  e = e.map((n) => n.replace("did:pkh:", ""));
  const r = AW(e);
  for (const [n, i] of Object.entries(r)) i.methods ? i.methods = jd(i.methods, t) : i.methods = t, i.events = ["chainChanged", "accountsChanged"];
  return r;
}
const PW = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, MW = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function ft(t, e) {
  const { message: r, code: n } = MW[t];
  return { message: e ? `${r} ${e}` : r, code: n };
}
function Or(t, e) {
  const { message: r, code: n } = PW[t];
  return { message: e ? `${r} ${e}` : r, code: n };
}
function _c(t, e) {
  return !!Array.isArray(t);
}
function Ll(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;
}
function vi(t) {
  return typeof t > "u";
}
function dn(t, e) {
  return e && vi(t) ? !0 : typeof t == "string" && !!t.trim().length;
}
function Eb(t, e) {
  return typeof t == "number" && !isNaN(t);
}
function IW(t, e) {
  const { requiredNamespaces: r } = e, n = Object.keys(t.namespaces), i = Object.keys(r);
  let s = !0;
  return uc(i, n) ? (n.forEach((o) => {
    const { accounts: a, methods: u, events: l } = t.namespaces[o], d = Ju(a), p = r[o];
    (!uc(oE(o, p), d) || !uc(p.methods, u) || !uc(p.events, l)) && (s = !1);
  }), s) : !1;
}
function _0(t) {
  return dn(t, !1) && t.includes(":") ? t.split(":").length === 2 : !1;
}
function CW(t) {
  if (dn(t, !1) && t.includes(":")) {
    const e = t.split(":");
    if (e.length === 3) {
      const r = e[0] + ":" + e[1];
      return !!e[2] && _0(r);
    }
  }
  return !1;
}
function TW(t) {
  function e(r) {
    try {
      return typeof new URL(r) < "u";
    } catch {
      return !1;
    }
  }
  try {
    if (dn(t, !1)) {
      if (e(t)) return !0;
      const r = dE(t);
      return e(r);
    }
  } catch {
  }
  return !1;
}
function RW(t) {
  var e;
  return (e = t == null ? void 0 : t.proposer) == null ? void 0 : e.publicKey;
}
function DW(t) {
  return t == null ? void 0 : t.topic;
}
function OW(t, e) {
  let r = null;
  return dn(t == null ? void 0 : t.publicKey, !1) || (r = ft("MISSING_OR_INVALID", `${e} controller public key should be a string`)), r;
}
function v3(t) {
  let e = !0;
  return _c(t) ? t.length && (e = t.every((r) => dn(r, !1))) : e = !1, e;
}
function NW(t, e, r) {
  let n = null;
  return _c(e) && e.length ? e.forEach((i) => {
    n || _0(i) || (n = Or("UNSUPPORTED_CHAINS", `${r}, chain ${i} should be a string and conform to "namespace:chainId" format`));
  }) : _0(t) || (n = Or("UNSUPPORTED_CHAINS", `${r}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), n;
}
function LW(t, e, r) {
  let n = null;
  return Object.entries(t).forEach(([i, s]) => {
    if (n) return;
    const o = NW(i, oE(i, s), `${e} ${r}`);
    o && (n = o);
  }), n;
}
function kW(t, e) {
  let r = null;
  return _c(t) ? t.forEach((n) => {
    r || CW(n) || (r = Or("UNSUPPORTED_ACCOUNTS", `${e}, account ${n} should be a string and conform to "namespace:chainId:address" format`));
  }) : r = Or("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), r;
}
function $W(t, e) {
  let r = null;
  return Object.values(t).forEach((n) => {
    if (r) return;
    const i = kW(n == null ? void 0 : n.accounts, `${e} namespace`);
    i && (r = i);
  }), r;
}
function BW(t, e) {
  let r = null;
  return v3(t == null ? void 0 : t.methods) ? v3(t == null ? void 0 : t.events) || (r = Or("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : r = Or("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), r;
}
function xE(t, e) {
  let r = null;
  return Object.values(t).forEach((n) => {
    if (r) return;
    const i = BW(n, `${e}, namespace`);
    i && (r = i);
  }), r;
}
function FW(t, e, r) {
  let n = null;
  if (t && Ll(t)) {
    const i = xE(t, e);
    i && (n = i);
    const s = LW(t, e, r);
    s && (n = s);
  } else n = ft("MISSING_OR_INVALID", `${e}, ${r} should be an object with data`);
  return n;
}
function Pm(t, e) {
  let r = null;
  if (t && Ll(t)) {
    const n = xE(t, e);
    n && (r = n);
    const i = $W(t, e);
    i && (r = i);
  } else r = ft("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return r;
}
function _E(t) {
  return dn(t.protocol, !0);
}
function jW(t, e) {
  let r = !1;
  return t ? t && _c(t) && t.length && t.forEach((n) => {
    r = _E(n);
  }) : r = !0, r;
}
function UW(t) {
  return typeof t == "number";
}
function mi(t) {
  return typeof t < "u" && typeof t !== null;
}
function qW(t) {
  return !(!t || typeof t != "object" || !t.code || !Eb(t.code) || !t.message || !dn(t.message, !1));
}
function zW(t) {
  return !(vi(t) || !dn(t.method, !1));
}
function WW(t) {
  return !(vi(t) || vi(t.result) && vi(t.error) || !Eb(t.id) || !dn(t.jsonrpc, !1));
}
function HW(t) {
  return !(vi(t) || !dn(t.name, !1));
}
function b3(t, e) {
  return !(!_0(e) || !_W(t).includes(e));
}
function KW(t, e, r) {
  return dn(r, !1) ? EW(t, e).includes(r) : !1;
}
function VW(t, e, r) {
  return dn(r, !1) ? SW(t, e).includes(r) : !1;
}
function y3(t, e, r) {
  let n = null;
  const i = GW(t), s = YW(e), o = Object.keys(i), a = Object.keys(s), u = w3(Object.keys(t)), l = w3(Object.keys(e)), d = u.filter((p) => !l.includes(p));
  return d.length && (n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces keys don't satisfy requiredNamespaces.
      Required: ${d.toString()}
      Received: ${Object.keys(e).toString()}`)), uc(o, a) || (n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`)), Object.keys(e).forEach((p) => {
    if (!p.includes(":") || n) return;
    const w = Ju(e[p].accounts);
    w.includes(p) || (n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces accounts don't satisfy namespace accounts for ${p}
        Required: ${p}
        Approved: ${w.toString()}`));
  }), o.forEach((p) => {
    n || (uc(i[p].methods, s[p].methods) ? uc(i[p].events, s[p].events) || (n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces events don't satisfy namespace events for ${p}`)) : n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces methods don't satisfy namespace methods for ${p}`));
  }), n;
}
function GW(t) {
  const e = {};
  return Object.keys(t).forEach((r) => {
    var n;
    r.includes(":") ? e[r] = t[r] : (n = t[r].chains) == null || n.forEach((i) => {
      e[i] = { methods: t[r].methods, events: t[r].events };
    });
  }), e;
}
function w3(t) {
  return [...new Set(t.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function YW(t) {
  const e = {};
  return Object.keys(t).forEach((r) => {
    if (r.includes(":")) e[r] = t[r];
    else {
      const n = Ju(t[r].accounts);
      n == null || n.forEach((i) => {
        e[i] = { accounts: t[r].accounts.filter((s) => s.includes(`${i}:`)), methods: t[r].methods, events: t[r].events };
      });
    }
  }), e;
}
function JW(t, e) {
  return Eb(t) && t <= e.max && t >= e.min;
}
function x3() {
  const t = ch();
  return new Promise((e) => {
    switch (t) {
      case Oi.browser:
        e(XW());
        break;
      case Oi.reactNative:
        e(ZW());
        break;
      case Oi.node:
        e(QW());
        break;
      default:
        e(!0);
    }
  });
}
function XW() {
  return ah() && (navigator == null ? void 0 : navigator.onLine);
}
async function ZW() {
  if (Yu() && typeof global < "u" && global != null && global.NetInfo) {
    const t = await (global == null ? void 0 : global.NetInfo.fetch());
    return t == null ? void 0 : t.isConnected;
  }
  return !0;
}
function QW() {
  return !0;
}
function eH(t) {
  switch (ch()) {
    case Oi.browser:
      tH(t);
      break;
    case Oi.reactNative:
      rH(t);
      break;
  }
}
function tH(t) {
  !Yu() && ah() && (window.addEventListener("online", () => t(!0)), window.addEventListener("offline", () => t(!1)));
}
function rH(t) {
  Yu() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener((e) => t(e == null ? void 0 : e.isConnected)));
}
const Mm = {};
class Of {
  static get(e) {
    return Mm[e];
  }
  static set(e, r) {
    Mm[e] = r;
  }
  static delete(e) {
    delete Mm[e];
  }
}
const nH = "PARSE_ERROR", iH = "INVALID_REQUEST", sH = "METHOD_NOT_FOUND", oH = "INVALID_PARAMS", EE = "INTERNAL_ERROR", Sb = "SERVER_ERROR", aH = [-32700, -32600, -32601, -32602, -32603], Jf = {
  [nH]: { code: -32700, message: "Parse error" },
  [iH]: { code: -32600, message: "Invalid Request" },
  [sH]: { code: -32601, message: "Method not found" },
  [oH]: { code: -32602, message: "Invalid params" },
  [EE]: { code: -32603, message: "Internal error" },
  [Sb]: { code: -32e3, message: "Server error" }
}, SE = Sb;
function cH(t) {
  return aH.includes(t);
}
function _3(t) {
  return Object.keys(Jf).includes(t) ? Jf[t] : Jf[SE];
}
function uH(t) {
  const e = Object.values(Jf).find((r) => r.code === t);
  return e || Jf[SE];
}
function AE(t, e, r) {
  return t.message.includes("getaddrinfo ENOTFOUND") || t.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${r} RPC url at ${e}`) : t;
}
var PE = {}, wo = {}, E3;
function fH() {
  if (E3) return wo;
  E3 = 1, Object.defineProperty(wo, "__esModule", { value: !0 }), wo.isBrowserCryptoAvailable = wo.getSubtleCrypto = wo.getBrowerCrypto = void 0;
  function t() {
    return (gn == null ? void 0 : gn.crypto) || (gn == null ? void 0 : gn.msCrypto) || {};
  }
  wo.getBrowerCrypto = t;
  function e() {
    const n = t();
    return n.subtle || n.webkitSubtle;
  }
  wo.getSubtleCrypto = e;
  function r() {
    return !!t() && !!e();
  }
  return wo.isBrowserCryptoAvailable = r, wo;
}
var xo = {}, S3;
function lH() {
  if (S3) return xo;
  S3 = 1, Object.defineProperty(xo, "__esModule", { value: !0 }), xo.isBrowser = xo.isNode = xo.isReactNative = void 0;
  function t() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  xo.isReactNative = t;
  function e() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
  }
  xo.isNode = e;
  function r() {
    return !t() && !e();
  }
  return xo.isBrowser = r, xo;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = Yl;
  e.__exportStar(fH(), t), e.__exportStar(lH(), t);
})(PE);
function la(t = 3) {
  const e = Date.now() * Math.pow(10, t), r = Math.floor(Math.random() * Math.pow(10, t));
  return e + r;
}
function fc(t = 6) {
  return BigInt(la(t));
}
function ga(t, e, r) {
  return {
    id: r || la(),
    jsonrpc: "2.0",
    method: t,
    params: e
  };
}
function mp(t, e) {
  return {
    id: t,
    jsonrpc: "2.0",
    result: e
  };
}
function vp(t, e, r) {
  return {
    id: t,
    jsonrpc: "2.0",
    error: hH(e)
  };
}
function hH(t, e) {
  return typeof t > "u" ? _3(EE) : (typeof t == "string" && (t = Object.assign(Object.assign({}, _3(Sb)), { message: t })), cH(t.code) && (t = uH(t.code)), t);
}
let dH = class {
}, pH = class extends dH {
  constructor() {
    super();
  }
}, gH = class extends pH {
  constructor(e) {
    super();
  }
};
const mH = "^https?:", vH = "^wss?:";
function bH(t) {
  const e = t.match(new RegExp(/^\w+:/, "gi"));
  if (!(!e || !e.length))
    return e[0];
}
function ME(t, e) {
  const r = bH(t);
  return typeof r > "u" ? !1 : new RegExp(e).test(r);
}
function A3(t) {
  return ME(t, mH);
}
function P3(t) {
  return ME(t, vH);
}
function yH(t) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(t);
}
function IE(t) {
  return typeof t == "object" && "id" in t && "jsonrpc" in t && t.jsonrpc === "2.0";
}
function Ab(t) {
  return IE(t) && "method" in t;
}
function bp(t) {
  return IE(t) && (zs(t) || es(t));
}
function zs(t) {
  return "result" in t;
}
function es(t) {
  return "error" in t;
}
let us = class extends gH {
  constructor(e) {
    super(e), this.events = new is.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners();
  }
  async connect(e = this.connection) {
    await this.open(e);
  }
  async disconnect() {
    await this.close();
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async request(e, r) {
    return this.requestStrict(ga(e.method, e.params || [], e.id || fc().toString()), r);
  }
  async requestStrict(e, r) {
    return new Promise(async (n, i) => {
      if (!this.connection.connected) try {
        await this.open();
      } catch (s) {
        i(s);
      }
      this.events.on(`${e.id}`, (s) => {
        es(s) ? i(s.error) : n(s.result);
      });
      try {
        await this.connection.send(e, r);
      } catch (s) {
        i(s);
      }
    });
  }
  setConnection(e = this.connection) {
    return e;
  }
  onPayload(e) {
    this.events.emit("payload", e), bp(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", { type: e.method, data: e.params });
  }
  onClose(e) {
    e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(e = this.connection) {
    this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (e) => this.onPayload(e)), this.connection.on("close", (e) => this.onClose(e)), this.connection.on("error", (e) => this.events.emit("error", e)), this.connection.on("register_error", (e) => this.onClose()), this.hasRegisteredEventListeners = !0);
  }
};
const wH = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"), xH = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", M3 = (t) => t.split("?")[0], I3 = 10, _H = wH();
let EH = class {
  constructor(e) {
    if (this.url = e, this.events = new is.EventEmitter(), this.registering = !1, !P3(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, r) => {
      if (typeof this.socket > "u") {
        r(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n) => {
        this.onClose(n), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(jo(e));
    } catch (r) {
      this.onError(e.id, r);
    }
  }
  register(e = this.url) {
    if (!P3(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const r = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= r || this.events.listenerCount("open") >= r) && this.events.setMaxListeners(r + 1), new Promise((n, i) => {
        this.events.once("register_error", (s) => {
          this.resetMaxListeners(), i(s);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return i(new Error("WebSocket connection is missing or invalid"));
          n(this.socket);
        });
      });
    }
    return this.url = e, this.registering = !0, new Promise((r, n) => {
      const i = new URLSearchParams(e).get("origin"), s = PE.isReactNative() ? { headers: { origin: i } } : { rejectUnauthorized: !yH(e) }, o = new _H(e, [], s);
      xH() ? o.onerror = (a) => {
        const u = a;
        n(this.emitError(u.error));
      } : o.on("error", (a) => {
        n(this.emitError(a));
      }), o.onopen = () => {
        this.onOpen(o), r(o);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (r) => this.onPayload(r), e.onclose = (r) => this.onClose(r), this.socket = e, this.registering = !1, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const r = typeof e.data == "string" ? bc(e.data) : e.data;
    this.events.emit("payload", r);
  }
  onError(e, r) {
    const n = this.parseError(r), i = n.message || n.toString(), s = vp(e, i);
    this.events.emit("payload", s);
  }
  parseError(e, r = this.url) {
    return AE(e, M3(r), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > I3 && this.events.setMaxListeners(I3);
  }
  emitError(e) {
    const r = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${M3(this.url)}`));
    return this.events.emit("register_error", r), r;
  }
};
var E0 = { exports: {} };
E0.exports;
(function(t, e) {
  var r = 200, n = "__lodash_hash_undefined__", i = 1, s = 2, o = 9007199254740991, a = "[object Arguments]", u = "[object Array]", l = "[object AsyncFunction]", d = "[object Boolean]", p = "[object Date]", w = "[object Error]", _ = "[object Function]", P = "[object GeneratorFunction]", O = "[object Map]", L = "[object Number]", B = "[object Null]", k = "[object Object]", q = "[object Promise]", U = "[object Proxy]", V = "[object RegExp]", Q = "[object Set]", R = "[object String]", K = "[object Symbol]", ge = "[object Undefined]", Ee = "[object WeakMap]", Y = "[object ArrayBuffer]", A = "[object DataView]", m = "[object Float32Array]", f = "[object Float64Array]", g = "[object Int8Array]", b = "[object Int16Array]", x = "[object Int32Array]", E = "[object Uint8Array]", S = "[object Uint8ClampedArray]", v = "[object Uint16Array]", M = "[object Uint32Array]", I = /[\\^$.*+?()[\]{}|]/g, F = /^\[object .+?Constructor\]$/, ce = /^(?:0|[1-9]\d*)$/, D = {};
  D[m] = D[f] = D[g] = D[b] = D[x] = D[E] = D[S] = D[v] = D[M] = !0, D[a] = D[u] = D[Y] = D[d] = D[A] = D[p] = D[w] = D[_] = D[O] = D[L] = D[k] = D[V] = D[Q] = D[R] = D[Ee] = !1;
  var oe = typeof gn == "object" && gn && gn.Object === Object && gn, Z = typeof self == "object" && self && self.Object === Object && self, J = oe || Z || Function("return this")(), ee = e && !e.nodeType && e, T = ee && !0 && t && !t.nodeType && t, X = T && T.exports === ee, re = X && oe.process, pe = function() {
    try {
      return re && re.binding && re.binding("util");
    } catch {
    }
  }(), ie = pe && pe.isTypedArray;
  function ue(ae, ye) {
    for (var Ge = -1, Pt = ae == null ? 0 : ae.length, jr = 0, nr = []; ++Ge < Pt; ) {
      var Kr = ae[Ge];
      ye(Kr, Ge, ae) && (nr[jr++] = Kr);
    }
    return nr;
  }
  function ve(ae, ye) {
    for (var Ge = -1, Pt = ye.length, jr = ae.length; ++Ge < Pt; )
      ae[jr + Ge] = ye[Ge];
    return ae;
  }
  function Pe(ae, ye) {
    for (var Ge = -1, Pt = ae == null ? 0 : ae.length; ++Ge < Pt; )
      if (ye(ae[Ge], Ge, ae))
        return !0;
    return !1;
  }
  function De(ae, ye) {
    for (var Ge = -1, Pt = Array(ae); ++Ge < ae; )
      Pt[Ge] = ye(Ge);
    return Pt;
  }
  function Ce(ae) {
    return function(ye) {
      return ae(ye);
    };
  }
  function $e(ae, ye) {
    return ae.has(ye);
  }
  function Me(ae, ye) {
    return ae == null ? void 0 : ae[ye];
  }
  function Ne(ae) {
    var ye = -1, Ge = Array(ae.size);
    return ae.forEach(function(Pt, jr) {
      Ge[++ye] = [jr, Pt];
    }), Ge;
  }
  function Ke(ae, ye) {
    return function(Ge) {
      return ae(ye(Ge));
    };
  }
  function Le(ae) {
    var ye = -1, Ge = Array(ae.size);
    return ae.forEach(function(Pt) {
      Ge[++ye] = Pt;
    }), Ge;
  }
  var qe = Array.prototype, ze = Function.prototype, _e = Object.prototype, Ze = J["__core-js_shared__"], at = ze.toString, ke = _e.hasOwnProperty, Qe = function() {
    var ae = /[^.]+$/.exec(Ze && Ze.keys && Ze.keys.IE_PROTO || "");
    return ae ? "Symbol(src)_1." + ae : "";
  }(), tt = _e.toString, Ye = RegExp(
    "^" + at.call(ke).replace(I, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), dt = X ? J.Buffer : void 0, lt = J.Symbol, ct = J.Uint8Array, qt = _e.propertyIsEnumerable, Jt = qe.splice, Et = lt ? lt.toStringTag : void 0, er = Object.getOwnPropertySymbols, Xt = dt ? dt.isBuffer : void 0, Dt = Ke(Object.keys, Object), kt = wr(J, "DataView"), Ct = wr(J, "Map"), mt = wr(J, "Promise"), Rt = wr(J, "Set"), Nt = wr(J, "WeakMap"), bt = wr(Object, "create"), $t = ao(kt), Ft = ao(Ct), rt = ao(mt), Bt = ao(Rt), $ = ao(Nt), z = lt ? lt.prototype : void 0, H = z ? z.valueOf : void 0;
  function C(ae) {
    var ye = -1, Ge = ae == null ? 0 : ae.length;
    for (this.clear(); ++ye < Ge; ) {
      var Pt = ae[ye];
      this.set(Pt[0], Pt[1]);
    }
  }
  function G() {
    this.__data__ = bt ? bt(null) : {}, this.size = 0;
  }
  function j(ae) {
    var ye = this.has(ae) && delete this.__data__[ae];
    return this.size -= ye ? 1 : 0, ye;
  }
  function se(ae) {
    var ye = this.__data__;
    if (bt) {
      var Ge = ye[ae];
      return Ge === n ? void 0 : Ge;
    }
    return ke.call(ye, ae) ? ye[ae] : void 0;
  }
  function de(ae) {
    var ye = this.__data__;
    return bt ? ye[ae] !== void 0 : ke.call(ye, ae);
  }
  function xe(ae, ye) {
    var Ge = this.__data__;
    return this.size += this.has(ae) ? 0 : 1, Ge[ae] = bt && ye === void 0 ? n : ye, this;
  }
  C.prototype.clear = G, C.prototype.delete = j, C.prototype.get = se, C.prototype.has = de, C.prototype.set = xe;
  function Te(ae) {
    var ye = -1, Ge = ae == null ? 0 : ae.length;
    for (this.clear(); ++ye < Ge; ) {
      var Pt = ae[ye];
      this.set(Pt[0], Pt[1]);
    }
  }
  function Re() {
    this.__data__ = [], this.size = 0;
  }
  function nt(ae) {
    var ye = this.__data__, Ge = Je(ye, ae);
    if (Ge < 0)
      return !1;
    var Pt = ye.length - 1;
    return Ge == Pt ? ye.pop() : Jt.call(ye, Ge, 1), --this.size, !0;
  }
  function je(ae) {
    var ye = this.__data__, Ge = Je(ye, ae);
    return Ge < 0 ? void 0 : ye[Ge][1];
  }
  function pt(ae) {
    return Je(this.__data__, ae) > -1;
  }
  function it(ae, ye) {
    var Ge = this.__data__, Pt = Je(Ge, ae);
    return Pt < 0 ? (++this.size, Ge.push([ae, ye])) : Ge[Pt][1] = ye, this;
  }
  Te.prototype.clear = Re, Te.prototype.delete = nt, Te.prototype.get = je, Te.prototype.has = pt, Te.prototype.set = it;
  function et(ae) {
    var ye = -1, Ge = ae == null ? 0 : ae.length;
    for (this.clear(); ++ye < Ge; ) {
      var Pt = ae[ye];
      this.set(Pt[0], Pt[1]);
    }
  }
  function St() {
    this.size = 0, this.__data__ = {
      hash: new C(),
      map: new (Ct || Te)(),
      string: new C()
    };
  }
  function Tt(ae) {
    var ye = mr(this, ae).delete(ae);
    return this.size -= ye ? 1 : 0, ye;
  }
  function At(ae) {
    return mr(this, ae).get(ae);
  }
  function _t(ae) {
    return mr(this, ae).has(ae);
  }
  function ht(ae, ye) {
    var Ge = mr(this, ae), Pt = Ge.size;
    return Ge.set(ae, ye), this.size += Ge.size == Pt ? 0 : 1, this;
  }
  et.prototype.clear = St, et.prototype.delete = Tt, et.prototype.get = At, et.prototype.has = _t, et.prototype.set = ht;
  function xt(ae) {
    var ye = -1, Ge = ae == null ? 0 : ae.length;
    for (this.__data__ = new et(); ++ye < Ge; )
      this.add(ae[ye]);
  }
  function st(ae) {
    return this.__data__.set(ae, n), this;
  }
  function yt(ae) {
    return this.__data__.has(ae);
  }
  xt.prototype.add = xt.prototype.push = st, xt.prototype.has = yt;
  function ut(ae) {
    var ye = this.__data__ = new Te(ae);
    this.size = ye.size;
  }
  function ot() {
    this.__data__ = new Te(), this.size = 0;
  }
  function Se(ae) {
    var ye = this.__data__, Ge = ye.delete(ae);
    return this.size = ye.size, Ge;
  }
  function Ae(ae) {
    return this.__data__.get(ae);
  }
  function Ve(ae) {
    return this.__data__.has(ae);
  }
  function Fe(ae, ye) {
    var Ge = this.__data__;
    if (Ge instanceof Te) {
      var Pt = Ge.__data__;
      if (!Ct || Pt.length < r - 1)
        return Pt.push([ae, ye]), this.size = ++Ge.size, this;
      Ge = this.__data__ = new et(Pt);
    }
    return Ge.set(ae, ye), this.size = Ge.size, this;
  }
  ut.prototype.clear = ot, ut.prototype.delete = Se, ut.prototype.get = Ae, ut.prototype.has = Ve, ut.prototype.set = Fe;
  function Ue(ae, ye) {
    var Ge = $c(ae), Pt = !Ge && _h(ae), jr = !Ge && !Pt && sf(ae), nr = !Ge && !Pt && !jr && Ah(ae), Kr = Ge || Pt || jr || nr, vn = Kr ? De(ae.length, String) : [], Er = vn.length;
    for (var Ur in ae)
      ke.call(ae, Ur) && !(Kr && // Safari 9 has enumerable `arguments.length` in strict mode.
      (Ur == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      jr && (Ur == "offset" || Ur == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      nr && (Ur == "buffer" || Ur == "byteLength" || Ur == "byteOffset") || // Skip index properties.
      nn(Ur, Er))) && vn.push(Ur);
    return vn;
  }
  function Je(ae, ye) {
    for (var Ge = ae.length; Ge--; )
      if (xh(ae[Ge][0], ye))
        return Ge;
    return -1;
  }
  function Lt(ae, ye, Ge) {
    var Pt = ye(ae);
    return $c(ae) ? Pt : ve(Pt, Ge(ae));
  }
  function zt(ae) {
    return ae == null ? ae === void 0 ? ge : B : Et && Et in Object(ae) ? $r(ae) : Hp(ae);
  }
  function Zt(ae) {
    return Ba(ae) && zt(ae) == a;
  }
  function Wt(ae, ye, Ge, Pt, jr) {
    return ae === ye ? !0 : ae == null || ye == null || !Ba(ae) && !Ba(ye) ? ae !== ae && ye !== ye : he(ae, ye, Ge, Pt, Wt, jr);
  }
  function he(ae, ye, Ge, Pt, jr, nr) {
    var Kr = $c(ae), vn = $c(ye), Er = Kr ? u : Ir(ae), Ur = vn ? u : Ir(ye);
    Er = Er == a ? k : Er, Ur = Ur == a ? k : Ur;
    var an = Er == k, fi = Ur == k, bn = Er == Ur;
    if (bn && sf(ae)) {
      if (!sf(ye))
        return !1;
      Kr = !0, an = !1;
    }
    if (bn && !an)
      return nr || (nr = new ut()), Kr || Ah(ae) ? Qt(ae, ye, Ge, Pt, jr, nr) : gr(ae, ye, Er, Ge, Pt, jr, nr);
    if (!(Ge & i)) {
      var Vr = an && ke.call(ae, "__wrapped__"), ri = fi && ke.call(ye, "__wrapped__");
      if (Vr || ri) {
        var hs = Vr ? ae.value() : ae, Ui = ri ? ye.value() : ye;
        return nr || (nr = new ut()), jr(hs, Ui, Ge, Pt, nr);
      }
    }
    return bn ? (nr || (nr = new ut()), lr(ae, ye, Ge, Pt, jr, nr)) : !1;
  }
  function rr(ae) {
    if (!Sh(ae) || on(ae))
      return !1;
    var ye = Bc(ae) ? Ye : F;
    return ye.test(ao(ae));
  }
  function dr(ae) {
    return Ba(ae) && Eh(ae.length) && !!D[zt(ae)];
  }
  function pr(ae) {
    if (!wh(ae))
      return Dt(ae);
    var ye = [];
    for (var Ge in Object(ae))
      ke.call(ae, Ge) && Ge != "constructor" && ye.push(Ge);
    return ye;
  }
  function Qt(ae, ye, Ge, Pt, jr, nr) {
    var Kr = Ge & i, vn = ae.length, Er = ye.length;
    if (vn != Er && !(Kr && Er > vn))
      return !1;
    var Ur = nr.get(ae);
    if (Ur && nr.get(ye))
      return Ur == ye;
    var an = -1, fi = !0, bn = Ge & s ? new xt() : void 0;
    for (nr.set(ae, ye), nr.set(ye, ae); ++an < vn; ) {
      var Vr = ae[an], ri = ye[an];
      if (Pt)
        var hs = Kr ? Pt(ri, Vr, an, ye, ae, nr) : Pt(Vr, ri, an, ae, ye, nr);
      if (hs !== void 0) {
        if (hs)
          continue;
        fi = !1;
        break;
      }
      if (bn) {
        if (!Pe(ye, function(Ui, Ds) {
          if (!$e(bn, Ds) && (Vr === Ui || jr(Vr, Ui, Ge, Pt, nr)))
            return bn.push(Ds);
        })) {
          fi = !1;
          break;
        }
      } else if (!(Vr === ri || jr(Vr, ri, Ge, Pt, nr))) {
        fi = !1;
        break;
      }
    }
    return nr.delete(ae), nr.delete(ye), fi;
  }
  function gr(ae, ye, Ge, Pt, jr, nr, Kr) {
    switch (Ge) {
      case A:
        if (ae.byteLength != ye.byteLength || ae.byteOffset != ye.byteOffset)
          return !1;
        ae = ae.buffer, ye = ye.buffer;
      case Y:
        return !(ae.byteLength != ye.byteLength || !nr(new ct(ae), new ct(ye)));
      case d:
      case p:
      case L:
        return xh(+ae, +ye);
      case w:
        return ae.name == ye.name && ae.message == ye.message;
      case V:
      case R:
        return ae == ye + "";
      case O:
        var vn = Ne;
      case Q:
        var Er = Pt & i;
        if (vn || (vn = Le), ae.size != ye.size && !Er)
          return !1;
        var Ur = Kr.get(ae);
        if (Ur)
          return Ur == ye;
        Pt |= s, Kr.set(ae, ye);
        var an = Qt(vn(ae), vn(ye), Pt, jr, nr, Kr);
        return Kr.delete(ae), an;
      case K:
        if (H)
          return H.call(ae) == H.call(ye);
    }
    return !1;
  }
  function lr(ae, ye, Ge, Pt, jr, nr) {
    var Kr = Ge & i, vn = Rr(ae), Er = vn.length, Ur = Rr(ye), an = Ur.length;
    if (Er != an && !Kr)
      return !1;
    for (var fi = Er; fi--; ) {
      var bn = vn[fi];
      if (!(Kr ? bn in ye : ke.call(ye, bn)))
        return !1;
    }
    var Vr = nr.get(ae);
    if (Vr && nr.get(ye))
      return Vr == ye;
    var ri = !0;
    nr.set(ae, ye), nr.set(ye, ae);
    for (var hs = Kr; ++fi < Er; ) {
      bn = vn[fi];
      var Ui = ae[bn], Ds = ye[bn];
      if (Pt)
        var of = Kr ? Pt(Ds, Ui, bn, ye, ae, nr) : Pt(Ui, Ds, bn, ae, ye, nr);
      if (!(of === void 0 ? Ui === Ds || jr(Ui, Ds, Ge, Pt, nr) : of)) {
        ri = !1;
        break;
      }
      hs || (hs = bn == "constructor");
    }
    if (ri && !hs) {
      var Fa = ae.constructor, Pn = ye.constructor;
      Fa != Pn && "constructor" in ae && "constructor" in ye && !(typeof Fa == "function" && Fa instanceof Fa && typeof Pn == "function" && Pn instanceof Pn) && (ri = !1);
    }
    return nr.delete(ae), nr.delete(ye), ri;
  }
  function Rr(ae) {
    return Lt(ae, Gp, Br);
  }
  function mr(ae, ye) {
    var Ge = ae.__data__;
    return sn(ye) ? Ge[typeof ye == "string" ? "string" : "hash"] : Ge.map;
  }
  function wr(ae, ye) {
    var Ge = Me(ae, ye);
    return rr(Ge) ? Ge : void 0;
  }
  function $r(ae) {
    var ye = ke.call(ae, Et), Ge = ae[Et];
    try {
      ae[Et] = void 0;
      var Pt = !0;
    } catch {
    }
    var jr = tt.call(ae);
    return Pt && (ye ? ae[Et] = Ge : delete ae[Et]), jr;
  }
  var Br = er ? function(ae) {
    return ae == null ? [] : (ae = Object(ae), ue(er(ae), function(ye) {
      return qt.call(ae, ye);
    }));
  } : Fr, Ir = zt;
  (kt && Ir(new kt(new ArrayBuffer(1))) != A || Ct && Ir(new Ct()) != O || mt && Ir(mt.resolve()) != q || Rt && Ir(new Rt()) != Q || Nt && Ir(new Nt()) != Ee) && (Ir = function(ae) {
    var ye = zt(ae), Ge = ye == k ? ae.constructor : void 0, Pt = Ge ? ao(Ge) : "";
    if (Pt)
      switch (Pt) {
        case $t:
          return A;
        case Ft:
          return O;
        case rt:
          return q;
        case Bt:
          return Q;
        case $:
          return Ee;
      }
    return ye;
  });
  function nn(ae, ye) {
    return ye = ye ?? o, !!ye && (typeof ae == "number" || ce.test(ae)) && ae > -1 && ae % 1 == 0 && ae < ye;
  }
  function sn(ae) {
    var ye = typeof ae;
    return ye == "string" || ye == "number" || ye == "symbol" || ye == "boolean" ? ae !== "__proto__" : ae === null;
  }
  function on(ae) {
    return !!Qe && Qe in ae;
  }
  function wh(ae) {
    var ye = ae && ae.constructor, Ge = typeof ye == "function" && ye.prototype || _e;
    return ae === Ge;
  }
  function Hp(ae) {
    return tt.call(ae);
  }
  function ao(ae) {
    if (ae != null) {
      try {
        return at.call(ae);
      } catch {
      }
      try {
        return ae + "";
      } catch {
      }
    }
    return "";
  }
  function xh(ae, ye) {
    return ae === ye || ae !== ae && ye !== ye;
  }
  var _h = Zt(/* @__PURE__ */ function() {
    return arguments;
  }()) ? Zt : function(ae) {
    return Ba(ae) && ke.call(ae, "callee") && !qt.call(ae, "callee");
  }, $c = Array.isArray;
  function Kp(ae) {
    return ae != null && Eh(ae.length) && !Bc(ae);
  }
  var sf = Xt || Dr;
  function Vp(ae, ye) {
    return Wt(ae, ye);
  }
  function Bc(ae) {
    if (!Sh(ae))
      return !1;
    var ye = zt(ae);
    return ye == _ || ye == P || ye == l || ye == U;
  }
  function Eh(ae) {
    return typeof ae == "number" && ae > -1 && ae % 1 == 0 && ae <= o;
  }
  function Sh(ae) {
    var ye = typeof ae;
    return ae != null && (ye == "object" || ye == "function");
  }
  function Ba(ae) {
    return ae != null && typeof ae == "object";
  }
  var Ah = ie ? Ce(ie) : dr;
  function Gp(ae) {
    return Kp(ae) ? Ue(ae) : pr(ae);
  }
  function Fr() {
    return [];
  }
  function Dr() {
    return !1;
  }
  t.exports = Vp;
})(E0, E0.exports);
var SH = E0.exports;
const AH = /* @__PURE__ */ ns(SH), CE = "wc", TE = 2, RE = "core", ro = `${CE}@2:${RE}:`, PH = { logger: "error" }, MH = { database: ":memory:" }, IH = "crypto", C3 = "client_ed25519_seed", CH = vt.ONE_DAY, TH = "keychain", RH = "0.3", DH = "messages", OH = "0.3", NH = vt.SIX_HOURS, LH = "publisher", DE = "irn", kH = "error", OE = "wss://relay.walletconnect.org", $H = "relayer", ai = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", publish: "relayer_publish" }, BH = "_subscription", Yi = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, FH = 0.1, K1 = "2.17.2", zr = { link_mode: "link_mode", relay: "relay" }, jH = "0.3", UH = "WALLETCONNECT_CLIENT_ID", T3 = "WALLETCONNECT_LINK_MODE_APPS", Ws = { created: "subscription_created", deleted: "subscription_deleted", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, qH = "subscription", zH = "0.3", WH = vt.FIVE_SECONDS * 1e3, HH = "pairing", KH = "0.3", Nf = { wc_pairingDelete: { req: { ttl: vt.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: vt.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: vt.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: vt.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: vt.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: vt.ONE_DAY, prompt: !1, tag: 0 } } }, ic = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" }, ys = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, VH = "history", GH = "0.3", YH = "expirer", Zi = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, JH = "0.3", XH = "verify-api", ZH = "https://verify.walletconnect.com", NE = "https://verify.walletconnect.org", Xf = NE, QH = `${Xf}/v3`, eK = [ZH, NE], tK = "echo", rK = "https://echo.walletconnect.com", qs = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal" }, So = { no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_listener_not_found: "proposal_listener_not_found" }, ws = { session_approve_started: "session_approve_started", session_namespaces_validation_success: "session_namespaces_validation_success", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" }, Xa = { no_internet_connection: "no_internet_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" }, Za = { authenticated_session_approve_started: "authenticated_session_approve_started", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve" }, Lf = { no_internet_connection: "no_internet_connection", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" }, nK = 0.1, iK = "event-client", sK = 86400, oK = "https://pulse.walletconnect.org/batch";
function aK(t, e) {
  if (t.length >= 255) throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++) r[n] = 255;
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i), o = s.charCodeAt(0);
    if (r[o] !== 255) throw new TypeError(s + " is ambiguous");
    r[o] = i;
  }
  var a = t.length, u = t.charAt(0), l = Math.log(a) / Math.log(256), d = Math.log(256) / Math.log(a);
  function p(P) {
    if (P instanceof Uint8Array || (ArrayBuffer.isView(P) ? P = new Uint8Array(P.buffer, P.byteOffset, P.byteLength) : Array.isArray(P) && (P = Uint8Array.from(P))), !(P instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (P.length === 0) return "";
    for (var O = 0, L = 0, B = 0, k = P.length; B !== k && P[B] === 0; ) B++, O++;
    for (var q = (k - B) * d + 1 >>> 0, U = new Uint8Array(q); B !== k; ) {
      for (var V = P[B], Q = 0, R = q - 1; (V !== 0 || Q < L) && R !== -1; R--, Q++) V += 256 * U[R] >>> 0, U[R] = V % a >>> 0, V = V / a >>> 0;
      if (V !== 0) throw new Error("Non-zero carry");
      L = Q, B++;
    }
    for (var K = q - L; K !== q && U[K] === 0; ) K++;
    for (var ge = u.repeat(O); K < q; ++K) ge += t.charAt(U[K]);
    return ge;
  }
  function w(P) {
    if (typeof P != "string") throw new TypeError("Expected String");
    if (P.length === 0) return new Uint8Array();
    var O = 0;
    if (P[O] !== " ") {
      for (var L = 0, B = 0; P[O] === u; ) L++, O++;
      for (var k = (P.length - O) * l + 1 >>> 0, q = new Uint8Array(k); P[O]; ) {
        var U = r[P.charCodeAt(O)];
        if (U === 255) return;
        for (var V = 0, Q = k - 1; (U !== 0 || V < B) && Q !== -1; Q--, V++) U += a * q[Q] >>> 0, q[Q] = U % 256 >>> 0, U = U / 256 >>> 0;
        if (U !== 0) throw new Error("Non-zero carry");
        B = V, O++;
      }
      if (P[O] !== " ") {
        for (var R = k - B; R !== k && q[R] === 0; ) R++;
        for (var K = new Uint8Array(L + (k - R)), ge = L; R !== k; ) K[ge++] = q[R++];
        return K;
      }
    }
  }
  function _(P) {
    var O = w(P);
    if (O) return O;
    throw new Error(`Non-${e} character`);
  }
  return { encode: p, decodeUnsafe: w, decode: _ };
}
var cK = aK, uK = cK;
const LE = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array") return t;
  if (t instanceof ArrayBuffer) return new Uint8Array(t);
  if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, fK = (t) => new TextEncoder().encode(t), lK = (t) => new TextDecoder().decode(t);
class hK {
  constructor(e, r, n) {
    this.name = e, this.prefix = r, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class dK {
  constructor(e, r, n) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return kE(this, e);
  }
}
class pK {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return kE(this, e);
  }
  decode(e) {
    const r = e[0], n = this.decoders[r];
    if (n) return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const kE = (t, e) => new pK({ ...t.decoders || { [t.prefix]: t }, ...e.decoders || { [e.prefix]: e } });
class gK {
  constructor(e, r, n, i) {
    this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = i, this.encoder = new hK(e, r, n), this.decoder = new dK(e, r, i);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const yp = ({ name: t, prefix: e, encode: r, decode: n }) => new gK(t, e, r, n), lh = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: n, decode: i } = uK(r, e);
  return yp({ prefix: t, name: e, encode: n, decode: (s) => LE(i(s)) });
}, mK = (t, e, r, n) => {
  const i = {};
  for (let d = 0; d < e.length; ++d) i[e[d]] = d;
  let s = t.length;
  for (; t[s - 1] === "="; ) --s;
  const o = new Uint8Array(s * r / 8 | 0);
  let a = 0, u = 0, l = 0;
  for (let d = 0; d < s; ++d) {
    const p = i[t[d]];
    if (p === void 0) throw new SyntaxError(`Non-${n} character`);
    u = u << r | p, a += r, a >= 8 && (a -= 8, o[l++] = 255 & u >> a);
  }
  if (a >= r || 255 & u << 8 - a) throw new SyntaxError("Unexpected end of data");
  return o;
}, vK = (t, e, r) => {
  const n = e[e.length - 1] === "=", i = (1 << r) - 1;
  let s = "", o = 0, a = 0;
  for (let u = 0; u < t.length; ++u) for (a = a << 8 | t[u], o += 8; o > r; ) o -= r, s += e[i & a >> o];
  if (o && (s += e[i & a << r - o]), n) for (; s.length * r & 7; ) s += "=";
  return s;
}, Hn = ({ name: t, prefix: e, bitsPerChar: r, alphabet: n }) => yp({ prefix: e, name: t, encode(i) {
  return vK(i, n, r);
}, decode(i) {
  return mK(i, n, r, t);
} }), bK = yp({ prefix: "\0", name: "identity", encode: (t) => lK(t), decode: (t) => fK(t) });
var yK = Object.freeze({ __proto__: null, identity: bK });
const wK = Hn({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var xK = Object.freeze({ __proto__: null, base2: wK });
const _K = Hn({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var EK = Object.freeze({ __proto__: null, base8: _K });
const SK = lh({ prefix: "9", name: "base10", alphabet: "0123456789" });
var AK = Object.freeze({ __proto__: null, base10: SK });
const PK = Hn({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), MK = Hn({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var IK = Object.freeze({ __proto__: null, base16: PK, base16upper: MK });
const CK = Hn({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), TK = Hn({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), RK = Hn({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), DK = Hn({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), OK = Hn({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), NK = Hn({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), LK = Hn({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), kK = Hn({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), $K = Hn({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var BK = Object.freeze({ __proto__: null, base32: CK, base32upper: TK, base32pad: RK, base32padupper: DK, base32hex: OK, base32hexupper: NK, base32hexpad: LK, base32hexpadupper: kK, base32z: $K });
const FK = lh({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), jK = lh({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var UK = Object.freeze({ __proto__: null, base36: FK, base36upper: jK });
const qK = lh({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), zK = lh({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var WK = Object.freeze({ __proto__: null, base58btc: qK, base58flickr: zK });
const HK = Hn({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), KK = Hn({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), VK = Hn({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), GK = Hn({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var YK = Object.freeze({ __proto__: null, base64: HK, base64pad: KK, base64url: VK, base64urlpad: GK });
const $E = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), JK = $E.reduce((t, e, r) => (t[r] = e, t), []), XK = $E.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function ZK(t) {
  return t.reduce((e, r) => (e += JK[r], e), "");
}
function QK(t) {
  const e = [];
  for (const r of t) {
    const n = XK[r.codePointAt(0)];
    if (n === void 0) throw new Error(`Non-base256emoji character: ${r}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const eV = yp({ prefix: "🚀", name: "base256emoji", encode: ZK, decode: QK });
var tV = Object.freeze({ __proto__: null, base256emoji: eV }), rV = BE, R3 = 128, nV = 127, iV = ~nV, sV = Math.pow(2, 31);
function BE(t, e, r) {
  e = e || [], r = r || 0;
  for (var n = r; t >= sV; ) e[r++] = t & 255 | R3, t /= 128;
  for (; t & iV; ) e[r++] = t & 255 | R3, t >>>= 7;
  return e[r] = t | 0, BE.bytes = r - n + 1, e;
}
var oV = V1, aV = 128, D3 = 127;
function V1(t, n) {
  var r = 0, n = n || 0, i = 0, s = n, o, a = t.length;
  do {
    if (s >= a) throw V1.bytes = 0, new RangeError("Could not decode varint");
    o = t[s++], r += i < 28 ? (o & D3) << i : (o & D3) * Math.pow(2, i), i += 7;
  } while (o >= aV);
  return V1.bytes = s - n, r;
}
var cV = Math.pow(2, 7), uV = Math.pow(2, 14), fV = Math.pow(2, 21), lV = Math.pow(2, 28), hV = Math.pow(2, 35), dV = Math.pow(2, 42), pV = Math.pow(2, 49), gV = Math.pow(2, 56), mV = Math.pow(2, 63), vV = function(t) {
  return t < cV ? 1 : t < uV ? 2 : t < fV ? 3 : t < lV ? 4 : t < hV ? 5 : t < dV ? 6 : t < pV ? 7 : t < gV ? 8 : t < mV ? 9 : 10;
}, bV = { encode: rV, decode: oV, encodingLength: vV }, FE = bV;
const O3 = (t, e, r = 0) => (FE.encode(t, e, r), e), N3 = (t) => FE.encodingLength(t), G1 = (t, e) => {
  const r = e.byteLength, n = N3(t), i = n + N3(r), s = new Uint8Array(i + r);
  return O3(t, s, 0), O3(r, s, n), s.set(e, i), new yV(t, r, e, s);
};
class yV {
  constructor(e, r, n, i) {
    this.code = e, this.size = r, this.digest = n, this.bytes = i;
  }
}
const jE = ({ name: t, code: e, encode: r }) => new wV(t, e, r);
class wV {
  constructor(e, r, n) {
    this.name = e, this.code = r, this.encode = n;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const r = this.encode(e);
      return r instanceof Uint8Array ? G1(this.code, r) : r.then((n) => G1(this.code, n));
    } else throw Error("Unknown type, must be binary type");
  }
}
const UE = (t) => async (e) => new Uint8Array(await crypto.subtle.digest(t, e)), xV = jE({ name: "sha2-256", code: 18, encode: UE("SHA-256") }), _V = jE({ name: "sha2-512", code: 19, encode: UE("SHA-512") });
var EV = Object.freeze({ __proto__: null, sha256: xV, sha512: _V });
const qE = 0, SV = "identity", zE = LE, AV = (t) => G1(qE, zE(t)), PV = { code: qE, name: SV, encode: zE, digest: AV };
var MV = Object.freeze({ __proto__: null, identity: PV });
new TextEncoder(), new TextDecoder();
const L3 = { ...yK, ...xK, ...EK, ...AK, ...IK, ...BK, ...UK, ...WK, ...YK, ...tV };
({ ...EV, ...MV });
function IV(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(t) : new Uint8Array(t);
}
function WE(t, e, r, n) {
  return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: r }, decoder: { decode: n } };
}
const k3 = WE("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), Im = WE("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = IV(t.length);
  for (let r = 0; r < t.length; r++) e[r] = t.charCodeAt(r);
  return e;
}), CV = { utf8: k3, "utf-8": k3, hex: L3.base16, latin1: Im, ascii: Im, binary: Im, ...L3 };
function TV(t, e = "utf8") {
  const r = CV[e];
  if (!r) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t, "utf8") : r.decoder.decode(`${r.prefix}${t}`);
}
let RV = class {
  constructor(e, r) {
    this.core = e, this.logger = r, this.keychain = /* @__PURE__ */ new Map(), this.name = TH, this.version = RH, this.initialized = !1, this.storagePrefix = ro, this.init = async () => {
      if (!this.initialized) {
        const n = await this.getKeyChain();
        typeof n < "u" && (this.keychain = n), this.initialized = !0;
      }
    }, this.has = (n) => (this.isInitialized(), this.keychain.has(n)), this.set = async (n, i) => {
      this.isInitialized(), this.keychain.set(n, i), await this.persist();
    }, this.get = (n) => {
      this.isInitialized();
      const i = this.keychain.get(n);
      if (typeof i > "u") {
        const { message: s } = ft("NO_MATCHING_KEY", `${this.name}: ${n}`);
        throw new Error(s);
      }
      return i;
    }, this.del = async (n) => {
      this.isInitialized(), this.keychain.delete(n), await this.persist();
    }, this.core = e, this.logger = ui(r, this.name);
  }
  get context() {
    return Pi(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, uE(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? fE(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}, DV = class {
  constructor(e, r, n) {
    this.core = e, this.logger = r, this.name = IH, this.randomSessionIdentifier = W1(), this.initialized = !1, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0);
    }, this.hasKeys = (i) => (this.isInitialized(), this.keychain.has(i)), this.getClientId = async () => {
      this.isInitialized();
      const i = await this.getClientSeed(), s = xx(i);
      return g8(s.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const i = tW();
      return this.setPrivateKey(i.publicKey, i.privateKey);
    }, this.signJWT = async (i) => {
      this.isInitialized();
      const s = await this.getClientSeed(), o = xx(s), a = this.randomSessionIdentifier;
      return await SF(a, i, CH, o);
    }, this.generateSharedKey = (i, s, o) => {
      this.isInitialized();
      const a = this.getPrivateKey(i), u = rW(a, s);
      return this.setSymKey(u, o);
    }, this.setSymKey = async (i, s) => {
      this.isInitialized();
      const o = s || qd(i);
      return await this.keychain.set(o, i), o;
    }, this.deleteKeyPair = async (i) => {
      this.isInitialized(), await this.keychain.del(i);
    }, this.deleteSymKey = async (i) => {
      this.isInitialized(), await this.keychain.del(i);
    }, this.encode = async (i, s, o) => {
      this.isInitialized();
      const a = wE(o), u = jo(s);
      if (f3(a)) return iW(u, o == null ? void 0 : o.encoding);
      if (u3(a)) {
        const w = a.senderPublicKey, _ = a.receiverPublicKey;
        i = await this.generateSharedKey(w, _);
      }
      const l = this.getSymKey(i), { type: d, senderPublicKey: p } = a;
      return nW({ type: d, symKey: l, message: u, senderPublicKey: p, encoding: o == null ? void 0 : o.encoding });
    }, this.decode = async (i, s, o) => {
      this.isInitialized();
      const a = aW(s, o);
      if (f3(a)) {
        const u = oW(s, o == null ? void 0 : o.encoding);
        return bc(u);
      }
      if (u3(a)) {
        const u = a.receiverPublicKey, l = a.senderPublicKey;
        i = await this.generateSharedKey(u, l);
      }
      try {
        const u = this.getSymKey(i), l = sW({ symKey: u, encoded: s, encoding: o == null ? void 0 : o.encoding });
        return bc(l);
      } catch (u) {
        this.logger.error(`Failed to decode message from topic: '${i}', clientId: '${await this.getClientId()}'`), this.logger.error(u);
      }
    }, this.getPayloadType = (i, s = pa) => {
      const o = Nl({ encoded: i, encoding: s });
      return xc(o.type);
    }, this.getPayloadSenderPublicKey = (i, s = pa) => {
      const o = Nl({ encoded: i, encoding: s });
      return o.senderPublicKey ? On(o.senderPublicKey, ci) : void 0;
    }, this.core = e, this.logger = ui(r, this.name), this.keychain = n || new RV(this.core, this.logger);
  }
  get context() {
    return Pi(this.logger);
  }
  async setPrivateKey(e, r) {
    return await this.keychain.set(e, r), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(C3);
    } catch {
      e = W1(), await this.keychain.set(C3, e);
    }
    return TV(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
class OV extends T$ {
  constructor(e, r) {
    super(e, r), this.logger = e, this.core = r, this.messages = /* @__PURE__ */ new Map(), this.name = DH, this.version = OH, this.initialized = !1, this.storagePrefix = ro, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const n = await this.getRelayerMessages();
          typeof n < "u" && (this.messages = n), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (n) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(n);
        } finally {
          this.initialized = !0;
        }
      }
    }, this.set = async (n, i) => {
      this.isInitialized();
      const s = Ao(i);
      let o = this.messages.get(n);
      return typeof o > "u" && (o = {}), typeof o[s] < "u" || (o[s] = i, this.messages.set(n, o), await this.persist()), s;
    }, this.get = (n) => {
      this.isInitialized();
      let i = this.messages.get(n);
      return typeof i > "u" && (i = {}), i;
    }, this.has = (n, i) => {
      this.isInitialized();
      const s = this.get(n), o = Ao(i);
      return typeof s[o] < "u";
    }, this.del = async (n) => {
      this.isInitialized(), this.messages.delete(n), await this.persist();
    }, this.logger = ui(e, this.name), this.core = r;
  }
  get context() {
    return Pi(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, uE(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? fE(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class NV extends R$ {
  constructor(e, r) {
    super(e, r), this.relayer = e, this.logger = r, this.events = new is.EventEmitter(), this.name = LH, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = vt.toMiliseconds(vt.ONE_MINUTE), this.failedPublishTimeout = vt.toMiliseconds(vt.ONE_SECOND), this.needsTransportRestart = !1, this.publish = async (n, i, s) => {
      var o;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: n, message: i, opts: s } });
      const a = (s == null ? void 0 : s.ttl) || NH, u = H1(s), l = (s == null ? void 0 : s.prompt) || !1, d = (s == null ? void 0 : s.tag) || 0, p = (s == null ? void 0 : s.id) || fc().toString(), w = { topic: n, message: i, opts: { ttl: a, relay: u, prompt: l, tag: d, id: p, attestation: s == null ? void 0 : s.attestation } }, _ = `Failed to publish payload, please try again. id:${p} tag:${d}`, P = Date.now();
      let O, L = 1;
      try {
        for (; O === void 0; ) {
          if (Date.now() - P > this.publishTimeout) throw new Error(_);
          this.logger.trace({ id: p, attempts: L }, `publisher.publish - attempt ${L}`), O = await await Eu(this.rpcPublish(n, i, a, u, l, d, p, s == null ? void 0 : s.attestation).catch((B) => this.logger.warn(B)), this.publishTimeout, _), L++, O || await new Promise((B) => setTimeout(B, this.failedPublishTimeout));
        }
        this.relayer.events.emit(ai.publish, w), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { id: p, topic: n, message: i, opts: s } });
      } catch (B) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(B), (o = s == null ? void 0 : s.internal) != null && o.throwOnFailedPublish) throw B;
        this.queue.set(p, w);
      }
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.relayer = e, this.logger = ui(r, this.name), this.registerEventListeners();
  }
  get context() {
    return Pi(this.logger);
  }
  rpcPublish(e, r, n, i, s, o, a, u) {
    var l, d, p, w;
    const _ = { method: Hf(i.protocol).publish, params: { topic: e, message: r, ttl: n, prompt: s, tag: o, attestation: u }, id: a };
    return vi((l = _.params) == null ? void 0 : l.prompt) && ((d = _.params) == null || delete d.prompt), vi((p = _.params) == null ? void 0 : p.tag) && ((w = _.params) == null || delete w.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: _ }), this.relayer.request(_);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: r, message: n, opts: i } = e;
      await this.publish(r, n, i);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(ju.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = !1, this.relayer.events.emit(ai.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(ai.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
}
class LV {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, r) => {
      const n = this.get(e);
      this.exists(e, r) || this.map.set(e, [...n, r]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, r) => this.get(e).includes(r), this.delete = (e, r) => {
      if (typeof r > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const n = this.get(e);
      if (!this.exists(e, r)) return;
      const i = n.filter((s) => s !== r);
      if (!i.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, i);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var kV = Object.defineProperty, $V = Object.defineProperties, BV = Object.getOwnPropertyDescriptors, $3 = Object.getOwnPropertySymbols, FV = Object.prototype.hasOwnProperty, jV = Object.prototype.propertyIsEnumerable, B3 = (t, e, r) => e in t ? kV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, kf = (t, e) => {
  for (var r in e || (e = {})) FV.call(e, r) && B3(t, r, e[r]);
  if ($3) for (var r of $3(e)) jV.call(e, r) && B3(t, r, e[r]);
  return t;
}, Cm = (t, e) => $V(t, BV(e));
class UV extends N$ {
  constructor(e, r) {
    super(e, r), this.relayer = e, this.logger = r, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new LV(), this.events = new is.EventEmitter(), this.name = qH, this.version = zH, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = ro, this.subscribeTimeout = vt.toMiliseconds(vt.ONE_MINUTE), this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.pendingBatchMessages = [], this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = !0;
    }, this.subscribe = async (n, i) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: i } });
      try {
        const s = H1(i), o = { topic: n, relay: s, transportType: i == null ? void 0 : i.transportType };
        this.pending.set(n, o);
        const a = await this.rpcSubscribe(n, s, i);
        return typeof a == "string" && (this.onSubscribe(a, o), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: i } })), a;
      } catch (s) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(s), s;
      }
    }, this.unsubscribe = async (n, i) => {
      await this.restartToComplete(), this.isInitialized(), typeof (i == null ? void 0 : i.id) < "u" ? await this.unsubscribeById(n, i.id, i) : await this.unsubscribeByTopic(n, i);
    }, this.isSubscribed = async (n) => {
      if (this.topics.includes(n)) return !0;
      const i = `${this.pendingSubscriptionWatchLabel}_${n}`;
      return await new Promise((s, o) => {
        const a = new vt.Watch();
        a.start(i);
        const u = setInterval(() => {
          !this.pending.has(n) && this.topics.includes(n) && (clearInterval(u), a.stop(i), s(!0)), a.elapsed(i) >= WH && (clearInterval(u), a.stop(i), o(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => !1);
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.start = async () => {
      await this.onConnect();
    }, this.stop = async () => {
      await this.onDisconnect();
    }, this.restart = async () => {
      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;
    }, this.relayer = e, this.logger = ui(r, this.name), this.clientId = "";
  }
  get context() {
    return Pi(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, r) {
    let n = !1;
    try {
      n = this.getSubscription(e).topic === r;
    } catch {
    }
    return n;
  }
  onEnable() {
    this.cached = [], this.initialized = !0;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, r) {
    const n = this.topicMap.get(e);
    await Promise.all(n.map(async (i) => await this.unsubscribeById(e, i, r)));
  }
  async unsubscribeById(e, r, n) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: r, opts: n } });
    try {
      const i = H1(n);
      await this.rpcUnsubscribe(e, r, i);
      const s = Or("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, r, s), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: r, opts: n } });
    } catch (i) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i), i;
    }
  }
  async rpcSubscribe(e, r, n) {
    var i;
    (n == null ? void 0 : n.transportType) === zr.relay && await this.restartToComplete();
    const s = { method: Hf(r.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s });
    const o = (i = n == null ? void 0 : n.internal) == null ? void 0 : i.throwOnFailedPublish;
    try {
      const a = Ao(e + this.clientId);
      if ((n == null ? void 0 : n.transportType) === zr.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(s).catch((l) => this.logger.warn(l));
      }, vt.toMiliseconds(vt.ONE_SECOND)), a;
      const u = await Eu(this.relayer.request(s).catch((l) => this.logger.warn(l)), this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!u && o) throw new Error(`Subscribing to ${e} failed, please try again`);
      return u ? a : null;
    } catch (a) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(ai.connection_stalled), o) throw a;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const r = e[0].relay, n = { method: Hf(r.protocol).batchSubscribe, params: { topics: e.map((i) => i.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    try {
      return await await Eu(this.relayer.request(n).catch((i) => this.logger.warn(i)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(ai.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const r = e[0].relay, n = { method: Hf(r.protocol).batchFetchMessages, params: { topics: e.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    let i;
    try {
      i = await await Eu(this.relayer.request(n).catch((s) => this.logger.warn(s)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(ai.connection_stalled);
    }
    return i;
  }
  rpcUnsubscribe(e, r, n) {
    const i = { method: Hf(n.protocol).unsubscribe, params: { topic: e, id: r } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i }), this.relayer.request(i);
  }
  onSubscribe(e, r) {
    this.setSubscription(e, Cm(kf({}, r), { id: e })), this.pending.delete(r.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((r) => {
      this.setSubscription(r.id, kf({}, r)), this.pending.delete(r.topic);
    });
  }
  async onUnsubscribe(e, r, n) {
    this.events.removeAllListeners(r), this.hasSubscription(r, e) && this.deleteSubscription(r, n), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, r) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: r }), this.addSubscription(e, r);
  }
  addSubscription(e, r) {
    this.subscriptions.set(e, kf({}, r)), this.topicMap.set(r.topic, e), this.events.emit(Ws.created, r);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const r = this.subscriptions.get(e);
    if (!r) {
      const { message: n } = ft("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return r;
  }
  deleteSubscription(e, r) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: r });
    const n = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(n.topic, e), this.events.emit(Ws.deleted, Cm(kf({}, n), { reason: r }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(Ws.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let r = 0; r < e; r++) {
        const n = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchFetchMessages(n), await this.batchSubscribe(n);
      }
    }
    this.events.emit(Ws.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: r } = ft("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length) return;
    const r = await this.rpcBatchSubscribe(e);
    _c(r) && this.onBatchSubscribe(r.map((n, i) => Cm(kf({}, e[i]), { id: n })));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const r = await this.rpcBatchFetchMessages(e);
    r && r.messages && (this.pendingBatchMessages = this.pendingBatchMessages.concat(r.messages));
  }
  async onConnect() {
    await this.restart(), this.onEnable();
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || !this.relayer.connected) return;
    const e = [];
    this.pending.forEach((r) => {
      e.push(r);
    }), await this.batchSubscribe(e), this.pendingBatchMessages.length && (await this.relayer.handleBatchMessageEvents(this.pendingBatchMessages), this.pendingBatchMessages = []);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(ju.pulse, async () => {
      await this.checkPending();
    }), this.events.on(Ws.created, async (e) => {
      const r = Ws.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), await this.persist();
    }), this.events.on(Ws.deleted, async (e) => {
      const r = Ws.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen(), this.restartInProgress && await new Promise((e) => {
      const r = setInterval(() => {
        this.restartInProgress || (clearInterval(r), e());
      }, this.pollingInterval);
    });
  }
}
var qV = Object.defineProperty, F3 = Object.getOwnPropertySymbols, zV = Object.prototype.hasOwnProperty, WV = Object.prototype.propertyIsEnumerable, j3 = (t, e, r) => e in t ? qV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, U3 = (t, e) => {
  for (var r in e || (e = {})) zV.call(e, r) && j3(t, r, e[r]);
  if (F3) for (var r of F3(e)) WV.call(e, r) && j3(t, r, e[r]);
  return t;
};
class HV extends D$ {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new is.EventEmitter(), this.name = $H, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "stalled", "interrupted"], this.hasExperiencedNetworkDisruption = !1, this.requestsInFlight = /* @__PURE__ */ new Map(), this.heartBeatTimeout = vt.toMiliseconds(vt.THIRTY_SECONDS + vt.ONE_SECOND), this.request = async (r) => {
      var n, i;
      this.logger.debug("Publishing Request Payload");
      const s = r.id || fc().toString();
      await this.toEstablishConnection();
      try {
        const o = this.provider.request(r);
        this.requestsInFlight.set(s, { promise: o, request: r }), this.logger.trace({ id: s, method: r.method, topic: (n = r.params) == null ? void 0 : n.topic }, "relayer.request - attempt to publish...");
        const a = await new Promise(async (u, l) => {
          const d = () => {
            l(new Error(`relayer.request - publish interrupted, id: ${s}`));
          };
          this.provider.on(Yi.disconnect, d);
          const p = await o;
          this.provider.off(Yi.disconnect, d), u(p);
        });
        return this.logger.trace({ id: s, method: r.method, topic: (i = r.params) == null ? void 0 : i.topic }, "relayer.request - published"), a;
      } catch (o) {
        throw this.logger.debug(`Failed to Publish Request: ${s}`), o;
      } finally {
        this.requestsInFlight.delete(s);
      }
    }, this.resetPingTimeout = () => {
      if (w0()) try {
        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
          var r, n, i;
          (i = (n = (r = this.provider) == null ? void 0 : r.connection) == null ? void 0 : n.socket) == null || i.terminate();
        }, this.heartBeatTimeout);
      } catch (r) {
        this.logger.warn(r);
      }
    }, this.onPayloadHandler = (r) => {
      this.onProviderPayload(r), this.resetPingTimeout();
    }, this.onConnectHandler = () => {
      this.logger.trace("relayer connected"), this.startPingTimeout(), this.events.emit(ai.connect);
    }, this.onDisconnectHandler = () => {
      this.logger.trace("relayer disconnected"), this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (r) => {
      this.logger.error(r), this.events.emit(ai.error, r), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(Yi.payload, this.onPayloadHandler), this.provider.on(Yi.connect, this.onConnectHandler), this.provider.on(Yi.disconnect, this.onDisconnectHandler), this.provider.on(Yi.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? ui(e.logger, this.name) : Xl(X0({ level: e.logger || kH })), this.messages = new OV(this.logger, e.core), this.subscriber = new UV(this, this.logger), this.publisher = new NV(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || OE, this.projectId = e.projectId, this.bundleId = yz(), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = !0, this.subscriber.cached.length > 0) try {
      await this.transportOpen();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  get context() {
    return Pi(this.logger);
  }
  get connected() {
    var e, r, n;
    return ((n = (r = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : r.socket) == null ? void 0 : n.readyState) === 1;
  }
  get connecting() {
    var e, r, n;
    return ((n = (r = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : r.socket) == null ? void 0 : n.readyState) === 0;
  }
  async publish(e, r, n) {
    this.isInitialized(), await this.publisher.publish(e, r, n), await this.recordMessageEvent({ topic: e, message: r, publishedAt: Date.now(), transportType: zr.relay });
  }
  async subscribe(e, r) {
    var n, i, s;
    this.isInitialized(), (r == null ? void 0 : r.transportType) === "relay" && await this.toEstablishConnection();
    const o = typeof ((n = r == null ? void 0 : r.internal) == null ? void 0 : n.throwOnFailedPublish) > "u" ? !0 : (i = r == null ? void 0 : r.internal) == null ? void 0 : i.throwOnFailedPublish;
    let a = ((s = this.subscriber.topicMap.get(e)) == null ? void 0 : s[0]) || "", u;
    const l = (d) => {
      d.topic === e && (this.subscriber.off(Ws.created, l), u());
    };
    return await Promise.all([new Promise((d) => {
      u = d, this.subscriber.on(Ws.created, l);
    }), new Promise(async (d, p) => {
      a = await this.subscriber.subscribe(e, U3({ internal: { throwOnFailedPublish: o } }, r)).catch((w) => {
        o && p(w);
      }) || a, d();
    })]), a;
  }
  async unsubscribe(e, r) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, r);
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async transportDisconnect() {
    if (!this.hasExperiencedNetworkDisruption && this.connected && this.requestsInFlight.size > 0) try {
      await Promise.all(Array.from(this.requestsInFlight.values()).map((e) => e.promise));
    } catch (e) {
      this.logger.warn(e);
    }
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await Eu(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = !0, await this.transportDisconnect();
  }
  async transportOpen(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), await this.createProvider(), this.connectionAttemptInProgress = !0, this.transportExplicitlyClosed = !1;
    try {
      await new Promise(async (r, n) => {
        const i = () => {
          this.provider.off(Yi.disconnect, i), n(new Error("Connection interrupted while trying to subscribe"));
        };
        this.provider.on(Yi.disconnect, i), await Eu(this.provider.connect(), vt.toMiliseconds(vt.ONE_MINUTE), `Socket stalled when trying to connect to ${this.relayUrl}`).catch((s) => {
          n(s);
        }).finally(() => {
          clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;
        }), this.subscriber.start().catch((s) => {
          this.logger.error(s), this.onDisconnectHandler();
        }), this.hasExperiencedNetworkDisruption = !1, r();
      });
    } catch (r) {
      this.logger.error(r);
      const n = r;
      if (this.hasExperiencedNetworkDisruption = !0, !this.isConnectionStalled(n.message)) throw r;
    } finally {
      this.connectionAttemptInProgress = !1;
    }
  }
  async restartTransport(e) {
    this.connectionAttemptInProgress || (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await x3()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const r = e.sort((n, i) => n.publishedAt - i.publishedAt);
    this.logger.trace(`Batch of ${r.length} message events sorted`);
    for (const n of r) try {
      await this.onMessageEvent(n);
    } catch (i) {
      this.logger.warn(i);
    }
    this.logger.trace(`Batch of ${r.length} message events processed`);
  }
  async onLinkMessageEvent(e, r) {
    const { topic: n } = e;
    if (!r.sessionExists) {
      const i = Sn(vt.FIVE_MINUTES), s = { topic: n, expiry: i, relay: { protocol: "irn" }, active: !1 };
      await this.core.pairing.pairings.set(n, s);
    }
    this.events.emit(ai.message, e), await this.recordMessageEvent(e);
  }
  startPingTimeout() {
    var e, r, n, i, s;
    if (w0()) try {
      (r = (e = this.provider) == null ? void 0 : e.connection) != null && r.socket && ((s = (i = (n = this.provider) == null ? void 0 : n.connection) == null ? void 0 : i.socket) == null || s.once("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o) {
      this.logger.warn(o);
    }
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((r) => e.includes(r));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new us(new EH(Ez({ sdkVersion: K1, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: !0, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: r, message: n } = e;
    await this.messages.set(r, n);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: r, message: n } = e;
    if (!n || n.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${n}`), !0;
    if (!await this.subscriber.isSubscribed(r)) return this.logger.debug(`Ignoring message for non-subscribed topic ${r}`), !0;
    const i = this.messages.has(r, n);
    return i && this.logger.debug(`Ignoring duplicate message: ${n}`), i;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), Ab(e)) {
      if (!e.method.endsWith(BH)) return;
      const r = e.params, { topic: n, message: i, publishedAt: s, attestation: o } = r.data, a = { topic: n, message: i, publishedAt: s, transportType: zr.relay, attestation: o };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(U3({ type: "event", event: r.id }, a)), this.events.emit(r.id, a), await this.acknowledgePayload(e), await this.onMessageEvent(a);
    } else bp(e) && this.events.emit(ai.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(ai.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const r = mp(e.id, !0);
    await this.provider.connection.send(r);
  }
  unregisterProviderListeners() {
    this.provider.off(Yi.payload, this.onPayloadHandler), this.provider.off(Yi.connect, this.onConnectHandler), this.provider.off(Yi.disconnect, this.onDisconnectHandler), this.provider.off(Yi.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await x3();
    eH(async (r) => {
      e !== r && (e = r, r ? await this.restartTransport().catch((n) => this.logger.error(n)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportDisconnect(), this.transportExplicitlyClosed = !1));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), this.requestsInFlight.clear(), clearTimeout(this.pingTimeout), this.events.emit(ai.disconnect), this.connectionAttemptInProgress = !1, !this.transportExplicitlyClosed && (this.reconnectTimeout || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e));
    }, vt.toMiliseconds(FH))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (this.connectionAttemptInProgress && await new Promise((e) => {
      const r = setInterval(() => {
        this.connected && (clearInterval(r), e());
      }, this.connectionStatusPollingInterval);
    }), await this.transportOpen());
  }
}
var KV = Object.defineProperty, q3 = Object.getOwnPropertySymbols, VV = Object.prototype.hasOwnProperty, GV = Object.prototype.propertyIsEnumerable, z3 = (t, e, r) => e in t ? KV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, W3 = (t, e) => {
  for (var r in e || (e = {})) VV.call(e, r) && z3(t, r, e[r]);
  if (q3) for (var r of q3(e)) GV.call(e, r) && z3(t, r, e[r]);
  return t;
};
class Oc extends O$ {
  constructor(e, r, n, i = ro, s = void 0) {
    super(e, r, n, i), this.core = e, this.logger = r, this.name = n, this.map = /* @__PURE__ */ new Map(), this.version = jH, this.cached = [], this.initialized = !1, this.storagePrefix = ro, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o) => {
        this.getKey && o !== null && !vi(o) ? this.map.set(this.getKey(o), o) : RW(o) ? this.map.set(o.id, o) : DW(o) && this.map.set(o.topic, o);
      }), this.cached = [], this.initialized = !0);
    }, this.set = async (o, a) => {
      this.isInitialized(), this.map.has(o) ? await this.update(o, a) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o, value: a }), this.map.set(o, a), await this.persist());
    }, this.get = (o) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o }), this.getData(o)), this.getAll = (o) => (this.isInitialized(), o ? this.values.filter((a) => Object.keys(o).every((u) => AH(a[u], o[u]))) : this.values), this.update = async (o, a) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o, update: a });
      const u = W3(W3({}, this.getData(o)), a);
      this.map.set(o, u), await this.persist();
    }, this.delete = async (o, a) => {
      this.isInitialized(), this.map.has(o) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o, reason: a }), this.map.delete(o), this.addToRecentlyDeleted(o), await this.persist());
    }, this.logger = ui(r, this.name), this.storagePrefix = i, this.getKey = s;
  }
  get context() {
    return Pi(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const r = this.map.get(e);
    if (!r) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: i } = ft("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(i), new Error(i);
      }
      const { message: n } = ft("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(n), new Error(n);
    }
    return r;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: r } = ft("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class YV {
  constructor(e, r) {
    this.core = e, this.logger = r, this.name = HH, this.version = KH, this.events = new Xv(), this.initialized = !1, this.storagePrefix = ro, this.ignoredPayloadTypes = [Oo], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
    }, this.register = ({ methods: n }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...n])];
    }, this.create = async (n) => {
      this.isInitialized();
      const i = W1(), s = await this.core.crypto.setSymKey(i), o = Sn(vt.FIVE_MINUTES), a = { protocol: DE }, u = { topic: s, expiry: o, relay: a, active: !1, methods: n == null ? void 0 : n.methods }, l = g3({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: i, relay: a, expiryTimestamp: o, methods: n == null ? void 0 : n.methods });
      return this.events.emit(ic.create, u), this.core.expirer.set(s, o), await this.pairings.set(s, u), await this.core.relayer.subscribe(s, { transportType: n == null ? void 0 : n.transportType }), { topic: s, uri: l };
    }, this.pair = async (n) => {
      this.isInitialized();
      const i = this.core.eventClient.createEvent({ properties: { topic: n == null ? void 0 : n.uri, trace: [qs.pairing_started] } });
      this.isValidPair(n, i);
      const { topic: s, symKey: o, relay: a, expiryTimestamp: u, methods: l } = p3(n.uri);
      i.props.properties.topic = s, i.addTrace(qs.pairing_uri_validation_success), i.addTrace(qs.pairing_uri_not_expired);
      let d;
      if (this.pairings.keys.includes(s)) {
        if (d = this.pairings.get(s), i.addTrace(qs.existing_pairing), d.active) throw i.setError(So.active_pairing_already_exists), new Error(`Pairing already exists: ${s}. Please try again with a new connection URI.`);
        i.addTrace(qs.pairing_not_expired);
      }
      const p = u || Sn(vt.FIVE_MINUTES), w = { topic: s, relay: a, expiry: p, active: !1, methods: l };
      this.core.expirer.set(s, p), await this.pairings.set(s, w), i.addTrace(qs.store_new_pairing), n.activatePairing && await this.activate({ topic: s }), this.events.emit(ic.create, w), i.addTrace(qs.emit_inactive_pairing), this.core.crypto.keychain.has(s) || await this.core.crypto.setSymKey(o, s), i.addTrace(qs.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        i.setError(So.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(s, { relay: a });
      } catch (_) {
        throw i.setError(So.subscribe_pairing_topic_failure), _;
      }
      return i.addTrace(qs.subscribe_pairing_topic_success), w;
    }, this.activate = async ({ topic: n }) => {
      this.isInitialized();
      const i = Sn(vt.THIRTY_DAYS);
      this.core.expirer.set(n, i), await this.pairings.update(n, { active: !0, expiry: i });
    }, this.ping = async (n) => {
      this.isInitialized(), await this.isValidPing(n);
      const { topic: i } = n;
      if (this.pairings.keys.includes(i)) {
        const s = await this.sendRequest(i, "wc_pairingPing", {}), { done: o, resolve: a, reject: u } = ec();
        this.events.once(yr("pairing_ping", s), ({ error: l }) => {
          l ? u(l) : a();
        }), await o();
      }
    }, this.updateExpiry = async ({ topic: n, expiry: i }) => {
      this.isInitialized(), await this.pairings.update(n, { expiry: i });
    }, this.updateMetadata = async ({ topic: n, metadata: i }) => {
      this.isInitialized(), await this.pairings.update(n, { peerMetadata: i });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (n) => {
      this.isInitialized(), await this.isValidDisconnect(n);
      const { topic: i } = n;
      this.pairings.keys.includes(i) && (await this.sendRequest(i, "wc_pairingDelete", Or("USER_DISCONNECTED")), await this.deletePairing(i));
    }, this.formatUriFromPairing = (n) => {
      this.isInitialized();
      const { topic: i, relay: s, expiry: o, methods: a } = n, u = this.core.crypto.keychain.get(i);
      return g3({ protocol: this.core.protocol, version: this.core.version, topic: i, symKey: u, relay: s, expiryTimestamp: o, methods: a });
    }, this.sendRequest = async (n, i, s) => {
      const o = ga(i, s), a = await this.core.crypto.encode(n, o), u = Nf[i].req;
      return this.core.history.set(n, o), this.core.relayer.publish(n, a, u), o.id;
    }, this.sendResult = async (n, i, s) => {
      const o = mp(n, s), a = await this.core.crypto.encode(i, o), u = await this.core.history.get(i, n), l = Nf[u.request.method].res;
      await this.core.relayer.publish(i, a, l), await this.core.history.resolve(o);
    }, this.sendError = async (n, i, s) => {
      const o = vp(n, s), a = await this.core.crypto.encode(i, o), u = await this.core.history.get(i, n), l = Nf[u.request.method] ? Nf[u.request.method].res : Nf.unregistered_method.res;
      await this.core.relayer.publish(i, a, l), await this.core.history.resolve(o);
    }, this.deletePairing = async (n, i) => {
      await this.core.relayer.unsubscribe(n), await Promise.all([this.pairings.delete(n, Or("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(n), i ? Promise.resolve() : this.core.expirer.del(n)]);
    }, this.cleanup = async () => {
      const n = this.pairings.getAll().filter((i) => fa(i.expiry));
      await Promise.all(n.map((i) => this.deletePairing(i.topic)));
    }, this.onRelayEventRequest = (n) => {
      const { topic: i, payload: s } = n;
      switch (s.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i, s);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i, s);
        default:
          return this.onUnknownRpcMethodRequest(i, s);
      }
    }, this.onRelayEventResponse = async (n) => {
      const { topic: i, payload: s } = n, o = (await this.core.history.get(i, s.id)).request.method;
      switch (o) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i, s);
        default:
          return this.onUnknownRpcMethodResponse(o);
      }
    }, this.onPairingPingRequest = async (n, i) => {
      const { id: s } = i;
      try {
        this.isValidPing({ topic: n }), await this.sendResult(s, n, !0), this.events.emit(ic.ping, { id: s, topic: n });
      } catch (o) {
        await this.sendError(s, n, o), this.logger.error(o);
      }
    }, this.onPairingPingResponse = (n, i) => {
      const { id: s } = i;
      setTimeout(() => {
        zs(i) ? this.events.emit(yr("pairing_ping", s), {}) : es(i) && this.events.emit(yr("pairing_ping", s), { error: i.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (n, i) => {
      const { id: s } = i;
      try {
        this.isValidDisconnect({ topic: n }), await this.deletePairing(n), this.events.emit(ic.delete, { id: s, topic: n });
      } catch (o) {
        await this.sendError(s, n, o), this.logger.error(o);
      }
    }, this.onUnknownRpcMethodRequest = async (n, i) => {
      const { id: s, method: o } = i;
      try {
        if (this.registeredMethods.includes(o)) return;
        const a = Or("WC_METHOD_UNSUPPORTED", o);
        await this.sendError(s, n, a), this.logger.error(a);
      } catch (a) {
        await this.sendError(s, n, a), this.logger.error(a);
      }
    }, this.onUnknownRpcMethodResponse = (n) => {
      this.registeredMethods.includes(n) || this.logger.error(Or("WC_METHOD_UNSUPPORTED", n));
    }, this.isValidPair = (n, i) => {
      var s;
      if (!mi(n)) {
        const { message: a } = ft("MISSING_OR_INVALID", `pair() params: ${n}`);
        throw i.setError(So.malformed_pairing_uri), new Error(a);
      }
      if (!TW(n.uri)) {
        const { message: a } = ft("MISSING_OR_INVALID", `pair() uri: ${n.uri}`);
        throw i.setError(So.malformed_pairing_uri), new Error(a);
      }
      const o = p3(n == null ? void 0 : n.uri);
      if (!((s = o == null ? void 0 : o.relay) != null && s.protocol)) {
        const { message: a } = ft("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw i.setError(So.malformed_pairing_uri), new Error(a);
      }
      if (!(o != null && o.symKey)) {
        const { message: a } = ft("MISSING_OR_INVALID", "pair() uri#symKey");
        throw i.setError(So.malformed_pairing_uri), new Error(a);
      }
      if (o != null && o.expiryTimestamp && vt.toMiliseconds(o == null ? void 0 : o.expiryTimestamp) < Date.now()) {
        i.setError(So.pairing_expired);
        const { message: a } = ft("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a);
      }
    }, this.isValidPing = async (n) => {
      if (!mi(n)) {
        const { message: s } = ft("MISSING_OR_INVALID", `ping() params: ${n}`);
        throw new Error(s);
      }
      const { topic: i } = n;
      await this.isValidPairingTopic(i);
    }, this.isValidDisconnect = async (n) => {
      if (!mi(n)) {
        const { message: s } = ft("MISSING_OR_INVALID", `disconnect() params: ${n}`);
        throw new Error(s);
      }
      const { topic: i } = n;
      await this.isValidPairingTopic(i);
    }, this.isValidPairingTopic = async (n) => {
      if (!dn(n, !1)) {
        const { message: i } = ft("MISSING_OR_INVALID", `pairing topic should be a string: ${n}`);
        throw new Error(i);
      }
      if (!this.pairings.keys.includes(n)) {
        const { message: i } = ft("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n}`);
        throw new Error(i);
      }
      if (fa(this.pairings.get(n).expiry)) {
        await this.deletePairing(n);
        const { message: i } = ft("EXPIRED", `pairing topic: ${n}`);
        throw new Error(i);
      }
    }, this.core = e, this.logger = ui(r, this.name), this.pairings = new Oc(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return Pi(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(ai.message, async (e) => {
      const { topic: r, message: n, transportType: i } = e;
      if (!this.pairings.keys.includes(r) || i === zr.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(n))) return;
      const s = await this.core.crypto.decode(r, n);
      try {
        Ab(s) ? (this.core.history.set(r, s), this.onRelayEventRequest({ topic: r, payload: s })) : bp(s) && (await this.core.history.resolve(s), await this.onRelayEventResponse({ topic: r, payload: s }), this.core.history.delete(r, s.id));
      } catch (o) {
        this.logger.error(o);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(Zi.expired, async (e) => {
      const { topic: r } = hE(e.target);
      r && this.pairings.keys.includes(r) && (await this.deletePairing(r, !0), this.events.emit(ic.expire, { topic: r }));
    });
  }
}
class JV extends C$ {
  constructor(e, r) {
    super(e, r), this.core = e, this.logger = r, this.records = /* @__PURE__ */ new Map(), this.events = new is.EventEmitter(), this.name = VH, this.version = GH, this.cached = [], this.initialized = !1, this.storagePrefix = ro, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.records.set(n.id, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.set = (n, i, s) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: n, request: i, chainId: s }), this.records.has(i.id)) return;
      const o = { id: i.id, topic: n, request: { method: i.method, params: i.params || null }, chainId: s, expiry: Sn(vt.THIRTY_DAYS) };
      this.records.set(o.id, o), this.persist(), this.events.emit(ys.created, o);
    }, this.resolve = async (n) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: n }), !this.records.has(n.id)) return;
      const i = await this.getRecord(n.id);
      typeof i.response > "u" && (i.response = es(n) ? { error: n.error } : { result: n.result }, this.records.set(i.id, i), this.persist(), this.events.emit(ys.updated, i));
    }, this.get = async (n, i) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: n, id: i }), await this.getRecord(i)), this.delete = (n, i) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i }), this.values.forEach((s) => {
        if (s.topic === n) {
          if (typeof i < "u" && s.id !== i) return;
          this.records.delete(s.id), this.events.emit(ys.deleted, s);
        }
      }), this.persist();
    }, this.exists = async (n, i) => (this.isInitialized(), this.records.has(i) ? (await this.getRecord(i)).topic === n : !1), this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.logger = ui(r, this.name);
  }
  get context() {
    return Pi(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((r) => {
      if (typeof r.response < "u") return;
      const n = { topic: r.topic, request: ga(r.request.method, r.request.params, r.id), chainId: r.chainId };
      return e.push(n);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const r = this.records.get(e);
    if (!r) {
      const { message: n } = ft("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return r;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(ys.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: r } = ft("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(ys.created, (e) => {
      const r = ys.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e });
    }), this.events.on(ys.updated, (e) => {
      const r = ys.updated;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e });
    }), this.events.on(ys.deleted, (e) => {
      const r = ys.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e });
    }), this.core.heartbeat.on(ju.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = !1;
      this.records.forEach((r) => {
        vt.toMiliseconds(r.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${r.id}`), this.records.delete(r.id), this.events.emit(ys.deleted, r, !1), e = !0);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class XV extends L$ {
  constructor(e, r) {
    super(e, r), this.core = e, this.logger = r, this.expirations = /* @__PURE__ */ new Map(), this.events = new is.EventEmitter(), this.name = YH, this.version = JH, this.cached = [], this.initialized = !1, this.storagePrefix = ro, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.expirations.set(n.target, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.has = (n) => {
      try {
        const i = this.formatTarget(n);
        return typeof this.getExpiration(i) < "u";
      } catch {
        return !1;
      }
    }, this.set = (n, i) => {
      this.isInitialized();
      const s = this.formatTarget(n), o = { target: s, expiry: i };
      this.expirations.set(s, o), this.checkExpiry(s, o), this.events.emit(Zi.created, { target: s, expiration: o });
    }, this.get = (n) => {
      this.isInitialized();
      const i = this.formatTarget(n);
      return this.getExpiration(i);
    }, this.del = (n) => {
      if (this.isInitialized(), this.has(n)) {
        const i = this.formatTarget(n), s = this.getExpiration(i);
        this.expirations.delete(i), this.events.emit(Zi.deleted, { target: i, expiration: s });
      }
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.logger = ui(r, this.name);
  }
  get context() {
    return Pi(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return Sz(e);
    if (typeof e == "number") return Az(e);
    const { message: r } = ft("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(r);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(Zi.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: r } = ft("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const r = this.expirations.get(e);
    if (!r) {
      const { message: n } = ft("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(n), new Error(n);
    }
    return r;
  }
  checkExpiry(e, r) {
    const { expiry: n } = r;
    vt.toMiliseconds(n) - Date.now() <= 0 && this.expire(e, r);
  }
  expire(e, r) {
    this.expirations.delete(e), this.events.emit(Zi.expired, { target: e, expiration: r });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, r) => this.checkExpiry(r, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(ju.pulse, () => this.checkExpirations()), this.events.on(Zi.created, (e) => {
      const r = Zi.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    }), this.events.on(Zi.expired, (e) => {
      const r = Zi.expired;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    }), this.events.on(Zi.deleted, (e) => {
      const r = Zi.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class ZV extends k$ {
  constructor(e, r, n) {
    super(e, r, n), this.core = e, this.logger = r, this.store = n, this.name = XH, this.verifyUrlV3 = QH, this.storagePrefix = ro, this.version = TE, this.init = async () => {
      var i;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && vt.toMiliseconds((i = this.publicKey) == null ? void 0 : i.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }, this.register = async (i) => {
      if (!ah() || this.isDevEnv) return;
      const s = window.location.origin, { id: o, decryptedId: a } = i, u = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${s}&id=${o}&decryptedId=${a}`;
      try {
        const l = th(), d = this.startAbortTimer(vt.ONE_SECOND * 5), p = await new Promise((w, _) => {
          const P = () => {
            window.removeEventListener("message", L), l.body.removeChild(O), _("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", P);
          const O = l.createElement("iframe");
          O.src = u, O.style.display = "none", O.addEventListener("error", P, { signal: this.abortController.signal });
          const L = (B) => {
            if (B.data && typeof B.data == "string") try {
              const k = JSON.parse(B.data);
              if (k.type === "verify_attestation") {
                if (O1(k.attestation).payload.id !== o) return;
                clearInterval(d), l.body.removeChild(O), this.abortController.signal.removeEventListener("abort", P), window.removeEventListener("message", L), w(k.attestation === null ? "" : k.attestation);
              }
            } catch (k) {
              this.logger.warn(k);
            }
          };
          l.body.appendChild(O), window.addEventListener("message", L, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", p), p;
      } catch (l) {
        this.logger.warn(l);
      }
      return "";
    }, this.resolve = async (i) => {
      if (this.isDevEnv) return "";
      const { attestationId: s, hash: o, encryptedId: a } = i;
      if (s === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (s) {
        if (O1(s).payload.id !== a) return;
        const l = await this.isValidJwtAttestation(s);
        if (l) {
          if (!l.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return l;
        }
      }
      if (!o) return;
      const u = this.getVerifyUrl(i == null ? void 0 : i.verifyUrl);
      return this.fetchAttestation(o, u);
    }, this.fetchAttestation = async (i, s) => {
      this.logger.debug(`resolving attestation: ${i} from url: ${s}`);
      const o = this.startAbortTimer(vt.ONE_SECOND * 5), a = await fetch(`${s}/attestation/${i}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o), a.status === 200 ? await a.json() : void 0;
    }, this.getVerifyUrl = (i) => {
      let s = i || Xf;
      return eK.includes(s) || (this.logger.info(`verify url: ${s}, not included in trusted list, assigning default: ${Xf}`), s = Xf), s;
    }, this.fetchPublicKey = async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const i = this.startAbortTimer(vt.FIVE_SECONDS), s = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(i), await s.json();
      } catch (i) {
        this.logger.warn(i);
      }
    }, this.persistPublicKey = async (i) => {
      this.logger.debug("persisting public key to local storage", i), await this.store.setItem(this.storeKey, i), this.publicKey = i;
    }, this.removePublicKey = async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }, this.isValidJwtAttestation = async (i) => {
      const s = await this.getPublicKey();
      try {
        if (s) return this.validateAttestation(i, s);
      } catch (a) {
        this.logger.error(a), this.logger.warn("error validating attestation");
      }
      const o = await this.fetchAndPersistPublicKey();
      try {
        if (o) return this.validateAttestation(i, o);
      } catch (a) {
        this.logger.error(a), this.logger.warn("error validating attestation");
      }
    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (s) => {
        const o = await this.fetchPublicKey();
        o && (await this.persistPublicKey(o), s(o));
      });
      const i = await this.fetchPromise;
      return this.fetchPromise = void 0, i;
    }, this.validateAttestation = (i, s) => {
      const o = lW(i, s.publicKey), a = { hasExpired: vt.toMiliseconds(o.exp) < Date.now(), payload: o };
      if (a.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a.payload.origin, isScam: a.payload.isScam, isVerified: a.payload.isVerified };
    }, this.logger = ui(r, this.name), this.abortController = new AbortController(), this.isDevEnv = yb(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return Pi(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), vt.toMiliseconds(e));
  }
}
class QV extends $$ {
  constructor(e, r) {
    super(e, r), this.projectId = e, this.logger = r, this.context = tK, this.registerDeviceToken = async (n) => {
      const { clientId: i, token: s, notificationType: o, enableEncrypted: a = !1 } = n, u = `${rK}/${this.projectId}/clients`;
      await fetch(u, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i, type: o, token: s, always_raw: a }) });
    }, this.logger = ui(r, this.context);
  }
}
var eG = Object.defineProperty, H3 = Object.getOwnPropertySymbols, tG = Object.prototype.hasOwnProperty, rG = Object.prototype.propertyIsEnumerable, K3 = (t, e, r) => e in t ? eG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, $f = (t, e) => {
  for (var r in e || (e = {})) tG.call(e, r) && K3(t, r, e[r]);
  if (H3) for (var r of H3(e)) rG.call(e, r) && K3(t, r, e[r]);
  return t;
};
class nG extends B$ {
  constructor(e, r, n = !0) {
    super(e, r, n), this.core = e, this.logger = r, this.context = iK, this.storagePrefix = ro, this.storageVersion = nK, this.events = /* @__PURE__ */ new Map(), this.shouldPersist = !1, this.init = async () => {
      if (!yb()) try {
        const i = { eventId: r3(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: cE(this.core.relayer.protocol, this.core.relayer.version, K1) } } };
        await this.sendEvent([i]);
      } catch (i) {
        this.logger.warn(i);
      }
    }, this.createEvent = (i) => {
      const { event: s = "ERROR", type: o = "", properties: { topic: a, trace: u } } = i, l = r3(), d = this.core.projectId || "", p = Date.now(), w = $f({ eventId: l, timestamp: p, props: { event: s, type: o, properties: { topic: a, trace: u } }, bundleId: d, domain: this.getAppDomain() }, this.setMethods(l));
      return this.telemetryEnabled && (this.events.set(l, w), this.shouldPersist = !0), w;
    }, this.getEvent = (i) => {
      const { eventId: s, topic: o } = i;
      if (s) return this.events.get(s);
      const a = Array.from(this.events.values()).find((u) => u.props.properties.topic === o);
      if (a) return $f($f({}, a), this.setMethods(a.eventId));
    }, this.deleteEvent = (i) => {
      const { eventId: s } = i;
      this.events.delete(s), this.shouldPersist = !0;
    }, this.setEventListeners = () => {
      this.core.heartbeat.on(ju.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((i) => {
          vt.fromMiliseconds(Date.now()) - vt.fromMiliseconds(i.timestamp) > sK && (this.events.delete(i.eventId), this.shouldPersist = !0);
        });
      });
    }, this.setMethods = (i) => ({ addTrace: (s) => this.addTrace(i, s), setError: (s) => this.setError(i, s) }), this.addTrace = (i, s) => {
      const o = this.events.get(i);
      o && (o.props.properties.trace.push(s), this.events.set(i, o), this.shouldPersist = !0);
    }, this.setError = (i, s) => {
      const o = this.events.get(i);
      o && (o.props.type = s, o.timestamp = Date.now(), this.events.set(i, o), this.shouldPersist = !0);
    }, this.persist = async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = !1;
    }, this.restore = async () => {
      try {
        const i = await this.core.storage.getItem(this.storageKey) || [];
        if (!i.length) return;
        i.forEach((s) => {
          this.events.set(s.eventId, $f($f({}, s), this.setMethods(s.eventId)));
        });
      } catch (i) {
        this.logger.warn(i);
      }
    }, this.submit = async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const i = [];
      for (const [s, o] of this.events) o.props.type && i.push(o);
      if (i.length !== 0) try {
        if ((await this.sendEvent(i)).ok) for (const s of i) this.events.delete(s.eventId), this.shouldPersist = !0;
      } catch (s) {
        this.logger.warn(s);
      }
    }, this.sendEvent = async (i) => {
      const s = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${oK}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${K1}${s}`, { method: "POST", body: JSON.stringify(i) });
    }, this.getAppDomain = () => aE().url, this.logger = ui(r, this.context), this.telemetryEnabled = n, n ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
}
var iG = Object.defineProperty, V3 = Object.getOwnPropertySymbols, sG = Object.prototype.hasOwnProperty, oG = Object.prototype.propertyIsEnumerable, G3 = (t, e, r) => e in t ? iG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Y3 = (t, e) => {
  for (var r in e || (e = {})) sG.call(e, r) && G3(t, r, e[r]);
  if (V3) for (var r of V3(e)) oG.call(e, r) && G3(t, r, e[r]);
  return t;
};
class Pb extends I$ {
  constructor(e) {
    var r;
    super(e), this.protocol = CE, this.version = TE, this.name = RE, this.events = new is.EventEmitter(), this.initialized = !1, this.on = (o, a) => this.events.on(o, a), this.once = (o, a) => this.events.once(o, a), this.off = (o, a) => this.events.off(o, a), this.removeListener = (o, a) => this.events.removeListener(o, a), this.dispatchEnvelope = ({ topic: o, message: a, sessionExists: u }) => {
      if (!o || !a) return;
      const l = { topic: o, message: a, publishedAt: Date.now(), transportType: zr.link_mode };
      this.relayer.onLinkMessageEvent(l, { sessionExists: u });
    }, this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || OE, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const n = X0({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : PH.logger }), { logger: i, chunkLoggerController: s } = M$({ opts: n, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = s, (r = this.logChunkController) != null && r.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var o, a;
      (o = this.logChunkController) != null && o.downloadLogsBlobInBrowser && ((a = this.logChunkController) == null || a.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = ui(i, this.name), this.heartbeat = new xk(), this.crypto = new DV(this, this.logger, e == null ? void 0 : e.keychain), this.history = new JV(this, this.logger), this.expirer = new XV(this, this.logger), this.storage = e != null && e.storage ? e.storage : new Qk(Y3(Y3({}, MH), e == null ? void 0 : e.storageOptions)), this.relayer = new HV({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new YV(this, this.logger), this.verify = new ZV(this, this.logger, this.storage), this.echoClient = new QV(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new nG(this, this.logger, e == null ? void 0 : e.telemetryEnabled);
  }
  static async init(e) {
    const r = new Pb(e);
    await r.initialize();
    const n = await r.crypto.getClientId();
    return await r.storage.setItem(UH, n), r;
  }
  get context() {
    return Pi(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(T3, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.eventClient.init(), this.linkModeSupportedApps = await this.storage.getItem(T3) || [], this.initialized = !0, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
}
const aG = Pb, HE = "wc", KE = 2, VE = "client", Mb = `${HE}@${KE}:${VE}:`, Tm = { name: VE, logger: "error" }, J3 = "WALLETCONNECT_DEEPLINK_CHOICE", cG = "proposal", GE = "Proposal expired", uG = "session", ru = vt.SEVEN_DAYS, fG = "engine", In = { wc_sessionPropose: { req: { ttl: vt.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: vt.FIVE_MINUTES, prompt: !1, tag: 1101 }, reject: { ttl: vt.FIVE_MINUTES, prompt: !1, tag: 1120 }, autoReject: { ttl: vt.FIVE_MINUTES, prompt: !1, tag: 1121 } }, wc_sessionSettle: { req: { ttl: vt.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: vt.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: vt.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: vt.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: vt.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: vt.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: vt.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: vt.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: vt.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: vt.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: vt.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: vt.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: vt.ONE_DAY, prompt: !1, tag: 1114 }, res: { ttl: vt.ONE_DAY, prompt: !1, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: vt.ONE_HOUR, prompt: !0, tag: 1116 }, res: { ttl: vt.ONE_HOUR, prompt: !1, tag: 1117 }, reject: { ttl: vt.FIVE_MINUTES, prompt: !1, tag: 1118 }, autoReject: { ttl: vt.FIVE_MINUTES, prompt: !1, tag: 1119 } } }, Rm = { min: vt.FIVE_MINUTES, max: vt.SEVEN_DAYS }, Fs = { idle: "IDLE", active: "ACTIVE" }, lG = "request", hG = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"], dG = "wc", pG = "auth", gG = "authKeys", mG = "pairingTopics", vG = "requests", wp = `${dG}@${1.5}:${pG}:`, zd = `${wp}:PUB_KEY`;
var bG = Object.defineProperty, yG = Object.defineProperties, wG = Object.getOwnPropertyDescriptors, X3 = Object.getOwnPropertySymbols, xG = Object.prototype.hasOwnProperty, _G = Object.prototype.propertyIsEnumerable, Z3 = (t, e, r) => e in t ? bG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, tn = (t, e) => {
  for (var r in e || (e = {})) xG.call(e, r) && Z3(t, r, e[r]);
  if (X3) for (var r of X3(e)) _G.call(e, r) && Z3(t, r, e[r]);
  return t;
}, xs = (t, e) => yG(t, wG(e));
class EG extends j$ {
  constructor(e) {
    super(e), this.name = fG, this.events = new Xv(), this.initialized = !1, this.requestQueue = { state: Fs.idle, queue: [] }, this.sessionRequestQueue = { state: Fs.idle, queue: [] }, this.requestQueueDelay = vt.ONE_SECOND, this.expectedPairingMethodMap = /* @__PURE__ */ new Map(), this.recentlyDeletedMap = /* @__PURE__ */ new Map(), this.recentlyDeletedLimit = 200, this.relayMessageCache = [], this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(In) }), this.initialized = !0, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, vt.toMiliseconds(this.requestQueueDelay)));
    }, this.connect = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const n = xs(tn({}, r), { requiredNamespaces: r.requiredNamespaces || {}, optionalNamespaces: r.optionalNamespaces || {} });
      await this.isValidConnect(n);
      const { pairingTopic: i, requiredNamespaces: s, optionalNamespaces: o, sessionProperties: a, relays: u } = n;
      let l = i, d, p = !1;
      try {
        l && (p = this.client.core.pairing.pairings.get(l).active);
      } catch (U) {
        throw this.client.logger.error(`connect() -> pairing.get(${l}) failed`), U;
      }
      if (!l || !p) {
        const { topic: U, uri: V } = await this.client.core.pairing.create();
        l = U, d = V;
      }
      if (!l) {
        const { message: U } = ft("NO_MATCHING_KEY", `connect() pairing topic: ${l}`);
        throw new Error(U);
      }
      const w = await this.client.core.crypto.generateKeyPair(), _ = In.wc_sessionPropose.req.ttl || vt.FIVE_MINUTES, P = Sn(_), O = tn({ requiredNamespaces: s, optionalNamespaces: o, relays: u ?? [{ protocol: DE }], proposer: { publicKey: w, metadata: this.client.metadata }, expiryTimestamp: P, pairingTopic: l }, a && { sessionProperties: a }), { reject: L, resolve: B, done: k } = ec(_, GE);
      this.events.once(yr("session_connect"), async ({ error: U, session: V }) => {
        if (U) L(U);
        else if (V) {
          V.self.publicKey = w;
          const Q = xs(tn({}, V), { pairingTopic: O.pairingTopic, requiredNamespaces: O.requiredNamespaces, optionalNamespaces: O.optionalNamespaces, transportType: zr.relay });
          await this.client.session.set(V.topic, Q), await this.setExpiry(V.topic, V.expiry), l && await this.client.core.pairing.updateMetadata({ topic: l, metadata: V.peer.metadata }), this.cleanupDuplicatePairings(Q), B(Q);
        }
      });
      const q = await this.sendRequest({ topic: l, method: "wc_sessionPropose", params: O, throwOnFailedPublish: !0 });
      return await this.setProposal(q, tn({ id: q }, O)), { uri: d, approval: k };
    }, this.pair = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(r);
      } catch (n) {
        throw this.client.logger.error("pair() failed"), n;
      }
    }, this.approve = async (r) => {
      var n, i, s;
      const o = this.client.core.eventClient.createEvent({ properties: { topic: (n = r == null ? void 0 : r.id) == null ? void 0 : n.toString(), trace: [ws.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (K) {
        throw o.setError(Xa.no_internet_connection), K;
      }
      try {
        await this.isValidProposalId(r == null ? void 0 : r.id);
      } catch (K) {
        throw this.client.logger.error(`approve() -> proposal.get(${r == null ? void 0 : r.id}) failed`), o.setError(Xa.proposal_not_found), K;
      }
      try {
        await this.isValidApprove(r);
      } catch (K) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), o.setError(Xa.session_approve_namespace_validation_failure), K;
      }
      const { id: a, relayProtocol: u, namespaces: l, sessionProperties: d, sessionConfig: p } = r, w = this.client.proposal.get(a);
      this.client.core.eventClient.deleteEvent({ eventId: o.eventId });
      const { pairingTopic: _, proposer: P, requiredNamespaces: O, optionalNamespaces: L } = w;
      let B = (i = this.client.core.eventClient) == null ? void 0 : i.getEvent({ topic: _ });
      B || (B = (s = this.client.core.eventClient) == null ? void 0 : s.createEvent({ type: ws.session_approve_started, properties: { topic: _, trace: [ws.session_approve_started, ws.session_namespaces_validation_success] } }));
      const k = await this.client.core.crypto.generateKeyPair(), q = P.publicKey, U = await this.client.core.crypto.generateSharedKey(k, q), V = tn(tn({ relay: { protocol: u ?? "irn" }, namespaces: l, controller: { publicKey: k, metadata: this.client.metadata }, expiry: Sn(ru) }, d && { sessionProperties: d }), p && { sessionConfig: p }), Q = zr.relay;
      B.addTrace(ws.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(U, { transportType: Q });
      } catch (K) {
        throw B.setError(Xa.subscribe_session_topic_failure), K;
      }
      B.addTrace(ws.subscribe_session_topic_success);
      const R = xs(tn({}, V), { topic: U, requiredNamespaces: O, optionalNamespaces: L, pairingTopic: _, acknowledged: !1, self: V.controller, peer: { publicKey: P.publicKey, metadata: P.metadata }, controller: k, transportType: zr.relay });
      await this.client.session.set(U, R), B.addTrace(ws.store_session);
      try {
        B.addTrace(ws.publishing_session_settle), await this.sendRequest({ topic: U, method: "wc_sessionSettle", params: V, throwOnFailedPublish: !0 }).catch((K) => {
          throw B == null || B.setError(Xa.session_settle_publish_failure), K;
        }), B.addTrace(ws.session_settle_publish_success), B.addTrace(ws.publishing_session_approve), await this.sendResult({ id: a, topic: _, result: { relay: { protocol: u ?? "irn" }, responderPublicKey: k }, throwOnFailedPublish: !0 }).catch((K) => {
          throw B == null || B.setError(Xa.session_approve_publish_failure), K;
        }), B.addTrace(ws.session_approve_publish_success);
      } catch (K) {
        throw this.client.logger.error(K), this.client.session.delete(U, Or("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(U), K;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: B.eventId }), await this.client.core.pairing.updateMetadata({ topic: _, metadata: P.metadata }), await this.client.proposal.delete(a, Or("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: _ }), await this.setExpiry(U, Sn(ru)), { topic: U, acknowledged: () => Promise.resolve(this.client.session.get(U)) };
    }, this.reject = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(r);
      } catch (o) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), o;
      }
      const { id: n, reason: i } = r;
      let s;
      try {
        s = this.client.proposal.get(n).pairingTopic;
      } catch (o) {
        throw this.client.logger.error(`reject() -> proposal.get(${n}) failed`), o;
      }
      s && (await this.sendError({ id: n, topic: s, error: i, rpcOpts: In.wc_sessionPropose.reject }), await this.client.proposal.delete(n, Or("USER_DISCONNECTED")));
    }, this.update = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(r);
      } catch (p) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), p;
      }
      const { topic: n, namespaces: i } = r, { done: s, resolve: o, reject: a } = ec(), u = la(), l = fc().toString(), d = this.client.session.get(n).namespaces;
      return this.events.once(yr("session_update", u), ({ error: p }) => {
        p ? a(p) : o();
      }), await this.client.session.update(n, { namespaces: i }), await this.sendRequest({ topic: n, method: "wc_sessionUpdate", params: { namespaces: i }, throwOnFailedPublish: !0, clientRpcId: u, relayRpcId: l }).catch((p) => {
        this.client.logger.error(p), this.client.session.update(n, { namespaces: d }), a(p);
      }), { acknowledged: s };
    }, this.extend = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(r);
      } catch (u) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), u;
      }
      const { topic: n } = r, i = la(), { done: s, resolve: o, reject: a } = ec();
      return this.events.once(yr("session_extend", i), ({ error: u }) => {
        u ? a(u) : o();
      }), await this.setExpiry(n, Sn(ru)), this.sendRequest({ topic: n, method: "wc_sessionExtend", params: {}, clientRpcId: i, throwOnFailedPublish: !0 }).catch((u) => {
        a(u);
      }), { acknowledged: s };
    }, this.request = async (r) => {
      this.isInitialized();
      try {
        await this.isValidRequest(r);
      } catch (P) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), P;
      }
      const { chainId: n, request: i, topic: s, expiry: o = In.wc_sessionRequest.req.ttl } = r, a = this.client.session.get(s);
      (a == null ? void 0 : a.transportType) === zr.relay && await this.confirmOnlineStateOrThrow();
      const u = la(), l = fc().toString(), { done: d, resolve: p, reject: w } = ec(o, "Request expired. Please try again.");
      this.events.once(yr("session_request", u), ({ error: P, result: O }) => {
        P ? w(P) : p(O);
      });
      const _ = this.getAppLinkIfEnabled(a.peer.metadata, a.transportType);
      return _ ? (await this.sendRequest({ clientRpcId: u, relayRpcId: l, topic: s, method: "wc_sessionRequest", params: { request: xs(tn({}, i), { expiryTimestamp: Sn(o) }), chainId: n }, expiry: o, throwOnFailedPublish: !0, appLink: _ }).catch((P) => w(P)), this.client.events.emit("session_request_sent", { topic: s, request: i, chainId: n, id: u }), await d()) : await Promise.all([new Promise(async (P) => {
        await this.sendRequest({ clientRpcId: u, relayRpcId: l, topic: s, method: "wc_sessionRequest", params: { request: xs(tn({}, i), { expiryTimestamp: Sn(o) }), chainId: n }, expiry: o, throwOnFailedPublish: !0 }).catch((O) => w(O)), this.client.events.emit("session_request_sent", { topic: s, request: i, chainId: n, id: u }), P();
      }), new Promise(async (P) => {
        var O;
        if (!((O = a.sessionConfig) != null && O.disableDeepLink)) {
          const L = await Iz(this.client.core.storage, J3);
          await Pz({ id: u, topic: s, wcDeepLink: L });
        }
        P();
      }), d()]).then((P) => P[2]);
    }, this.respond = async (r) => {
      this.isInitialized(), await this.isValidRespond(r);
      const { topic: n, response: i } = r, { id: s } = i, o = this.client.session.get(n);
      o.transportType === zr.relay && await this.confirmOnlineStateOrThrow();
      const a = this.getAppLinkIfEnabled(o.peer.metadata, o.transportType);
      zs(i) ? await this.sendResult({ id: s, topic: n, result: i.result, throwOnFailedPublish: !0, appLink: a }) : es(i) && await this.sendError({ id: s, topic: n, error: i.error, appLink: a }), this.cleanupAfterResponse(r);
    }, this.ping = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(r);
      } catch (i) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), i;
      }
      const { topic: n } = r;
      if (this.client.session.keys.includes(n)) {
        const i = la(), s = fc().toString(), { done: o, resolve: a, reject: u } = ec();
        this.events.once(yr("session_ping", i), ({ error: l }) => {
          l ? u(l) : a();
        }), await Promise.all([this.sendRequest({ topic: n, method: "wc_sessionPing", params: {}, throwOnFailedPublish: !0, clientRpcId: i, relayRpcId: s }), o()]);
      } else this.client.core.pairing.pairings.keys.includes(n) && await this.client.core.pairing.ping({ topic: n });
    }, this.emit = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(r);
      const { topic: n, event: i, chainId: s } = r, o = fc().toString();
      await this.sendRequest({ topic: n, method: "wc_sessionEvent", params: { event: i, chainId: s }, throwOnFailedPublish: !0, relayRpcId: o });
    }, this.disconnect = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(r);
      const { topic: n } = r;
      if (this.client.session.keys.includes(n)) await this.sendRequest({ topic: n, method: "wc_sessionDelete", params: Or("USER_DISCONNECTED"), throwOnFailedPublish: !0 }), await this.deleteSession({ topic: n, emitEvent: !1 });
      else if (this.client.core.pairing.pairings.keys.includes(n)) await this.client.core.pairing.disconnect({ topic: n });
      else {
        const { message: i } = ft("MISMATCHED_TOPIC", `Session or pairing topic not found: ${n}`);
        throw new Error(i);
      }
    }, this.find = (r) => (this.isInitialized(), this.client.session.getAll().filter((n) => IW(n, r))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (r, n) => {
      var i;
      this.isInitialized(), this.isValidAuthenticate(r);
      const s = n && this.client.core.linkModeSupportedApps.includes(n) && ((i = this.client.metadata.redirect) == null ? void 0 : i.linkMode), o = s ? zr.link_mode : zr.relay;
      o === zr.relay && await this.confirmOnlineStateOrThrow();
      const { chains: a, statement: u = "", uri: l, domain: d, nonce: p, type: w, exp: _, nbf: P, methods: O = [], expiry: L } = r, B = [...r.resources || []], { topic: k, uri: q } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: o });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: k, uri: q } });
      const U = await this.client.core.crypto.generateKeyPair(), V = qd(U);
      if (await Promise.all([this.client.auth.authKeys.set(zd, { responseTopic: V, publicKey: U }), this.client.auth.pairingTopics.set(V, { topic: V, pairingTopic: k })]), await this.client.core.relayer.subscribe(V, { transportType: o }), this.client.logger.info(`sending request to new pairing topic: ${k}`), O.length > 0) {
        const { namespace: E } = _u(a[0]);
        let S = Yz(E, "request", O);
        Ud(B) && (S = Xz(S, B.pop())), B.push(S);
      }
      const Q = L && L > In.wc_sessionAuthenticate.req.ttl ? L : In.wc_sessionAuthenticate.req.ttl, R = { authPayload: { type: w ?? "caip122", chains: a, statement: u, aud: l, domain: d, version: "1", nonce: p, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: _, nbf: P, resources: B }, requester: { publicKey: U, metadata: this.client.metadata }, expiryTimestamp: Sn(Q) }, K = { eip155: { chains: a, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...O])], events: ["chainChanged", "accountsChanged"] } }, ge = { requiredNamespaces: {}, optionalNamespaces: K, relays: [{ protocol: "irn" }], pairingTopic: k, proposer: { publicKey: U, metadata: this.client.metadata }, expiryTimestamp: Sn(In.wc_sessionPropose.req.ttl) }, { done: Ee, resolve: Y, reject: A } = ec(Q, "Request expired"), m = async ({ error: E, session: S }) => {
        if (this.events.off(yr("session_request", g), f), E) A(E);
        else if (S) {
          S.self.publicKey = U, await this.client.session.set(S.topic, S), await this.setExpiry(S.topic, S.expiry), k && await this.client.core.pairing.updateMetadata({ topic: k, metadata: S.peer.metadata });
          const v = this.client.session.get(S.topic);
          await this.deleteProposal(b), Y({ session: v });
        }
      }, f = async (E) => {
        var S, v, M;
        if (await this.deletePendingAuthRequest(g, { message: "fulfilled", code: 0 }), E.error) {
          const J = Or("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return E.error.code === J.code ? void 0 : (this.events.off(yr("session_connect"), m), A(E.error.message));
        }
        await this.deleteProposal(b), this.events.off(yr("session_connect"), m);
        const { cacaos: I, responder: F } = E.result, ce = [], D = [];
        for (const J of I) {
          await s3({ cacao: J, projectId: this.client.core.projectId }) || (this.client.logger.error(J, "Signature verification failed"), A(Or("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: ee } = J, T = Ud(ee.resources), X = [z1(ee.iss)], re = x0(ee.iss);
          if (T) {
            const pe = o3(T), ie = a3(T);
            ce.push(...pe), X.push(...ie);
          }
          for (const pe of X) D.push(`${pe}:${re}`);
        }
        const oe = await this.client.core.crypto.generateSharedKey(U, F.publicKey);
        let Z;
        ce.length > 0 && (Z = { topic: oe, acknowledged: !0, self: { publicKey: U, metadata: this.client.metadata }, peer: F, controller: F.publicKey, expiry: Sn(ru), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: k, namespaces: m3([...new Set(ce)], [...new Set(D)]), transportType: o }, await this.client.core.relayer.subscribe(oe, { transportType: o }), await this.client.session.set(oe, Z), k && await this.client.core.pairing.updateMetadata({ topic: k, metadata: F.metadata }), Z = this.client.session.get(oe)), (S = this.client.metadata.redirect) != null && S.linkMode && (v = F.metadata.redirect) != null && v.linkMode && (M = F.metadata.redirect) != null && M.universal && n && (this.client.core.addLinkModeSupportedApp(F.metadata.redirect.universal), this.client.session.update(oe, { transportType: zr.link_mode })), Y({ auths: I, session: Z });
      }, g = la(), b = la();
      this.events.once(yr("session_connect"), m), this.events.once(yr("session_request", g), f);
      let x;
      try {
        if (s) {
          const E = ga("wc_sessionAuthenticate", R, g);
          this.client.core.history.set(k, E);
          const S = await this.client.core.crypto.encode("", E, { type: fh, encoding: Df });
          x = xd(n, k, S);
        } else await Promise.all([this.sendRequest({ topic: k, method: "wc_sessionAuthenticate", params: R, expiry: r.expiry, throwOnFailedPublish: !0, clientRpcId: g }), this.sendRequest({ topic: k, method: "wc_sessionPropose", params: ge, expiry: In.wc_sessionPropose.req.ttl, throwOnFailedPublish: !0, clientRpcId: b })]);
      } catch (E) {
        throw this.events.off(yr("session_connect"), m), this.events.off(yr("session_request", g), f), E;
      }
      return await this.setProposal(b, tn({ id: b }, ge)), await this.setAuthRequest(g, { request: xs(tn({}, R), { verifyContext: {} }), pairingTopic: k, transportType: o }), { uri: x ?? q, response: Ee };
    }, this.approveSessionAuthenticate = async (r) => {
      const { id: n, auths: i } = r, s = this.client.core.eventClient.createEvent({ properties: { topic: n.toString(), trace: [Za.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (L) {
        throw s.setError(Lf.no_internet_connection), L;
      }
      const o = this.getPendingAuthRequest(n);
      if (!o) throw s.setError(Lf.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${n}`);
      const a = o.transportType || zr.relay;
      a === zr.relay && await this.confirmOnlineStateOrThrow();
      const u = o.requester.publicKey, l = await this.client.core.crypto.generateKeyPair(), d = qd(u), p = { type: Oo, receiverPublicKey: u, senderPublicKey: l }, w = [], _ = [];
      for (const L of i) {
        if (!await s3({ cacao: L, projectId: this.client.core.projectId })) {
          s.setError(Lf.invalid_cacao);
          const V = Or("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: n, topic: d, error: V, encodeOpts: p }), new Error(V.message);
        }
        s.addTrace(Za.cacaos_verified);
        const { p: B } = L, k = Ud(B.resources), q = [z1(B.iss)], U = x0(B.iss);
        if (k) {
          const V = o3(k), Q = a3(k);
          w.push(...V), q.push(...Q);
        }
        for (const V of q) _.push(`${V}:${U}`);
      }
      const P = await this.client.core.crypto.generateSharedKey(l, u);
      s.addTrace(Za.create_authenticated_session_topic);
      let O;
      if ((w == null ? void 0 : w.length) > 0) {
        O = { topic: P, acknowledged: !0, self: { publicKey: l, metadata: this.client.metadata }, peer: { publicKey: u, metadata: o.requester.metadata }, controller: u, expiry: Sn(ru), authentication: i, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: o.pairingTopic, namespaces: m3([...new Set(w)], [...new Set(_)]), transportType: a }, s.addTrace(Za.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(P, { transportType: a });
        } catch (L) {
          throw s.setError(Lf.subscribe_authenticated_session_topic_failure), L;
        }
        s.addTrace(Za.subscribe_authenticated_session_topic_success), await this.client.session.set(P, O), s.addTrace(Za.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: o.pairingTopic, metadata: o.requester.metadata });
      }
      s.addTrace(Za.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: d, id: n, result: { cacaos: i, responder: { publicKey: l, metadata: this.client.metadata } }, encodeOpts: p, throwOnFailedPublish: !0, appLink: this.getAppLinkIfEnabled(o.requester.metadata, a) });
      } catch (L) {
        throw s.setError(Lf.authenticated_session_approve_publish_failure), L;
      }
      return await this.client.auth.requests.delete(n, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: o.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: s.eventId }), { session: O };
    }, this.rejectSessionAuthenticate = async (r) => {
      this.isInitialized();
      const { id: n, reason: i } = r, s = this.getPendingAuthRequest(n);
      if (!s) throw new Error(`Could not find pending auth request with id ${n}`);
      s.transportType === zr.relay && await this.confirmOnlineStateOrThrow();
      const o = s.requester.publicKey, a = await this.client.core.crypto.generateKeyPair(), u = qd(o), l = { type: Oo, receiverPublicKey: o, senderPublicKey: a };
      await this.sendError({ id: n, topic: u, error: i, encodeOpts: l, rpcOpts: In.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(s.requester.metadata, s.transportType) }), await this.client.auth.requests.delete(n, { message: "rejected", code: 0 }), await this.client.proposal.delete(n, Or("USER_DISCONNECTED"));
    }, this.formatAuthMessage = (r) => {
      this.isInitialized();
      const { request: n, iss: i } = r;
      return pE(n, i);
    }, this.processRelayMessageCache = () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const r = this.relayMessageCache.shift();
          r && await this.onRelayMessage(r);
        } catch (r) {
          this.client.logger.error(r);
        }
      }, 50);
    }, this.cleanupDuplicatePairings = async (r) => {
      if (r.pairingTopic) try {
        const n = this.client.core.pairing.pairings.get(r.pairingTopic), i = this.client.core.pairing.pairings.getAll().filter((s) => {
          var o, a;
          return ((o = s.peerMetadata) == null ? void 0 : o.url) && ((a = s.peerMetadata) == null ? void 0 : a.url) === r.peer.metadata.url && s.topic && s.topic !== n.topic;
        });
        if (i.length === 0) return;
        this.client.logger.info(`Cleaning up ${i.length} duplicate pairing(s)`), await Promise.all(i.map((s) => this.client.core.pairing.disconnect({ topic: s.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (n) {
        this.client.logger.error(n);
      }
    }, this.deleteSession = async (r) => {
      var n;
      const { topic: i, expirerHasDeleted: s = !1, emitEvent: o = !0, id: a = 0 } = r, { self: u } = this.client.session.get(i);
      await this.client.core.relayer.unsubscribe(i), await this.client.session.delete(i, Or("USER_DISCONNECTED")), this.addToRecentlyDeleted(i, "session"), this.client.core.crypto.keychain.has(u.publicKey) && await this.client.core.crypto.deleteKeyPair(u.publicKey), this.client.core.crypto.keychain.has(i) && await this.client.core.crypto.deleteSymKey(i), s || this.client.core.expirer.del(i), this.client.core.storage.removeItem(J3).catch((l) => this.client.logger.warn(l)), this.getPendingSessionRequests().forEach((l) => {
        l.topic === i && this.deletePendingSessionRequest(l.id, Or("USER_DISCONNECTED"));
      }), i === ((n = this.sessionRequestQueue.queue[0]) == null ? void 0 : n.topic) && (this.sessionRequestQueue.state = Fs.idle), o && this.client.events.emit("session_delete", { id: a, topic: i });
    }, this.deleteProposal = async (r, n) => {
      if (n) try {
        const i = this.client.proposal.get(r), s = this.client.core.eventClient.getEvent({ topic: i.pairingTopic });
        s == null || s.setError(Xa.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(r, Or("USER_DISCONNECTED")), n ? Promise.resolve() : this.client.core.expirer.del(r)]), this.addToRecentlyDeleted(r, "proposal");
    }, this.deletePendingSessionRequest = async (r, n, i = !1) => {
      await Promise.all([this.client.pendingRequest.delete(r, n), i ? Promise.resolve() : this.client.core.expirer.del(r)]), this.addToRecentlyDeleted(r, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((s) => s.id !== r), i && (this.sessionRequestQueue.state = Fs.idle, this.client.events.emit("session_request_expire", { id: r }));
    }, this.deletePendingAuthRequest = async (r, n, i = !1) => {
      await Promise.all([this.client.auth.requests.delete(r, n), i ? Promise.resolve() : this.client.core.expirer.del(r)]);
    }, this.setExpiry = async (r, n) => {
      this.client.session.keys.includes(r) && (this.client.core.expirer.set(r, n), await this.client.session.update(r, { expiry: n }));
    }, this.setProposal = async (r, n) => {
      this.client.core.expirer.set(r, Sn(In.wc_sessionPropose.req.ttl)), await this.client.proposal.set(r, n);
    }, this.setAuthRequest = async (r, n) => {
      const { request: i, pairingTopic: s, transportType: o = zr.relay } = n;
      this.client.core.expirer.set(r, i.expiryTimestamp), await this.client.auth.requests.set(r, { authPayload: i.authPayload, requester: i.requester, expiryTimestamp: i.expiryTimestamp, id: r, pairingTopic: s, verifyContext: i.verifyContext, transportType: o });
    }, this.setPendingSessionRequest = async (r) => {
      const { id: n, topic: i, params: s, verifyContext: o } = r, a = s.request.expiryTimestamp || Sn(In.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(n, a), await this.client.pendingRequest.set(n, { id: n, topic: i, params: s, verifyContext: o });
    }, this.sendRequest = async (r) => {
      const { topic: n, method: i, params: s, expiry: o, relayRpcId: a, clientRpcId: u, throwOnFailedPublish: l, appLink: d } = r, p = ga(i, s, u);
      let w;
      const _ = !!d;
      try {
        const L = _ ? Df : pa;
        w = await this.client.core.crypto.encode(n, p, { encoding: L });
      } catch (L) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${n} failed`), L;
      }
      let P;
      if (hG.includes(i)) {
        const L = Ao(JSON.stringify(p)), B = Ao(w);
        P = await this.client.core.verify.register({ id: B, decryptedId: L });
      }
      const O = In[i].req;
      if (O.attestation = P, o && (O.ttl = o), a && (O.id = a), this.client.core.history.set(n, p), _) {
        const L = xd(d, n, w);
        await global.Linking.openURL(L, this.client.name);
      } else {
        const L = In[i].req;
        o && (L.ttl = o), a && (L.id = a), l ? (L.internal = xs(tn({}, L.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(n, w, L)) : this.client.core.relayer.publish(n, w, L).catch((B) => this.client.logger.error(B));
      }
      return p.id;
    }, this.sendResult = async (r) => {
      const { id: n, topic: i, result: s, throwOnFailedPublish: o, encodeOpts: a, appLink: u } = r, l = mp(n, s);
      let d;
      const p = u && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const _ = p ? Df : pa;
        d = await this.client.core.crypto.encode(i, l, xs(tn({}, a || {}), { encoding: _ }));
      } catch (_) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${i} failed`), _;
      }
      let w;
      try {
        w = await this.client.core.history.get(i, n);
      } catch (_) {
        throw this.client.logger.error(`sendResult() -> history.get(${i}, ${n}) failed`), _;
      }
      if (p) {
        const _ = xd(u, i, d);
        await global.Linking.openURL(_, this.client.name);
      } else {
        const _ = In[w.request.method].res;
        o ? (_.internal = xs(tn({}, _.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(i, d, _)) : this.client.core.relayer.publish(i, d, _).catch((P) => this.client.logger.error(P));
      }
      await this.client.core.history.resolve(l);
    }, this.sendError = async (r) => {
      const { id: n, topic: i, error: s, encodeOpts: o, rpcOpts: a, appLink: u } = r, l = vp(n, s);
      let d;
      const p = u && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const _ = p ? Df : pa;
        d = await this.client.core.crypto.encode(i, l, xs(tn({}, o || {}), { encoding: _ }));
      } catch (_) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${i} failed`), _;
      }
      let w;
      try {
        w = await this.client.core.history.get(i, n);
      } catch (_) {
        throw this.client.logger.error(`sendError() -> history.get(${i}, ${n}) failed`), _;
      }
      if (p) {
        const _ = xd(u, i, d);
        await global.Linking.openURL(_, this.client.name);
      } else {
        const _ = a || In[w.request.method].res;
        this.client.core.relayer.publish(i, d, _);
      }
      await this.client.core.history.resolve(l);
    }, this.cleanup = async () => {
      const r = [], n = [];
      this.client.session.getAll().forEach((i) => {
        let s = !1;
        fa(i.expiry) && (s = !0), this.client.core.crypto.keychain.has(i.topic) || (s = !0), s && r.push(i.topic);
      }), this.client.proposal.getAll().forEach((i) => {
        fa(i.expiryTimestamp) && n.push(i.id);
      }), await Promise.all([...r.map((i) => this.deleteSession({ topic: i })), ...n.map((i) => this.deleteProposal(i))]);
    }, this.onRelayEventRequest = async (r) => {
      this.requestQueue.queue.push(r), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === Fs.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = Fs.active;
        const r = this.requestQueue.queue.shift();
        if (r) try {
          await this.processRequest(r);
        } catch (n) {
          this.client.logger.warn(n);
        }
      }
      this.requestQueue.state = Fs.idle;
    }, this.processRequest = async (r) => {
      const { topic: n, payload: i, attestation: s, transportType: o, encryptedId: a } = r, u = i.method;
      if (!this.shouldIgnorePairingRequest({ topic: n, requestMethod: u })) switch (u) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: n, payload: i, attestation: s, encryptedId: a });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(n, i);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(n, i);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(n, i);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(n, i);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(n, i);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: n, payload: i, attestation: s, encryptedId: a, transportType: o });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(n, i);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: n, payload: i, attestation: s, encryptedId: a, transportType: o });
        default:
          return this.client.logger.info(`Unsupported request method ${u}`);
      }
    }, this.onRelayEventResponse = async (r) => {
      const { topic: n, payload: i, transportType: s } = r, o = (await this.client.core.history.get(n, i.id)).request.method;
      switch (o) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(n, i, s);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(n, i);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(n, i);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(n, i);
        case "wc_sessionPing":
          return this.onSessionPingResponse(n, i);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(n, i);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(n, i);
        default:
          return this.client.logger.info(`Unsupported response method ${o}`);
      }
    }, this.onRelayEventUnknownPayload = (r) => {
      const { topic: n } = r, { message: i } = ft("MISSING_OR_INVALID", `Decoded payload on topic ${n} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(i);
    }, this.shouldIgnorePairingRequest = (r) => {
      const { topic: n, requestMethod: i } = r, s = this.expectedPairingMethodMap.get(n);
      return !s || s.includes(i) ? !1 : !!(s.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }, this.onSessionProposeRequest = async (r) => {
      const { topic: n, payload: i, attestation: s, encryptedId: o } = r, { params: a, id: u } = i;
      try {
        const l = this.client.core.eventClient.getEvent({ topic: n });
        this.isValidConnect(tn({}, i.params));
        const d = a.expiryTimestamp || Sn(In.wc_sessionPropose.req.ttl), p = tn({ id: u, pairingTopic: n, expiryTimestamp: d }, a);
        await this.setProposal(u, p);
        const w = await this.getVerifyContext({ attestationId: s, hash: Ao(JSON.stringify(i)), encryptedId: o, metadata: p.proposer.metadata });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l == null || l.setError(So.proposal_listener_not_found)), l == null || l.addTrace(qs.emit_session_proposal), this.client.events.emit("session_proposal", { id: u, params: p, verifyContext: w });
      } catch (l) {
        await this.sendError({ id: u, topic: n, error: l, rpcOpts: In.wc_sessionPropose.autoReject }), this.client.logger.error(l);
      }
    }, this.onSessionProposeResponse = async (r, n, i) => {
      const { id: s } = n;
      if (zs(n)) {
        const { result: o } = n;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: o });
        const a = this.client.proposal.get(s);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: a });
        const u = a.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: u });
        const l = o.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l });
        const d = await this.client.core.crypto.generateSharedKey(u, l);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: d });
        const p = await this.client.core.relayer.subscribe(d, { transportType: i });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p }), await this.client.core.pairing.activate({ topic: r });
      } else if (es(n)) {
        await this.client.proposal.delete(s, Or("USER_DISCONNECTED"));
        const o = yr("session_connect");
        if (this.events.listenerCount(o) === 0) throw new Error(`emitting ${o} without any listeners, 954`);
        this.events.emit(yr("session_connect"), { error: n.error });
      }
    }, this.onSessionSettleRequest = async (r, n) => {
      const { id: i, params: s } = n;
      try {
        this.isValidSessionSettleRequest(s);
        const { relay: o, controller: a, expiry: u, namespaces: l, sessionProperties: d, sessionConfig: p } = n.params, w = xs(tn(tn({ topic: r, relay: o, expiry: u, namespaces: l, acknowledged: !0, pairingTopic: "", requiredNamespaces: {}, optionalNamespaces: {}, controller: a.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: a.publicKey, metadata: a.metadata } }, d && { sessionProperties: d }), p && { sessionConfig: p }), { transportType: zr.relay }), _ = yr("session_connect");
        if (this.events.listenerCount(_) === 0) throw new Error(`emitting ${_} without any listeners 997`);
        this.events.emit(yr("session_connect"), { session: w }), await this.sendResult({ id: n.id, topic: r, result: !0, throwOnFailedPublish: !0 });
      } catch (o) {
        await this.sendError({ id: i, topic: r, error: o }), this.client.logger.error(o);
      }
    }, this.onSessionSettleResponse = async (r, n) => {
      const { id: i } = n;
      zs(n) ? (await this.client.session.update(r, { acknowledged: !0 }), this.events.emit(yr("session_approve", i), {})) : es(n) && (await this.client.session.delete(r, Or("USER_DISCONNECTED")), this.events.emit(yr("session_approve", i), { error: n.error }));
    }, this.onSessionUpdateRequest = async (r, n) => {
      const { params: i, id: s } = n;
      try {
        const o = `${r}_session_update`, a = Of.get(o);
        if (a && this.isRequestOutOfSync(a, s)) {
          this.client.logger.info(`Discarding out of sync request - ${s}`), this.sendError({ id: s, topic: r, error: Or("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(tn({ topic: r }, i));
        try {
          Of.set(o, s), await this.client.session.update(r, { namespaces: i.namespaces }), await this.sendResult({ id: s, topic: r, result: !0, throwOnFailedPublish: !0 });
        } catch (u) {
          throw Of.delete(o), u;
        }
        this.client.events.emit("session_update", { id: s, topic: r, params: i });
      } catch (o) {
        await this.sendError({ id: s, topic: r, error: o }), this.client.logger.error(o);
      }
    }, this.isRequestOutOfSync = (r, n) => parseInt(n.toString().slice(0, -3)) <= parseInt(r.toString().slice(0, -3)), this.onSessionUpdateResponse = (r, n) => {
      const { id: i } = n, s = yr("session_update", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      zs(n) ? this.events.emit(yr("session_update", i), {}) : es(n) && this.events.emit(yr("session_update", i), { error: n.error });
    }, this.onSessionExtendRequest = async (r, n) => {
      const { id: i } = n;
      try {
        this.isValidExtend({ topic: r }), await this.setExpiry(r, Sn(ru)), await this.sendResult({ id: i, topic: r, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_extend", { id: i, topic: r });
      } catch (s) {
        await this.sendError({ id: i, topic: r, error: s }), this.client.logger.error(s);
      }
    }, this.onSessionExtendResponse = (r, n) => {
      const { id: i } = n, s = yr("session_extend", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      zs(n) ? this.events.emit(yr("session_extend", i), {}) : es(n) && this.events.emit(yr("session_extend", i), { error: n.error });
    }, this.onSessionPingRequest = async (r, n) => {
      const { id: i } = n;
      try {
        this.isValidPing({ topic: r }), await this.sendResult({ id: i, topic: r, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_ping", { id: i, topic: r });
      } catch (s) {
        await this.sendError({ id: i, topic: r, error: s }), this.client.logger.error(s);
      }
    }, this.onSessionPingResponse = (r, n) => {
      const { id: i } = n, s = yr("session_ping", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      setTimeout(() => {
        zs(n) ? this.events.emit(yr("session_ping", i), {}) : es(n) && this.events.emit(yr("session_ping", i), { error: n.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (r, n) => {
      const { id: i } = n;
      try {
        this.isValidDisconnect({ topic: r, reason: n.params }), Promise.all([new Promise((s) => {
          this.client.core.relayer.once(ai.publish, async () => {
            s(await this.deleteSession({ topic: r, id: i }));
          });
        }), this.sendResult({ id: i, topic: r, result: !0, throwOnFailedPublish: !0 }), this.cleanupPendingSentRequestsForTopic({ topic: r, error: Or("USER_DISCONNECTED") })]).catch((s) => this.client.logger.error(s));
      } catch (s) {
        this.client.logger.error(s);
      }
    }, this.onSessionRequest = async (r) => {
      var n, i, s;
      const { topic: o, payload: a, attestation: u, encryptedId: l, transportType: d } = r, { id: p, params: w } = a;
      try {
        await this.isValidRequest(tn({ topic: o }, w));
        const _ = this.client.session.get(o), P = await this.getVerifyContext({ attestationId: u, hash: Ao(JSON.stringify(ga("wc_sessionRequest", w, p))), encryptedId: l, metadata: _.peer.metadata, transportType: d }), O = { id: p, topic: o, params: w, verifyContext: P };
        await this.setPendingSessionRequest(O), d === zr.link_mode && (n = _.peer.metadata.redirect) != null && n.universal && this.client.core.addLinkModeSupportedApp((i = _.peer.metadata.redirect) == null ? void 0 : i.universal), (s = this.client.signConfig) != null && s.disableRequestQueue ? this.emitSessionRequest(O) : (this.addSessionRequestToSessionRequestQueue(O), this.processSessionRequestQueue());
      } catch (_) {
        await this.sendError({ id: p, topic: o, error: _ }), this.client.logger.error(_);
      }
    }, this.onSessionRequestResponse = (r, n) => {
      const { id: i } = n, s = yr("session_request", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      zs(n) ? this.events.emit(yr("session_request", i), { result: n.result }) : es(n) && this.events.emit(yr("session_request", i), { error: n.error });
    }, this.onSessionEventRequest = async (r, n) => {
      const { id: i, params: s } = n;
      try {
        const o = `${r}_session_event_${s.event.name}`, a = Of.get(o);
        if (a && this.isRequestOutOfSync(a, i)) {
          this.client.logger.info(`Discarding out of sync request - ${i}`);
          return;
        }
        this.isValidEmit(tn({ topic: r }, s)), this.client.events.emit("session_event", { id: i, topic: r, params: s }), Of.set(o, i);
      } catch (o) {
        await this.sendError({ id: i, topic: r, error: o }), this.client.logger.error(o);
      }
    }, this.onSessionAuthenticateResponse = (r, n) => {
      const { id: i } = n;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: r, payload: n }), zs(n) ? this.events.emit(yr("session_request", i), { result: n.result }) : es(n) && this.events.emit(yr("session_request", i), { error: n.error });
    }, this.onSessionAuthenticateRequest = async (r) => {
      var n;
      const { topic: i, payload: s, attestation: o, encryptedId: a, transportType: u } = r;
      try {
        const { requester: l, authPayload: d, expiryTimestamp: p } = s.params, w = await this.getVerifyContext({ attestationId: o, hash: Ao(JSON.stringify(s)), encryptedId: a, metadata: l.metadata, transportType: u }), _ = { requester: l, pairingTopic: i, id: s.id, authPayload: d, verifyContext: w, expiryTimestamp: p };
        await this.setAuthRequest(s.id, { request: _, pairingTopic: i, transportType: u }), u === zr.link_mode && (n = l.metadata.redirect) != null && n.universal && this.client.core.addLinkModeSupportedApp(l.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: i, params: s.params, id: s.id, verifyContext: w });
      } catch (l) {
        this.client.logger.error(l);
        const d = s.params.requester.publicKey, p = await this.client.core.crypto.generateKeyPair(), w = this.getAppLinkIfEnabled(s.params.requester.metadata, u), _ = { type: Oo, receiverPublicKey: d, senderPublicKey: p };
        await this.sendError({ id: s.id, topic: i, error: l, encodeOpts: _, rpcOpts: In.wc_sessionAuthenticate.autoReject, appLink: w });
      }
    }, this.addSessionRequestToSessionRequestQueue = (r) => {
      this.sessionRequestQueue.queue.push(r);
    }, this.cleanupAfterResponse = (r) => {
      this.deletePendingSessionRequest(r.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = Fs.idle, this.processSessionRequestQueue();
      }, vt.toMiliseconds(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: r, error: n }) => {
      const i = this.client.core.history.pending;
      i.length > 0 && i.filter((s) => s.topic === r && s.request.method === "wc_sessionRequest").forEach((s) => {
        const o = s.request.id, a = yr("session_request", o);
        if (this.events.listenerCount(a) === 0) throw new Error(`emitting ${a} without any listeners`);
        this.events.emit(yr("session_request", s.request.id), { error: n });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === Fs.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const r = this.sessionRequestQueue.queue[0];
      if (!r) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = Fs.active, this.emitSessionRequest(r);
      } catch (n) {
        this.client.logger.error(n);
      }
    }, this.emitSessionRequest = (r) => {
      this.client.events.emit("session_request", r);
    }, this.onPairingCreated = (r) => {
      if (r.methods && this.expectedPairingMethodMap.set(r.topic, r.methods), r.active) return;
      const n = this.client.proposal.getAll().find((i) => i.pairingTopic === r.topic);
      n && this.onSessionProposeRequest({ topic: r.topic, payload: ga("wc_sessionPropose", { requiredNamespaces: n.requiredNamespaces, optionalNamespaces: n.optionalNamespaces, relays: n.relays, proposer: n.proposer, sessionProperties: n.sessionProperties }, n.id) });
    }, this.isValidConnect = async (r) => {
      if (!mi(r)) {
        const { message: u } = ft("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(r)}`);
        throw new Error(u);
      }
      const { pairingTopic: n, requiredNamespaces: i, optionalNamespaces: s, sessionProperties: o, relays: a } = r;
      if (vi(n) || await this.isValidPairingTopic(n), !jW(a)) {
        const { message: u } = ft("MISSING_OR_INVALID", `connect() relays: ${a}`);
        throw new Error(u);
      }
      !vi(i) && Ll(i) !== 0 && this.validateNamespaces(i, "requiredNamespaces"), !vi(s) && Ll(s) !== 0 && this.validateNamespaces(s, "optionalNamespaces"), vi(o) || this.validateSessionProps(o, "sessionProperties");
    }, this.validateNamespaces = (r, n) => {
      const i = FW(r, "connect()", n);
      if (i) throw new Error(i.message);
    }, this.isValidApprove = async (r) => {
      if (!mi(r)) throw new Error(ft("MISSING_OR_INVALID", `approve() params: ${r}`).message);
      const { id: n, namespaces: i, relayProtocol: s, sessionProperties: o } = r;
      this.checkRecentlyDeleted(n), await this.isValidProposalId(n);
      const a = this.client.proposal.get(n), u = Pm(i, "approve()");
      if (u) throw new Error(u.message);
      const l = y3(a.requiredNamespaces, i, "approve()");
      if (l) throw new Error(l.message);
      if (!dn(s, !0)) {
        const { message: d } = ft("MISSING_OR_INVALID", `approve() relayProtocol: ${s}`);
        throw new Error(d);
      }
      vi(o) || this.validateSessionProps(o, "sessionProperties");
    }, this.isValidReject = async (r) => {
      if (!mi(r)) {
        const { message: s } = ft("MISSING_OR_INVALID", `reject() params: ${r}`);
        throw new Error(s);
      }
      const { id: n, reason: i } = r;
      if (this.checkRecentlyDeleted(n), await this.isValidProposalId(n), !qW(i)) {
        const { message: s } = ft("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(i)}`);
        throw new Error(s);
      }
    }, this.isValidSessionSettleRequest = (r) => {
      if (!mi(r)) {
        const { message: l } = ft("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${r}`);
        throw new Error(l);
      }
      const { relay: n, controller: i, namespaces: s, expiry: o } = r;
      if (!_E(n)) {
        const { message: l } = ft("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l);
      }
      const a = OW(i, "onSessionSettleRequest()");
      if (a) throw new Error(a.message);
      const u = Pm(s, "onSessionSettleRequest()");
      if (u) throw new Error(u.message);
      if (fa(o)) {
        const { message: l } = ft("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l);
      }
    }, this.isValidUpdate = async (r) => {
      if (!mi(r)) {
        const { message: u } = ft("MISSING_OR_INVALID", `update() params: ${r}`);
        throw new Error(u);
      }
      const { topic: n, namespaces: i } = r;
      this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
      const s = this.client.session.get(n), o = Pm(i, "update()");
      if (o) throw new Error(o.message);
      const a = y3(s.requiredNamespaces, i, "update()");
      if (a) throw new Error(a.message);
    }, this.isValidExtend = async (r) => {
      if (!mi(r)) {
        const { message: i } = ft("MISSING_OR_INVALID", `extend() params: ${r}`);
        throw new Error(i);
      }
      const { topic: n } = r;
      this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
    }, this.isValidRequest = async (r) => {
      if (!mi(r)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() params: ${r}`);
        throw new Error(u);
      }
      const { topic: n, request: i, chainId: s, expiry: o } = r;
      this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
      const { namespaces: a } = this.client.session.get(n);
      if (!b3(a, s)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() chainId: ${s}`);
        throw new Error(u);
      }
      if (!zW(i)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() ${JSON.stringify(i)}`);
        throw new Error(u);
      }
      if (!KW(a, s, i.method)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() method: ${i.method}`);
        throw new Error(u);
      }
      if (o && !JW(o, Rm)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() expiry: ${o}. Expiry must be a number (in seconds) between ${Rm.min} and ${Rm.max}`);
        throw new Error(u);
      }
    }, this.isValidRespond = async (r) => {
      var n;
      if (!mi(r)) {
        const { message: o } = ft("MISSING_OR_INVALID", `respond() params: ${r}`);
        throw new Error(o);
      }
      const { topic: i, response: s } = r;
      try {
        await this.isValidSessionTopic(i);
      } catch (o) {
        throw (n = r == null ? void 0 : r.response) != null && n.id && this.cleanupAfterResponse(r), o;
      }
      if (!WW(s)) {
        const { message: o } = ft("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(s)}`);
        throw new Error(o);
      }
    }, this.isValidPing = async (r) => {
      if (!mi(r)) {
        const { message: i } = ft("MISSING_OR_INVALID", `ping() params: ${r}`);
        throw new Error(i);
      }
      const { topic: n } = r;
      await this.isValidSessionOrPairingTopic(n);
    }, this.isValidEmit = async (r) => {
      if (!mi(r)) {
        const { message: a } = ft("MISSING_OR_INVALID", `emit() params: ${r}`);
        throw new Error(a);
      }
      const { topic: n, event: i, chainId: s } = r;
      await this.isValidSessionTopic(n);
      const { namespaces: o } = this.client.session.get(n);
      if (!b3(o, s)) {
        const { message: a } = ft("MISSING_OR_INVALID", `emit() chainId: ${s}`);
        throw new Error(a);
      }
      if (!HW(i)) {
        const { message: a } = ft("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
        throw new Error(a);
      }
      if (!VW(o, s, i.name)) {
        const { message: a } = ft("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
        throw new Error(a);
      }
    }, this.isValidDisconnect = async (r) => {
      if (!mi(r)) {
        const { message: i } = ft("MISSING_OR_INVALID", `disconnect() params: ${r}`);
        throw new Error(i);
      }
      const { topic: n } = r;
      await this.isValidSessionOrPairingTopic(n);
    }, this.isValidAuthenticate = (r) => {
      const { chains: n, uri: i, domain: s, nonce: o } = r;
      if (!Array.isArray(n) || n.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!dn(i, !1)) throw new Error("uri is required parameter");
      if (!dn(s, !1)) throw new Error("domain is required parameter");
      if (!dn(o, !1)) throw new Error("nonce is required parameter");
      if ([...new Set(n.map((u) => _u(u).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: a } = _u(n[0]);
      if (a !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }, this.getVerifyContext = async (r) => {
      const { attestationId: n, hash: i, encryptedId: s, metadata: o, transportType: a } = r, u = { verified: { verifyUrl: o.verifyUrl || Xf, validation: "UNKNOWN", origin: o.url || "" } };
      try {
        if (a === zr.link_mode) {
          const d = this.getAppLinkIfEnabled(o, a);
          return u.verified.validation = d && new URL(d).origin === new URL(o.url).origin ? "VALID" : "INVALID", u;
        }
        const l = await this.client.core.verify.resolve({ attestationId: n, hash: i, encryptedId: s, verifyUrl: o.verifyUrl });
        l && (u.verified.origin = l.origin, u.verified.isScam = l.isScam, u.verified.validation = l.origin === new URL(o.url).origin ? "VALID" : "INVALID");
      } catch (l) {
        this.client.logger.warn(l);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(u)}`), u;
    }, this.validateSessionProps = (r, n) => {
      Object.values(r).forEach((i) => {
        if (!dn(i, !1)) {
          const { message: s } = ft("MISSING_OR_INVALID", `${n} must be in Record<string, string> format. Received: ${JSON.stringify(i)}`);
          throw new Error(s);
        }
      });
    }, this.getPendingAuthRequest = (r) => {
      const n = this.client.auth.requests.get(r);
      return typeof n == "object" ? n : void 0;
    }, this.addToRecentlyDeleted = (r, n) => {
      if (this.recentlyDeletedMap.set(r, n), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let i = 0;
        const s = this.recentlyDeletedLimit / 2;
        for (const o of this.recentlyDeletedMap.keys()) {
          if (i++ >= s) break;
          this.recentlyDeletedMap.delete(o);
        }
      }
    }, this.checkRecentlyDeleted = (r) => {
      const n = this.recentlyDeletedMap.get(r);
      if (n) {
        const { message: i } = ft("MISSING_OR_INVALID", `Record was recently deleted - ${n}: ${r}`);
        throw new Error(i);
      }
    }, this.isLinkModeEnabled = (r, n) => {
      var i, s, o, a, u, l, d, p, w;
      return !r || n !== zr.link_mode ? !1 : ((s = (i = this.client.metadata) == null ? void 0 : i.redirect) == null ? void 0 : s.linkMode) === !0 && ((a = (o = this.client.metadata) == null ? void 0 : o.redirect) == null ? void 0 : a.universal) !== void 0 && ((l = (u = this.client.metadata) == null ? void 0 : u.redirect) == null ? void 0 : l.universal) !== "" && ((d = r == null ? void 0 : r.redirect) == null ? void 0 : d.universal) !== void 0 && ((p = r == null ? void 0 : r.redirect) == null ? void 0 : p.universal) !== "" && ((w = r == null ? void 0 : r.redirect) == null ? void 0 : w.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(r.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }, this.getAppLinkIfEnabled = (r, n) => {
      var i;
      return this.isLinkModeEnabled(r, n) ? (i = r == null ? void 0 : r.redirect) == null ? void 0 : i.universal : void 0;
    }, this.handleLinkModeMessage = ({ url: r }) => {
      if (!r || !r.includes("wc_ev") || !r.includes("topic")) return;
      const n = t3(r, "topic") || "", i = decodeURIComponent(t3(r, "wc_ev") || ""), s = this.client.session.keys.includes(n);
      s && this.client.session.update(n, { transportType: zr.link_mode }), this.client.core.dispatchEnvelope({ topic: n, message: i, sessionExists: s });
    }, this.registerLinkModeListeners = async () => {
      var r;
      if (yb() || Yu() && (r = this.client.metadata.redirect) != null && r.linkMode) {
        const n = global == null ? void 0 : global.Linking;
        if (typeof n < "u") {
          n.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const i = await n.getInitialURL();
          i && setTimeout(() => {
            this.handleLinkModeMessage({ url: i });
          }, 50);
        }
      }
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(ai.message, (e) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(e) : this.onRelayMessage(e);
    });
  }
  async onRelayMessage(e) {
    const { topic: r, message: n, attestation: i, transportType: s } = e, { publicKey: o } = this.client.auth.authKeys.keys.includes(zd) ? this.client.auth.authKeys.get(zd) : { publicKey: void 0 }, a = await this.client.core.crypto.decode(r, n, { receiverPublicKey: o, encoding: s === zr.link_mode ? Df : pa });
    try {
      Ab(a) ? (this.client.core.history.set(r, a), this.onRelayEventRequest({ topic: r, payload: a, attestation: i, transportType: s, encryptedId: Ao(n) })) : bp(a) ? (await this.client.core.history.resolve(a), await this.onRelayEventResponse({ topic: r, payload: a, transportType: s }), this.client.core.history.delete(r, a.id)) : this.onRelayEventUnknownPayload({ topic: r, payload: a, transportType: s });
    } catch (u) {
      this.client.logger.error(u);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(Zi.expired, async (e) => {
      const { topic: r, id: n } = hE(e.target);
      if (n && this.client.pendingRequest.keys.includes(n)) return await this.deletePendingSessionRequest(n, ft("EXPIRED"), !0);
      if (n && this.client.auth.requests.keys.includes(n)) return await this.deletePendingAuthRequest(n, ft("EXPIRED"), !0);
      r ? this.client.session.keys.includes(r) && (await this.deleteSession({ topic: r, expirerHasDeleted: !0 }), this.client.events.emit("session_expire", { topic: r })) : n && (await this.deleteProposal(n, !0), this.client.events.emit("proposal_expire", { id: n }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(ic.create, (e) => this.onPairingCreated(e)), this.client.core.pairing.events.on(ic.delete, (e) => {
      this.addToRecentlyDeleted(e.topic, "pairing");
    });
  }
  isValidPairingTopic(e) {
    if (!dn(e, !1)) {
      const { message: r } = ft("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
      throw new Error(r);
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: r } = ft("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (fa(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: r } = ft("EXPIRED", `pairing topic: ${e}`);
      throw new Error(r);
    }
  }
  async isValidSessionTopic(e) {
    if (!dn(e, !1)) {
      const { message: r } = ft("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
      throw new Error(r);
    }
    if (this.checkRecentlyDeleted(e), !this.client.session.keys.includes(e)) {
      const { message: r } = ft("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (fa(this.client.session.get(e).expiry)) {
      await this.deleteSession({ topic: e });
      const { message: r } = ft("EXPIRED", `session topic: ${e}`);
      throw new Error(r);
    }
    if (!this.client.core.crypto.keychain.has(e)) {
      const { message: r } = ft("MISSING_OR_INVALID", `session topic does not exist in keychain: ${e}`);
      throw await this.deleteSession({ topic: e }), new Error(r);
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if (this.checkRecentlyDeleted(e), this.client.session.keys.includes(e)) await this.isValidSessionTopic(e);
    else if (this.client.core.pairing.pairings.keys.includes(e)) this.isValidPairingTopic(e);
    else if (dn(e, !1)) {
      const { message: r } = ft("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
      throw new Error(r);
    } else {
      const { message: r } = ft("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
      throw new Error(r);
    }
  }
  async isValidProposalId(e) {
    if (!UW(e)) {
      const { message: r } = ft("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
      throw new Error(r);
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: r } = ft("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (fa(this.client.proposal.get(e).expiryTimestamp)) {
      await this.deleteProposal(e);
      const { message: r } = ft("EXPIRED", `proposal id: ${e}`);
      throw new Error(r);
    }
  }
}
class SG extends Oc {
  constructor(e, r) {
    super(e, r, cG, Mb), this.core = e, this.logger = r;
  }
}
let AG = class extends Oc {
  constructor(e, r) {
    super(e, r, uG, Mb), this.core = e, this.logger = r;
  }
};
class PG extends Oc {
  constructor(e, r) {
    super(e, r, lG, Mb, (n) => n.id), this.core = e, this.logger = r;
  }
}
class MG extends Oc {
  constructor(e, r) {
    super(e, r, gG, wp, () => zd), this.core = e, this.logger = r;
  }
}
class IG extends Oc {
  constructor(e, r) {
    super(e, r, mG, wp), this.core = e, this.logger = r;
  }
}
class CG extends Oc {
  constructor(e, r) {
    super(e, r, vG, wp, (n) => n.id), this.core = e, this.logger = r;
  }
}
class TG {
  constructor(e, r) {
    this.core = e, this.logger = r, this.authKeys = new MG(this.core, this.logger), this.pairingTopics = new IG(this.core, this.logger), this.requests = new CG(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
}
class Ib extends F$ {
  constructor(e) {
    super(e), this.protocol = HE, this.version = KE, this.name = Tm.name, this.events = new is.EventEmitter(), this.on = (n, i) => this.events.on(n, i), this.once = (n, i) => this.events.once(n, i), this.off = (n, i) => this.events.off(n, i), this.removeListener = (n, i) => this.events.removeListener(n, i), this.removeAllListeners = (n) => this.events.removeAllListeners(n), this.connect = async (n) => {
      try {
        return await this.engine.connect(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.pair = async (n) => {
      try {
        return await this.engine.pair(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.approve = async (n) => {
      try {
        return await this.engine.approve(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.reject = async (n) => {
      try {
        return await this.engine.reject(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.update = async (n) => {
      try {
        return await this.engine.update(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.extend = async (n) => {
      try {
        return await this.engine.extend(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.request = async (n) => {
      try {
        return await this.engine.request(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.respond = async (n) => {
      try {
        return await this.engine.respond(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.ping = async (n) => {
      try {
        return await this.engine.ping(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.emit = async (n) => {
      try {
        return await this.engine.emit(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.disconnect = async (n) => {
      try {
        return await this.engine.disconnect(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.find = (n) => {
      try {
        return this.engine.find(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.authenticate = async (n, i) => {
      try {
        return await this.engine.authenticate(n, i);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.formatAuthMessage = (n) => {
      try {
        return this.engine.formatAuthMessage(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.approveSessionAuthenticate = async (n) => {
      try {
        return await this.engine.approveSessionAuthenticate(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.rejectSessionAuthenticate = async (n) => {
      try {
        return await this.engine.rejectSessionAuthenticate(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.name = (e == null ? void 0 : e.name) || Tm.name, this.metadata = (e == null ? void 0 : e.metadata) || aE(), this.signConfig = e == null ? void 0 : e.signConfig;
    const r = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : Xl(X0({ level: (e == null ? void 0 : e.logger) || Tm.logger }));
    this.core = (e == null ? void 0 : e.core) || new aG(e), this.logger = ui(r, this.name), this.session = new AG(this.core, this.logger), this.proposal = new SG(this.core, this.logger), this.pendingRequest = new PG(this.core, this.logger), this.engine = new EG(this), this.auth = new TG(this.core, this.logger);
  }
  static async init(e) {
    const r = new Ib(e);
    return await r.initialize(), r;
  }
  get context() {
    return Pi(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), this.engine.processRelayMessageCache();
    } catch (e) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(e.message), e;
    }
  }
}
var S0 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
S0.exports;
(function(t, e) {
  (function() {
    var r, n = "4.17.21", i = 200, s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", o = "Expected a function", a = "Invalid `variable` option passed into `_.template`", u = "__lodash_hash_undefined__", l = 500, d = "__lodash_placeholder__", p = 1, w = 2, _ = 4, P = 1, O = 2, L = 1, B = 2, k = 4, q = 8, U = 16, V = 32, Q = 64, R = 128, K = 256, ge = 512, Ee = 30, Y = "...", A = 800, m = 16, f = 1, g = 2, b = 3, x = 1 / 0, E = 9007199254740991, S = 17976931348623157e292, v = NaN, M = 4294967295, I = M - 1, F = M >>> 1, ce = [
      ["ary", R],
      ["bind", L],
      ["bindKey", B],
      ["curry", q],
      ["curryRight", U],
      ["flip", ge],
      ["partial", V],
      ["partialRight", Q],
      ["rearg", K]
    ], D = "[object Arguments]", oe = "[object Array]", Z = "[object AsyncFunction]", J = "[object Boolean]", ee = "[object Date]", T = "[object DOMException]", X = "[object Error]", re = "[object Function]", pe = "[object GeneratorFunction]", ie = "[object Map]", ue = "[object Number]", ve = "[object Null]", Pe = "[object Object]", De = "[object Promise]", Ce = "[object Proxy]", $e = "[object RegExp]", Me = "[object Set]", Ne = "[object String]", Ke = "[object Symbol]", Le = "[object Undefined]", qe = "[object WeakMap]", ze = "[object WeakSet]", _e = "[object ArrayBuffer]", Ze = "[object DataView]", at = "[object Float32Array]", ke = "[object Float64Array]", Qe = "[object Int8Array]", tt = "[object Int16Array]", Ye = "[object Int32Array]", dt = "[object Uint8Array]", lt = "[object Uint8ClampedArray]", ct = "[object Uint16Array]", qt = "[object Uint32Array]", Jt = /\b__p \+= '';/g, Et = /\b(__p \+=) '' \+/g, er = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Xt = /&(?:amp|lt|gt|quot|#39);/g, Dt = /[&<>"']/g, kt = RegExp(Xt.source), Ct = RegExp(Dt.source), mt = /<%-([\s\S]+?)%>/g, Rt = /<%([\s\S]+?)%>/g, Nt = /<%=([\s\S]+?)%>/g, bt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, $t = /^\w*$/, Ft = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, rt = /[\\^$.*+?()[\]{}|]/g, Bt = RegExp(rt.source), $ = /^\s+/, z = /\s/, H = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, C = /\{\n\/\* \[wrapped with (.+)\] \*/, G = /,? & /, j = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, se = /[()=,{}\[\]\/\s]/, de = /\\(\\)?/g, xe = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Te = /\w*$/, Re = /^[-+]0x[0-9a-f]+$/i, nt = /^0b[01]+$/i, je = /^\[object .+?Constructor\]$/, pt = /^0o[0-7]+$/i, it = /^(?:0|[1-9]\d*)$/, et = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, St = /($^)/, Tt = /['\n\r\u2028\u2029\\]/g, At = "\\ud800-\\udfff", _t = "\\u0300-\\u036f", ht = "\\ufe20-\\ufe2f", xt = "\\u20d0-\\u20ff", st = _t + ht + xt, yt = "\\u2700-\\u27bf", ut = "a-z\\xdf-\\xf6\\xf8-\\xff", ot = "\\xac\\xb1\\xd7\\xf7", Se = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Ae = "\\u2000-\\u206f", Ve = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Fe = "A-Z\\xc0-\\xd6\\xd8-\\xde", Ue = "\\ufe0e\\ufe0f", Je = ot + Se + Ae + Ve, Lt = "['’]", zt = "[" + At + "]", Zt = "[" + Je + "]", Wt = "[" + st + "]", he = "\\d+", rr = "[" + yt + "]", dr = "[" + ut + "]", pr = "[^" + At + Je + he + yt + ut + Fe + "]", Qt = "\\ud83c[\\udffb-\\udfff]", gr = "(?:" + Wt + "|" + Qt + ")", lr = "[^" + At + "]", Rr = "(?:\\ud83c[\\udde6-\\uddff]){2}", mr = "[\\ud800-\\udbff][\\udc00-\\udfff]", wr = "[" + Fe + "]", $r = "\\u200d", Br = "(?:" + dr + "|" + pr + ")", Ir = "(?:" + wr + "|" + pr + ")", nn = "(?:" + Lt + "(?:d|ll|m|re|s|t|ve))?", sn = "(?:" + Lt + "(?:D|LL|M|RE|S|T|VE))?", on = gr + "?", wh = "[" + Ue + "]?", Hp = "(?:" + $r + "(?:" + [lr, Rr, mr].join("|") + ")" + wh + on + ")*", ao = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", xh = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", _h = wh + on + Hp, $c = "(?:" + [rr, Rr, mr].join("|") + ")" + _h, Kp = "(?:" + [lr + Wt + "?", Wt, Rr, mr, zt].join("|") + ")", sf = RegExp(Lt, "g"), Vp = RegExp(Wt, "g"), Bc = RegExp(Qt + "(?=" + Qt + ")|" + Kp + _h, "g"), Eh = RegExp([
      wr + "?" + dr + "+" + nn + "(?=" + [Zt, wr, "$"].join("|") + ")",
      Ir + "+" + sn + "(?=" + [Zt, wr + Br, "$"].join("|") + ")",
      wr + "?" + Br + "+" + nn,
      wr + "+" + sn,
      xh,
      ao,
      he,
      $c
    ].join("|"), "g"), Sh = RegExp("[" + $r + At + st + Ue + "]"), Ba = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Ah = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], Gp = -1, Fr = {};
    Fr[at] = Fr[ke] = Fr[Qe] = Fr[tt] = Fr[Ye] = Fr[dt] = Fr[lt] = Fr[ct] = Fr[qt] = !0, Fr[D] = Fr[oe] = Fr[_e] = Fr[J] = Fr[Ze] = Fr[ee] = Fr[X] = Fr[re] = Fr[ie] = Fr[ue] = Fr[Pe] = Fr[$e] = Fr[Me] = Fr[Ne] = Fr[qe] = !1;
    var Dr = {};
    Dr[D] = Dr[oe] = Dr[_e] = Dr[Ze] = Dr[J] = Dr[ee] = Dr[at] = Dr[ke] = Dr[Qe] = Dr[tt] = Dr[Ye] = Dr[ie] = Dr[ue] = Dr[Pe] = Dr[$e] = Dr[Me] = Dr[Ne] = Dr[Ke] = Dr[dt] = Dr[lt] = Dr[ct] = Dr[qt] = !0, Dr[X] = Dr[re] = Dr[qe] = !1;
    var ae = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, ye = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, Ge = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, Pt = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, jr = parseFloat, nr = parseInt, Kr = typeof gn == "object" && gn && gn.Object === Object && gn, vn = typeof self == "object" && self && self.Object === Object && self, Er = Kr || vn || Function("return this")(), Ur = e && !e.nodeType && e, an = Ur && !0 && t && !t.nodeType && t, fi = an && an.exports === Ur, bn = fi && Kr.process, Vr = function() {
      try {
        var be = an && an.require && an.require("util").types;
        return be || bn && bn.binding && bn.binding("util");
      } catch {
      }
    }(), ri = Vr && Vr.isArrayBuffer, hs = Vr && Vr.isDate, Ui = Vr && Vr.isMap, Ds = Vr && Vr.isRegExp, of = Vr && Vr.isSet, Fa = Vr && Vr.isTypedArray;
    function Pn(be, Be, Ie) {
      switch (Ie.length) {
        case 0:
          return be.call(Be);
        case 1:
          return be.call(Be, Ie[0]);
        case 2:
          return be.call(Be, Ie[0], Ie[1]);
        case 3:
          return be.call(Be, Ie[0], Ie[1], Ie[2]);
      }
      return be.apply(Be, Ie);
    }
    function RA(be, Be, Ie, It) {
      for (var tr = -1, Mr = be == null ? 0 : be.length; ++tr < Mr; ) {
        var _n = be[tr];
        Be(It, _n, Ie(_n), be);
      }
      return It;
    }
    function qi(be, Be) {
      for (var Ie = -1, It = be == null ? 0 : be.length; ++Ie < It && Be(be[Ie], Ie, be) !== !1; )
        ;
      return be;
    }
    function DA(be, Be) {
      for (var Ie = be == null ? 0 : be.length; Ie-- && Be(be[Ie], Ie, be) !== !1; )
        ;
      return be;
    }
    function Cy(be, Be) {
      for (var Ie = -1, It = be == null ? 0 : be.length; ++Ie < It; )
        if (!Be(be[Ie], Ie, be))
          return !1;
      return !0;
    }
    function Ko(be, Be) {
      for (var Ie = -1, It = be == null ? 0 : be.length, tr = 0, Mr = []; ++Ie < It; ) {
        var _n = be[Ie];
        Be(_n, Ie, be) && (Mr[tr++] = _n);
      }
      return Mr;
    }
    function Ph(be, Be) {
      var Ie = be == null ? 0 : be.length;
      return !!Ie && Fc(be, Be, 0) > -1;
    }
    function Yp(be, Be, Ie) {
      for (var It = -1, tr = be == null ? 0 : be.length; ++It < tr; )
        if (Ie(Be, be[It]))
          return !0;
      return !1;
    }
    function Xr(be, Be) {
      for (var Ie = -1, It = be == null ? 0 : be.length, tr = Array(It); ++Ie < It; )
        tr[Ie] = Be(be[Ie], Ie, be);
      return tr;
    }
    function Vo(be, Be) {
      for (var Ie = -1, It = Be.length, tr = be.length; ++Ie < It; )
        be[tr + Ie] = Be[Ie];
      return be;
    }
    function Jp(be, Be, Ie, It) {
      var tr = -1, Mr = be == null ? 0 : be.length;
      for (It && Mr && (Ie = be[++tr]); ++tr < Mr; )
        Ie = Be(Ie, be[tr], tr, be);
      return Ie;
    }
    function OA(be, Be, Ie, It) {
      var tr = be == null ? 0 : be.length;
      for (It && tr && (Ie = be[--tr]); tr--; )
        Ie = Be(Ie, be[tr], tr, be);
      return Ie;
    }
    function Xp(be, Be) {
      for (var Ie = -1, It = be == null ? 0 : be.length; ++Ie < It; )
        if (Be(be[Ie], Ie, be))
          return !0;
      return !1;
    }
    var NA = Zp("length");
    function LA(be) {
      return be.split("");
    }
    function kA(be) {
      return be.match(j) || [];
    }
    function Ty(be, Be, Ie) {
      var It;
      return Ie(be, function(tr, Mr, _n) {
        if (Be(tr, Mr, _n))
          return It = Mr, !1;
      }), It;
    }
    function Mh(be, Be, Ie, It) {
      for (var tr = be.length, Mr = Ie + (It ? 1 : -1); It ? Mr-- : ++Mr < tr; )
        if (Be(be[Mr], Mr, be))
          return Mr;
      return -1;
    }
    function Fc(be, Be, Ie) {
      return Be === Be ? GA(be, Be, Ie) : Mh(be, Ry, Ie);
    }
    function $A(be, Be, Ie, It) {
      for (var tr = Ie - 1, Mr = be.length; ++tr < Mr; )
        if (It(be[tr], Be))
          return tr;
      return -1;
    }
    function Ry(be) {
      return be !== be;
    }
    function Dy(be, Be) {
      var Ie = be == null ? 0 : be.length;
      return Ie ? eg(be, Be) / Ie : v;
    }
    function Zp(be) {
      return function(Be) {
        return Be == null ? r : Be[be];
      };
    }
    function Qp(be) {
      return function(Be) {
        return be == null ? r : be[Be];
      };
    }
    function Oy(be, Be, Ie, It, tr) {
      return tr(be, function(Mr, _n, qr) {
        Ie = It ? (It = !1, Mr) : Be(Ie, Mr, _n, qr);
      }), Ie;
    }
    function BA(be, Be) {
      var Ie = be.length;
      for (be.sort(Be); Ie--; )
        be[Ie] = be[Ie].value;
      return be;
    }
    function eg(be, Be) {
      for (var Ie, It = -1, tr = be.length; ++It < tr; ) {
        var Mr = Be(be[It]);
        Mr !== r && (Ie = Ie === r ? Mr : Ie + Mr);
      }
      return Ie;
    }
    function tg(be, Be) {
      for (var Ie = -1, It = Array(be); ++Ie < be; )
        It[Ie] = Be(Ie);
      return It;
    }
    function FA(be, Be) {
      return Xr(Be, function(Ie) {
        return [Ie, be[Ie]];
      });
    }
    function Ny(be) {
      return be && be.slice(0, By(be) + 1).replace($, "");
    }
    function Mi(be) {
      return function(Be) {
        return be(Be);
      };
    }
    function rg(be, Be) {
      return Xr(Be, function(Ie) {
        return be[Ie];
      });
    }
    function af(be, Be) {
      return be.has(Be);
    }
    function Ly(be, Be) {
      for (var Ie = -1, It = be.length; ++Ie < It && Fc(Be, be[Ie], 0) > -1; )
        ;
      return Ie;
    }
    function ky(be, Be) {
      for (var Ie = be.length; Ie-- && Fc(Be, be[Ie], 0) > -1; )
        ;
      return Ie;
    }
    function jA(be, Be) {
      for (var Ie = be.length, It = 0; Ie--; )
        be[Ie] === Be && ++It;
      return It;
    }
    var UA = Qp(ae), qA = Qp(ye);
    function zA(be) {
      return "\\" + Pt[be];
    }
    function WA(be, Be) {
      return be == null ? r : be[Be];
    }
    function jc(be) {
      return Sh.test(be);
    }
    function HA(be) {
      return Ba.test(be);
    }
    function KA(be) {
      for (var Be, Ie = []; !(Be = be.next()).done; )
        Ie.push(Be.value);
      return Ie;
    }
    function ng(be) {
      var Be = -1, Ie = Array(be.size);
      return be.forEach(function(It, tr) {
        Ie[++Be] = [tr, It];
      }), Ie;
    }
    function $y(be, Be) {
      return function(Ie) {
        return be(Be(Ie));
      };
    }
    function Go(be, Be) {
      for (var Ie = -1, It = be.length, tr = 0, Mr = []; ++Ie < It; ) {
        var _n = be[Ie];
        (_n === Be || _n === d) && (be[Ie] = d, Mr[tr++] = Ie);
      }
      return Mr;
    }
    function Ih(be) {
      var Be = -1, Ie = Array(be.size);
      return be.forEach(function(It) {
        Ie[++Be] = It;
      }), Ie;
    }
    function VA(be) {
      var Be = -1, Ie = Array(be.size);
      return be.forEach(function(It) {
        Ie[++Be] = [It, It];
      }), Ie;
    }
    function GA(be, Be, Ie) {
      for (var It = Ie - 1, tr = be.length; ++It < tr; )
        if (be[It] === Be)
          return It;
      return -1;
    }
    function YA(be, Be, Ie) {
      for (var It = Ie + 1; It--; )
        if (be[It] === Be)
          return It;
      return It;
    }
    function Uc(be) {
      return jc(be) ? XA(be) : NA(be);
    }
    function ds(be) {
      return jc(be) ? ZA(be) : LA(be);
    }
    function By(be) {
      for (var Be = be.length; Be-- && z.test(be.charAt(Be)); )
        ;
      return Be;
    }
    var JA = Qp(Ge);
    function XA(be) {
      for (var Be = Bc.lastIndex = 0; Bc.test(be); )
        ++Be;
      return Be;
    }
    function ZA(be) {
      return be.match(Bc) || [];
    }
    function QA(be) {
      return be.match(Eh) || [];
    }
    var eP = function be(Be) {
      Be = Be == null ? Er : qc.defaults(Er.Object(), Be, qc.pick(Er, Ah));
      var Ie = Be.Array, It = Be.Date, tr = Be.Error, Mr = Be.Function, _n = Be.Math, qr = Be.Object, ig = Be.RegExp, tP = Be.String, zi = Be.TypeError, Ch = Ie.prototype, rP = Mr.prototype, zc = qr.prototype, Th = Be["__core-js_shared__"], Rh = rP.toString, Tr = zc.hasOwnProperty, nP = 0, Fy = function() {
        var c = /[^.]+$/.exec(Th && Th.keys && Th.keys.IE_PROTO || "");
        return c ? "Symbol(src)_1." + c : "";
      }(), Dh = zc.toString, iP = Rh.call(qr), sP = Er._, oP = ig(
        "^" + Rh.call(Tr).replace(rt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Oh = fi ? Be.Buffer : r, Yo = Be.Symbol, Nh = Be.Uint8Array, jy = Oh ? Oh.allocUnsafe : r, Lh = $y(qr.getPrototypeOf, qr), Uy = qr.create, qy = zc.propertyIsEnumerable, kh = Ch.splice, zy = Yo ? Yo.isConcatSpreadable : r, cf = Yo ? Yo.iterator : r, ja = Yo ? Yo.toStringTag : r, $h = function() {
        try {
          var c = Ha(qr, "defineProperty");
          return c({}, "", {}), c;
        } catch {
        }
      }(), aP = Be.clearTimeout !== Er.clearTimeout && Be.clearTimeout, cP = It && It.now !== Er.Date.now && It.now, uP = Be.setTimeout !== Er.setTimeout && Be.setTimeout, Bh = _n.ceil, Fh = _n.floor, sg = qr.getOwnPropertySymbols, fP = Oh ? Oh.isBuffer : r, Wy = Be.isFinite, lP = Ch.join, hP = $y(qr.keys, qr), En = _n.max, Kn = _n.min, dP = It.now, pP = Be.parseInt, Hy = _n.random, gP = Ch.reverse, og = Ha(Be, "DataView"), uf = Ha(Be, "Map"), ag = Ha(Be, "Promise"), Wc = Ha(Be, "Set"), ff = Ha(Be, "WeakMap"), lf = Ha(qr, "create"), jh = ff && new ff(), Hc = {}, mP = Ka(og), vP = Ka(uf), bP = Ka(ag), yP = Ka(Wc), wP = Ka(ff), Uh = Yo ? Yo.prototype : r, hf = Uh ? Uh.valueOf : r, Ky = Uh ? Uh.toString : r;
      function te(c) {
        if (en(c) && !ir(c) && !(c instanceof xr)) {
          if (c instanceof Wi)
            return c;
          if (Tr.call(c, "__wrapped__"))
            return Vw(c);
        }
        return new Wi(c);
      }
      var Kc = /* @__PURE__ */ function() {
        function c() {
        }
        return function(h) {
          if (!Zr(h))
            return {};
          if (Uy)
            return Uy(h);
          c.prototype = h;
          var y = new c();
          return c.prototype = r, y;
        };
      }();
      function qh() {
      }
      function Wi(c, h) {
        this.__wrapped__ = c, this.__actions__ = [], this.__chain__ = !!h, this.__index__ = 0, this.__values__ = r;
      }
      te.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: mt,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: Rt,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: Nt,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: te
        }
      }, te.prototype = qh.prototype, te.prototype.constructor = te, Wi.prototype = Kc(qh.prototype), Wi.prototype.constructor = Wi;
      function xr(c) {
        this.__wrapped__ = c, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = M, this.__views__ = [];
      }
      function xP() {
        var c = new xr(this.__wrapped__);
        return c.__actions__ = li(this.__actions__), c.__dir__ = this.__dir__, c.__filtered__ = this.__filtered__, c.__iteratees__ = li(this.__iteratees__), c.__takeCount__ = this.__takeCount__, c.__views__ = li(this.__views__), c;
      }
      function _P() {
        if (this.__filtered__) {
          var c = new xr(this);
          c.__dir__ = -1, c.__filtered__ = !0;
        } else
          c = this.clone(), c.__dir__ *= -1;
        return c;
      }
      function EP() {
        var c = this.__wrapped__.value(), h = this.__dir__, y = ir(c), N = h < 0, W = y ? c.length : 0, ne = LM(0, W, this.__views__), fe = ne.start, me = ne.end, we = me - fe, We = N ? me : fe - 1, He = this.__iteratees__, Xe = He.length, wt = 0, Ot = Kn(we, this.__takeCount__);
        if (!y || !N && W == we && Ot == we)
          return mw(c, this.__actions__);
        var Ht = [];
        e:
          for (; we-- && wt < Ot; ) {
            We += h;
            for (var fr = -1, Kt = c[We]; ++fr < Xe; ) {
              var br = He[fr], Sr = br.iteratee, Ti = br.type, si = Sr(Kt);
              if (Ti == g)
                Kt = si;
              else if (!si) {
                if (Ti == f)
                  continue e;
                break e;
              }
            }
            Ht[wt++] = Kt;
          }
        return Ht;
      }
      xr.prototype = Kc(qh.prototype), xr.prototype.constructor = xr;
      function Ua(c) {
        var h = -1, y = c == null ? 0 : c.length;
        for (this.clear(); ++h < y; ) {
          var N = c[h];
          this.set(N[0], N[1]);
        }
      }
      function SP() {
        this.__data__ = lf ? lf(null) : {}, this.size = 0;
      }
      function AP(c) {
        var h = this.has(c) && delete this.__data__[c];
        return this.size -= h ? 1 : 0, h;
      }
      function PP(c) {
        var h = this.__data__;
        if (lf) {
          var y = h[c];
          return y === u ? r : y;
        }
        return Tr.call(h, c) ? h[c] : r;
      }
      function MP(c) {
        var h = this.__data__;
        return lf ? h[c] !== r : Tr.call(h, c);
      }
      function IP(c, h) {
        var y = this.__data__;
        return this.size += this.has(c) ? 0 : 1, y[c] = lf && h === r ? u : h, this;
      }
      Ua.prototype.clear = SP, Ua.prototype.delete = AP, Ua.prototype.get = PP, Ua.prototype.has = MP, Ua.prototype.set = IP;
      function co(c) {
        var h = -1, y = c == null ? 0 : c.length;
        for (this.clear(); ++h < y; ) {
          var N = c[h];
          this.set(N[0], N[1]);
        }
      }
      function CP() {
        this.__data__ = [], this.size = 0;
      }
      function TP(c) {
        var h = this.__data__, y = zh(h, c);
        if (y < 0)
          return !1;
        var N = h.length - 1;
        return y == N ? h.pop() : kh.call(h, y, 1), --this.size, !0;
      }
      function RP(c) {
        var h = this.__data__, y = zh(h, c);
        return y < 0 ? r : h[y][1];
      }
      function DP(c) {
        return zh(this.__data__, c) > -1;
      }
      function OP(c, h) {
        var y = this.__data__, N = zh(y, c);
        return N < 0 ? (++this.size, y.push([c, h])) : y[N][1] = h, this;
      }
      co.prototype.clear = CP, co.prototype.delete = TP, co.prototype.get = RP, co.prototype.has = DP, co.prototype.set = OP;
      function uo(c) {
        var h = -1, y = c == null ? 0 : c.length;
        for (this.clear(); ++h < y; ) {
          var N = c[h];
          this.set(N[0], N[1]);
        }
      }
      function NP() {
        this.size = 0, this.__data__ = {
          hash: new Ua(),
          map: new (uf || co)(),
          string: new Ua()
        };
      }
      function LP(c) {
        var h = td(this, c).delete(c);
        return this.size -= h ? 1 : 0, h;
      }
      function kP(c) {
        return td(this, c).get(c);
      }
      function $P(c) {
        return td(this, c).has(c);
      }
      function BP(c, h) {
        var y = td(this, c), N = y.size;
        return y.set(c, h), this.size += y.size == N ? 0 : 1, this;
      }
      uo.prototype.clear = NP, uo.prototype.delete = LP, uo.prototype.get = kP, uo.prototype.has = $P, uo.prototype.set = BP;
      function qa(c) {
        var h = -1, y = c == null ? 0 : c.length;
        for (this.__data__ = new uo(); ++h < y; )
          this.add(c[h]);
      }
      function FP(c) {
        return this.__data__.set(c, u), this;
      }
      function jP(c) {
        return this.__data__.has(c);
      }
      qa.prototype.add = qa.prototype.push = FP, qa.prototype.has = jP;
      function ps(c) {
        var h = this.__data__ = new co(c);
        this.size = h.size;
      }
      function UP() {
        this.__data__ = new co(), this.size = 0;
      }
      function qP(c) {
        var h = this.__data__, y = h.delete(c);
        return this.size = h.size, y;
      }
      function zP(c) {
        return this.__data__.get(c);
      }
      function WP(c) {
        return this.__data__.has(c);
      }
      function HP(c, h) {
        var y = this.__data__;
        if (y instanceof co) {
          var N = y.__data__;
          if (!uf || N.length < i - 1)
            return N.push([c, h]), this.size = ++y.size, this;
          y = this.__data__ = new uo(N);
        }
        return y.set(c, h), this.size = y.size, this;
      }
      ps.prototype.clear = UP, ps.prototype.delete = qP, ps.prototype.get = zP, ps.prototype.has = WP, ps.prototype.set = HP;
      function Vy(c, h) {
        var y = ir(c), N = !y && Va(c), W = !y && !N && ea(c), ne = !y && !N && !W && Jc(c), fe = y || N || W || ne, me = fe ? tg(c.length, tP) : [], we = me.length;
        for (var We in c)
          (h || Tr.call(c, We)) && !(fe && // Safari 9 has enumerable `arguments.length` in strict mode.
          (We == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          W && (We == "offset" || We == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          ne && (We == "buffer" || We == "byteLength" || We == "byteOffset") || // Skip index properties.
          po(We, we))) && me.push(We);
        return me;
      }
      function Gy(c) {
        var h = c.length;
        return h ? c[bg(0, h - 1)] : r;
      }
      function KP(c, h) {
        return rd(li(c), za(h, 0, c.length));
      }
      function VP(c) {
        return rd(li(c));
      }
      function cg(c, h, y) {
        (y !== r && !gs(c[h], y) || y === r && !(h in c)) && fo(c, h, y);
      }
      function df(c, h, y) {
        var N = c[h];
        (!(Tr.call(c, h) && gs(N, y)) || y === r && !(h in c)) && fo(c, h, y);
      }
      function zh(c, h) {
        for (var y = c.length; y--; )
          if (gs(c[y][0], h))
            return y;
        return -1;
      }
      function GP(c, h, y, N) {
        return Jo(c, function(W, ne, fe) {
          h(N, W, y(W), fe);
        }), N;
      }
      function Yy(c, h) {
        return c && Ns(h, Mn(h), c);
      }
      function YP(c, h) {
        return c && Ns(h, di(h), c);
      }
      function fo(c, h, y) {
        h == "__proto__" && $h ? $h(c, h, {
          configurable: !0,
          enumerable: !0,
          value: y,
          writable: !0
        }) : c[h] = y;
      }
      function ug(c, h) {
        for (var y = -1, N = h.length, W = Ie(N), ne = c == null; ++y < N; )
          W[y] = ne ? r : zg(c, h[y]);
        return W;
      }
      function za(c, h, y) {
        return c === c && (y !== r && (c = c <= y ? c : y), h !== r && (c = c >= h ? c : h)), c;
      }
      function Hi(c, h, y, N, W, ne) {
        var fe, me = h & p, we = h & w, We = h & _;
        if (y && (fe = W ? y(c, N, W, ne) : y(c)), fe !== r)
          return fe;
        if (!Zr(c))
          return c;
        var He = ir(c);
        if (He) {
          if (fe = $M(c), !me)
            return li(c, fe);
        } else {
          var Xe = Vn(c), wt = Xe == re || Xe == pe;
          if (ea(c))
            return yw(c, me);
          if (Xe == Pe || Xe == D || wt && !W) {
            if (fe = we || wt ? {} : Bw(c), !me)
              return we ? PM(c, YP(fe, c)) : AM(c, Yy(fe, c));
          } else {
            if (!Dr[Xe])
              return W ? c : {};
            fe = BM(c, Xe, me);
          }
        }
        ne || (ne = new ps());
        var Ot = ne.get(c);
        if (Ot)
          return Ot;
        ne.set(c, fe), d2(c) ? c.forEach(function(Kt) {
          fe.add(Hi(Kt, h, y, Kt, c, ne));
        }) : l2(c) && c.forEach(function(Kt, br) {
          fe.set(br, Hi(Kt, h, y, br, c, ne));
        });
        var Ht = We ? we ? Cg : Ig : we ? di : Mn, fr = He ? r : Ht(c);
        return qi(fr || c, function(Kt, br) {
          fr && (br = Kt, Kt = c[br]), df(fe, br, Hi(Kt, h, y, br, c, ne));
        }), fe;
      }
      function JP(c) {
        var h = Mn(c);
        return function(y) {
          return Jy(y, c, h);
        };
      }
      function Jy(c, h, y) {
        var N = y.length;
        if (c == null)
          return !N;
        for (c = qr(c); N--; ) {
          var W = y[N], ne = h[W], fe = c[W];
          if (fe === r && !(W in c) || !ne(fe))
            return !1;
        }
        return !0;
      }
      function Xy(c, h, y) {
        if (typeof c != "function")
          throw new zi(o);
        return wf(function() {
          c.apply(r, y);
        }, h);
      }
      function pf(c, h, y, N) {
        var W = -1, ne = Ph, fe = !0, me = c.length, we = [], We = h.length;
        if (!me)
          return we;
        y && (h = Xr(h, Mi(y))), N ? (ne = Yp, fe = !1) : h.length >= i && (ne = af, fe = !1, h = new qa(h));
        e:
          for (; ++W < me; ) {
            var He = c[W], Xe = y == null ? He : y(He);
            if (He = N || He !== 0 ? He : 0, fe && Xe === Xe) {
              for (var wt = We; wt--; )
                if (h[wt] === Xe)
                  continue e;
              we.push(He);
            } else ne(h, Xe, N) || we.push(He);
          }
        return we;
      }
      var Jo = Sw(Os), Zy = Sw(lg, !0);
      function XP(c, h) {
        var y = !0;
        return Jo(c, function(N, W, ne) {
          return y = !!h(N, W, ne), y;
        }), y;
      }
      function Wh(c, h, y) {
        for (var N = -1, W = c.length; ++N < W; ) {
          var ne = c[N], fe = h(ne);
          if (fe != null && (me === r ? fe === fe && !Ci(fe) : y(fe, me)))
            var me = fe, we = ne;
        }
        return we;
      }
      function ZP(c, h, y, N) {
        var W = c.length;
        for (y = cr(y), y < 0 && (y = -y > W ? 0 : W + y), N = N === r || N > W ? W : cr(N), N < 0 && (N += W), N = y > N ? 0 : g2(N); y < N; )
          c[y++] = h;
        return c;
      }
      function Qy(c, h) {
        var y = [];
        return Jo(c, function(N, W, ne) {
          h(N, W, ne) && y.push(N);
        }), y;
      }
      function Bn(c, h, y, N, W) {
        var ne = -1, fe = c.length;
        for (y || (y = jM), W || (W = []); ++ne < fe; ) {
          var me = c[ne];
          h > 0 && y(me) ? h > 1 ? Bn(me, h - 1, y, N, W) : Vo(W, me) : N || (W[W.length] = me);
        }
        return W;
      }
      var fg = Aw(), ew = Aw(!0);
      function Os(c, h) {
        return c && fg(c, h, Mn);
      }
      function lg(c, h) {
        return c && ew(c, h, Mn);
      }
      function Hh(c, h) {
        return Ko(h, function(y) {
          return go(c[y]);
        });
      }
      function Wa(c, h) {
        h = Zo(h, c);
        for (var y = 0, N = h.length; c != null && y < N; )
          c = c[Ls(h[y++])];
        return y && y == N ? c : r;
      }
      function tw(c, h, y) {
        var N = h(c);
        return ir(c) ? N : Vo(N, y(c));
      }
      function ni(c) {
        return c == null ? c === r ? Le : ve : ja && ja in qr(c) ? NM(c) : VM(c);
      }
      function hg(c, h) {
        return c > h;
      }
      function QP(c, h) {
        return c != null && Tr.call(c, h);
      }
      function eM(c, h) {
        return c != null && h in qr(c);
      }
      function tM(c, h, y) {
        return c >= Kn(h, y) && c < En(h, y);
      }
      function dg(c, h, y) {
        for (var N = y ? Yp : Ph, W = c[0].length, ne = c.length, fe = ne, me = Ie(ne), we = 1 / 0, We = []; fe--; ) {
          var He = c[fe];
          fe && h && (He = Xr(He, Mi(h))), we = Kn(He.length, we), me[fe] = !y && (h || W >= 120 && He.length >= 120) ? new qa(fe && He) : r;
        }
        He = c[0];
        var Xe = -1, wt = me[0];
        e:
          for (; ++Xe < W && We.length < we; ) {
            var Ot = He[Xe], Ht = h ? h(Ot) : Ot;
            if (Ot = y || Ot !== 0 ? Ot : 0, !(wt ? af(wt, Ht) : N(We, Ht, y))) {
              for (fe = ne; --fe; ) {
                var fr = me[fe];
                if (!(fr ? af(fr, Ht) : N(c[fe], Ht, y)))
                  continue e;
              }
              wt && wt.push(Ht), We.push(Ot);
            }
          }
        return We;
      }
      function rM(c, h, y, N) {
        return Os(c, function(W, ne, fe) {
          h(N, y(W), ne, fe);
        }), N;
      }
      function gf(c, h, y) {
        h = Zo(h, c), c = qw(c, h);
        var N = c == null ? c : c[Ls(Vi(h))];
        return N == null ? r : Pn(N, c, y);
      }
      function rw(c) {
        return en(c) && ni(c) == D;
      }
      function nM(c) {
        return en(c) && ni(c) == _e;
      }
      function iM(c) {
        return en(c) && ni(c) == ee;
      }
      function mf(c, h, y, N, W) {
        return c === h ? !0 : c == null || h == null || !en(c) && !en(h) ? c !== c && h !== h : sM(c, h, y, N, mf, W);
      }
      function sM(c, h, y, N, W, ne) {
        var fe = ir(c), me = ir(h), we = fe ? oe : Vn(c), We = me ? oe : Vn(h);
        we = we == D ? Pe : we, We = We == D ? Pe : We;
        var He = we == Pe, Xe = We == Pe, wt = we == We;
        if (wt && ea(c)) {
          if (!ea(h))
            return !1;
          fe = !0, He = !1;
        }
        if (wt && !He)
          return ne || (ne = new ps()), fe || Jc(c) ? Lw(c, h, y, N, W, ne) : DM(c, h, we, y, N, W, ne);
        if (!(y & P)) {
          var Ot = He && Tr.call(c, "__wrapped__"), Ht = Xe && Tr.call(h, "__wrapped__");
          if (Ot || Ht) {
            var fr = Ot ? c.value() : c, Kt = Ht ? h.value() : h;
            return ne || (ne = new ps()), W(fr, Kt, y, N, ne);
          }
        }
        return wt ? (ne || (ne = new ps()), OM(c, h, y, N, W, ne)) : !1;
      }
      function oM(c) {
        return en(c) && Vn(c) == ie;
      }
      function pg(c, h, y, N) {
        var W = y.length, ne = W, fe = !N;
        if (c == null)
          return !ne;
        for (c = qr(c); W--; ) {
          var me = y[W];
          if (fe && me[2] ? me[1] !== c[me[0]] : !(me[0] in c))
            return !1;
        }
        for (; ++W < ne; ) {
          me = y[W];
          var we = me[0], We = c[we], He = me[1];
          if (fe && me[2]) {
            if (We === r && !(we in c))
              return !1;
          } else {
            var Xe = new ps();
            if (N)
              var wt = N(We, He, we, c, h, Xe);
            if (!(wt === r ? mf(He, We, P | O, N, Xe) : wt))
              return !1;
          }
        }
        return !0;
      }
      function nw(c) {
        if (!Zr(c) || qM(c))
          return !1;
        var h = go(c) ? oP : je;
        return h.test(Ka(c));
      }
      function aM(c) {
        return en(c) && ni(c) == $e;
      }
      function cM(c) {
        return en(c) && Vn(c) == Me;
      }
      function uM(c) {
        return en(c) && cd(c.length) && !!Fr[ni(c)];
      }
      function iw(c) {
        return typeof c == "function" ? c : c == null ? pi : typeof c == "object" ? ir(c) ? aw(c[0], c[1]) : ow(c) : P2(c);
      }
      function gg(c) {
        if (!yf(c))
          return hP(c);
        var h = [];
        for (var y in qr(c))
          Tr.call(c, y) && y != "constructor" && h.push(y);
        return h;
      }
      function fM(c) {
        if (!Zr(c))
          return KM(c);
        var h = yf(c), y = [];
        for (var N in c)
          N == "constructor" && (h || !Tr.call(c, N)) || y.push(N);
        return y;
      }
      function mg(c, h) {
        return c < h;
      }
      function sw(c, h) {
        var y = -1, N = hi(c) ? Ie(c.length) : [];
        return Jo(c, function(W, ne, fe) {
          N[++y] = h(W, ne, fe);
        }), N;
      }
      function ow(c) {
        var h = Rg(c);
        return h.length == 1 && h[0][2] ? jw(h[0][0], h[0][1]) : function(y) {
          return y === c || pg(y, c, h);
        };
      }
      function aw(c, h) {
        return Og(c) && Fw(h) ? jw(Ls(c), h) : function(y) {
          var N = zg(y, c);
          return N === r && N === h ? Wg(y, c) : mf(h, N, P | O);
        };
      }
      function Kh(c, h, y, N, W) {
        c !== h && fg(h, function(ne, fe) {
          if (W || (W = new ps()), Zr(ne))
            lM(c, h, fe, y, Kh, N, W);
          else {
            var me = N ? N(Lg(c, fe), ne, fe + "", c, h, W) : r;
            me === r && (me = ne), cg(c, fe, me);
          }
        }, di);
      }
      function lM(c, h, y, N, W, ne, fe) {
        var me = Lg(c, y), we = Lg(h, y), We = fe.get(we);
        if (We) {
          cg(c, y, We);
          return;
        }
        var He = ne ? ne(me, we, y + "", c, h, fe) : r, Xe = He === r;
        if (Xe) {
          var wt = ir(we), Ot = !wt && ea(we), Ht = !wt && !Ot && Jc(we);
          He = we, wt || Ot || Ht ? ir(me) ? He = me : cn(me) ? He = li(me) : Ot ? (Xe = !1, He = yw(we, !0)) : Ht ? (Xe = !1, He = ww(we, !0)) : He = [] : xf(we) || Va(we) ? (He = me, Va(me) ? He = m2(me) : (!Zr(me) || go(me)) && (He = Bw(we))) : Xe = !1;
        }
        Xe && (fe.set(we, He), W(He, we, N, ne, fe), fe.delete(we)), cg(c, y, He);
      }
      function cw(c, h) {
        var y = c.length;
        if (y)
          return h += h < 0 ? y : 0, po(h, y) ? c[h] : r;
      }
      function uw(c, h, y) {
        h.length ? h = Xr(h, function(ne) {
          return ir(ne) ? function(fe) {
            return Wa(fe, ne.length === 1 ? ne[0] : ne);
          } : ne;
        }) : h = [pi];
        var N = -1;
        h = Xr(h, Mi(Ut()));
        var W = sw(c, function(ne, fe, me) {
          var we = Xr(h, function(We) {
            return We(ne);
          });
          return { criteria: we, index: ++N, value: ne };
        });
        return BA(W, function(ne, fe) {
          return SM(ne, fe, y);
        });
      }
      function hM(c, h) {
        return fw(c, h, function(y, N) {
          return Wg(c, N);
        });
      }
      function fw(c, h, y) {
        for (var N = -1, W = h.length, ne = {}; ++N < W; ) {
          var fe = h[N], me = Wa(c, fe);
          y(me, fe) && vf(ne, Zo(fe, c), me);
        }
        return ne;
      }
      function dM(c) {
        return function(h) {
          return Wa(h, c);
        };
      }
      function vg(c, h, y, N) {
        var W = N ? $A : Fc, ne = -1, fe = h.length, me = c;
        for (c === h && (h = li(h)), y && (me = Xr(c, Mi(y))); ++ne < fe; )
          for (var we = 0, We = h[ne], He = y ? y(We) : We; (we = W(me, He, we, N)) > -1; )
            me !== c && kh.call(me, we, 1), kh.call(c, we, 1);
        return c;
      }
      function lw(c, h) {
        for (var y = c ? h.length : 0, N = y - 1; y--; ) {
          var W = h[y];
          if (y == N || W !== ne) {
            var ne = W;
            po(W) ? kh.call(c, W, 1) : xg(c, W);
          }
        }
        return c;
      }
      function bg(c, h) {
        return c + Fh(Hy() * (h - c + 1));
      }
      function pM(c, h, y, N) {
        for (var W = -1, ne = En(Bh((h - c) / (y || 1)), 0), fe = Ie(ne); ne--; )
          fe[N ? ne : ++W] = c, c += y;
        return fe;
      }
      function yg(c, h) {
        var y = "";
        if (!c || h < 1 || h > E)
          return y;
        do
          h % 2 && (y += c), h = Fh(h / 2), h && (c += c);
        while (h);
        return y;
      }
      function hr(c, h) {
        return kg(Uw(c, h, pi), c + "");
      }
      function gM(c) {
        return Gy(Xc(c));
      }
      function mM(c, h) {
        var y = Xc(c);
        return rd(y, za(h, 0, y.length));
      }
      function vf(c, h, y, N) {
        if (!Zr(c))
          return c;
        h = Zo(h, c);
        for (var W = -1, ne = h.length, fe = ne - 1, me = c; me != null && ++W < ne; ) {
          var we = Ls(h[W]), We = y;
          if (we === "__proto__" || we === "constructor" || we === "prototype")
            return c;
          if (W != fe) {
            var He = me[we];
            We = N ? N(He, we, me) : r, We === r && (We = Zr(He) ? He : po(h[W + 1]) ? [] : {});
          }
          df(me, we, We), me = me[we];
        }
        return c;
      }
      var hw = jh ? function(c, h) {
        return jh.set(c, h), c;
      } : pi, vM = $h ? function(c, h) {
        return $h(c, "toString", {
          configurable: !0,
          enumerable: !1,
          value: Kg(h),
          writable: !0
        });
      } : pi;
      function bM(c) {
        return rd(Xc(c));
      }
      function Ki(c, h, y) {
        var N = -1, W = c.length;
        h < 0 && (h = -h > W ? 0 : W + h), y = y > W ? W : y, y < 0 && (y += W), W = h > y ? 0 : y - h >>> 0, h >>>= 0;
        for (var ne = Ie(W); ++N < W; )
          ne[N] = c[N + h];
        return ne;
      }
      function yM(c, h) {
        var y;
        return Jo(c, function(N, W, ne) {
          return y = h(N, W, ne), !y;
        }), !!y;
      }
      function Vh(c, h, y) {
        var N = 0, W = c == null ? N : c.length;
        if (typeof h == "number" && h === h && W <= F) {
          for (; N < W; ) {
            var ne = N + W >>> 1, fe = c[ne];
            fe !== null && !Ci(fe) && (y ? fe <= h : fe < h) ? N = ne + 1 : W = ne;
          }
          return W;
        }
        return wg(c, h, pi, y);
      }
      function wg(c, h, y, N) {
        var W = 0, ne = c == null ? 0 : c.length;
        if (ne === 0)
          return 0;
        h = y(h);
        for (var fe = h !== h, me = h === null, we = Ci(h), We = h === r; W < ne; ) {
          var He = Fh((W + ne) / 2), Xe = y(c[He]), wt = Xe !== r, Ot = Xe === null, Ht = Xe === Xe, fr = Ci(Xe);
          if (fe)
            var Kt = N || Ht;
          else We ? Kt = Ht && (N || wt) : me ? Kt = Ht && wt && (N || !Ot) : we ? Kt = Ht && wt && !Ot && (N || !fr) : Ot || fr ? Kt = !1 : Kt = N ? Xe <= h : Xe < h;
          Kt ? W = He + 1 : ne = He;
        }
        return Kn(ne, I);
      }
      function dw(c, h) {
        for (var y = -1, N = c.length, W = 0, ne = []; ++y < N; ) {
          var fe = c[y], me = h ? h(fe) : fe;
          if (!y || !gs(me, we)) {
            var we = me;
            ne[W++] = fe === 0 ? 0 : fe;
          }
        }
        return ne;
      }
      function pw(c) {
        return typeof c == "number" ? c : Ci(c) ? v : +c;
      }
      function Ii(c) {
        if (typeof c == "string")
          return c;
        if (ir(c))
          return Xr(c, Ii) + "";
        if (Ci(c))
          return Ky ? Ky.call(c) : "";
        var h = c + "";
        return h == "0" && 1 / c == -x ? "-0" : h;
      }
      function Xo(c, h, y) {
        var N = -1, W = Ph, ne = c.length, fe = !0, me = [], we = me;
        if (y)
          fe = !1, W = Yp;
        else if (ne >= i) {
          var We = h ? null : TM(c);
          if (We)
            return Ih(We);
          fe = !1, W = af, we = new qa();
        } else
          we = h ? [] : me;
        e:
          for (; ++N < ne; ) {
            var He = c[N], Xe = h ? h(He) : He;
            if (He = y || He !== 0 ? He : 0, fe && Xe === Xe) {
              for (var wt = we.length; wt--; )
                if (we[wt] === Xe)
                  continue e;
              h && we.push(Xe), me.push(He);
            } else W(we, Xe, y) || (we !== me && we.push(Xe), me.push(He));
          }
        return me;
      }
      function xg(c, h) {
        return h = Zo(h, c), c = qw(c, h), c == null || delete c[Ls(Vi(h))];
      }
      function gw(c, h, y, N) {
        return vf(c, h, y(Wa(c, h)), N);
      }
      function Gh(c, h, y, N) {
        for (var W = c.length, ne = N ? W : -1; (N ? ne-- : ++ne < W) && h(c[ne], ne, c); )
          ;
        return y ? Ki(c, N ? 0 : ne, N ? ne + 1 : W) : Ki(c, N ? ne + 1 : 0, N ? W : ne);
      }
      function mw(c, h) {
        var y = c;
        return y instanceof xr && (y = y.value()), Jp(h, function(N, W) {
          return W.func.apply(W.thisArg, Vo([N], W.args));
        }, y);
      }
      function _g(c, h, y) {
        var N = c.length;
        if (N < 2)
          return N ? Xo(c[0]) : [];
        for (var W = -1, ne = Ie(N); ++W < N; )
          for (var fe = c[W], me = -1; ++me < N; )
            me != W && (ne[W] = pf(ne[W] || fe, c[me], h, y));
        return Xo(Bn(ne, 1), h, y);
      }
      function vw(c, h, y) {
        for (var N = -1, W = c.length, ne = h.length, fe = {}; ++N < W; ) {
          var me = N < ne ? h[N] : r;
          y(fe, c[N], me);
        }
        return fe;
      }
      function Eg(c) {
        return cn(c) ? c : [];
      }
      function Sg(c) {
        return typeof c == "function" ? c : pi;
      }
      function Zo(c, h) {
        return ir(c) ? c : Og(c, h) ? [c] : Kw(Cr(c));
      }
      var wM = hr;
      function Qo(c, h, y) {
        var N = c.length;
        return y = y === r ? N : y, !h && y >= N ? c : Ki(c, h, y);
      }
      var bw = aP || function(c) {
        return Er.clearTimeout(c);
      };
      function yw(c, h) {
        if (h)
          return c.slice();
        var y = c.length, N = jy ? jy(y) : new c.constructor(y);
        return c.copy(N), N;
      }
      function Ag(c) {
        var h = new c.constructor(c.byteLength);
        return new Nh(h).set(new Nh(c)), h;
      }
      function xM(c, h) {
        var y = h ? Ag(c.buffer) : c.buffer;
        return new c.constructor(y, c.byteOffset, c.byteLength);
      }
      function _M(c) {
        var h = new c.constructor(c.source, Te.exec(c));
        return h.lastIndex = c.lastIndex, h;
      }
      function EM(c) {
        return hf ? qr(hf.call(c)) : {};
      }
      function ww(c, h) {
        var y = h ? Ag(c.buffer) : c.buffer;
        return new c.constructor(y, c.byteOffset, c.length);
      }
      function xw(c, h) {
        if (c !== h) {
          var y = c !== r, N = c === null, W = c === c, ne = Ci(c), fe = h !== r, me = h === null, we = h === h, We = Ci(h);
          if (!me && !We && !ne && c > h || ne && fe && we && !me && !We || N && fe && we || !y && we || !W)
            return 1;
          if (!N && !ne && !We && c < h || We && y && W && !N && !ne || me && y && W || !fe && W || !we)
            return -1;
        }
        return 0;
      }
      function SM(c, h, y) {
        for (var N = -1, W = c.criteria, ne = h.criteria, fe = W.length, me = y.length; ++N < fe; ) {
          var we = xw(W[N], ne[N]);
          if (we) {
            if (N >= me)
              return we;
            var We = y[N];
            return we * (We == "desc" ? -1 : 1);
          }
        }
        return c.index - h.index;
      }
      function _w(c, h, y, N) {
        for (var W = -1, ne = c.length, fe = y.length, me = -1, we = h.length, We = En(ne - fe, 0), He = Ie(we + We), Xe = !N; ++me < we; )
          He[me] = h[me];
        for (; ++W < fe; )
          (Xe || W < ne) && (He[y[W]] = c[W]);
        for (; We--; )
          He[me++] = c[W++];
        return He;
      }
      function Ew(c, h, y, N) {
        for (var W = -1, ne = c.length, fe = -1, me = y.length, we = -1, We = h.length, He = En(ne - me, 0), Xe = Ie(He + We), wt = !N; ++W < He; )
          Xe[W] = c[W];
        for (var Ot = W; ++we < We; )
          Xe[Ot + we] = h[we];
        for (; ++fe < me; )
          (wt || W < ne) && (Xe[Ot + y[fe]] = c[W++]);
        return Xe;
      }
      function li(c, h) {
        var y = -1, N = c.length;
        for (h || (h = Ie(N)); ++y < N; )
          h[y] = c[y];
        return h;
      }
      function Ns(c, h, y, N) {
        var W = !y;
        y || (y = {});
        for (var ne = -1, fe = h.length; ++ne < fe; ) {
          var me = h[ne], we = N ? N(y[me], c[me], me, y, c) : r;
          we === r && (we = c[me]), W ? fo(y, me, we) : df(y, me, we);
        }
        return y;
      }
      function AM(c, h) {
        return Ns(c, Dg(c), h);
      }
      function PM(c, h) {
        return Ns(c, kw(c), h);
      }
      function Yh(c, h) {
        return function(y, N) {
          var W = ir(y) ? RA : GP, ne = h ? h() : {};
          return W(y, c, Ut(N, 2), ne);
        };
      }
      function Vc(c) {
        return hr(function(h, y) {
          var N = -1, W = y.length, ne = W > 1 ? y[W - 1] : r, fe = W > 2 ? y[2] : r;
          for (ne = c.length > 3 && typeof ne == "function" ? (W--, ne) : r, fe && ii(y[0], y[1], fe) && (ne = W < 3 ? r : ne, W = 1), h = qr(h); ++N < W; ) {
            var me = y[N];
            me && c(h, me, N, ne);
          }
          return h;
        });
      }
      function Sw(c, h) {
        return function(y, N) {
          if (y == null)
            return y;
          if (!hi(y))
            return c(y, N);
          for (var W = y.length, ne = h ? W : -1, fe = qr(y); (h ? ne-- : ++ne < W) && N(fe[ne], ne, fe) !== !1; )
            ;
          return y;
        };
      }
      function Aw(c) {
        return function(h, y, N) {
          for (var W = -1, ne = qr(h), fe = N(h), me = fe.length; me--; ) {
            var we = fe[c ? me : ++W];
            if (y(ne[we], we, ne) === !1)
              break;
          }
          return h;
        };
      }
      function MM(c, h, y) {
        var N = h & L, W = bf(c);
        function ne() {
          var fe = this && this !== Er && this instanceof ne ? W : c;
          return fe.apply(N ? y : this, arguments);
        }
        return ne;
      }
      function Pw(c) {
        return function(h) {
          h = Cr(h);
          var y = jc(h) ? ds(h) : r, N = y ? y[0] : h.charAt(0), W = y ? Qo(y, 1).join("") : h.slice(1);
          return N[c]() + W;
        };
      }
      function Gc(c) {
        return function(h) {
          return Jp(S2(E2(h).replace(sf, "")), c, "");
        };
      }
      function bf(c) {
        return function() {
          var h = arguments;
          switch (h.length) {
            case 0:
              return new c();
            case 1:
              return new c(h[0]);
            case 2:
              return new c(h[0], h[1]);
            case 3:
              return new c(h[0], h[1], h[2]);
            case 4:
              return new c(h[0], h[1], h[2], h[3]);
            case 5:
              return new c(h[0], h[1], h[2], h[3], h[4]);
            case 6:
              return new c(h[0], h[1], h[2], h[3], h[4], h[5]);
            case 7:
              return new c(h[0], h[1], h[2], h[3], h[4], h[5], h[6]);
          }
          var y = Kc(c.prototype), N = c.apply(y, h);
          return Zr(N) ? N : y;
        };
      }
      function IM(c, h, y) {
        var N = bf(c);
        function W() {
          for (var ne = arguments.length, fe = Ie(ne), me = ne, we = Yc(W); me--; )
            fe[me] = arguments[me];
          var We = ne < 3 && fe[0] !== we && fe[ne - 1] !== we ? [] : Go(fe, we);
          if (ne -= We.length, ne < y)
            return Rw(
              c,
              h,
              Jh,
              W.placeholder,
              r,
              fe,
              We,
              r,
              r,
              y - ne
            );
          var He = this && this !== Er && this instanceof W ? N : c;
          return Pn(He, this, fe);
        }
        return W;
      }
      function Mw(c) {
        return function(h, y, N) {
          var W = qr(h);
          if (!hi(h)) {
            var ne = Ut(y, 3);
            h = Mn(h), y = function(me) {
              return ne(W[me], me, W);
            };
          }
          var fe = c(h, y, N);
          return fe > -1 ? W[ne ? h[fe] : fe] : r;
        };
      }
      function Iw(c) {
        return ho(function(h) {
          var y = h.length, N = y, W = Wi.prototype.thru;
          for (c && h.reverse(); N--; ) {
            var ne = h[N];
            if (typeof ne != "function")
              throw new zi(o);
            if (W && !fe && ed(ne) == "wrapper")
              var fe = new Wi([], !0);
          }
          for (N = fe ? N : y; ++N < y; ) {
            ne = h[N];
            var me = ed(ne), we = me == "wrapper" ? Tg(ne) : r;
            we && Ng(we[0]) && we[1] == (R | q | V | K) && !we[4].length && we[9] == 1 ? fe = fe[ed(we[0])].apply(fe, we[3]) : fe = ne.length == 1 && Ng(ne) ? fe[me]() : fe.thru(ne);
          }
          return function() {
            var We = arguments, He = We[0];
            if (fe && We.length == 1 && ir(He))
              return fe.plant(He).value();
            for (var Xe = 0, wt = y ? h[Xe].apply(this, We) : He; ++Xe < y; )
              wt = h[Xe].call(this, wt);
            return wt;
          };
        });
      }
      function Jh(c, h, y, N, W, ne, fe, me, we, We) {
        var He = h & R, Xe = h & L, wt = h & B, Ot = h & (q | U), Ht = h & ge, fr = wt ? r : bf(c);
        function Kt() {
          for (var br = arguments.length, Sr = Ie(br), Ti = br; Ti--; )
            Sr[Ti] = arguments[Ti];
          if (Ot)
            var si = Yc(Kt), Ri = jA(Sr, si);
          if (N && (Sr = _w(Sr, N, W, Ot)), ne && (Sr = Ew(Sr, ne, fe, Ot)), br -= Ri, Ot && br < We) {
            var un = Go(Sr, si);
            return Rw(
              c,
              h,
              Jh,
              Kt.placeholder,
              y,
              Sr,
              un,
              me,
              we,
              We - br
            );
          }
          var ms = Xe ? y : this, vo = wt ? ms[c] : c;
          return br = Sr.length, me ? Sr = GM(Sr, me) : Ht && br > 1 && Sr.reverse(), He && we < br && (Sr.length = we), this && this !== Er && this instanceof Kt && (vo = fr || bf(vo)), vo.apply(ms, Sr);
        }
        return Kt;
      }
      function Cw(c, h) {
        return function(y, N) {
          return rM(y, c, h(N), {});
        };
      }
      function Xh(c, h) {
        return function(y, N) {
          var W;
          if (y === r && N === r)
            return h;
          if (y !== r && (W = y), N !== r) {
            if (W === r)
              return N;
            typeof y == "string" || typeof N == "string" ? (y = Ii(y), N = Ii(N)) : (y = pw(y), N = pw(N)), W = c(y, N);
          }
          return W;
        };
      }
      function Pg(c) {
        return ho(function(h) {
          return h = Xr(h, Mi(Ut())), hr(function(y) {
            var N = this;
            return c(h, function(W) {
              return Pn(W, N, y);
            });
          });
        });
      }
      function Zh(c, h) {
        h = h === r ? " " : Ii(h);
        var y = h.length;
        if (y < 2)
          return y ? yg(h, c) : h;
        var N = yg(h, Bh(c / Uc(h)));
        return jc(h) ? Qo(ds(N), 0, c).join("") : N.slice(0, c);
      }
      function CM(c, h, y, N) {
        var W = h & L, ne = bf(c);
        function fe() {
          for (var me = -1, we = arguments.length, We = -1, He = N.length, Xe = Ie(He + we), wt = this && this !== Er && this instanceof fe ? ne : c; ++We < He; )
            Xe[We] = N[We];
          for (; we--; )
            Xe[We++] = arguments[++me];
          return Pn(wt, W ? y : this, Xe);
        }
        return fe;
      }
      function Tw(c) {
        return function(h, y, N) {
          return N && typeof N != "number" && ii(h, y, N) && (y = N = r), h = mo(h), y === r ? (y = h, h = 0) : y = mo(y), N = N === r ? h < y ? 1 : -1 : mo(N), pM(h, y, N, c);
        };
      }
      function Qh(c) {
        return function(h, y) {
          return typeof h == "string" && typeof y == "string" || (h = Gi(h), y = Gi(y)), c(h, y);
        };
      }
      function Rw(c, h, y, N, W, ne, fe, me, we, We) {
        var He = h & q, Xe = He ? fe : r, wt = He ? r : fe, Ot = He ? ne : r, Ht = He ? r : ne;
        h |= He ? V : Q, h &= ~(He ? Q : V), h & k || (h &= ~(L | B));
        var fr = [
          c,
          h,
          W,
          Ot,
          Xe,
          Ht,
          wt,
          me,
          we,
          We
        ], Kt = y.apply(r, fr);
        return Ng(c) && zw(Kt, fr), Kt.placeholder = N, Ww(Kt, c, h);
      }
      function Mg(c) {
        var h = _n[c];
        return function(y, N) {
          if (y = Gi(y), N = N == null ? 0 : Kn(cr(N), 292), N && Wy(y)) {
            var W = (Cr(y) + "e").split("e"), ne = h(W[0] + "e" + (+W[1] + N));
            return W = (Cr(ne) + "e").split("e"), +(W[0] + "e" + (+W[1] - N));
          }
          return h(y);
        };
      }
      var TM = Wc && 1 / Ih(new Wc([, -0]))[1] == x ? function(c) {
        return new Wc(c);
      } : Yg;
      function Dw(c) {
        return function(h) {
          var y = Vn(h);
          return y == ie ? ng(h) : y == Me ? VA(h) : FA(h, c(h));
        };
      }
      function lo(c, h, y, N, W, ne, fe, me) {
        var we = h & B;
        if (!we && typeof c != "function")
          throw new zi(o);
        var We = N ? N.length : 0;
        if (We || (h &= ~(V | Q), N = W = r), fe = fe === r ? fe : En(cr(fe), 0), me = me === r ? me : cr(me), We -= W ? W.length : 0, h & Q) {
          var He = N, Xe = W;
          N = W = r;
        }
        var wt = we ? r : Tg(c), Ot = [
          c,
          h,
          y,
          N,
          W,
          He,
          Xe,
          ne,
          fe,
          me
        ];
        if (wt && HM(Ot, wt), c = Ot[0], h = Ot[1], y = Ot[2], N = Ot[3], W = Ot[4], me = Ot[9] = Ot[9] === r ? we ? 0 : c.length : En(Ot[9] - We, 0), !me && h & (q | U) && (h &= ~(q | U)), !h || h == L)
          var Ht = MM(c, h, y);
        else h == q || h == U ? Ht = IM(c, h, me) : (h == V || h == (L | V)) && !W.length ? Ht = CM(c, h, y, N) : Ht = Jh.apply(r, Ot);
        var fr = wt ? hw : zw;
        return Ww(fr(Ht, Ot), c, h);
      }
      function Ow(c, h, y, N) {
        return c === r || gs(c, zc[y]) && !Tr.call(N, y) ? h : c;
      }
      function Nw(c, h, y, N, W, ne) {
        return Zr(c) && Zr(h) && (ne.set(h, c), Kh(c, h, r, Nw, ne), ne.delete(h)), c;
      }
      function RM(c) {
        return xf(c) ? r : c;
      }
      function Lw(c, h, y, N, W, ne) {
        var fe = y & P, me = c.length, we = h.length;
        if (me != we && !(fe && we > me))
          return !1;
        var We = ne.get(c), He = ne.get(h);
        if (We && He)
          return We == h && He == c;
        var Xe = -1, wt = !0, Ot = y & O ? new qa() : r;
        for (ne.set(c, h), ne.set(h, c); ++Xe < me; ) {
          var Ht = c[Xe], fr = h[Xe];
          if (N)
            var Kt = fe ? N(fr, Ht, Xe, h, c, ne) : N(Ht, fr, Xe, c, h, ne);
          if (Kt !== r) {
            if (Kt)
              continue;
            wt = !1;
            break;
          }
          if (Ot) {
            if (!Xp(h, function(br, Sr) {
              if (!af(Ot, Sr) && (Ht === br || W(Ht, br, y, N, ne)))
                return Ot.push(Sr);
            })) {
              wt = !1;
              break;
            }
          } else if (!(Ht === fr || W(Ht, fr, y, N, ne))) {
            wt = !1;
            break;
          }
        }
        return ne.delete(c), ne.delete(h), wt;
      }
      function DM(c, h, y, N, W, ne, fe) {
        switch (y) {
          case Ze:
            if (c.byteLength != h.byteLength || c.byteOffset != h.byteOffset)
              return !1;
            c = c.buffer, h = h.buffer;
          case _e:
            return !(c.byteLength != h.byteLength || !ne(new Nh(c), new Nh(h)));
          case J:
          case ee:
          case ue:
            return gs(+c, +h);
          case X:
            return c.name == h.name && c.message == h.message;
          case $e:
          case Ne:
            return c == h + "";
          case ie:
            var me = ng;
          case Me:
            var we = N & P;
            if (me || (me = Ih), c.size != h.size && !we)
              return !1;
            var We = fe.get(c);
            if (We)
              return We == h;
            N |= O, fe.set(c, h);
            var He = Lw(me(c), me(h), N, W, ne, fe);
            return fe.delete(c), He;
          case Ke:
            if (hf)
              return hf.call(c) == hf.call(h);
        }
        return !1;
      }
      function OM(c, h, y, N, W, ne) {
        var fe = y & P, me = Ig(c), we = me.length, We = Ig(h), He = We.length;
        if (we != He && !fe)
          return !1;
        for (var Xe = we; Xe--; ) {
          var wt = me[Xe];
          if (!(fe ? wt in h : Tr.call(h, wt)))
            return !1;
        }
        var Ot = ne.get(c), Ht = ne.get(h);
        if (Ot && Ht)
          return Ot == h && Ht == c;
        var fr = !0;
        ne.set(c, h), ne.set(h, c);
        for (var Kt = fe; ++Xe < we; ) {
          wt = me[Xe];
          var br = c[wt], Sr = h[wt];
          if (N)
            var Ti = fe ? N(Sr, br, wt, h, c, ne) : N(br, Sr, wt, c, h, ne);
          if (!(Ti === r ? br === Sr || W(br, Sr, y, N, ne) : Ti)) {
            fr = !1;
            break;
          }
          Kt || (Kt = wt == "constructor");
        }
        if (fr && !Kt) {
          var si = c.constructor, Ri = h.constructor;
          si != Ri && "constructor" in c && "constructor" in h && !(typeof si == "function" && si instanceof si && typeof Ri == "function" && Ri instanceof Ri) && (fr = !1);
        }
        return ne.delete(c), ne.delete(h), fr;
      }
      function ho(c) {
        return kg(Uw(c, r, Jw), c + "");
      }
      function Ig(c) {
        return tw(c, Mn, Dg);
      }
      function Cg(c) {
        return tw(c, di, kw);
      }
      var Tg = jh ? function(c) {
        return jh.get(c);
      } : Yg;
      function ed(c) {
        for (var h = c.name + "", y = Hc[h], N = Tr.call(Hc, h) ? y.length : 0; N--; ) {
          var W = y[N], ne = W.func;
          if (ne == null || ne == c)
            return W.name;
        }
        return h;
      }
      function Yc(c) {
        var h = Tr.call(te, "placeholder") ? te : c;
        return h.placeholder;
      }
      function Ut() {
        var c = te.iteratee || Vg;
        return c = c === Vg ? iw : c, arguments.length ? c(arguments[0], arguments[1]) : c;
      }
      function td(c, h) {
        var y = c.__data__;
        return UM(h) ? y[typeof h == "string" ? "string" : "hash"] : y.map;
      }
      function Rg(c) {
        for (var h = Mn(c), y = h.length; y--; ) {
          var N = h[y], W = c[N];
          h[y] = [N, W, Fw(W)];
        }
        return h;
      }
      function Ha(c, h) {
        var y = WA(c, h);
        return nw(y) ? y : r;
      }
      function NM(c) {
        var h = Tr.call(c, ja), y = c[ja];
        try {
          c[ja] = r;
          var N = !0;
        } catch {
        }
        var W = Dh.call(c);
        return N && (h ? c[ja] = y : delete c[ja]), W;
      }
      var Dg = sg ? function(c) {
        return c == null ? [] : (c = qr(c), Ko(sg(c), function(h) {
          return qy.call(c, h);
        }));
      } : Jg, kw = sg ? function(c) {
        for (var h = []; c; )
          Vo(h, Dg(c)), c = Lh(c);
        return h;
      } : Jg, Vn = ni;
      (og && Vn(new og(new ArrayBuffer(1))) != Ze || uf && Vn(new uf()) != ie || ag && Vn(ag.resolve()) != De || Wc && Vn(new Wc()) != Me || ff && Vn(new ff()) != qe) && (Vn = function(c) {
        var h = ni(c), y = h == Pe ? c.constructor : r, N = y ? Ka(y) : "";
        if (N)
          switch (N) {
            case mP:
              return Ze;
            case vP:
              return ie;
            case bP:
              return De;
            case yP:
              return Me;
            case wP:
              return qe;
          }
        return h;
      });
      function LM(c, h, y) {
        for (var N = -1, W = y.length; ++N < W; ) {
          var ne = y[N], fe = ne.size;
          switch (ne.type) {
            case "drop":
              c += fe;
              break;
            case "dropRight":
              h -= fe;
              break;
            case "take":
              h = Kn(h, c + fe);
              break;
            case "takeRight":
              c = En(c, h - fe);
              break;
          }
        }
        return { start: c, end: h };
      }
      function kM(c) {
        var h = c.match(C);
        return h ? h[1].split(G) : [];
      }
      function $w(c, h, y) {
        h = Zo(h, c);
        for (var N = -1, W = h.length, ne = !1; ++N < W; ) {
          var fe = Ls(h[N]);
          if (!(ne = c != null && y(c, fe)))
            break;
          c = c[fe];
        }
        return ne || ++N != W ? ne : (W = c == null ? 0 : c.length, !!W && cd(W) && po(fe, W) && (ir(c) || Va(c)));
      }
      function $M(c) {
        var h = c.length, y = new c.constructor(h);
        return h && typeof c[0] == "string" && Tr.call(c, "index") && (y.index = c.index, y.input = c.input), y;
      }
      function Bw(c) {
        return typeof c.constructor == "function" && !yf(c) ? Kc(Lh(c)) : {};
      }
      function BM(c, h, y) {
        var N = c.constructor;
        switch (h) {
          case _e:
            return Ag(c);
          case J:
          case ee:
            return new N(+c);
          case Ze:
            return xM(c, y);
          case at:
          case ke:
          case Qe:
          case tt:
          case Ye:
          case dt:
          case lt:
          case ct:
          case qt:
            return ww(c, y);
          case ie:
            return new N();
          case ue:
          case Ne:
            return new N(c);
          case $e:
            return _M(c);
          case Me:
            return new N();
          case Ke:
            return EM(c);
        }
      }
      function FM(c, h) {
        var y = h.length;
        if (!y)
          return c;
        var N = y - 1;
        return h[N] = (y > 1 ? "& " : "") + h[N], h = h.join(y > 2 ? ", " : " "), c.replace(H, `{
/* [wrapped with ` + h + `] */
`);
      }
      function jM(c) {
        return ir(c) || Va(c) || !!(zy && c && c[zy]);
      }
      function po(c, h) {
        var y = typeof c;
        return h = h ?? E, !!h && (y == "number" || y != "symbol" && it.test(c)) && c > -1 && c % 1 == 0 && c < h;
      }
      function ii(c, h, y) {
        if (!Zr(y))
          return !1;
        var N = typeof h;
        return (N == "number" ? hi(y) && po(h, y.length) : N == "string" && h in y) ? gs(y[h], c) : !1;
      }
      function Og(c, h) {
        if (ir(c))
          return !1;
        var y = typeof c;
        return y == "number" || y == "symbol" || y == "boolean" || c == null || Ci(c) ? !0 : $t.test(c) || !bt.test(c) || h != null && c in qr(h);
      }
      function UM(c) {
        var h = typeof c;
        return h == "string" || h == "number" || h == "symbol" || h == "boolean" ? c !== "__proto__" : c === null;
      }
      function Ng(c) {
        var h = ed(c), y = te[h];
        if (typeof y != "function" || !(h in xr.prototype))
          return !1;
        if (c === y)
          return !0;
        var N = Tg(y);
        return !!N && c === N[0];
      }
      function qM(c) {
        return !!Fy && Fy in c;
      }
      var zM = Th ? go : Xg;
      function yf(c) {
        var h = c && c.constructor, y = typeof h == "function" && h.prototype || zc;
        return c === y;
      }
      function Fw(c) {
        return c === c && !Zr(c);
      }
      function jw(c, h) {
        return function(y) {
          return y == null ? !1 : y[c] === h && (h !== r || c in qr(y));
        };
      }
      function WM(c) {
        var h = od(c, function(N) {
          return y.size === l && y.clear(), N;
        }), y = h.cache;
        return h;
      }
      function HM(c, h) {
        var y = c[1], N = h[1], W = y | N, ne = W < (L | B | R), fe = N == R && y == q || N == R && y == K && c[7].length <= h[8] || N == (R | K) && h[7].length <= h[8] && y == q;
        if (!(ne || fe))
          return c;
        N & L && (c[2] = h[2], W |= y & L ? 0 : k);
        var me = h[3];
        if (me) {
          var we = c[3];
          c[3] = we ? _w(we, me, h[4]) : me, c[4] = we ? Go(c[3], d) : h[4];
        }
        return me = h[5], me && (we = c[5], c[5] = we ? Ew(we, me, h[6]) : me, c[6] = we ? Go(c[5], d) : h[6]), me = h[7], me && (c[7] = me), N & R && (c[8] = c[8] == null ? h[8] : Kn(c[8], h[8])), c[9] == null && (c[9] = h[9]), c[0] = h[0], c[1] = W, c;
      }
      function KM(c) {
        var h = [];
        if (c != null)
          for (var y in qr(c))
            h.push(y);
        return h;
      }
      function VM(c) {
        return Dh.call(c);
      }
      function Uw(c, h, y) {
        return h = En(h === r ? c.length - 1 : h, 0), function() {
          for (var N = arguments, W = -1, ne = En(N.length - h, 0), fe = Ie(ne); ++W < ne; )
            fe[W] = N[h + W];
          W = -1;
          for (var me = Ie(h + 1); ++W < h; )
            me[W] = N[W];
          return me[h] = y(fe), Pn(c, this, me);
        };
      }
      function qw(c, h) {
        return h.length < 2 ? c : Wa(c, Ki(h, 0, -1));
      }
      function GM(c, h) {
        for (var y = c.length, N = Kn(h.length, y), W = li(c); N--; ) {
          var ne = h[N];
          c[N] = po(ne, y) ? W[ne] : r;
        }
        return c;
      }
      function Lg(c, h) {
        if (!(h === "constructor" && typeof c[h] == "function") && h != "__proto__")
          return c[h];
      }
      var zw = Hw(hw), wf = uP || function(c, h) {
        return Er.setTimeout(c, h);
      }, kg = Hw(vM);
      function Ww(c, h, y) {
        var N = h + "";
        return kg(c, FM(N, YM(kM(N), y)));
      }
      function Hw(c) {
        var h = 0, y = 0;
        return function() {
          var N = dP(), W = m - (N - y);
          if (y = N, W > 0) {
            if (++h >= A)
              return arguments[0];
          } else
            h = 0;
          return c.apply(r, arguments);
        };
      }
      function rd(c, h) {
        var y = -1, N = c.length, W = N - 1;
        for (h = h === r ? N : h; ++y < h; ) {
          var ne = bg(y, W), fe = c[ne];
          c[ne] = c[y], c[y] = fe;
        }
        return c.length = h, c;
      }
      var Kw = WM(function(c) {
        var h = [];
        return c.charCodeAt(0) === 46 && h.push(""), c.replace(Ft, function(y, N, W, ne) {
          h.push(W ? ne.replace(de, "$1") : N || y);
        }), h;
      });
      function Ls(c) {
        if (typeof c == "string" || Ci(c))
          return c;
        var h = c + "";
        return h == "0" && 1 / c == -x ? "-0" : h;
      }
      function Ka(c) {
        if (c != null) {
          try {
            return Rh.call(c);
          } catch {
          }
          try {
            return c + "";
          } catch {
          }
        }
        return "";
      }
      function YM(c, h) {
        return qi(ce, function(y) {
          var N = "_." + y[0];
          h & y[1] && !Ph(c, N) && c.push(N);
        }), c.sort();
      }
      function Vw(c) {
        if (c instanceof xr)
          return c.clone();
        var h = new Wi(c.__wrapped__, c.__chain__);
        return h.__actions__ = li(c.__actions__), h.__index__ = c.__index__, h.__values__ = c.__values__, h;
      }
      function JM(c, h, y) {
        (y ? ii(c, h, y) : h === r) ? h = 1 : h = En(cr(h), 0);
        var N = c == null ? 0 : c.length;
        if (!N || h < 1)
          return [];
        for (var W = 0, ne = 0, fe = Ie(Bh(N / h)); W < N; )
          fe[ne++] = Ki(c, W, W += h);
        return fe;
      }
      function XM(c) {
        for (var h = -1, y = c == null ? 0 : c.length, N = 0, W = []; ++h < y; ) {
          var ne = c[h];
          ne && (W[N++] = ne);
        }
        return W;
      }
      function ZM() {
        var c = arguments.length;
        if (!c)
          return [];
        for (var h = Ie(c - 1), y = arguments[0], N = c; N--; )
          h[N - 1] = arguments[N];
        return Vo(ir(y) ? li(y) : [y], Bn(h, 1));
      }
      var QM = hr(function(c, h) {
        return cn(c) ? pf(c, Bn(h, 1, cn, !0)) : [];
      }), eI = hr(function(c, h) {
        var y = Vi(h);
        return cn(y) && (y = r), cn(c) ? pf(c, Bn(h, 1, cn, !0), Ut(y, 2)) : [];
      }), tI = hr(function(c, h) {
        var y = Vi(h);
        return cn(y) && (y = r), cn(c) ? pf(c, Bn(h, 1, cn, !0), r, y) : [];
      });
      function rI(c, h, y) {
        var N = c == null ? 0 : c.length;
        return N ? (h = y || h === r ? 1 : cr(h), Ki(c, h < 0 ? 0 : h, N)) : [];
      }
      function nI(c, h, y) {
        var N = c == null ? 0 : c.length;
        return N ? (h = y || h === r ? 1 : cr(h), h = N - h, Ki(c, 0, h < 0 ? 0 : h)) : [];
      }
      function iI(c, h) {
        return c && c.length ? Gh(c, Ut(h, 3), !0, !0) : [];
      }
      function sI(c, h) {
        return c && c.length ? Gh(c, Ut(h, 3), !0) : [];
      }
      function oI(c, h, y, N) {
        var W = c == null ? 0 : c.length;
        return W ? (y && typeof y != "number" && ii(c, h, y) && (y = 0, N = W), ZP(c, h, y, N)) : [];
      }
      function Gw(c, h, y) {
        var N = c == null ? 0 : c.length;
        if (!N)
          return -1;
        var W = y == null ? 0 : cr(y);
        return W < 0 && (W = En(N + W, 0)), Mh(c, Ut(h, 3), W);
      }
      function Yw(c, h, y) {
        var N = c == null ? 0 : c.length;
        if (!N)
          return -1;
        var W = N - 1;
        return y !== r && (W = cr(y), W = y < 0 ? En(N + W, 0) : Kn(W, N - 1)), Mh(c, Ut(h, 3), W, !0);
      }
      function Jw(c) {
        var h = c == null ? 0 : c.length;
        return h ? Bn(c, 1) : [];
      }
      function aI(c) {
        var h = c == null ? 0 : c.length;
        return h ? Bn(c, x) : [];
      }
      function cI(c, h) {
        var y = c == null ? 0 : c.length;
        return y ? (h = h === r ? 1 : cr(h), Bn(c, h)) : [];
      }
      function uI(c) {
        for (var h = -1, y = c == null ? 0 : c.length, N = {}; ++h < y; ) {
          var W = c[h];
          N[W[0]] = W[1];
        }
        return N;
      }
      function Xw(c) {
        return c && c.length ? c[0] : r;
      }
      function fI(c, h, y) {
        var N = c == null ? 0 : c.length;
        if (!N)
          return -1;
        var W = y == null ? 0 : cr(y);
        return W < 0 && (W = En(N + W, 0)), Fc(c, h, W);
      }
      function lI(c) {
        var h = c == null ? 0 : c.length;
        return h ? Ki(c, 0, -1) : [];
      }
      var hI = hr(function(c) {
        var h = Xr(c, Eg);
        return h.length && h[0] === c[0] ? dg(h) : [];
      }), dI = hr(function(c) {
        var h = Vi(c), y = Xr(c, Eg);
        return h === Vi(y) ? h = r : y.pop(), y.length && y[0] === c[0] ? dg(y, Ut(h, 2)) : [];
      }), pI = hr(function(c) {
        var h = Vi(c), y = Xr(c, Eg);
        return h = typeof h == "function" ? h : r, h && y.pop(), y.length && y[0] === c[0] ? dg(y, r, h) : [];
      });
      function gI(c, h) {
        return c == null ? "" : lP.call(c, h);
      }
      function Vi(c) {
        var h = c == null ? 0 : c.length;
        return h ? c[h - 1] : r;
      }
      function mI(c, h, y) {
        var N = c == null ? 0 : c.length;
        if (!N)
          return -1;
        var W = N;
        return y !== r && (W = cr(y), W = W < 0 ? En(N + W, 0) : Kn(W, N - 1)), h === h ? YA(c, h, W) : Mh(c, Ry, W, !0);
      }
      function vI(c, h) {
        return c && c.length ? cw(c, cr(h)) : r;
      }
      var bI = hr(Zw);
      function Zw(c, h) {
        return c && c.length && h && h.length ? vg(c, h) : c;
      }
      function yI(c, h, y) {
        return c && c.length && h && h.length ? vg(c, h, Ut(y, 2)) : c;
      }
      function wI(c, h, y) {
        return c && c.length && h && h.length ? vg(c, h, r, y) : c;
      }
      var xI = ho(function(c, h) {
        var y = c == null ? 0 : c.length, N = ug(c, h);
        return lw(c, Xr(h, function(W) {
          return po(W, y) ? +W : W;
        }).sort(xw)), N;
      });
      function _I(c, h) {
        var y = [];
        if (!(c && c.length))
          return y;
        var N = -1, W = [], ne = c.length;
        for (h = Ut(h, 3); ++N < ne; ) {
          var fe = c[N];
          h(fe, N, c) && (y.push(fe), W.push(N));
        }
        return lw(c, W), y;
      }
      function $g(c) {
        return c == null ? c : gP.call(c);
      }
      function EI(c, h, y) {
        var N = c == null ? 0 : c.length;
        return N ? (y && typeof y != "number" && ii(c, h, y) ? (h = 0, y = N) : (h = h == null ? 0 : cr(h), y = y === r ? N : cr(y)), Ki(c, h, y)) : [];
      }
      function SI(c, h) {
        return Vh(c, h);
      }
      function AI(c, h, y) {
        return wg(c, h, Ut(y, 2));
      }
      function PI(c, h) {
        var y = c == null ? 0 : c.length;
        if (y) {
          var N = Vh(c, h);
          if (N < y && gs(c[N], h))
            return N;
        }
        return -1;
      }
      function MI(c, h) {
        return Vh(c, h, !0);
      }
      function II(c, h, y) {
        return wg(c, h, Ut(y, 2), !0);
      }
      function CI(c, h) {
        var y = c == null ? 0 : c.length;
        if (y) {
          var N = Vh(c, h, !0) - 1;
          if (gs(c[N], h))
            return N;
        }
        return -1;
      }
      function TI(c) {
        return c && c.length ? dw(c) : [];
      }
      function RI(c, h) {
        return c && c.length ? dw(c, Ut(h, 2)) : [];
      }
      function DI(c) {
        var h = c == null ? 0 : c.length;
        return h ? Ki(c, 1, h) : [];
      }
      function OI(c, h, y) {
        return c && c.length ? (h = y || h === r ? 1 : cr(h), Ki(c, 0, h < 0 ? 0 : h)) : [];
      }
      function NI(c, h, y) {
        var N = c == null ? 0 : c.length;
        return N ? (h = y || h === r ? 1 : cr(h), h = N - h, Ki(c, h < 0 ? 0 : h, N)) : [];
      }
      function LI(c, h) {
        return c && c.length ? Gh(c, Ut(h, 3), !1, !0) : [];
      }
      function kI(c, h) {
        return c && c.length ? Gh(c, Ut(h, 3)) : [];
      }
      var $I = hr(function(c) {
        return Xo(Bn(c, 1, cn, !0));
      }), BI = hr(function(c) {
        var h = Vi(c);
        return cn(h) && (h = r), Xo(Bn(c, 1, cn, !0), Ut(h, 2));
      }), FI = hr(function(c) {
        var h = Vi(c);
        return h = typeof h == "function" ? h : r, Xo(Bn(c, 1, cn, !0), r, h);
      });
      function jI(c) {
        return c && c.length ? Xo(c) : [];
      }
      function UI(c, h) {
        return c && c.length ? Xo(c, Ut(h, 2)) : [];
      }
      function qI(c, h) {
        return h = typeof h == "function" ? h : r, c && c.length ? Xo(c, r, h) : [];
      }
      function Bg(c) {
        if (!(c && c.length))
          return [];
        var h = 0;
        return c = Ko(c, function(y) {
          if (cn(y))
            return h = En(y.length, h), !0;
        }), tg(h, function(y) {
          return Xr(c, Zp(y));
        });
      }
      function Qw(c, h) {
        if (!(c && c.length))
          return [];
        var y = Bg(c);
        return h == null ? y : Xr(y, function(N) {
          return Pn(h, r, N);
        });
      }
      var zI = hr(function(c, h) {
        return cn(c) ? pf(c, h) : [];
      }), WI = hr(function(c) {
        return _g(Ko(c, cn));
      }), HI = hr(function(c) {
        var h = Vi(c);
        return cn(h) && (h = r), _g(Ko(c, cn), Ut(h, 2));
      }), KI = hr(function(c) {
        var h = Vi(c);
        return h = typeof h == "function" ? h : r, _g(Ko(c, cn), r, h);
      }), VI = hr(Bg);
      function GI(c, h) {
        return vw(c || [], h || [], df);
      }
      function YI(c, h) {
        return vw(c || [], h || [], vf);
      }
      var JI = hr(function(c) {
        var h = c.length, y = h > 1 ? c[h - 1] : r;
        return y = typeof y == "function" ? (c.pop(), y) : r, Qw(c, y);
      });
      function e2(c) {
        var h = te(c);
        return h.__chain__ = !0, h;
      }
      function XI(c, h) {
        return h(c), c;
      }
      function nd(c, h) {
        return h(c);
      }
      var ZI = ho(function(c) {
        var h = c.length, y = h ? c[0] : 0, N = this.__wrapped__, W = function(ne) {
          return ug(ne, c);
        };
        return h > 1 || this.__actions__.length || !(N instanceof xr) || !po(y) ? this.thru(W) : (N = N.slice(y, +y + (h ? 1 : 0)), N.__actions__.push({
          func: nd,
          args: [W],
          thisArg: r
        }), new Wi(N, this.__chain__).thru(function(ne) {
          return h && !ne.length && ne.push(r), ne;
        }));
      });
      function QI() {
        return e2(this);
      }
      function eC() {
        return new Wi(this.value(), this.__chain__);
      }
      function tC() {
        this.__values__ === r && (this.__values__ = p2(this.value()));
        var c = this.__index__ >= this.__values__.length, h = c ? r : this.__values__[this.__index__++];
        return { done: c, value: h };
      }
      function rC() {
        return this;
      }
      function nC(c) {
        for (var h, y = this; y instanceof qh; ) {
          var N = Vw(y);
          N.__index__ = 0, N.__values__ = r, h ? W.__wrapped__ = N : h = N;
          var W = N;
          y = y.__wrapped__;
        }
        return W.__wrapped__ = c, h;
      }
      function iC() {
        var c = this.__wrapped__;
        if (c instanceof xr) {
          var h = c;
          return this.__actions__.length && (h = new xr(this)), h = h.reverse(), h.__actions__.push({
            func: nd,
            args: [$g],
            thisArg: r
          }), new Wi(h, this.__chain__);
        }
        return this.thru($g);
      }
      function sC() {
        return mw(this.__wrapped__, this.__actions__);
      }
      var oC = Yh(function(c, h, y) {
        Tr.call(c, y) ? ++c[y] : fo(c, y, 1);
      });
      function aC(c, h, y) {
        var N = ir(c) ? Cy : XP;
        return y && ii(c, h, y) && (h = r), N(c, Ut(h, 3));
      }
      function cC(c, h) {
        var y = ir(c) ? Ko : Qy;
        return y(c, Ut(h, 3));
      }
      var uC = Mw(Gw), fC = Mw(Yw);
      function lC(c, h) {
        return Bn(id(c, h), 1);
      }
      function hC(c, h) {
        return Bn(id(c, h), x);
      }
      function dC(c, h, y) {
        return y = y === r ? 1 : cr(y), Bn(id(c, h), y);
      }
      function t2(c, h) {
        var y = ir(c) ? qi : Jo;
        return y(c, Ut(h, 3));
      }
      function r2(c, h) {
        var y = ir(c) ? DA : Zy;
        return y(c, Ut(h, 3));
      }
      var pC = Yh(function(c, h, y) {
        Tr.call(c, y) ? c[y].push(h) : fo(c, y, [h]);
      });
      function gC(c, h, y, N) {
        c = hi(c) ? c : Xc(c), y = y && !N ? cr(y) : 0;
        var W = c.length;
        return y < 0 && (y = En(W + y, 0)), ud(c) ? y <= W && c.indexOf(h, y) > -1 : !!W && Fc(c, h, y) > -1;
      }
      var mC = hr(function(c, h, y) {
        var N = -1, W = typeof h == "function", ne = hi(c) ? Ie(c.length) : [];
        return Jo(c, function(fe) {
          ne[++N] = W ? Pn(h, fe, y) : gf(fe, h, y);
        }), ne;
      }), vC = Yh(function(c, h, y) {
        fo(c, y, h);
      });
      function id(c, h) {
        var y = ir(c) ? Xr : sw;
        return y(c, Ut(h, 3));
      }
      function bC(c, h, y, N) {
        return c == null ? [] : (ir(h) || (h = h == null ? [] : [h]), y = N ? r : y, ir(y) || (y = y == null ? [] : [y]), uw(c, h, y));
      }
      var yC = Yh(function(c, h, y) {
        c[y ? 0 : 1].push(h);
      }, function() {
        return [[], []];
      });
      function wC(c, h, y) {
        var N = ir(c) ? Jp : Oy, W = arguments.length < 3;
        return N(c, Ut(h, 4), y, W, Jo);
      }
      function xC(c, h, y) {
        var N = ir(c) ? OA : Oy, W = arguments.length < 3;
        return N(c, Ut(h, 4), y, W, Zy);
      }
      function _C(c, h) {
        var y = ir(c) ? Ko : Qy;
        return y(c, ad(Ut(h, 3)));
      }
      function EC(c) {
        var h = ir(c) ? Gy : gM;
        return h(c);
      }
      function SC(c, h, y) {
        (y ? ii(c, h, y) : h === r) ? h = 1 : h = cr(h);
        var N = ir(c) ? KP : mM;
        return N(c, h);
      }
      function AC(c) {
        var h = ir(c) ? VP : bM;
        return h(c);
      }
      function PC(c) {
        if (c == null)
          return 0;
        if (hi(c))
          return ud(c) ? Uc(c) : c.length;
        var h = Vn(c);
        return h == ie || h == Me ? c.size : gg(c).length;
      }
      function MC(c, h, y) {
        var N = ir(c) ? Xp : yM;
        return y && ii(c, h, y) && (h = r), N(c, Ut(h, 3));
      }
      var IC = hr(function(c, h) {
        if (c == null)
          return [];
        var y = h.length;
        return y > 1 && ii(c, h[0], h[1]) ? h = [] : y > 2 && ii(h[0], h[1], h[2]) && (h = [h[0]]), uw(c, Bn(h, 1), []);
      }), sd = cP || function() {
        return Er.Date.now();
      };
      function CC(c, h) {
        if (typeof h != "function")
          throw new zi(o);
        return c = cr(c), function() {
          if (--c < 1)
            return h.apply(this, arguments);
        };
      }
      function n2(c, h, y) {
        return h = y ? r : h, h = c && h == null ? c.length : h, lo(c, R, r, r, r, r, h);
      }
      function i2(c, h) {
        var y;
        if (typeof h != "function")
          throw new zi(o);
        return c = cr(c), function() {
          return --c > 0 && (y = h.apply(this, arguments)), c <= 1 && (h = r), y;
        };
      }
      var Fg = hr(function(c, h, y) {
        var N = L;
        if (y.length) {
          var W = Go(y, Yc(Fg));
          N |= V;
        }
        return lo(c, N, h, y, W);
      }), s2 = hr(function(c, h, y) {
        var N = L | B;
        if (y.length) {
          var W = Go(y, Yc(s2));
          N |= V;
        }
        return lo(h, N, c, y, W);
      });
      function o2(c, h, y) {
        h = y ? r : h;
        var N = lo(c, q, r, r, r, r, r, h);
        return N.placeholder = o2.placeholder, N;
      }
      function a2(c, h, y) {
        h = y ? r : h;
        var N = lo(c, U, r, r, r, r, r, h);
        return N.placeholder = a2.placeholder, N;
      }
      function c2(c, h, y) {
        var N, W, ne, fe, me, we, We = 0, He = !1, Xe = !1, wt = !0;
        if (typeof c != "function")
          throw new zi(o);
        h = Gi(h) || 0, Zr(y) && (He = !!y.leading, Xe = "maxWait" in y, ne = Xe ? En(Gi(y.maxWait) || 0, h) : ne, wt = "trailing" in y ? !!y.trailing : wt);
        function Ot(un) {
          var ms = N, vo = W;
          return N = W = r, We = un, fe = c.apply(vo, ms), fe;
        }
        function Ht(un) {
          return We = un, me = wf(br, h), He ? Ot(un) : fe;
        }
        function fr(un) {
          var ms = un - we, vo = un - We, M2 = h - ms;
          return Xe ? Kn(M2, ne - vo) : M2;
        }
        function Kt(un) {
          var ms = un - we, vo = un - We;
          return we === r || ms >= h || ms < 0 || Xe && vo >= ne;
        }
        function br() {
          var un = sd();
          if (Kt(un))
            return Sr(un);
          me = wf(br, fr(un));
        }
        function Sr(un) {
          return me = r, wt && N ? Ot(un) : (N = W = r, fe);
        }
        function Ti() {
          me !== r && bw(me), We = 0, N = we = W = me = r;
        }
        function si() {
          return me === r ? fe : Sr(sd());
        }
        function Ri() {
          var un = sd(), ms = Kt(un);
          if (N = arguments, W = this, we = un, ms) {
            if (me === r)
              return Ht(we);
            if (Xe)
              return bw(me), me = wf(br, h), Ot(we);
          }
          return me === r && (me = wf(br, h)), fe;
        }
        return Ri.cancel = Ti, Ri.flush = si, Ri;
      }
      var TC = hr(function(c, h) {
        return Xy(c, 1, h);
      }), RC = hr(function(c, h, y) {
        return Xy(c, Gi(h) || 0, y);
      });
      function DC(c) {
        return lo(c, ge);
      }
      function od(c, h) {
        if (typeof c != "function" || h != null && typeof h != "function")
          throw new zi(o);
        var y = function() {
          var N = arguments, W = h ? h.apply(this, N) : N[0], ne = y.cache;
          if (ne.has(W))
            return ne.get(W);
          var fe = c.apply(this, N);
          return y.cache = ne.set(W, fe) || ne, fe;
        };
        return y.cache = new (od.Cache || uo)(), y;
      }
      od.Cache = uo;
      function ad(c) {
        if (typeof c != "function")
          throw new zi(o);
        return function() {
          var h = arguments;
          switch (h.length) {
            case 0:
              return !c.call(this);
            case 1:
              return !c.call(this, h[0]);
            case 2:
              return !c.call(this, h[0], h[1]);
            case 3:
              return !c.call(this, h[0], h[1], h[2]);
          }
          return !c.apply(this, h);
        };
      }
      function OC(c) {
        return i2(2, c);
      }
      var NC = wM(function(c, h) {
        h = h.length == 1 && ir(h[0]) ? Xr(h[0], Mi(Ut())) : Xr(Bn(h, 1), Mi(Ut()));
        var y = h.length;
        return hr(function(N) {
          for (var W = -1, ne = Kn(N.length, y); ++W < ne; )
            N[W] = h[W].call(this, N[W]);
          return Pn(c, this, N);
        });
      }), jg = hr(function(c, h) {
        var y = Go(h, Yc(jg));
        return lo(c, V, r, h, y);
      }), u2 = hr(function(c, h) {
        var y = Go(h, Yc(u2));
        return lo(c, Q, r, h, y);
      }), LC = ho(function(c, h) {
        return lo(c, K, r, r, r, h);
      });
      function kC(c, h) {
        if (typeof c != "function")
          throw new zi(o);
        return h = h === r ? h : cr(h), hr(c, h);
      }
      function $C(c, h) {
        if (typeof c != "function")
          throw new zi(o);
        return h = h == null ? 0 : En(cr(h), 0), hr(function(y) {
          var N = y[h], W = Qo(y, 0, h);
          return N && Vo(W, N), Pn(c, this, W);
        });
      }
      function BC(c, h, y) {
        var N = !0, W = !0;
        if (typeof c != "function")
          throw new zi(o);
        return Zr(y) && (N = "leading" in y ? !!y.leading : N, W = "trailing" in y ? !!y.trailing : W), c2(c, h, {
          leading: N,
          maxWait: h,
          trailing: W
        });
      }
      function FC(c) {
        return n2(c, 1);
      }
      function jC(c, h) {
        return jg(Sg(h), c);
      }
      function UC() {
        if (!arguments.length)
          return [];
        var c = arguments[0];
        return ir(c) ? c : [c];
      }
      function qC(c) {
        return Hi(c, _);
      }
      function zC(c, h) {
        return h = typeof h == "function" ? h : r, Hi(c, _, h);
      }
      function WC(c) {
        return Hi(c, p | _);
      }
      function HC(c, h) {
        return h = typeof h == "function" ? h : r, Hi(c, p | _, h);
      }
      function KC(c, h) {
        return h == null || Jy(c, h, Mn(h));
      }
      function gs(c, h) {
        return c === h || c !== c && h !== h;
      }
      var VC = Qh(hg), GC = Qh(function(c, h) {
        return c >= h;
      }), Va = rw(/* @__PURE__ */ function() {
        return arguments;
      }()) ? rw : function(c) {
        return en(c) && Tr.call(c, "callee") && !qy.call(c, "callee");
      }, ir = Ie.isArray, YC = ri ? Mi(ri) : nM;
      function hi(c) {
        return c != null && cd(c.length) && !go(c);
      }
      function cn(c) {
        return en(c) && hi(c);
      }
      function JC(c) {
        return c === !0 || c === !1 || en(c) && ni(c) == J;
      }
      var ea = fP || Xg, XC = hs ? Mi(hs) : iM;
      function ZC(c) {
        return en(c) && c.nodeType === 1 && !xf(c);
      }
      function QC(c) {
        if (c == null)
          return !0;
        if (hi(c) && (ir(c) || typeof c == "string" || typeof c.splice == "function" || ea(c) || Jc(c) || Va(c)))
          return !c.length;
        var h = Vn(c);
        if (h == ie || h == Me)
          return !c.size;
        if (yf(c))
          return !gg(c).length;
        for (var y in c)
          if (Tr.call(c, y))
            return !1;
        return !0;
      }
      function eT(c, h) {
        return mf(c, h);
      }
      function tT(c, h, y) {
        y = typeof y == "function" ? y : r;
        var N = y ? y(c, h) : r;
        return N === r ? mf(c, h, r, y) : !!N;
      }
      function Ug(c) {
        if (!en(c))
          return !1;
        var h = ni(c);
        return h == X || h == T || typeof c.message == "string" && typeof c.name == "string" && !xf(c);
      }
      function rT(c) {
        return typeof c == "number" && Wy(c);
      }
      function go(c) {
        if (!Zr(c))
          return !1;
        var h = ni(c);
        return h == re || h == pe || h == Z || h == Ce;
      }
      function f2(c) {
        return typeof c == "number" && c == cr(c);
      }
      function cd(c) {
        return typeof c == "number" && c > -1 && c % 1 == 0 && c <= E;
      }
      function Zr(c) {
        var h = typeof c;
        return c != null && (h == "object" || h == "function");
      }
      function en(c) {
        return c != null && typeof c == "object";
      }
      var l2 = Ui ? Mi(Ui) : oM;
      function nT(c, h) {
        return c === h || pg(c, h, Rg(h));
      }
      function iT(c, h, y) {
        return y = typeof y == "function" ? y : r, pg(c, h, Rg(h), y);
      }
      function sT(c) {
        return h2(c) && c != +c;
      }
      function oT(c) {
        if (zM(c))
          throw new tr(s);
        return nw(c);
      }
      function aT(c) {
        return c === null;
      }
      function cT(c) {
        return c == null;
      }
      function h2(c) {
        return typeof c == "number" || en(c) && ni(c) == ue;
      }
      function xf(c) {
        if (!en(c) || ni(c) != Pe)
          return !1;
        var h = Lh(c);
        if (h === null)
          return !0;
        var y = Tr.call(h, "constructor") && h.constructor;
        return typeof y == "function" && y instanceof y && Rh.call(y) == iP;
      }
      var qg = Ds ? Mi(Ds) : aM;
      function uT(c) {
        return f2(c) && c >= -E && c <= E;
      }
      var d2 = of ? Mi(of) : cM;
      function ud(c) {
        return typeof c == "string" || !ir(c) && en(c) && ni(c) == Ne;
      }
      function Ci(c) {
        return typeof c == "symbol" || en(c) && ni(c) == Ke;
      }
      var Jc = Fa ? Mi(Fa) : uM;
      function fT(c) {
        return c === r;
      }
      function lT(c) {
        return en(c) && Vn(c) == qe;
      }
      function hT(c) {
        return en(c) && ni(c) == ze;
      }
      var dT = Qh(mg), pT = Qh(function(c, h) {
        return c <= h;
      });
      function p2(c) {
        if (!c)
          return [];
        if (hi(c))
          return ud(c) ? ds(c) : li(c);
        if (cf && c[cf])
          return KA(c[cf]());
        var h = Vn(c), y = h == ie ? ng : h == Me ? Ih : Xc;
        return y(c);
      }
      function mo(c) {
        if (!c)
          return c === 0 ? c : 0;
        if (c = Gi(c), c === x || c === -x) {
          var h = c < 0 ? -1 : 1;
          return h * S;
        }
        return c === c ? c : 0;
      }
      function cr(c) {
        var h = mo(c), y = h % 1;
        return h === h ? y ? h - y : h : 0;
      }
      function g2(c) {
        return c ? za(cr(c), 0, M) : 0;
      }
      function Gi(c) {
        if (typeof c == "number")
          return c;
        if (Ci(c))
          return v;
        if (Zr(c)) {
          var h = typeof c.valueOf == "function" ? c.valueOf() : c;
          c = Zr(h) ? h + "" : h;
        }
        if (typeof c != "string")
          return c === 0 ? c : +c;
        c = Ny(c);
        var y = nt.test(c);
        return y || pt.test(c) ? nr(c.slice(2), y ? 2 : 8) : Re.test(c) ? v : +c;
      }
      function m2(c) {
        return Ns(c, di(c));
      }
      function gT(c) {
        return c ? za(cr(c), -E, E) : c === 0 ? c : 0;
      }
      function Cr(c) {
        return c == null ? "" : Ii(c);
      }
      var mT = Vc(function(c, h) {
        if (yf(h) || hi(h)) {
          Ns(h, Mn(h), c);
          return;
        }
        for (var y in h)
          Tr.call(h, y) && df(c, y, h[y]);
      }), v2 = Vc(function(c, h) {
        Ns(h, di(h), c);
      }), fd = Vc(function(c, h, y, N) {
        Ns(h, di(h), c, N);
      }), vT = Vc(function(c, h, y, N) {
        Ns(h, Mn(h), c, N);
      }), bT = ho(ug);
      function yT(c, h) {
        var y = Kc(c);
        return h == null ? y : Yy(y, h);
      }
      var wT = hr(function(c, h) {
        c = qr(c);
        var y = -1, N = h.length, W = N > 2 ? h[2] : r;
        for (W && ii(h[0], h[1], W) && (N = 1); ++y < N; )
          for (var ne = h[y], fe = di(ne), me = -1, we = fe.length; ++me < we; ) {
            var We = fe[me], He = c[We];
            (He === r || gs(He, zc[We]) && !Tr.call(c, We)) && (c[We] = ne[We]);
          }
        return c;
      }), xT = hr(function(c) {
        return c.push(r, Nw), Pn(b2, r, c);
      });
      function _T(c, h) {
        return Ty(c, Ut(h, 3), Os);
      }
      function ET(c, h) {
        return Ty(c, Ut(h, 3), lg);
      }
      function ST(c, h) {
        return c == null ? c : fg(c, Ut(h, 3), di);
      }
      function AT(c, h) {
        return c == null ? c : ew(c, Ut(h, 3), di);
      }
      function PT(c, h) {
        return c && Os(c, Ut(h, 3));
      }
      function MT(c, h) {
        return c && lg(c, Ut(h, 3));
      }
      function IT(c) {
        return c == null ? [] : Hh(c, Mn(c));
      }
      function CT(c) {
        return c == null ? [] : Hh(c, di(c));
      }
      function zg(c, h, y) {
        var N = c == null ? r : Wa(c, h);
        return N === r ? y : N;
      }
      function TT(c, h) {
        return c != null && $w(c, h, QP);
      }
      function Wg(c, h) {
        return c != null && $w(c, h, eM);
      }
      var RT = Cw(function(c, h, y) {
        h != null && typeof h.toString != "function" && (h = Dh.call(h)), c[h] = y;
      }, Kg(pi)), DT = Cw(function(c, h, y) {
        h != null && typeof h.toString != "function" && (h = Dh.call(h)), Tr.call(c, h) ? c[h].push(y) : c[h] = [y];
      }, Ut), OT = hr(gf);
      function Mn(c) {
        return hi(c) ? Vy(c) : gg(c);
      }
      function di(c) {
        return hi(c) ? Vy(c, !0) : fM(c);
      }
      function NT(c, h) {
        var y = {};
        return h = Ut(h, 3), Os(c, function(N, W, ne) {
          fo(y, h(N, W, ne), N);
        }), y;
      }
      function LT(c, h) {
        var y = {};
        return h = Ut(h, 3), Os(c, function(N, W, ne) {
          fo(y, W, h(N, W, ne));
        }), y;
      }
      var kT = Vc(function(c, h, y) {
        Kh(c, h, y);
      }), b2 = Vc(function(c, h, y, N) {
        Kh(c, h, y, N);
      }), $T = ho(function(c, h) {
        var y = {};
        if (c == null)
          return y;
        var N = !1;
        h = Xr(h, function(ne) {
          return ne = Zo(ne, c), N || (N = ne.length > 1), ne;
        }), Ns(c, Cg(c), y), N && (y = Hi(y, p | w | _, RM));
        for (var W = h.length; W--; )
          xg(y, h[W]);
        return y;
      });
      function BT(c, h) {
        return y2(c, ad(Ut(h)));
      }
      var FT = ho(function(c, h) {
        return c == null ? {} : hM(c, h);
      });
      function y2(c, h) {
        if (c == null)
          return {};
        var y = Xr(Cg(c), function(N) {
          return [N];
        });
        return h = Ut(h), fw(c, y, function(N, W) {
          return h(N, W[0]);
        });
      }
      function jT(c, h, y) {
        h = Zo(h, c);
        var N = -1, W = h.length;
        for (W || (W = 1, c = r); ++N < W; ) {
          var ne = c == null ? r : c[Ls(h[N])];
          ne === r && (N = W, ne = y), c = go(ne) ? ne.call(c) : ne;
        }
        return c;
      }
      function UT(c, h, y) {
        return c == null ? c : vf(c, h, y);
      }
      function qT(c, h, y, N) {
        return N = typeof N == "function" ? N : r, c == null ? c : vf(c, h, y, N);
      }
      var w2 = Dw(Mn), x2 = Dw(di);
      function zT(c, h, y) {
        var N = ir(c), W = N || ea(c) || Jc(c);
        if (h = Ut(h, 4), y == null) {
          var ne = c && c.constructor;
          W ? y = N ? new ne() : [] : Zr(c) ? y = go(ne) ? Kc(Lh(c)) : {} : y = {};
        }
        return (W ? qi : Os)(c, function(fe, me, we) {
          return h(y, fe, me, we);
        }), y;
      }
      function WT(c, h) {
        return c == null ? !0 : xg(c, h);
      }
      function HT(c, h, y) {
        return c == null ? c : gw(c, h, Sg(y));
      }
      function KT(c, h, y, N) {
        return N = typeof N == "function" ? N : r, c == null ? c : gw(c, h, Sg(y), N);
      }
      function Xc(c) {
        return c == null ? [] : rg(c, Mn(c));
      }
      function VT(c) {
        return c == null ? [] : rg(c, di(c));
      }
      function GT(c, h, y) {
        return y === r && (y = h, h = r), y !== r && (y = Gi(y), y = y === y ? y : 0), h !== r && (h = Gi(h), h = h === h ? h : 0), za(Gi(c), h, y);
      }
      function YT(c, h, y) {
        return h = mo(h), y === r ? (y = h, h = 0) : y = mo(y), c = Gi(c), tM(c, h, y);
      }
      function JT(c, h, y) {
        if (y && typeof y != "boolean" && ii(c, h, y) && (h = y = r), y === r && (typeof h == "boolean" ? (y = h, h = r) : typeof c == "boolean" && (y = c, c = r)), c === r && h === r ? (c = 0, h = 1) : (c = mo(c), h === r ? (h = c, c = 0) : h = mo(h)), c > h) {
          var N = c;
          c = h, h = N;
        }
        if (y || c % 1 || h % 1) {
          var W = Hy();
          return Kn(c + W * (h - c + jr("1e-" + ((W + "").length - 1))), h);
        }
        return bg(c, h);
      }
      var XT = Gc(function(c, h, y) {
        return h = h.toLowerCase(), c + (y ? _2(h) : h);
      });
      function _2(c) {
        return Hg(Cr(c).toLowerCase());
      }
      function E2(c) {
        return c = Cr(c), c && c.replace(et, UA).replace(Vp, "");
      }
      function ZT(c, h, y) {
        c = Cr(c), h = Ii(h);
        var N = c.length;
        y = y === r ? N : za(cr(y), 0, N);
        var W = y;
        return y -= h.length, y >= 0 && c.slice(y, W) == h;
      }
      function QT(c) {
        return c = Cr(c), c && Ct.test(c) ? c.replace(Dt, qA) : c;
      }
      function eR(c) {
        return c = Cr(c), c && Bt.test(c) ? c.replace(rt, "\\$&") : c;
      }
      var tR = Gc(function(c, h, y) {
        return c + (y ? "-" : "") + h.toLowerCase();
      }), rR = Gc(function(c, h, y) {
        return c + (y ? " " : "") + h.toLowerCase();
      }), nR = Pw("toLowerCase");
      function iR(c, h, y) {
        c = Cr(c), h = cr(h);
        var N = h ? Uc(c) : 0;
        if (!h || N >= h)
          return c;
        var W = (h - N) / 2;
        return Zh(Fh(W), y) + c + Zh(Bh(W), y);
      }
      function sR(c, h, y) {
        c = Cr(c), h = cr(h);
        var N = h ? Uc(c) : 0;
        return h && N < h ? c + Zh(h - N, y) : c;
      }
      function oR(c, h, y) {
        c = Cr(c), h = cr(h);
        var N = h ? Uc(c) : 0;
        return h && N < h ? Zh(h - N, y) + c : c;
      }
      function aR(c, h, y) {
        return y || h == null ? h = 0 : h && (h = +h), pP(Cr(c).replace($, ""), h || 0);
      }
      function cR(c, h, y) {
        return (y ? ii(c, h, y) : h === r) ? h = 1 : h = cr(h), yg(Cr(c), h);
      }
      function uR() {
        var c = arguments, h = Cr(c[0]);
        return c.length < 3 ? h : h.replace(c[1], c[2]);
      }
      var fR = Gc(function(c, h, y) {
        return c + (y ? "_" : "") + h.toLowerCase();
      });
      function lR(c, h, y) {
        return y && typeof y != "number" && ii(c, h, y) && (h = y = r), y = y === r ? M : y >>> 0, y ? (c = Cr(c), c && (typeof h == "string" || h != null && !qg(h)) && (h = Ii(h), !h && jc(c)) ? Qo(ds(c), 0, y) : c.split(h, y)) : [];
      }
      var hR = Gc(function(c, h, y) {
        return c + (y ? " " : "") + Hg(h);
      });
      function dR(c, h, y) {
        return c = Cr(c), y = y == null ? 0 : za(cr(y), 0, c.length), h = Ii(h), c.slice(y, y + h.length) == h;
      }
      function pR(c, h, y) {
        var N = te.templateSettings;
        y && ii(c, h, y) && (h = r), c = Cr(c), h = fd({}, h, N, Ow);
        var W = fd({}, h.imports, N.imports, Ow), ne = Mn(W), fe = rg(W, ne), me, we, We = 0, He = h.interpolate || St, Xe = "__p += '", wt = ig(
          (h.escape || St).source + "|" + He.source + "|" + (He === Nt ? xe : St).source + "|" + (h.evaluate || St).source + "|$",
          "g"
        ), Ot = "//# sourceURL=" + (Tr.call(h, "sourceURL") ? (h.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Gp + "]") + `
`;
        c.replace(wt, function(Kt, br, Sr, Ti, si, Ri) {
          return Sr || (Sr = Ti), Xe += c.slice(We, Ri).replace(Tt, zA), br && (me = !0, Xe += `' +
__e(` + br + `) +
'`), si && (we = !0, Xe += `';
` + si + `;
__p += '`), Sr && (Xe += `' +
((__t = (` + Sr + `)) == null ? '' : __t) +
'`), We = Ri + Kt.length, Kt;
        }), Xe += `';
`;
        var Ht = Tr.call(h, "variable") && h.variable;
        if (!Ht)
          Xe = `with (obj) {
` + Xe + `
}
`;
        else if (se.test(Ht))
          throw new tr(a);
        Xe = (we ? Xe.replace(Jt, "") : Xe).replace(Et, "$1").replace(er, "$1;"), Xe = "function(" + (Ht || "obj") + `) {
` + (Ht ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (me ? ", __e = _.escape" : "") + (we ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Xe + `return __p
}`;
        var fr = A2(function() {
          return Mr(ne, Ot + "return " + Xe).apply(r, fe);
        });
        if (fr.source = Xe, Ug(fr))
          throw fr;
        return fr;
      }
      function gR(c) {
        return Cr(c).toLowerCase();
      }
      function mR(c) {
        return Cr(c).toUpperCase();
      }
      function vR(c, h, y) {
        if (c = Cr(c), c && (y || h === r))
          return Ny(c);
        if (!c || !(h = Ii(h)))
          return c;
        var N = ds(c), W = ds(h), ne = Ly(N, W), fe = ky(N, W) + 1;
        return Qo(N, ne, fe).join("");
      }
      function bR(c, h, y) {
        if (c = Cr(c), c && (y || h === r))
          return c.slice(0, By(c) + 1);
        if (!c || !(h = Ii(h)))
          return c;
        var N = ds(c), W = ky(N, ds(h)) + 1;
        return Qo(N, 0, W).join("");
      }
      function yR(c, h, y) {
        if (c = Cr(c), c && (y || h === r))
          return c.replace($, "");
        if (!c || !(h = Ii(h)))
          return c;
        var N = ds(c), W = Ly(N, ds(h));
        return Qo(N, W).join("");
      }
      function wR(c, h) {
        var y = Ee, N = Y;
        if (Zr(h)) {
          var W = "separator" in h ? h.separator : W;
          y = "length" in h ? cr(h.length) : y, N = "omission" in h ? Ii(h.omission) : N;
        }
        c = Cr(c);
        var ne = c.length;
        if (jc(c)) {
          var fe = ds(c);
          ne = fe.length;
        }
        if (y >= ne)
          return c;
        var me = y - Uc(N);
        if (me < 1)
          return N;
        var we = fe ? Qo(fe, 0, me).join("") : c.slice(0, me);
        if (W === r)
          return we + N;
        if (fe && (me += we.length - me), qg(W)) {
          if (c.slice(me).search(W)) {
            var We, He = we;
            for (W.global || (W = ig(W.source, Cr(Te.exec(W)) + "g")), W.lastIndex = 0; We = W.exec(He); )
              var Xe = We.index;
            we = we.slice(0, Xe === r ? me : Xe);
          }
        } else if (c.indexOf(Ii(W), me) != me) {
          var wt = we.lastIndexOf(W);
          wt > -1 && (we = we.slice(0, wt));
        }
        return we + N;
      }
      function xR(c) {
        return c = Cr(c), c && kt.test(c) ? c.replace(Xt, JA) : c;
      }
      var _R = Gc(function(c, h, y) {
        return c + (y ? " " : "") + h.toUpperCase();
      }), Hg = Pw("toUpperCase");
      function S2(c, h, y) {
        return c = Cr(c), h = y ? r : h, h === r ? HA(c) ? QA(c) : kA(c) : c.match(h) || [];
      }
      var A2 = hr(function(c, h) {
        try {
          return Pn(c, r, h);
        } catch (y) {
          return Ug(y) ? y : new tr(y);
        }
      }), ER = ho(function(c, h) {
        return qi(h, function(y) {
          y = Ls(y), fo(c, y, Fg(c[y], c));
        }), c;
      });
      function SR(c) {
        var h = c == null ? 0 : c.length, y = Ut();
        return c = h ? Xr(c, function(N) {
          if (typeof N[1] != "function")
            throw new zi(o);
          return [y(N[0]), N[1]];
        }) : [], hr(function(N) {
          for (var W = -1; ++W < h; ) {
            var ne = c[W];
            if (Pn(ne[0], this, N))
              return Pn(ne[1], this, N);
          }
        });
      }
      function AR(c) {
        return JP(Hi(c, p));
      }
      function Kg(c) {
        return function() {
          return c;
        };
      }
      function PR(c, h) {
        return c == null || c !== c ? h : c;
      }
      var MR = Iw(), IR = Iw(!0);
      function pi(c) {
        return c;
      }
      function Vg(c) {
        return iw(typeof c == "function" ? c : Hi(c, p));
      }
      function CR(c) {
        return ow(Hi(c, p));
      }
      function TR(c, h) {
        return aw(c, Hi(h, p));
      }
      var RR = hr(function(c, h) {
        return function(y) {
          return gf(y, c, h);
        };
      }), DR = hr(function(c, h) {
        return function(y) {
          return gf(c, y, h);
        };
      });
      function Gg(c, h, y) {
        var N = Mn(h), W = Hh(h, N);
        y == null && !(Zr(h) && (W.length || !N.length)) && (y = h, h = c, c = this, W = Hh(h, Mn(h)));
        var ne = !(Zr(y) && "chain" in y) || !!y.chain, fe = go(c);
        return qi(W, function(me) {
          var we = h[me];
          c[me] = we, fe && (c.prototype[me] = function() {
            var We = this.__chain__;
            if (ne || We) {
              var He = c(this.__wrapped__), Xe = He.__actions__ = li(this.__actions__);
              return Xe.push({ func: we, args: arguments, thisArg: c }), He.__chain__ = We, He;
            }
            return we.apply(c, Vo([this.value()], arguments));
          });
        }), c;
      }
      function OR() {
        return Er._ === this && (Er._ = sP), this;
      }
      function Yg() {
      }
      function NR(c) {
        return c = cr(c), hr(function(h) {
          return cw(h, c);
        });
      }
      var LR = Pg(Xr), kR = Pg(Cy), $R = Pg(Xp);
      function P2(c) {
        return Og(c) ? Zp(Ls(c)) : dM(c);
      }
      function BR(c) {
        return function(h) {
          return c == null ? r : Wa(c, h);
        };
      }
      var FR = Tw(), jR = Tw(!0);
      function Jg() {
        return [];
      }
      function Xg() {
        return !1;
      }
      function UR() {
        return {};
      }
      function qR() {
        return "";
      }
      function zR() {
        return !0;
      }
      function WR(c, h) {
        if (c = cr(c), c < 1 || c > E)
          return [];
        var y = M, N = Kn(c, M);
        h = Ut(h), c -= M;
        for (var W = tg(N, h); ++y < c; )
          h(y);
        return W;
      }
      function HR(c) {
        return ir(c) ? Xr(c, Ls) : Ci(c) ? [c] : li(Kw(Cr(c)));
      }
      function KR(c) {
        var h = ++nP;
        return Cr(c) + h;
      }
      var VR = Xh(function(c, h) {
        return c + h;
      }, 0), GR = Mg("ceil"), YR = Xh(function(c, h) {
        return c / h;
      }, 1), JR = Mg("floor");
      function XR(c) {
        return c && c.length ? Wh(c, pi, hg) : r;
      }
      function ZR(c, h) {
        return c && c.length ? Wh(c, Ut(h, 2), hg) : r;
      }
      function QR(c) {
        return Dy(c, pi);
      }
      function eD(c, h) {
        return Dy(c, Ut(h, 2));
      }
      function tD(c) {
        return c && c.length ? Wh(c, pi, mg) : r;
      }
      function rD(c, h) {
        return c && c.length ? Wh(c, Ut(h, 2), mg) : r;
      }
      var nD = Xh(function(c, h) {
        return c * h;
      }, 1), iD = Mg("round"), sD = Xh(function(c, h) {
        return c - h;
      }, 0);
      function oD(c) {
        return c && c.length ? eg(c, pi) : 0;
      }
      function aD(c, h) {
        return c && c.length ? eg(c, Ut(h, 2)) : 0;
      }
      return te.after = CC, te.ary = n2, te.assign = mT, te.assignIn = v2, te.assignInWith = fd, te.assignWith = vT, te.at = bT, te.before = i2, te.bind = Fg, te.bindAll = ER, te.bindKey = s2, te.castArray = UC, te.chain = e2, te.chunk = JM, te.compact = XM, te.concat = ZM, te.cond = SR, te.conforms = AR, te.constant = Kg, te.countBy = oC, te.create = yT, te.curry = o2, te.curryRight = a2, te.debounce = c2, te.defaults = wT, te.defaultsDeep = xT, te.defer = TC, te.delay = RC, te.difference = QM, te.differenceBy = eI, te.differenceWith = tI, te.drop = rI, te.dropRight = nI, te.dropRightWhile = iI, te.dropWhile = sI, te.fill = oI, te.filter = cC, te.flatMap = lC, te.flatMapDeep = hC, te.flatMapDepth = dC, te.flatten = Jw, te.flattenDeep = aI, te.flattenDepth = cI, te.flip = DC, te.flow = MR, te.flowRight = IR, te.fromPairs = uI, te.functions = IT, te.functionsIn = CT, te.groupBy = pC, te.initial = lI, te.intersection = hI, te.intersectionBy = dI, te.intersectionWith = pI, te.invert = RT, te.invertBy = DT, te.invokeMap = mC, te.iteratee = Vg, te.keyBy = vC, te.keys = Mn, te.keysIn = di, te.map = id, te.mapKeys = NT, te.mapValues = LT, te.matches = CR, te.matchesProperty = TR, te.memoize = od, te.merge = kT, te.mergeWith = b2, te.method = RR, te.methodOf = DR, te.mixin = Gg, te.negate = ad, te.nthArg = NR, te.omit = $T, te.omitBy = BT, te.once = OC, te.orderBy = bC, te.over = LR, te.overArgs = NC, te.overEvery = kR, te.overSome = $R, te.partial = jg, te.partialRight = u2, te.partition = yC, te.pick = FT, te.pickBy = y2, te.property = P2, te.propertyOf = BR, te.pull = bI, te.pullAll = Zw, te.pullAllBy = yI, te.pullAllWith = wI, te.pullAt = xI, te.range = FR, te.rangeRight = jR, te.rearg = LC, te.reject = _C, te.remove = _I, te.rest = kC, te.reverse = $g, te.sampleSize = SC, te.set = UT, te.setWith = qT, te.shuffle = AC, te.slice = EI, te.sortBy = IC, te.sortedUniq = TI, te.sortedUniqBy = RI, te.split = lR, te.spread = $C, te.tail = DI, te.take = OI, te.takeRight = NI, te.takeRightWhile = LI, te.takeWhile = kI, te.tap = XI, te.throttle = BC, te.thru = nd, te.toArray = p2, te.toPairs = w2, te.toPairsIn = x2, te.toPath = HR, te.toPlainObject = m2, te.transform = zT, te.unary = FC, te.union = $I, te.unionBy = BI, te.unionWith = FI, te.uniq = jI, te.uniqBy = UI, te.uniqWith = qI, te.unset = WT, te.unzip = Bg, te.unzipWith = Qw, te.update = HT, te.updateWith = KT, te.values = Xc, te.valuesIn = VT, te.without = zI, te.words = S2, te.wrap = jC, te.xor = WI, te.xorBy = HI, te.xorWith = KI, te.zip = VI, te.zipObject = GI, te.zipObjectDeep = YI, te.zipWith = JI, te.entries = w2, te.entriesIn = x2, te.extend = v2, te.extendWith = fd, Gg(te, te), te.add = VR, te.attempt = A2, te.camelCase = XT, te.capitalize = _2, te.ceil = GR, te.clamp = GT, te.clone = qC, te.cloneDeep = WC, te.cloneDeepWith = HC, te.cloneWith = zC, te.conformsTo = KC, te.deburr = E2, te.defaultTo = PR, te.divide = YR, te.endsWith = ZT, te.eq = gs, te.escape = QT, te.escapeRegExp = eR, te.every = aC, te.find = uC, te.findIndex = Gw, te.findKey = _T, te.findLast = fC, te.findLastIndex = Yw, te.findLastKey = ET, te.floor = JR, te.forEach = t2, te.forEachRight = r2, te.forIn = ST, te.forInRight = AT, te.forOwn = PT, te.forOwnRight = MT, te.get = zg, te.gt = VC, te.gte = GC, te.has = TT, te.hasIn = Wg, te.head = Xw, te.identity = pi, te.includes = gC, te.indexOf = fI, te.inRange = YT, te.invoke = OT, te.isArguments = Va, te.isArray = ir, te.isArrayBuffer = YC, te.isArrayLike = hi, te.isArrayLikeObject = cn, te.isBoolean = JC, te.isBuffer = ea, te.isDate = XC, te.isElement = ZC, te.isEmpty = QC, te.isEqual = eT, te.isEqualWith = tT, te.isError = Ug, te.isFinite = rT, te.isFunction = go, te.isInteger = f2, te.isLength = cd, te.isMap = l2, te.isMatch = nT, te.isMatchWith = iT, te.isNaN = sT, te.isNative = oT, te.isNil = cT, te.isNull = aT, te.isNumber = h2, te.isObject = Zr, te.isObjectLike = en, te.isPlainObject = xf, te.isRegExp = qg, te.isSafeInteger = uT, te.isSet = d2, te.isString = ud, te.isSymbol = Ci, te.isTypedArray = Jc, te.isUndefined = fT, te.isWeakMap = lT, te.isWeakSet = hT, te.join = gI, te.kebabCase = tR, te.last = Vi, te.lastIndexOf = mI, te.lowerCase = rR, te.lowerFirst = nR, te.lt = dT, te.lte = pT, te.max = XR, te.maxBy = ZR, te.mean = QR, te.meanBy = eD, te.min = tD, te.minBy = rD, te.stubArray = Jg, te.stubFalse = Xg, te.stubObject = UR, te.stubString = qR, te.stubTrue = zR, te.multiply = nD, te.nth = vI, te.noConflict = OR, te.noop = Yg, te.now = sd, te.pad = iR, te.padEnd = sR, te.padStart = oR, te.parseInt = aR, te.random = JT, te.reduce = wC, te.reduceRight = xC, te.repeat = cR, te.replace = uR, te.result = jT, te.round = iD, te.runInContext = be, te.sample = EC, te.size = PC, te.snakeCase = fR, te.some = MC, te.sortedIndex = SI, te.sortedIndexBy = AI, te.sortedIndexOf = PI, te.sortedLastIndex = MI, te.sortedLastIndexBy = II, te.sortedLastIndexOf = CI, te.startCase = hR, te.startsWith = dR, te.subtract = sD, te.sum = oD, te.sumBy = aD, te.template = pR, te.times = WR, te.toFinite = mo, te.toInteger = cr, te.toLength = g2, te.toLower = gR, te.toNumber = Gi, te.toSafeInteger = gT, te.toString = Cr, te.toUpper = mR, te.trim = vR, te.trimEnd = bR, te.trimStart = yR, te.truncate = wR, te.unescape = xR, te.uniqueId = KR, te.upperCase = _R, te.upperFirst = Hg, te.each = t2, te.eachRight = r2, te.first = Xw, Gg(te, function() {
        var c = {};
        return Os(te, function(h, y) {
          Tr.call(te.prototype, y) || (c[y] = h);
        }), c;
      }(), { chain: !1 }), te.VERSION = n, qi(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(c) {
        te[c].placeholder = te;
      }), qi(["drop", "take"], function(c, h) {
        xr.prototype[c] = function(y) {
          y = y === r ? 1 : En(cr(y), 0);
          var N = this.__filtered__ && !h ? new xr(this) : this.clone();
          return N.__filtered__ ? N.__takeCount__ = Kn(y, N.__takeCount__) : N.__views__.push({
            size: Kn(y, M),
            type: c + (N.__dir__ < 0 ? "Right" : "")
          }), N;
        }, xr.prototype[c + "Right"] = function(y) {
          return this.reverse()[c](y).reverse();
        };
      }), qi(["filter", "map", "takeWhile"], function(c, h) {
        var y = h + 1, N = y == f || y == b;
        xr.prototype[c] = function(W) {
          var ne = this.clone();
          return ne.__iteratees__.push({
            iteratee: Ut(W, 3),
            type: y
          }), ne.__filtered__ = ne.__filtered__ || N, ne;
        };
      }), qi(["head", "last"], function(c, h) {
        var y = "take" + (h ? "Right" : "");
        xr.prototype[c] = function() {
          return this[y](1).value()[0];
        };
      }), qi(["initial", "tail"], function(c, h) {
        var y = "drop" + (h ? "" : "Right");
        xr.prototype[c] = function() {
          return this.__filtered__ ? new xr(this) : this[y](1);
        };
      }), xr.prototype.compact = function() {
        return this.filter(pi);
      }, xr.prototype.find = function(c) {
        return this.filter(c).head();
      }, xr.prototype.findLast = function(c) {
        return this.reverse().find(c);
      }, xr.prototype.invokeMap = hr(function(c, h) {
        return typeof c == "function" ? new xr(this) : this.map(function(y) {
          return gf(y, c, h);
        });
      }), xr.prototype.reject = function(c) {
        return this.filter(ad(Ut(c)));
      }, xr.prototype.slice = function(c, h) {
        c = cr(c);
        var y = this;
        return y.__filtered__ && (c > 0 || h < 0) ? new xr(y) : (c < 0 ? y = y.takeRight(-c) : c && (y = y.drop(c)), h !== r && (h = cr(h), y = h < 0 ? y.dropRight(-h) : y.take(h - c)), y);
      }, xr.prototype.takeRightWhile = function(c) {
        return this.reverse().takeWhile(c).reverse();
      }, xr.prototype.toArray = function() {
        return this.take(M);
      }, Os(xr.prototype, function(c, h) {
        var y = /^(?:filter|find|map|reject)|While$/.test(h), N = /^(?:head|last)$/.test(h), W = te[N ? "take" + (h == "last" ? "Right" : "") : h], ne = N || /^find/.test(h);
        W && (te.prototype[h] = function() {
          var fe = this.__wrapped__, me = N ? [1] : arguments, we = fe instanceof xr, We = me[0], He = we || ir(fe), Xe = function(br) {
            var Sr = W.apply(te, Vo([br], me));
            return N && wt ? Sr[0] : Sr;
          };
          He && y && typeof We == "function" && We.length != 1 && (we = He = !1);
          var wt = this.__chain__, Ot = !!this.__actions__.length, Ht = ne && !wt, fr = we && !Ot;
          if (!ne && He) {
            fe = fr ? fe : new xr(this);
            var Kt = c.apply(fe, me);
            return Kt.__actions__.push({ func: nd, args: [Xe], thisArg: r }), new Wi(Kt, wt);
          }
          return Ht && fr ? c.apply(this, me) : (Kt = this.thru(Xe), Ht ? N ? Kt.value()[0] : Kt.value() : Kt);
        });
      }), qi(["pop", "push", "shift", "sort", "splice", "unshift"], function(c) {
        var h = Ch[c], y = /^(?:push|sort|unshift)$/.test(c) ? "tap" : "thru", N = /^(?:pop|shift)$/.test(c);
        te.prototype[c] = function() {
          var W = arguments;
          if (N && !this.__chain__) {
            var ne = this.value();
            return h.apply(ir(ne) ? ne : [], W);
          }
          return this[y](function(fe) {
            return h.apply(ir(fe) ? fe : [], W);
          });
        };
      }), Os(xr.prototype, function(c, h) {
        var y = te[h];
        if (y) {
          var N = y.name + "";
          Tr.call(Hc, N) || (Hc[N] = []), Hc[N].push({ name: h, func: y });
        }
      }), Hc[Jh(r, B).name] = [{
        name: "wrapper",
        func: r
      }], xr.prototype.clone = xP, xr.prototype.reverse = _P, xr.prototype.value = EP, te.prototype.at = ZI, te.prototype.chain = QI, te.prototype.commit = eC, te.prototype.next = tC, te.prototype.plant = nC, te.prototype.reverse = iC, te.prototype.toJSON = te.prototype.valueOf = te.prototype.value = sC, te.prototype.first = te.prototype.head, cf && (te.prototype[cf] = rC), te;
    }, qc = eP();
    an ? ((an.exports = qc)._ = qc, Ur._ = qc) : Er._ = qc;
  }).call(gn);
})(S0, S0.exports);
var RG = S0.exports, Y1 = { exports: {} };
(function(t, e) {
  var r = typeof self < "u" ? self : gn, n = function() {
    function s() {
      this.fetch = !1, this.DOMException = r.DOMException;
    }
    return s.prototype = r, new s();
  }();
  (function(s) {
    (function(o) {
      var a = {
        searchParams: "URLSearchParams" in s,
        iterable: "Symbol" in s && "iterator" in Symbol,
        blob: "FileReader" in s && "Blob" in s && function() {
          try {
            return new Blob(), !0;
          } catch {
            return !1;
          }
        }(),
        formData: "FormData" in s,
        arrayBuffer: "ArrayBuffer" in s
      };
      function u(f) {
        return f && DataView.prototype.isPrototypeOf(f);
      }
      if (a.arrayBuffer)
        var l = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ], d = ArrayBuffer.isView || function(f) {
          return f && l.indexOf(Object.prototype.toString.call(f)) > -1;
        };
      function p(f) {
        if (typeof f != "string" && (f = String(f)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(f))
          throw new TypeError("Invalid character in header field name");
        return f.toLowerCase();
      }
      function w(f) {
        return typeof f != "string" && (f = String(f)), f;
      }
      function _(f) {
        var g = {
          next: function() {
            var b = f.shift();
            return { done: b === void 0, value: b };
          }
        };
        return a.iterable && (g[Symbol.iterator] = function() {
          return g;
        }), g;
      }
      function P(f) {
        this.map = {}, f instanceof P ? f.forEach(function(g, b) {
          this.append(b, g);
        }, this) : Array.isArray(f) ? f.forEach(function(g) {
          this.append(g[0], g[1]);
        }, this) : f && Object.getOwnPropertyNames(f).forEach(function(g) {
          this.append(g, f[g]);
        }, this);
      }
      P.prototype.append = function(f, g) {
        f = p(f), g = w(g);
        var b = this.map[f];
        this.map[f] = b ? b + ", " + g : g;
      }, P.prototype.delete = function(f) {
        delete this.map[p(f)];
      }, P.prototype.get = function(f) {
        return f = p(f), this.has(f) ? this.map[f] : null;
      }, P.prototype.has = function(f) {
        return this.map.hasOwnProperty(p(f));
      }, P.prototype.set = function(f, g) {
        this.map[p(f)] = w(g);
      }, P.prototype.forEach = function(f, g) {
        for (var b in this.map)
          this.map.hasOwnProperty(b) && f.call(g, this.map[b], b, this);
      }, P.prototype.keys = function() {
        var f = [];
        return this.forEach(function(g, b) {
          f.push(b);
        }), _(f);
      }, P.prototype.values = function() {
        var f = [];
        return this.forEach(function(g) {
          f.push(g);
        }), _(f);
      }, P.prototype.entries = function() {
        var f = [];
        return this.forEach(function(g, b) {
          f.push([b, g]);
        }), _(f);
      }, a.iterable && (P.prototype[Symbol.iterator] = P.prototype.entries);
      function O(f) {
        if (f.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        f.bodyUsed = !0;
      }
      function L(f) {
        return new Promise(function(g, b) {
          f.onload = function() {
            g(f.result);
          }, f.onerror = function() {
            b(f.error);
          };
        });
      }
      function B(f) {
        var g = new FileReader(), b = L(g);
        return g.readAsArrayBuffer(f), b;
      }
      function k(f) {
        var g = new FileReader(), b = L(g);
        return g.readAsText(f), b;
      }
      function q(f) {
        for (var g = new Uint8Array(f), b = new Array(g.length), x = 0; x < g.length; x++)
          b[x] = String.fromCharCode(g[x]);
        return b.join("");
      }
      function U(f) {
        if (f.slice)
          return f.slice(0);
        var g = new Uint8Array(f.byteLength);
        return g.set(new Uint8Array(f)), g.buffer;
      }
      function V() {
        return this.bodyUsed = !1, this._initBody = function(f) {
          this._bodyInit = f, f ? typeof f == "string" ? this._bodyText = f : a.blob && Blob.prototype.isPrototypeOf(f) ? this._bodyBlob = f : a.formData && FormData.prototype.isPrototypeOf(f) ? this._bodyFormData = f : a.searchParams && URLSearchParams.prototype.isPrototypeOf(f) ? this._bodyText = f.toString() : a.arrayBuffer && a.blob && u(f) ? (this._bodyArrayBuffer = U(f.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : a.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(f) || d(f)) ? this._bodyArrayBuffer = U(f) : this._bodyText = f = Object.prototype.toString.call(f) : this._bodyText = "", this.headers.get("content-type") || (typeof f == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : a.searchParams && URLSearchParams.prototype.isPrototypeOf(f) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, a.blob && (this.blob = function() {
          var f = O(this);
          if (f)
            return f;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? O(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(B);
        }), this.text = function() {
          var f = O(this);
          if (f)
            return f;
          if (this._bodyBlob)
            return k(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(q(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, a.formData && (this.formData = function() {
          return this.text().then(ge);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var Q = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function R(f) {
        var g = f.toUpperCase();
        return Q.indexOf(g) > -1 ? g : f;
      }
      function K(f, g) {
        g = g || {};
        var b = g.body;
        if (f instanceof K) {
          if (f.bodyUsed)
            throw new TypeError("Already read");
          this.url = f.url, this.credentials = f.credentials, g.headers || (this.headers = new P(f.headers)), this.method = f.method, this.mode = f.mode, this.signal = f.signal, !b && f._bodyInit != null && (b = f._bodyInit, f.bodyUsed = !0);
        } else
          this.url = String(f);
        if (this.credentials = g.credentials || this.credentials || "same-origin", (g.headers || !this.headers) && (this.headers = new P(g.headers)), this.method = R(g.method || this.method || "GET"), this.mode = g.mode || this.mode || null, this.signal = g.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && b)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(b);
      }
      K.prototype.clone = function() {
        return new K(this, { body: this._bodyInit });
      };
      function ge(f) {
        var g = new FormData();
        return f.trim().split("&").forEach(function(b) {
          if (b) {
            var x = b.split("="), E = x.shift().replace(/\+/g, " "), S = x.join("=").replace(/\+/g, " ");
            g.append(decodeURIComponent(E), decodeURIComponent(S));
          }
        }), g;
      }
      function Ee(f) {
        var g = new P(), b = f.replace(/\r?\n[\t ]+/g, " ");
        return b.split(/\r?\n/).forEach(function(x) {
          var E = x.split(":"), S = E.shift().trim();
          if (S) {
            var v = E.join(":").trim();
            g.append(S, v);
          }
        }), g;
      }
      V.call(K.prototype);
      function Y(f, g) {
        g || (g = {}), this.type = "default", this.status = g.status === void 0 ? 200 : g.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in g ? g.statusText : "OK", this.headers = new P(g.headers), this.url = g.url || "", this._initBody(f);
      }
      V.call(Y.prototype), Y.prototype.clone = function() {
        return new Y(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new P(this.headers),
          url: this.url
        });
      }, Y.error = function() {
        var f = new Y(null, { status: 0, statusText: "" });
        return f.type = "error", f;
      };
      var A = [301, 302, 303, 307, 308];
      Y.redirect = function(f, g) {
        if (A.indexOf(g) === -1)
          throw new RangeError("Invalid status code");
        return new Y(null, { status: g, headers: { location: f } });
      }, o.DOMException = s.DOMException;
      try {
        new o.DOMException();
      } catch {
        o.DOMException = function(g, b) {
          this.message = g, this.name = b;
          var x = Error(g);
          this.stack = x.stack;
        }, o.DOMException.prototype = Object.create(Error.prototype), o.DOMException.prototype.constructor = o.DOMException;
      }
      function m(f, g) {
        return new Promise(function(b, x) {
          var E = new K(f, g);
          if (E.signal && E.signal.aborted)
            return x(new o.DOMException("Aborted", "AbortError"));
          var S = new XMLHttpRequest();
          function v() {
            S.abort();
          }
          S.onload = function() {
            var M = {
              status: S.status,
              statusText: S.statusText,
              headers: Ee(S.getAllResponseHeaders() || "")
            };
            M.url = "responseURL" in S ? S.responseURL : M.headers.get("X-Request-URL");
            var I = "response" in S ? S.response : S.responseText;
            b(new Y(I, M));
          }, S.onerror = function() {
            x(new TypeError("Network request failed"));
          }, S.ontimeout = function() {
            x(new TypeError("Network request failed"));
          }, S.onabort = function() {
            x(new o.DOMException("Aborted", "AbortError"));
          }, S.open(E.method, E.url, !0), E.credentials === "include" ? S.withCredentials = !0 : E.credentials === "omit" && (S.withCredentials = !1), "responseType" in S && a.blob && (S.responseType = "blob"), E.headers.forEach(function(M, I) {
            S.setRequestHeader(I, M);
          }), E.signal && (E.signal.addEventListener("abort", v), S.onreadystatechange = function() {
            S.readyState === 4 && E.signal.removeEventListener("abort", v);
          }), S.send(typeof E._bodyInit > "u" ? null : E._bodyInit);
        });
      }
      return m.polyfill = !0, s.fetch || (s.fetch = m, s.Headers = P, s.Request = K, s.Response = Y), o.Headers = P, o.Request = K, o.Response = Y, o.fetch = m, Object.defineProperty(o, "__esModule", { value: !0 }), o;
    })({});
  })(n), n.fetch.ponyfill = !0, delete n.fetch.polyfill;
  var i = n;
  e = i.fetch, e.default = i.fetch, e.fetch = i.fetch, e.Headers = i.Headers, e.Request = i.Request, e.Response = i.Response, t.exports = e;
})(Y1, Y1.exports);
var DG = Y1.exports;
const Q3 = /* @__PURE__ */ ns(DG);
var OG = Object.defineProperty, NG = Object.defineProperties, LG = Object.getOwnPropertyDescriptors, e_ = Object.getOwnPropertySymbols, kG = Object.prototype.hasOwnProperty, $G = Object.prototype.propertyIsEnumerable, t_ = (t, e, r) => e in t ? OG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, r_ = (t, e) => {
  for (var r in e || (e = {})) kG.call(e, r) && t_(t, r, e[r]);
  if (e_) for (var r of e_(e)) $G.call(e, r) && t_(t, r, e[r]);
  return t;
}, n_ = (t, e) => NG(t, LG(e));
const BG = { Accept: "application/json", "Content-Type": "application/json" }, FG = "POST", i_ = { headers: BG, method: FG }, s_ = 10;
let Cs = class {
  constructor(e, r = !1) {
    if (this.url = e, this.disableProviderPing = r, this.events = new is.EventEmitter(), this.isAvailable = !1, this.registering = !1, !A3(e)) throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
    this.url = e, this.disableProviderPing = r;
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    if (!this.isAvailable) throw new Error("Connection already closed");
    this.onClose();
  }
  async send(e) {
    this.isAvailable || await this.register();
    try {
      const r = jo(e), n = await (await Q3(this.url, n_(r_({}, i_), { body: r }))).json();
      this.onPayload({ data: n });
    } catch (r) {
      this.onError(e.id, r);
    }
  }
  async register(e = this.url) {
    if (!A3(e)) throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
    if (this.registering) {
      const r = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= r || this.events.listenerCount("open") >= r) && this.events.setMaxListeners(r + 1), new Promise((n, i) => {
        this.events.once("register_error", (s) => {
          this.resetMaxListeners(), i(s);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.isAvailable > "u") return i(new Error("HTTP connection is missing or invalid"));
          n();
        });
      });
    }
    this.url = e, this.registering = !0;
    try {
      if (!this.disableProviderPing) {
        const r = jo({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
        await Q3(e, n_(r_({}, i_), { body: r }));
      }
      this.onOpen();
    } catch (r) {
      const n = this.parseError(r);
      throw this.events.emit("register_error", n), this.onClose(), n;
    }
  }
  onOpen() {
    this.isAvailable = !0, this.registering = !1, this.events.emit("open");
  }
  onClose() {
    this.isAvailable = !1, this.registering = !1, this.events.emit("close");
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const r = typeof e.data == "string" ? bc(e.data) : e.data;
    this.events.emit("payload", r);
  }
  onError(e, r) {
    const n = this.parseError(r), i = n.message || n.toString(), s = vp(e, i);
    this.events.emit("payload", s);
  }
  parseError(e, r = this.url) {
    return AE(e, r, "HTTP");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > s_ && this.events.setMaxListeners(s_);
  }
};
const o_ = "error", jG = "wss://relay.walletconnect.org", UG = "wc", qG = "universal_provider", a_ = `${UG}@2:${qG}:`, YE = "https://rpc.walletconnect.org/v1/", au = "generic", zG = `${YE}bundler`, fs = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
var WG = Object.defineProperty, HG = Object.defineProperties, KG = Object.getOwnPropertyDescriptors, c_ = Object.getOwnPropertySymbols, VG = Object.prototype.hasOwnProperty, GG = Object.prototype.propertyIsEnumerable, u_ = (t, e, r) => e in t ? WG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, _d = (t, e) => {
  for (var r in e || (e = {})) VG.call(e, r) && u_(t, r, e[r]);
  if (c_) for (var r of c_(e)) GG.call(e, r) && u_(t, r, e[r]);
  return t;
}, YG = (t, e) => HG(t, KG(e));
function Li(t, e, r) {
  var n;
  const i = _u(t);
  return ((n = e.rpcMap) == null ? void 0 : n[i.reference]) || `${YE}?chainId=${i.namespace}:${i.reference}&projectId=${r}`;
}
function Nc(t) {
  return t.includes(":") ? t.split(":")[1] : t;
}
function JE(t) {
  return t.map((e) => `${e.split(":")[0]}:${e.split(":")[1]}`);
}
function JG(t, e) {
  const r = Object.keys(e.namespaces).filter((i) => i.includes(t));
  if (!r.length) return [];
  const n = [];
  return r.forEach((i) => {
    const s = e.namespaces[i].accounts;
    n.push(...s);
  }), n;
}
function Dm(t = {}, e = {}) {
  const r = f_(t), n = f_(e);
  return RG.merge(r, n);
}
function f_(t) {
  var e, r, n, i;
  const s = {};
  if (!Ll(t)) return s;
  for (const [o, a] of Object.entries(t)) {
    const u = _b(o) ? [o] : a.chains, l = a.methods || [], d = a.events || [], p = a.rpcMap || {}, w = Kf(o);
    s[w] = YG(_d(_d({}, s[w]), a), { chains: jd(u, (e = s[w]) == null ? void 0 : e.chains), methods: jd(l, (r = s[w]) == null ? void 0 : r.methods), events: jd(d, (n = s[w]) == null ? void 0 : n.events), rpcMap: _d(_d({}, p), (i = s[w]) == null ? void 0 : i.rpcMap) });
  }
  return s;
}
function XG(t) {
  return t.includes(":") ? t.split(":")[2] : t;
}
function l_(t) {
  const e = {};
  for (const [r, n] of Object.entries(t)) {
    const i = n.methods || [], s = n.events || [], o = n.accounts || [], a = _b(r) ? [r] : n.chains ? n.chains : JE(n.accounts);
    e[r] = { chains: a, methods: i, events: s, accounts: o };
  }
  return e;
}
function Om(t) {
  return typeof t == "number" ? t : t.includes("0x") ? parseInt(t, 16) : (t = t.includes(":") ? t.split(":")[1] : t, isNaN(Number(t)) ? t : Number(t));
}
const XE = {}, Pr = (t) => XE[t], Nm = (t, e) => {
  XE[t] = e;
};
class ZG {
  constructor(e) {
    this.name = "polkadot", this.namespace = e.namespace, this.events = Pr("events"), this.client = Pr("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(fs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = Nc(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Li(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new us(new Cs(n, Pr("disableProviderPing")));
  }
}
var QG = Object.defineProperty, eY = Object.defineProperties, tY = Object.getOwnPropertyDescriptors, h_ = Object.getOwnPropertySymbols, rY = Object.prototype.hasOwnProperty, nY = Object.prototype.propertyIsEnumerable, d_ = (t, e, r) => e in t ? QG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, p_ = (t, e) => {
  for (var r in e || (e = {})) rY.call(e, r) && d_(t, r, e[r]);
  if (h_) for (var r of h_(e)) nY.call(e, r) && d_(t, r, e[r]);
  return t;
}, g_ = (t, e) => eY(t, tY(e));
class iY {
  constructor(e) {
    this.name = "eip155", this.namespace = e.namespace, this.events = Pr("events"), this.client = Pr("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(e) {
    switch (e.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(e);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(e);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(e);
    }
    return this.namespace.methods.includes(e.request.method) ? await this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(parseInt(e), r), this.chainId = parseInt(e), this.events.emit(fs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  createHttpProvider(e, r) {
    const n = r || Li(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new us(new Cs(n, Pr("disableProviderPing")));
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = parseInt(Nc(r));
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const e = this.chainId, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  async handleSwitchChain(e) {
    var r, n;
    let i = e.request.params ? (r = e.request.params[0]) == null ? void 0 : r.chainId : "0x0";
    i = i.startsWith("0x") ? i : `0x${i}`;
    const s = parseInt(i, 16);
    if (this.isChainApproved(s)) this.setDefaultChain(`${s}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: e.topic, request: { method: e.request.method, params: [{ chainId: i }] }, chainId: (n = this.namespace.chains) == null ? void 0 : n[0] }), this.setDefaultChain(`${s}`);
    else throw new Error(`Failed to switch to chain 'eip155:${s}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(e) {
    return this.namespace.chains.includes(`${this.name}:${e}`);
  }
  async getCapabilities(e) {
    var r, n, i;
    const s = (n = (r = e.request) == null ? void 0 : r.params) == null ? void 0 : n[0];
    if (!s) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const o = this.client.session.get(e.topic), a = ((i = o == null ? void 0 : o.sessionProperties) == null ? void 0 : i.capabilities) || {};
    if (a != null && a[s]) return a == null ? void 0 : a[s];
    const u = await this.client.request(e);
    try {
      await this.client.session.update(e.topic, { sessionProperties: g_(p_({}, o.sessionProperties || {}), { capabilities: g_(p_({}, a || {}), { [s]: u }) }) });
    } catch (l) {
      console.warn("Failed to update session with capabilities", l);
    }
    return u;
  }
  async getCallStatus(e) {
    var r, n;
    const i = this.client.session.get(e.topic), s = (r = i.sessionProperties) == null ? void 0 : r.bundler_name;
    if (s) {
      const a = this.getBundlerUrl(e.chainId, s);
      try {
        return await this.getUserOperationReceipt(a, e);
      } catch (u) {
        console.warn("Failed to fetch call status from bundler", u, a);
      }
    }
    const o = (n = i.sessionProperties) == null ? void 0 : n.bundler_url;
    if (o) try {
      return await this.getUserOperationReceipt(o, e);
    } catch (a) {
      console.warn("Failed to fetch call status from custom bundler", a, o);
    }
    if (this.namespace.methods.includes(e.request.method)) return await this.client.request(e);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(e, r) {
    var n;
    const i = new URL(e), s = await fetch(i, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(ga("eth_getUserOperationReceipt", [(n = r.request.params) == null ? void 0 : n[0]])) });
    if (!s.ok) throw new Error(`Failed to fetch user operation receipt - ${s.status}`);
    return await s.json();
  }
  getBundlerUrl(e, r) {
    return `${zG}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${r}`;
  }
}
class sY {
  constructor(e) {
    this.name = "solana", this.namespace = e.namespace, this.events = Pr("events"), this.client = Pr("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(fs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = Nc(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Li(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new us(new Cs(n, Pr("disableProviderPing")));
  }
}
let oY = class {
  constructor(e) {
    this.name = "cosmos", this.namespace = e.namespace, this.events = Pr("events"), this.client = Pr("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(fs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = Nc(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Li(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new us(new Cs(n, Pr("disableProviderPing")));
  }
}, aY = class {
  constructor(e) {
    this.name = "algorand", this.namespace = e.namespace, this.events = Pr("events"), this.client = Pr("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    if (!this.httpProviders[e]) {
      const n = r || Li(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
      if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, n);
    }
    this.chainId = e, this.events.emit(fs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      e[r] = this.createHttpProvider(r, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Li(e, this.namespace, this.client.core.projectId);
    return typeof n > "u" ? void 0 : new us(new Cs(n, Pr("disableProviderPing")));
  }
}, cY = class {
  constructor(e) {
    this.name = "cip34", this.namespace = e.namespace, this.events = Pr("events"), this.client = Pr("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(fs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      const n = this.getCardanoRPCUrl(r), i = Nc(r);
      e[i] = this.createHttpProvider(i, n);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  getCardanoRPCUrl(e) {
    const r = this.namespace.rpcMap;
    if (r) return r[e];
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || this.getCardanoRPCUrl(e);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new us(new Cs(n, Pr("disableProviderPing")));
  }
}, uY = class {
  constructor(e) {
    this.name = "elrond", this.namespace = e.namespace, this.events = Pr("events"), this.client = Pr("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(fs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = Nc(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Li(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new us(new Cs(n, Pr("disableProviderPing")));
  }
};
class fY {
  constructor(e) {
    this.name = "multiversx", this.namespace = e.namespace, this.events = Pr("events"), this.client = Pr("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(fs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = Nc(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Li(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new us(new Cs(n, Pr("disableProviderPing")));
  }
}
let lY = class {
  constructor(e) {
    this.name = "near", this.namespace = e.namespace, this.events = Pr("events"), this.client = Pr("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    if (this.chainId = e, !this.httpProviders[e]) {
      const n = r || Li(`${this.name}:${e}`, this.namespace);
      if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, n);
    }
    this.events.emit(fs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      e[r] = this.createHttpProvider(r, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Li(e, this.namespace);
    return typeof n > "u" ? void 0 : new us(new Cs(n, Pr("disableProviderPing")));
  }
};
class hY {
  constructor(e) {
    this.name = "tezos", this.namespace = e.namespace, this.events = Pr("events"), this.client = Pr("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    if (this.chainId = e, !this.httpProviders[e]) {
      const n = r || Li(`${this.name}:${e}`, this.namespace);
      if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, n);
    }
    this.events.emit(fs.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      e[r] = this.createHttpProvider(r);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Li(e, this.namespace);
    return typeof n > "u" ? void 0 : new us(new Cs(n));
  }
}
class dY {
  constructor(e) {
    this.name = au, this.namespace = e.namespace, this.events = Pr("events"), this.client = Pr("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(e.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(e.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(e.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(e.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider(e.chainId).request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(fs.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var e, r;
    const n = {};
    return (r = (e = this.namespace) == null ? void 0 : e.accounts) == null || r.forEach((i) => {
      const s = _u(i);
      n[`${s.namespace}:${s.reference}`] = this.createHttpProvider(i);
    }), n;
  }
  getHttpProvider(e) {
    const r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Li(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new us(new Cs(n, Pr("disableProviderPing")));
  }
}
var pY = Object.defineProperty, gY = Object.defineProperties, mY = Object.getOwnPropertyDescriptors, m_ = Object.getOwnPropertySymbols, vY = Object.prototype.hasOwnProperty, bY = Object.prototype.propertyIsEnumerable, v_ = (t, e, r) => e in t ? pY(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Ed = (t, e) => {
  for (var r in e || (e = {})) vY.call(e, r) && v_(t, r, e[r]);
  if (m_) for (var r of m_(e)) bY.call(e, r) && v_(t, r, e[r]);
  return t;
}, Lm = (t, e) => gY(t, mY(e));
let J1 = class ZE {
  constructor(e) {
    this.events = new Xv(), this.rpcProviders = {}, this.shouldAbortPairingAttempt = !1, this.maxPairingAttempts = 10, this.disableProviderPing = !1, this.providerOpts = e, this.logger = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : Xl(X0({ level: (e == null ? void 0 : e.logger) || o_ })), this.disableProviderPing = (e == null ? void 0 : e.disableProviderPing) || !1;
  }
  static async init(e) {
    const r = new ZE(e);
    return await r.initialize(), r;
  }
  async request(e, r, n) {
    const [i, s] = this.validateChain(r);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(i).request({ request: Ed({}, e), chainId: `${i}:${s}`, topic: this.session.topic, expiry: n });
  }
  sendAsync(e, r, n, i) {
    const s = (/* @__PURE__ */ new Date()).getTime();
    this.request(e, n, i).then((o) => r(null, mp(s, o))).catch((o) => r(o, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var e;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (e = this.session) == null ? void 0 : e.topic, reason: Or("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(e) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(e), await this.cleanupPendingPairings(), !e.skipPairing) return await this.pair(e.pairingTopic);
  }
  async authenticate(e, r) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(e), await this.cleanupPendingPairings();
    const { uri: n, response: i } = await this.client.authenticate(e, r);
    n && (this.uri = n, this.events.emit("display_uri", n));
    const s = await i();
    if (this.session = s.session, this.session) {
      const o = l_(this.session.namespaces);
      this.namespaces = Dm(this.namespaces, o), this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return s;
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  get isWalletConnect() {
    return !0;
  }
  async pair(e) {
    this.shouldAbortPairingAttempt = !1;
    let r = 0;
    do {
      if (this.shouldAbortPairingAttempt) throw new Error("Pairing aborted");
      if (r >= this.maxPairingAttempts) throw new Error("Max auto pairing attempts reached");
      const { uri: n, approval: i } = await this.client.connect({ pairingTopic: e, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties });
      n && (this.uri = n, this.events.emit("display_uri", n)), await i().then((s) => {
        this.session = s;
        const o = l_(s.namespaces);
        this.namespaces = Dm(this.namespaces, o), this.persist("namespaces", this.namespaces);
      }).catch((s) => {
        if (s.message !== GE) throw s;
        r++;
      });
    } while (!this.session);
    return this.onConnect(), this.session;
  }
  setDefaultChain(e, r) {
    try {
      if (!this.session) return;
      const [n, i] = this.validateChain(e), s = this.getProvider(n);
      s.name === au ? s.setDefaultChain(`${n}:${i}`, r) : s.setDefaultChain(i, r);
    } catch (n) {
      if (!/Please call connect/.test(n.message)) throw n;
    }
  }
  async cleanupPendingPairings(e = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const r = this.client.pairing.getAll();
    if (_c(r)) {
      for (const n of r) e.deletePairings ? this.client.core.expirer.set(n.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(n.topic);
      this.logger.info(`Inactive pairings cleared: ${r.length}`);
    }
  }
  abortPairingAttempt() {
    this.shouldAbortPairingAttempt = !0;
  }
  async checkStorage() {
    if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
      const e = this.client.session.keys.length - 1;
      this.session = this.client.session.get(this.client.session.keys[e]), this.createProviders();
    }
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    this.client = this.providerOpts.client || await Ib.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || o_, relayUrl: this.providerOpts.relayUrl || jG, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const e = [...new Set(Object.keys(this.session.namespaces).map((r) => Kf(r)))];
    Nm("client", this.client), Nm("events", this.events), Nm("disableProviderPing", this.disableProviderPing), e.forEach((r) => {
      if (!this.session) return;
      const n = JG(r, this.session), i = JE(n), s = Dm(this.namespaces, this.optionalNamespaces), o = Lm(Ed({}, s[r]), { accounts: n, chains: i });
      switch (r) {
        case "eip155":
          this.rpcProviders[r] = new iY({ namespace: o });
          break;
        case "algorand":
          this.rpcProviders[r] = new aY({ namespace: o });
          break;
        case "solana":
          this.rpcProviders[r] = new sY({ namespace: o });
          break;
        case "cosmos":
          this.rpcProviders[r] = new oY({ namespace: o });
          break;
        case "polkadot":
          this.rpcProviders[r] = new ZG({ namespace: o });
          break;
        case "cip34":
          this.rpcProviders[r] = new cY({ namespace: o });
          break;
        case "elrond":
          this.rpcProviders[r] = new uY({ namespace: o });
          break;
        case "multiversx":
          this.rpcProviders[r] = new fY({ namespace: o });
          break;
        case "near":
          this.rpcProviders[r] = new lY({ namespace: o });
          break;
        case "tezos":
          this.rpcProviders[r] = new hY({ namespace: o });
          break;
        default:
          this.rpcProviders[au] ? this.rpcProviders[au].updateNamespace(o) : this.rpcProviders[au] = new dY({ namespace: o });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (e) => {
      this.events.emit("session_ping", e);
    }), this.client.on("session_event", (e) => {
      const { params: r } = e, { event: n } = r;
      if (n.name === "accountsChanged") {
        const i = n.data;
        i && _c(i) && this.events.emit("accountsChanged", i.map(XG));
      } else if (n.name === "chainChanged") {
        const i = r.chainId, s = r.event.data, o = Kf(i), a = Om(i) !== Om(s) ? `${o}:${Om(s)}` : i;
        this.onChainChanged(a);
      } else this.events.emit(n.name, n.data);
      this.events.emit("session_event", e);
    }), this.client.on("session_update", ({ topic: e, params: r }) => {
      var n;
      const { namespaces: i } = r, s = (n = this.client) == null ? void 0 : n.session.get(e);
      this.session = Lm(Ed({}, s), { namespaces: i }), this.onSessionUpdate(), this.events.emit("session_update", { topic: e, params: r });
    }), this.client.on("session_delete", async (e) => {
      await this.cleanup(), this.events.emit("session_delete", e), this.events.emit("disconnect", Lm(Ed({}, Or("USER_DISCONNECTED")), { data: e.topic }));
    }), this.on(fs.DEFAULT_CHAIN_CHANGED, (e) => {
      this.onChainChanged(e, !0);
    });
  }
  getProvider(e) {
    return this.rpcProviders[e] || this.rpcProviders[au];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((e) => {
      var r;
      this.getProvider(e).updateNamespace((r = this.session) == null ? void 0 : r.namespaces[e]);
    });
  }
  setNamespaces(e) {
    const { namespaces: r, optionalNamespaces: n, sessionProperties: i } = e;
    r && Object.keys(r).length && (this.namespaces = r), n && Object.keys(n).length && (this.optionalNamespaces = n), this.sessionProperties = i, this.persist("namespaces", r), this.persist("optionalNamespaces", n);
  }
  validateChain(e) {
    const [r, n] = (e == null ? void 0 : e.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [r, n];
    if (r && !Object.keys(this.namespaces || {}).map((o) => Kf(o)).includes(r)) throw new Error(`Namespace '${r}' is not configured. Please call connect() first with namespace config.`);
    if (r && n) return [r, n];
    const i = Kf(Object.keys(this.namespaces)[0]), s = this.rpcProviders[i].getDefaultChain();
    return [i, s];
  }
  async requestAccounts() {
    const [e] = this.validateChain();
    return await this.getProvider(e).requestAccounts();
  }
  onChainChanged(e, r = !1) {
    if (!this.namespaces) return;
    const [n, i] = this.validateChain(e);
    i && (r || this.getProvider(n).setDefaultChain(i), this.namespaces[n] ? this.namespaces[n].defaultChain = i : this.namespaces[`${n}:${i}`] ? this.namespaces[`${n}:${i}`].defaultChain = i : this.namespaces[`${n}:${i}`] = { defaultChain: i }, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", i));
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({ deletePairings: !0 });
  }
  persist(e, r) {
    this.client.core.storage.setItem(`${a_}/${e}`, r);
  }
  async getFromStore(e) {
    return await this.client.core.storage.getItem(`${a_}/${e}`);
  }
};
const yY = J1;
function wY() {
  return new Promise((t) => {
    const e = [];
    let r;
    window.addEventListener("eip6963:announceProvider", (n) => {
      const { detail: i } = n;
      r && clearTimeout(r), e.push(i), r = setTimeout(() => t(e), 200);
    }), r = setTimeout(() => t(e), 200), window.dispatchEvent(new Event("eip6963:requestProvider"));
  });
}
class no {
  constructor(e, r) {
    this.scope = e, this.module = r;
  }
  storeObject(e, r) {
    this.setItem(e, JSON.stringify(r));
  }
  loadObject(e) {
    const r = this.getItem(e);
    return r ? JSON.parse(r) : void 0;
  }
  setItem(e, r) {
    localStorage.setItem(this.scopedKey(e), r);
  }
  getItem(e) {
    return localStorage.getItem(this.scopedKey(e));
  }
  removeItem(e) {
    localStorage.removeItem(this.scopedKey(e));
  }
  clear() {
    const e = this.scopedKey(""), r = [];
    for (let n = 0; n < localStorage.length; n++) {
      const i = localStorage.key(n);
      typeof i == "string" && i.startsWith(e) && r.push(i);
    }
    r.forEach((n) => localStorage.removeItem(n));
  }
  scopedKey(e) {
    return `-${this.scope}${this.module ? `:${this.module}` : ""}:${e}`;
  }
  static clearAll() {
    new no("CBWSDK").clear(), new no("walletlink").clear();
  }
}
const fn = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901,
    unsupportedChain: 4902
  }
}, X1 = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  4001: {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  4100: {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  4200: {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  4900: {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  4901: {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  },
  4902: {
    standard: "EIP-3085",
    message: "Unrecognized chain ID."
  }
}, QE = "Unspecified error message.", xY = "Unspecified server error.";
function Cb(t, e = QE) {
  if (t && Number.isInteger(t)) {
    const r = t.toString();
    if (Z1(X1, r))
      return X1[r].message;
    if (eS(t))
      return xY;
  }
  return e;
}
function _Y(t) {
  if (!Number.isInteger(t))
    return !1;
  const e = t.toString();
  return !!(X1[e] || eS(t));
}
function EY(t, { shouldIncludeStack: e = !1 } = {}) {
  const r = {};
  if (t && typeof t == "object" && !Array.isArray(t) && Z1(t, "code") && _Y(t.code)) {
    const n = t;
    r.code = n.code, n.message && typeof n.message == "string" ? (r.message = n.message, Z1(n, "data") && (r.data = n.data)) : (r.message = Cb(r.code), r.data = { originalError: b_(t) });
  } else
    r.code = fn.rpc.internal, r.message = y_(t, "message") ? t.message : QE, r.data = { originalError: b_(t) };
  return e && (r.stack = y_(t, "stack") ? t.stack : void 0), r;
}
function eS(t) {
  return t >= -32099 && t <= -32e3;
}
function b_(t) {
  return t && typeof t == "object" && !Array.isArray(t) ? Object.assign({}, t) : t;
}
function Z1(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function y_(t, e) {
  return typeof t == "object" && t !== null && e in t && typeof t[e] == "string";
}
const Ar = {
  rpc: {
    parse: (t) => Ji(fn.rpc.parse, t),
    invalidRequest: (t) => Ji(fn.rpc.invalidRequest, t),
    invalidParams: (t) => Ji(fn.rpc.invalidParams, t),
    methodNotFound: (t) => Ji(fn.rpc.methodNotFound, t),
    internal: (t) => Ji(fn.rpc.internal, t),
    server: (t) => {
      if (!t || typeof t != "object" || Array.isArray(t))
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      const { code: e } = t;
      if (!Number.isInteger(e) || e > -32005 || e < -32099)
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      return Ji(e, t);
    },
    invalidInput: (t) => Ji(fn.rpc.invalidInput, t),
    resourceNotFound: (t) => Ji(fn.rpc.resourceNotFound, t),
    resourceUnavailable: (t) => Ji(fn.rpc.resourceUnavailable, t),
    transactionRejected: (t) => Ji(fn.rpc.transactionRejected, t),
    methodNotSupported: (t) => Ji(fn.rpc.methodNotSupported, t),
    limitExceeded: (t) => Ji(fn.rpc.limitExceeded, t)
  },
  provider: {
    userRejectedRequest: (t) => nu(fn.provider.userRejectedRequest, t),
    unauthorized: (t) => nu(fn.provider.unauthorized, t),
    unsupportedMethod: (t) => nu(fn.provider.unsupportedMethod, t),
    disconnected: (t) => nu(fn.provider.disconnected, t),
    chainDisconnected: (t) => nu(fn.provider.chainDisconnected, t),
    unsupportedChain: (t) => nu(fn.provider.unsupportedChain, t),
    custom: (t) => {
      if (!t || typeof t != "object" || Array.isArray(t))
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      const { code: e, message: r, data: n } = t;
      if (!r || typeof r != "string")
        throw new Error('"message" must be a nonempty string');
      return new nS(e, r, n);
    }
  }
};
function Ji(t, e) {
  const [r, n] = tS(e);
  return new rS(t, r || Cb(t), n);
}
function nu(t, e) {
  const [r, n] = tS(e);
  return new nS(t, r || Cb(t), n);
}
function tS(t) {
  if (t) {
    if (typeof t == "string")
      return [t];
    if (typeof t == "object" && !Array.isArray(t)) {
      const { message: e, data: r } = t;
      if (e && typeof e != "string")
        throw new Error("Must specify string message.");
      return [e || void 0, r];
    }
  }
  return [];
}
class rS extends Error {
  constructor(e, r, n) {
    if (!Number.isInteger(e))
      throw new Error('"code" must be an integer.');
    if (!r || typeof r != "string")
      throw new Error('"message" must be a nonempty string.');
    super(r), this.code = e, n !== void 0 && (this.data = n);
  }
}
class nS extends rS {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(e, r, n) {
    if (!SY(e))
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(e, r, n);
  }
}
function SY(t) {
  return Number.isInteger(t) && t >= 1e3 && t <= 4999;
}
function Tb() {
  return (t) => t;
}
const kl = Tb(), AY = Tb(), PY = Tb();
function Po(t) {
  return Math.floor(t);
}
const iS = /^[0-9]*$/, sS = /^[a-f0-9]*$/;
function sc(t) {
  return Rb(crypto.getRandomValues(new Uint8Array(t)));
}
function Rb(t) {
  return [...t].map((e) => e.toString(16).padStart(2, "0")).join("");
}
function Wd(t) {
  return new Uint8Array(t.match(/.{1,2}/g).map((e) => Number.parseInt(e, 16)));
}
function Zf(t, e = !1) {
  const r = t.toString("hex");
  return kl(e ? `0x${r}` : r);
}
function km(t) {
  return Zf(Q1(t), !0);
}
function js(t) {
  return PY(t.toString(10));
}
function ma(t) {
  return kl(`0x${BigInt(t).toString(16)}`);
}
function oS(t) {
  return t.startsWith("0x") || t.startsWith("0X");
}
function Db(t) {
  return oS(t) ? t.slice(2) : t;
}
function aS(t) {
  return oS(t) ? `0x${t.slice(2)}` : `0x${t}`;
}
function xp(t) {
  if (typeof t != "string")
    return !1;
  const e = Db(t).toLowerCase();
  return sS.test(e);
}
function MY(t, e = !1) {
  if (typeof t == "string") {
    const r = Db(t).toLowerCase();
    if (sS.test(r))
      return kl(e ? `0x${r}` : r);
  }
  throw Ar.rpc.invalidParams(`"${String(t)}" is not a hexadecimal string`);
}
function Ob(t, e = !1) {
  let r = MY(t, !1);
  return r.length % 2 === 1 && (r = kl(`0${r}`)), e ? kl(`0x${r}`) : r;
}
function ia(t) {
  if (typeof t == "string") {
    const e = Db(t).toLowerCase();
    if (xp(e) && e.length === 40)
      return AY(aS(e));
  }
  throw Ar.rpc.invalidParams(`Invalid Ethereum address: ${String(t)}`);
}
function Q1(t) {
  if (Buffer.isBuffer(t))
    return t;
  if (typeof t == "string") {
    if (xp(t)) {
      const e = Ob(t, !1);
      return Buffer.from(e, "hex");
    }
    return Buffer.from(t, "utf8");
  }
  throw Ar.rpc.invalidParams(`Not binary data: ${String(t)}`);
}
function Qf(t) {
  if (typeof t == "number" && Number.isInteger(t))
    return Po(t);
  if (typeof t == "string") {
    if (iS.test(t))
      return Po(Number(t));
    if (xp(t))
      return Po(Number(BigInt(Ob(t, !0))));
  }
  throw Ar.rpc.invalidParams(`Not an integer: ${String(t)}`);
}
function Bf(t) {
  if (t !== null && (typeof t == "bigint" || CY(t)))
    return BigInt(t.toString(10));
  if (typeof t == "number")
    return BigInt(Qf(t));
  if (typeof t == "string") {
    if (iS.test(t))
      return BigInt(t);
    if (xp(t))
      return BigInt(Ob(t, !0));
  }
  throw Ar.rpc.invalidParams(`Not an integer: ${String(t)}`);
}
function IY(t) {
  if (typeof t == "string")
    return JSON.parse(t);
  if (typeof t == "object")
    return t;
  throw Ar.rpc.invalidParams(`Not a JSON string or an object: ${String(t)}`);
}
function CY(t) {
  if (t == null || typeof t.constructor != "function")
    return !1;
  const { constructor: e } = t;
  return typeof e.config == "function" && typeof e.EUCLID == "number";
}
async function TY() {
  return crypto.subtle.generateKey({
    name: "ECDH",
    namedCurve: "P-256"
  }, !0, ["deriveKey"]);
}
async function RY(t, e) {
  return crypto.subtle.deriveKey({
    name: "ECDH",
    public: e
  }, t, {
    name: "AES-GCM",
    length: 256
  }, !1, ["encrypt", "decrypt"]);
}
async function DY(t, e) {
  const r = crypto.getRandomValues(new Uint8Array(12)), n = await crypto.subtle.encrypt({
    name: "AES-GCM",
    iv: r
  }, t, new TextEncoder().encode(e));
  return { iv: r, cipherText: n };
}
async function OY(t, { iv: e, cipherText: r }) {
  const n = await crypto.subtle.decrypt({
    name: "AES-GCM",
    iv: e
  }, t, r);
  return new TextDecoder().decode(n);
}
function cS(t) {
  switch (t) {
    case "public":
      return "spki";
    case "private":
      return "pkcs8";
  }
}
async function uS(t, e) {
  const r = cS(t), n = await crypto.subtle.exportKey(r, e);
  return Rb(new Uint8Array(n));
}
async function fS(t, e) {
  const r = cS(t), n = Wd(e).buffer;
  return await crypto.subtle.importKey(r, new Uint8Array(n), {
    name: "ECDH",
    namedCurve: "P-256"
  }, !0, t === "private" ? ["deriveKey"] : []);
}
async function NY(t, e) {
  const r = JSON.stringify(t, (n, i) => {
    if (!(i instanceof Error))
      return i;
    const s = i;
    return Object.assign(Object.assign({}, s.code ? { code: s.code } : {}), { message: s.message });
  });
  return DY(e, r);
}
async function LY(t, e) {
  return JSON.parse(await OY(e, t));
}
const $m = {
  storageKey: "ownPrivateKey",
  keyType: "private"
}, Bm = {
  storageKey: "ownPublicKey",
  keyType: "public"
}, Fm = {
  storageKey: "peerPublicKey",
  keyType: "public"
};
class kY {
  constructor() {
    this.storage = new no("CBWSDK", "SCWKeyManager"), this.ownPrivateKey = null, this.ownPublicKey = null, this.peerPublicKey = null, this.sharedSecret = null;
  }
  async getOwnPublicKey() {
    return await this.loadKeysIfNeeded(), this.ownPublicKey;
  }
  // returns null if the shared secret is not yet derived
  async getSharedSecret() {
    return await this.loadKeysIfNeeded(), this.sharedSecret;
  }
  async setPeerPublicKey(e) {
    this.sharedSecret = null, this.peerPublicKey = e, await this.storeKey(Fm, e), await this.loadKeysIfNeeded();
  }
  async clear() {
    this.ownPrivateKey = null, this.ownPublicKey = null, this.peerPublicKey = null, this.sharedSecret = null, this.storage.removeItem(Bm.storageKey), this.storage.removeItem($m.storageKey), this.storage.removeItem(Fm.storageKey);
  }
  async generateKeyPair() {
    const e = await TY();
    this.ownPrivateKey = e.privateKey, this.ownPublicKey = e.publicKey, await this.storeKey($m, e.privateKey), await this.storeKey(Bm, e.publicKey);
  }
  async loadKeysIfNeeded() {
    if (this.ownPrivateKey === null && (this.ownPrivateKey = await this.loadKey($m)), this.ownPublicKey === null && (this.ownPublicKey = await this.loadKey(Bm)), (this.ownPrivateKey === null || this.ownPublicKey === null) && await this.generateKeyPair(), this.peerPublicKey === null && (this.peerPublicKey = await this.loadKey(Fm)), this.sharedSecret === null) {
      if (this.ownPrivateKey === null || this.peerPublicKey === null)
        return;
      this.sharedSecret = await RY(this.ownPrivateKey, this.peerPublicKey);
    }
  }
  // storage methods
  async loadKey(e) {
    const r = this.storage.getItem(e.storageKey);
    return r ? fS(e.keyType, r) : null;
  }
  async storeKey(e, r) {
    const n = await uS(e.keyType, r);
    this.storage.setItem(e.storageKey, n);
  }
}
const hh = "4.2.4", lS = "@coinbase/wallet-sdk";
async function hS(t, e) {
  const r = Object.assign(Object.assign({}, t), { jsonrpc: "2.0", id: crypto.randomUUID() }), n = await window.fetch(e, {
    method: "POST",
    body: JSON.stringify(r),
    mode: "cors",
    headers: {
      "Content-Type": "application/json",
      "X-Cbw-Sdk-Version": hh,
      "X-Cbw-Sdk-Platform": lS
    }
  }), { result: i, error: s } = await n.json();
  if (s)
    throw s;
  return i;
}
function $Y() {
  return globalThis.coinbaseWalletExtension;
}
function BY() {
  var t, e;
  try {
    const r = globalThis;
    return (t = r.ethereum) !== null && t !== void 0 ? t : (e = r.top) === null || e === void 0 ? void 0 : e.ethereum;
  } catch {
    return;
  }
}
function FY({ metadata: t, preference: e }) {
  var r, n;
  const { appName: i, appLogoUrl: s, appChainIds: o } = t;
  if (e.options !== "smartWalletOnly") {
    const u = $Y();
    if (u)
      return (r = u.setAppInfo) === null || r === void 0 || r.call(u, i, s, o, e), u;
  }
  const a = BY();
  if (a != null && a.isCoinbaseBrowser)
    return (n = a.setAppInfo) === null || n === void 0 || n.call(a, i, s, o, e), a;
}
function jY(t) {
  if (!t || typeof t != "object" || Array.isArray(t))
    throw Ar.rpc.invalidParams({
      message: "Expected a single, non-array, object argument.",
      data: t
    });
  const { method: e, params: r } = t;
  if (typeof e != "string" || e.length === 0)
    throw Ar.rpc.invalidParams({
      message: "'args.method' must be a non-empty string.",
      data: t
    });
  if (r !== void 0 && !Array.isArray(r) && (typeof r != "object" || r === null))
    throw Ar.rpc.invalidParams({
      message: "'args.params' must be an object or array if provided.",
      data: t
    });
  switch (e) {
    case "eth_sign":
    case "eth_signTypedData_v2":
    case "eth_subscribe":
    case "eth_unsubscribe":
      throw Ar.provider.unsupportedMethod();
  }
}
const w_ = "accounts", x_ = "activeChain", __ = "availableChains", E_ = "walletCapabilities";
class UY {
  constructor(e) {
    var r, n, i;
    this.metadata = e.metadata, this.communicator = e.communicator, this.callback = e.callback, this.keyManager = new kY(), this.storage = new no("CBWSDK", "SCWStateManager"), this.accounts = (r = this.storage.loadObject(w_)) !== null && r !== void 0 ? r : [], this.chain = this.storage.loadObject(x_) || {
      id: (i = (n = e.metadata.appChainIds) === null || n === void 0 ? void 0 : n[0]) !== null && i !== void 0 ? i : 1
    }, this.handshake = this.handshake.bind(this), this.request = this.request.bind(this), this.createRequestMessage = this.createRequestMessage.bind(this), this.decryptResponseMessage = this.decryptResponseMessage.bind(this);
  }
  async handshake(e) {
    var r, n;
    const i = await this.createRequestMessage({
      handshake: {
        method: e.method,
        params: Object.assign({}, this.metadata, (r = e.params) !== null && r !== void 0 ? r : {})
      }
    }), s = await this.communicator.postRequestAndWaitForResponse(i);
    if ("failure" in s.content)
      throw s.content.failure;
    const o = await fS("public", s.sender);
    await this.keyManager.setPeerPublicKey(o);
    const u = (await this.decryptResponseMessage(s)).result;
    if ("error" in u)
      throw u.error;
    const l = u.value;
    this.accounts = l, this.storage.storeObject(w_, l), (n = this.callback) === null || n === void 0 || n.call(this, "accountsChanged", l);
  }
  async request(e) {
    var r;
    if (this.accounts.length === 0)
      throw Ar.provider.unauthorized();
    switch (e.method) {
      case "eth_requestAccounts":
        return (r = this.callback) === null || r === void 0 || r.call(this, "connect", { chainId: ma(this.chain.id) }), this.accounts;
      case "eth_accounts":
        return this.accounts;
      case "eth_coinbase":
        return this.accounts[0];
      case "net_version":
        return this.chain.id;
      case "eth_chainId":
        return ma(this.chain.id);
      case "wallet_getCapabilities":
        return this.storage.loadObject(E_);
      case "wallet_switchEthereumChain":
        return this.handleSwitchChainRequest(e);
      case "eth_ecRecover":
      case "personal_sign":
      case "personal_ecRecover":
      case "eth_signTransaction":
      case "eth_sendTransaction":
      case "eth_signTypedData_v1":
      case "eth_signTypedData_v3":
      case "eth_signTypedData_v4":
      case "eth_signTypedData":
      case "wallet_addEthereumChain":
      case "wallet_watchAsset":
      case "wallet_sendCalls":
      case "wallet_showCallsStatus":
      case "wallet_grantPermissions":
        return this.sendRequestToPopup(e);
      default:
        if (!this.chain.rpcUrl)
          throw Ar.rpc.internal("No RPC URL set for chain");
        return hS(e, this.chain.rpcUrl);
    }
  }
  async sendRequestToPopup(e) {
    var r, n;
    await ((n = (r = this.communicator).waitForPopupLoaded) === null || n === void 0 ? void 0 : n.call(r));
    const i = await this.sendEncryptedRequest(e), o = (await this.decryptResponseMessage(i)).result;
    if ("error" in o)
      throw o.error;
    return o.value;
  }
  async cleanup() {
    var e, r;
    this.storage.clear(), await this.keyManager.clear(), this.accounts = [], this.chain = {
      id: (r = (e = this.metadata.appChainIds) === null || e === void 0 ? void 0 : e[0]) !== null && r !== void 0 ? r : 1
    };
  }
  /**
   * @returns `null` if the request was successful.
   * https://eips.ethereum.org/EIPS/eip-3326#wallet_switchethereumchain
   */
  async handleSwitchChainRequest(e) {
    var r;
    const n = e.params;
    if (!n || !(!((r = n[0]) === null || r === void 0) && r.chainId))
      throw Ar.rpc.invalidParams();
    const i = Qf(n[0].chainId);
    if (this.updateChain(i))
      return null;
    const o = await this.sendRequestToPopup(e);
    return o === null && this.updateChain(i), o;
  }
  async sendEncryptedRequest(e) {
    const r = await this.keyManager.getSharedSecret();
    if (!r)
      throw Ar.provider.unauthorized("No valid session found, try requestAccounts before other methods");
    const n = await NY({
      action: e,
      chainId: this.chain.id
    }, r), i = await this.createRequestMessage({ encrypted: n });
    return this.communicator.postRequestAndWaitForResponse(i);
  }
  async createRequestMessage(e) {
    const r = await uS("public", await this.keyManager.getOwnPublicKey());
    return {
      id: crypto.randomUUID(),
      sender: r,
      content: e,
      timestamp: /* @__PURE__ */ new Date()
    };
  }
  async decryptResponseMessage(e) {
    var r, n;
    const i = e.content;
    if ("failure" in i)
      throw i.failure;
    const s = await this.keyManager.getSharedSecret();
    if (!s)
      throw Ar.provider.unauthorized("Invalid session");
    const o = await LY(i.encrypted, s), a = (r = o.data) === null || r === void 0 ? void 0 : r.chains;
    if (a) {
      const l = Object.entries(a).map(([d, p]) => ({
        id: Number(d),
        rpcUrl: p
      }));
      this.storage.storeObject(__, l), this.updateChain(this.chain.id, l);
    }
    const u = (n = o.data) === null || n === void 0 ? void 0 : n.capabilities;
    return u && this.storage.storeObject(E_, u), o;
  }
  updateChain(e, r) {
    var n;
    const i = r ?? this.storage.loadObject(__), s = i == null ? void 0 : i.find((o) => o.id === e);
    return s ? (s !== this.chain && (this.chain = s, this.storage.storeObject(x_, s), (n = this.callback) === null || n === void 0 || n.call(this, "chainChanged", ma(s.id))), !0) : !1;
  }
}
const qY = /* @__PURE__ */ Lv(mO), { keccak_256: zY } = qY;
function dS(t) {
  return Buffer.allocUnsafe(t).fill(0);
}
function WY(t) {
  return t.toString(2).length;
}
function pS(t, e) {
  let r = t.toString(16);
  r.length % 2 !== 0 && (r = "0" + r);
  const n = r.match(/.{1,2}/g).map((i) => parseInt(i, 16));
  for (; n.length < e; )
    n.unshift(0);
  return Buffer.from(n);
}
function HY(t, e) {
  const r = t < 0n;
  let n;
  if (r) {
    const i = (1n << BigInt(e)) - 1n;
    n = (~t & i) + 1n;
  } else
    n = t;
  return n &= (1n << BigInt(e)) - 1n, n;
}
function gS(t, e, r) {
  const n = dS(e);
  return t = _p(t), r ? t.length < e ? (t.copy(n), n) : t.slice(0, e) : t.length < e ? (t.copy(n, e - t.length), n) : t.slice(-e);
}
function KY(t, e) {
  return gS(t, e, !0);
}
function _p(t) {
  if (!Buffer.isBuffer(t))
    if (Array.isArray(t))
      t = Buffer.from(t);
    else if (typeof t == "string")
      mS(t) ? t = Buffer.from(YY(vS(t)), "hex") : t = Buffer.from(t);
    else if (typeof t == "number")
      t = intToBuffer(t);
    else if (t == null)
      t = Buffer.allocUnsafe(0);
    else if (typeof t == "bigint")
      t = pS(t);
    else if (t.toArray)
      t = Buffer.from(t.toArray());
    else
      throw new Error("invalid type");
  return t;
}
function VY(t) {
  return t = _p(t), "0x" + t.toString("hex");
}
function GY(t, e) {
  if (t = _p(t), e || (e = 256), e !== 256)
    throw new Error("unsupported");
  return Buffer.from(zY(new Uint8Array(t)));
}
function YY(t) {
  return t.length % 2 ? "0" + t : t;
}
function mS(t) {
  return typeof t == "string" && t.match(/^0x[0-9A-Fa-f]*$/);
}
function vS(t) {
  return typeof t == "string" && t.startsWith("0x") ? t.slice(2) : t;
}
var bS = {
  zeros: dS,
  setLength: gS,
  setLengthRight: KY,
  isHexString: mS,
  stripHexPrefix: vS,
  toBuffer: _p,
  bufferToHex: VY,
  keccak: GY,
  bitLengthFromBigInt: WY,
  bufferBEFromBigInt: pS,
  twosFromBigInt: HY
};
const oi = bS;
function yS(t) {
  return t.startsWith("int[") ? "int256" + t.slice(3) : t === "int" ? "int256" : t.startsWith("uint[") ? "uint256" + t.slice(4) : t === "uint" ? "uint256" : t.startsWith("fixed[") ? "fixed128x128" + t.slice(5) : t === "fixed" ? "fixed128x128" : t.startsWith("ufixed[") ? "ufixed128x128" + t.slice(6) : t === "ufixed" ? "ufixed128x128" : t;
}
function Su(t) {
  return Number.parseInt(/^\D+(\d+)$/.exec(t)[1], 10);
}
function S_(t) {
  var e = /^\D+(\d+)x(\d+)$/.exec(t);
  return [Number.parseInt(e[1], 10), Number.parseInt(e[2], 10)];
}
function wS(t) {
  var e = t.match(/(.*)\[(.*?)\]$/);
  return e ? e[2] === "" ? "dynamic" : Number.parseInt(e[2], 10) : null;
}
function oc(t) {
  var e = typeof t;
  if (e === "string" || e === "number")
    return BigInt(t);
  if (e === "bigint")
    return t;
  throw new Error("Argument is not a number");
}
function Hs(t, e) {
  var r, n, i, s;
  if (t === "address")
    return Hs("uint160", oc(e));
  if (t === "bool")
    return Hs("uint8", e ? 1 : 0);
  if (t === "string")
    return Hs("bytes", new Buffer(e, "utf8"));
  if (XY(t)) {
    if (typeof e.length > "u")
      throw new Error("Not an array?");
    if (r = wS(t), r !== "dynamic" && r !== 0 && e.length > r)
      throw new Error("Elements exceed array size: " + r);
    i = [], t = t.slice(0, t.lastIndexOf("[")), typeof e == "string" && (e = JSON.parse(e));
    for (s in e)
      i.push(Hs(t, e[s]));
    if (r === "dynamic") {
      var o = Hs("uint256", e.length);
      i.unshift(o);
    }
    return Buffer.concat(i);
  } else {
    if (t === "bytes")
      return e = new Buffer(e), i = Buffer.concat([Hs("uint256", e.length), e]), e.length % 32 !== 0 && (i = Buffer.concat([i, oi.zeros(32 - e.length % 32)])), i;
    if (t.startsWith("bytes")) {
      if (r = Su(t), r < 1 || r > 32)
        throw new Error("Invalid bytes<N> width: " + r);
      return oi.setLengthRight(e, 32);
    } else if (t.startsWith("uint")) {
      if (r = Su(t), r % 8 || r < 8 || r > 256)
        throw new Error("Invalid uint<N> width: " + r);
      n = oc(e);
      const a = oi.bitLengthFromBigInt(n);
      if (a > r)
        throw new Error("Supplied uint exceeds width: " + r + " vs " + a);
      if (n < 0)
        throw new Error("Supplied uint is negative");
      return oi.bufferBEFromBigInt(n, 32);
    } else if (t.startsWith("int")) {
      if (r = Su(t), r % 8 || r < 8 || r > 256)
        throw new Error("Invalid int<N> width: " + r);
      n = oc(e);
      const a = oi.bitLengthFromBigInt(n);
      if (a > r)
        throw new Error("Supplied int exceeds width: " + r + " vs " + a);
      const u = oi.twosFromBigInt(n, 256);
      return oi.bufferBEFromBigInt(u, 32);
    } else if (t.startsWith("ufixed")) {
      if (r = S_(t), n = oc(e), n < 0)
        throw new Error("Supplied ufixed is negative");
      return Hs("uint256", n * BigInt(2) ** BigInt(r[1]));
    } else if (t.startsWith("fixed"))
      return r = S_(t), Hs("int256", oc(e) * BigInt(2) ** BigInt(r[1]));
  }
  throw new Error("Unsupported or invalid type: " + t);
}
function JY(t) {
  return t === "string" || t === "bytes" || wS(t) === "dynamic";
}
function XY(t) {
  return t.lastIndexOf("]") === t.length - 1;
}
function ZY(t, e) {
  var r = [], n = [], i = 32 * t.length;
  for (var s in t) {
    var o = yS(t[s]), a = e[s], u = Hs(o, a);
    JY(o) ? (r.push(Hs("uint256", i)), n.push(u), i += u.length) : r.push(u);
  }
  return Buffer.concat(r.concat(n));
}
function xS(t, e) {
  if (t.length !== e.length)
    throw new Error("Number of types are not matching the values");
  for (var r, n, i = [], s = 0; s < t.length; s++) {
    var o = yS(t[s]), a = e[s];
    if (o === "bytes")
      i.push(a);
    else if (o === "string")
      i.push(new Buffer(a, "utf8"));
    else if (o === "bool")
      i.push(new Buffer(a ? "01" : "00", "hex"));
    else if (o === "address")
      i.push(oi.setLength(a, 20));
    else if (o.startsWith("bytes")) {
      if (r = Su(o), r < 1 || r > 32)
        throw new Error("Invalid bytes<N> width: " + r);
      i.push(oi.setLengthRight(a, r));
    } else if (o.startsWith("uint")) {
      if (r = Su(o), r % 8 || r < 8 || r > 256)
        throw new Error("Invalid uint<N> width: " + r);
      n = oc(a);
      const u = oi.bitLengthFromBigInt(n);
      if (u > r)
        throw new Error("Supplied uint exceeds width: " + r + " vs " + u);
      i.push(oi.bufferBEFromBigInt(n, r / 8));
    } else if (o.startsWith("int")) {
      if (r = Su(o), r % 8 || r < 8 || r > 256)
        throw new Error("Invalid int<N> width: " + r);
      n = oc(a);
      const u = oi.bitLengthFromBigInt(n);
      if (u > r)
        throw new Error("Supplied int exceeds width: " + r + " vs " + u);
      const l = oi.twosFromBigInt(n, r);
      i.push(oi.bufferBEFromBigInt(l, r / 8));
    } else
      throw new Error("Unsupported or invalid type: " + o);
  }
  return Buffer.concat(i);
}
function QY(t, e) {
  return oi.keccak(xS(t, e));
}
var eJ = {
  rawEncode: ZY,
  solidityPack: xS,
  soliditySHA3: QY
};
const _s = bS, el = eJ, _S = {
  type: "object",
  properties: {
    types: {
      type: "object",
      additionalProperties: {
        type: "array",
        items: {
          type: "object",
          properties: {
            name: { type: "string" },
            type: { type: "string" }
          },
          required: ["name", "type"]
        }
      }
    },
    primaryType: { type: "string" },
    domain: { type: "object" },
    message: { type: "object" }
  },
  required: ["types", "primaryType", "domain", "message"]
}, jm = {
  /**
   * Encodes an object by encoding and concatenating each of its members
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of an object
   */
  encodeData(t, e, r, n = !0) {
    const i = ["bytes32"], s = [this.hashType(t, r)];
    if (n) {
      const o = (a, u, l) => {
        if (r[u] !== void 0)
          return ["bytes32", l == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : _s.keccak(this.encodeData(u, l, r, n))];
        if (l === void 0)
          throw new Error(`missing value for field ${a} of type ${u}`);
        if (u === "bytes")
          return ["bytes32", _s.keccak(l)];
        if (u === "string")
          return typeof l == "string" && (l = Buffer.from(l, "utf8")), ["bytes32", _s.keccak(l)];
        if (u.lastIndexOf("]") === u.length - 1) {
          const d = u.slice(0, u.lastIndexOf("[")), p = l.map((w) => o(a, d, w));
          return ["bytes32", _s.keccak(el.rawEncode(
            p.map(([w]) => w),
            p.map(([, w]) => w)
          ))];
        }
        return [u, l];
      };
      for (const a of r[t]) {
        const [u, l] = o(a.name, a.type, e[a.name]);
        i.push(u), s.push(l);
      }
    } else
      for (const o of r[t]) {
        let a = e[o.name];
        if (a !== void 0)
          if (o.type === "bytes")
            i.push("bytes32"), a = _s.keccak(a), s.push(a);
          else if (o.type === "string")
            i.push("bytes32"), typeof a == "string" && (a = Buffer.from(a, "utf8")), a = _s.keccak(a), s.push(a);
          else if (r[o.type] !== void 0)
            i.push("bytes32"), a = _s.keccak(this.encodeData(o.type, a, r, n)), s.push(a);
          else {
            if (o.type.lastIndexOf("]") === o.type.length - 1)
              throw new Error("Arrays currently unimplemented in encodeData");
            i.push(o.type), s.push(a);
          }
      }
    return el.rawEncode(i, s);
  },
  /**
   * Encodes the type of an object by encoding a comma delimited list of its members
   *
   * @param {string} primaryType - Root type to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of the type of an object
   */
  encodeType(t, e) {
    let r = "", n = this.findTypeDependencies(t, e).filter((i) => i !== t);
    n = [t].concat(n.sort());
    for (const i of n) {
      if (!e[i])
        throw new Error("No type definition specified: " + i);
      r += i + "(" + e[i].map(({ name: o, type: a }) => a + " " + o).join(",") + ")";
    }
    return r;
  },
  /**
   * Finds all types within a type definition object
   *
   * @param {string} primaryType - Root type
   * @param {Object} types - Type definitions
   * @param {Array} results - current set of accumulated types
   * @returns {Array} - Set of all types found in the type definition
   */
  findTypeDependencies(t, e, r = []) {
    if (t = t.match(/^\w*/)[0], r.includes(t) || e[t] === void 0)
      return r;
    r.push(t);
    for (const n of e[t])
      for (const i of this.findTypeDependencies(n.type, e, r))
        !r.includes(i) && r.push(i);
    return r;
  },
  /**
   * Hashes an object
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to hash
   * @param {Object} types - Type definitions
   * @returns {Buffer} - Hash of an object
   */
  hashStruct(t, e, r, n = !0) {
    return _s.keccak(this.encodeData(t, e, r, n));
  },
  /**
   * Hashes the type of an object
   *
   * @param {string} primaryType - Root type to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashType(t, e) {
    return _s.keccak(this.encodeType(t, e));
  },
  /**
   * Removes properties from a message object that are not defined per EIP-712
   *
   * @param {Object} data - typed message object
   * @returns {Object} - typed message object with only allowed fields
   */
  sanitizeData(t) {
    const e = {};
    for (const r in _S.properties)
      t[r] && (e[r] = t[r]);
    return e.types && (e.types = Object.assign({ EIP712Domain: [] }, e.types)), e;
  },
  /**
   * Returns the hash of a typed message as per EIP-712 for signing
   *
   * @param {Object} typedData - Types message data to sign
   * @returns {string} - sha3 hash for signing
   */
  hash(t, e = !0) {
    const r = this.sanitizeData(t), n = [Buffer.from("1901", "hex")];
    return n.push(this.hashStruct("EIP712Domain", r.domain, r.types, e)), r.primaryType !== "EIP712Domain" && n.push(this.hashStruct(r.primaryType, r.message, r.types, e)), _s.keccak(Buffer.concat(n));
  }
};
var tJ = {
  TYPED_MESSAGE_SCHEMA: _S,
  TypedDataUtils: jm,
  hashForSignTypedDataLegacy: function(t) {
    return rJ(t.data);
  },
  hashForSignTypedData_v3: function(t) {
    return jm.hash(t.data, !1);
  },
  hashForSignTypedData_v4: function(t) {
    return jm.hash(t.data);
  }
};
function rJ(t) {
  const e = new Error("Expect argument to be non-empty array");
  if (typeof t != "object" || !t.length) throw e;
  const r = t.map(function(s) {
    return s.type === "bytes" ? _s.toBuffer(s.value) : s.value;
  }), n = t.map(function(s) {
    return s.type;
  }), i = t.map(function(s) {
    if (!s.name) throw e;
    return s.type + " " + s.name;
  });
  return el.soliditySHA3(
    ["bytes32", "bytes32"],
    [
      el.soliditySHA3(new Array(t.length).fill("string"), i),
      el.soliditySHA3(n, r)
    ]
  );
}
const Sd = /* @__PURE__ */ ns(tJ), nJ = "walletUsername", ev = "Addresses", iJ = "AppVersion";
function jn(t) {
  return t.errorMessage !== void 0;
}
class sJ {
  // @param secret hex representation of 32-byte secret
  constructor(e) {
    this.secret = e;
  }
  /**
   *
   * @param plainText string to be encrypted
   * returns hex string representation of bytes in the order: initialization vector (iv),
   * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the
   * encrypted plainText.
   */
  async encrypt(e) {
    const r = this.secret;
    if (r.length !== 64)
      throw Error("secret must be 256 bits");
    const n = crypto.getRandomValues(new Uint8Array(12)), i = await crypto.subtle.importKey("raw", Wd(r), { name: "aes-gcm" }, !1, ["encrypt", "decrypt"]), s = new TextEncoder(), o = await window.crypto.subtle.encrypt({
      name: "AES-GCM",
      iv: n
    }, i, s.encode(e)), a = 16, u = o.slice(o.byteLength - a), l = o.slice(0, o.byteLength - a), d = new Uint8Array(u), p = new Uint8Array(l), w = new Uint8Array([...n, ...d, ...p]);
    return Rb(w);
  }
  /**
   *
   * @param cipherText hex string representation of bytes in the order: initialization vector (iv),
   * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.
   */
  async decrypt(e) {
    const r = this.secret;
    if (r.length !== 64)
      throw Error("secret must be 256 bits");
    return new Promise((n, i) => {
      (async function() {
        const s = await crypto.subtle.importKey("raw", Wd(r), { name: "aes-gcm" }, !1, ["encrypt", "decrypt"]), o = Wd(e), a = o.slice(0, 12), u = o.slice(12, 28), l = o.slice(28), d = new Uint8Array([...l, ...u]), p = {
          name: "AES-GCM",
          iv: new Uint8Array(a)
        };
        try {
          const w = await window.crypto.subtle.decrypt(p, s, d), _ = new TextDecoder();
          n(_.decode(w));
        } catch (w) {
          i(w);
        }
      })();
    });
  }
}
class oJ {
  constructor(e, r, n) {
    this.linkAPIUrl = e, this.sessionId = r;
    const i = `${r}:${n}`;
    this.auth = `Basic ${btoa(i)}`;
  }
  // mark unseen events as seen
  async markUnseenEventsAsSeen(e) {
    return Promise.all(e.map((r) => fetch(`${this.linkAPIUrl}/events/${r.eventId}/seen`, {
      method: "POST",
      headers: {
        Authorization: this.auth
      }
    }))).catch((r) => console.error("Unabled to mark event as failed:", r));
  }
  async fetchUnseenEvents() {
    var e;
    const r = await fetch(`${this.linkAPIUrl}/events?unseen=true`, {
      headers: {
        Authorization: this.auth
      }
    });
    if (r.ok) {
      const { events: n, error: i } = await r.json();
      if (i)
        throw new Error(`Check unseen events failed: ${i}`);
      const s = (e = n == null ? void 0 : n.filter((o) => o.event === "Web3Response").map((o) => ({
        type: "Event",
        sessionId: this.sessionId,
        eventId: o.id,
        event: o.event,
        data: o.data
      }))) !== null && e !== void 0 ? e : [];
      return this.markUnseenEventsAsSeen(s), s;
    }
    throw new Error(`Check unseen events failed: ${r.status}`);
  }
}
var To;
(function(t) {
  t[t.DISCONNECTED = 0] = "DISCONNECTED", t[t.CONNECTING = 1] = "CONNECTING", t[t.CONNECTED = 2] = "CONNECTED";
})(To || (To = {}));
class aJ {
  setConnectionStateListener(e) {
    this.connectionStateListener = e;
  }
  setIncomingDataListener(e) {
    this.incomingDataListener = e;
  }
  /**
   * Constructor
   * @param url WebSocket server URL
   * @param [WebSocketClass] Custom WebSocket implementation
   */
  constructor(e, r = WebSocket) {
    this.WebSocketClass = r, this.webSocket = null, this.pendingData = [], this.url = e.replace(/^http/, "ws");
  }
  /**
   * Make a websocket connection
   * @returns a Promise that resolves when connected
   */
  async connect() {
    if (this.webSocket)
      throw new Error("webSocket object is not null");
    return new Promise((e, r) => {
      var n;
      let i;
      try {
        this.webSocket = i = new this.WebSocketClass(this.url);
      } catch (s) {
        r(s);
        return;
      }
      (n = this.connectionStateListener) === null || n === void 0 || n.call(this, To.CONNECTING), i.onclose = (s) => {
        var o;
        this.clearWebSocket(), r(new Error(`websocket error ${s.code}: ${s.reason}`)), (o = this.connectionStateListener) === null || o === void 0 || o.call(this, To.DISCONNECTED);
      }, i.onopen = (s) => {
        var o;
        e(), (o = this.connectionStateListener) === null || o === void 0 || o.call(this, To.CONNECTED), this.pendingData.length > 0 && ([...this.pendingData].forEach((u) => this.sendData(u)), this.pendingData = []);
      }, i.onmessage = (s) => {
        var o, a;
        if (s.data === "h")
          (o = this.incomingDataListener) === null || o === void 0 || o.call(this, {
            type: "Heartbeat"
          });
        else
          try {
            const u = JSON.parse(s.data);
            (a = this.incomingDataListener) === null || a === void 0 || a.call(this, u);
          } catch {
          }
      };
    });
  }
  /**
   * Disconnect from server
   */
  disconnect() {
    var e;
    const { webSocket: r } = this;
    if (r) {
      this.clearWebSocket(), (e = this.connectionStateListener) === null || e === void 0 || e.call(this, To.DISCONNECTED), this.connectionStateListener = void 0, this.incomingDataListener = void 0;
      try {
        r.close();
      } catch {
      }
    }
  }
  /**
   * Send data to server
   * @param data text to send
   */
  sendData(e) {
    const { webSocket: r } = this;
    if (!r) {
      this.pendingData.push(e), this.connect();
      return;
    }
    r.send(e);
  }
  clearWebSocket() {
    const { webSocket: e } = this;
    e && (this.webSocket = null, e.onclose = null, e.onerror = null, e.onmessage = null, e.onopen = null);
  }
}
const A_ = 1e4, cJ = 6e4;
class uJ {
  /**
   * Constructor
   * @param session Session
   * @param linkAPIUrl Coinbase Wallet link server URL
   * @param listener WalletLinkConnectionUpdateListener
   * @param [WebSocketClass] Custom WebSocket implementation
   */
  constructor({ session: e, linkAPIUrl: r, listener: n }) {
    this.destroyed = !1, this.lastHeartbeatResponse = 0, this.nextReqId = Po(1), this._connected = !1, this._linked = !1, this.shouldFetchUnseenEventsOnConnect = !1, this.requestResolutions = /* @__PURE__ */ new Map(), this.handleSessionMetadataUpdated = (s) => {
      if (!s)
        return;
      (/* @__PURE__ */ new Map([
        ["__destroyed", this.handleDestroyed],
        ["EthereumAddress", this.handleAccountUpdated],
        ["WalletUsername", this.handleWalletUsernameUpdated],
        ["AppVersion", this.handleAppVersionUpdated],
        [
          "ChainId",
          // ChainId and JsonRpcUrl are always updated together
          (a) => s.JsonRpcUrl && this.handleChainUpdated(a, s.JsonRpcUrl)
        ]
      ])).forEach((a, u) => {
        const l = s[u];
        l !== void 0 && a(l);
      });
    }, this.handleDestroyed = (s) => {
      var o;
      s === "1" && ((o = this.listener) === null || o === void 0 || o.resetAndReload());
    }, this.handleAccountUpdated = async (s) => {
      var o;
      const a = await this.cipher.decrypt(s);
      (o = this.listener) === null || o === void 0 || o.accountUpdated(a);
    }, this.handleMetadataUpdated = async (s, o) => {
      var a;
      const u = await this.cipher.decrypt(o);
      (a = this.listener) === null || a === void 0 || a.metadataUpdated(s, u);
    }, this.handleWalletUsernameUpdated = async (s) => {
      this.handleMetadataUpdated(nJ, s);
    }, this.handleAppVersionUpdated = async (s) => {
      this.handleMetadataUpdated(iJ, s);
    }, this.handleChainUpdated = async (s, o) => {
      var a;
      const u = await this.cipher.decrypt(s), l = await this.cipher.decrypt(o);
      (a = this.listener) === null || a === void 0 || a.chainUpdated(u, l);
    }, this.session = e, this.cipher = new sJ(e.secret), this.listener = n;
    const i = new aJ(`${r}/rpc`, WebSocket);
    i.setConnectionStateListener(async (s) => {
      let o = !1;
      switch (s) {
        case To.DISCONNECTED:
          if (!this.destroyed) {
            const a = async () => {
              await new Promise((u) => setTimeout(u, 5e3)), this.destroyed || i.connect().catch(() => {
                a();
              });
            };
            a();
          }
          break;
        case To.CONNECTED:
          o = await this.handleConnected(), this.updateLastHeartbeat(), setInterval(() => {
            this.heartbeat();
          }, A_), this.shouldFetchUnseenEventsOnConnect && this.fetchUnseenEventsAPI();
          break;
        case To.CONNECTING:
          break;
      }
      this.connected !== o && (this.connected = o);
    }), i.setIncomingDataListener((s) => {
      var o;
      switch (s.type) {
        case "Heartbeat":
          this.updateLastHeartbeat();
          return;
        case "IsLinkedOK":
        case "Linked": {
          const a = s.type === "IsLinkedOK" ? s.linked : void 0;
          this.linked = a || s.onlineGuests > 0;
          break;
        }
        case "GetSessionConfigOK":
        case "SessionConfigUpdated": {
          this.handleSessionMetadataUpdated(s.metadata);
          break;
        }
        case "Event": {
          this.handleIncomingEvent(s);
          break;
        }
      }
      s.id !== void 0 && ((o = this.requestResolutions.get(s.id)) === null || o === void 0 || o(s));
    }), this.ws = i, this.http = new oJ(r, e.id, e.key);
  }
  /**
   * Make a connection to the server
   */
  connect() {
    if (this.destroyed)
      throw new Error("instance is destroyed");
    this.ws.connect();
  }
  /**
   * Terminate connection, and mark as destroyed. To reconnect, create a new
   * instance of WalletSDKConnection
   */
  async destroy() {
    this.destroyed || (await this.makeRequest({
      type: "SetSessionConfig",
      id: Po(this.nextReqId++),
      sessionId: this.session.id,
      metadata: { __destroyed: "1" }
    }, { timeout: 1e3 }), this.destroyed = !0, this.ws.disconnect(), this.listener = void 0);
  }
  get connected() {
    return this._connected;
  }
  set connected(e) {
    this._connected = e;
  }
  get linked() {
    return this._linked;
  }
  set linked(e) {
    var r, n;
    this._linked = e, e && ((r = this.onceLinked) === null || r === void 0 || r.call(this)), (n = this.listener) === null || n === void 0 || n.linkedUpdated(e);
  }
  setOnceLinked(e) {
    return new Promise((r) => {
      this.linked ? e().then(r) : this.onceLinked = () => {
        e().then(r), this.onceLinked = void 0;
      };
    });
  }
  async handleIncomingEvent(e) {
    var r;
    if (e.type !== "Event" || e.event !== "Web3Response")
      return;
    const n = await this.cipher.decrypt(e.data), i = JSON.parse(n);
    if (i.type !== "WEB3_RESPONSE")
      return;
    const { id: s, response: o } = i;
    (r = this.listener) === null || r === void 0 || r.handleWeb3ResponseMessage(s, o);
  }
  async checkUnseenEvents() {
    if (!this.connected) {
      this.shouldFetchUnseenEventsOnConnect = !0;
      return;
    }
    await new Promise((e) => setTimeout(e, 250));
    try {
      await this.fetchUnseenEventsAPI();
    } catch (e) {
      console.error("Unable to check for unseen events", e);
    }
  }
  async fetchUnseenEventsAPI() {
    this.shouldFetchUnseenEventsOnConnect = !1, (await this.http.fetchUnseenEvents()).forEach((r) => this.handleIncomingEvent(r));
  }
  /**
   * Publish an event and emit event ID when successful
   * @param event event name
   * @param unencryptedData unencrypted event data
   * @param callWebhook whether the webhook should be invoked
   * @returns a Promise that emits event ID when successful
   */
  async publishEvent(e, r, n = !1) {
    const i = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, r), { origin: location.origin, location: location.href, relaySource: "coinbaseWalletExtension" in window && window.coinbaseWalletExtension ? "injected_sdk" : "sdk" }))), s = {
      type: "PublishEvent",
      id: Po(this.nextReqId++),
      sessionId: this.session.id,
      event: e,
      data: i,
      callWebhook: n
    };
    return this.setOnceLinked(async () => {
      const o = await this.makeRequest(s);
      if (o.type === "Fail")
        throw new Error(o.error || "failed to publish event");
      return o.eventId;
    });
  }
  sendData(e) {
    this.ws.sendData(JSON.stringify(e));
  }
  updateLastHeartbeat() {
    this.lastHeartbeatResponse = Date.now();
  }
  heartbeat() {
    if (Date.now() - this.lastHeartbeatResponse > A_ * 2) {
      this.ws.disconnect();
      return;
    }
    try {
      this.ws.sendData("h");
    } catch {
    }
  }
  async makeRequest(e, r = { timeout: cJ }) {
    const n = e.id;
    this.sendData(e);
    let i;
    return Promise.race([
      new Promise((s, o) => {
        i = window.setTimeout(() => {
          o(new Error(`request ${n} timed out`));
        }, r.timeout);
      }),
      new Promise((s) => {
        this.requestResolutions.set(n, (o) => {
          clearTimeout(i), s(o), this.requestResolutions.delete(n);
        });
      })
    ]);
  }
  async handleConnected() {
    return (await this.makeRequest({
      type: "HostSession",
      id: Po(this.nextReqId++),
      sessionId: this.session.id,
      sessionKey: this.session.key
    })).type === "Fail" ? !1 : (this.sendData({
      type: "IsLinked",
      id: Po(this.nextReqId++),
      sessionId: this.session.id
    }), this.sendData({
      type: "GetSessionConfig",
      id: Po(this.nextReqId++),
      sessionId: this.session.id
    }), !0);
  }
}
class fJ {
  constructor() {
    this._nextRequestId = 0, this.callbacks = /* @__PURE__ */ new Map();
  }
  makeRequestId() {
    this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
    const e = this._nextRequestId, r = aS(e.toString(16));
    return this.callbacks.get(r) && this.callbacks.delete(r), e;
  }
}
const P_ = "session:id", M_ = "session:secret", I_ = "session:linked";
class Au {
  constructor(e, r, n, i = !1) {
    this.storage = e, this.id = r, this.secret = n, this.key = XD(P4(`${r}, ${n} WalletLink`)), this._linked = !!i;
  }
  static create(e) {
    const r = sc(16), n = sc(32);
    return new Au(e, r, n).save();
  }
  static load(e) {
    const r = e.getItem(P_), n = e.getItem(I_), i = e.getItem(M_);
    return r && i ? new Au(e, r, i, n === "1") : null;
  }
  get linked() {
    return this._linked;
  }
  set linked(e) {
    this._linked = e, this.persistLinked();
  }
  save() {
    return this.storage.setItem(P_, this.id), this.storage.setItem(M_, this.secret), this.persistLinked(), this;
  }
  persistLinked() {
    this.storage.setItem(I_, this._linked ? "1" : "0");
  }
}
function lJ() {
  try {
    return window.frameElement !== null;
  } catch {
    return !1;
  }
}
function hJ() {
  try {
    return lJ() && window.top ? window.top.location : window.location;
  } catch {
    return window.location;
  }
}
function dJ() {
  var t;
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test((t = window == null ? void 0 : window.navigator) === null || t === void 0 ? void 0 : t.userAgent);
}
function ES() {
  var t, e;
  return (e = (t = window == null ? void 0 : window.matchMedia) === null || t === void 0 ? void 0 : t.call(window, "(prefers-color-scheme: dark)").matches) !== null && e !== void 0 ? e : !1;
}
const pJ = '@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}';
function SS() {
  const t = document.createElement("style");
  t.type = "text/css", t.appendChild(document.createTextNode(pJ)), document.documentElement.appendChild(t);
}
function AS(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number") n += t;
  else if (typeof t == "object") if (Array.isArray(t)) for (e = 0; e < t.length; e++) t[e] && (r = AS(t[e])) && (n && (n += " "), n += r);
  else for (e in t) t[e] && (n && (n += " "), n += e);
  return n;
}
function tl() {
  for (var t, e, r = 0, n = ""; r < arguments.length; ) (t = arguments[r++]) && (e = AS(t)) && (n && (n += " "), n += e);
  return n;
}
var Ep, Jr, PS, ac, C_, MS, tv, IS, Nb, rv, nv, $l = {}, CS = [], gJ = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, Lb = Array.isArray;
function va(t, e) {
  for (var r in e) t[r] = e[r];
  return t;
}
function kb(t) {
  t && t.parentNode && t.parentNode.removeChild(t);
}
function Nr(t, e, r) {
  var n, i, s, o = {};
  for (s in e) s == "key" ? n = e[s] : s == "ref" ? i = e[s] : o[s] = e[s];
  if (arguments.length > 2 && (o.children = arguments.length > 3 ? Ep.call(arguments, 2) : r), typeof t == "function" && t.defaultProps != null) for (s in t.defaultProps) o[s] === void 0 && (o[s] = t.defaultProps[s]);
  return Hd(t, o, n, i, null);
}
function Hd(t, e, r, n, i) {
  var s = { type: t, props: e, key: r, ref: n, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: i ?? ++PS, __i: -1, __u: 0 };
  return i == null && Jr.vnode != null && Jr.vnode(s), s;
}
function dh(t) {
  return t.children;
}
function Kd(t, e) {
  this.props = t, this.context = e;
}
function Lu(t, e) {
  if (e == null) return t.__ ? Lu(t.__, t.__i + 1) : null;
  for (var r; e < t.__k.length; e++) if ((r = t.__k[e]) != null && r.__e != null) return r.__e;
  return typeof t.type == "function" ? Lu(t) : null;
}
function TS(t) {
  var e, r;
  if ((t = t.__) != null && t.__c != null) {
    for (t.__e = t.__c.base = null, e = 0; e < t.__k.length; e++) if ((r = t.__k[e]) != null && r.__e != null) {
      t.__e = t.__c.base = r.__e;
      break;
    }
    return TS(t);
  }
}
function T_(t) {
  (!t.__d && (t.__d = !0) && ac.push(t) && !A0.__r++ || C_ !== Jr.debounceRendering) && ((C_ = Jr.debounceRendering) || MS)(A0);
}
function A0() {
  var t, e, r, n, i, s, o, a;
  for (ac.sort(tv); t = ac.shift(); ) t.__d && (e = ac.length, n = void 0, s = (i = (r = t).__v).__e, o = [], a = [], r.__P && ((n = va({}, i)).__v = i.__v + 1, Jr.vnode && Jr.vnode(n), $b(r.__P, n, i, r.__n, r.__P.namespaceURI, 32 & i.__u ? [s] : null, o, s ?? Lu(i), !!(32 & i.__u), a), n.__v = i.__v, n.__.__k[n.__i] = n, OS(o, n, a), n.__e != s && TS(n)), ac.length > e && ac.sort(tv));
  A0.__r = 0;
}
function RS(t, e, r, n, i, s, o, a, u, l, d) {
  var p, w, _, P, O, L, B = n && n.__k || CS, k = e.length;
  for (u = mJ(r, e, B, u), p = 0; p < k; p++) (_ = r.__k[p]) != null && (w = _.__i === -1 ? $l : B[_.__i] || $l, _.__i = p, L = $b(t, _, w, i, s, o, a, u, l, d), P = _.__e, _.ref && w.ref != _.ref && (w.ref && Bb(w.ref, null, _), d.push(_.ref, _.__c || P, _)), O == null && P != null && (O = P), 4 & _.__u || w.__k === _.__k ? u = DS(_, u, t) : typeof _.type == "function" && L !== void 0 ? u = L : P && (u = P.nextSibling), _.__u &= -7);
  return r.__e = O, u;
}
function mJ(t, e, r, n) {
  var i, s, o, a, u, l = e.length, d = r.length, p = d, w = 0;
  for (t.__k = [], i = 0; i < l; i++) (s = e[i]) != null && typeof s != "boolean" && typeof s != "function" ? (a = i + w, (s = t.__k[i] = typeof s == "string" || typeof s == "number" || typeof s == "bigint" || s.constructor == String ? Hd(null, s, null, null, null) : Lb(s) ? Hd(dh, { children: s }, null, null, null) : s.constructor === void 0 && s.__b > 0 ? Hd(s.type, s.props, s.key, s.ref ? s.ref : null, s.__v) : s).__ = t, s.__b = t.__b + 1, o = null, (u = s.__i = vJ(s, r, a, p)) !== -1 && (p--, (o = r[u]) && (o.__u |= 2)), o == null || o.__v === null ? (u == -1 && w--, typeof s.type != "function" && (s.__u |= 4)) : u !== a && (u == a - 1 ? w-- : u == a + 1 ? w++ : (u > a ? w-- : w++, s.__u |= 4))) : s = t.__k[i] = null;
  if (p) for (i = 0; i < d; i++) (o = r[i]) != null && !(2 & o.__u) && (o.__e == n && (n = Lu(o)), NS(o, o));
  return n;
}
function DS(t, e, r) {
  var n, i;
  if (typeof t.type == "function") {
    for (n = t.__k, i = 0; n && i < n.length; i++) n[i] && (n[i].__ = t, e = DS(n[i], e, r));
    return e;
  }
  t.__e != e && (e && t.type && !r.contains(e) && (e = Lu(t)), r.insertBefore(t.__e, e || null), e = t.__e);
  do
    e = e && e.nextSibling;
  while (e != null && e.nodeType === 8);
  return e;
}
function vJ(t, e, r, n) {
  var i = t.key, s = t.type, o = r - 1, a = r + 1, u = e[r];
  if (u === null || u && i == u.key && s === u.type && !(2 & u.__u)) return r;
  if ((typeof s != "function" || s === dh || i) && n > (u != null && !(2 & u.__u) ? 1 : 0)) for (; o >= 0 || a < e.length; ) {
    if (o >= 0) {
      if ((u = e[o]) && !(2 & u.__u) && i == u.key && s === u.type) return o;
      o--;
    }
    if (a < e.length) {
      if ((u = e[a]) && !(2 & u.__u) && i == u.key && s === u.type) return a;
      a++;
    }
  }
  return -1;
}
function R_(t, e, r) {
  e[0] === "-" ? t.setProperty(e, r ?? "") : t[e] = r == null ? "" : typeof r != "number" || gJ.test(e) ? r : r + "px";
}
function Ad(t, e, r, n, i) {
  var s;
  e: if (e === "style") if (typeof r == "string") t.style.cssText = r;
  else {
    if (typeof n == "string" && (t.style.cssText = n = ""), n) for (e in n) r && e in r || R_(t.style, e, "");
    if (r) for (e in r) n && r[e] === n[e] || R_(t.style, e, r[e]);
  }
  else if (e[0] === "o" && e[1] === "n") s = e !== (e = e.replace(IS, "$1")), e = e.toLowerCase() in t || e === "onFocusOut" || e === "onFocusIn" ? e.toLowerCase().slice(2) : e.slice(2), t.l || (t.l = {}), t.l[e + s] = r, r ? n ? r.u = n.u : (r.u = Nb, t.addEventListener(e, s ? nv : rv, s)) : t.removeEventListener(e, s ? nv : rv, s);
  else {
    if (i == "http://www.w3.org/2000/svg") e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if (e != "width" && e != "height" && e != "href" && e != "list" && e != "form" && e != "tabIndex" && e != "download" && e != "rowSpan" && e != "colSpan" && e != "role" && e != "popover" && e in t) try {
      t[e] = r ?? "";
      break e;
    } catch {
    }
    typeof r == "function" || (r == null || r === !1 && e[4] !== "-" ? t.removeAttribute(e) : t.setAttribute(e, e == "popover" && r == 1 ? "" : r));
  }
}
function D_(t) {
  return function(e) {
    if (this.l) {
      var r = this.l[e.type + t];
      if (e.t == null) e.t = Nb++;
      else if (e.t < r.u) return;
      return r(Jr.event ? Jr.event(e) : e);
    }
  };
}
function $b(t, e, r, n, i, s, o, a, u, l) {
  var d, p, w, _, P, O, L, B, k, q, U, V, Q, R, K, ge, Ee, Y = e.type;
  if (e.constructor !== void 0) return null;
  128 & r.__u && (u = !!(32 & r.__u), s = [a = e.__e = r.__e]), (d = Jr.__b) && d(e);
  e: if (typeof Y == "function") try {
    if (B = e.props, k = "prototype" in Y && Y.prototype.render, q = (d = Y.contextType) && n[d.__c], U = d ? q ? q.props.value : d.__ : n, r.__c ? L = (p = e.__c = r.__c).__ = p.__E : (k ? e.__c = p = new Y(B, U) : (e.__c = p = new Kd(B, U), p.constructor = Y, p.render = yJ), q && q.sub(p), p.props = B, p.state || (p.state = {}), p.context = U, p.__n = n, w = p.__d = !0, p.__h = [], p._sb = []), k && p.__s == null && (p.__s = p.state), k && Y.getDerivedStateFromProps != null && (p.__s == p.state && (p.__s = va({}, p.__s)), va(p.__s, Y.getDerivedStateFromProps(B, p.__s))), _ = p.props, P = p.state, p.__v = e, w) k && Y.getDerivedStateFromProps == null && p.componentWillMount != null && p.componentWillMount(), k && p.componentDidMount != null && p.__h.push(p.componentDidMount);
    else {
      if (k && Y.getDerivedStateFromProps == null && B !== _ && p.componentWillReceiveProps != null && p.componentWillReceiveProps(B, U), !p.__e && (p.shouldComponentUpdate != null && p.shouldComponentUpdate(B, p.__s, U) === !1 || e.__v === r.__v)) {
        for (e.__v !== r.__v && (p.props = B, p.state = p.__s, p.__d = !1), e.__e = r.__e, e.__k = r.__k, e.__k.some(function(A) {
          A && (A.__ = e);
        }), V = 0; V < p._sb.length; V++) p.__h.push(p._sb[V]);
        p._sb = [], p.__h.length && o.push(p);
        break e;
      }
      p.componentWillUpdate != null && p.componentWillUpdate(B, p.__s, U), k && p.componentDidUpdate != null && p.__h.push(function() {
        p.componentDidUpdate(_, P, O);
      });
    }
    if (p.context = U, p.props = B, p.__P = t, p.__e = !1, Q = Jr.__r, R = 0, k) {
      for (p.state = p.__s, p.__d = !1, Q && Q(e), d = p.render(p.props, p.state, p.context), K = 0; K < p._sb.length; K++) p.__h.push(p._sb[K]);
      p._sb = [];
    } else do
      p.__d = !1, Q && Q(e), d = p.render(p.props, p.state, p.context), p.state = p.__s;
    while (p.__d && ++R < 25);
    p.state = p.__s, p.getChildContext != null && (n = va(va({}, n), p.getChildContext())), k && !w && p.getSnapshotBeforeUpdate != null && (O = p.getSnapshotBeforeUpdate(_, P)), a = RS(t, Lb(ge = d != null && d.type === dh && d.key == null ? d.props.children : d) ? ge : [ge], e, r, n, i, s, o, a, u, l), p.base = e.__e, e.__u &= -161, p.__h.length && o.push(p), L && (p.__E = p.__ = null);
  } catch (A) {
    if (e.__v = null, u || s != null) if (A.then) {
      for (e.__u |= u ? 160 : 128; a && a.nodeType === 8 && a.nextSibling; ) a = a.nextSibling;
      s[s.indexOf(a)] = null, e.__e = a;
    } else for (Ee = s.length; Ee--; ) kb(s[Ee]);
    else e.__e = r.__e, e.__k = r.__k;
    Jr.__e(A, e, r);
  }
  else s == null && e.__v === r.__v ? (e.__k = r.__k, e.__e = r.__e) : a = e.__e = bJ(r.__e, e, r, n, i, s, o, u, l);
  return (d = Jr.diffed) && d(e), 128 & e.__u ? void 0 : a;
}
function OS(t, e, r) {
  for (var n = 0; n < r.length; n++) Bb(r[n], r[++n], r[++n]);
  Jr.__c && Jr.__c(e, t), t.some(function(i) {
    try {
      t = i.__h, i.__h = [], t.some(function(s) {
        s.call(i);
      });
    } catch (s) {
      Jr.__e(s, i.__v);
    }
  });
}
function bJ(t, e, r, n, i, s, o, a, u) {
  var l, d, p, w, _, P, O, L = r.props, B = e.props, k = e.type;
  if (k === "svg" ? i = "http://www.w3.org/2000/svg" : k === "math" ? i = "http://www.w3.org/1998/Math/MathML" : i || (i = "http://www.w3.org/1999/xhtml"), s != null) {
    for (l = 0; l < s.length; l++) if ((_ = s[l]) && "setAttribute" in _ == !!k && (k ? _.localName === k : _.nodeType === 3)) {
      t = _, s[l] = null;
      break;
    }
  }
  if (t == null) {
    if (k === null) return document.createTextNode(B);
    t = document.createElementNS(i, k, B.is && B), a && (Jr.__m && Jr.__m(e, s), a = !1), s = null;
  }
  if (k === null) L === B || a && t.data === B || (t.data = B);
  else {
    if (s = s && Ep.call(t.childNodes), L = r.props || $l, !a && s != null) for (L = {}, l = 0; l < t.attributes.length; l++) L[(_ = t.attributes[l]).name] = _.value;
    for (l in L) if (_ = L[l], l != "children") {
      if (l == "dangerouslySetInnerHTML") p = _;
      else if (!(l in B)) {
        if (l == "value" && "defaultValue" in B || l == "checked" && "defaultChecked" in B) continue;
        Ad(t, l, null, _, i);
      }
    }
    for (l in B) _ = B[l], l == "children" ? w = _ : l == "dangerouslySetInnerHTML" ? d = _ : l == "value" ? P = _ : l == "checked" ? O = _ : a && typeof _ != "function" || L[l] === _ || Ad(t, l, _, L[l], i);
    if (d) a || p && (d.__html === p.__html || d.__html === t.innerHTML) || (t.innerHTML = d.__html), e.__k = [];
    else if (p && (t.innerHTML = ""), RS(t, Lb(w) ? w : [w], e, r, n, k === "foreignObject" ? "http://www.w3.org/1999/xhtml" : i, s, o, s ? s[0] : r.__k && Lu(r, 0), a, u), s != null) for (l = s.length; l--; ) kb(s[l]);
    a || (l = "value", k === "progress" && P == null ? t.removeAttribute("value") : P !== void 0 && (P !== t[l] || k === "progress" && !P || k === "option" && P !== L[l]) && Ad(t, l, P, L[l], i), l = "checked", O !== void 0 && O !== t[l] && Ad(t, l, O, L[l], i));
  }
  return t;
}
function Bb(t, e, r) {
  try {
    if (typeof t == "function") {
      var n = typeof t.__u == "function";
      n && t.__u(), n && e == null || (t.__u = t(e));
    } else t.current = e;
  } catch (i) {
    Jr.__e(i, r);
  }
}
function NS(t, e, r) {
  var n, i;
  if (Jr.unmount && Jr.unmount(t), (n = t.ref) && (n.current && n.current !== t.__e || Bb(n, null, e)), (n = t.__c) != null) {
    if (n.componentWillUnmount) try {
      n.componentWillUnmount();
    } catch (s) {
      Jr.__e(s, e);
    }
    n.base = n.__P = null;
  }
  if (n = t.__k) for (i = 0; i < n.length; i++) n[i] && NS(n[i], e, r || typeof t.type != "function");
  r || kb(t.__e), t.__c = t.__ = t.__e = void 0;
}
function yJ(t, e, r) {
  return this.constructor(t, r);
}
function iv(t, e, r) {
  var n, i, s, o;
  e === document && (e = document.documentElement), Jr.__ && Jr.__(t, e), i = (n = typeof r == "function") ? null : e.__k, s = [], o = [], $b(e, t = (!n && r || e).__k = Nr(dh, null, [t]), i || $l, $l, e.namespaceURI, !n && r ? [r] : i ? null : e.firstChild ? Ep.call(e.childNodes) : null, s, !n && r ? r : i ? i.__e : e.firstChild, n, o), OS(s, t, o);
}
Ep = CS.slice, Jr = { __e: function(t, e, r, n) {
  for (var i, s, o; e = e.__; ) if ((i = e.__c) && !i.__) try {
    if ((s = i.constructor) && s.getDerivedStateFromError != null && (i.setState(s.getDerivedStateFromError(t)), o = i.__d), i.componentDidCatch != null && (i.componentDidCatch(t, n || {}), o = i.__d), o) return i.__E = i;
  } catch (a) {
    t = a;
  }
  throw t;
} }, PS = 0, Kd.prototype.setState = function(t, e) {
  var r;
  r = this.__s != null && this.__s !== this.state ? this.__s : this.__s = va({}, this.state), typeof t == "function" && (t = t(va({}, r), this.props)), t && va(r, t), t != null && this.__v && (e && this._sb.push(e), T_(this));
}, Kd.prototype.forceUpdate = function(t) {
  this.__v && (this.__e = !0, t && this.__h.push(t), T_(this));
}, Kd.prototype.render = dh, ac = [], MS = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, tv = function(t, e) {
  return t.__v.__b - e.__v.__b;
}, A0.__r = 0, IS = /(PointerCapture)$|Capture$/i, Nb = 0, rv = D_(!1), nv = D_(!0);
var P0, pn, Um, O_, sv = 0, LS = [], yn = Jr, N_ = yn.__b, L_ = yn.__r, k_ = yn.diffed, $_ = yn.__c, B_ = yn.unmount, F_ = yn.__;
function kS(t, e) {
  yn.__h && yn.__h(pn, t, sv || e), sv = 0;
  var r = pn.__H || (pn.__H = { __: [], __h: [] });
  return t >= r.__.length && r.__.push({}), r.__[t];
}
function j_(t) {
  return sv = 1, wJ($S, t);
}
function wJ(t, e, r) {
  var n = kS(P0++, 2);
  if (n.t = t, !n.__c && (n.__ = [$S(void 0, e), function(a) {
    var u = n.__N ? n.__N[0] : n.__[0], l = n.t(u, a);
    u !== l && (n.__N = [l, n.__[1]], n.__c.setState({}));
  }], n.__c = pn, !pn.u)) {
    var i = function(a, u, l) {
      if (!n.__c.__H) return !0;
      var d = n.__c.__H.__.filter(function(w) {
        return !!w.__c;
      });
      if (d.every(function(w) {
        return !w.__N;
      })) return !s || s.call(this, a, u, l);
      var p = n.__c.props !== a;
      return d.forEach(function(w) {
        if (w.__N) {
          var _ = w.__[0];
          w.__ = w.__N, w.__N = void 0, _ !== w.__[0] && (p = !0);
        }
      }), s && s.call(this, a, u, l) || p;
    };
    pn.u = !0;
    var s = pn.shouldComponentUpdate, o = pn.componentWillUpdate;
    pn.componentWillUpdate = function(a, u, l) {
      if (this.__e) {
        var d = s;
        s = void 0, i(a, u, l), s = d;
      }
      o && o.call(this, a, u, l);
    }, pn.shouldComponentUpdate = i;
  }
  return n.__N || n.__;
}
function xJ(t, e) {
  var r = kS(P0++, 3);
  !yn.__s && SJ(r.__H, e) && (r.__ = t, r.i = e, pn.__H.__h.push(r));
}
function _J() {
  for (var t; t = LS.shift(); ) if (t.__P && t.__H) try {
    t.__H.__h.forEach(Vd), t.__H.__h.forEach(ov), t.__H.__h = [];
  } catch (e) {
    t.__H.__h = [], yn.__e(e, t.__v);
  }
}
yn.__b = function(t) {
  pn = null, N_ && N_(t);
}, yn.__ = function(t, e) {
  t && e.__k && e.__k.__m && (t.__m = e.__k.__m), F_ && F_(t, e);
}, yn.__r = function(t) {
  L_ && L_(t), P0 = 0;
  var e = (pn = t.__c).__H;
  e && (Um === pn ? (e.__h = [], pn.__h = [], e.__.forEach(function(r) {
    r.__N && (r.__ = r.__N), r.i = r.__N = void 0;
  })) : (e.__h.forEach(Vd), e.__h.forEach(ov), e.__h = [], P0 = 0)), Um = pn;
}, yn.diffed = function(t) {
  k_ && k_(t);
  var e = t.__c;
  e && e.__H && (e.__H.__h.length && (LS.push(e) !== 1 && O_ === yn.requestAnimationFrame || ((O_ = yn.requestAnimationFrame) || EJ)(_J)), e.__H.__.forEach(function(r) {
    r.i && (r.__H = r.i), r.i = void 0;
  })), Um = pn = null;
}, yn.__c = function(t, e) {
  e.some(function(r) {
    try {
      r.__h.forEach(Vd), r.__h = r.__h.filter(function(n) {
        return !n.__ || ov(n);
      });
    } catch (n) {
      e.some(function(i) {
        i.__h && (i.__h = []);
      }), e = [], yn.__e(n, r.__v);
    }
  }), $_ && $_(t, e);
}, yn.unmount = function(t) {
  B_ && B_(t);
  var e, r = t.__c;
  r && r.__H && (r.__H.__.forEach(function(n) {
    try {
      Vd(n);
    } catch (i) {
      e = i;
    }
  }), r.__H = void 0, e && yn.__e(e, r.__v));
};
var U_ = typeof requestAnimationFrame == "function";
function EJ(t) {
  var e, r = function() {
    clearTimeout(n), U_ && cancelAnimationFrame(e), setTimeout(t);
  }, n = setTimeout(r, 100);
  U_ && (e = requestAnimationFrame(r));
}
function Vd(t) {
  var e = pn, r = t.__c;
  typeof r == "function" && (t.__c = void 0, r()), pn = e;
}
function ov(t) {
  var e = pn;
  t.__c = t.__(), pn = e;
}
function SJ(t, e) {
  return !t || t.length !== e.length || e.some(function(r, n) {
    return r !== t[n];
  });
}
function $S(t, e) {
  return typeof e == "function" ? e(t) : e;
}
const AJ = ".-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}", PJ = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+", MJ = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=";
class IJ {
  constructor() {
    this.items = /* @__PURE__ */ new Map(), this.nextItemKey = 0, this.root = null, this.darkMode = ES();
  }
  attach(e) {
    this.root = document.createElement("div"), this.root.className = "-cbwsdk-snackbar-root", e.appendChild(this.root), this.render();
  }
  presentItem(e) {
    const r = this.nextItemKey++;
    return this.items.set(r, e), this.render(), () => {
      this.items.delete(r), this.render();
    };
  }
  clear() {
    this.items.clear(), this.render();
  }
  render() {
    this.root && iv(Nr(
      "div",
      null,
      Nr(BS, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([e, r]) => Nr(CJ, Object.assign({}, r, { key: e }))))
    ), this.root);
  }
}
const BS = (t) => Nr(
  "div",
  { class: tl("-cbwsdk-snackbar-container") },
  Nr("style", null, AJ),
  Nr("div", { class: "-cbwsdk-snackbar" }, t.children)
), CJ = ({ autoExpand: t, message: e, menuItems: r }) => {
  const [n, i] = j_(!0), [s, o] = j_(t ?? !1);
  xJ(() => {
    const u = [
      window.setTimeout(() => {
        i(!1);
      }, 1),
      window.setTimeout(() => {
        o(!0);
      }, 1e4)
    ];
    return () => {
      u.forEach(window.clearTimeout);
    };
  });
  const a = () => {
    o(!s);
  };
  return Nr(
    "div",
    { class: tl("-cbwsdk-snackbar-instance", n && "-cbwsdk-snackbar-instance-hidden", s && "-cbwsdk-snackbar-instance-expanded") },
    Nr(
      "div",
      { class: "-cbwsdk-snackbar-instance-header", onClick: a },
      Nr("img", { src: PJ, class: "-cbwsdk-snackbar-instance-header-cblogo" }),
      " ",
      Nr("div", { class: "-cbwsdk-snackbar-instance-header-message" }, e),
      Nr(
        "div",
        { class: "-gear-container" },
        !s && Nr(
          "svg",
          { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
          Nr("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" })
        ),
        Nr("img", { src: MJ, class: "-gear-icon", title: "Expand" })
      )
    ),
    r && r.length > 0 && Nr("div", { class: "-cbwsdk-snackbar-instance-menu" }, r.map((u, l) => Nr(
      "div",
      { class: tl("-cbwsdk-snackbar-instance-menu-item", u.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"), onClick: u.onClick, key: l },
      Nr(
        "svg",
        { width: u.svgWidth, height: u.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        Nr("path", { "fill-rule": u.defaultFillRule, "clip-rule": u.defaultClipRule, d: u.path, fill: "#AAAAAA" })
      ),
      Nr("span", { class: tl("-cbwsdk-snackbar-instance-menu-item-info", u.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red") }, u.info)
    )))
  );
};
class TJ {
  constructor() {
    this.attached = !1, this.snackbar = new IJ();
  }
  attach() {
    if (this.attached)
      throw new Error("Coinbase Wallet SDK UI is already attached");
    const e = document.documentElement, r = document.createElement("div");
    r.className = "-cbwsdk-css-reset", e.appendChild(r), this.snackbar.attach(r), this.attached = !0, SS();
  }
  showConnecting(e) {
    let r;
    return e.isUnlinkedErrorState ? r = {
      autoExpand: !0,
      message: "Connection lost",
      menuItems: [
        {
          isRed: !1,
          info: "Reset connection",
          svgWidth: "10",
          svgHeight: "11",
          path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
          defaultFillRule: "evenodd",
          defaultClipRule: "evenodd",
          onClick: e.onResetConnection
        }
      ]
    } : r = {
      message: "Confirm on phone",
      menuItems: [
        {
          isRed: !0,
          info: "Cancel transaction",
          svgWidth: "11",
          svgHeight: "11",
          path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
          defaultFillRule: "inherit",
          defaultClipRule: "inherit",
          onClick: e.onCancel
        },
        {
          isRed: !1,
          info: "Reset connection",
          svgWidth: "10",
          svgHeight: "11",
          path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
          defaultFillRule: "evenodd",
          defaultClipRule: "evenodd",
          onClick: e.onResetConnection
        }
      ]
    }, this.snackbar.presentItem(r);
  }
}
const RJ = ".-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop{position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s;background-color:rgba(10,11,13,.5)}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box{display:block;position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);padding:20px;border-radius:8px;background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box p{display:block;font-weight:400;font-size:14px;line-height:20px;padding-bottom:12px;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box button{appearance:none;border:none;background:none;color:#0052ff;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark{background-color:#0a0b0d;color:#fff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark button{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light{background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light button{color:#0052ff}";
class DJ {
  constructor() {
    this.root = null, this.darkMode = ES();
  }
  attach() {
    const e = document.documentElement;
    this.root = document.createElement("div"), this.root.className = "-cbwsdk-css-reset", e.appendChild(this.root), SS();
  }
  present(e) {
    this.render(e);
  }
  clear() {
    this.render(null);
  }
  render(e) {
    this.root && (iv(null, this.root), e && iv(Nr(OJ, Object.assign({}, e, { onDismiss: () => {
      this.clear();
    }, darkMode: this.darkMode })), this.root));
  }
}
const OJ = ({ title: t, buttonText: e, darkMode: r, onButtonClick: n, onDismiss: i }) => {
  const s = r ? "dark" : "light";
  return Nr(
    BS,
    { darkMode: r },
    Nr(
      "div",
      { class: "-cbwsdk-redirect-dialog" },
      Nr("style", null, RJ),
      Nr("div", { class: "-cbwsdk-redirect-dialog-backdrop", onClick: i }),
      Nr(
        "div",
        { class: tl("-cbwsdk-redirect-dialog-box", s) },
        Nr("p", null, t),
        Nr("button", { onClick: n }, e)
      )
    )
  );
}, NJ = "https://keys.coinbase.com/connect", q_ = "https://www.walletlink.org", LJ = "https://go.cb-w.com/walletlink";
class z_ {
  constructor() {
    this.attached = !1, this.redirectDialog = new DJ();
  }
  attach() {
    if (this.attached)
      throw new Error("Coinbase Wallet SDK UI is already attached");
    this.redirectDialog.attach(), this.attached = !0;
  }
  redirectToCoinbaseWallet(e) {
    const r = new URL(LJ);
    r.searchParams.append("redirect_url", hJ().href), e && r.searchParams.append("wl_url", e);
    const n = document.createElement("a");
    n.target = "cbw-opener", n.href = r.href, n.rel = "noreferrer noopener", n.click();
  }
  openCoinbaseWalletDeeplink(e) {
    this.redirectDialog.present({
      title: "Redirecting to Coinbase Wallet...",
      buttonText: "Open",
      onButtonClick: () => {
        this.redirectToCoinbaseWallet(e);
      }
    }), setTimeout(() => {
      this.redirectToCoinbaseWallet(e);
    }, 99);
  }
  showConnecting(e) {
    return () => {
      this.redirectDialog.clear();
    };
  }
}
class Mo {
  constructor(e) {
    this.chainCallbackParams = { chainId: "", jsonRpcUrl: "" }, this.isMobileWeb = dJ(), this.linkedUpdated = (s) => {
      this.isLinked = s;
      const o = this.storage.getItem(ev);
      if (s && (this._session.linked = s), this.isUnlinkedErrorState = !1, o) {
        const a = o.split(" "), u = this.storage.getItem("IsStandaloneSigning") === "true";
        a[0] !== "" && !s && this._session.linked && !u && (this.isUnlinkedErrorState = !0);
      }
    }, this.metadataUpdated = (s, o) => {
      this.storage.setItem(s, o);
    }, this.chainUpdated = (s, o) => {
      this.chainCallbackParams.chainId === s && this.chainCallbackParams.jsonRpcUrl === o || (this.chainCallbackParams = {
        chainId: s,
        jsonRpcUrl: o
      }, this.chainCallback && this.chainCallback(o, Number.parseInt(s, 10)));
    }, this.accountUpdated = (s) => {
      this.accountsCallback && this.accountsCallback([s]), Mo.accountRequestCallbackIds.size > 0 && (Array.from(Mo.accountRequestCallbackIds.values()).forEach((o) => {
        this.invokeCallback(o, {
          method: "requestEthereumAccounts",
          result: [s]
        });
      }), Mo.accountRequestCallbackIds.clear());
    }, this.resetAndReload = this.resetAndReload.bind(this), this.linkAPIUrl = e.linkAPIUrl, this.storage = e.storage, this.metadata = e.metadata, this.accountsCallback = e.accountsCallback, this.chainCallback = e.chainCallback;
    const { session: r, ui: n, connection: i } = this.subscribe();
    this._session = r, this.connection = i, this.relayEventManager = new fJ(), this.ui = n, this.ui.attach();
  }
  subscribe() {
    const e = Au.load(this.storage) || Au.create(this.storage), { linkAPIUrl: r } = this, n = new uJ({
      session: e,
      linkAPIUrl: r,
      listener: this
    }), i = this.isMobileWeb ? new z_() : new TJ();
    return n.connect(), { session: e, ui: i, connection: n };
  }
  resetAndReload() {
    this.connection.destroy().then(() => {
      const e = Au.load(this.storage);
      (e == null ? void 0 : e.id) === this._session.id && no.clearAll(), document.location.reload();
    }).catch((e) => {
    });
  }
  signEthereumTransaction(e) {
    return this.sendRequest({
      method: "signEthereumTransaction",
      params: {
        fromAddress: e.fromAddress,
        toAddress: e.toAddress,
        weiValue: js(e.weiValue),
        data: Zf(e.data, !0),
        nonce: e.nonce,
        gasPriceInWei: e.gasPriceInWei ? js(e.gasPriceInWei) : null,
        maxFeePerGas: e.gasPriceInWei ? js(e.gasPriceInWei) : null,
        maxPriorityFeePerGas: e.gasPriceInWei ? js(e.gasPriceInWei) : null,
        gasLimit: e.gasLimit ? js(e.gasLimit) : null,
        chainId: e.chainId,
        shouldSubmit: !1
      }
    });
  }
  signAndSubmitEthereumTransaction(e) {
    return this.sendRequest({
      method: "signEthereumTransaction",
      params: {
        fromAddress: e.fromAddress,
        toAddress: e.toAddress,
        weiValue: js(e.weiValue),
        data: Zf(e.data, !0),
        nonce: e.nonce,
        gasPriceInWei: e.gasPriceInWei ? js(e.gasPriceInWei) : null,
        maxFeePerGas: e.maxFeePerGas ? js(e.maxFeePerGas) : null,
        maxPriorityFeePerGas: e.maxPriorityFeePerGas ? js(e.maxPriorityFeePerGas) : null,
        gasLimit: e.gasLimit ? js(e.gasLimit) : null,
        chainId: e.chainId,
        shouldSubmit: !0
      }
    });
  }
  submitEthereumTransaction(e, r) {
    return this.sendRequest({
      method: "submitEthereumTransaction",
      params: {
        signedTransaction: Zf(e, !0),
        chainId: r
      }
    });
  }
  getWalletLinkSession() {
    return this._session;
  }
  sendRequest(e) {
    let r = null;
    const n = sc(8), i = (s) => {
      this.publishWeb3RequestCanceledEvent(n), this.handleErrorResponse(n, e.method, s), r == null || r();
    };
    return new Promise((s, o) => {
      r = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: i,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      }), this.relayEventManager.callbacks.set(n, (a) => {
        if (r == null || r(), jn(a))
          return o(new Error(a.errorMessage));
        s(a);
      }), this.publishWeb3RequestEvent(n, e);
    });
  }
  publishWeb3RequestEvent(e, r) {
    const n = { type: "WEB3_REQUEST", id: e, request: r };
    this.publishEvent("Web3Request", n, !0).then((i) => {
    }).catch((i) => {
      this.handleWeb3ResponseMessage(n.id, {
        method: r.method,
        errorMessage: i.message
      });
    }), this.isMobileWeb && this.openCoinbaseWalletDeeplink(r.method);
  }
  // copied from MobileRelay
  openCoinbaseWalletDeeplink(e) {
    if (this.ui instanceof z_)
      switch (e) {
        case "requestEthereumAccounts":
        case "switchEthereumChain":
          return;
        default:
          window.addEventListener("blur", () => {
            window.addEventListener("focus", () => {
              this.connection.checkUnseenEvents();
            }, { once: !0 });
          }, { once: !0 }), this.ui.openCoinbaseWalletDeeplink();
          break;
      }
  }
  publishWeb3RequestCanceledEvent(e) {
    const r = {
      type: "WEB3_REQUEST_CANCELED",
      id: e
    };
    this.publishEvent("Web3RequestCanceled", r, !1).then();
  }
  publishEvent(e, r, n) {
    return this.connection.publishEvent(e, r, n);
  }
  handleWeb3ResponseMessage(e, r) {
    if (r.method === "requestEthereumAccounts") {
      Mo.accountRequestCallbackIds.forEach((n) => this.invokeCallback(n, r)), Mo.accountRequestCallbackIds.clear();
      return;
    }
    this.invokeCallback(e, r);
  }
  handleErrorResponse(e, r, n) {
    var i;
    const s = (i = n == null ? void 0 : n.message) !== null && i !== void 0 ? i : "Unspecified error message.";
    this.handleWeb3ResponseMessage(e, {
      method: r,
      errorMessage: s
    });
  }
  invokeCallback(e, r) {
    const n = this.relayEventManager.callbacks.get(e);
    n && (n(r), this.relayEventManager.callbacks.delete(e));
  }
  requestEthereumAccounts() {
    const { appName: e, appLogoUrl: r } = this.metadata, n = {
      method: "requestEthereumAccounts",
      params: {
        appName: e,
        appLogoUrl: r
      }
    }, i = sc(8);
    return new Promise((s, o) => {
      this.relayEventManager.callbacks.set(i, (a) => {
        if (jn(a))
          return o(new Error(a.errorMessage));
        s(a);
      }), Mo.accountRequestCallbackIds.add(i), this.publishWeb3RequestEvent(i, n);
    });
  }
  watchAsset(e, r, n, i, s, o) {
    const a = {
      method: "watchAsset",
      params: {
        type: e,
        options: {
          address: r,
          symbol: n,
          decimals: i,
          image: s
        },
        chainId: o
      }
    };
    let u = null;
    const l = sc(8), d = (p) => {
      this.publishWeb3RequestCanceledEvent(l), this.handleErrorResponse(l, a.method, p), u == null || u();
    };
    return u = this.ui.showConnecting({
      isUnlinkedErrorState: this.isUnlinkedErrorState,
      onCancel: d,
      onResetConnection: this.resetAndReload
      // eslint-disable-line @typescript-eslint/unbound-method
    }), new Promise((p, w) => {
      this.relayEventManager.callbacks.set(l, (_) => {
        if (u == null || u(), jn(_))
          return w(new Error(_.errorMessage));
        p(_);
      }), this.publishWeb3RequestEvent(l, a);
    });
  }
  addEthereumChain(e, r, n, i, s, o) {
    const a = {
      method: "addEthereumChain",
      params: {
        chainId: e,
        rpcUrls: r,
        blockExplorerUrls: i,
        chainName: s,
        iconUrls: n,
        nativeCurrency: o
      }
    };
    let u = null;
    const l = sc(8), d = (p) => {
      this.publishWeb3RequestCanceledEvent(l), this.handleErrorResponse(l, a.method, p), u == null || u();
    };
    return u = this.ui.showConnecting({
      isUnlinkedErrorState: this.isUnlinkedErrorState,
      onCancel: d,
      onResetConnection: this.resetAndReload
      // eslint-disable-line @typescript-eslint/unbound-method
    }), new Promise((p, w) => {
      this.relayEventManager.callbacks.set(l, (_) => {
        if (u == null || u(), jn(_))
          return w(new Error(_.errorMessage));
        p(_);
      }), this.publishWeb3RequestEvent(l, a);
    });
  }
  switchEthereumChain(e, r) {
    const n = {
      method: "switchEthereumChain",
      params: Object.assign({ chainId: e }, { address: r })
    };
    let i = null;
    const s = sc(8), o = (a) => {
      this.publishWeb3RequestCanceledEvent(s), this.handleErrorResponse(s, n.method, a), i == null || i();
    };
    return i = this.ui.showConnecting({
      isUnlinkedErrorState: this.isUnlinkedErrorState,
      onCancel: o,
      onResetConnection: this.resetAndReload
      // eslint-disable-line @typescript-eslint/unbound-method
    }), new Promise((a, u) => {
      this.relayEventManager.callbacks.set(s, (l) => {
        if (i == null || i(), jn(l) && l.errorCode)
          return u(Ar.provider.custom({
            code: l.errorCode,
            message: "Unrecognized chain ID. Try adding the chain using addEthereumChain first."
          }));
        if (jn(l))
          return u(new Error(l.errorMessage));
        a(l);
      }), this.publishWeb3RequestEvent(s, n);
    });
  }
}
Mo.accountRequestCallbackIds = /* @__PURE__ */ new Set();
const W_ = "DefaultChainId", H_ = "DefaultJsonRpcUrl";
class FS {
  constructor(e) {
    this._relay = null, this._addresses = [], this.metadata = e.metadata, this._storage = new no("walletlink", q_), this.callback = e.callback || null;
    const r = this._storage.getItem(ev);
    if (r) {
      const n = r.split(" ");
      n[0] !== "" && (this._addresses = n.map((i) => ia(i)));
    }
    this.initializeRelay();
  }
  getSession() {
    const e = this.initializeRelay(), { id: r, secret: n } = e.getWalletLinkSession();
    return { id: r, secret: n };
  }
  async handshake() {
    await this._eth_requestAccounts();
  }
  get selectedAddress() {
    return this._addresses[0] || void 0;
  }
  get jsonRpcUrl() {
    var e;
    return (e = this._storage.getItem(H_)) !== null && e !== void 0 ? e : void 0;
  }
  set jsonRpcUrl(e) {
    this._storage.setItem(H_, e);
  }
  updateProviderInfo(e, r) {
    var n;
    this.jsonRpcUrl = e;
    const i = this.getChainId();
    this._storage.setItem(W_, r.toString(10)), Qf(r) !== i && ((n = this.callback) === null || n === void 0 || n.call(this, "chainChanged", ma(r)));
  }
  async watchAsset(e) {
    const r = Array.isArray(e) ? e[0] : e;
    if (!r.type)
      throw Ar.rpc.invalidParams("Type is required");
    if ((r == null ? void 0 : r.type) !== "ERC20")
      throw Ar.rpc.invalidParams(`Asset of type '${r.type}' is not supported`);
    if (!(r != null && r.options))
      throw Ar.rpc.invalidParams("Options are required");
    if (!(r != null && r.options.address))
      throw Ar.rpc.invalidParams("Address is required");
    const n = this.getChainId(), { address: i, symbol: s, image: o, decimals: a } = r.options, l = await this.initializeRelay().watchAsset(r.type, i, s, a, o, n == null ? void 0 : n.toString());
    return jn(l) ? !1 : !!l.result;
  }
  async addEthereumChain(e) {
    var r, n;
    const i = e[0];
    if (((r = i.rpcUrls) === null || r === void 0 ? void 0 : r.length) === 0)
      throw Ar.rpc.invalidParams("please pass in at least 1 rpcUrl");
    if (!i.chainName || i.chainName.trim() === "")
      throw Ar.rpc.invalidParams("chainName is a required field");
    if (!i.nativeCurrency)
      throw Ar.rpc.invalidParams("nativeCurrency is a required field");
    const s = Number.parseInt(i.chainId, 16);
    if (s === this.getChainId())
      return !1;
    const o = this.initializeRelay(), { rpcUrls: a = [], blockExplorerUrls: u = [], chainName: l, iconUrls: d = [], nativeCurrency: p } = i, w = await o.addEthereumChain(s.toString(), a, d, u, l, p);
    if (jn(w))
      return !1;
    if (((n = w.result) === null || n === void 0 ? void 0 : n.isApproved) === !0)
      return this.updateProviderInfo(a[0], s), null;
    throw Ar.rpc.internal("unable to add ethereum chain");
  }
  async switchEthereumChain(e) {
    const r = e[0], n = Number.parseInt(r.chainId, 16), s = await this.initializeRelay().switchEthereumChain(n.toString(10), this.selectedAddress || void 0);
    if (jn(s))
      throw s;
    const o = s.result;
    return o.isApproved && o.rpcUrl.length > 0 && this.updateProviderInfo(o.rpcUrl, n), null;
  }
  async cleanup() {
    this.callback = null, this._relay && this._relay.resetAndReload(), this._storage.clear();
  }
  _setAddresses(e, r) {
    var n;
    if (!Array.isArray(e))
      throw new Error("addresses is not an array");
    const i = e.map((s) => ia(s));
    JSON.stringify(i) !== JSON.stringify(this._addresses) && (this._addresses = i, (n = this.callback) === null || n === void 0 || n.call(this, "accountsChanged", i), this._storage.setItem(ev, i.join(" ")));
  }
  async request(e) {
    const r = e.params || [];
    switch (e.method) {
      case "eth_accounts":
        return [...this._addresses];
      case "eth_coinbase":
        return this.selectedAddress || null;
      case "net_version":
        return this.getChainId().toString(10);
      case "eth_chainId":
        return ma(this.getChainId());
      case "eth_requestAccounts":
        return this._eth_requestAccounts();
      case "eth_ecRecover":
      case "personal_ecRecover":
        return this.ecRecover(e);
      case "personal_sign":
        return this.personalSign(e);
      case "eth_signTransaction":
        return this._eth_signTransaction(r);
      case "eth_sendRawTransaction":
        return this._eth_sendRawTransaction(r);
      case "eth_sendTransaction":
        return this._eth_sendTransaction(r);
      case "eth_signTypedData_v1":
      case "eth_signTypedData_v3":
      case "eth_signTypedData_v4":
      case "eth_signTypedData":
        return this.signTypedData(e);
      case "wallet_addEthereumChain":
        return this.addEthereumChain(r);
      case "wallet_switchEthereumChain":
        return this.switchEthereumChain(r);
      case "wallet_watchAsset":
        return this.watchAsset(r);
      default:
        if (!this.jsonRpcUrl)
          throw Ar.rpc.internal("No RPC URL set for chain");
        return hS(e, this.jsonRpcUrl);
    }
  }
  _ensureKnownAddress(e) {
    const r = ia(e);
    if (!this._addresses.map((i) => ia(i)).includes(r))
      throw new Error("Unknown Ethereum address");
  }
  _prepareTransactionParams(e) {
    const r = e.from ? ia(e.from) : this.selectedAddress;
    if (!r)
      throw new Error("Ethereum address is unavailable");
    this._ensureKnownAddress(r);
    const n = e.to ? ia(e.to) : null, i = e.value != null ? Bf(e.value) : BigInt(0), s = e.data ? Q1(e.data) : Buffer.alloc(0), o = e.nonce != null ? Qf(e.nonce) : null, a = e.gasPrice != null ? Bf(e.gasPrice) : null, u = e.maxFeePerGas != null ? Bf(e.maxFeePerGas) : null, l = e.maxPriorityFeePerGas != null ? Bf(e.maxPriorityFeePerGas) : null, d = e.gas != null ? Bf(e.gas) : null, p = e.chainId ? Qf(e.chainId) : this.getChainId();
    return {
      fromAddress: r,
      toAddress: n,
      weiValue: i,
      data: s,
      nonce: o,
      gasPriceInWei: a,
      maxFeePerGas: u,
      maxPriorityFeePerGas: l,
      gasLimit: d,
      chainId: p
    };
  }
  async ecRecover(e) {
    const { method: r, params: n } = e;
    if (!Array.isArray(n))
      throw Ar.rpc.invalidParams();
    const s = await this.initializeRelay().sendRequest({
      method: "ethereumAddressFromSignedMessage",
      params: {
        message: km(n[0]),
        signature: km(n[1]),
        addPrefix: r === "personal_ecRecover"
      }
    });
    if (jn(s))
      throw s;
    return s.result;
  }
  getChainId() {
    var e;
    return Number.parseInt((e = this._storage.getItem(W_)) !== null && e !== void 0 ? e : "1", 10);
  }
  async _eth_requestAccounts() {
    var e, r;
    if (this._addresses.length > 0)
      return (e = this.callback) === null || e === void 0 || e.call(this, "connect", { chainId: ma(this.getChainId()) }), this._addresses;
    const i = await this.initializeRelay().requestEthereumAccounts();
    if (jn(i))
      throw i;
    if (!i.result)
      throw new Error("accounts received is empty");
    return this._setAddresses(i.result), (r = this.callback) === null || r === void 0 || r.call(this, "connect", { chainId: ma(this.getChainId()) }), this._addresses;
  }
  async personalSign({ params: e }) {
    if (!Array.isArray(e))
      throw Ar.rpc.invalidParams();
    const r = e[1], n = e[0];
    this._ensureKnownAddress(r);
    const s = await this.initializeRelay().sendRequest({
      method: "signEthereumMessage",
      params: {
        address: ia(r),
        message: km(n),
        addPrefix: !0,
        typedDataJson: null
      }
    });
    if (jn(s))
      throw s;
    return s.result;
  }
  async _eth_signTransaction(e) {
    const r = this._prepareTransactionParams(e[0] || {}), i = await this.initializeRelay().signEthereumTransaction(r);
    if (jn(i))
      throw i;
    return i.result;
  }
  async _eth_sendRawTransaction(e) {
    const r = Q1(e[0]), i = await this.initializeRelay().submitEthereumTransaction(r, this.getChainId());
    if (jn(i))
      throw i;
    return i.result;
  }
  async _eth_sendTransaction(e) {
    const r = this._prepareTransactionParams(e[0] || {}), i = await this.initializeRelay().signAndSubmitEthereumTransaction(r);
    if (jn(i))
      throw i;
    return i.result;
  }
  async signTypedData(e) {
    const { method: r, params: n } = e;
    if (!Array.isArray(n))
      throw Ar.rpc.invalidParams();
    const i = (l) => {
      const d = {
        eth_signTypedData_v1: Sd.hashForSignTypedDataLegacy,
        eth_signTypedData_v3: Sd.hashForSignTypedData_v3,
        eth_signTypedData_v4: Sd.hashForSignTypedData_v4,
        eth_signTypedData: Sd.hashForSignTypedData_v4
      };
      return Zf(d[r]({
        data: IY(l)
      }), !0);
    }, s = n[r === "eth_signTypedData_v1" ? 1 : 0], o = n[r === "eth_signTypedData_v1" ? 0 : 1];
    this._ensureKnownAddress(s);
    const u = await this.initializeRelay().sendRequest({
      method: "signEthereumMessage",
      params: {
        address: ia(s),
        message: i(o),
        typedDataJson: JSON.stringify(o, null, 2),
        addPrefix: !1
      }
    });
    if (jn(u))
      throw u;
    return u.result;
  }
  initializeRelay() {
    return this._relay || (this._relay = new Mo({
      linkAPIUrl: q_,
      storage: this._storage,
      metadata: this.metadata,
      accountsCallback: this._setAddresses.bind(this),
      chainCallback: this.updateProviderInfo.bind(this)
    })), this._relay;
  }
}
const jS = "SignerType", US = new no("CBWSDK", "SignerConfigurator");
function kJ() {
  return US.getItem(jS);
}
function $J(t) {
  US.setItem(jS, t);
}
async function BJ(t) {
  const { communicator: e, metadata: r, handshakeRequest: n, callback: i } = t;
  jJ(e, r, i).catch(() => {
  });
  const s = {
    id: crypto.randomUUID(),
    event: "selectSignerType",
    data: Object.assign(Object.assign({}, t.preference), { handshakeRequest: n })
  }, { data: o } = await e.postRequestAndWaitForResponse(s);
  return o;
}
function FJ(t) {
  const { signerType: e, metadata: r, communicator: n, callback: i } = t;
  switch (e) {
    case "scw":
      return new UY({
        metadata: r,
        callback: i,
        communicator: n
      });
    case "walletlink":
      return new FS({
        metadata: r,
        callback: i
      });
  }
}
async function jJ(t, e, r) {
  await t.onMessage(({ event: i }) => i === "WalletLinkSessionRequest");
  const n = new FS({
    metadata: e,
    callback: r
  });
  t.postMessage({
    event: "WalletLinkUpdate",
    data: { session: n.getSession() }
  }), await n.handshake(), t.postMessage({
    event: "WalletLinkUpdate",
    data: { connected: !0 }
  });
}
const UJ = `Coinbase Wallet SDK requires the Cross-Origin-Opener-Policy header to not be set to 'same-origin'. This is to ensure that the SDK can communicate with the Coinbase Smart Wallet app.

Please see https://www.smartwallet.dev/guides/tips/popup-tips#cross-origin-opener-policy for more information.`, qJ = () => {
  let t;
  return {
    getCrossOriginOpenerPolicy: () => t === void 0 ? "undefined" : t,
    checkCrossOriginOpenerPolicy: async () => {
      if (typeof window > "u") {
        t = "non-browser-env";
        return;
      }
      try {
        const e = `${window.location.origin}${window.location.pathname}`, r = await fetch(e, {
          method: "HEAD"
        });
        if (!r.ok)
          throw new Error(`HTTP error! status: ${r.status}`);
        const n = r.headers.get("Cross-Origin-Opener-Policy");
        t = n ?? "null", t === "same-origin" && console.error(UJ);
      } catch (e) {
        console.error("Error checking Cross-Origin-Opener-Policy:", e.message), t = "error";
      }
    }
  };
}, { checkCrossOriginOpenerPolicy: zJ, getCrossOriginOpenerPolicy: WJ } = qJ(), K_ = 420, V_ = 540;
function HJ(t) {
  const e = (window.innerWidth - K_) / 2 + window.screenX, r = (window.innerHeight - V_) / 2 + window.screenY;
  VJ(t);
  const n = window.open(t, "Smart Wallet", `width=${K_}, height=${V_}, left=${e}, top=${r}`);
  if (n == null || n.focus(), !n)
    throw Ar.rpc.internal("Pop up window failed to open");
  return n;
}
function KJ(t) {
  t && !t.closed && t.close();
}
function VJ(t) {
  const e = {
    sdkName: lS,
    sdkVersion: hh,
    origin: window.location.origin,
    coop: WJ()
  };
  for (const [r, n] of Object.entries(e))
    t.searchParams.append(r, n.toString());
}
class GJ {
  constructor({ url: e = NJ, metadata: r, preference: n }) {
    this.popup = null, this.listeners = /* @__PURE__ */ new Map(), this.postMessage = async (i) => {
      (await this.waitForPopupLoaded()).postMessage(i, this.url.origin);
    }, this.postRequestAndWaitForResponse = async (i) => {
      const s = this.onMessage(({ requestId: o }) => o === i.id);
      return this.postMessage(i), await s;
    }, this.onMessage = async (i) => new Promise((s, o) => {
      const a = (u) => {
        if (u.origin !== this.url.origin)
          return;
        const l = u.data;
        i(l) && (s(l), window.removeEventListener("message", a), this.listeners.delete(a));
      };
      window.addEventListener("message", a), this.listeners.set(a, { reject: o });
    }), this.disconnect = () => {
      KJ(this.popup), this.popup = null, this.listeners.forEach(({ reject: i }, s) => {
        i(Ar.provider.userRejectedRequest("Request rejected")), window.removeEventListener("message", s);
      }), this.listeners.clear();
    }, this.waitForPopupLoaded = async () => this.popup && !this.popup.closed ? (this.popup.focus(), this.popup) : (this.popup = HJ(this.url), this.onMessage(({ event: i }) => i === "PopupUnload").then(this.disconnect).catch(() => {
    }), this.onMessage(({ event: i }) => i === "PopupLoaded").then((i) => {
      this.postMessage({
        requestId: i.id,
        data: {
          version: hh,
          metadata: this.metadata,
          preference: this.preference,
          location: window.location.toString()
        }
      });
    }).then(() => {
      if (!this.popup)
        throw Ar.rpc.internal();
      return this.popup;
    })), this.url = new URL(e), this.metadata = r, this.preference = n;
  }
}
function YJ(t) {
  const e = EY(JJ(t), {
    shouldIncludeStack: !0
  }), r = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
  return r.searchParams.set("version", hh), r.searchParams.set("code", e.code.toString()), r.searchParams.set("message", e.message), Object.assign(Object.assign({}, e), { docUrl: r.href });
}
function JJ(t) {
  var e;
  if (typeof t == "string")
    return {
      message: t,
      code: fn.rpc.internal
    };
  if (jn(t)) {
    const r = t.errorMessage, n = (e = t.errorCode) !== null && e !== void 0 ? e : r.match(/(denied|rejected)/i) ? fn.provider.userRejectedRequest : void 0;
    return Object.assign(Object.assign({}, t), {
      message: r,
      code: n,
      data: { method: t.method }
    });
  }
  return t;
}
var qS = { exports: {} };
(function(t) {
  var e = Object.prototype.hasOwnProperty, r = "~";
  function n() {
  }
  Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (r = !1));
  function i(u, l, d) {
    this.fn = u, this.context = l, this.once = d || !1;
  }
  function s(u, l, d, p, w) {
    if (typeof d != "function")
      throw new TypeError("The listener must be a function");
    var _ = new i(d, p || u, w), P = r ? r + l : l;
    return u._events[P] ? u._events[P].fn ? u._events[P] = [u._events[P], _] : u._events[P].push(_) : (u._events[P] = _, u._eventsCount++), u;
  }
  function o(u, l) {
    --u._eventsCount === 0 ? u._events = new n() : delete u._events[l];
  }
  function a() {
    this._events = new n(), this._eventsCount = 0;
  }
  a.prototype.eventNames = function() {
    var l = [], d, p;
    if (this._eventsCount === 0) return l;
    for (p in d = this._events)
      e.call(d, p) && l.push(r ? p.slice(1) : p);
    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(d)) : l;
  }, a.prototype.listeners = function(l) {
    var d = r ? r + l : l, p = this._events[d];
    if (!p) return [];
    if (p.fn) return [p.fn];
    for (var w = 0, _ = p.length, P = new Array(_); w < _; w++)
      P[w] = p[w].fn;
    return P;
  }, a.prototype.listenerCount = function(l) {
    var d = r ? r + l : l, p = this._events[d];
    return p ? p.fn ? 1 : p.length : 0;
  }, a.prototype.emit = function(l, d, p, w, _, P) {
    var O = r ? r + l : l;
    if (!this._events[O]) return !1;
    var L = this._events[O], B = arguments.length, k, q;
    if (L.fn) {
      switch (L.once && this.removeListener(l, L.fn, void 0, !0), B) {
        case 1:
          return L.fn.call(L.context), !0;
        case 2:
          return L.fn.call(L.context, d), !0;
        case 3:
          return L.fn.call(L.context, d, p), !0;
        case 4:
          return L.fn.call(L.context, d, p, w), !0;
        case 5:
          return L.fn.call(L.context, d, p, w, _), !0;
        case 6:
          return L.fn.call(L.context, d, p, w, _, P), !0;
      }
      for (q = 1, k = new Array(B - 1); q < B; q++)
        k[q - 1] = arguments[q];
      L.fn.apply(L.context, k);
    } else {
      var U = L.length, V;
      for (q = 0; q < U; q++)
        switch (L[q].once && this.removeListener(l, L[q].fn, void 0, !0), B) {
          case 1:
            L[q].fn.call(L[q].context);
            break;
          case 2:
            L[q].fn.call(L[q].context, d);
            break;
          case 3:
            L[q].fn.call(L[q].context, d, p);
            break;
          case 4:
            L[q].fn.call(L[q].context, d, p, w);
            break;
          default:
            if (!k) for (V = 1, k = new Array(B - 1); V < B; V++)
              k[V - 1] = arguments[V];
            L[q].fn.apply(L[q].context, k);
        }
    }
    return !0;
  }, a.prototype.on = function(l, d, p) {
    return s(this, l, d, p, !1);
  }, a.prototype.once = function(l, d, p) {
    return s(this, l, d, p, !0);
  }, a.prototype.removeListener = function(l, d, p, w) {
    var _ = r ? r + l : l;
    if (!this._events[_]) return this;
    if (!d)
      return o(this, _), this;
    var P = this._events[_];
    if (P.fn)
      P.fn === d && (!w || P.once) && (!p || P.context === p) && o(this, _);
    else {
      for (var O = 0, L = [], B = P.length; O < B; O++)
        (P[O].fn !== d || w && !P[O].once || p && P[O].context !== p) && L.push(P[O]);
      L.length ? this._events[_] = L.length === 1 ? L[0] : L : o(this, _);
    }
    return this;
  }, a.prototype.removeAllListeners = function(l) {
    var d;
    return l ? (d = r ? r + l : l, this._events[d] && o(this, d)) : (this._events = new n(), this._eventsCount = 0), this;
  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, t.exports = a;
})(qS);
var XJ = qS.exports;
const ZJ = /* @__PURE__ */ ns(XJ);
class QJ extends ZJ {
}
var eX = function(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
  return r;
};
class tX extends QJ {
  constructor(e) {
    var { metadata: r } = e, n = e.preference, { keysUrl: i } = n, s = eX(n, ["keysUrl"]);
    super(), this.signer = null, this.isCoinbaseWallet = !0, this.metadata = r, this.preference = s, this.communicator = new GJ({
      url: i,
      metadata: r,
      preference: s
    });
    const o = kJ();
    o && (this.signer = this.initSigner(o));
  }
  async request(e) {
    try {
      if (jY(e), !this.signer)
        switch (e.method) {
          case "eth_requestAccounts": {
            const r = await this.requestSignerSelection(e), n = this.initSigner(r);
            await n.handshake(e), this.signer = n, $J(r);
            break;
          }
          case "net_version":
            return 1;
          case "eth_chainId":
            return ma(1);
          default:
            throw Ar.provider.unauthorized("Must call 'eth_requestAccounts' before other methods");
        }
      return this.signer.request(e);
    } catch (r) {
      const { code: n } = r;
      return n === fn.provider.unauthorized && this.disconnect(), Promise.reject(YJ(r));
    }
  }
  /** @deprecated Use `.request({ method: 'eth_requestAccounts' })` instead. */
  async enable() {
    return console.warn('.enable() has been deprecated. Please use .request({ method: "eth_requestAccounts" }) instead.'), await this.request({
      method: "eth_requestAccounts"
    });
  }
  async disconnect() {
    var e;
    await ((e = this.signer) === null || e === void 0 ? void 0 : e.cleanup()), this.signer = null, no.clearAll(), this.emit("disconnect", Ar.provider.disconnected("User initiated disconnection"));
  }
  requestSignerSelection(e) {
    return BJ({
      communicator: this.communicator,
      preference: this.preference,
      metadata: this.metadata,
      handshakeRequest: e,
      callback: this.emit.bind(this)
    });
  }
  initSigner(e) {
    return FJ({
      signerType: e,
      metadata: this.metadata,
      communicator: this.communicator,
      callback: this.emit.bind(this)
    });
  }
}
function rX(t) {
  if (t) {
    if (!["all", "smartWalletOnly", "eoaOnly"].includes(t.options))
      throw new Error(`Invalid options: ${t.options}`);
    if (t.attribution && t.attribution.auto !== void 0 && t.attribution.dataSuffix !== void 0)
      throw new Error("Attribution cannot contain both auto and dataSuffix properties");
  }
}
function nX(t) {
  var e;
  const r = {
    metadata: t.metadata,
    preference: t.preference
  };
  return (e = FY(r)) !== null && e !== void 0 ? e : new tX(r);
}
const iX = {
  options: "all"
};
function sX(t) {
  var e;
  new no("CBWSDK").setItem("VERSION", hh), zJ();
  const n = {
    metadata: {
      appName: t.appName || "Dapp",
      appLogoUrl: t.appLogoUrl || "",
      appChainIds: t.appChainIds || []
    },
    preference: Object.assign(iX, (e = t.preference) !== null && e !== void 0 ? e : {})
  };
  rX(n.preference);
  let i = null;
  return {
    getProvider: () => (i || (i = nX(n)), i)
  };
}
function zS(t, e) {
  return function() {
    return t.apply(e, arguments);
  };
}
const { toString: oX } = Object.prototype, { getPrototypeOf: Fb } = Object, Sp = /* @__PURE__ */ ((t) => (e) => {
  const r = oX.call(e);
  return t[r] || (t[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Ts = (t) => (t = t.toLowerCase(), (e) => Sp(e) === t), Ap = (t) => (e) => typeof e === t, { isArray: Xu } = Array, Bl = Ap("undefined");
function aX(t) {
  return t !== null && !Bl(t) && t.constructor !== null && !Bl(t.constructor) && Ni(t.constructor.isBuffer) && t.constructor.isBuffer(t);
}
const WS = Ts("ArrayBuffer");
function cX(t) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && WS(t.buffer), e;
}
const uX = Ap("string"), Ni = Ap("function"), HS = Ap("number"), Pp = (t) => t !== null && typeof t == "object", fX = (t) => t === !0 || t === !1, Gd = (t) => {
  if (Sp(t) !== "object")
    return !1;
  const e = Fb(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
}, lX = Ts("Date"), hX = Ts("File"), dX = Ts("Blob"), pX = Ts("FileList"), gX = (t) => Pp(t) && Ni(t.pipe), mX = (t) => {
  let e;
  return t && (typeof FormData == "function" && t instanceof FormData || Ni(t.append) && ((e = Sp(t)) === "formdata" || // detect form-data instance
  e === "object" && Ni(t.toString) && t.toString() === "[object FormData]"));
}, vX = Ts("URLSearchParams"), [bX, yX, wX, xX] = ["ReadableStream", "Request", "Response", "Headers"].map(Ts), _X = (t) => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function ph(t, e, { allOwnKeys: r = !1 } = {}) {
  if (t === null || typeof t > "u")
    return;
  let n, i;
  if (typeof t != "object" && (t = [t]), Xu(t))
    for (n = 0, i = t.length; n < i; n++)
      e.call(null, t[n], n, t);
  else {
    const s = r ? Object.getOwnPropertyNames(t) : Object.keys(t), o = s.length;
    let a;
    for (n = 0; n < o; n++)
      a = s[n], e.call(null, t[a], a, t);
  }
}
function KS(t, e) {
  e = e.toLowerCase();
  const r = Object.keys(t);
  let n = r.length, i;
  for (; n-- > 0; )
    if (i = r[n], e === i.toLowerCase())
      return i;
  return null;
}
const lc = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, VS = (t) => !Bl(t) && t !== lc;
function av() {
  const { caseless: t } = VS(this) && this || {}, e = {}, r = (n, i) => {
    const s = t && KS(e, i) || i;
    Gd(e[s]) && Gd(n) ? e[s] = av(e[s], n) : Gd(n) ? e[s] = av({}, n) : Xu(n) ? e[s] = n.slice() : e[s] = n;
  };
  for (let n = 0, i = arguments.length; n < i; n++)
    arguments[n] && ph(arguments[n], r);
  return e;
}
const EX = (t, e, r, { allOwnKeys: n } = {}) => (ph(e, (i, s) => {
  r && Ni(i) ? t[s] = zS(i, r) : t[s] = i;
}, { allOwnKeys: n }), t), SX = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), AX = (t, e, r, n) => {
  t.prototype = Object.create(e.prototype, n), t.prototype.constructor = t, Object.defineProperty(t, "super", {
    value: e.prototype
  }), r && Object.assign(t.prototype, r);
}, PX = (t, e, r, n) => {
  let i, s, o;
  const a = {};
  if (e = e || {}, t == null) return e;
  do {
    for (i = Object.getOwnPropertyNames(t), s = i.length; s-- > 0; )
      o = i[s], (!n || n(o, t, e)) && !a[o] && (e[o] = t[o], a[o] = !0);
    t = r !== !1 && Fb(t);
  } while (t && (!r || r(t, e)) && t !== Object.prototype);
  return e;
}, MX = (t, e, r) => {
  t = String(t), (r === void 0 || r > t.length) && (r = t.length), r -= e.length;
  const n = t.indexOf(e, r);
  return n !== -1 && n === r;
}, IX = (t) => {
  if (!t) return null;
  if (Xu(t)) return t;
  let e = t.length;
  if (!HS(e)) return null;
  const r = new Array(e);
  for (; e-- > 0; )
    r[e] = t[e];
  return r;
}, CX = /* @__PURE__ */ ((t) => (e) => t && e instanceof t)(typeof Uint8Array < "u" && Fb(Uint8Array)), TX = (t, e) => {
  const n = (t && t[Symbol.iterator]).call(t);
  let i;
  for (; (i = n.next()) && !i.done; ) {
    const s = i.value;
    e.call(t, s[0], s[1]);
  }
}, RX = (t, e) => {
  let r;
  const n = [];
  for (; (r = t.exec(e)) !== null; )
    n.push(r);
  return n;
}, DX = Ts("HTMLFormElement"), OX = (t) => t.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, n, i) {
    return n.toUpperCase() + i;
  }
), G_ = (({ hasOwnProperty: t }) => (e, r) => t.call(e, r))(Object.prototype), NX = Ts("RegExp"), GS = (t, e) => {
  const r = Object.getOwnPropertyDescriptors(t), n = {};
  ph(r, (i, s) => {
    let o;
    (o = e(i, s, t)) !== !1 && (n[s] = o || i);
  }), Object.defineProperties(t, n);
}, LX = (t) => {
  GS(t, (e, r) => {
    if (Ni(t) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const n = t[r];
    if (Ni(n)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
}, kX = (t, e) => {
  const r = {}, n = (i) => {
    i.forEach((s) => {
      r[s] = !0;
    });
  };
  return Xu(t) ? n(t) : n(String(t).split(e)), r;
}, $X = () => {
}, BX = (t, e) => t != null && Number.isFinite(t = +t) ? t : e, qm = "abcdefghijklmnopqrstuvwxyz", Y_ = "0123456789", YS = {
  DIGIT: Y_,
  ALPHA: qm,
  ALPHA_DIGIT: qm + qm.toUpperCase() + Y_
}, FX = (t = 16, e = YS.ALPHA_DIGIT) => {
  let r = "";
  const { length: n } = e;
  for (; t--; )
    r += e[Math.random() * n | 0];
  return r;
};
function jX(t) {
  return !!(t && Ni(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator]);
}
const UX = (t) => {
  const e = new Array(10), r = (n, i) => {
    if (Pp(n)) {
      if (e.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        e[i] = n;
        const s = Xu(n) ? [] : {};
        return ph(n, (o, a) => {
          const u = r(o, i + 1);
          !Bl(u) && (s[a] = u);
        }), e[i] = void 0, s;
      }
    }
    return n;
  };
  return r(t, 0);
}, qX = Ts("AsyncFunction"), zX = (t) => t && (Pp(t) || Ni(t)) && Ni(t.then) && Ni(t.catch), JS = ((t, e) => t ? setImmediate : e ? ((r, n) => (lc.addEventListener("message", ({ source: i, data: s }) => {
  i === lc && s === r && n.length && n.shift()();
}, !1), (i) => {
  n.push(i), lc.postMessage(r, "*");
}))(`axios@${Math.random()}`, []) : (r) => setTimeout(r))(
  typeof setImmediate == "function",
  Ni(lc.postMessage)
), WX = typeof queueMicrotask < "u" ? queueMicrotask.bind(lc) : typeof process < "u" && process.nextTick || JS, Oe = {
  isArray: Xu,
  isArrayBuffer: WS,
  isBuffer: aX,
  isFormData: mX,
  isArrayBufferView: cX,
  isString: uX,
  isNumber: HS,
  isBoolean: fX,
  isObject: Pp,
  isPlainObject: Gd,
  isReadableStream: bX,
  isRequest: yX,
  isResponse: wX,
  isHeaders: xX,
  isUndefined: Bl,
  isDate: lX,
  isFile: hX,
  isBlob: dX,
  isRegExp: NX,
  isFunction: Ni,
  isStream: gX,
  isURLSearchParams: vX,
  isTypedArray: CX,
  isFileList: pX,
  forEach: ph,
  merge: av,
  extend: EX,
  trim: _X,
  stripBOM: SX,
  inherits: AX,
  toFlatObject: PX,
  kindOf: Sp,
  kindOfTest: Ts,
  endsWith: MX,
  toArray: IX,
  forEachEntry: TX,
  matchAll: RX,
  isHTMLForm: DX,
  hasOwnProperty: G_,
  hasOwnProp: G_,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: GS,
  freezeMethods: LX,
  toObjectSet: kX,
  toCamelCase: OX,
  noop: $X,
  toFiniteNumber: BX,
  findKey: KS,
  global: lc,
  isContextDefined: VS,
  ALPHABET: YS,
  generateString: FX,
  isSpecCompliantForm: jX,
  toJSONObject: UX,
  isAsyncFn: qX,
  isThenable: zX,
  setImmediate: JS,
  asap: WX
};
function or(t, e, r, n, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), r && (this.config = r), n && (this.request = n), i && (this.response = i, this.status = i.status ? i.status : null);
}
Oe.inherits(or, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Oe.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const XS = or.prototype, ZS = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((t) => {
  ZS[t] = { value: t };
});
Object.defineProperties(or, ZS);
Object.defineProperty(XS, "isAxiosError", { value: !0 });
or.from = (t, e, r, n, i, s) => {
  const o = Object.create(XS);
  return Oe.toFlatObject(t, o, function(u) {
    return u !== Error.prototype;
  }, (a) => a !== "isAxiosError"), or.call(o, t.message, e, r, n, i), o.cause = t, o.name = t.name, s && Object.assign(o, s), o;
};
const HX = null;
function cv(t) {
  return Oe.isPlainObject(t) || Oe.isArray(t);
}
function QS(t) {
  return Oe.endsWith(t, "[]") ? t.slice(0, -2) : t;
}
function J_(t, e, r) {
  return t ? t.concat(e).map(function(i, s) {
    return i = QS(i), !r && s ? "[" + i + "]" : i;
  }).join(r ? "." : "") : e;
}
function KX(t) {
  return Oe.isArray(t) && !t.some(cv);
}
const VX = Oe.toFlatObject(Oe, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function Mp(t, e, r) {
  if (!Oe.isObject(t))
    throw new TypeError("target must be an object");
  e = e || new FormData(), r = Oe.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(O, L) {
    return !Oe.isUndefined(L[O]);
  });
  const n = r.metaTokens, i = r.visitor || d, s = r.dots, o = r.indexes, u = (r.Blob || typeof Blob < "u" && Blob) && Oe.isSpecCompliantForm(e);
  if (!Oe.isFunction(i))
    throw new TypeError("visitor must be a function");
  function l(P) {
    if (P === null) return "";
    if (Oe.isDate(P))
      return P.toISOString();
    if (!u && Oe.isBlob(P))
      throw new or("Blob is not supported. Use a Buffer instead.");
    return Oe.isArrayBuffer(P) || Oe.isTypedArray(P) ? u && typeof Blob == "function" ? new Blob([P]) : Buffer.from(P) : P;
  }
  function d(P, O, L) {
    let B = P;
    if (P && !L && typeof P == "object") {
      if (Oe.endsWith(O, "{}"))
        O = n ? O : O.slice(0, -2), P = JSON.stringify(P);
      else if (Oe.isArray(P) && KX(P) || (Oe.isFileList(P) || Oe.endsWith(O, "[]")) && (B = Oe.toArray(P)))
        return O = QS(O), B.forEach(function(q, U) {
          !(Oe.isUndefined(q) || q === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? J_([O], U, s) : o === null ? O : O + "[]",
            l(q)
          );
        }), !1;
    }
    return cv(P) ? !0 : (e.append(J_(L, O, s), l(P)), !1);
  }
  const p = [], w = Object.assign(VX, {
    defaultVisitor: d,
    convertValue: l,
    isVisitable: cv
  });
  function _(P, O) {
    if (!Oe.isUndefined(P)) {
      if (p.indexOf(P) !== -1)
        throw Error("Circular reference detected in " + O.join("."));
      p.push(P), Oe.forEach(P, function(B, k) {
        (!(Oe.isUndefined(B) || B === null) && i.call(
          e,
          B,
          Oe.isString(k) ? k.trim() : k,
          O,
          w
        )) === !0 && _(B, O ? O.concat(k) : [k]);
      }), p.pop();
    }
  }
  if (!Oe.isObject(t))
    throw new TypeError("data must be an object");
  return _(t), e;
}
function X_(t) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(n) {
    return e[n];
  });
}
function jb(t, e) {
  this._pairs = [], t && Mp(t, this, e);
}
const e7 = jb.prototype;
e7.append = function(e, r) {
  this._pairs.push([e, r]);
};
e7.toString = function(e) {
  const r = e ? function(n) {
    return e.call(this, n, X_);
  } : X_;
  return this._pairs.map(function(i) {
    return r(i[0]) + "=" + r(i[1]);
  }, "").join("&");
};
function GX(t) {
  return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function t7(t, e, r) {
  if (!e)
    return t;
  const n = r && r.encode || GX;
  Oe.isFunction(r) && (r = {
    serialize: r
  });
  const i = r && r.serialize;
  let s;
  if (i ? s = i(e, r) : s = Oe.isURLSearchParams(e) ? e.toString() : new jb(e, r).toString(n), s) {
    const o = t.indexOf("#");
    o !== -1 && (t = t.slice(0, o)), t += (t.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return t;
}
class Z_ {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, r, n) {
    return this.handlers.push({
      fulfilled: e,
      rejected: r,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    Oe.forEach(this.handlers, function(n) {
      n !== null && e(n);
    });
  }
}
const r7 = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, YX = typeof URLSearchParams < "u" ? URLSearchParams : jb, JX = typeof FormData < "u" ? FormData : null, XX = typeof Blob < "u" ? Blob : null, ZX = {
  isBrowser: !0,
  classes: {
    URLSearchParams: YX,
    FormData: JX,
    Blob: XX
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Ub = typeof window < "u" && typeof document < "u", uv = typeof navigator == "object" && navigator || void 0, QX = Ub && (!uv || ["ReactNative", "NativeScript", "NS"].indexOf(uv.product) < 0), eZ = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", tZ = Ub && window.location.href || "http://localhost", rZ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Ub,
  hasStandardBrowserEnv: QX,
  hasStandardBrowserWebWorkerEnv: eZ,
  navigator: uv,
  origin: tZ
}, Symbol.toStringTag, { value: "Module" })), Jn = {
  ...rZ,
  ...ZX
};
function nZ(t, e) {
  return Mp(t, new Jn.classes.URLSearchParams(), Object.assign({
    visitor: function(r, n, i, s) {
      return Jn.isNode && Oe.isBuffer(r) ? (this.append(n, r.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function iZ(t) {
  return Oe.matchAll(/\w+|\[(\w*)]/g, t).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function sZ(t) {
  const e = {}, r = Object.keys(t);
  let n;
  const i = r.length;
  let s;
  for (n = 0; n < i; n++)
    s = r[n], e[s] = t[s];
  return e;
}
function n7(t) {
  function e(r, n, i, s) {
    let o = r[s++];
    if (o === "__proto__") return !0;
    const a = Number.isFinite(+o), u = s >= r.length;
    return o = !o && Oe.isArray(i) ? i.length : o, u ? (Oe.hasOwnProp(i, o) ? i[o] = [i[o], n] : i[o] = n, !a) : ((!i[o] || !Oe.isObject(i[o])) && (i[o] = []), e(r, n, i[o], s) && Oe.isArray(i[o]) && (i[o] = sZ(i[o])), !a);
  }
  if (Oe.isFormData(t) && Oe.isFunction(t.entries)) {
    const r = {};
    return Oe.forEachEntry(t, (n, i) => {
      e(iZ(n), i, r, 0);
    }), r;
  }
  return null;
}
function oZ(t, e, r) {
  if (Oe.isString(t))
    try {
      return (e || JSON.parse)(t), Oe.trim(t);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (r || JSON.stringify)(t);
}
const gh = {
  transitional: r7,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, r) {
    const n = r.getContentType() || "", i = n.indexOf("application/json") > -1, s = Oe.isObject(e);
    if (s && Oe.isHTMLForm(e) && (e = new FormData(e)), Oe.isFormData(e))
      return i ? JSON.stringify(n7(e)) : e;
    if (Oe.isArrayBuffer(e) || Oe.isBuffer(e) || Oe.isStream(e) || Oe.isFile(e) || Oe.isBlob(e) || Oe.isReadableStream(e))
      return e;
    if (Oe.isArrayBufferView(e))
      return e.buffer;
    if (Oe.isURLSearchParams(e))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let a;
    if (s) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return nZ(e, this.formSerializer).toString();
      if ((a = Oe.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
        const u = this.env && this.env.FormData;
        return Mp(
          a ? { "files[]": e } : e,
          u && new u(),
          this.formSerializer
        );
      }
    }
    return s || i ? (r.setContentType("application/json", !1), oZ(e)) : e;
  }],
  transformResponse: [function(e) {
    const r = this.transitional || gh.transitional, n = r && r.forcedJSONParsing, i = this.responseType === "json";
    if (Oe.isResponse(e) || Oe.isReadableStream(e))
      return e;
    if (e && Oe.isString(e) && (n && !this.responseType || i)) {
      const o = !(r && r.silentJSONParsing) && i;
      try {
        return JSON.parse(e);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? or.from(a, or.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Jn.classes.FormData,
    Blob: Jn.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
Oe.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
  gh.headers[t] = {};
});
const aZ = Oe.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), cZ = (t) => {
  const e = {};
  let r, n, i;
  return t && t.split(`
`).forEach(function(o) {
    i = o.indexOf(":"), r = o.substring(0, i).trim().toLowerCase(), n = o.substring(i + 1).trim(), !(!r || e[r] && aZ[r]) && (r === "set-cookie" ? e[r] ? e[r].push(n) : e[r] = [n] : e[r] = e[r] ? e[r] + ", " + n : n);
  }), e;
}, Q_ = Symbol("internals");
function Ff(t) {
  return t && String(t).trim().toLowerCase();
}
function Yd(t) {
  return t === !1 || t == null ? t : Oe.isArray(t) ? t.map(Yd) : String(t);
}
function uZ(t) {
  const e = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = r.exec(t); )
    e[n[1]] = n[2];
  return e;
}
const fZ = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
function zm(t, e, r, n, i) {
  if (Oe.isFunction(n))
    return n.call(this, e, r);
  if (i && (e = r), !!Oe.isString(e)) {
    if (Oe.isString(n))
      return e.indexOf(n) !== -1;
    if (Oe.isRegExp(n))
      return n.test(e);
  }
}
function lZ(t) {
  return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, r, n) => r.toUpperCase() + n);
}
function hZ(t, e) {
  const r = Oe.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(t, n + r, {
      value: function(i, s, o) {
        return this[n].call(this, e, i, s, o);
      },
      configurable: !0
    });
  });
}
let yi = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, r, n) {
    const i = this;
    function s(a, u, l) {
      const d = Ff(u);
      if (!d)
        throw new Error("header name must be a non-empty string");
      const p = Oe.findKey(i, d);
      (!p || i[p] === void 0 || l === !0 || l === void 0 && i[p] !== !1) && (i[p || u] = Yd(a));
    }
    const o = (a, u) => Oe.forEach(a, (l, d) => s(l, d, u));
    if (Oe.isPlainObject(e) || e instanceof this.constructor)
      o(e, r);
    else if (Oe.isString(e) && (e = e.trim()) && !fZ(e))
      o(cZ(e), r);
    else if (Oe.isHeaders(e))
      for (const [a, u] of e.entries())
        s(u, a, n);
    else
      e != null && s(r, e, n);
    return this;
  }
  get(e, r) {
    if (e = Ff(e), e) {
      const n = Oe.findKey(this, e);
      if (n) {
        const i = this[n];
        if (!r)
          return i;
        if (r === !0)
          return uZ(i);
        if (Oe.isFunction(r))
          return r.call(this, i, n);
        if (Oe.isRegExp(r))
          return r.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, r) {
    if (e = Ff(e), e) {
      const n = Oe.findKey(this, e);
      return !!(n && this[n] !== void 0 && (!r || zm(this, this[n], n, r)));
    }
    return !1;
  }
  delete(e, r) {
    const n = this;
    let i = !1;
    function s(o) {
      if (o = Ff(o), o) {
        const a = Oe.findKey(n, o);
        a && (!r || zm(n, n[a], a, r)) && (delete n[a], i = !0);
      }
    }
    return Oe.isArray(e) ? e.forEach(s) : s(e), i;
  }
  clear(e) {
    const r = Object.keys(this);
    let n = r.length, i = !1;
    for (; n--; ) {
      const s = r[n];
      (!e || zm(this, this[s], s, e, !0)) && (delete this[s], i = !0);
    }
    return i;
  }
  normalize(e) {
    const r = this, n = {};
    return Oe.forEach(this, (i, s) => {
      const o = Oe.findKey(n, s);
      if (o) {
        r[o] = Yd(i), delete r[s];
        return;
      }
      const a = e ? lZ(s) : String(s).trim();
      a !== s && delete r[s], r[a] = Yd(i), n[a] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const r = /* @__PURE__ */ Object.create(null);
    return Oe.forEach(this, (n, i) => {
      n != null && n !== !1 && (r[i] = e && Oe.isArray(n) ? n.join(", ") : n);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, r]) => e + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...r) {
    const n = new this(e);
    return r.forEach((i) => n.set(i)), n;
  }
  static accessor(e) {
    const n = (this[Q_] = this[Q_] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function s(o) {
      const a = Ff(o);
      n[a] || (hZ(i, o), n[a] = !0);
    }
    return Oe.isArray(e) ? e.forEach(s) : s(e), this;
  }
};
yi.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Oe.reduceDescriptors(yi.prototype, ({ value: t }, e) => {
  let r = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => t,
    set(n) {
      this[r] = n;
    }
  };
});
Oe.freezeMethods(yi);
function Wm(t, e) {
  const r = this || gh, n = e || r, i = yi.from(n.headers);
  let s = n.data;
  return Oe.forEach(t, function(a) {
    s = a.call(r, s, i.normalize(), e ? e.status : void 0);
  }), i.normalize(), s;
}
function i7(t) {
  return !!(t && t.__CANCEL__);
}
function Zu(t, e, r) {
  or.call(this, t ?? "canceled", or.ERR_CANCELED, e, r), this.name = "CanceledError";
}
Oe.inherits(Zu, or, {
  __CANCEL__: !0
});
function s7(t, e, r) {
  const n = r.config.validateStatus;
  !r.status || !n || n(r.status) ? t(r) : e(new or(
    "Request failed with status code " + r.status,
    [or.ERR_BAD_REQUEST, or.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
function dZ(t) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
  return e && e[1] || "";
}
function pZ(t, e) {
  t = t || 10;
  const r = new Array(t), n = new Array(t);
  let i = 0, s = 0, o;
  return e = e !== void 0 ? e : 1e3, function(u) {
    const l = Date.now(), d = n[s];
    o || (o = l), r[i] = u, n[i] = l;
    let p = s, w = 0;
    for (; p !== i; )
      w += r[p++], p = p % t;
    if (i = (i + 1) % t, i === s && (s = (s + 1) % t), l - o < e)
      return;
    const _ = d && l - d;
    return _ ? Math.round(w * 1e3 / _) : void 0;
  };
}
function gZ(t, e) {
  let r = 0, n = 1e3 / e, i, s;
  const o = (l, d = Date.now()) => {
    r = d, i = null, s && (clearTimeout(s), s = null), t.apply(null, l);
  };
  return [(...l) => {
    const d = Date.now(), p = d - r;
    p >= n ? o(l, d) : (i = l, s || (s = setTimeout(() => {
      s = null, o(i);
    }, n - p)));
  }, () => i && o(i)];
}
const M0 = (t, e, r = 3) => {
  let n = 0;
  const i = pZ(50, 250);
  return gZ((s) => {
    const o = s.loaded, a = s.lengthComputable ? s.total : void 0, u = o - n, l = i(u), d = o <= a;
    n = o;
    const p = {
      loaded: o,
      total: a,
      progress: a ? o / a : void 0,
      bytes: u,
      rate: l || void 0,
      estimated: l && a && d ? (a - o) / l : void 0,
      event: s,
      lengthComputable: a != null,
      [e ? "download" : "upload"]: !0
    };
    t(p);
  }, r);
}, e6 = (t, e) => {
  const r = t != null;
  return [(n) => e[0]({
    lengthComputable: r,
    total: t,
    loaded: n
  }), e[1]];
}, t6 = (t) => (...e) => Oe.asap(() => t(...e)), mZ = Jn.hasStandardBrowserEnv ? /* @__PURE__ */ ((t, e) => (r) => (r = new URL(r, Jn.origin), t.protocol === r.protocol && t.host === r.host && (e || t.port === r.port)))(
  new URL(Jn.origin),
  Jn.navigator && /(msie|trident)/i.test(Jn.navigator.userAgent)
) : () => !0, vZ = Jn.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(t, e, r, n, i, s) {
      const o = [t + "=" + encodeURIComponent(e)];
      Oe.isNumber(r) && o.push("expires=" + new Date(r).toGMTString()), Oe.isString(n) && o.push("path=" + n), Oe.isString(i) && o.push("domain=" + i), s === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(t) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(t) {
      this.write(t, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function bZ(t) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
}
function yZ(t, e) {
  return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t;
}
function o7(t, e) {
  return t && !bZ(e) ? yZ(t, e) : e;
}
const r6 = (t) => t instanceof yi ? { ...t } : t;
function Ec(t, e) {
  e = e || {};
  const r = {};
  function n(l, d, p, w) {
    return Oe.isPlainObject(l) && Oe.isPlainObject(d) ? Oe.merge.call({ caseless: w }, l, d) : Oe.isPlainObject(d) ? Oe.merge({}, d) : Oe.isArray(d) ? d.slice() : d;
  }
  function i(l, d, p, w) {
    if (Oe.isUndefined(d)) {
      if (!Oe.isUndefined(l))
        return n(void 0, l, p, w);
    } else return n(l, d, p, w);
  }
  function s(l, d) {
    if (!Oe.isUndefined(d))
      return n(void 0, d);
  }
  function o(l, d) {
    if (Oe.isUndefined(d)) {
      if (!Oe.isUndefined(l))
        return n(void 0, l);
    } else return n(void 0, d);
  }
  function a(l, d, p) {
    if (p in e)
      return n(l, d);
    if (p in t)
      return n(void 0, l);
  }
  const u = {
    url: s,
    method: s,
    data: s,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (l, d, p) => i(r6(l), r6(d), p, !0)
  };
  return Oe.forEach(Object.keys(Object.assign({}, t, e)), function(d) {
    const p = u[d] || i, w = p(t[d], e[d], d);
    Oe.isUndefined(w) && p !== a || (r[d] = w);
  }), r;
}
const a7 = (t) => {
  const e = Ec({}, t);
  let { data: r, withXSRFToken: n, xsrfHeaderName: i, xsrfCookieName: s, headers: o, auth: a } = e;
  e.headers = o = yi.from(o), e.url = t7(o7(e.baseURL, e.url), t.params, t.paramsSerializer), a && o.set(
    "Authorization",
    "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
  );
  let u;
  if (Oe.isFormData(r)) {
    if (Jn.hasStandardBrowserEnv || Jn.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if ((u = o.getContentType()) !== !1) {
      const [l, ...d] = u ? u.split(";").map((p) => p.trim()).filter(Boolean) : [];
      o.setContentType([l || "multipart/form-data", ...d].join("; "));
    }
  }
  if (Jn.hasStandardBrowserEnv && (n && Oe.isFunction(n) && (n = n(e)), n || n !== !1 && mZ(e.url))) {
    const l = i && s && vZ.read(s);
    l && o.set(i, l);
  }
  return e;
}, wZ = typeof XMLHttpRequest < "u", xZ = wZ && function(t) {
  return new Promise(function(r, n) {
    const i = a7(t);
    let s = i.data;
    const o = yi.from(i.headers).normalize();
    let { responseType: a, onUploadProgress: u, onDownloadProgress: l } = i, d, p, w, _, P;
    function O() {
      _ && _(), P && P(), i.cancelToken && i.cancelToken.unsubscribe(d), i.signal && i.signal.removeEventListener("abort", d);
    }
    let L = new XMLHttpRequest();
    L.open(i.method.toUpperCase(), i.url, !0), L.timeout = i.timeout;
    function B() {
      if (!L)
        return;
      const q = yi.from(
        "getAllResponseHeaders" in L && L.getAllResponseHeaders()
      ), V = {
        data: !a || a === "text" || a === "json" ? L.responseText : L.response,
        status: L.status,
        statusText: L.statusText,
        headers: q,
        config: t,
        request: L
      };
      s7(function(R) {
        r(R), O();
      }, function(R) {
        n(R), O();
      }, V), L = null;
    }
    "onloadend" in L ? L.onloadend = B : L.onreadystatechange = function() {
      !L || L.readyState !== 4 || L.status === 0 && !(L.responseURL && L.responseURL.indexOf("file:") === 0) || setTimeout(B);
    }, L.onabort = function() {
      L && (n(new or("Request aborted", or.ECONNABORTED, t, L)), L = null);
    }, L.onerror = function() {
      n(new or("Network Error", or.ERR_NETWORK, t, L)), L = null;
    }, L.ontimeout = function() {
      let U = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const V = i.transitional || r7;
      i.timeoutErrorMessage && (U = i.timeoutErrorMessage), n(new or(
        U,
        V.clarifyTimeoutError ? or.ETIMEDOUT : or.ECONNABORTED,
        t,
        L
      )), L = null;
    }, s === void 0 && o.setContentType(null), "setRequestHeader" in L && Oe.forEach(o.toJSON(), function(U, V) {
      L.setRequestHeader(V, U);
    }), Oe.isUndefined(i.withCredentials) || (L.withCredentials = !!i.withCredentials), a && a !== "json" && (L.responseType = i.responseType), l && ([w, P] = M0(l, !0), L.addEventListener("progress", w)), u && L.upload && ([p, _] = M0(u), L.upload.addEventListener("progress", p), L.upload.addEventListener("loadend", _)), (i.cancelToken || i.signal) && (d = (q) => {
      L && (n(!q || q.type ? new Zu(null, t, L) : q), L.abort(), L = null);
    }, i.cancelToken && i.cancelToken.subscribe(d), i.signal && (i.signal.aborted ? d() : i.signal.addEventListener("abort", d)));
    const k = dZ(i.url);
    if (k && Jn.protocols.indexOf(k) === -1) {
      n(new or("Unsupported protocol " + k + ":", or.ERR_BAD_REQUEST, t));
      return;
    }
    L.send(s || null);
  });
}, _Z = (t, e) => {
  const { length: r } = t = t ? t.filter(Boolean) : [];
  if (e || r) {
    let n = new AbortController(), i;
    const s = function(l) {
      if (!i) {
        i = !0, a();
        const d = l instanceof Error ? l : this.reason;
        n.abort(d instanceof or ? d : new Zu(d instanceof Error ? d.message : d));
      }
    };
    let o = e && setTimeout(() => {
      o = null, s(new or(`timeout ${e} of ms exceeded`, or.ETIMEDOUT));
    }, e);
    const a = () => {
      t && (o && clearTimeout(o), o = null, t.forEach((l) => {
        l.unsubscribe ? l.unsubscribe(s) : l.removeEventListener("abort", s);
      }), t = null);
    };
    t.forEach((l) => l.addEventListener("abort", s));
    const { signal: u } = n;
    return u.unsubscribe = () => Oe.asap(a), u;
  }
}, EZ = function* (t, e) {
  let r = t.byteLength;
  if (r < e) {
    yield t;
    return;
  }
  let n = 0, i;
  for (; n < r; )
    i = n + e, yield t.slice(n, i), n = i;
}, SZ = async function* (t, e) {
  for await (const r of AZ(t))
    yield* EZ(r, e);
}, AZ = async function* (t) {
  if (t[Symbol.asyncIterator]) {
    yield* t;
    return;
  }
  const e = t.getReader();
  try {
    for (; ; ) {
      const { done: r, value: n } = await e.read();
      if (r)
        break;
      yield n;
    }
  } finally {
    await e.cancel();
  }
}, n6 = (t, e, r, n) => {
  const i = SZ(t, e);
  let s = 0, o, a = (u) => {
    o || (o = !0, n && n(u));
  };
  return new ReadableStream({
    async pull(u) {
      try {
        const { done: l, value: d } = await i.next();
        if (l) {
          a(), u.close();
          return;
        }
        let p = d.byteLength;
        if (r) {
          let w = s += p;
          r(w);
        }
        u.enqueue(new Uint8Array(d));
      } catch (l) {
        throw a(l), l;
      }
    },
    cancel(u) {
      return a(u), i.return();
    }
  }, {
    highWaterMark: 2
  });
}, Ip = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", c7 = Ip && typeof ReadableStream == "function", PZ = Ip && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((t) => (e) => t.encode(e))(new TextEncoder()) : async (t) => new Uint8Array(await new Response(t).arrayBuffer())), u7 = (t, ...e) => {
  try {
    return !!t(...e);
  } catch {
    return !1;
  }
}, MZ = c7 && u7(() => {
  let t = !1;
  const e = new Request(Jn.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return t = !0, "half";
    }
  }).headers.has("Content-Type");
  return t && !e;
}), i6 = 64 * 1024, fv = c7 && u7(() => Oe.isReadableStream(new Response("").body)), I0 = {
  stream: fv && ((t) => t.body)
};
Ip && ((t) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !I0[e] && (I0[e] = Oe.isFunction(t[e]) ? (r) => r[e]() : (r, n) => {
      throw new or(`Response type '${e}' is not supported`, or.ERR_NOT_SUPPORT, n);
    });
  });
})(new Response());
const IZ = async (t) => {
  if (t == null)
    return 0;
  if (Oe.isBlob(t))
    return t.size;
  if (Oe.isSpecCompliantForm(t))
    return (await new Request(Jn.origin, {
      method: "POST",
      body: t
    }).arrayBuffer()).byteLength;
  if (Oe.isArrayBufferView(t) || Oe.isArrayBuffer(t))
    return t.byteLength;
  if (Oe.isURLSearchParams(t) && (t = t + ""), Oe.isString(t))
    return (await PZ(t)).byteLength;
}, CZ = async (t, e) => {
  const r = Oe.toFiniteNumber(t.getContentLength());
  return r ?? IZ(e);
}, TZ = Ip && (async (t) => {
  let {
    url: e,
    method: r,
    data: n,
    signal: i,
    cancelToken: s,
    timeout: o,
    onDownloadProgress: a,
    onUploadProgress: u,
    responseType: l,
    headers: d,
    withCredentials: p = "same-origin",
    fetchOptions: w
  } = a7(t);
  l = l ? (l + "").toLowerCase() : "text";
  let _ = _Z([i, s && s.toAbortSignal()], o), P;
  const O = _ && _.unsubscribe && (() => {
    _.unsubscribe();
  });
  let L;
  try {
    if (u && MZ && r !== "get" && r !== "head" && (L = await CZ(d, n)) !== 0) {
      let V = new Request(e, {
        method: "POST",
        body: n,
        duplex: "half"
      }), Q;
      if (Oe.isFormData(n) && (Q = V.headers.get("content-type")) && d.setContentType(Q), V.body) {
        const [R, K] = e6(
          L,
          M0(t6(u))
        );
        n = n6(V.body, i6, R, K);
      }
    }
    Oe.isString(p) || (p = p ? "include" : "omit");
    const B = "credentials" in Request.prototype;
    P = new Request(e, {
      ...w,
      signal: _,
      method: r.toUpperCase(),
      headers: d.normalize().toJSON(),
      body: n,
      duplex: "half",
      credentials: B ? p : void 0
    });
    let k = await fetch(P);
    const q = fv && (l === "stream" || l === "response");
    if (fv && (a || q && O)) {
      const V = {};
      ["status", "statusText", "headers"].forEach((ge) => {
        V[ge] = k[ge];
      });
      const Q = Oe.toFiniteNumber(k.headers.get("content-length")), [R, K] = a && e6(
        Q,
        M0(t6(a), !0)
      ) || [];
      k = new Response(
        n6(k.body, i6, R, () => {
          K && K(), O && O();
        }),
        V
      );
    }
    l = l || "text";
    let U = await I0[Oe.findKey(I0, l) || "text"](k, t);
    return !q && O && O(), await new Promise((V, Q) => {
      s7(V, Q, {
        data: U,
        headers: yi.from(k.headers),
        status: k.status,
        statusText: k.statusText,
        config: t,
        request: P
      });
    });
  } catch (B) {
    throw O && O(), B && B.name === "TypeError" && /fetch/i.test(B.message) ? Object.assign(
      new or("Network Error", or.ERR_NETWORK, t, P),
      {
        cause: B.cause || B
      }
    ) : or.from(B, B && B.code, t, P);
  }
}), lv = {
  http: HX,
  xhr: xZ,
  fetch: TZ
};
Oe.forEach(lv, (t, e) => {
  if (t) {
    try {
      Object.defineProperty(t, "name", { value: e });
    } catch {
    }
    Object.defineProperty(t, "adapterName", { value: e });
  }
});
const s6 = (t) => `- ${t}`, RZ = (t) => Oe.isFunction(t) || t === null || t === !1, f7 = {
  getAdapter: (t) => {
    t = Oe.isArray(t) ? t : [t];
    const { length: e } = t;
    let r, n;
    const i = {};
    for (let s = 0; s < e; s++) {
      r = t[s];
      let o;
      if (n = r, !RZ(r) && (n = lv[(o = String(r)).toLowerCase()], n === void 0))
        throw new or(`Unknown adapter '${o}'`);
      if (n)
        break;
      i[o || "#" + s] = n;
    }
    if (!n) {
      const s = Object.entries(i).map(
        ([a, u]) => `adapter ${a} ` + (u === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = e ? s.length > 1 ? `since :
` + s.map(s6).join(`
`) : " " + s6(s[0]) : "as no adapter specified";
      throw new or(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return n;
  },
  adapters: lv
};
function Hm(t) {
  if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)
    throw new Zu(null, t);
}
function o6(t) {
  return Hm(t), t.headers = yi.from(t.headers), t.data = Wm.call(
    t,
    t.transformRequest
  ), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), f7.getAdapter(t.adapter || gh.adapter)(t).then(function(n) {
    return Hm(t), n.data = Wm.call(
      t,
      t.transformResponse,
      n
    ), n.headers = yi.from(n.headers), n;
  }, function(n) {
    return i7(n) || (Hm(t), n && n.response && (n.response.data = Wm.call(
      t,
      t.transformResponse,
      n.response
    ), n.response.headers = yi.from(n.response.headers))), Promise.reject(n);
  });
}
const l7 = "1.7.8", Cp = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
  Cp[t] = function(n) {
    return typeof n === t || "a" + (e < 1 ? "n " : " ") + t;
  };
});
const a6 = {};
Cp.transitional = function(e, r, n) {
  function i(s, o) {
    return "[Axios v" + l7 + "] Transitional option '" + s + "'" + o + (n ? ". " + n : "");
  }
  return (s, o, a) => {
    if (e === !1)
      throw new or(
        i(o, " has been removed" + (r ? " in " + r : "")),
        or.ERR_DEPRECATED
      );
    return r && !a6[o] && (a6[o] = !0, console.warn(
      i(
        o,
        " has been deprecated since v" + r + " and will be removed in the near future"
      )
    )), e ? e(s, o, a) : !0;
  };
};
Cp.spelling = function(e) {
  return (r, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0);
};
function DZ(t, e, r) {
  if (typeof t != "object")
    throw new or("options must be an object", or.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(t);
  let i = n.length;
  for (; i-- > 0; ) {
    const s = n[i], o = e[s];
    if (o) {
      const a = t[s], u = a === void 0 || o(a, s, t);
      if (u !== !0)
        throw new or("option " + s + " must be " + u, or.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new or("Unknown option " + s, or.ERR_BAD_OPTION);
  }
}
const Jd = {
  assertOptions: DZ,
  validators: Cp
}, Us = Jd.validators;
let pc = class {
  constructor(e) {
    this.defaults = e, this.interceptors = {
      request: new Z_(),
      response: new Z_()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, r) {
    try {
      return await this._request(e, r);
    } catch (n) {
      if (n instanceof Error) {
        let i = {};
        Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error();
        const s = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? s && !String(n.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + s) : n.stack = s;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(e, r) {
    typeof e == "string" ? (r = r || {}, r.url = e) : r = e || {}, r = Ec(this.defaults, r);
    const { transitional: n, paramsSerializer: i, headers: s } = r;
    n !== void 0 && Jd.assertOptions(n, {
      silentJSONParsing: Us.transitional(Us.boolean),
      forcedJSONParsing: Us.transitional(Us.boolean),
      clarifyTimeoutError: Us.transitional(Us.boolean)
    }, !1), i != null && (Oe.isFunction(i) ? r.paramsSerializer = {
      serialize: i
    } : Jd.assertOptions(i, {
      encode: Us.function,
      serialize: Us.function
    }, !0)), Jd.assertOptions(r, {
      baseUrl: Us.spelling("baseURL"),
      withXsrfToken: Us.spelling("withXSRFToken")
    }, !0), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let o = s && Oe.merge(
      s.common,
      s[r.method]
    );
    s && Oe.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (P) => {
        delete s[P];
      }
    ), r.headers = yi.concat(o, s);
    const a = [];
    let u = !0;
    this.interceptors.request.forEach(function(O) {
      typeof O.runWhen == "function" && O.runWhen(r) === !1 || (u = u && O.synchronous, a.unshift(O.fulfilled, O.rejected));
    });
    const l = [];
    this.interceptors.response.forEach(function(O) {
      l.push(O.fulfilled, O.rejected);
    });
    let d, p = 0, w;
    if (!u) {
      const P = [o6.bind(this), void 0];
      for (P.unshift.apply(P, a), P.push.apply(P, l), w = P.length, d = Promise.resolve(r); p < w; )
        d = d.then(P[p++], P[p++]);
      return d;
    }
    w = a.length;
    let _ = r;
    for (p = 0; p < w; ) {
      const P = a[p++], O = a[p++];
      try {
        _ = P(_);
      } catch (L) {
        O.call(this, L);
        break;
      }
    }
    try {
      d = o6.call(this, _);
    } catch (P) {
      return Promise.reject(P);
    }
    for (p = 0, w = l.length; p < w; )
      d = d.then(l[p++], l[p++]);
    return d;
  }
  getUri(e) {
    e = Ec(this.defaults, e);
    const r = o7(e.baseURL, e.url);
    return t7(r, e.params, e.paramsSerializer);
  }
};
Oe.forEach(["delete", "get", "head", "options"], function(e) {
  pc.prototype[e] = function(r, n) {
    return this.request(Ec(n || {}, {
      method: e,
      url: r,
      data: (n || {}).data
    }));
  };
});
Oe.forEach(["post", "put", "patch"], function(e) {
  function r(n) {
    return function(s, o, a) {
      return this.request(Ec(a || {}, {
        method: e,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: o
      }));
    };
  }
  pc.prototype[e] = r(), pc.prototype[e + "Form"] = r(!0);
});
let OZ = class h7 {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(s) {
      r = s;
    });
    const n = this;
    this.promise.then((i) => {
      if (!n._listeners) return;
      let s = n._listeners.length;
      for (; s-- > 0; )
        n._listeners[s](i);
      n._listeners = null;
    }), this.promise.then = (i) => {
      let s;
      const o = new Promise((a) => {
        n.subscribe(a), s = a;
      }).then(i);
      return o.cancel = function() {
        n.unsubscribe(s);
      }, o;
    }, e(function(s, o, a) {
      n.reason || (n.reason = new Zu(s, o, a), r(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(e);
    r !== -1 && this._listeners.splice(r, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), r = (n) => {
      e.abort(n);
    };
    return this.subscribe(r), e.signal.unsubscribe = () => this.unsubscribe(r), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new h7(function(i) {
        e = i;
      }),
      cancel: e
    };
  }
};
function NZ(t) {
  return function(r) {
    return t.apply(null, r);
  };
}
function LZ(t) {
  return Oe.isObject(t) && t.isAxiosError === !0;
}
const hv = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(hv).forEach(([t, e]) => {
  hv[e] = t;
});
function d7(t) {
  const e = new pc(t), r = zS(pc.prototype.request, e);
  return Oe.extend(r, pc.prototype, e, { allOwnKeys: !0 }), Oe.extend(r, e, null, { allOwnKeys: !0 }), r.create = function(i) {
    return d7(Ec(t, i));
  }, r;
}
const mn = d7(gh);
mn.Axios = pc;
mn.CanceledError = Zu;
mn.CancelToken = OZ;
mn.isCancel = i7;
mn.VERSION = l7;
mn.toFormData = Mp;
mn.AxiosError = or;
mn.Cancel = mn.CanceledError;
mn.all = function(e) {
  return Promise.all(e);
};
mn.spread = NZ;
mn.isAxiosError = LZ;
mn.mergeConfig = Ec;
mn.AxiosHeaders = yi;
mn.formToJSON = (t) => n7(Oe.isHTMLForm(t) ? new FormData(t) : t);
mn.getAdapter = f7.getAdapter;
mn.HttpStatusCode = hv;
mn.default = mn;
const {
  Axios: Boe,
  AxiosError: p7,
  CanceledError: Foe,
  isCancel: joe,
  CancelToken: Uoe,
  VERSION: qoe,
  all: zoe,
  Cancel: Woe,
  isAxiosError: Hoe,
  spread: Koe,
  toFormData: Voe,
  AxiosHeaders: Goe,
  HttpStatusCode: Yoe,
  formToJSON: Joe,
  getAdapter: Xoe,
  mergeConfig: Zoe
} = mn, g7 = mn.create({
  timeout: 6e4,
  headers: {
    "Content-Type": "application/json",
    token: localStorage.getItem("auth")
  }
});
function kZ(t) {
  var e, r, n;
  if (((e = t.data) == null ? void 0 : e.success) !== !0) {
    const i = new p7(
      (r = t.data) == null ? void 0 : r.errorMessage,
      (n = t.data) == null ? void 0 : n.errorCode,
      t.config,
      t.request,
      t
    );
    return Promise.reject(i);
  } else
    return t;
}
function $Z(t) {
  var r;
  console.log(t);
  const e = (r = t.response) == null ? void 0 : r.data;
  if (e) {
    console.log(e, "responseData");
    const n = new p7(
      e.errorMessage,
      t.code,
      t.config,
      t.request,
      t.response
    );
    return Promise.reject(n);
  } else
    return Promise.reject(t);
}
g7.interceptors.response.use(
  kZ,
  $Z
);
class BZ {
  constructor(e) {
    vs(this, "_apiBase", "");
    this.request = e;
  }
  setApiBase(e) {
    this._apiBase = e || "";
  }
  async getNonce(e) {
    const { data: r } = await this.request.post(`${this._apiBase}/api/v2/user/nonce`, e);
    return r.data;
  }
  async getEmailCode(e, r) {
    const { data: n } = await this.request.post(`${this._apiBase}/api/v2/user/get_code`, e, {
      headers: { "Captcha-Param": r }
    });
    return n.data;
  }
  async emailLogin(e) {
    return (await this.request.post(`${this._apiBase}/api/v2/user/login`, e)).data;
  }
  async walletLogin(e) {
    return e.account_enum === "C" ? (await this.request.post(`${this._apiBase}/api/v2/user/login`, e)).data : (await this.request.post(`${this._apiBase}/api/v2/business/login`, e)).data;
  }
  async tonLogin(e) {
    return (await this.request.post(`${this._apiBase}/api/v2/user/login`, e)).data;
  }
  async bindEmail(e) {
    return (await this.request.post("/api/v2/user/account/bind", e)).data;
  }
  async bindTonWallet(e) {
    return (await this.request.post("/api/v2/user/account/bind", e)).data;
  }
  async bindEvmWallet(e) {
    return (await this.request.post("/api/v2/user/account/bind", e)).data;
  }
}
const ka = new BZ(g7), FZ = {
  projectId: "7a4434fefbcc9af474fb5c995e47d286",
  metadata: {
    name: "codatta",
    description: "codatta",
    url: "https://codatta.io/",
    icons: ["https://avatars.githubusercontent.com/u/171659315"]
  }
}, jZ = sX({
  appName: "codatta",
  appLogoUrl: "https://avatars.githubusercontent.com/u/171659315"
}), m7 = Ta({
  saveLastUsedWallet: () => {
  },
  lastUsedWallet: null,
  wallets: [],
  initialized: !1,
  featuredWallets: [],
  chains: []
});
function Tp() {
  return Tn(m7);
}
function Qoe(t) {
  const { apiBaseUrl: e } = t, [r, n] = Yt([]), [i, s] = Yt([]), [o, a] = Yt(null), [u, l] = Yt(!1), [d, p] = Yt([]), w = (O) => {
    a(O);
    const B = {
      provider: O.provider instanceof J1 ? "UniversalProvider" : "EIP1193Provider",
      key: O.key,
      timestamp: Date.now()
    };
    localStorage.setItem("xn-last-used-info", JSON.stringify(B));
  };
  function _(O) {
    const L = O.find((B) => {
      var k;
      return ((k = B.config) == null ? void 0 : k.name) === t.singleWalletName;
    });
    if (L)
      s([L]);
    else {
      const B = O.filter((U) => U.featured || U.installed), k = O.filter((U) => !U.featured && !U.installed), q = [...B, ...k];
      n(q), s(B);
    }
  }
  async function P() {
    const O = [], L = /* @__PURE__ */ new Map();
    mD.forEach((k) => {
      const q = new Il(k);
      k.name === "Coinbase Wallet" && q.EIP6963Detected({
        info: { name: "Coinbase Wallet", uuid: "coinbase", icon: k.image, rdns: "coinbase" },
        provider: jZ.getProvider()
      }), L.set(q.key, q), O.push(q);
    }), (await wY()).forEach((k) => {
      const q = L.get(k.info.name);
      if (q)
        q.EIP6963Detected(k);
      else {
        const U = new Il(k);
        L.set(U.key, U), O.push(U);
      }
    });
    try {
      const k = JSON.parse(localStorage.getItem("xn-last-used-info") || "{}"), q = L.get(k.key);
      if (q) {
        if (q.lastUsed = !0, k.provider === "UniversalProvider") {
          const U = await J1.init(FZ);
          U.session && (q.setUniversalProvider(U), console.log("Restored UniversalProvider for wallet:", q.key));
        } else k.provider === "EIP1193Provider" && q.installed && console.log("Using detected EIP1193Provider for wallet:", q.key);
        a(q);
      }
    } catch (k) {
      console.log(k);
    }
    t.chains && p(t.chains), _(O), l(!0);
  }
  return Dn(() => {
    P(), ka.setApiBase(e);
  }, []), /* @__PURE__ */ le.jsx(
    m7.Provider,
    {
      value: {
        saveLastUsedWallet: w,
        wallets: r,
        initialized: u,
        lastUsedWallet: o,
        featuredWallets: i,
        chains: d
      },
      children: t.children
    }
  );
}
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const UZ = (t) => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), v7 = (...t) => t.filter((e, r, n) => !!e && e.trim() !== "" && n.indexOf(e) === r).join(" ").trim();
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var qZ = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const zZ = Dv(
  ({
    color: t = "currentColor",
    size: e = 24,
    strokeWidth: r = 2,
    absoluteStrokeWidth: n,
    className: i = "",
    children: s,
    iconNode: o,
    ...a
  }, u) => e0(
    "svg",
    {
      ref: u,
      ...qZ,
      width: e,
      height: e,
      stroke: t,
      strokeWidth: n ? Number(r) * 24 / Number(e) : r,
      className: v7("lucide", i),
      ...a
    },
    [
      ...o.map(([l, d]) => e0(l, d)),
      ...Array.isArray(s) ? s : [s]
    ]
  )
);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ls = (t, e) => {
  const r = Dv(
    ({ className: n, ...i }, s) => e0(zZ, {
      ref: s,
      iconNode: e,
      className: v7(`lucide-${UZ(t)}`, n),
      ...i
    })
  );
  return r.displayName = `${t}`, r;
};
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const WZ = ls("ArrowLeft", [
  ["path", { d: "m12 19-7-7 7-7", key: "1l729n" }],
  ["path", { d: "M19 12H5", key: "x3x0zl" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const b7 = ls("ArrowRight", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const HZ = ls("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const KZ = ls("CircleCheckBig", [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const VZ = ls("Download", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }],
  ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const GZ = ls("Globe", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" }],
  ["path", { d: "M2 12h20", key: "9i4pu4" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const y7 = ls("Laptop", [
  [
    "path",
    {
      d: "M20 16V7a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v9m16 0H4m16 0 1.28 2.55a1 1 0 0 1-.9 1.45H3.62a1 1 0 0 1-.9-1.45L4 16",
      key: "tarvll"
    }
  ]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const YZ = ls("Link2", [
  ["path", { d: "M9 17H7A5 5 0 0 1 7 7h2", key: "8i5ue5" }],
  ["path", { d: "M15 7h2a5 5 0 1 1 0 10h-2", key: "1b9ql8" }],
  ["line", { x1: "8", x2: "16", y1: "12", y2: "12", key: "1jonct" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Sc = ls("LoaderCircle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const JZ = ls("Mail", [
  ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" }],
  ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7", key: "1ocrg3" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const w7 = ls("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const XZ = ls("UserRoundCheck", [
  ["path", { d: "M2 21a8 8 0 0 1 13.292-6", key: "bjp14o" }],
  ["circle", { cx: "10", cy: "8", r: "5", key: "o932ke" }],
  ["path", { d: "m16 19 2 2 4-4", key: "1b14m6" }]
]), c6 = /* @__PURE__ */ new Set();
function Rp(t, e, r) {
  t || c6.has(e) || (console.warn(e), c6.add(e));
}
function ZZ(t) {
  if (typeof Proxy > "u")
    return t;
  const e = /* @__PURE__ */ new Map(), r = (...n) => (process.env.NODE_ENV !== "production" && Rp(!1, "motion() is deprecated. Use motion.create() instead."), t(...n));
  return new Proxy(r, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (n, i) => i === "create" ? t : (e.has(i) || e.set(i, t(i)), e.get(i))
  });
}
function Dp(t) {
  return t !== null && typeof t == "object" && typeof t.start == "function";
}
const dv = (t) => Array.isArray(t);
function x7(t, e) {
  if (!Array.isArray(e))
    return !1;
  const r = e.length;
  if (r !== t.length)
    return !1;
  for (let n = 0; n < r; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function Fl(t) {
  return typeof t == "string" || Array.isArray(t);
}
function u6(t) {
  const e = [{}, {}];
  return t == null || t.values.forEach((r, n) => {
    e[0][n] = r.get(), e[1][n] = r.getVelocity();
  }), e;
}
function qb(t, e, r, n) {
  if (typeof e == "function") {
    const [i, s] = u6(n);
    e = e(r !== void 0 ? r : t.custom, i, s);
  }
  if (typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function") {
    const [i, s] = u6(n);
    e = e(r !== void 0 ? r : t.custom, i, s);
  }
  return e;
}
function Op(t, e, r) {
  const n = t.getProps();
  return qb(n, e, r !== void 0 ? r : n.custom, t);
}
const zb = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], Wb = ["initial", ...zb], mh = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], Lc = new Set(mh), Js = (t) => t * 1e3, No = (t) => t / 1e3, QZ = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, eQ = (t) => ({
  type: "spring",
  stiffness: 550,
  damping: t === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), tQ = {
  type: "keyframes",
  duration: 0.8
}, rQ = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, nQ = (t, { keyframes: e }) => e.length > 2 ? tQ : Lc.has(t) ? t.startsWith("scale") ? eQ(e[1]) : QZ : rQ;
function Hb(t, e) {
  return t ? t[e] || t.default || t : void 0;
}
const iQ = {
  useManualTiming: !1
}, sQ = (t) => t !== null;
function Np(t, { repeat: e, repeatType: r = "loop" }, n) {
  const i = t.filter(sQ), s = e && r !== "loop" && e % 2 === 1 ? 0 : i.length - 1;
  return !s || n === void 0 ? i[s] : n;
}
const Un = (t) => t;
function oQ(t) {
  let e = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), n = !1, i = !1;
  const s = /* @__PURE__ */ new WeakSet();
  let o = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function a(l) {
    s.has(l) && (u.schedule(l), t()), l(o);
  }
  const u = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (l, d = !1, p = !1) => {
      const _ = p && n ? e : r;
      return d && s.add(l), _.has(l) || _.add(l), l;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (l) => {
      r.delete(l), s.delete(l);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (l) => {
      if (o = l, n) {
        i = !0;
        return;
      }
      n = !0, [e, r] = [r, e], r.clear(), e.forEach(a), n = !1, i && (i = !1, u.process(l));
    }
  };
  return u;
}
const Pd = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
], aQ = 40;
function _7(t, e) {
  let r = !1, n = !0;
  const i = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, s = () => r = !0, o = Pd.reduce((B, k) => (B[k] = oQ(s), B), {}), { read: a, resolveKeyframes: u, update: l, preRender: d, render: p, postRender: w } = o, _ = () => {
    const B = performance.now();
    r = !1, i.delta = n ? 1e3 / 60 : Math.max(Math.min(B - i.timestamp, aQ), 1), i.timestamp = B, i.isProcessing = !0, a.process(i), u.process(i), l.process(i), d.process(i), p.process(i), w.process(i), i.isProcessing = !1, r && e && (n = !1, t(_));
  }, P = () => {
    r = !0, n = !0, i.isProcessing || t(_);
  };
  return { schedule: Pd.reduce((B, k) => {
    const q = o[k];
    return B[k] = (U, V = !1, Q = !1) => (r || P(), q.schedule(U, V, Q)), B;
  }, {}), cancel: (B) => {
    for (let k = 0; k < Pd.length; k++)
      o[Pd[k]].cancel(B);
  }, state: i, steps: o };
}
const { schedule: Lr, cancel: Pa, state: Fn, steps: Km } = _7(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Un, !0), E7 = (t, e, r) => (((1 - 3 * r + 3 * e) * t + (3 * r - 6 * e)) * t + 3 * e) * t, cQ = 1e-7, uQ = 12;
function fQ(t, e, r, n, i) {
  let s, o, a = 0;
  do
    o = e + (r - e) / 2, s = E7(o, n, i) - t, s > 0 ? r = o : e = o;
  while (Math.abs(s) > cQ && ++a < uQ);
  return o;
}
function vh(t, e, r, n) {
  if (t === e && r === n)
    return Un;
  const i = (s) => fQ(s, 0, 1, t, r);
  return (s) => s === 0 || s === 1 ? s : E7(i(s), e, n);
}
const S7 = (t) => (e) => e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, A7 = (t) => (e) => 1 - t(1 - e), P7 = /* @__PURE__ */ vh(0.33, 1.53, 0.69, 0.99), Kb = /* @__PURE__ */ A7(P7), M7 = /* @__PURE__ */ S7(Kb), I7 = (t) => (t *= 2) < 1 ? 0.5 * Kb(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))), Vb = (t) => 1 - Math.sin(Math.acos(t)), C7 = A7(Vb), T7 = S7(Vb), R7 = (t) => /^0[^.\s]+$/u.test(t);
function lQ(t) {
  return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || R7(t) : !0;
}
let Qu = Un, Wo = Un;
process.env.NODE_ENV !== "production" && (Qu = (t, e) => {
  !t && typeof console < "u" && console.warn(e);
}, Wo = (t, e) => {
  if (!t)
    throw new Error(e);
});
const D7 = (t) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t), O7 = (t) => (e) => typeof e == "string" && e.startsWith(t), N7 = /* @__PURE__ */ O7("--"), hQ = /* @__PURE__ */ O7("var(--"), Gb = (t) => hQ(t) ? dQ.test(t.split("/*")[0].trim()) : !1, dQ = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, pQ = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function gQ(t) {
  const e = pQ.exec(t);
  if (!e)
    return [,];
  const [, r, n, i] = e;
  return [`--${r ?? n}`, i];
}
const mQ = 4;
function L7(t, e, r = 1) {
  Wo(r <= mQ, `Max CSS variable fallback depth detected in property "${t}". This may indicate a circular fallback dependency.`);
  const [n, i] = gQ(t);
  if (!n)
    return;
  const s = window.getComputedStyle(e).getPropertyValue(n);
  if (s) {
    const o = s.trim();
    return D7(o) ? parseFloat(o) : o;
  }
  return Gb(i) ? L7(i, e, r + 1) : i;
}
const Ma = (t, e, r) => r > e ? e : r < t ? t : r, ef = {
  test: (t) => typeof t == "number",
  parse: parseFloat,
  transform: (t) => t
}, jl = {
  ...ef,
  transform: (t) => Ma(0, 1, t)
}, Md = {
  ...ef,
  default: 1
}, bh = (t) => ({
  test: (e) => typeof e == "string" && e.endsWith(t) && e.split(" ").length === 1,
  parse: parseFloat,
  transform: (e) => `${e}${t}`
}), ca = /* @__PURE__ */ bh("deg"), Xs = /* @__PURE__ */ bh("%"), Vt = /* @__PURE__ */ bh("px"), vQ = /* @__PURE__ */ bh("vh"), bQ = /* @__PURE__ */ bh("vw"), f6 = {
  ...Xs,
  parse: (t) => Xs.parse(t) / 100,
  transform: (t) => Xs.transform(t * 100)
}, yQ = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]), l6 = (t) => t === ef || t === Vt, h6 = (t, e) => parseFloat(t.split(", ")[e]), d6 = (t, e) => (r, { transform: n }) => {
  if (n === "none" || !n)
    return 0;
  const i = n.match(/^matrix3d\((.+)\)$/u);
  if (i)
    return h6(i[1], e);
  {
    const s = n.match(/^matrix\((.+)\)$/u);
    return s ? h6(s[1], t) : 0;
  }
}, wQ = /* @__PURE__ */ new Set(["x", "y", "z"]), xQ = mh.filter((t) => !wQ.has(t));
function _Q(t) {
  const e = [];
  return xQ.forEach((r) => {
    const n = t.getValue(r);
    n !== void 0 && (e.push([r, n.get()]), n.set(r.startsWith("scale") ? 1 : 0));
  }), e;
}
const ku = {
  // Dimensions
  width: ({ x: t }, { paddingLeft: e = "0", paddingRight: r = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(r),
  height: ({ y: t }, { paddingTop: e = "0", paddingBottom: r = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(r),
  top: (t, { top: e }) => parseFloat(e),
  left: (t, { left: e }) => parseFloat(e),
  bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min),
  right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min),
  // Transform
  x: d6(4, 13),
  y: d6(5, 14)
};
ku.translateX = ku.x;
ku.translateY = ku.y;
const k7 = (t) => (e) => e.test(t), EQ = {
  test: (t) => t === "auto",
  parse: (t) => t
}, $7 = [ef, Vt, Xs, ca, bQ, vQ, EQ], p6 = (t) => $7.find(k7(t)), gc = /* @__PURE__ */ new Set();
let pv = !1, gv = !1;
function B7() {
  if (gv) {
    const t = Array.from(gc).filter((n) => n.needsMeasurement), e = new Set(t.map((n) => n.element)), r = /* @__PURE__ */ new Map();
    e.forEach((n) => {
      const i = _Q(n);
      i.length && (r.set(n, i), n.render());
    }), t.forEach((n) => n.measureInitialState()), e.forEach((n) => {
      n.render();
      const i = r.get(n);
      i && i.forEach(([s, o]) => {
        var a;
        (a = n.getValue(s)) === null || a === void 0 || a.set(o);
      });
    }), t.forEach((n) => n.measureEndState()), t.forEach((n) => {
      n.suspendedScrollY !== void 0 && window.scrollTo(0, n.suspendedScrollY);
    });
  }
  gv = !1, pv = !1, gc.forEach((t) => t.complete()), gc.clear();
}
function F7() {
  gc.forEach((t) => {
    t.readKeyframes(), t.needsMeasurement && (gv = !0);
  });
}
function SQ() {
  F7(), B7();
}
class Yb {
  constructor(e, r, n, i, s, o = !1) {
    this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = r, this.name = n, this.motionValue = i, this.element = s, this.isAsync = o;
  }
  scheduleResolve() {
    this.isScheduled = !0, this.isAsync ? (gc.add(this), pv || (pv = !0, Lr.read(F7), Lr.resolveKeyframes(B7))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, name: r, element: n, motionValue: i } = this;
    for (let s = 0; s < e.length; s++)
      if (e[s] === null)
        if (s === 0) {
          const o = i == null ? void 0 : i.get(), a = e[e.length - 1];
          if (o !== void 0)
            e[0] = o;
          else if (n && r) {
            const u = n.readValue(r, a);
            u != null && (e[0] = u);
          }
          e[0] === void 0 && (e[0] = a), i && o === void 0 && i.set(e[0]);
        } else
          e[s] = e[s - 1];
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), gc.delete(this);
  }
  cancel() {
    this.isComplete || (this.isScheduled = !1, gc.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const rl = (t) => Math.round(t * 1e5) / 1e5, Jb = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function AQ(t) {
  return t == null;
}
const PQ = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, Xb = (t, e) => (r) => !!(typeof r == "string" && PQ.test(r) && r.startsWith(t) || e && !AQ(r) && Object.prototype.hasOwnProperty.call(r, e)), j7 = (t, e, r) => (n) => {
  if (typeof n != "string")
    return n;
  const [i, s, o, a] = n.match(Jb);
  return {
    [t]: parseFloat(i),
    [e]: parseFloat(s),
    [r]: parseFloat(o),
    alpha: a !== void 0 ? parseFloat(a) : 1
  };
}, MQ = (t) => Ma(0, 255, t), Vm = {
  ...ef,
  transform: (t) => Math.round(MQ(t))
}, hc = {
  test: /* @__PURE__ */ Xb("rgb", "red"),
  parse: /* @__PURE__ */ j7("red", "green", "blue"),
  transform: ({ red: t, green: e, blue: r, alpha: n = 1 }) => "rgba(" + Vm.transform(t) + ", " + Vm.transform(e) + ", " + Vm.transform(r) + ", " + rl(jl.transform(n)) + ")"
};
function IQ(t) {
  let e = "", r = "", n = "", i = "";
  return t.length > 5 ? (e = t.substring(1, 3), r = t.substring(3, 5), n = t.substring(5, 7), i = t.substring(7, 9)) : (e = t.substring(1, 2), r = t.substring(2, 3), n = t.substring(3, 4), i = t.substring(4, 5), e += e, r += r, n += n, i += i), {
    red: parseInt(e, 16),
    green: parseInt(r, 16),
    blue: parseInt(n, 16),
    alpha: i ? parseInt(i, 16) / 255 : 1
  };
}
const mv = {
  test: /* @__PURE__ */ Xb("#"),
  parse: IQ,
  transform: hc.transform
}, fu = {
  test: /* @__PURE__ */ Xb("hsl", "hue"),
  parse: /* @__PURE__ */ j7("hue", "saturation", "lightness"),
  transform: ({ hue: t, saturation: e, lightness: r, alpha: n = 1 }) => "hsla(" + Math.round(t) + ", " + Xs.transform(rl(e)) + ", " + Xs.transform(rl(r)) + ", " + rl(jl.transform(n)) + ")"
}, Yn = {
  test: (t) => hc.test(t) || mv.test(t) || fu.test(t),
  parse: (t) => hc.test(t) ? hc.parse(t) : fu.test(t) ? fu.parse(t) : mv.parse(t),
  transform: (t) => typeof t == "string" ? t : t.hasOwnProperty("red") ? hc.transform(t) : fu.transform(t)
}, CQ = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function TQ(t) {
  var e, r;
  return isNaN(t) && typeof t == "string" && (((e = t.match(Jb)) === null || e === void 0 ? void 0 : e.length) || 0) + (((r = t.match(CQ)) === null || r === void 0 ? void 0 : r.length) || 0) > 0;
}
const U7 = "number", q7 = "color", RQ = "var", DQ = "var(", g6 = "${}", OQ = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function Ul(t) {
  const e = t.toString(), r = [], n = {
    color: [],
    number: [],
    var: []
  }, i = [];
  let s = 0;
  const a = e.replace(OQ, (u) => (Yn.test(u) ? (n.color.push(s), i.push(q7), r.push(Yn.parse(u))) : u.startsWith(DQ) ? (n.var.push(s), i.push(RQ), r.push(u)) : (n.number.push(s), i.push(U7), r.push(parseFloat(u))), ++s, g6)).split(g6);
  return { values: r, split: a, indexes: n, types: i };
}
function z7(t) {
  return Ul(t).values;
}
function W7(t) {
  const { split: e, types: r } = Ul(t), n = e.length;
  return (i) => {
    let s = "";
    for (let o = 0; o < n; o++)
      if (s += e[o], i[o] !== void 0) {
        const a = r[o];
        a === U7 ? s += rl(i[o]) : a === q7 ? s += Yn.transform(i[o]) : s += i[o];
      }
    return s;
  };
}
const NQ = (t) => typeof t == "number" ? 0 : t;
function LQ(t) {
  const e = z7(t);
  return W7(t)(e.map(NQ));
}
const Ia = {
  test: TQ,
  parse: z7,
  createTransformer: W7,
  getAnimatableNone: LQ
}, kQ = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function $Q(t) {
  const [e, r] = t.slice(0, -1).split("(");
  if (e === "drop-shadow")
    return t;
  const [n] = r.match(Jb) || [];
  if (!n)
    return t;
  const i = r.replace(n, "");
  let s = kQ.has(e) ? 1 : 0;
  return n !== r && (s *= 100), e + "(" + s + i + ")";
}
const BQ = /\b([a-z-]*)\(.*?\)/gu, vv = {
  ...Ia,
  getAnimatableNone: (t) => {
    const e = t.match(BQ);
    return e ? e.map($Q).join(" ") : t;
  }
}, FQ = {
  // Border props
  borderWidth: Vt,
  borderTopWidth: Vt,
  borderRightWidth: Vt,
  borderBottomWidth: Vt,
  borderLeftWidth: Vt,
  borderRadius: Vt,
  radius: Vt,
  borderTopLeftRadius: Vt,
  borderTopRightRadius: Vt,
  borderBottomRightRadius: Vt,
  borderBottomLeftRadius: Vt,
  // Positioning props
  width: Vt,
  maxWidth: Vt,
  height: Vt,
  maxHeight: Vt,
  top: Vt,
  right: Vt,
  bottom: Vt,
  left: Vt,
  // Spacing props
  padding: Vt,
  paddingTop: Vt,
  paddingRight: Vt,
  paddingBottom: Vt,
  paddingLeft: Vt,
  margin: Vt,
  marginTop: Vt,
  marginRight: Vt,
  marginBottom: Vt,
  marginLeft: Vt,
  // Misc
  backgroundPositionX: Vt,
  backgroundPositionY: Vt
}, jQ = {
  rotate: ca,
  rotateX: ca,
  rotateY: ca,
  rotateZ: ca,
  scale: Md,
  scaleX: Md,
  scaleY: Md,
  scaleZ: Md,
  skew: ca,
  skewX: ca,
  skewY: ca,
  distance: Vt,
  translateX: Vt,
  translateY: Vt,
  translateZ: Vt,
  x: Vt,
  y: Vt,
  z: Vt,
  perspective: Vt,
  transformPerspective: Vt,
  opacity: jl,
  originX: f6,
  originY: f6,
  originZ: Vt
}, m6 = {
  ...ef,
  transform: Math.round
}, Zb = {
  ...FQ,
  ...jQ,
  zIndex: m6,
  size: Vt,
  // SVG
  fillOpacity: jl,
  strokeOpacity: jl,
  numOctaves: m6
}, UQ = {
  ...Zb,
  // Color props
  color: Yn,
  backgroundColor: Yn,
  outlineColor: Yn,
  fill: Yn,
  stroke: Yn,
  // Border props
  borderColor: Yn,
  borderTopColor: Yn,
  borderRightColor: Yn,
  borderBottomColor: Yn,
  borderLeftColor: Yn,
  filter: vv,
  WebkitFilter: vv
}, Qb = (t) => UQ[t];
function H7(t, e) {
  let r = Qb(t);
  return r !== vv && (r = Ia), r.getAnimatableNone ? r.getAnimatableNone(e) : void 0;
}
const qQ = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function zQ(t, e, r) {
  let n = 0, i;
  for (; n < t.length && !i; ) {
    const s = t[n];
    typeof s == "string" && !qQ.has(s) && Ul(s).values.length && (i = t[n]), n++;
  }
  if (i && r)
    for (const s of e)
      t[s] = H7(r, i);
}
class K7 extends Yb {
  constructor(e, r, n, i, s) {
    super(e, r, n, i, s, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: r, name: n } = this;
    if (!r || !r.current)
      return;
    super.readKeyframes();
    for (let u = 0; u < e.length; u++) {
      let l = e[u];
      if (typeof l == "string" && (l = l.trim(), Gb(l))) {
        const d = L7(l, r.current);
        d !== void 0 && (e[u] = d), u === e.length - 1 && (this.finalKeyframe = l);
      }
    }
    if (this.resolveNoneKeyframes(), !yQ.has(n) || e.length !== 2)
      return;
    const [i, s] = e, o = p6(i), a = p6(s);
    if (o !== a)
      if (l6(o) && l6(a))
        for (let u = 0; u < e.length; u++) {
          const l = e[u];
          typeof l == "string" && (e[u] = parseFloat(l));
        }
      else
        this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: r } = this, n = [];
    for (let i = 0; i < e.length; i++)
      lQ(e[i]) && n.push(i);
    n.length && zQ(e, n, r);
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: r, name: n } = this;
    if (!e || !e.current)
      return;
    n === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = ku[n](e.measureViewportBox(), window.getComputedStyle(e.current)), r[0] = this.measuredOrigin;
    const i = r[r.length - 1];
    i !== void 0 && e.getValue(n, i).jump(i, !1);
  }
  measureEndState() {
    var e;
    const { element: r, name: n, unresolvedKeyframes: i } = this;
    if (!r || !r.current)
      return;
    const s = r.getValue(n);
    s && s.jump(this.measuredOrigin, !1);
    const o = i.length - 1, a = i[o];
    i[o] = ku[n](r.measureViewportBox(), window.getComputedStyle(r.current)), a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a), !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach(([u, l]) => {
      r.getValue(u).set(l);
    }), this.resolveNoneKeyframes();
  }
}
function ey(t) {
  return typeof t == "function";
}
let Xd;
function WQ() {
  Xd = void 0;
}
const Zs = {
  now: () => (Xd === void 0 && Zs.set(Fn.isProcessing || iQ.useManualTiming ? Fn.timestamp : performance.now()), Xd),
  set: (t) => {
    Xd = t, queueMicrotask(WQ);
  }
}, v6 = (t, e) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && // It's animatable if we have a string
(Ia.test(t) || t === "0") && // And it contains numbers and/or colors
!t.startsWith("url("));
function HQ(t) {
  const e = t[0];
  if (t.length === 1)
    return !0;
  for (let r = 0; r < t.length; r++)
    if (t[r] !== e)
      return !0;
}
function KQ(t, e, r, n) {
  const i = t[0];
  if (i === null)
    return !1;
  if (e === "display" || e === "visibility")
    return !0;
  const s = t[t.length - 1], o = v6(i, e), a = v6(s, e);
  return Qu(o === a, `You are trying to animate ${e} from "${i}" to "${s}". ${i} is not an animatable value - to enable this animation set ${i} to a value animatable to ${s} via the \`style\` property.`), !o || !a ? !1 : HQ(t) || (r === "spring" || ey(r)) && n;
}
const VQ = 40;
class V7 {
  constructor({ autoplay: e = !0, delay: r = 0, type: n = "keyframes", repeat: i = 0, repeatDelay: s = 0, repeatType: o = "loop", ...a }) {
    this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = Zs.now(), this.options = {
      autoplay: e,
      delay: r,
      type: n,
      repeat: i,
      repeatDelay: s,
      repeatType: o,
      ...a
    }, this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    return this.resolvedAt ? this.resolvedAt - this.createdAt > VQ ? this.resolvedAt : this.createdAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && SQ(), this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(e, r) {
    this.resolvedAt = Zs.now(), this.hasAttemptedResolve = !0;
    const { name: n, type: i, velocity: s, delay: o, onComplete: a, onUpdate: u, isGenerator: l } = this.options;
    if (!l && !KQ(e, n, i, s))
      if (o)
        this.options.duration = 0;
      else {
        u == null || u(Np(e, this.options, r)), a == null || a(), this.resolveFinishedPromise();
        return;
      }
    const d = this.initPlayback(e, r);
    d !== !1 && (this._resolved = {
      keyframes: e,
      finalKeyframe: r,
      ...d
    }, this.onPostResolved());
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(e, r) {
    return this.currentFinishedPromise.then(e, r);
  }
  flatten() {
    this.options.type = "keyframes", this.options.ease = "linear";
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((e) => {
      this.resolveFinishedPromise = e;
    });
  }
}
function G7(t, e) {
  return e ? t * (1e3 / e) : 0;
}
const GQ = 5;
function Y7(t, e, r) {
  const n = Math.max(e - GQ, 0);
  return G7(r - t(n), e - n);
}
const Gm = 1e-3, YQ = 0.01, b6 = 10, JQ = 0.05, XQ = 1;
function ZQ({ duration: t = 800, bounce: e = 0.25, velocity: r = 0, mass: n = 1 }) {
  let i, s;
  Qu(t <= Js(b6), "Spring duration must be 10 seconds or less");
  let o = 1 - e;
  o = Ma(JQ, XQ, o), t = Ma(YQ, b6, No(t)), o < 1 ? (i = (l) => {
    const d = l * o, p = d * t, w = d - r, _ = bv(l, o), P = Math.exp(-p);
    return Gm - w / _ * P;
  }, s = (l) => {
    const p = l * o * t, w = p * r + r, _ = Math.pow(o, 2) * Math.pow(l, 2) * t, P = Math.exp(-p), O = bv(Math.pow(l, 2), o);
    return (-i(l) + Gm > 0 ? -1 : 1) * ((w - _) * P) / O;
  }) : (i = (l) => {
    const d = Math.exp(-l * t), p = (l - r) * t + 1;
    return -Gm + d * p;
  }, s = (l) => {
    const d = Math.exp(-l * t), p = (r - l) * (t * t);
    return d * p;
  });
  const a = 5 / t, u = eee(i, s, a);
  if (t = Js(t), isNaN(u))
    return {
      stiffness: 100,
      damping: 10,
      duration: t
    };
  {
    const l = Math.pow(u, 2) * n;
    return {
      stiffness: l,
      damping: o * 2 * Math.sqrt(n * l),
      duration: t
    };
  }
}
const QQ = 12;
function eee(t, e, r) {
  let n = r;
  for (let i = 1; i < QQ; i++)
    n = n - t(n) / e(n);
  return n;
}
function bv(t, e) {
  return t * Math.sqrt(1 - e * e);
}
const tee = ["duration", "bounce"], ree = ["stiffness", "damping", "mass"];
function y6(t, e) {
  return e.some((r) => t[r] !== void 0);
}
function nee(t) {
  let e = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...t
  };
  if (!y6(t, ree) && y6(t, tee)) {
    const r = ZQ(t);
    e = {
      ...e,
      ...r,
      mass: 1
    }, e.isResolvedFromDuration = !0;
  }
  return e;
}
function J7({ keyframes: t, restDelta: e, restSpeed: r, ...n }) {
  const i = t[0], s = t[t.length - 1], o = { done: !1, value: i }, { stiffness: a, damping: u, mass: l, duration: d, velocity: p, isResolvedFromDuration: w } = nee({
    ...n,
    velocity: -No(n.velocity || 0)
  }), _ = p || 0, P = u / (2 * Math.sqrt(a * l)), O = s - i, L = No(Math.sqrt(a / l)), B = Math.abs(O) < 5;
  r || (r = B ? 0.01 : 2), e || (e = B ? 5e-3 : 0.5);
  let k;
  if (P < 1) {
    const q = bv(L, P);
    k = (U) => {
      const V = Math.exp(-P * L * U);
      return s - V * ((_ + P * L * O) / q * Math.sin(q * U) + O * Math.cos(q * U));
    };
  } else if (P === 1)
    k = (q) => s - Math.exp(-L * q) * (O + (_ + L * O) * q);
  else {
    const q = L * Math.sqrt(P * P - 1);
    k = (U) => {
      const V = Math.exp(-P * L * U), Q = Math.min(q * U, 300);
      return s - V * ((_ + P * L * O) * Math.sinh(Q) + q * O * Math.cosh(Q)) / q;
    };
  }
  return {
    calculatedDuration: w && d || null,
    next: (q) => {
      const U = k(q);
      if (w)
        o.done = q >= d;
      else {
        let V = 0;
        P < 1 && (V = q === 0 ? Js(_) : Y7(k, q, U));
        const Q = Math.abs(V) <= r, R = Math.abs(s - U) <= e;
        o.done = Q && R;
      }
      return o.value = o.done ? s : U, o;
    }
  };
}
function w6({ keyframes: t, velocity: e = 0, power: r = 0.8, timeConstant: n = 325, bounceDamping: i = 10, bounceStiffness: s = 500, modifyTarget: o, min: a, max: u, restDelta: l = 0.5, restSpeed: d }) {
  const p = t[0], w = {
    done: !1,
    value: p
  }, _ = (K) => a !== void 0 && K < a || u !== void 0 && K > u, P = (K) => a === void 0 ? u : u === void 0 || Math.abs(a - K) < Math.abs(u - K) ? a : u;
  let O = r * e;
  const L = p + O, B = o === void 0 ? L : o(L);
  B !== L && (O = B - p);
  const k = (K) => -O * Math.exp(-K / n), q = (K) => B + k(K), U = (K) => {
    const ge = k(K), Ee = q(K);
    w.done = Math.abs(ge) <= l, w.value = w.done ? B : Ee;
  };
  let V, Q;
  const R = (K) => {
    _(w.value) && (V = K, Q = J7({
      keyframes: [w.value, P(w.value)],
      velocity: Y7(q, K, w.value),
      // TODO: This should be passing * 1000
      damping: i,
      stiffness: s,
      restDelta: l,
      restSpeed: d
    }));
  };
  return R(0), {
    calculatedDuration: null,
    next: (K) => {
      let ge = !1;
      return !Q && V === void 0 && (ge = !0, U(K), R(K)), V !== void 0 && K >= V ? Q.next(K - V) : (!ge && U(K), w);
    }
  };
}
const iee = /* @__PURE__ */ vh(0.42, 0, 1, 1), see = /* @__PURE__ */ vh(0, 0, 0.58, 1), X7 = /* @__PURE__ */ vh(0.42, 0, 0.58, 1), oee = (t) => Array.isArray(t) && typeof t[0] != "number", ty = (t) => Array.isArray(t) && typeof t[0] == "number", x6 = {
  linear: Un,
  easeIn: iee,
  easeInOut: X7,
  easeOut: see,
  circIn: Vb,
  circInOut: T7,
  circOut: C7,
  backIn: Kb,
  backInOut: M7,
  backOut: P7,
  anticipate: I7
}, _6 = (t) => {
  if (ty(t)) {
    Wo(t.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [e, r, n, i] = t;
    return vh(e, r, n, i);
  } else if (typeof t == "string")
    return Wo(x6[t] !== void 0, `Invalid easing type '${t}'`), x6[t];
  return t;
}, aee = (t, e) => (r) => e(t(r)), Lo = (...t) => t.reduce(aee), $u = (t, e, r) => {
  const n = e - t;
  return n === 0 ? 1 : (r - t) / n;
}, Qr = (t, e, r) => t + (e - t) * r;
function Ym(t, e, r) {
  return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? t + (e - t) * 6 * r : r < 1 / 2 ? e : r < 2 / 3 ? t + (e - t) * (2 / 3 - r) * 6 : t;
}
function cee({ hue: t, saturation: e, lightness: r, alpha: n }) {
  t /= 360, e /= 100, r /= 100;
  let i = 0, s = 0, o = 0;
  if (!e)
    i = s = o = r;
  else {
    const a = r < 0.5 ? r * (1 + e) : r + e - r * e, u = 2 * r - a;
    i = Ym(u, a, t + 1 / 3), s = Ym(u, a, t), o = Ym(u, a, t - 1 / 3);
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(s * 255),
    blue: Math.round(o * 255),
    alpha: n
  };
}
function C0(t, e) {
  return (r) => r > 0 ? e : t;
}
const Jm = (t, e, r) => {
  const n = t * t, i = r * (e * e - n) + n;
  return i < 0 ? 0 : Math.sqrt(i);
}, uee = [mv, hc, fu], fee = (t) => uee.find((e) => e.test(t));
function E6(t) {
  const e = fee(t);
  if (Qu(!!e, `'${t}' is not an animatable color. Use the equivalent color code instead.`), !e)
    return !1;
  let r = e.parse(t);
  return e === fu && (r = cee(r)), r;
}
const S6 = (t, e) => {
  const r = E6(t), n = E6(e);
  if (!r || !n)
    return C0(t, e);
  const i = { ...r };
  return (s) => (i.red = Jm(r.red, n.red, s), i.green = Jm(r.green, n.green, s), i.blue = Jm(r.blue, n.blue, s), i.alpha = Qr(r.alpha, n.alpha, s), hc.transform(i));
}, yv = /* @__PURE__ */ new Set(["none", "hidden"]);
function lee(t, e) {
  return yv.has(t) ? (r) => r <= 0 ? t : e : (r) => r >= 1 ? e : t;
}
function hee(t, e) {
  return (r) => Qr(t, e, r);
}
function ry(t) {
  return typeof t == "number" ? hee : typeof t == "string" ? Gb(t) ? C0 : Yn.test(t) ? S6 : gee : Array.isArray(t) ? Z7 : typeof t == "object" ? Yn.test(t) ? S6 : dee : C0;
}
function Z7(t, e) {
  const r = [...t], n = r.length, i = t.map((s, o) => ry(s)(s, e[o]));
  return (s) => {
    for (let o = 0; o < n; o++)
      r[o] = i[o](s);
    return r;
  };
}
function dee(t, e) {
  const r = { ...t, ...e }, n = {};
  for (const i in r)
    t[i] !== void 0 && e[i] !== void 0 && (n[i] = ry(t[i])(t[i], e[i]));
  return (i) => {
    for (const s in n)
      r[s] = n[s](i);
    return r;
  };
}
function pee(t, e) {
  var r;
  const n = [], i = { color: 0, var: 0, number: 0 };
  for (let s = 0; s < e.values.length; s++) {
    const o = e.types[s], a = t.indexes[o][i[o]], u = (r = t.values[a]) !== null && r !== void 0 ? r : 0;
    n[s] = u, i[o]++;
  }
  return n;
}
const gee = (t, e) => {
  const r = Ia.createTransformer(e), n = Ul(t), i = Ul(e);
  return n.indexes.var.length === i.indexes.var.length && n.indexes.color.length === i.indexes.color.length && n.indexes.number.length >= i.indexes.number.length ? yv.has(t) && !i.values.length || yv.has(e) && !n.values.length ? lee(t, e) : Lo(Z7(pee(n, i), i.values), r) : (Qu(!0, `Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), C0(t, e));
};
function Q7(t, e, r) {
  return typeof t == "number" && typeof e == "number" && typeof r == "number" ? Qr(t, e, r) : ry(t)(t, e);
}
function mee(t, e, r) {
  const n = [], i = r || Q7, s = t.length - 1;
  for (let o = 0; o < s; o++) {
    let a = i(t[o], t[o + 1]);
    if (e) {
      const u = Array.isArray(e) ? e[o] || Un : e;
      a = Lo(u, a);
    }
    n.push(a);
  }
  return n;
}
function vee(t, e, { clamp: r = !0, ease: n, mixer: i } = {}) {
  const s = t.length;
  if (Wo(s === e.length, "Both input and output ranges must be the same length"), s === 1)
    return () => e[0];
  if (s === 2 && t[0] === t[1])
    return () => e[1];
  t[0] > t[s - 1] && (t = [...t].reverse(), e = [...e].reverse());
  const o = mee(e, n, i), a = o.length, u = (l) => {
    let d = 0;
    if (a > 1)
      for (; d < t.length - 2 && !(l < t[d + 1]); d++)
        ;
    const p = $u(t[d], t[d + 1], l);
    return o[d](p);
  };
  return r ? (l) => u(Ma(t[0], t[s - 1], l)) : u;
}
function bee(t, e) {
  const r = t[t.length - 1];
  for (let n = 1; n <= e; n++) {
    const i = $u(0, e, n);
    t.push(Qr(r, 1, i));
  }
}
function yee(t) {
  const e = [0];
  return bee(e, t.length - 1), e;
}
function wee(t, e) {
  return t.map((r) => r * e);
}
function xee(t, e) {
  return t.map(() => e || X7).splice(0, t.length - 1);
}
function T0({ duration: t = 300, keyframes: e, times: r, ease: n = "easeInOut" }) {
  const i = oee(n) ? n.map(_6) : _6(n), s = {
    done: !1,
    value: e[0]
  }, o = wee(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    r && r.length === e.length ? r : yee(e),
    t
  ), a = vee(o, e, {
    ease: Array.isArray(i) ? i : xee(e, i)
  });
  return {
    calculatedDuration: t,
    next: (u) => (s.value = a(u), s.done = u >= t, s)
  };
}
const A6 = 2e4;
function _ee(t) {
  let e = 0;
  const r = 50;
  let n = t.next(e);
  for (; !n.done && e < A6; )
    e += r, n = t.next(e);
  return e >= A6 ? 1 / 0 : e;
}
const Eee = (t) => {
  const e = ({ timestamp: r }) => t(r);
  return {
    start: () => Lr.update(e, !0),
    stop: () => Pa(e),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => Fn.isProcessing ? Fn.timestamp : Zs.now()
  };
}, See = {
  decay: w6,
  inertia: w6,
  tween: T0,
  keyframes: T0,
  spring: J7
}, Aee = (t) => t / 100;
class ny extends V7 {
  constructor(e) {
    super(e), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
      if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
        return;
      this.teardown();
      const { onStop: u } = this.options;
      u && u();
    };
    const { name: r, motionValue: n, element: i, keyframes: s } = this.options, o = (i == null ? void 0 : i.KeyframeResolver) || Yb, a = (u, l) => this.onKeyframesResolved(u, l);
    this.resolver = new o(s, a, r, n, i), this.resolver.scheduleResolve();
  }
  flatten() {
    super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
  }
  initPlayback(e) {
    const { type: r = "keyframes", repeat: n = 0, repeatDelay: i = 0, repeatType: s, velocity: o = 0 } = this.options, a = ey(r) ? r : See[r] || T0;
    let u, l;
    a !== T0 && typeof e[0] != "number" && (process.env.NODE_ENV !== "production" && Wo(e.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${e}`), u = Lo(Aee, Q7(e[0], e[1])), e = [0, 100]);
    const d = a({ ...this.options, keyframes: e });
    s === "mirror" && (l = a({
      ...this.options,
      keyframes: [...e].reverse(),
      velocity: -o
    })), d.calculatedDuration === null && (d.calculatedDuration = _ee(d));
    const { calculatedDuration: p } = d, w = p + i, _ = w * (n + 1) - i;
    return {
      generator: d,
      mirroredGenerator: l,
      mapPercentToKeyframes: u,
      calculatedDuration: p,
      resolvedDuration: w,
      totalDuration: _
    };
  }
  onPostResolved() {
    const { autoplay: e = !0 } = this.options;
    this.play(), this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState;
  }
  tick(e, r = !1) {
    const { resolved: n } = this;
    if (!n) {
      const { keyframes: K } = this.options;
      return { done: !0, value: K[K.length - 1] };
    }
    const { finalKeyframe: i, generator: s, mirroredGenerator: o, mapPercentToKeyframes: a, keyframes: u, calculatedDuration: l, totalDuration: d, resolvedDuration: p } = n;
    if (this.startTime === null)
      return s.next(0);
    const { delay: w, repeat: _, repeatType: P, repeatDelay: O, onUpdate: L } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - d / this.speed, this.startTime)), r ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed;
    const B = this.currentTime - w * (this.speed >= 0 ? 1 : -1), k = this.speed >= 0 ? B < 0 : B > d;
    this.currentTime = Math.max(B, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = d);
    let q = this.currentTime, U = s;
    if (_) {
      const K = Math.min(this.currentTime, d) / p;
      let ge = Math.floor(K), Ee = K % 1;
      !Ee && K >= 1 && (Ee = 1), Ee === 1 && ge--, ge = Math.min(ge, _ + 1), !!(ge % 2) && (P === "reverse" ? (Ee = 1 - Ee, O && (Ee -= O / p)) : P === "mirror" && (U = o)), q = Ma(0, 1, Ee) * p;
    }
    const V = k ? { done: !1, value: u[0] } : U.next(q);
    a && (V.value = a(V.value));
    let { done: Q } = V;
    !k && l !== null && (Q = this.speed >= 0 ? this.currentTime >= d : this.currentTime <= 0);
    const R = this.holdTime === null && (this.state === "finished" || this.state === "running" && Q);
    return R && i !== void 0 && (V.value = Np(u, this.options, i)), L && L(V.value), R && this.finish(), V;
  }
  get duration() {
    const { resolved: e } = this;
    return e ? No(e.calculatedDuration) : 0;
  }
  get time() {
    return No(this.currentTime);
  }
  set time(e) {
    e = Js(e), this.currentTime = e, this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(e) {
    const r = this.playbackSpeed !== e;
    this.playbackSpeed = e, r && (this.time = No(this.currentTime));
  }
  play() {
    if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver: e = Eee, onPlay: r, startTime: n } = this.options;
    this.driver || (this.driver = e((s) => this.tick(s))), r && r();
    const i = this.driver.now();
    this.holdTime !== null ? this.startTime = i - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = i) : this.startTime = n ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    var e;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused", this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0;
  }
  complete() {
    this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.teardown(), this.state = "finished";
    const { onComplete: e } = this.options;
    e && e();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(e) {
    return this.startTime = 0, this.tick(e, !0);
  }
}
const Pee = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]), Mee = 10, Iee = (t, e) => {
  let r = "";
  const n = Math.max(Math.round(e / Mee), 2);
  for (let i = 0; i < n; i++)
    r += t($u(0, n - 1, i)) + ", ";
  return `linear(${r.substring(0, r.length - 2)})`;
};
function iy(t) {
  let e;
  return () => (e === void 0 && (e = t()), e);
}
const Cee = {
  linearEasing: void 0
};
function Tee(t, e) {
  const r = iy(t);
  return () => {
    var n;
    return (n = Cee[e]) !== null && n !== void 0 ? n : r();
  };
}
const R0 = /* @__PURE__ */ Tee(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing");
function e9(t) {
  return !!(typeof t == "function" && R0() || !t || typeof t == "string" && (t in wv || R0()) || ty(t) || Array.isArray(t) && t.every(e9));
}
const Vf = ([t, e, r, n]) => `cubic-bezier(${t}, ${e}, ${r}, ${n})`, wv = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ Vf([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ Vf([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ Vf([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ Vf([0.33, 1.53, 0.69, 0.99])
};
function t9(t, e) {
  if (t)
    return typeof t == "function" && R0() ? Iee(t, e) : ty(t) ? Vf(t) : Array.isArray(t) ? t.map((r) => t9(r, e) || wv.easeOut) : wv[t];
}
function Ree(t, e, r, { delay: n = 0, duration: i = 300, repeat: s = 0, repeatType: o = "loop", ease: a = "easeInOut", times: u } = {}) {
  const l = { [e]: r };
  u && (l.offset = u);
  const d = t9(a, i);
  return Array.isArray(d) && (l.easing = d), t.animate(l, {
    delay: n,
    duration: i,
    easing: Array.isArray(d) ? "linear" : d,
    fill: "both",
    iterations: s + 1,
    direction: o === "reverse" ? "alternate" : "normal"
  });
}
function P6(t, e) {
  t.timeline = e, t.onfinish = null;
}
const Dee = /* @__PURE__ */ iy(() => Object.hasOwnProperty.call(Element.prototype, "animate")), D0 = 10, Oee = 2e4;
function Nee(t) {
  return ey(t.type) || t.type === "spring" || !e9(t.ease);
}
function Lee(t, e) {
  const r = new ny({
    ...e,
    keyframes: t,
    repeat: 0,
    delay: 0,
    isGenerator: !0
  });
  let n = { done: !1, value: t[0] };
  const i = [];
  let s = 0;
  for (; !n.done && s < Oee; )
    n = r.sample(s), i.push(n.value), s += D0;
  return {
    times: void 0,
    keyframes: i,
    duration: s - D0,
    ease: "linear"
  };
}
const r9 = {
  anticipate: I7,
  backInOut: M7,
  circInOut: T7
};
function kee(t) {
  return t in r9;
}
class M6 extends V7 {
  constructor(e) {
    super(e);
    const { name: r, motionValue: n, element: i, keyframes: s } = this.options;
    this.resolver = new K7(s, (o, a) => this.onKeyframesResolved(o, a), r, n, i), this.resolver.scheduleResolve();
  }
  initPlayback(e, r) {
    var n;
    let { duration: i = 300, times: s, ease: o, type: a, motionValue: u, name: l, startTime: d } = this.options;
    if (!(!((n = u.owner) === null || n === void 0) && n.current))
      return !1;
    if (typeof o == "string" && R0() && kee(o) && (o = r9[o]), Nee(this.options)) {
      const { onComplete: w, onUpdate: _, motionValue: P, element: O, ...L } = this.options, B = Lee(e, L);
      e = B.keyframes, e.length === 1 && (e[1] = e[0]), i = B.duration, s = B.times, o = B.ease, a = "keyframes";
    }
    const p = Ree(u.owner.current, l, e, { ...this.options, duration: i, times: s, ease: o });
    return p.startTime = d ?? this.calcStartTime(), this.pendingTimeline ? (P6(p, this.pendingTimeline), this.pendingTimeline = void 0) : p.onfinish = () => {
      const { onComplete: w } = this.options;
      u.set(Np(e, this.options, r)), w && w(), this.cancel(), this.resolveFinishedPromise();
    }, {
      animation: p,
      duration: i,
      times: s,
      type: a,
      ease: o,
      keyframes: e
    };
  }
  get duration() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { duration: r } = e;
    return No(r);
  }
  get time() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { animation: r } = e;
    return No(r.currentTime || 0);
  }
  set time(e) {
    const { resolved: r } = this;
    if (!r)
      return;
    const { animation: n } = r;
    n.currentTime = Js(e);
  }
  get speed() {
    const { resolved: e } = this;
    if (!e)
      return 1;
    const { animation: r } = e;
    return r.playbackRate;
  }
  set speed(e) {
    const { resolved: r } = this;
    if (!r)
      return;
    const { animation: n } = r;
    n.playbackRate = e;
  }
  get state() {
    const { resolved: e } = this;
    if (!e)
      return "idle";
    const { animation: r } = e;
    return r.playState;
  }
  get startTime() {
    const { resolved: e } = this;
    if (!e)
      return null;
    const { animation: r } = e;
    return r.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(e) {
    if (!this._resolved)
      this.pendingTimeline = e;
    else {
      const { resolved: r } = this;
      if (!r)
        return Un;
      const { animation: n } = r;
      P6(n, e);
    }
    return Un;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: r } = e;
    r.playState === "finished" && this.updateFinishedPromise(), r.play();
  }
  pause() {
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: r } = e;
    r.pause();
  }
  stop() {
    if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: r, keyframes: n, duration: i, type: s, ease: o, times: a } = e;
    if (r.playState === "idle" || r.playState === "finished")
      return;
    if (this.time) {
      const { motionValue: l, onUpdate: d, onComplete: p, element: w, ..._ } = this.options, P = new ny({
        ..._,
        keyframes: n,
        duration: i,
        type: s,
        ease: o,
        times: a,
        isGenerator: !0
      }), O = Js(this.time);
      l.setWithVelocity(P.sample(O - D0).value, P.sample(O).value, D0);
    }
    const { onStop: u } = this.options;
    u && u(), this.cancel();
  }
  complete() {
    const { resolved: e } = this;
    e && e.animation.finish();
  }
  cancel() {
    const { resolved: e } = this;
    e && e.animation.cancel();
  }
  static supports(e) {
    const { motionValue: r, name: n, repeatDelay: i, repeatType: s, damping: o, type: a } = e;
    return Dee() && n && Pee.has(n) && r && r.owner && r.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !r.owner.getProps().onUpdate && !i && s !== "mirror" && o !== 0 && a !== "inertia";
  }
}
const $ee = iy(() => window.ScrollTimeline !== void 0);
class Bee {
  constructor(e) {
    this.stop = () => this.runAll("stop"), this.animations = e.filter(Boolean);
  }
  then(e, r) {
    return Promise.all(this.animations).then(e).catch(r);
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(e) {
    return this.animations[0][e];
  }
  setAll(e, r) {
    for (let n = 0; n < this.animations.length; n++)
      this.animations[n][e] = r;
  }
  attachTimeline(e, r) {
    const n = this.animations.map((i) => $ee() && i.attachTimeline ? i.attachTimeline(e) : r(i));
    return () => {
      n.forEach((i, s) => {
        i && i(), this.animations[s].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(e) {
    this.setAll("time", e);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(e) {
    this.setAll("speed", e);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let e = 0;
    for (let r = 0; r < this.animations.length; r++)
      e = Math.max(e, this.animations[r].duration);
    return e;
  }
  runAll(e) {
    this.animations.forEach((r) => r[e]());
  }
  flatten() {
    this.runAll("flatten");
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
function Fee({ when: t, delay: e, delayChildren: r, staggerChildren: n, staggerDirection: i, repeat: s, repeatType: o, repeatDelay: a, from: u, elapsed: l, ...d }) {
  return !!Object.keys(d).length;
}
const sy = (t, e, r, n = {}, i, s) => (o) => {
  const a = Hb(n, t) || {}, u = a.delay || n.delay || 0;
  let { elapsed: l = 0 } = n;
  l = l - Js(u);
  let d = {
    keyframes: Array.isArray(r) ? r : [null, r],
    ease: "easeOut",
    velocity: e.getVelocity(),
    ...a,
    delay: -l,
    onUpdate: (w) => {
      e.set(w), a.onUpdate && a.onUpdate(w);
    },
    onComplete: () => {
      o(), a.onComplete && a.onComplete();
    },
    name: t,
    motionValue: e,
    element: s ? void 0 : i
  };
  Fee(a) || (d = {
    ...d,
    ...nQ(t, d)
  }), d.duration && (d.duration = Js(d.duration)), d.repeatDelay && (d.repeatDelay = Js(d.repeatDelay)), d.from !== void 0 && (d.keyframes[0] = d.from);
  let p = !1;
  if ((d.type === !1 || d.duration === 0 && !d.repeatDelay) && (d.duration = 0, d.delay === 0 && (p = !0)), p && !s && e.get() !== void 0) {
    const w = Np(d.keyframes, a);
    if (w !== void 0)
      return Lr.update(() => {
        d.onUpdate(w), d.onComplete();
      }), new Bee([]);
  }
  return !s && M6.supports(d) ? new M6(d) : new ny(d);
}, jee = (t) => !!(t && typeof t == "object" && t.mix && t.toValue), Uee = (t) => dv(t) ? t[t.length - 1] || 0 : t;
function oy(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function ay(t, e) {
  const r = t.indexOf(e);
  r > -1 && t.splice(r, 1);
}
class cy {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return oy(this.subscriptions, e), () => ay(this.subscriptions, e);
  }
  notify(e, r, n) {
    const i = this.subscriptions.length;
    if (i)
      if (i === 1)
        this.subscriptions[0](e, r, n);
      else
        for (let s = 0; s < i; s++) {
          const o = this.subscriptions[s];
          o && o(e, r, n);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const I6 = 30, qee = (t) => !isNaN(parseFloat(t));
class zee {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(e, r = {}) {
    this.version = "11.11.17", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (n, i = !0) => {
      const s = Zs.now();
      this.updatedAt !== s && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(n), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), i && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.hasAnimated = !1, this.setCurrent(e), this.owner = r.owner;
  }
  setCurrent(e) {
    this.current = e, this.updatedAt = Zs.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = qee(this.current));
  }
  setPrevFrameValue(e = this.current) {
    this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(e) {
    return process.env.NODE_ENV !== "production" && Rp(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", e);
  }
  on(e, r) {
    this.events[e] || (this.events[e] = new cy());
    const n = this.events[e].add(r);
    return e === "change" ? () => {
      n(), Lr.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : n;
  }
  clearListeners() {
    for (const e in this.events)
      this.events[e].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(e, r) {
    this.passiveEffect = e, this.stopPassiveEffect = r;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(e, r = !0) {
    !r || !this.passiveEffect ? this.updateAndNotify(e, r) : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, r, n) {
    this.set(r), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - n;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(e, r = !0) {
    this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, r && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const e = Zs.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > I6)
      return 0;
    const r = Math.min(this.updatedAt - this.prevUpdatedAt, I6);
    return G7(parseFloat(this.current) - parseFloat(this.prevFrameValue), r);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(e) {
    return this.stop(), new Promise((r) => {
      this.hasAnimated = !0, this.animation = e(r), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function ql(t, e) {
  return new zee(t, e);
}
function Wee(t, e, r) {
  t.hasValue(e) ? t.getValue(e).set(r) : t.addValue(e, ql(r));
}
function Hee(t, e) {
  const r = Op(t, e);
  let { transitionEnd: n = {}, transition: i = {}, ...s } = r || {};
  s = { ...s, ...n };
  for (const o in s) {
    const a = Uee(s[o]);
    Wee(t, o, a);
  }
}
const uy = (t) => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), Kee = "framerAppearId", n9 = "data-" + uy(Kee);
function i9(t) {
  return t.props[n9];
}
const Zn = (t) => !!(t && t.getVelocity);
function Vee(t) {
  return !!(Zn(t) && t.add);
}
function xv(t, e) {
  const r = t.getValue("willChange");
  if (Vee(r))
    return r.add(e);
}
function Gee({ protectedKeys: t, needsAnimating: e }, r) {
  const n = t.hasOwnProperty(r) && e[r] !== !0;
  return e[r] = !1, n;
}
function s9(t, e, { delay: r = 0, transitionOverride: n, type: i } = {}) {
  var s;
  let { transition: o = t.getDefaultTransition(), transitionEnd: a, ...u } = e;
  n && (o = n);
  const l = [], d = i && t.animationState && t.animationState.getState()[i];
  for (const p in u) {
    const w = t.getValue(p, (s = t.latestValues[p]) !== null && s !== void 0 ? s : null), _ = u[p];
    if (_ === void 0 || d && Gee(d, p))
      continue;
    const P = {
      delay: r,
      ...Hb(o || {}, p)
    };
    let O = !1;
    if (window.MotionHandoffAnimation) {
      const B = i9(t);
      if (B) {
        const k = window.MotionHandoffAnimation(B, p, Lr);
        k !== null && (P.startTime = k, O = !0);
      }
    }
    xv(t, p), w.start(sy(p, w, _, t.shouldReduceMotion && Lc.has(p) ? { type: !1 } : P, t, O));
    const L = w.animation;
    L && l.push(L);
  }
  return a && Promise.all(l).then(() => {
    Lr.update(() => {
      a && Hee(t, a);
    });
  }), l;
}
function _v(t, e, r = {}) {
  var n;
  const i = Op(t, e, r.type === "exit" ? (n = t.presenceContext) === null || n === void 0 ? void 0 : n.custom : void 0);
  let { transition: s = t.getDefaultTransition() || {} } = i || {};
  r.transitionOverride && (s = r.transitionOverride);
  const o = i ? () => Promise.all(s9(t, i, r)) : () => Promise.resolve(), a = t.variantChildren && t.variantChildren.size ? (l = 0) => {
    const { delayChildren: d = 0, staggerChildren: p, staggerDirection: w } = s;
    return Yee(t, e, d + l, p, w, r);
  } : () => Promise.resolve(), { when: u } = s;
  if (u) {
    const [l, d] = u === "beforeChildren" ? [o, a] : [a, o];
    return l().then(() => d());
  } else
    return Promise.all([o(), a(r.delay)]);
}
function Yee(t, e, r = 0, n = 0, i = 1, s) {
  const o = [], a = (t.variantChildren.size - 1) * n, u = i === 1 ? (l = 0) => l * n : (l = 0) => a - l * n;
  return Array.from(t.variantChildren).sort(Jee).forEach((l, d) => {
    l.notify("AnimationStart", e), o.push(_v(l, e, {
      ...s,
      delay: r + u(d)
    }).then(() => l.notify("AnimationComplete", e)));
  }), Promise.all(o);
}
function Jee(t, e) {
  return t.sortNodePosition(e);
}
function Xee(t, e, r = {}) {
  t.notify("AnimationStart", e);
  let n;
  if (Array.isArray(e)) {
    const i = e.map((s) => _v(t, s, r));
    n = Promise.all(i);
  } else if (typeof e == "string")
    n = _v(t, e, r);
  else {
    const i = typeof e == "function" ? Op(t, e, r.custom) : e;
    n = Promise.all(s9(t, i, r));
  }
  return n.then(() => {
    t.notify("AnimationComplete", e);
  });
}
const Zee = Wb.length;
function o9(t) {
  if (!t)
    return;
  if (!t.isControllingVariants) {
    const r = t.parent ? o9(t.parent) || {} : {};
    return t.props.initial !== void 0 && (r.initial = t.props.initial), r;
  }
  const e = {};
  for (let r = 0; r < Zee; r++) {
    const n = Wb[r], i = t.props[n];
    (Fl(i) || i === !1) && (e[n] = i);
  }
  return e;
}
const Qee = [...zb].reverse(), ete = zb.length;
function tte(t) {
  return (e) => Promise.all(e.map(({ animation: r, options: n }) => Xee(t, r, n)));
}
function rte(t) {
  let e = tte(t), r = C6(), n = !0;
  const i = (u) => (l, d) => {
    var p;
    const w = Op(t, d, u === "exit" ? (p = t.presenceContext) === null || p === void 0 ? void 0 : p.custom : void 0);
    if (w) {
      const { transition: _, transitionEnd: P, ...O } = w;
      l = { ...l, ...O, ...P };
    }
    return l;
  };
  function s(u) {
    e = u(t);
  }
  function o(u) {
    const { props: l } = t, d = o9(t.parent) || {}, p = [], w = /* @__PURE__ */ new Set();
    let _ = {}, P = 1 / 0;
    for (let L = 0; L < ete; L++) {
      const B = Qee[L], k = r[B], q = l[B] !== void 0 ? l[B] : d[B], U = Fl(q), V = B === u ? k.isActive : null;
      V === !1 && (P = L);
      let Q = q === d[B] && q !== l[B] && U;
      if (Q && n && t.manuallyAnimateOnMount && (Q = !1), k.protectedKeys = { ..._ }, // If it isn't active and hasn't *just* been set as inactive
      !k.isActive && V === null || // If we didn't and don't have any defined prop for this animation type
      !q && !k.prevProp || // Or if the prop doesn't define an animation
      Dp(q) || typeof q == "boolean")
        continue;
      const R = nte(k.prevProp, q);
      let K = R || // If we're making this variant active, we want to always make it active
      B === u && k.isActive && !Q && U || // If we removed a higher-priority variant (i is in reverse order)
      L > P && U, ge = !1;
      const Ee = Array.isArray(q) ? q : [q];
      let Y = Ee.reduce(i(B), {});
      V === !1 && (Y = {});
      const { prevResolvedValues: A = {} } = k, m = {
        ...A,
        ...Y
      }, f = (x) => {
        K = !0, w.has(x) && (ge = !0, w.delete(x)), k.needsAnimating[x] = !0;
        const E = t.getValue(x);
        E && (E.liveStyle = !1);
      };
      for (const x in m) {
        const E = Y[x], S = A[x];
        if (_.hasOwnProperty(x))
          continue;
        let v = !1;
        dv(E) && dv(S) ? v = !x7(E, S) : v = E !== S, v ? E != null ? f(x) : w.add(x) : E !== void 0 && w.has(x) ? f(x) : k.protectedKeys[x] = !0;
      }
      k.prevProp = q, k.prevResolvedValues = Y, k.isActive && (_ = { ..._, ...Y }), n && t.blockInitialAnimation && (K = !1), K && (!(Q && R) || ge) && p.push(...Ee.map((x) => ({
        animation: x,
        options: { type: B }
      })));
    }
    if (w.size) {
      const L = {};
      w.forEach((B) => {
        const k = t.getBaseTarget(B), q = t.getValue(B);
        q && (q.liveStyle = !0), L[B] = k ?? null;
      }), p.push({ animation: L });
    }
    let O = !!p.length;
    return n && (l.initial === !1 || l.initial === l.animate) && !t.manuallyAnimateOnMount && (O = !1), n = !1, O ? e(p) : Promise.resolve();
  }
  function a(u, l) {
    var d;
    if (r[u].isActive === l)
      return Promise.resolve();
    (d = t.variantChildren) === null || d === void 0 || d.forEach((w) => {
      var _;
      return (_ = w.animationState) === null || _ === void 0 ? void 0 : _.setActive(u, l);
    }), r[u].isActive = l;
    const p = o(u);
    for (const w in r)
      r[w].protectedKeys = {};
    return p;
  }
  return {
    animateChanges: o,
    setActive: a,
    setAnimateFunction: s,
    getState: () => r,
    reset: () => {
      r = C6(), n = !0;
    }
  };
}
function nte(t, e) {
  return typeof e == "string" ? e !== t : Array.isArray(e) ? !x7(e, t) : !1;
}
function Qa(t = !1) {
  return {
    isActive: t,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function C6() {
  return {
    animate: Qa(!0),
    whileInView: Qa(),
    whileHover: Qa(),
    whileTap: Qa(),
    whileDrag: Qa(),
    whileFocus: Qa(),
    exit: Qa()
  };
}
class $a {
  constructor(e) {
    this.isMounted = !1, this.node = e;
  }
  update() {
  }
}
class ite extends $a {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(e) {
    super(e), e.animationState || (e.animationState = rte(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    Dp(e) && (this.unmountControls = e.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(), { animate: r } = this.node.prevProps || {};
    e !== r && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var e;
    this.node.animationState.reset(), (e = this.unmountControls) === null || e === void 0 || e.call(this);
  }
}
let ste = 0;
class ote extends $a {
  constructor() {
    super(...arguments), this.id = ste++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: e, onExitComplete: r } = this.node.presenceContext, { isPresent: n } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === n)
      return;
    const i = this.node.animationState.setActive("exit", !e);
    r && !e && i.then(() => r(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {
  }
}
const ate = {
  animation: {
    Feature: ite
  },
  exit: {
    Feature: ote
  }
}, a9 = (t) => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1;
function Lp(t, e = "page") {
  return {
    point: {
      x: t[`${e}X`],
      y: t[`${e}Y`]
    }
  };
}
const cte = (t) => (e) => a9(e) && t(e, Lp(e));
function Ro(t, e, r, n = { passive: !0 }) {
  return t.addEventListener(e, r, n), () => t.removeEventListener(e, r);
}
function ko(t, e, r, n) {
  return Ro(t, e, cte(r), n);
}
const T6 = (t, e) => Math.abs(t - e);
function ute(t, e) {
  const r = T6(t.x, e.x), n = T6(t.y, e.y);
  return Math.sqrt(r ** 2 + n ** 2);
}
class c9 {
  constructor(e, r, { transformPagePoint: n, contextWindow: i, dragSnapToOrigin: s = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const p = Zm(this.lastMoveEventInfo, this.history), w = this.startEvent !== null, _ = ute(p.offset, { x: 0, y: 0 }) >= 3;
      if (!w && !_)
        return;
      const { point: P } = p, { timestamp: O } = Fn;
      this.history.push({ ...P, timestamp: O });
      const { onStart: L, onMove: B } = this.handlers;
      w || (L && L(this.lastMoveEvent, p), this.startEvent = this.lastMoveEvent), B && B(this.lastMoveEvent, p);
    }, this.handlePointerMove = (p, w) => {
      this.lastMoveEvent = p, this.lastMoveEventInfo = Xm(w, this.transformPagePoint), Lr.update(this.updatePoint, !0);
    }, this.handlePointerUp = (p, w) => {
      this.end();
      const { onEnd: _, onSessionEnd: P, resumeAnimation: O } = this.handlers;
      if (this.dragSnapToOrigin && O && O(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const L = Zm(p.type === "pointercancel" ? this.lastMoveEventInfo : Xm(w, this.transformPagePoint), this.history);
      this.startEvent && _ && _(p, L), P && P(p, L);
    }, !a9(e))
      return;
    this.dragSnapToOrigin = s, this.handlers = r, this.transformPagePoint = n, this.contextWindow = i || window;
    const o = Lp(e), a = Xm(o, this.transformPagePoint), { point: u } = a, { timestamp: l } = Fn;
    this.history = [{ ...u, timestamp: l }];
    const { onSessionStart: d } = r;
    d && d(e, Zm(a, this.history)), this.removeListeners = Lo(ko(this.contextWindow, "pointermove", this.handlePointerMove), ko(this.contextWindow, "pointerup", this.handlePointerUp), ko(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), Pa(this.updatePoint);
  }
}
function Xm(t, e) {
  return e ? { point: e(t.point) } : t;
}
function R6(t, e) {
  return { x: t.x - e.x, y: t.y - e.y };
}
function Zm({ point: t }, e) {
  return {
    point: t,
    delta: R6(t, u9(e)),
    offset: R6(t, fte(e)),
    velocity: lte(e, 0.1)
  };
}
function fte(t) {
  return t[0];
}
function u9(t) {
  return t[t.length - 1];
}
function lte(t, e) {
  if (t.length < 2)
    return { x: 0, y: 0 };
  let r = t.length - 1, n = null;
  const i = u9(t);
  for (; r >= 0 && (n = t[r], !(i.timestamp - n.timestamp > Js(e))); )
    r--;
  if (!n)
    return { x: 0, y: 0 };
  const s = No(i.timestamp - n.timestamp);
  if (s === 0)
    return { x: 0, y: 0 };
  const o = {
    x: (i.x - n.x) / s,
    y: (i.y - n.y) / s
  };
  return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o;
}
function f9(t) {
  let e = null;
  return () => {
    const r = () => {
      e = null;
    };
    return e === null ? (e = t, r) : !1;
  };
}
const D6 = f9("dragHorizontal"), O6 = f9("dragVertical");
function l9(t) {
  let e = !1;
  if (t === "y")
    e = O6();
  else if (t === "x")
    e = D6();
  else {
    const r = D6(), n = O6();
    r && n ? e = () => {
      r(), n();
    } : (r && r(), n && n());
  }
  return e;
}
function h9() {
  const t = l9(!0);
  return t ? (t(), !1) : !0;
}
function lu(t) {
  return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current");
}
const d9 = 1e-4, hte = 1 - d9, dte = 1 + d9, p9 = 0.01, pte = 0 - p9, gte = 0 + p9;
function ki(t) {
  return t.max - t.min;
}
function mte(t, e, r) {
  return Math.abs(t - e) <= r;
}
function N6(t, e, r, n = 0.5) {
  t.origin = n, t.originPoint = Qr(e.min, e.max, t.origin), t.scale = ki(r) / ki(e), t.translate = Qr(r.min, r.max, t.origin) - t.originPoint, (t.scale >= hte && t.scale <= dte || isNaN(t.scale)) && (t.scale = 1), (t.translate >= pte && t.translate <= gte || isNaN(t.translate)) && (t.translate = 0);
}
function nl(t, e, r, n) {
  N6(t.x, e.x, r.x, n ? n.originX : void 0), N6(t.y, e.y, r.y, n ? n.originY : void 0);
}
function L6(t, e, r) {
  t.min = r.min + e.min, t.max = t.min + ki(e);
}
function vte(t, e, r) {
  L6(t.x, e.x, r.x), L6(t.y, e.y, r.y);
}
function k6(t, e, r) {
  t.min = e.min - r.min, t.max = t.min + ki(e);
}
function il(t, e, r) {
  k6(t.x, e.x, r.x), k6(t.y, e.y, r.y);
}
function bte(t, { min: e, max: r }, n) {
  return e !== void 0 && t < e ? t = n ? Qr(e, t, n.min) : Math.max(t, e) : r !== void 0 && t > r && (t = n ? Qr(r, t, n.max) : Math.min(t, r)), t;
}
function $6(t, e, r) {
  return {
    min: e !== void 0 ? t.min + e : void 0,
    max: r !== void 0 ? t.max + r - (t.max - t.min) : void 0
  };
}
function yte(t, { top: e, left: r, bottom: n, right: i }) {
  return {
    x: $6(t.x, r, i),
    y: $6(t.y, e, n)
  };
}
function B6(t, e) {
  let r = e.min - t.min, n = e.max - t.max;
  return e.max - e.min < t.max - t.min && ([r, n] = [n, r]), { min: r, max: n };
}
function wte(t, e) {
  return {
    x: B6(t.x, e.x),
    y: B6(t.y, e.y)
  };
}
function xte(t, e) {
  let r = 0.5;
  const n = ki(t), i = ki(e);
  return i > n ? r = $u(e.min, e.max - n, t.min) : n > i && (r = $u(t.min, t.max - i, e.min)), Ma(0, 1, r);
}
function _te(t, e) {
  const r = {};
  return e.min !== void 0 && (r.min = e.min - t.min), e.max !== void 0 && (r.max = e.max - t.min), r;
}
const Ev = 0.35;
function Ete(t = Ev) {
  return t === !1 ? t = 0 : t === !0 && (t = Ev), {
    x: F6(t, "left", "right"),
    y: F6(t, "top", "bottom")
  };
}
function F6(t, e, r) {
  return {
    min: j6(t, e),
    max: j6(t, r)
  };
}
function j6(t, e) {
  return typeof t == "number" ? t : t[e] || 0;
}
const U6 = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), hu = () => ({
  x: U6(),
  y: U6()
}), q6 = () => ({ min: 0, max: 0 }), ln = () => ({
  x: q6(),
  y: q6()
});
function Qi(t) {
  return [t("x"), t("y")];
}
function g9({ top: t, left: e, right: r, bottom: n }) {
  return {
    x: { min: e, max: r },
    y: { min: t, max: n }
  };
}
function Ste({ x: t, y: e }) {
  return { top: e.min, right: t.max, bottom: e.max, left: t.min };
}
function Ate(t, e) {
  if (!e)
    return t;
  const r = e({ x: t.left, y: t.top }), n = e({ x: t.right, y: t.bottom });
  return {
    top: r.y,
    left: r.x,
    bottom: n.y,
    right: n.x
  };
}
function Qm(t) {
  return t === void 0 || t === 1;
}
function Sv({ scale: t, scaleX: e, scaleY: r }) {
  return !Qm(t) || !Qm(e) || !Qm(r);
}
function tc(t) {
  return Sv(t) || m9(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY;
}
function m9(t) {
  return z6(t.x) || z6(t.y);
}
function z6(t) {
  return t && t !== "0%";
}
function O0(t, e, r) {
  const n = t - r, i = e * n;
  return r + i;
}
function W6(t, e, r, n, i) {
  return i !== void 0 && (t = O0(t, i, n)), O0(t, r, n) + e;
}
function Av(t, e = 0, r = 1, n, i) {
  t.min = W6(t.min, e, r, n, i), t.max = W6(t.max, e, r, n, i);
}
function v9(t, { x: e, y: r }) {
  Av(t.x, e.translate, e.scale, e.originPoint), Av(t.y, r.translate, r.scale, r.originPoint);
}
const H6 = 0.999999999999, K6 = 1.0000000000001;
function Pte(t, e, r, n = !1) {
  const i = r.length;
  if (!i)
    return;
  e.x = e.y = 1;
  let s, o;
  for (let a = 0; a < i; a++) {
    s = r[a], o = s.projectionDelta;
    const { visualElement: u } = s.options;
    u && u.props.style && u.props.style.display === "contents" || (n && s.options.layoutScroll && s.scroll && s !== s.root && pu(t, {
      x: -s.scroll.offset.x,
      y: -s.scroll.offset.y
    }), o && (e.x *= o.x.scale, e.y *= o.y.scale, v9(t, o)), n && tc(s.latestValues) && pu(t, s.latestValues));
  }
  e.x < K6 && e.x > H6 && (e.x = 1), e.y < K6 && e.y > H6 && (e.y = 1);
}
function du(t, e) {
  t.min = t.min + e, t.max = t.max + e;
}
function V6(t, e, r, n, i = 0.5) {
  const s = Qr(t.min, t.max, i);
  Av(t, e, r, s, n);
}
function pu(t, e) {
  V6(t.x, e.x, e.scaleX, e.scale, e.originX), V6(t.y, e.y, e.scaleY, e.scale, e.originY);
}
function b9(t, e) {
  return g9(Ate(t.getBoundingClientRect(), e));
}
function Mte(t, e, r) {
  const n = b9(t, r), { scroll: i } = e;
  return i && (du(n.x, i.offset.x), du(n.y, i.offset.y)), n;
}
const y9 = ({ current: t }) => t ? t.ownerDocument.defaultView : null, Ite = /* @__PURE__ */ new WeakMap();
class Cte {
  constructor(e) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = ln(), this.visualElement = e;
  }
  start(e, { snapToCursor: r = !1 } = {}) {
    const { presenceContext: n } = this.visualElement;
    if (n && n.isPresent === !1)
      return;
    const i = (d) => {
      const { dragSnapToOrigin: p } = this.getProps();
      p ? this.pauseAnimation() : this.stopAnimation(), r && this.snapToCursor(Lp(d, "page").point);
    }, s = (d, p) => {
      const { drag: w, dragPropagation: _, onDragStart: P } = this.getProps();
      if (w && !_ && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = l9(w), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Qi((L) => {
        let B = this.getAxisMotionValue(L).get() || 0;
        if (Xs.test(B)) {
          const { projection: k } = this.visualElement;
          if (k && k.layout) {
            const q = k.layout.layoutBox[L];
            q && (B = ki(q) * (parseFloat(B) / 100));
          }
        }
        this.originPoint[L] = B;
      }), P && Lr.postRender(() => P(d, p)), xv(this.visualElement, "transform");
      const { animationState: O } = this.visualElement;
      O && O.setActive("whileDrag", !0);
    }, o = (d, p) => {
      const { dragPropagation: w, dragDirectionLock: _, onDirectionLock: P, onDrag: O } = this.getProps();
      if (!w && !this.openGlobalLock)
        return;
      const { offset: L } = p;
      if (_ && this.currentDirection === null) {
        this.currentDirection = Tte(L), this.currentDirection !== null && P && P(this.currentDirection);
        return;
      }
      this.updateAxis("x", p.point, L), this.updateAxis("y", p.point, L), this.visualElement.render(), O && O(d, p);
    }, a = (d, p) => this.stop(d, p), u = () => Qi((d) => {
      var p;
      return this.getAnimationState(d) === "paused" && ((p = this.getAxisMotionValue(d).animation) === null || p === void 0 ? void 0 : p.play());
    }), { dragSnapToOrigin: l } = this.getProps();
    this.panSession = new c9(e, {
      onSessionStart: i,
      onStart: s,
      onMove: o,
      onSessionEnd: a,
      resumeAnimation: u
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: l,
      contextWindow: y9(this.visualElement)
    });
  }
  stop(e, r) {
    const n = this.isDragging;
    if (this.cancel(), !n)
      return;
    const { velocity: i } = r;
    this.startAnimation(i);
    const { onDragEnd: s } = this.getProps();
    s && Lr.postRender(() => s(e, r));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: r } = this.visualElement;
    e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: n } = this.getProps();
    !n && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), r && r.setActive("whileDrag", !1);
  }
  updateAxis(e, r, n) {
    const { drag: i } = this.getProps();
    if (!n || !Id(e, i, this.currentDirection))
      return;
    const s = this.getAxisMotionValue(e);
    let o = this.originPoint[e] + n[e];
    this.constraints && this.constraints[e] && (o = bte(o, this.constraints[e], this.elastic[e])), s.set(o);
  }
  resolveConstraints() {
    var e;
    const { dragConstraints: r, dragElastic: n } = this.getProps(), i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout, s = this.constraints;
    r && lu(r) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : r && i ? this.constraints = yte(i.layoutBox, r) : this.constraints = !1, this.elastic = Ete(n), s !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && Qi((o) => {
      this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = _te(i.layoutBox[o], this.constraints[o]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: r } = this.getProps();
    if (!e || !lu(e))
      return !1;
    const n = e.current;
    Wo(n !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: i } = this.visualElement;
    if (!i || !i.layout)
      return !1;
    const s = Mte(n, i.root, this.visualElement.getTransformPagePoint());
    let o = wte(i.layout.layoutBox, s);
    if (r) {
      const a = r(Ste(o));
      this.hasMutatedConstraints = !!a, a && (o = g9(a));
    }
    return o;
  }
  startAnimation(e) {
    const { drag: r, dragMomentum: n, dragElastic: i, dragTransition: s, dragSnapToOrigin: o, onDragTransitionEnd: a } = this.getProps(), u = this.constraints || {}, l = Qi((d) => {
      if (!Id(d, r, this.currentDirection))
        return;
      let p = u && u[d] || {};
      o && (p = { min: 0, max: 0 });
      const w = i ? 200 : 1e6, _ = i ? 40 : 1e7, P = {
        type: "inertia",
        velocity: n ? e[d] : 0,
        bounceStiffness: w,
        bounceDamping: _,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...s,
        ...p
      };
      return this.startAxisValueAnimation(d, P);
    });
    return Promise.all(l).then(a);
  }
  startAxisValueAnimation(e, r) {
    const n = this.getAxisMotionValue(e);
    return xv(this.visualElement, e), n.start(sy(e, n, 0, r, this.visualElement, !1));
  }
  stopAnimation() {
    Qi((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    Qi((e) => {
      var r;
      return (r = this.getAxisMotionValue(e).animation) === null || r === void 0 ? void 0 : r.pause();
    });
  }
  getAnimationState(e) {
    var r;
    return (r = this.getAxisMotionValue(e).animation) === null || r === void 0 ? void 0 : r.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(e) {
    const r = `_drag${e.toUpperCase()}`, n = this.visualElement.getProps(), i = n[r];
    return i || this.visualElement.getValue(e, (n.initial ? n.initial[e] : void 0) || 0);
  }
  snapToCursor(e) {
    Qi((r) => {
      const { drag: n } = this.getProps();
      if (!Id(r, n, this.currentDirection))
        return;
      const { projection: i } = this.visualElement, s = this.getAxisMotionValue(r);
      if (i && i.layout) {
        const { min: o, max: a } = i.layout.layoutBox[r];
        s.set(e[r] - Qr(o, a, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: e, dragConstraints: r } = this.getProps(), { projection: n } = this.visualElement;
    if (!lu(r) || !n || !this.constraints)
      return;
    this.stopAnimation();
    const i = { x: 0, y: 0 };
    Qi((o) => {
      const a = this.getAxisMotionValue(o);
      if (a && this.constraints !== !1) {
        const u = a.get();
        i[o] = xte({ min: u, max: u }, this.constraints[o]);
      }
    });
    const { transformTemplate: s } = this.visualElement.getProps();
    this.visualElement.current.style.transform = s ? s({}, "") : "none", n.root && n.root.updateScroll(), n.updateLayout(), this.resolveConstraints(), Qi((o) => {
      if (!Id(o, e, null))
        return;
      const a = this.getAxisMotionValue(o), { min: u, max: l } = this.constraints[o];
      a.set(Qr(u, l, i[o]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    Ite.set(this.visualElement, this);
    const e = this.visualElement.current, r = ko(e, "pointerdown", (u) => {
      const { drag: l, dragListener: d = !0 } = this.getProps();
      l && d && this.start(u);
    }), n = () => {
      const { dragConstraints: u } = this.getProps();
      lu(u) && u.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: i } = this.visualElement, s = i.addEventListener("measure", n);
    i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), Lr.read(n);
    const o = Ro(window, "resize", () => this.scalePositionWithinConstraints()), a = i.addEventListener("didUpdate", ({ delta: u, hasLayoutChanged: l }) => {
      this.isDragging && l && (Qi((d) => {
        const p = this.getAxisMotionValue(d);
        p && (this.originPoint[d] += u[d].translate, p.set(p.get() + u[d].translate));
      }), this.visualElement.render());
    });
    return () => {
      o(), r(), s(), a && a();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(), { drag: r = !1, dragDirectionLock: n = !1, dragPropagation: i = !1, dragConstraints: s = !1, dragElastic: o = Ev, dragMomentum: a = !0 } = e;
    return {
      ...e,
      drag: r,
      dragDirectionLock: n,
      dragPropagation: i,
      dragConstraints: s,
      dragElastic: o,
      dragMomentum: a
    };
  }
}
function Id(t, e, r) {
  return (e === !0 || e === t) && (r === null || r === t);
}
function Tte(t, e = 10) {
  let r = null;
  return Math.abs(t.y) > e ? r = "y" : Math.abs(t.x) > e && (r = "x"), r;
}
class Rte extends $a {
  constructor(e) {
    super(e), this.removeGroupControls = Un, this.removeListeners = Un, this.controls = new Cte(e);
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Un;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const G6 = (t) => (e, r) => {
  t && Lr.postRender(() => t(e, r));
};
class Dte extends $a {
  constructor() {
    super(...arguments), this.removePointerDownListener = Un;
  }
  onPointerDown(e) {
    this.session = new c9(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: y9(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: e, onPanStart: r, onPan: n, onPanEnd: i } = this.node.getProps();
    return {
      onSessionStart: G6(e),
      onStart: G6(r),
      onMove: n,
      onEnd: (s, o) => {
        delete this.session, i && Lr.postRender(() => i(s, o));
      }
    };
  }
  mount() {
    this.removePointerDownListener = ko(this.node.current, "pointerdown", (e) => this.onPointerDown(e));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const kp = Ta(null);
function Ote() {
  const t = Tn(kp);
  if (t === null)
    return [!0, null];
  const { isPresent: e, onExitComplete: r, register: n } = t, i = Ov();
  Dn(() => n(i), []);
  const s = Nv(() => r && r(i), [i, r]);
  return !e && r ? [!1, s] : [!0];
}
const fy = Ta({}), w9 = Ta({}), Zd = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function Y6(t, e) {
  return e.max === e.min ? 0 : t / (e.max - e.min) * 100;
}
const jf = {
  correct: (t, e) => {
    if (!e.target)
      return t;
    if (typeof t == "string")
      if (Vt.test(t))
        t = parseFloat(t);
      else
        return t;
    const r = Y6(t, e.target.x), n = Y6(t, e.target.y);
    return `${r}% ${n}%`;
  }
}, Nte = {
  correct: (t, { treeScale: e, projectionDelta: r }) => {
    const n = t, i = Ia.parse(t);
    if (i.length > 5)
      return n;
    const s = Ia.createTransformer(t), o = typeof i[0] != "number" ? 1 : 0, a = r.x.scale * e.x, u = r.y.scale * e.y;
    i[0 + o] /= a, i[1 + o] /= u;
    const l = Qr(a, u, 0.5);
    return typeof i[2 + o] == "number" && (i[2 + o] /= l), typeof i[3 + o] == "number" && (i[3 + o] /= l), s(i);
  }
}, N0 = {};
function Lte(t) {
  Object.assign(N0, t);
}
const { schedule: ly } = _7(queueMicrotask, !1);
class kte extends fD {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: e, layoutGroup: r, switchLayoutGroup: n, layoutId: i } = this.props, { projection: s } = e;
    Lte($te), s && (r.group && r.group.add(s), n && n.register && i && n.register(s), s.root.didUpdate(), s.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), s.setOptions({
      ...s.options,
      onExitComplete: () => this.safeToRemove()
    })), Zd.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(e) {
    const { layoutDependency: r, visualElement: n, drag: i, isPresent: s } = this.props, o = n.projection;
    return o && (o.isPresent = s, i || e.layoutDependency !== r || r === void 0 ? o.willUpdate() : this.safeToRemove(), e.isPresent !== s && (s ? o.promote() : o.relegate() || Lr.postRender(() => {
      const a = o.getStack();
      (!a || !a.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e && (e.root.didUpdate(), ly.postRender(() => {
      !e.currentAnimation && e.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: e, layoutGroup: r, switchLayoutGroup: n } = this.props, { projection: i } = e;
    i && (i.scheduleCheckAfterUnmount(), r && r.group && r.group.remove(i), n && n.deregister && n.deregister(i));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function x9(t) {
  const [e, r] = Ote(), n = Tn(fy);
  return le.jsx(kte, { ...t, layoutGroup: n, switchLayoutGroup: Tn(w9), isPresent: e, safeToRemove: r });
}
const $te = {
  borderRadius: {
    ...jf,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: jf,
  borderTopRightRadius: jf,
  borderBottomLeftRadius: jf,
  borderBottomRightRadius: jf,
  boxShadow: Nte
}, _9 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], Bte = _9.length, J6 = (t) => typeof t == "string" ? parseFloat(t) : t, X6 = (t) => typeof t == "number" || Vt.test(t);
function Fte(t, e, r, n, i, s) {
  i ? (t.opacity = Qr(
    0,
    // TODO Reinstate this if only child
    r.opacity !== void 0 ? r.opacity : 1,
    jte(n)
  ), t.opacityExit = Qr(e.opacity !== void 0 ? e.opacity : 1, 0, Ute(n))) : s && (t.opacity = Qr(e.opacity !== void 0 ? e.opacity : 1, r.opacity !== void 0 ? r.opacity : 1, n));
  for (let o = 0; o < Bte; o++) {
    const a = `border${_9[o]}Radius`;
    let u = Z6(e, a), l = Z6(r, a);
    if (u === void 0 && l === void 0)
      continue;
    u || (u = 0), l || (l = 0), u === 0 || l === 0 || X6(u) === X6(l) ? (t[a] = Math.max(Qr(J6(u), J6(l), n), 0), (Xs.test(l) || Xs.test(u)) && (t[a] += "%")) : t[a] = l;
  }
  (e.rotate || r.rotate) && (t.rotate = Qr(e.rotate || 0, r.rotate || 0, n));
}
function Z6(t, e) {
  return t[e] !== void 0 ? t[e] : t.borderRadius;
}
const jte = /* @__PURE__ */ E9(0, 0.5, C7), Ute = /* @__PURE__ */ E9(0.5, 0.95, Un);
function E9(t, e, r) {
  return (n) => n < t ? 0 : n > e ? 1 : r($u(t, e, n));
}
function Q6(t, e) {
  t.min = e.min, t.max = e.max;
}
function Xi(t, e) {
  Q6(t.x, e.x), Q6(t.y, e.y);
}
function e5(t, e) {
  t.translate = e.translate, t.scale = e.scale, t.originPoint = e.originPoint, t.origin = e.origin;
}
function t5(t, e, r, n, i) {
  return t -= e, t = O0(t, 1 / r, n), i !== void 0 && (t = O0(t, 1 / i, n)), t;
}
function qte(t, e = 0, r = 1, n = 0.5, i, s = t, o = t) {
  if (Xs.test(e) && (e = parseFloat(e), e = Qr(o.min, o.max, e / 100) - o.min), typeof e != "number")
    return;
  let a = Qr(s.min, s.max, n);
  t === s && (a -= e), t.min = t5(t.min, e, r, a, i), t.max = t5(t.max, e, r, a, i);
}
function r5(t, e, [r, n, i], s, o) {
  qte(t, e[r], e[n], e[i], e.scale, s, o);
}
const zte = ["x", "scaleX", "originX"], Wte = ["y", "scaleY", "originY"];
function n5(t, e, r, n) {
  r5(t.x, e, zte, r ? r.x : void 0, n ? n.x : void 0), r5(t.y, e, Wte, r ? r.y : void 0, n ? n.y : void 0);
}
function i5(t) {
  return t.translate === 0 && t.scale === 1;
}
function S9(t) {
  return i5(t.x) && i5(t.y);
}
function s5(t, e) {
  return t.min === e.min && t.max === e.max;
}
function Hte(t, e) {
  return s5(t.x, e.x) && s5(t.y, e.y);
}
function o5(t, e) {
  return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max);
}
function A9(t, e) {
  return o5(t.x, e.x) && o5(t.y, e.y);
}
function a5(t) {
  return ki(t.x) / ki(t.y);
}
function c5(t, e) {
  return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint;
}
class Kte {
  constructor() {
    this.members = [];
  }
  add(e) {
    oy(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (ay(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
      const r = this.members[this.members.length - 1];
      r && this.promote(r);
    }
  }
  relegate(e) {
    const r = this.members.findIndex((i) => e === i);
    if (r === 0)
      return !1;
    let n;
    for (let i = r; i >= 0; i--) {
      const s = this.members[i];
      if (s.isPresent !== !1) {
        n = s;
        break;
      }
    }
    return n ? (this.promote(n), !0) : !1;
  }
  promote(e, r) {
    const n = this.lead;
    if (e !== n && (this.prevLead = n, this.lead = e, e.show(), n)) {
      n.instance && n.scheduleRender(), e.scheduleRender(), e.resumeFrom = n, r && (e.resumeFrom.preserveOpacity = !0), n.snapshot && (e.snapshot = n.snapshot, e.snapshot.latestValues = n.animationValues || n.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: i } = e.options;
      i === !1 && n.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: r, resumingFrom: n } = e;
      r.onExitComplete && r.onExitComplete(), n && n.options.onExitComplete && n.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function Vte(t, e, r) {
  let n = "";
  const i = t.x.translate / e.x, s = t.y.translate / e.y, o = (r == null ? void 0 : r.z) || 0;
  if ((i || s || o) && (n = `translate3d(${i}px, ${s}px, ${o}px) `), (e.x !== 1 || e.y !== 1) && (n += `scale(${1 / e.x}, ${1 / e.y}) `), r) {
    const { transformPerspective: l, rotate: d, rotateX: p, rotateY: w, skewX: _, skewY: P } = r;
    l && (n = `perspective(${l}px) ${n}`), d && (n += `rotate(${d}deg) `), p && (n += `rotateX(${p}deg) `), w && (n += `rotateY(${w}deg) `), _ && (n += `skewX(${_}deg) `), P && (n += `skewY(${P}deg) `);
  }
  const a = t.x.scale * e.x, u = t.y.scale * e.y;
  return (a !== 1 || u !== 1) && (n += `scale(${a}, ${u})`), n || "none";
}
const Gte = (t, e) => t.depth - e.depth;
class Yte {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(e) {
    oy(this.children, e), this.isDirty = !0;
  }
  remove(e) {
    ay(this.children, e), this.isDirty = !0;
  }
  forEach(e) {
    this.isDirty && this.children.sort(Gte), this.isDirty = !1, this.children.forEach(e);
  }
}
function Qd(t) {
  const e = Zn(t) ? t.get() : t;
  return jee(e) ? e.toValue() : e;
}
function Jte(t, e) {
  const r = Zs.now(), n = ({ timestamp: i }) => {
    const s = i - r;
    s >= e && (Pa(n), t(s - e));
  };
  return Lr.read(n, !0), () => Pa(n);
}
function Xte(t) {
  return t instanceof SVGElement && t.tagName !== "svg";
}
function Zte(t, e, r) {
  const n = Zn(t) ? t : ql(t);
  return n.start(sy("", n, e, r)), n.animation;
}
const rc = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
}, Gf = typeof window < "u" && window.MotionDebug !== void 0, e1 = ["", "X", "Y", "Z"], Qte = { visibility: "hidden" }, u5 = 1e3;
let ere = 0;
function t1(t, e, r, n) {
  const { latestValues: i } = e;
  i[t] && (r[t] = i[t], e.setStaticValue(t, 0), n && (n[t] = 0));
}
function P9(t) {
  if (t.hasCheckedOptimisedAppear = !0, t.root === t)
    return;
  const { visualElement: e } = t.options;
  if (!e)
    return;
  const r = i9(e);
  if (window.MotionHasOptimisedAnimation(r, "transform")) {
    const { layout: i, layoutId: s } = t.options;
    window.MotionCancelOptimisedAnimation(r, "transform", Lr, !(i || s));
  }
  const { parent: n } = t;
  n && !n.hasCheckedOptimisedAppear && P9(n);
}
function M9({ attachResizeListener: t, defaultParent: e, measureScroll: r, checkIsScrollRoot: n, resetTransform: i }) {
  return class {
    constructor(o = {}, a = e == null ? void 0 : e()) {
      this.id = ere++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, Gf && (rc.totalNodes = rc.resolvedTargetDeltas = rc.recalculatedProjection = 0), this.nodes.forEach(nre), this.nodes.forEach(cre), this.nodes.forEach(ure), this.nodes.forEach(ire), Gf && window.MotionDebug.record(rc);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = o, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
      for (let u = 0; u < this.path.length; u++)
        this.path[u].shouldResetTransform = !0;
      this.root === this && (this.nodes = new Yte());
    }
    addEventListener(o, a) {
      return this.eventHandlers.has(o) || this.eventHandlers.set(o, new cy()), this.eventHandlers.get(o).add(a);
    }
    notifyListeners(o, ...a) {
      const u = this.eventHandlers.get(o);
      u && u.notify(...a);
    }
    hasListeners(o) {
      return this.eventHandlers.has(o);
    }
    /**
     * Lifecycles
     */
    mount(o, a = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = Xte(o), this.instance = o;
      const { layoutId: u, layout: l, visualElement: d } = this.options;
      if (d && !d.current && d.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (l || u) && (this.isLayoutDirty = !0), t) {
        let p;
        const w = () => this.root.updateBlockedByResize = !1;
        t(o, () => {
          this.root.updateBlockedByResize = !0, p && p(), p = Jte(w, 250), Zd.hasAnimatedSinceResize && (Zd.hasAnimatedSinceResize = !1, this.nodes.forEach(l5));
        });
      }
      u && this.root.registerSharedNode(u, this), this.options.animate !== !1 && d && (u || l) && this.addEventListener("didUpdate", ({ delta: p, hasLayoutChanged: w, hasRelativeTargetChanged: _, layout: P }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const O = this.options.transition || d.getDefaultTransition() || pre, { onLayoutAnimationStart: L, onLayoutAnimationComplete: B } = d.getProps(), k = !this.targetLayout || !A9(this.targetLayout, P) || _, q = !w && _;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || q || w && (k || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(p, q);
          const U = {
            ...Hb(O, "layout"),
            onPlay: L,
            onComplete: B
          };
          (d.shouldReduceMotion || this.options.layoutRoot) && (U.delay = 0, U.type = !1), this.startAnimation(U);
        } else
          w || l5(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = P;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const o = this.getStack();
      o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, Pa(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(fre), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: o } = this.options;
      return o && o.getProps().transformTemplate;
    }
    willUpdate(o = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && P9(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let d = 0; d < this.path.length; d++) {
        const p = this.path[d];
        p.shouldResetTransform = !0, p.updateScroll("snapshot"), p.options.layoutRoot && p.willUpdate(!1);
      }
      const { layoutId: a, layout: u } = this.options;
      if (a === void 0 && !u)
        return;
      const l = this.getTransformTemplate();
      this.prevTransformTemplateValue = l ? l(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(f5);
        return;
      }
      this.isUpdating || this.nodes.forEach(ore), this.isUpdating = !1, this.nodes.forEach(are), this.nodes.forEach(tre), this.nodes.forEach(rre), this.clearAllSnapshots();
      const a = Zs.now();
      Fn.delta = Ma(0, 1e3 / 60, a - Fn.timestamp), Fn.timestamp = a, Fn.isProcessing = !0, Km.update.process(Fn), Km.preRender.process(Fn), Km.render.process(Fn), Fn.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, ly.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(sre), this.sharedNodes.forEach(lre);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Lr.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      Lr.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let u = 0; u < this.path.length; u++)
          this.path[u].updateScroll();
      const o = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = ln(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0);
    }
    updateScroll(o = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a) {
        const u = n(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: o,
          isRoot: u,
          offset: r(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : u
        };
      }
    }
    resetTransform() {
      if (!i)
        return;
      const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !S9(this.projectionDelta), u = this.getTransformTemplate(), l = u ? u(this.latestValues, "") : void 0, d = l !== this.prevTransformTemplateValue;
      o && (a || tc(this.latestValues) || d) && (i(this.instance, l), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(o = !0) {
      const a = this.measurePageBox();
      let u = this.removeElementScroll(a);
      return o && (u = this.removeTransform(u)), gre(u), {
        animationId: this.root.animationId,
        measuredBox: a,
        layoutBox: u,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var o;
      const { visualElement: a } = this.options;
      if (!a)
        return ln();
      const u = a.measureViewportBox();
      if (!(((o = this.scroll) === null || o === void 0 ? void 0 : o.wasRoot) || this.path.some(mre))) {
        const { scroll: d } = this.root;
        d && (du(u.x, d.offset.x), du(u.y, d.offset.y));
      }
      return u;
    }
    removeElementScroll(o) {
      var a;
      const u = ln();
      if (Xi(u, o), !((a = this.scroll) === null || a === void 0) && a.wasRoot)
        return u;
      for (let l = 0; l < this.path.length; l++) {
        const d = this.path[l], { scroll: p, options: w } = d;
        d !== this.root && p && w.layoutScroll && (p.wasRoot && Xi(u, o), du(u.x, p.offset.x), du(u.y, p.offset.y));
      }
      return u;
    }
    applyTransform(o, a = !1) {
      const u = ln();
      Xi(u, o);
      for (let l = 0; l < this.path.length; l++) {
        const d = this.path[l];
        !a && d.options.layoutScroll && d.scroll && d !== d.root && pu(u, {
          x: -d.scroll.offset.x,
          y: -d.scroll.offset.y
        }), tc(d.latestValues) && pu(u, d.latestValues);
      }
      return tc(this.latestValues) && pu(u, this.latestValues), u;
    }
    removeTransform(o) {
      const a = ln();
      Xi(a, o);
      for (let u = 0; u < this.path.length; u++) {
        const l = this.path[u];
        if (!l.instance || !tc(l.latestValues))
          continue;
        Sv(l.latestValues) && l.updateSnapshot();
        const d = ln(), p = l.measurePageBox();
        Xi(d, p), n5(a, l.latestValues, l.snapshot ? l.snapshot.layoutBox : void 0, d);
      }
      return tc(this.latestValues) && n5(a, this.latestValues), a;
    }
    setTargetDelta(o) {
      this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(o) {
      this.options = {
        ...this.options,
        ...o,
        crossfade: o.crossfade !== void 0 ? o.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Fn.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(o = !1) {
      var a;
      const u = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = u.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = u.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = u.isSharedProjectionDirty);
      const l = !!this.resumingFrom || this !== u;
      if (!(o || l && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: p, layoutId: w } = this.options;
      if (!(!this.layout || !(p || w))) {
        if (this.resolvedRelativeTargetAt = Fn.timestamp, !this.targetDelta && !this.relativeTarget) {
          const _ = this.getClosestProjectingParent();
          _ && _.layout && this.animationProgress !== 1 ? (this.relativeParent = _, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ln(), this.relativeTargetOrigin = ln(), il(this.relativeTargetOrigin, this.layout.layoutBox, _.layout.layoutBox), Xi(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = ln(), this.targetWithTransforms = ln()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), vte(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Xi(this.target, this.layout.layoutBox), v9(this.target, this.targetDelta)) : Xi(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const _ = this.getClosestProjectingParent();
            _ && !!_.resumingFrom == !!this.resumingFrom && !_.options.layoutScroll && _.target && this.animationProgress !== 1 ? (this.relativeParent = _, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ln(), this.relativeTargetOrigin = ln(), il(this.relativeTargetOrigin, this.target, _.target), Xi(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          Gf && rc.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || Sv(this.parent.latestValues) || m9(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var o;
      const a = this.getLead(), u = !!this.resumingFrom || this !== a;
      let l = !0;
      if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (l = !1), u && (this.isSharedProjectionDirty || this.isTransformDirty) && (l = !1), this.resolvedRelativeTargetAt === Fn.timestamp && (l = !1), l)
        return;
      const { layout: d, layoutId: p } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(d || p))
        return;
      Xi(this.layoutCorrected, this.layout.layoutBox);
      const w = this.treeScale.x, _ = this.treeScale.y;
      Pte(this.layoutCorrected, this.treeScale, this.path, u), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = ln());
      const { target: P } = a;
      if (!P) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (e5(this.prevProjectionDelta.x, this.projectionDelta.x), e5(this.prevProjectionDelta.y, this.projectionDelta.y)), nl(this.projectionDelta, this.layoutCorrected, P, this.latestValues), (this.treeScale.x !== w || this.treeScale.y !== _ || !c5(this.projectionDelta.x, this.prevProjectionDelta.x) || !c5(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", P)), Gf && rc.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(o = !0) {
      var a;
      if ((a = this.options.visualElement) === null || a === void 0 || a.scheduleRender(), o) {
        const u = this.getStack();
        u && u.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = hu(), this.projectionDelta = hu(), this.projectionDeltaWithTransform = hu();
    }
    setAnimationOrigin(o, a = !1) {
      const u = this.snapshot, l = u ? u.latestValues : {}, d = { ...this.latestValues }, p = hu();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
      const w = ln(), _ = u ? u.source : void 0, P = this.layout ? this.layout.source : void 0, O = _ !== P, L = this.getStack(), B = !L || L.members.length <= 1, k = !!(O && !B && this.options.crossfade === !0 && !this.path.some(dre));
      this.animationProgress = 0;
      let q;
      this.mixTargetDelta = (U) => {
        const V = U / 1e3;
        h5(p.x, o.x, V), h5(p.y, o.y, V), this.setTargetDelta(p), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (il(w, this.layout.layoutBox, this.relativeParent.layout.layoutBox), hre(this.relativeTarget, this.relativeTargetOrigin, w, V), q && Hte(this.relativeTarget, q) && (this.isProjectionDirty = !1), q || (q = ln()), Xi(q, this.relativeTarget)), O && (this.animationValues = d, Fte(d, l, this.latestValues, V, k, B)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = V;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(o) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (Pa(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Lr.update(() => {
        Zd.hasAnimatedSinceResize = !0, this.currentAnimation = Zte(0, u5, {
          ...o,
          onUpdate: (a) => {
            this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a);
          },
          onComplete: () => {
            o.onComplete && o.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const o = this.getStack();
      o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(u5), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const o = this.getLead();
      let { targetWithTransforms: a, target: u, layout: l, latestValues: d } = o;
      if (!(!a || !u || !l)) {
        if (this !== o && this.layout && l && I9(this.options.animationType, this.layout.layoutBox, l.layoutBox)) {
          u = this.target || ln();
          const p = ki(this.layout.layoutBox.x);
          u.x.min = o.target.x.min, u.x.max = u.x.min + p;
          const w = ki(this.layout.layoutBox.y);
          u.y.min = o.target.y.min, u.y.max = u.y.min + w;
        }
        Xi(a, u), pu(a, d), nl(this.projectionDeltaWithTransform, this.layoutCorrected, a, d);
      }
    }
    registerSharedNode(o, a) {
      this.sharedNodes.has(o) || this.sharedNodes.set(o, new Kte()), this.sharedNodes.get(o).add(a);
      const l = a.options.initialPromotionConfig;
      a.promote({
        transition: l ? l.transition : void 0,
        preserveFollowOpacity: l && l.shouldPreserveFollowOpacity ? l.shouldPreserveFollowOpacity(a) : void 0
      });
    }
    isLead() {
      const o = this.getStack();
      return o ? o.lead === this : !0;
    }
    getLead() {
      var o;
      const { layoutId: a } = this.options;
      return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this;
    }
    getPrevLead() {
      var o;
      const { layoutId: a } = this.options;
      return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0;
    }
    getStack() {
      const { layoutId: o } = this.options;
      if (o)
        return this.root.sharedNodes.get(o);
    }
    promote({ needsReset: o, transition: a, preserveFollowOpacity: u } = {}) {
      const l = this.getStack();
      l && l.promote(this, u), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a });
    }
    relegate() {
      const o = this.getStack();
      return o ? o.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: o } = this.options;
      if (!o)
        return;
      let a = !1;
      const { latestValues: u } = o;
      if ((u.z || u.rotate || u.rotateX || u.rotateY || u.rotateZ || u.skewX || u.skewY) && (a = !0), !a)
        return;
      const l = {};
      u.z && t1("z", o, l, this.animationValues);
      for (let d = 0; d < e1.length; d++)
        t1(`rotate${e1[d]}`, o, l, this.animationValues), t1(`skew${e1[d]}`, o, l, this.animationValues);
      o.render();
      for (const d in l)
        o.setStaticValue(d, l[d]), this.animationValues && (this.animationValues[d] = l[d]);
      o.scheduleRender();
    }
    getProjectionStyles(o) {
      var a, u;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return Qte;
      const l = {
        visibility: ""
      }, d = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, l.opacity = "", l.pointerEvents = Qd(o == null ? void 0 : o.pointerEvents) || "", l.transform = d ? d(this.latestValues, "") : "none", l;
      const p = this.getLead();
      if (!this.projectionDelta || !this.layout || !p.target) {
        const O = {};
        return this.options.layoutId && (O.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, O.pointerEvents = Qd(o == null ? void 0 : o.pointerEvents) || ""), this.hasProjected && !tc(this.latestValues) && (O.transform = d ? d({}, "") : "none", this.hasProjected = !1), O;
      }
      const w = p.animationValues || p.latestValues;
      this.applyTransformsToTarget(), l.transform = Vte(this.projectionDeltaWithTransform, this.treeScale, w), d && (l.transform = d(w, l.transform));
      const { x: _, y: P } = this.projectionDelta;
      l.transformOrigin = `${_.origin * 100}% ${P.origin * 100}% 0`, p.animationValues ? l.opacity = p === this ? (u = (a = w.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && u !== void 0 ? u : 1 : this.preserveOpacity ? this.latestValues.opacity : w.opacityExit : l.opacity = p === this ? w.opacity !== void 0 ? w.opacity : "" : w.opacityExit !== void 0 ? w.opacityExit : 0;
      for (const O in N0) {
        if (w[O] === void 0)
          continue;
        const { correct: L, applyTo: B } = N0[O], k = l.transform === "none" ? w[O] : L(w[O], p);
        if (B) {
          const q = B.length;
          for (let U = 0; U < q; U++)
            l[B[U]] = k;
        } else
          l[O] = k;
      }
      return this.options.layoutId && (l.pointerEvents = p === this ? Qd(o == null ? void 0 : o.pointerEvents) || "" : "none"), l;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((o) => {
        var a;
        return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop();
      }), this.root.nodes.forEach(f5), this.root.sharedNodes.clear();
    }
  };
}
function tre(t) {
  t.updateLayout();
}
function rre(t) {
  var e;
  const r = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot;
  if (t.isLead() && t.layout && r && t.hasListeners("didUpdate")) {
    const { layoutBox: n, measuredBox: i } = t.layout, { animationType: s } = t.options, o = r.source !== t.layout.source;
    s === "size" ? Qi((p) => {
      const w = o ? r.measuredBox[p] : r.layoutBox[p], _ = ki(w);
      w.min = n[p].min, w.max = w.min + _;
    }) : I9(s, r.layoutBox, n) && Qi((p) => {
      const w = o ? r.measuredBox[p] : r.layoutBox[p], _ = ki(n[p]);
      w.max = w.min + _, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[p].max = t.relativeTarget[p].min + _);
    });
    const a = hu();
    nl(a, n, r.layoutBox);
    const u = hu();
    o ? nl(u, t.applyTransform(i, !0), r.measuredBox) : nl(u, n, r.layoutBox);
    const l = !S9(a);
    let d = !1;
    if (!t.resumeFrom) {
      const p = t.getClosestProjectingParent();
      if (p && !p.resumeFrom) {
        const { snapshot: w, layout: _ } = p;
        if (w && _) {
          const P = ln();
          il(P, r.layoutBox, w.layoutBox);
          const O = ln();
          il(O, n, _.layoutBox), A9(P, O) || (d = !0), p.options.layoutRoot && (t.relativeTarget = O, t.relativeTargetOrigin = P, t.relativeParent = p);
        }
      }
    }
    t.notifyListeners("didUpdate", {
      layout: n,
      snapshot: r,
      delta: u,
      layoutDelta: a,
      hasLayoutChanged: l,
      hasRelativeTargetChanged: d
    });
  } else if (t.isLead()) {
    const { onExitComplete: n } = t.options;
    n && n();
  }
  t.options.transition = void 0;
}
function nre(t) {
  Gf && rc.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty));
}
function ire(t) {
  t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1;
}
function sre(t) {
  t.clearSnapshot();
}
function f5(t) {
  t.clearMeasurements();
}
function ore(t) {
  t.isLayoutDirty = !1;
}
function are(t) {
  const { visualElement: e } = t.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform();
}
function l5(t) {
  t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0;
}
function cre(t) {
  t.resolveTargetDelta();
}
function ure(t) {
  t.calcProjection();
}
function fre(t) {
  t.resetSkewAndRotation();
}
function lre(t) {
  t.removeLeadSnapshot();
}
function h5(t, e, r) {
  t.translate = Qr(e.translate, 0, r), t.scale = Qr(e.scale, 1, r), t.origin = e.origin, t.originPoint = e.originPoint;
}
function d5(t, e, r, n) {
  t.min = Qr(e.min, r.min, n), t.max = Qr(e.max, r.max, n);
}
function hre(t, e, r, n) {
  d5(t.x, e.x, r.x, n), d5(t.y, e.y, r.y, n);
}
function dre(t) {
  return t.animationValues && t.animationValues.opacityExit !== void 0;
}
const pre = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, p5 = (t) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), g5 = p5("applewebkit/") && !p5("chrome/") ? Math.round : Un;
function m5(t) {
  t.min = g5(t.min), t.max = g5(t.max);
}
function gre(t) {
  m5(t.x), m5(t.y);
}
function I9(t, e, r) {
  return t === "position" || t === "preserve-aspect" && !mte(a5(e), a5(r), 0.2);
}
function mre(t) {
  var e;
  return t !== t.root && ((e = t.scroll) === null || e === void 0 ? void 0 : e.wasRoot);
}
const vre = M9({
  attachResizeListener: (t, e) => Ro(t, "resize", e),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), r1 = {
  current: void 0
}, C9 = M9({
  measureScroll: (t) => ({
    x: t.scrollLeft,
    y: t.scrollTop
  }),
  defaultParent: () => {
    if (!r1.current) {
      const t = new vre({});
      t.mount(window), t.setOptions({ layoutScroll: !0 }), r1.current = t;
    }
    return r1.current;
  },
  resetTransform: (t, e) => {
    t.style.transform = e !== void 0 ? e : "none";
  },
  checkIsScrollRoot: (t) => window.getComputedStyle(t).position === "fixed"
}), bre = {
  pan: {
    Feature: Dte
  },
  drag: {
    Feature: Rte,
    ProjectionNode: C9,
    MeasureLayout: x9
  }
};
function v5(t, e) {
  const r = e ? "pointerenter" : "pointerleave", n = e ? "onHoverStart" : "onHoverEnd", i = (s, o) => {
    if (s.pointerType === "touch" || h9())
      return;
    const a = t.getProps();
    t.animationState && a.whileHover && t.animationState.setActive("whileHover", e);
    const u = a[n];
    u && Lr.postRender(() => u(s, o));
  };
  return ko(t.current, r, i, {
    passive: !t.getProps()[n]
  });
}
class yre extends $a {
  mount() {
    this.unmount = Lo(v5(this.node, !0), v5(this.node, !1));
  }
  unmount() {
  }
}
class wre extends $a {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Lo(Ro(this.node.current, "focus", () => this.onFocus()), Ro(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const T9 = (t, e) => e ? t === e ? !0 : T9(t, e.parentElement) : !1;
function n1(t, e) {
  if (!e)
    return;
  const r = new PointerEvent("pointer" + t);
  e(r, Lp(r));
}
class xre extends $a {
  constructor() {
    super(...arguments), this.removeStartListeners = Un, this.removeEndListeners = Un, this.removeAccessibleListeners = Un, this.startPointerPress = (e, r) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const n = this.node.getProps(), s = ko(window, "pointerup", (a, u) => {
        if (!this.checkPressEnd())
          return;
        const { onTap: l, onTapCancel: d, globalTapTarget: p } = this.node.getProps(), w = !p && !T9(this.node.current, a.target) ? d : l;
        w && Lr.update(() => w(a, u));
      }, {
        passive: !(n.onTap || n.onPointerUp)
      }), o = ko(window, "pointercancel", (a, u) => this.cancelPress(a, u), {
        passive: !(n.onTapCancel || n.onPointerCancel)
      });
      this.removeEndListeners = Lo(s, o), this.startPress(e, r);
    }, this.startAccessiblePress = () => {
      const e = (s) => {
        if (s.key !== "Enter" || this.isPressing)
          return;
        const o = (a) => {
          a.key !== "Enter" || !this.checkPressEnd() || n1("up", (u, l) => {
            const { onTap: d } = this.node.getProps();
            d && Lr.postRender(() => d(u, l));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = Ro(this.node.current, "keyup", o), n1("down", (a, u) => {
          this.startPress(a, u);
        });
      }, r = Ro(this.node.current, "keydown", e), n = () => {
        this.isPressing && n1("cancel", (s, o) => this.cancelPress(s, o));
      }, i = Ro(this.node.current, "blur", n);
      this.removeAccessibleListeners = Lo(r, i);
    };
  }
  startPress(e, r) {
    this.isPressing = !0;
    const { onTapStart: n, whileTap: i } = this.node.getProps();
    i && this.node.animationState && this.node.animationState.setActive("whileTap", !0), n && Lr.postRender(() => n(e, r));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !h9();
  }
  cancelPress(e, r) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel: n } = this.node.getProps();
    n && Lr.postRender(() => n(e, r));
  }
  mount() {
    const e = this.node.getProps(), r = ko(e.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
      passive: !(e.onTapStart || e.onPointerStart)
    }), n = Ro(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = Lo(r, n);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const Pv = /* @__PURE__ */ new WeakMap(), i1 = /* @__PURE__ */ new WeakMap(), _re = (t) => {
  const e = Pv.get(t.target);
  e && e(t);
}, Ere = (t) => {
  t.forEach(_re);
};
function Sre({ root: t, ...e }) {
  const r = t || document;
  i1.has(r) || i1.set(r, {});
  const n = i1.get(r), i = JSON.stringify(e);
  return n[i] || (n[i] = new IntersectionObserver(Ere, { root: t, ...e })), n[i];
}
function Are(t, e, r) {
  const n = Sre(e);
  return Pv.set(t, r), n.observe(t), () => {
    Pv.delete(t), n.unobserve(t);
  };
}
const Pre = {
  some: 0,
  all: 1
};
class Mre extends $a {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(), { root: r, margin: n, amount: i = "some", once: s } = e, o = {
      root: r ? r.current : void 0,
      rootMargin: n,
      threshold: typeof i == "number" ? i : Pre[i]
    }, a = (u) => {
      const { isIntersecting: l } = u;
      if (this.isInView === l || (this.isInView = l, s && !l && this.hasEnteredView))
        return;
      l && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", l);
      const { onViewportEnter: d, onViewportLeave: p } = this.node.getProps(), w = l ? d : p;
      w && w(u);
    };
    return Are(this.node.current, o, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: e, prevProps: r } = this.node;
    ["amount", "margin", "root"].some(Ire(e, r)) && this.startObserver();
  }
  unmount() {
  }
}
function Ire({ viewport: t = {} }, { viewport: e = {} } = {}) {
  return (r) => t[r] !== e[r];
}
const Cre = {
  inView: {
    Feature: Mre
  },
  tap: {
    Feature: xre
  },
  focus: {
    Feature: wre
  },
  hover: {
    Feature: yre
  }
}, Tre = {
  layout: {
    ProjectionNode: C9,
    MeasureLayout: x9
  }
}, hy = Ta({
  transformPagePoint: (t) => t,
  isStatic: !1,
  reducedMotion: "never"
}), $p = Ta({}), dy = typeof window < "u", R9 = dy ? lD : Dn, D9 = Ta({ strict: !1 });
function Rre(t, e, r, n, i) {
  var s, o;
  const { visualElement: a } = Tn($p), u = Tn(D9), l = Tn(kp), d = Tn(hy).reducedMotion, p = Qn();
  n = n || u.renderer, !p.current && n && (p.current = n(t, {
    visualState: e,
    parent: a,
    props: r,
    presenceContext: l,
    blockInitialAnimation: l ? l.initial === !1 : !1,
    reducedMotionConfig: d
  }));
  const w = p.current, _ = Tn(w9);
  w && !w.projection && i && (w.type === "html" || w.type === "svg") && Dre(p.current, r, i, _);
  const P = Qn(!1);
  L5(() => {
    w && P.current && w.update(r, l);
  });
  const O = r[n9], L = Qn(!!O && !(!((s = window.MotionHandoffIsComplete) === null || s === void 0) && s.call(window, O)) && ((o = window.MotionHasOptimisedAnimation) === null || o === void 0 ? void 0 : o.call(window, O)));
  return R9(() => {
    w && (P.current = !0, window.MotionIsMounted = !0, w.updateFeatures(), ly.render(w.render), L.current && w.animationState && w.animationState.animateChanges());
  }), Dn(() => {
    w && (!L.current && w.animationState && w.animationState.animateChanges(), L.current && (queueMicrotask(() => {
      var B;
      (B = window.MotionHandoffMarkAsComplete) === null || B === void 0 || B.call(window, O);
    }), L.current = !1));
  }), w;
}
function Dre(t, e, r, n) {
  const { layoutId: i, layout: s, drag: o, dragConstraints: a, layoutScroll: u, layoutRoot: l } = e;
  t.projection = new r(t.latestValues, e["data-framer-portal-id"] ? void 0 : O9(t.parent)), t.projection.setOptions({
    layoutId: i,
    layout: s,
    alwaysMeasureLayout: !!o || a && lu(a),
    visualElement: t,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof s == "string" ? s : "both",
    initialPromotionConfig: n,
    layoutScroll: u,
    layoutRoot: l
  });
}
function O9(t) {
  if (t)
    return t.options.allowProjection !== !1 ? t.projection : O9(t.parent);
}
function Ore(t, e, r) {
  return Nv(
    (n) => {
      n && t.mount && t.mount(n), e && (n ? e.mount(n) : e.unmount()), r && (typeof r == "function" ? r(n) : lu(r) && (r.current = n));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [e]
  );
}
function Bp(t) {
  return Dp(t.animate) || Wb.some((e) => Fl(t[e]));
}
function N9(t) {
  return !!(Bp(t) || t.variants);
}
function Nre(t, e) {
  if (Bp(t)) {
    const { initial: r, animate: n } = t;
    return {
      initial: r === !1 || Fl(r) ? r : void 0,
      animate: Fl(n) ? n : void 0
    };
  }
  return t.inherit !== !1 ? e : {};
}
function Lre(t) {
  const { initial: e, animate: r } = Nre(t, Tn($p));
  return wi(() => ({ initial: e, animate: r }), [b5(e), b5(r)]);
}
function b5(t) {
  return Array.isArray(t) ? t.join(" ") : t;
}
const y5 = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, Bu = {};
for (const t in y5)
  Bu[t] = {
    isEnabled: (e) => y5[t].some((r) => !!e[r])
  };
function kre(t) {
  for (const e in t)
    Bu[e] = {
      ...Bu[e],
      ...t[e]
    };
}
const $re = Symbol.for("motionComponentSymbol");
function Bre({ preloadedFeatures: t, createVisualElement: e, useRender: r, useVisualState: n, Component: i }) {
  t && kre(t);
  function s(a, u) {
    let l;
    const d = {
      ...Tn(hy),
      ...a,
      layoutId: Fre(a)
    }, { isStatic: p } = d, w = Lre(a), _ = n(a, p);
    if (!p && dy) {
      jre(d, t);
      const P = Ure(d);
      l = P.MeasureLayout, w.visualElement = Rre(i, _, d, e, P.ProjectionNode);
    }
    return le.jsxs($p.Provider, { value: w, children: [l && w.visualElement ? le.jsx(l, { visualElement: w.visualElement, ...d }) : null, r(i, a, Ore(_, w.visualElement, u), _, p, w.visualElement)] });
  }
  const o = Dv(s);
  return o[$re] = i, o;
}
function Fre({ layoutId: t }) {
  const e = Tn(fy).id;
  return e && t !== void 0 ? e + "-" + t : t;
}
function jre(t, e) {
  const r = Tn(D9).strict;
  if (process.env.NODE_ENV !== "production" && e && r) {
    const n = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    t.ignoreStrict ? Qu(!1, n) : Wo(!1, n);
  }
}
function Ure(t) {
  const { drag: e, layout: r } = Bu;
  if (!e && !r)
    return {};
  const n = { ...e, ...r };
  return {
    MeasureLayout: e != null && e.isEnabled(t) || r != null && r.isEnabled(t) ? n.MeasureLayout : void 0,
    ProjectionNode: n.ProjectionNode
  };
}
const qre = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function py(t) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof t != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    t.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(qre.indexOf(t) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(t))
    )
  );
}
function L9(t, { style: e, vars: r }, n, i) {
  Object.assign(t.style, e, i && i.getProjectionStyles(n));
  for (const s in r)
    t.style.setProperty(s, r[s]);
}
const k9 = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function $9(t, e, r, n) {
  L9(t, e, void 0, n);
  for (const i in e.attrs)
    t.setAttribute(k9.has(i) ? i : uy(i), e.attrs[i]);
}
function B9(t, { layout: e, layoutId: r }) {
  return Lc.has(t) || t.startsWith("origin") || (e || r !== void 0) && (!!N0[t] || t === "opacity");
}
function gy(t, e, r) {
  var n;
  const { style: i } = t, s = {};
  for (const o in i)
    (Zn(i[o]) || e.style && Zn(e.style[o]) || B9(o, t) || ((n = r == null ? void 0 : r.getValue(o)) === null || n === void 0 ? void 0 : n.liveStyle) !== void 0) && (s[o] = i[o]);
  return s;
}
function F9(t, e, r) {
  const n = gy(t, e, r);
  for (const i in t)
    if (Zn(t[i]) || Zn(e[i])) {
      const s = mh.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
      n[s] = t[i];
    }
  return n;
}
function my(t) {
  const e = Qn(null);
  return e.current === null && (e.current = t()), e.current;
}
function zre({ scrapeMotionValuesFromProps: t, createRenderState: e, onMount: r }, n, i, s) {
  const o = {
    latestValues: Wre(n, i, s, t),
    renderState: e()
  };
  return r && (o.mount = (a) => r(n, a, o)), o;
}
const j9 = (t) => (e, r) => {
  const n = Tn($p), i = Tn(kp), s = () => zre(t, e, n, i);
  return r ? s() : my(s);
};
function Wre(t, e, r, n) {
  const i = {}, s = n(t, {});
  for (const w in s)
    i[w] = Qd(s[w]);
  let { initial: o, animate: a } = t;
  const u = Bp(t), l = N9(t);
  e && l && !u && t.inherit !== !1 && (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate));
  let d = r ? r.initial === !1 : !1;
  d = d || o === !1;
  const p = d ? a : o;
  if (p && typeof p != "boolean" && !Dp(p)) {
    const w = Array.isArray(p) ? p : [p];
    for (let _ = 0; _ < w.length; _++) {
      const P = qb(t, w[_]);
      if (P) {
        const { transitionEnd: O, transition: L, ...B } = P;
        for (const k in B) {
          let q = B[k];
          if (Array.isArray(q)) {
            const U = d ? q.length - 1 : 0;
            q = q[U];
          }
          q !== null && (i[k] = q);
        }
        for (const k in O)
          i[k] = O[k];
      }
    }
  }
  return i;
}
const vy = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
}), U9 = () => ({
  ...vy(),
  attrs: {}
}), q9 = (t, e) => e && typeof t == "number" ? e.transform(t) : t, Hre = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, Kre = mh.length;
function Vre(t, e, r) {
  let n = "", i = !0;
  for (let s = 0; s < Kre; s++) {
    const o = mh[s], a = t[o];
    if (a === void 0)
      continue;
    let u = !0;
    if (typeof a == "number" ? u = a === (o.startsWith("scale") ? 1 : 0) : u = parseFloat(a) === 0, !u || r) {
      const l = q9(a, Zb[o]);
      if (!u) {
        i = !1;
        const d = Hre[o] || o;
        n += `${d}(${l}) `;
      }
      r && (e[o] = l);
    }
  }
  return n = n.trim(), r ? n = r(e, i ? "" : n) : i && (n = "none"), n;
}
function by(t, e, r) {
  const { style: n, vars: i, transformOrigin: s } = t;
  let o = !1, a = !1;
  for (const u in e) {
    const l = e[u];
    if (Lc.has(u)) {
      o = !0;
      continue;
    } else if (N7(u)) {
      i[u] = l;
      continue;
    } else {
      const d = q9(l, Zb[u]);
      u.startsWith("origin") ? (a = !0, s[u] = d) : n[u] = d;
    }
  }
  if (e.transform || (o || r ? n.transform = Vre(e, t.transform, r) : n.transform && (n.transform = "none")), a) {
    const { originX: u = "50%", originY: l = "50%", originZ: d = 0 } = s;
    n.transformOrigin = `${u} ${l} ${d}`;
  }
}
function w5(t, e, r) {
  return typeof t == "string" ? t : Vt.transform(e + r * t);
}
function Gre(t, e, r) {
  const n = w5(e, t.x, t.width), i = w5(r, t.y, t.height);
  return `${n} ${i}`;
}
const Yre = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, Jre = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function Xre(t, e, r = 1, n = 0, i = !0) {
  t.pathLength = 1;
  const s = i ? Yre : Jre;
  t[s.offset] = Vt.transform(-n);
  const o = Vt.transform(e), a = Vt.transform(r);
  t[s.array] = `${o} ${a}`;
}
function yy(t, {
  attrX: e,
  attrY: r,
  attrScale: n,
  originX: i,
  originY: s,
  pathLength: o,
  pathSpacing: a = 1,
  pathOffset: u = 0,
  // This is object creation, which we try to avoid per-frame.
  ...l
}, d, p) {
  if (by(t, l, p), d) {
    t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
    return;
  }
  t.attrs = t.style, t.style = {};
  const { attrs: w, style: _, dimensions: P } = t;
  w.transform && (P && (_.transform = w.transform), delete w.transform), P && (i !== void 0 || s !== void 0 || _.transform) && (_.transformOrigin = Gre(P, i !== void 0 ? i : 0.5, s !== void 0 ? s : 0.5)), e !== void 0 && (w.x = e), r !== void 0 && (w.y = r), n !== void 0 && (w.scale = n), o !== void 0 && Xre(w, o, a, u, !1);
}
const wy = (t) => typeof t == "string" && t.toLowerCase() === "svg", Zre = {
  useVisualState: j9({
    scrapeMotionValuesFromProps: F9,
    createRenderState: U9,
    onMount: (t, e, { renderState: r, latestValues: n }) => {
      Lr.read(() => {
        try {
          r.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect();
        } catch {
          r.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      }), Lr.render(() => {
        yy(r, n, wy(e.tagName), t.transformTemplate), $9(e, r);
      });
    }
  })
}, Qre = {
  useVisualState: j9({
    scrapeMotionValuesFromProps: gy,
    createRenderState: vy
  })
};
function z9(t, e, r) {
  for (const n in e)
    !Zn(e[n]) && !B9(n, r) && (t[n] = e[n]);
}
function ene({ transformTemplate: t }, e) {
  return wi(() => {
    const r = vy();
    return by(r, e, t), Object.assign({}, r.vars, r.style);
  }, [e]);
}
function tne(t, e) {
  const r = t.style || {}, n = {};
  return z9(n, r, t), Object.assign(n, ene(t, e)), n;
}
function rne(t, e) {
  const r = {}, n = tne(t, e);
  return t.drag && t.dragListener !== !1 && (r.draggable = !1, n.userSelect = n.WebkitUserSelect = n.WebkitTouchCallout = "none", n.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (r.tabIndex = 0), r.style = n, r;
}
const nne = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function L0(t) {
  return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || nne.has(t);
}
let W9 = (t) => !L0(t);
function ine(t) {
  t && (W9 = (e) => e.startsWith("on") ? !L0(e) : t(e));
}
try {
  ine(require("@emotion/is-prop-valid").default);
} catch {
}
function sne(t, e, r) {
  const n = {};
  for (const i in t)
    i === "values" && typeof t.values == "object" || (W9(i) || r === !0 && L0(i) || !e && !L0(i) || // If trying to use native HTML drag events, forward drag listeners
    t.draggable && i.startsWith("onDrag")) && (n[i] = t[i]);
  return n;
}
function one(t, e, r, n) {
  const i = wi(() => {
    const s = U9();
    return yy(s, e, wy(n), t.transformTemplate), {
      ...s.attrs,
      style: { ...s.style }
    };
  }, [e]);
  if (t.style) {
    const s = {};
    z9(s, t.style, t), i.style = { ...s, ...i.style };
  }
  return i;
}
function ane(t = !1) {
  return (r, n, i, { latestValues: s }, o) => {
    const u = (py(r) ? one : rne)(n, s, o, r), l = sne(n, typeof r == "string", t), d = r !== k5 ? { ...l, ...u, ref: i } : {}, { children: p } = n, w = wi(() => Zn(p) ? p.get() : p, [p]);
    return e0(r, {
      ...d,
      children: w
    });
  };
}
function cne(t, e) {
  return function(n, { forwardMotionProps: i } = { forwardMotionProps: !1 }) {
    const o = {
      ...py(n) ? Zre : Qre,
      preloadedFeatures: t,
      useRender: ane(i),
      createVisualElement: e,
      Component: n
    };
    return Bre(o);
  };
}
const Mv = { current: null }, H9 = { current: !1 };
function une() {
  if (H9.current = !0, !!dy)
    if (window.matchMedia) {
      const t = window.matchMedia("(prefers-reduced-motion)"), e = () => Mv.current = t.matches;
      t.addListener(e), e();
    } else
      Mv.current = !1;
}
function fne(t, e, r) {
  for (const n in e) {
    const i = e[n], s = r[n];
    if (Zn(i))
      t.addValue(n, i), process.env.NODE_ENV === "development" && Rp(i.version === "11.11.17", `Attempting to mix Motion versions ${i.version} with 11.11.17 may not work as expected.`);
    else if (Zn(s))
      t.addValue(n, ql(i, { owner: t }));
    else if (s !== i)
      if (t.hasValue(n)) {
        const o = t.getValue(n);
        o.liveStyle === !0 ? o.jump(i) : o.hasAnimated || o.set(i);
      } else {
        const o = t.getStaticValue(n);
        t.addValue(n, ql(o !== void 0 ? o : i, { owner: t }));
      }
  }
  for (const n in r)
    e[n] === void 0 && t.removeValue(n);
  return e;
}
const x5 = /* @__PURE__ */ new WeakMap(), lne = [...$7, Yn, Ia], hne = (t) => lne.find(k7(t)), _5 = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class dne {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(e, r, n) {
    return {};
  }
  constructor({ parent: e, props: r, presenceContext: n, reducedMotionConfig: i, blockInitialAnimation: s, visualState: o }, a = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = Yb, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const w = Zs.now();
      this.renderScheduledAt < w && (this.renderScheduledAt = w, Lr.render(this.render, !1, !0));
    };
    const { latestValues: u, renderState: l } = o;
    this.latestValues = u, this.baseTarget = { ...u }, this.initialValues = r.initial ? { ...u } : {}, this.renderState = l, this.parent = e, this.props = r, this.presenceContext = n, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = i, this.options = a, this.blockInitialAnimation = !!s, this.isControllingVariants = Bp(r), this.isVariantNode = N9(r), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(e && e.current);
    const { willChange: d, ...p } = this.scrapeMotionValuesFromProps(r, {}, this);
    for (const w in p) {
      const _ = p[w];
      u[w] !== void 0 && Zn(_) && _.set(u[w], !1);
    }
  }
  mount(e) {
    this.current = e, x5.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((r, n) => this.bindToMotionValue(n, r)), H9.current || une(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Mv.current, process.env.NODE_ENV !== "production" && Rp(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    x5.delete(this.current), this.projection && this.projection.unmount(), Pa(this.notifyUpdate), Pa(this.render), this.valueSubscriptions.forEach((e) => e()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const e in this.events)
      this.events[e].clear();
    for (const e in this.features) {
      const r = this.features[e];
      r && (r.unmount(), r.isMounted = !1);
    }
    this.current = null;
  }
  bindToMotionValue(e, r) {
    this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
    const n = Lc.has(e), i = r.on("change", (a) => {
      this.latestValues[e] = a, this.props.onUpdate && Lr.preRender(this.notifyUpdate), n && this.projection && (this.projection.isTransformDirty = !0);
    }), s = r.on("renderRequest", this.scheduleRender);
    let o;
    window.MotionCheckAppearSync && (o = window.MotionCheckAppearSync(this, e, r)), this.valueSubscriptions.set(e, () => {
      i(), s(), o && o(), r.owner && r.stop();
    });
  }
  sortNodePosition(e) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current);
  }
  updateFeatures() {
    let e = "animation";
    for (e in Bu) {
      const r = Bu[e];
      if (!r)
        continue;
      const { isEnabled: n, Feature: i } = r;
      if (!this.features[e] && i && n(this.props) && (this.features[e] = new i(this)), this.features[e]) {
        const s = this.features[e];
        s.isMounted ? s.update() : (s.mount(), s.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : ln();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, r) {
    this.latestValues[e] = r;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(e, r) {
    (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = r;
    for (let n = 0; n < _5.length; n++) {
      const i = _5[n];
      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
      const s = "on" + i, o = e[s];
      o && (this.propEventSubscriptions[i] = this.on(i, o));
    }
    this.prevMotionValues = fne(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(e) {
    const r = this.getClosestVariantNode();
    if (r)
      return r.variantChildren && r.variantChildren.add(e), () => r.variantChildren.delete(e);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(e, r) {
    const n = this.values.get(e);
    r !== n && (n && this.removeValue(e), this.bindToMotionValue(e, r), this.values.set(e, r), this.latestValues[e] = r.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(e) {
    this.values.delete(e);
    const r = this.valueSubscriptions.get(e);
    r && (r(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, r) {
    if (this.props.values && this.props.values[e])
      return this.props.values[e];
    let n = this.values.get(e);
    return n === void 0 && r !== void 0 && (n = ql(r === null ? void 0 : r, { owner: this }), this.addValue(e, n)), n;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(e, r) {
    var n;
    let i = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (n = this.getBaseTargetFromProps(this.props, e)) !== null && n !== void 0 ? n : this.readValueFromInstance(this.current, e, this.options);
    return i != null && (typeof i == "string" && (D7(i) || R7(i)) ? i = parseFloat(i) : !hne(i) && Ia.test(r) && (i = H7(e, r)), this.setBaseTarget(e, Zn(i) ? i.get() : i)), Zn(i) ? i.get() : i;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(e, r) {
    this.baseTarget[e] = r;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(e) {
    var r;
    const { initial: n } = this.props;
    let i;
    if (typeof n == "string" || typeof n == "object") {
      const o = qb(this.props, n, (r = this.presenceContext) === null || r === void 0 ? void 0 : r.custom);
      o && (i = o[e]);
    }
    if (n && i !== void 0)
      return i;
    const s = this.getBaseTargetFromProps(this.props, e);
    return s !== void 0 && !Zn(s) ? s : this.initialValues[e] !== void 0 && i === void 0 ? void 0 : this.baseTarget[e];
  }
  on(e, r) {
    return this.events[e] || (this.events[e] = new cy()), this.events[e].add(r);
  }
  notify(e, ...r) {
    this.events[e] && this.events[e].notify(...r);
  }
}
class K9 extends dne {
  constructor() {
    super(...arguments), this.KeyframeResolver = K7;
  }
  sortInstanceNodePosition(e, r) {
    return e.compareDocumentPosition(r) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, r) {
    return e.style ? e.style[r] : void 0;
  }
  removeValueFromRenderState(e, { vars: r, style: n }) {
    delete r[e], delete n[e];
  }
}
function pne(t) {
  return window.getComputedStyle(t);
}
class gne extends K9 {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = L9;
  }
  readValueFromInstance(e, r) {
    if (Lc.has(r)) {
      const n = Qb(r);
      return n && n.default || 0;
    } else {
      const n = pne(e), i = (N7(r) ? n.getPropertyValue(r) : n[r]) || 0;
      return typeof i == "string" ? i.trim() : i;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: r }) {
    return b9(e, r);
  }
  build(e, r, n) {
    by(e, r, n.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, r, n) {
    return gy(e, r, n);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    Zn(e) && (this.childSubscription = e.on("change", (r) => {
      this.current && (this.current.textContent = `${r}`);
    }));
  }
}
class mne extends K9 {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = ln;
  }
  getBaseTargetFromProps(e, r) {
    return e[r];
  }
  readValueFromInstance(e, r) {
    if (Lc.has(r)) {
      const n = Qb(r);
      return n && n.default || 0;
    }
    return r = k9.has(r) ? r : uy(r), e.getAttribute(r);
  }
  scrapeMotionValuesFromProps(e, r, n) {
    return F9(e, r, n);
  }
  build(e, r, n) {
    yy(e, r, this.isSVGTag, n.transformTemplate);
  }
  renderInstance(e, r, n, i) {
    $9(e, r, n, i);
  }
  mount(e) {
    this.isSVGTag = wy(e.tagName), super.mount(e);
  }
}
const vne = (t, e) => py(t) ? new mne(e) : new gne(e, {
  allowProjection: t !== k5
}), bne = /* @__PURE__ */ cne({
  ...ate,
  ...Cre,
  ...bre,
  ...Tre
}, vne), yne = /* @__PURE__ */ ZZ(bne);
class wne extends Gt.Component {
  getSnapshotBeforeUpdate(e) {
    const r = this.props.childRef.current;
    if (r && e.isPresent && !this.props.isPresent) {
      const n = this.props.sizeRef.current;
      n.height = r.offsetHeight || 0, n.width = r.offsetWidth || 0, n.top = r.offsetTop, n.left = r.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function xne({ children: t, isPresent: e }) {
  const r = Ov(), n = Qn(null), i = Qn({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), { nonce: s } = Tn(hy);
  return L5(() => {
    const { width: o, height: a, top: u, left: l } = i.current;
    if (e || !n.current || !o || !a)
      return;
    n.current.dataset.motionPopId = r;
    const d = document.createElement("style");
    return s && (d.nonce = s), document.head.appendChild(d), d.sheet && d.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${o}px !important;
            height: ${a}px !important;
            top: ${u}px !important;
            left: ${l}px !important;
          }
        `), () => {
      document.head.removeChild(d);
    };
  }, [e]), le.jsx(wne, { isPresent: e, childRef: n, sizeRef: i, children: Gt.cloneElement(t, { ref: n }) });
}
const _ne = ({ children: t, initial: e, isPresent: r, onExitComplete: n, custom: i, presenceAffectsLayout: s, mode: o }) => {
  const a = my(Ene), u = Ov(), l = Nv((p) => {
    a.set(p, !0);
    for (const w of a.values())
      if (!w)
        return;
    n && n();
  }, [a, n]), d = wi(
    () => ({
      id: u,
      initial: e,
      isPresent: r,
      custom: i,
      onExitComplete: l,
      register: (p) => (a.set(p, !1), () => a.delete(p))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    s ? [Math.random(), l] : [r, l]
  );
  return wi(() => {
    a.forEach((p, w) => a.set(w, !1));
  }, [r]), Gt.useEffect(() => {
    !r && !a.size && n && n();
  }, [r]), o === "popLayout" && (t = le.jsx(xne, { isPresent: r, children: t })), le.jsx(kp.Provider, { value: d, children: t });
};
function Ene() {
  return /* @__PURE__ */ new Map();
}
const Cd = (t) => t.key || "";
function E5(t) {
  const e = [];
  return hD.forEach(t, (r) => {
    dD(r) && e.push(r);
  }), e;
}
const Sne = ({ children: t, exitBeforeEnter: e, custom: r, initial: n = !0, onExitComplete: i, presenceAffectsLayout: s = !0, mode: o = "sync" }) => {
  Wo(!e, "Replace exitBeforeEnter with mode='wait'");
  const a = wi(() => E5(t), [t]), u = a.map(Cd), l = Qn(!0), d = Qn(a), p = my(() => /* @__PURE__ */ new Map()), [w, _] = Yt(a), [P, O] = Yt(a);
  R9(() => {
    l.current = !1, d.current = a;
    for (let k = 0; k < P.length; k++) {
      const q = Cd(P[k]);
      u.includes(q) ? p.delete(q) : p.get(q) !== !0 && p.set(q, !1);
    }
  }, [P, u.length, u.join("-")]);
  const L = [];
  if (a !== w) {
    let k = [...a];
    for (let q = 0; q < P.length; q++) {
      const U = P[q], V = Cd(U);
      u.includes(V) || (k.splice(q, 0, U), L.push(U));
    }
    o === "wait" && L.length && (k = L), O(E5(k)), _(a);
    return;
  }
  process.env.NODE_ENV !== "production" && o === "wait" && P.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
  const { forceRender: B } = Tn(fy);
  return le.jsx(le.Fragment, { children: P.map((k) => {
    const q = Cd(k), U = a === P || u.includes(q), V = () => {
      if (p.has(q))
        p.set(q, !0);
      else
        return;
      let Q = !0;
      p.forEach((R) => {
        R || (Q = !1);
      }), Q && (B == null || B(), O(d.current), i && i());
    };
    return le.jsx(_ne, { isPresent: U, initial: !l.current || n ? void 0 : !1, custom: U ? void 0 : r, presenceAffectsLayout: s, mode: o, onExitComplete: U ? void 0 : V, children: k }, q);
  }) });
}, Rs = (t) => /* @__PURE__ */ le.jsx(Sne, { children: /* @__PURE__ */ le.jsx(
  yne.div,
  {
    initial: { x: 0, opacity: 0 },
    animate: { x: 0, opacity: 1 },
    exit: { x: 30, opacity: 0 },
    transition: { duration: 0.3 },
    className: t.className,
    children: t.children
  }
) });
function xy(t) {
  const { icon: e, title: r, extra: n, onClick: i } = t;
  function s() {
    i && i();
  }
  return /* @__PURE__ */ le.jsxs(
    "div",
    {
      className: "xc-rounded-lg xc-group xc-flex xc-cursor-pointer xc-items-center xc-gap-2 xc-border xc-border-white xc-border-opacity-15 xc-px-4 xc-py-2 xc-transition-all hover:xc-shadow-lg",
      onClick: s,
      children: [
        e,
        r,
        /* @__PURE__ */ le.jsxs("div", { className: "xc-relative xc-ml-auto xc-h-6", children: [
          /* @__PURE__ */ le.jsx("div", { className: "xc-relative xc-left-0 xc-opacity-100 xc-transition-all group-hover:xc-left-2 group-hover:xc-opacity-0", children: n }),
          /* @__PURE__ */ le.jsx("div", { className: "xc-absolute xc-right-2 xc-top-0 xc-text-gray-400 xc-opacity-0 xc-transition-all group-hover:xc-right-0 group-hover:xc-opacity-100", children: /* @__PURE__ */ le.jsx(HZ, {}) })
        ] })
      ]
    }
  );
}
function Ane(t) {
  return t.lastUsed ? /* @__PURE__ */ le.jsxs("div", { className: "xc-flex xc-items-center xc-gap-2 xc-rounded-full xc-py-1 xc-text-xs xc-text-gray-500", children: [
    /* @__PURE__ */ le.jsx("div", { className: "xc-h-1 xc-w-1 xc-rounded-full xc-bg-[#009E8C]" }),
    "Last Used"
  ] }) : t.installed ? /* @__PURE__ */ le.jsxs("div", { className: "xc-flex xc-items-center xc-gap-2 xc-rounded-full xc-py-1 xc-text-xs xc-text-gray-500", children: [
    /* @__PURE__ */ le.jsx("div", { className: "xc-h-1 xc-w-1 xc-rounded-full xc-bg-[#2596FF]" }),
    "Installed"
  ] }) : null;
}
function V9(t) {
  var o, a;
  const { wallet: e, onClick: r } = t, n = /* @__PURE__ */ le.jsx("img", { className: "xc-rounded-md xc-h-5 xc-w-5", src: (o = e.config) == null ? void 0 : o.image }), i = ((a = e.config) == null ? void 0 : a.name) || "", s = wi(() => Ane(e), [e]);
  return /* @__PURE__ */ le.jsx(xy, { icon: n, title: i, extra: s, onClick: () => r(e) });
}
function G9(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number") n += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var i = t.length;
    for (e = 0; e < i; e++) t[e] && (r = G9(t[e])) && (n && (n += " "), n += r);
  } else for (r in t) t[r] && (n && (n += " "), n += r);
  return n;
}
function Pne() {
  for (var t, e, r = 0, n = "", i = arguments.length; r < i; r++) (t = arguments[r]) && (e = G9(t)) && (n && (n += " "), n += e);
  return n;
}
const Mne = Pne, _y = "-", Ine = (t) => {
  const e = Tne(t), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: n
  } = t;
  return {
    getClassGroupId: (o) => {
      const a = o.split(_y);
      return a[0] === "" && a.length !== 1 && a.shift(), Y9(a, e) || Cne(o);
    },
    getConflictingClassGroupIds: (o, a) => {
      const u = r[o] || [];
      return a && n[o] ? [...u, ...n[o]] : u;
    }
  };
}, Y9 = (t, e) => {
  var o;
  if (t.length === 0)
    return e.classGroupId;
  const r = t[0], n = e.nextPart.get(r), i = n ? Y9(t.slice(1), n) : void 0;
  if (i)
    return i;
  if (e.validators.length === 0)
    return;
  const s = t.join(_y);
  return (o = e.validators.find(({
    validator: a
  }) => a(s))) == null ? void 0 : o.classGroupId;
}, S5 = /^\[(.+)\]$/, Cne = (t) => {
  if (S5.test(t)) {
    const e = S5.exec(t)[1], r = e == null ? void 0 : e.substring(0, e.indexOf(":"));
    if (r)
      return "arbitrary.." + r;
  }
}, Tne = (t) => {
  const {
    theme: e,
    prefix: r
  } = t, n = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return Dne(Object.entries(t.classGroups), r).forEach(([s, o]) => {
    Iv(o, n, s, e);
  }), n;
}, Iv = (t, e, r, n) => {
  t.forEach((i) => {
    if (typeof i == "string") {
      const s = i === "" ? e : A5(e, i);
      s.classGroupId = r;
      return;
    }
    if (typeof i == "function") {
      if (Rne(i)) {
        Iv(i(n), e, r, n);
        return;
      }
      e.validators.push({
        validator: i,
        classGroupId: r
      });
      return;
    }
    Object.entries(i).forEach(([s, o]) => {
      Iv(o, A5(e, s), r, n);
    });
  });
}, A5 = (t, e) => {
  let r = t;
  return e.split(_y).forEach((n) => {
    r.nextPart.has(n) || r.nextPart.set(n, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), r = r.nextPart.get(n);
  }), r;
}, Rne = (t) => t.isThemeGetter, Dne = (t, e) => e ? t.map(([r, n]) => {
  const i = n.map((s) => typeof s == "string" ? e + s : typeof s == "object" ? Object.fromEntries(Object.entries(s).map(([o, a]) => [e + o, a])) : s);
  return [r, i];
}) : t, One = (t) => {
  if (t < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  const i = (s, o) => {
    r.set(s, o), e++, e > t && (e = 0, n = r, r = /* @__PURE__ */ new Map());
  };
  return {
    get(s) {
      let o = r.get(s);
      if (o !== void 0)
        return o;
      if ((o = n.get(s)) !== void 0)
        return i(s, o), o;
    },
    set(s, o) {
      r.has(s) ? r.set(s, o) : i(s, o);
    }
  };
}, J9 = "!", Nne = (t) => {
  const {
    separator: e,
    experimentalParseClassName: r
  } = t, n = e.length === 1, i = e[0], s = e.length, o = (a) => {
    const u = [];
    let l = 0, d = 0, p;
    for (let L = 0; L < a.length; L++) {
      let B = a[L];
      if (l === 0) {
        if (B === i && (n || a.slice(L, L + s) === e)) {
          u.push(a.slice(d, L)), d = L + s;
          continue;
        }
        if (B === "/") {
          p = L;
          continue;
        }
      }
      B === "[" ? l++ : B === "]" && l--;
    }
    const w = u.length === 0 ? a : a.substring(d), _ = w.startsWith(J9), P = _ ? w.substring(1) : w, O = p && p > d ? p - d : void 0;
    return {
      modifiers: u,
      hasImportantModifier: _,
      baseClassName: P,
      maybePostfixModifierPosition: O
    };
  };
  return r ? (a) => r({
    className: a,
    parseClassName: o
  }) : o;
}, Lne = (t) => {
  if (t.length <= 1)
    return t;
  const e = [];
  let r = [];
  return t.forEach((n) => {
    n[0] === "[" ? (e.push(...r.sort(), n), r = []) : r.push(n);
  }), e.push(...r.sort()), e;
}, kne = (t) => ({
  cache: One(t.cacheSize),
  parseClassName: Nne(t),
  ...Ine(t)
}), $ne = /\s+/, Bne = (t, e) => {
  const {
    parseClassName: r,
    getClassGroupId: n,
    getConflictingClassGroupIds: i
  } = e, s = [], o = t.trim().split($ne);
  let a = "";
  for (let u = o.length - 1; u >= 0; u -= 1) {
    const l = o[u], {
      modifiers: d,
      hasImportantModifier: p,
      baseClassName: w,
      maybePostfixModifierPosition: _
    } = r(l);
    let P = !!_, O = n(P ? w.substring(0, _) : w);
    if (!O) {
      if (!P) {
        a = l + (a.length > 0 ? " " + a : a);
        continue;
      }
      if (O = n(w), !O) {
        a = l + (a.length > 0 ? " " + a : a);
        continue;
      }
      P = !1;
    }
    const L = Lne(d).join(":"), B = p ? L + J9 : L, k = B + O;
    if (s.includes(k))
      continue;
    s.push(k);
    const q = i(O, P);
    for (let U = 0; U < q.length; ++U) {
      const V = q[U];
      s.push(B + V);
    }
    a = l + (a.length > 0 ? " " + a : a);
  }
  return a;
};
function Fne() {
  let t = 0, e, r, n = "";
  for (; t < arguments.length; )
    (e = arguments[t++]) && (r = X9(e)) && (n && (n += " "), n += r);
  return n;
}
const X9 = (t) => {
  if (typeof t == "string")
    return t;
  let e, r = "";
  for (let n = 0; n < t.length; n++)
    t[n] && (e = X9(t[n])) && (r && (r += " "), r += e);
  return r;
};
function jne(t, ...e) {
  let r, n, i, s = o;
  function o(u) {
    const l = e.reduce((d, p) => p(d), t());
    return r = kne(l), n = r.cache.get, i = r.cache.set, s = a, a(u);
  }
  function a(u) {
    const l = n(u);
    if (l)
      return l;
    const d = Bne(u, r);
    return i(u, d), d;
  }
  return function() {
    return s(Fne.apply(null, arguments));
  };
}
const Gr = (t) => {
  const e = (r) => r[t] || [];
  return e.isThemeGetter = !0, e;
}, Z9 = /^\[(?:([a-z-]+):)?(.+)\]$/i, Une = /^\d+\/\d+$/, qne = /* @__PURE__ */ new Set(["px", "full", "screen"]), zne = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, Wne = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, Hne = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, Kne = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, Vne = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, _o = (t) => Pu(t) || qne.has(t) || Une.test(t), sa = (t) => tf(t, "length", tie), Pu = (t) => !!t && !Number.isNaN(Number(t)), s1 = (t) => tf(t, "number", Pu), Uf = (t) => !!t && Number.isInteger(Number(t)), Gne = (t) => t.endsWith("%") && Pu(t.slice(0, -1)), ur = (t) => Z9.test(t), oa = (t) => zne.test(t), Yne = /* @__PURE__ */ new Set(["length", "size", "percentage"]), Jne = (t) => tf(t, Yne, Q9), Xne = (t) => tf(t, "position", Q9), Zne = /* @__PURE__ */ new Set(["image", "url"]), Qne = (t) => tf(t, Zne, nie), eie = (t) => tf(t, "", rie), qf = () => !0, tf = (t, e, r) => {
  const n = Z9.exec(t);
  return n ? n[1] ? typeof e == "string" ? n[1] === e : e.has(n[1]) : r(n[2]) : !1;
}, tie = (t) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  Wne.test(t) && !Hne.test(t)
), Q9 = () => !1, rie = (t) => Kne.test(t), nie = (t) => Vne.test(t), iie = () => {
  const t = Gr("colors"), e = Gr("spacing"), r = Gr("blur"), n = Gr("brightness"), i = Gr("borderColor"), s = Gr("borderRadius"), o = Gr("borderSpacing"), a = Gr("borderWidth"), u = Gr("contrast"), l = Gr("grayscale"), d = Gr("hueRotate"), p = Gr("invert"), w = Gr("gap"), _ = Gr("gradientColorStops"), P = Gr("gradientColorStopPositions"), O = Gr("inset"), L = Gr("margin"), B = Gr("opacity"), k = Gr("padding"), q = Gr("saturate"), U = Gr("scale"), V = Gr("sepia"), Q = Gr("skew"), R = Gr("space"), K = Gr("translate"), ge = () => ["auto", "contain", "none"], Ee = () => ["auto", "hidden", "clip", "visible", "scroll"], Y = () => ["auto", ur, e], A = () => [ur, e], m = () => ["", _o, sa], f = () => ["auto", Pu, ur], g = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], b = () => ["solid", "dashed", "dotted", "double", "none"], x = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], E = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], S = () => ["", "0", ur], v = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], M = () => [Pu, ur];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [qf],
      spacing: [_o, sa],
      blur: ["none", "", oa, ur],
      brightness: M(),
      borderColor: [t],
      borderRadius: ["none", "", "full", oa, ur],
      borderSpacing: A(),
      borderWidth: m(),
      contrast: M(),
      grayscale: S(),
      hueRotate: M(),
      invert: S(),
      gap: A(),
      gradientColorStops: [t],
      gradientColorStopPositions: [Gne, sa],
      inset: Y(),
      margin: Y(),
      opacity: M(),
      padding: A(),
      saturate: M(),
      scale: M(),
      sepia: S(),
      skew: M(),
      space: A(),
      translate: A()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", ur]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [oa]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": v()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": v()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...g(), ur]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: Ee()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": Ee()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": Ee()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: ge()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": ge()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": ge()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [O]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [O]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [O]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [O]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [O]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [O]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [O]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [O]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [O]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Uf, ur]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: Y()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", ur]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: S()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: S()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Uf, ur]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [qf]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Uf, ur]
        }, ur]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": f()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": f()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [qf]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Uf, ur]
        }, ur]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": f()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": f()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", ur]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", ur]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [w]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [w]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [w]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...E()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...E(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...E(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [k]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [k]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [k]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [k]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [k]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [k]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [k]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [k]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [k]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [L]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [L]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [L]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [L]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [L]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [L]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [L]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [L]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [L]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [R]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [R]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", ur, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [ur, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [ur, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [oa]
        }, oa]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [ur, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [ur, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [ur, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [ur, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", oa, sa]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", s1]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [qf]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", ur]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", Pu, s1]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", _o, ur]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", ur]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", ur]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [t]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [B]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [t]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [B]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...b(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", _o, sa]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", _o, ur]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [t]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: A()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ur]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", ur]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [B]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...g(), Xne]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", Jne]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, Qne]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [t]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [P]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [P]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [P]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [_]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [_]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [_]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [s]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [s]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [s]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [s]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [s]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [s]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [s]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [s]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [s]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [s]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [s]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [s]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [s]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [s]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [s]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [a]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [a]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [a]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [a]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [a]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [a]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [a]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [a]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [a]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [B]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...b(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [a]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [a]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [B]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: b()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [i]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [i]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [i]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [i]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [i]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [i]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [i]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [i]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [i]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [i]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...b()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [_o, ur]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [_o, sa]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [t]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: m()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [t]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [B]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [_o, sa]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [t]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", oa, eie]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [qf]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [B]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...x(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": x()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [r]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [n]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [u]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", oa, ur]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [l]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [d]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [p]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [q]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [V]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [r]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [n]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [u]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [l]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [d]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [p]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [B]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [q]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [V]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [o]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [o]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [o]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", ur]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: M()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", ur]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: M()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", ur]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [U]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [U]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [U]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Uf, ur]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [K]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [K]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [Q]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [Q]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", ur]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", t]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ur]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [t]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": A()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": A()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": A()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": A()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": A()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": A()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": A()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": A()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": A()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": A()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": A()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": A()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": A()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": A()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": A()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": A()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": A()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": A()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", ur]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [t, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [_o, sa, s1]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [t, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, sie = /* @__PURE__ */ jne(iie);
function $o(...t) {
  return sie(Mne(t));
}
function eA(t) {
  const { className: e } = t;
  return /* @__PURE__ */ le.jsxs("div", { className: $o("xc-flex xc-items-center xc-gap-2"), children: [
    /* @__PURE__ */ le.jsx("hr", { className: $o("xc-flex-1 xc-border-gray-200", e) }),
    /* @__PURE__ */ le.jsx("div", { className: "xc-shrink-0", children: t.children }),
    /* @__PURE__ */ le.jsx("hr", { className: $o("xc-flex-1 xc-border-gray-200", e) })
  ] });
}
function oie(t) {
  var n, i;
  const { wallet: e, onClick: r } = t;
  return /* @__PURE__ */ le.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center xc-justify-center xc-gap-4", children: [
    /* @__PURE__ */ le.jsx("img", { className: "xc-rounded-md xc-h-16 xc-w-16", src: (n = e.config) == null ? void 0 : n.image, alt: "" }),
    /* @__PURE__ */ le.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center", children: [
      /* @__PURE__ */ le.jsxs("p", { className: "xc-text-danger xc-mb-2 xc-text-center", children: [
        "Connect to ",
        (i = e.config) == null ? void 0 : i.name
      ] }),
      /* @__PURE__ */ le.jsx("div", { className: "xc-flex xc-gap-2", children: /* @__PURE__ */ le.jsx("button", { className: "xc-rounded-full xc-bg-white xc-bg-opacity-10 xc-px-6 xc-py-1", onClick: () => r(e), children: "Connect" }) })
    ] })
  ] });
}
const aie = "https://static.codatta.io/codatta-connect/wallet-icons.svg?v=2#ton";
function cie(t) {
  const { onClick: e } = t;
  function r() {
    e && e();
  }
  return /* @__PURE__ */ le.jsx(eA, { className: "xc-opacity-20", children: /* @__PURE__ */ le.jsxs("div", { className: "xc-flex xc-items-center xc-gap-2 xc-cursor-pointer", onClick: r, children: [
    /* @__PURE__ */ le.jsx("span", { className: "xc-text-sm", children: "View more wallets" }),
    /* @__PURE__ */ le.jsx(b7, { size: 16 })
  ] }) });
}
function tA(t) {
  const [e, r] = Yt(""), { featuredWallets: n, initialized: i } = Tp(), { onEmailConfirm: s, onSelectWallet: o, onSelectMoreWallets: a, onSelectTonConnect: u, config: l } = t, d = wi(() => {
    const O = /[\u4e00-\u9fff]|[\u3400-\u4dbf]|[\u{20000}-\u{2a6df}]|[\u{2a700}-\u{2b73f}]|[\u{2b740}-\u{2b81f}]|[\u{2b820}-\u{2ceaf}]|[\uf900-\ufaff]|[\u3300-\u33ff]|[\ufe30-\ufe4f]/gu, L = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return !O.test(e) && L.test(e);
  }, [e]);
  function p(O) {
    o(O);
  }
  function w(O) {
    r(O.target.value);
  }
  async function _() {
    s(e);
  }
  function P(O) {
    O.key === "Enter" && d && _();
  }
  return /* @__PURE__ */ le.jsx(Rs, { children: i && /* @__PURE__ */ le.jsxs(le.Fragment, { children: [
    t.header || /* @__PURE__ */ le.jsx("div", { className: "xc-mb-6 xc-text-xl xc-font-bold", children: "Log in or sign up" }),
    n.length === 1 && /* @__PURE__ */ le.jsx("div", { className: "xc-mb-4 xc-flex xc-max-h-[309px] xc-flex-col xc-gap-4 xc-overflow-scroll no-scrollbar", children: n.map((O) => /* @__PURE__ */ le.jsx(
      oie,
      {
        wallet: O,
        onClick: p
      },
      `feature-${O.key}`
    )) }),
    n.length > 1 && /* @__PURE__ */ le.jsxs(le.Fragment, { children: [
      /* @__PURE__ */ le.jsxs("div", { children: [
        /* @__PURE__ */ le.jsxs("div", { className: "xc-mb-4 xc-flex xc-max-h-[309px] xc-flex-col xc-gap-4 xc-overflow-scroll no-scrollbar", children: [
          l.showFeaturedWallets && n && n.map((O) => /* @__PURE__ */ le.jsx(
            V9,
            {
              wallet: O,
              onClick: p
            },
            `feature-${O.key}`
          )),
          l.showTonConnect && /* @__PURE__ */ le.jsx(
            xy,
            {
              icon: /* @__PURE__ */ le.jsx("img", { className: "xc-h-5 xc-w-5", src: aie }),
              title: "TON Connect",
              onClick: u
            }
          )
        ] }),
        l.showMoreWallets && /* @__PURE__ */ le.jsx(cie, { onClick: a })
      ] }),
      l.showEmailSignIn && (l.showFeaturedWallets || l.showTonConnect) && /* @__PURE__ */ le.jsx("div", { className: "xc-mb-4 xc-mt-4", children: /* @__PURE__ */ le.jsxs(eA, { className: "xc-opacity-20", children: [
        " ",
        /* @__PURE__ */ le.jsx("span", { className: "xc-text-sm xc-opacity-20", children: "OR" })
      ] }) }),
      l.showEmailSignIn && /* @__PURE__ */ le.jsxs("div", { className: "xc-mb-4", children: [
        /* @__PURE__ */ le.jsx("input", { className: "xc-w-full xc-bg-transparent xc-border-white xc-border xc-border-opacity-15 xc-h-10 xc-rounded-lg xc-px-3 xc-mb-3", placeholder: "Enter your email", type: "email", onChange: w, onKeyDown: P }),
        /* @__PURE__ */ le.jsx("button", { disabled: !d, className: "xc-bg-[rgb(135,93,255)] xc-text-white xc-w-full xc-rounded-lg xc-py-2 disabled:xc-bg-opacity-10 disabled:xc-text-opacity-50 disabled:xc-bg-white xc-transition-all", onClick: _, children: "Continue" })
      ] })
    ] })
  ] }) });
}
function kc(t) {
  const { title: e } = t;
  return /* @__PURE__ */ le.jsxs("div", { className: "xc-flex xc-items-center xc-gap-2", children: [
    /* @__PURE__ */ le.jsx(WZ, { onClick: t.onBack, size: 20, className: "xc-cursor-pointer" }),
    /* @__PURE__ */ le.jsx("span", { children: e })
  ] });
}
const rA = Ta({
  channel: "",
  device: "WEB",
  app: "",
  inviterCode: "",
  role: "C"
});
function Ey() {
  return Tn(rA);
}
function uie(t) {
  const { config: e } = t, [r, n] = Yt(e.channel), [i, s] = Yt(e.device), [o, a] = Yt(e.app), [u, l] = Yt(e.role || "C"), [d, p] = Yt(e.inviterCode);
  return Dn(() => {
    n(e.channel), s(e.device), a(e.app), p(e.inviterCode), l(e.role || "C");
  }, [e]), /* @__PURE__ */ le.jsx(
    rA.Provider,
    {
      value: {
        channel: r,
        device: i,
        app: o,
        inviterCode: d,
        role: u
      },
      children: t.children
    }
  );
}
var fie = Object.defineProperty, lie = Object.defineProperties, hie = Object.getOwnPropertyDescriptors, k0 = Object.getOwnPropertySymbols, nA = Object.prototype.hasOwnProperty, iA = Object.prototype.propertyIsEnumerable, P5 = (t, e, r) => e in t ? fie(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, die = (t, e) => {
  for (var r in e || (e = {})) nA.call(e, r) && P5(t, r, e[r]);
  if (k0) for (var r of k0(e)) iA.call(e, r) && P5(t, r, e[r]);
  return t;
}, pie = (t, e) => lie(t, hie(e)), gie = (t, e) => {
  var r = {};
  for (var n in t) nA.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && k0) for (var n of k0(t)) e.indexOf(n) < 0 && iA.call(t, n) && (r[n] = t[n]);
  return r;
};
function mie(t) {
  let e = setTimeout(t, 0), r = setTimeout(t, 10), n = setTimeout(t, 50);
  return [e, r, n];
}
function vie(t) {
  let e = Gt.useRef();
  return Gt.useEffect(() => {
    e.current = t;
  }), e.current;
}
var bie = 18, sA = 40, yie = `${sA}px`, wie = ["[data-lastpass-icon-root]", "com-1password-button", "[data-dashlanecreated]", '[style$="2147483647 !important;"]'].join(",");
function xie({ containerRef: t, inputRef: e, pushPasswordManagerStrategy: r, isFocused: n }) {
  let [i, s] = Gt.useState(!1), [o, a] = Gt.useState(!1), [u, l] = Gt.useState(!1), d = Gt.useMemo(() => r === "none" ? !1 : (r === "increase-width" || r === "experimental-no-flickering") && i && o, [i, o, r]), p = Gt.useCallback(() => {
    let w = t.current, _ = e.current;
    if (!w || !_ || u || r === "none") return;
    let P = w, O = P.getBoundingClientRect().left + P.offsetWidth, L = P.getBoundingClientRect().top + P.offsetHeight / 2, B = O - bie, k = L;
    document.querySelectorAll(wie).length === 0 && document.elementFromPoint(B, k) === w || (s(!0), l(!0));
  }, [t, e, u, r]);
  return Gt.useEffect(() => {
    let w = t.current;
    if (!w || r === "none") return;
    function _() {
      let O = window.innerWidth - w.getBoundingClientRect().right;
      a(O >= sA);
    }
    _();
    let P = setInterval(_, 1e3);
    return () => {
      clearInterval(P);
    };
  }, [t, r]), Gt.useEffect(() => {
    let w = n || document.activeElement === e.current;
    if (r === "none" || !w) return;
    let _ = setTimeout(p, 0), P = setTimeout(p, 2e3), O = setTimeout(p, 5e3), L = setTimeout(() => {
      l(!0);
    }, 6e3);
    return () => {
      clearTimeout(_), clearTimeout(P), clearTimeout(O), clearTimeout(L);
    };
  }, [e, n, r, p]), { hasPWMBadge: i, willPushPWMBadge: d, PWM_BADGE_SPACE_WIDTH: yie };
}
var oA = Gt.createContext({}), aA = Gt.forwardRef((t, e) => {
  var r = t, { value: n, onChange: i, maxLength: s, textAlign: o = "left", pattern: a, placeholder: u, inputMode: l = "numeric", onComplete: d, pushPasswordManagerStrategy: p = "increase-width", pasteTransformer: w, containerClassName: _, noScriptCSSFallback: P = _ie, render: O, children: L } = r, B = gie(r, ["value", "onChange", "maxLength", "textAlign", "pattern", "placeholder", "inputMode", "onComplete", "pushPasswordManagerStrategy", "pasteTransformer", "containerClassName", "noScriptCSSFallback", "render", "children"]), k, q, U, V, Q;
  let [R, K] = Gt.useState(typeof B.defaultValue == "string" ? B.defaultValue : ""), ge = n ?? R, Ee = vie(ge), Y = Gt.useCallback((ie) => {
    i == null || i(ie), K(ie);
  }, [i]), A = Gt.useMemo(() => a ? typeof a == "string" ? new RegExp(a) : a : null, [a]), m = Gt.useRef(null), f = Gt.useRef(null), g = Gt.useRef({ value: ge, onChange: Y, isIOS: typeof window < "u" && ((q = (k = window == null ? void 0 : window.CSS) == null ? void 0 : k.supports) == null ? void 0 : q.call(k, "-webkit-touch-callout", "none")) }), b = Gt.useRef({ prev: [(U = m.current) == null ? void 0 : U.selectionStart, (V = m.current) == null ? void 0 : V.selectionEnd, (Q = m.current) == null ? void 0 : Q.selectionDirection] });
  Gt.useImperativeHandle(e, () => m.current, []), Gt.useEffect(() => {
    let ie = m.current, ue = f.current;
    if (!ie || !ue) return;
    g.current.value !== ie.value && g.current.onChange(ie.value), b.current.prev = [ie.selectionStart, ie.selectionEnd, ie.selectionDirection];
    function ve() {
      if (document.activeElement !== ie) {
        I(null), ce(null);
        return;
      }
      let Ce = ie.selectionStart, $e = ie.selectionEnd, Me = ie.selectionDirection, Ne = ie.maxLength, Ke = ie.value, Le = b.current.prev, qe = -1, ze = -1, _e;
      if (Ke.length !== 0 && Ce !== null && $e !== null) {
        let Qe = Ce === $e, tt = Ce === Ke.length && Ke.length < Ne;
        if (Qe && !tt) {
          let Ye = Ce;
          if (Ye === 0) qe = 0, ze = 1, _e = "forward";
          else if (Ye === Ne) qe = Ye - 1, ze = Ye, _e = "backward";
          else if (Ne > 1 && Ke.length > 1) {
            let dt = 0;
            if (Le[0] !== null && Le[1] !== null) {
              _e = Ye < Le[1] ? "backward" : "forward";
              let lt = Le[0] === Le[1] && Le[0] < Ne;
              _e === "backward" && !lt && (dt = -1);
            }
            qe = dt + Ye, ze = dt + Ye + 1;
          }
        }
        qe !== -1 && ze !== -1 && qe !== ze && m.current.setSelectionRange(qe, ze, _e);
      }
      let Ze = qe !== -1 ? qe : Ce, at = ze !== -1 ? ze : $e, ke = _e ?? Me;
      I(Ze), ce(at), b.current.prev = [Ze, at, ke];
    }
    if (document.addEventListener("selectionchange", ve, { capture: !0 }), ve(), document.activeElement === ie && v(!0), !document.getElementById("input-otp-style")) {
      let Ce = document.createElement("style");
      if (Ce.id = "input-otp-style", document.head.appendChild(Ce), Ce.sheet) {
        let $e = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
        zf(Ce.sheet, "[data-input-otp]::selection { background: transparent !important; color: transparent !important; }"), zf(Ce.sheet, `[data-input-otp]:autofill { ${$e} }`), zf(Ce.sheet, `[data-input-otp]:-webkit-autofill { ${$e} }`), zf(Ce.sheet, "@supports (-webkit-touch-callout: none) { [data-input-otp] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"), zf(Ce.sheet, "[data-input-otp] + * { pointer-events: all !important; }");
      }
    }
    let Pe = () => {
      ue && ue.style.setProperty("--root-height", `${ie.clientHeight}px`);
    };
    Pe();
    let De = new ResizeObserver(Pe);
    return De.observe(ie), () => {
      document.removeEventListener("selectionchange", ve, { capture: !0 }), De.disconnect();
    };
  }, []);
  let [x, E] = Gt.useState(!1), [S, v] = Gt.useState(!1), [M, I] = Gt.useState(null), [F, ce] = Gt.useState(null);
  Gt.useEffect(() => {
    mie(() => {
      var ie, ue, ve, Pe;
      (ie = m.current) == null || ie.dispatchEvent(new Event("input"));
      let De = (ue = m.current) == null ? void 0 : ue.selectionStart, Ce = (ve = m.current) == null ? void 0 : ve.selectionEnd, $e = (Pe = m.current) == null ? void 0 : Pe.selectionDirection;
      De !== null && Ce !== null && (I(De), ce(Ce), b.current.prev = [De, Ce, $e]);
    });
  }, [ge, S]), Gt.useEffect(() => {
    Ee !== void 0 && ge !== Ee && Ee.length < s && ge.length === s && (d == null || d(ge));
  }, [s, d, Ee, ge]);
  let D = xie({ containerRef: f, inputRef: m, pushPasswordManagerStrategy: p, isFocused: S }), oe = Gt.useCallback((ie) => {
    let ue = ie.currentTarget.value.slice(0, s);
    if (ue.length > 0 && A && !A.test(ue)) {
      ie.preventDefault();
      return;
    }
    typeof Ee == "string" && ue.length < Ee.length && document.dispatchEvent(new Event("selectionchange")), Y(ue);
  }, [s, Y, Ee, A]), Z = Gt.useCallback(() => {
    var ie;
    if (m.current) {
      let ue = Math.min(m.current.value.length, s - 1), ve = m.current.value.length;
      (ie = m.current) == null || ie.setSelectionRange(ue, ve), I(ue), ce(ve);
    }
    v(!0);
  }, [s]), J = Gt.useCallback((ie) => {
    var ue, ve;
    let Pe = m.current;
    if (!w && (!g.current.isIOS || !ie.clipboardData || !Pe)) return;
    let De = ie.clipboardData.getData("text/plain"), Ce = w ? w(De) : De;
    console.log({ _content: De, content: Ce }), ie.preventDefault();
    let $e = (ue = m.current) == null ? void 0 : ue.selectionStart, Me = (ve = m.current) == null ? void 0 : ve.selectionEnd, Ne = ($e !== Me ? ge.slice(0, $e) + Ce + ge.slice(Me) : ge.slice(0, $e) + Ce + ge.slice($e)).slice(0, s);
    if (Ne.length > 0 && A && !A.test(Ne)) return;
    Pe.value = Ne, Y(Ne);
    let Ke = Math.min(Ne.length, s - 1), Le = Ne.length;
    Pe.setSelectionRange(Ke, Le), I(Ke), ce(Le);
  }, [s, Y, A, ge]), ee = Gt.useMemo(() => ({ position: "relative", cursor: B.disabled ? "default" : "text", userSelect: "none", WebkitUserSelect: "none", pointerEvents: "none" }), [B.disabled]), T = Gt.useMemo(() => ({ position: "absolute", inset: 0, width: D.willPushPWMBadge ? `calc(100% + ${D.PWM_BADGE_SPACE_WIDTH})` : "100%", clipPath: D.willPushPWMBadge ? `inset(0 ${D.PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0, height: "100%", display: "flex", textAlign: o, opacity: "1", color: "transparent", pointerEvents: "all", background: "transparent", caretColor: "transparent", border: "0 solid transparent", outline: "0 solid transparent", boxShadow: "none", lineHeight: "1", letterSpacing: "-.5em", fontSize: "var(--root-height)", fontFamily: "monospace", fontVariantNumeric: "tabular-nums" }), [D.PWM_BADGE_SPACE_WIDTH, D.willPushPWMBadge, o]), X = Gt.useMemo(() => Gt.createElement("input", pie(die({ autoComplete: B.autoComplete || "one-time-code" }, B), { "data-input-otp": !0, "data-input-otp-placeholder-shown": ge.length === 0 || void 0, "data-input-otp-mss": M, "data-input-otp-mse": F, inputMode: l, pattern: A == null ? void 0 : A.source, "aria-placeholder": u, style: T, maxLength: s, value: ge, ref: m, onPaste: (ie) => {
    var ue;
    J(ie), (ue = B.onPaste) == null || ue.call(B, ie);
  }, onChange: oe, onMouseOver: (ie) => {
    var ue;
    E(!0), (ue = B.onMouseOver) == null || ue.call(B, ie);
  }, onMouseLeave: (ie) => {
    var ue;
    E(!1), (ue = B.onMouseLeave) == null || ue.call(B, ie);
  }, onFocus: (ie) => {
    var ue;
    Z(), (ue = B.onFocus) == null || ue.call(B, ie);
  }, onBlur: (ie) => {
    var ue;
    v(!1), (ue = B.onBlur) == null || ue.call(B, ie);
  } })), [oe, Z, J, l, T, s, F, M, B, A == null ? void 0 : A.source, ge]), re = Gt.useMemo(() => ({ slots: Array.from({ length: s }).map((ie, ue) => {
    var ve;
    let Pe = S && M !== null && F !== null && (M === F && ue === M || ue >= M && ue < F), De = ge[ue] !== void 0 ? ge[ue] : null, Ce = ge[0] !== void 0 ? null : (ve = u == null ? void 0 : u[ue]) != null ? ve : null;
    return { char: De, placeholderChar: Ce, isActive: Pe, hasFakeCaret: Pe && De === null };
  }), isFocused: S, isHovering: !B.disabled && x }), [S, x, s, F, M, B.disabled, ge]), pe = Gt.useMemo(() => O ? O(re) : Gt.createElement(oA.Provider, { value: re }, L), [L, re, O]);
  return Gt.createElement(Gt.Fragment, null, P !== null && Gt.createElement("noscript", null, Gt.createElement("style", null, P)), Gt.createElement("div", { ref: f, "data-input-otp-container": !0, style: ee, className: _ }, pe, Gt.createElement("div", { style: { position: "absolute", inset: 0, pointerEvents: "none" } }, X)));
});
aA.displayName = "Input";
function zf(t, e) {
  try {
    t.insertRule(e);
  } catch {
    console.error("input-otp could not insert CSS rule:", e);
  }
}
var _ie = `
[data-input-otp] {
  --nojs-bg: white !important;
  --nojs-fg: black !important;

  background-color: var(--nojs-bg) !important;
  color: var(--nojs-fg) !important;
  caret-color: var(--nojs-fg) !important;
  letter-spacing: .25em !important;
  text-align: center !important;
  border: 1px solid var(--nojs-fg) !important;
  border-radius: 4px !important;
  width: 100% !important;
}
@media (prefers-color-scheme: dark) {
  [data-input-otp] {
    --nojs-bg: black !important;
    --nojs-fg: white !important;
  }
}`;
const cA = Gt.forwardRef(({ className: t, containerClassName: e, ...r }, n) => /* @__PURE__ */ le.jsx(
  aA,
  {
    ref: n,
    containerClassName: $o(
      "xc-flex xc-items-center xc-gap-2 xc-has-[:disabled]:opacity-50",
      e
    ),
    className: $o("disabled:xc-cursor-not-allowed", t),
    ...r
  }
));
cA.displayName = "InputOTP";
const uA = Gt.forwardRef(({ className: t, ...e }, r) => /* @__PURE__ */ le.jsx("div", { ref: r, className: $o("xc-flex xc-items-center", t), ...e }));
uA.displayName = "InputOTPGroup";
const nc = Gt.forwardRef(({ index: t, className: e, ...r }, n) => {
  const i = Gt.useContext(oA), { char: s, hasFakeCaret: o, isActive: a } = i.slots[t];
  return /* @__PURE__ */ le.jsxs(
    "div",
    {
      ref: n,
      className: $o(
        "xc-relative xc-rounded-xl xc-text-2xl xc-flex xc-h-12 xc-w-12 xc-items-center xc-justify-center xc-border xc-border-white xc-border-opacity-20 xc-transition-all",
        a && "xc-z-10 xc-ring-2 xc-ring-ring xc-ring-[rgb(135,93,255)] xc-ring-offset-background",
        e
      ),
      ...r,
      children: [
        s,
        o && /* @__PURE__ */ le.jsx("div", { className: "xc-pointer-events-none xc-absolute xc-inset-0 xc-flex xc-items-center xc-justify-center", children: /* @__PURE__ */ le.jsx("div", { className: "xc-h-4 xc-w-px xc-animate-caret-blink xc-bg-foreground xc-duration-1000" }) })
      ]
    }
  );
});
nc.displayName = "InputOTPSlot";
function Eie(t) {
  const { spinning: e, children: r, className: n } = t;
  return /* @__PURE__ */ le.jsxs("div", { className: "xc-inline-block xc-relative", children: [
    r,
    e && /* @__PURE__ */ le.jsx("div", { className: $o("xc-absolute xc-top-0 xc-left-0 xc-w-full xc-h-full xc-bg-black xc-bg-opacity-10 xc-flex xc-items-center xc-justify-center", n), children: /* @__PURE__ */ le.jsx(Sc, { className: "xc-animate-spin" }) })
  ] });
}
function fA(t) {
  const { email: e } = t, [r, n] = Yt(0), [i, s] = Yt(!1), [o, a] = Yt("");
  async function u() {
    n(60);
    const d = setInterval(() => {
      n((p) => p === 0 ? (clearInterval(d), 0) : p - 1);
    }, 1e3);
  }
  async function l(d) {
    if (a(""), !(d.length < 6)) {
      s(!0);
      try {
        await t.onInputCode(e, d);
      } catch (p) {
        a(p.message);
      }
      s(!1);
    }
  }
  return Dn(() => {
    u();
  }, []), /* @__PURE__ */ le.jsxs(Rs, { children: [
    /* @__PURE__ */ le.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center xc-justify-center xc-mb-12", children: [
      /* @__PURE__ */ le.jsx(JZ, { className: "xc-mb-4", size: 60 }),
      /* @__PURE__ */ le.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center xc-justify-center xc-mb-8 xc-h-16", children: [
        /* @__PURE__ */ le.jsx("p", { className: "xc-text-lg xc-mb-1", children: "We’ve sent a verification code to" }),
        /* @__PURE__ */ le.jsx("p", { className: "xc-font-bold xc-text-center", children: e })
      ] }),
      /* @__PURE__ */ le.jsx("div", { className: "xc-mb-2 xc-h-12", children: /* @__PURE__ */ le.jsx(Eie, { spinning: i, className: "xc-rounded-xl", children: /* @__PURE__ */ le.jsx(cA, { maxLength: 6, onChange: l, disabled: i, className: "disabled:xc-opacity-20", children: /* @__PURE__ */ le.jsx(uA, { children: /* @__PURE__ */ le.jsxs("div", { className: $o("xc-flex xc-gap-2", i ? "xc-opacity-20" : ""), children: [
        /* @__PURE__ */ le.jsx(nc, { index: 0 }),
        /* @__PURE__ */ le.jsx(nc, { index: 1 }),
        /* @__PURE__ */ le.jsx(nc, { index: 2 }),
        /* @__PURE__ */ le.jsx(nc, { index: 3 }),
        /* @__PURE__ */ le.jsx(nc, { index: 4 }),
        /* @__PURE__ */ le.jsx(nc, { index: 5 })
      ] }) }) }) }) }),
      o && /* @__PURE__ */ le.jsx("div", { className: "xc-text-[#ff0000] xc-text-center", children: /* @__PURE__ */ le.jsx("p", { children: o }) })
    ] }),
    /* @__PURE__ */ le.jsxs("div", { className: "xc-text-center xc-text-sm xc-text-gray-400", children: [
      "Not get it? ",
      r ? `Resend in ${r}s` : /* @__PURE__ */ le.jsx("button", { id: "sendCodeButton", onClick: t.onResendCode, children: "Send again" })
    ] }),
    /* @__PURE__ */ le.jsx("div", { id: "captcha-element" })
  ] });
}
function lA(t) {
  const { email: e } = t, [r, n] = Yt(!1), [i, s] = Yt(""), o = wi(() => `xn-btn-${(/* @__PURE__ */ new Date()).getTime()}`, [e]);
  async function a(w, _) {
    n(!0), s(""), await ka.getEmailCode({ account_type: "email", email: w }, _), n(!1);
  }
  async function u(w) {
    try {
      return await a(e, JSON.stringify(w)), { captchaResult: !0, bizResult: !0 };
    } catch (_) {
      return s(_.message), { captchaResult: !1, bizResult: !1 };
    }
  }
  async function l(w) {
    w && t.onCodeSend();
  }
  const d = Qn();
  function p(w) {
    d.current = w;
  }
  return Dn(() => {
    if (e)
      return window.initAliyunCaptcha({
        SceneId: "tqyu8129d",
        prefix: "1mfsn5f",
        mode: "popup",
        element: "#captcha-element",
        button: `#${o}`,
        captchaVerifyCallback: u,
        onBizResultCallback: l,
        getInstance: p,
        slideStyle: {
          width: 360,
          height: 40
        },
        language: "en",
        region: "cn"
      }), () => {
        var w, _;
        (w = document.getElementById("aliyunCaptcha-mask")) == null || w.remove(), (_ = document.getElementById("aliyunCaptcha-window-popup")) == null || _.remove();
      };
  }, [e]), /* @__PURE__ */ le.jsxs(Rs, { children: [
    /* @__PURE__ */ le.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center xc-justify-center xc-mb-12", children: [
      /* @__PURE__ */ le.jsx(XZ, { className: "xc-mb-4", size: 60 }),
      /* @__PURE__ */ le.jsx("button", { className: "xc-border xc-rounded-full xc-bg-white xc-text-black xc-px-8 xc-py-2", id: o, children: r ? /* @__PURE__ */ le.jsx(Sc, { className: "xc-animate-spin" }) : "I'm not a robot" })
    ] }),
    i && /* @__PURE__ */ le.jsx("div", { className: "xc-text-[#ff0000] xc-text-center", children: /* @__PURE__ */ le.jsx("p", { children: i }) })
  ] });
}
function Sie(t) {
  const { email: e } = t, r = Ey(), [n, i] = Yt("captcha");
  async function s(o, a) {
    const u = await ka.emailLogin({
      account_type: "email",
      connector: "codatta_email",
      account_enum: "C",
      email_code: a,
      email: o,
      inviter_code: r.inviterCode,
      source: {
        device: r.device,
        channel: r.channel,
        app: r.app
      }
    });
    t.onLogin(u.data);
  }
  return /* @__PURE__ */ le.jsxs(Rs, { children: [
    /* @__PURE__ */ le.jsx("div", { className: "xc-mb-12", children: /* @__PURE__ */ le.jsx(kc, { title: "Sign in with email", onBack: t.onBack }) }),
    n === "captcha" && /* @__PURE__ */ le.jsx(lA, { email: e, onCodeSend: () => i("verify-email") }),
    n === "verify-email" && /* @__PURE__ */ le.jsx(fA, { email: e, onInputCode: s, onResendCode: () => i("captcha") })
  ] });
}
var hA = { exports: {} };
(function(t, e) {
  (function(r, n) {
    t.exports = n();
  })(gn, () => (() => {
    var r = { 873: (o, a) => {
      var u, l, d = function() {
        var p = function(f, g) {
          var b = f, x = B[g], E = null, S = 0, v = null, M = [], I = {}, F = function(re, pe) {
            E = function(ie) {
              for (var ue = new Array(ie), ve = 0; ve < ie; ve += 1) {
                ue[ve] = new Array(ie);
                for (var Pe = 0; Pe < ie; Pe += 1) ue[ve][Pe] = null;
              }
              return ue;
            }(S = 4 * b + 17), ce(0, 0), ce(S - 7, 0), ce(0, S - 7), oe(), D(), J(re, pe), b >= 7 && Z(re), v == null && (v = T(b, x, M)), ee(v, pe);
          }, ce = function(re, pe) {
            for (var ie = -1; ie <= 7; ie += 1) if (!(re + ie <= -1 || S <= re + ie)) for (var ue = -1; ue <= 7; ue += 1) pe + ue <= -1 || S <= pe + ue || (E[re + ie][pe + ue] = 0 <= ie && ie <= 6 && (ue == 0 || ue == 6) || 0 <= ue && ue <= 6 && (ie == 0 || ie == 6) || 2 <= ie && ie <= 4 && 2 <= ue && ue <= 4);
          }, D = function() {
            for (var re = 8; re < S - 8; re += 1) E[re][6] == null && (E[re][6] = re % 2 == 0);
            for (var pe = 8; pe < S - 8; pe += 1) E[6][pe] == null && (E[6][pe] = pe % 2 == 0);
          }, oe = function() {
            for (var re = k.getPatternPosition(b), pe = 0; pe < re.length; pe += 1) for (var ie = 0; ie < re.length; ie += 1) {
              var ue = re[pe], ve = re[ie];
              if (E[ue][ve] == null) for (var Pe = -2; Pe <= 2; Pe += 1) for (var De = -2; De <= 2; De += 1) E[ue + Pe][ve + De] = Pe == -2 || Pe == 2 || De == -2 || De == 2 || Pe == 0 && De == 0;
            }
          }, Z = function(re) {
            for (var pe = k.getBCHTypeNumber(b), ie = 0; ie < 18; ie += 1) {
              var ue = !re && (pe >> ie & 1) == 1;
              E[Math.floor(ie / 3)][ie % 3 + S - 8 - 3] = ue;
            }
            for (ie = 0; ie < 18; ie += 1) ue = !re && (pe >> ie & 1) == 1, E[ie % 3 + S - 8 - 3][Math.floor(ie / 3)] = ue;
          }, J = function(re, pe) {
            for (var ie = x << 3 | pe, ue = k.getBCHTypeInfo(ie), ve = 0; ve < 15; ve += 1) {
              var Pe = !re && (ue >> ve & 1) == 1;
              ve < 6 ? E[ve][8] = Pe : ve < 8 ? E[ve + 1][8] = Pe : E[S - 15 + ve][8] = Pe;
            }
            for (ve = 0; ve < 15; ve += 1) Pe = !re && (ue >> ve & 1) == 1, ve < 8 ? E[8][S - ve - 1] = Pe : ve < 9 ? E[8][15 - ve - 1 + 1] = Pe : E[8][15 - ve - 1] = Pe;
            E[S - 8][8] = !re;
          }, ee = function(re, pe) {
            for (var ie = -1, ue = S - 1, ve = 7, Pe = 0, De = k.getMaskFunction(pe), Ce = S - 1; Ce > 0; Ce -= 2) for (Ce == 6 && (Ce -= 1); ; ) {
              for (var $e = 0; $e < 2; $e += 1) if (E[ue][Ce - $e] == null) {
                var Me = !1;
                Pe < re.length && (Me = (re[Pe] >>> ve & 1) == 1), De(ue, Ce - $e) && (Me = !Me), E[ue][Ce - $e] = Me, (ve -= 1) == -1 && (Pe += 1, ve = 7);
              }
              if ((ue += ie) < 0 || S <= ue) {
                ue -= ie, ie = -ie;
                break;
              }
            }
          }, T = function(re, pe, ie) {
            for (var ue = V.getRSBlocks(re, pe), ve = Q(), Pe = 0; Pe < ie.length; Pe += 1) {
              var De = ie[Pe];
              ve.put(De.getMode(), 4), ve.put(De.getLength(), k.getLengthInBits(De.getMode(), re)), De.write(ve);
            }
            var Ce = 0;
            for (Pe = 0; Pe < ue.length; Pe += 1) Ce += ue[Pe].dataCount;
            if (ve.getLengthInBits() > 8 * Ce) throw "code length overflow. (" + ve.getLengthInBits() + ">" + 8 * Ce + ")";
            for (ve.getLengthInBits() + 4 <= 8 * Ce && ve.put(0, 4); ve.getLengthInBits() % 8 != 0; ) ve.putBit(!1);
            for (; !(ve.getLengthInBits() >= 8 * Ce || (ve.put(236, 8), ve.getLengthInBits() >= 8 * Ce)); ) ve.put(17, 8);
            return function($e, Me) {
              for (var Ne = 0, Ke = 0, Le = 0, qe = new Array(Me.length), ze = new Array(Me.length), _e = 0; _e < Me.length; _e += 1) {
                var Ze = Me[_e].dataCount, at = Me[_e].totalCount - Ze;
                Ke = Math.max(Ke, Ze), Le = Math.max(Le, at), qe[_e] = new Array(Ze);
                for (var ke = 0; ke < qe[_e].length; ke += 1) qe[_e][ke] = 255 & $e.getBuffer()[ke + Ne];
                Ne += Ze;
                var Qe = k.getErrorCorrectPolynomial(at), tt = U(qe[_e], Qe.getLength() - 1).mod(Qe);
                for (ze[_e] = new Array(Qe.getLength() - 1), ke = 0; ke < ze[_e].length; ke += 1) {
                  var Ye = ke + tt.getLength() - ze[_e].length;
                  ze[_e][ke] = Ye >= 0 ? tt.getAt(Ye) : 0;
                }
              }
              var dt = 0;
              for (ke = 0; ke < Me.length; ke += 1) dt += Me[ke].totalCount;
              var lt = new Array(dt), ct = 0;
              for (ke = 0; ke < Ke; ke += 1) for (_e = 0; _e < Me.length; _e += 1) ke < qe[_e].length && (lt[ct] = qe[_e][ke], ct += 1);
              for (ke = 0; ke < Le; ke += 1) for (_e = 0; _e < Me.length; _e += 1) ke < ze[_e].length && (lt[ct] = ze[_e][ke], ct += 1);
              return lt;
            }(ve, ue);
          };
          I.addData = function(re, pe) {
            var ie = null;
            switch (pe = pe || "Byte") {
              case "Numeric":
                ie = R(re);
                break;
              case "Alphanumeric":
                ie = K(re);
                break;
              case "Byte":
                ie = ge(re);
                break;
              case "Kanji":
                ie = Ee(re);
                break;
              default:
                throw "mode:" + pe;
            }
            M.push(ie), v = null;
          }, I.isDark = function(re, pe) {
            if (re < 0 || S <= re || pe < 0 || S <= pe) throw re + "," + pe;
            return E[re][pe];
          }, I.getModuleCount = function() {
            return S;
          }, I.make = function() {
            if (b < 1) {
              for (var re = 1; re < 40; re++) {
                for (var pe = V.getRSBlocks(re, x), ie = Q(), ue = 0; ue < M.length; ue++) {
                  var ve = M[ue];
                  ie.put(ve.getMode(), 4), ie.put(ve.getLength(), k.getLengthInBits(ve.getMode(), re)), ve.write(ie);
                }
                var Pe = 0;
                for (ue = 0; ue < pe.length; ue++) Pe += pe[ue].dataCount;
                if (ie.getLengthInBits() <= 8 * Pe) break;
              }
              b = re;
            }
            F(!1, function() {
              for (var De = 0, Ce = 0, $e = 0; $e < 8; $e += 1) {
                F(!0, $e);
                var Me = k.getLostPoint(I);
                ($e == 0 || De > Me) && (De = Me, Ce = $e);
              }
              return Ce;
            }());
          }, I.createTableTag = function(re, pe) {
            re = re || 2;
            var ie = "";
            ie += '<table style="', ie += " border-width: 0px; border-style: none;", ie += " border-collapse: collapse;", ie += " padding: 0px; margin: " + (pe = pe === void 0 ? 4 * re : pe) + "px;", ie += '">', ie += "<tbody>";
            for (var ue = 0; ue < I.getModuleCount(); ue += 1) {
              ie += "<tr>";
              for (var ve = 0; ve < I.getModuleCount(); ve += 1) ie += '<td style="', ie += " border-width: 0px; border-style: none;", ie += " border-collapse: collapse;", ie += " padding: 0px; margin: 0px;", ie += " width: " + re + "px;", ie += " height: " + re + "px;", ie += " background-color: ", ie += I.isDark(ue, ve) ? "#000000" : "#ffffff", ie += ";", ie += '"/>';
              ie += "</tr>";
            }
            return (ie += "</tbody>") + "</table>";
          }, I.createSvgTag = function(re, pe, ie, ue) {
            var ve = {};
            typeof arguments[0] == "object" && (re = (ve = arguments[0]).cellSize, pe = ve.margin, ie = ve.alt, ue = ve.title), re = re || 2, pe = pe === void 0 ? 4 * re : pe, (ie = typeof ie == "string" ? { text: ie } : ie || {}).text = ie.text || null, ie.id = ie.text ? ie.id || "qrcode-description" : null, (ue = typeof ue == "string" ? { text: ue } : ue || {}).text = ue.text || null, ue.id = ue.text ? ue.id || "qrcode-title" : null;
            var Pe, De, Ce, $e, Me = I.getModuleCount() * re + 2 * pe, Ne = "";
            for ($e = "l" + re + ",0 0," + re + " -" + re + ",0 0,-" + re + "z ", Ne += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"', Ne += ve.scalable ? "" : ' width="' + Me + 'px" height="' + Me + 'px"', Ne += ' viewBox="0 0 ' + Me + " " + Me + '" ', Ne += ' preserveAspectRatio="xMinYMin meet"', Ne += ue.text || ie.text ? ' role="img" aria-labelledby="' + X([ue.id, ie.id].join(" ").trim()) + '"' : "", Ne += ">", Ne += ue.text ? '<title id="' + X(ue.id) + '">' + X(ue.text) + "</title>" : "", Ne += ie.text ? '<description id="' + X(ie.id) + '">' + X(ie.text) + "</description>" : "", Ne += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>', Ne += '<path d="', De = 0; De < I.getModuleCount(); De += 1) for (Ce = De * re + pe, Pe = 0; Pe < I.getModuleCount(); Pe += 1) I.isDark(De, Pe) && (Ne += "M" + (Pe * re + pe) + "," + Ce + $e);
            return (Ne += '" stroke="transparent" fill="black"/>') + "</svg>";
          }, I.createDataURL = function(re, pe) {
            re = re || 2, pe = pe === void 0 ? 4 * re : pe;
            var ie = I.getModuleCount() * re + 2 * pe, ue = pe, ve = ie - pe;
            return m(ie, ie, function(Pe, De) {
              if (ue <= Pe && Pe < ve && ue <= De && De < ve) {
                var Ce = Math.floor((Pe - ue) / re), $e = Math.floor((De - ue) / re);
                return I.isDark($e, Ce) ? 0 : 1;
              }
              return 1;
            });
          }, I.createImgTag = function(re, pe, ie) {
            re = re || 2, pe = pe === void 0 ? 4 * re : pe;
            var ue = I.getModuleCount() * re + 2 * pe, ve = "";
            return ve += "<img", ve += ' src="', ve += I.createDataURL(re, pe), ve += '"', ve += ' width="', ve += ue, ve += '"', ve += ' height="', ve += ue, ve += '"', ie && (ve += ' alt="', ve += X(ie), ve += '"'), ve + "/>";
          };
          var X = function(re) {
            for (var pe = "", ie = 0; ie < re.length; ie += 1) {
              var ue = re.charAt(ie);
              switch (ue) {
                case "<":
                  pe += "&lt;";
                  break;
                case ">":
                  pe += "&gt;";
                  break;
                case "&":
                  pe += "&amp;";
                  break;
                case '"':
                  pe += "&quot;";
                  break;
                default:
                  pe += ue;
              }
            }
            return pe;
          };
          return I.createASCII = function(re, pe) {
            if ((re = re || 1) < 2) return function(qe) {
              qe = qe === void 0 ? 2 : qe;
              var ze, _e, Ze, at, ke, Qe = 1 * I.getModuleCount() + 2 * qe, tt = qe, Ye = Qe - qe, dt = { "██": "█", "█ ": "▀", " █": "▄", "  ": " " }, lt = { "██": "▀", "█ ": "▀", " █": " ", "  ": " " }, ct = "";
              for (ze = 0; ze < Qe; ze += 2) {
                for (Ze = Math.floor((ze - tt) / 1), at = Math.floor((ze + 1 - tt) / 1), _e = 0; _e < Qe; _e += 1) ke = "█", tt <= _e && _e < Ye && tt <= ze && ze < Ye && I.isDark(Ze, Math.floor((_e - tt) / 1)) && (ke = " "), tt <= _e && _e < Ye && tt <= ze + 1 && ze + 1 < Ye && I.isDark(at, Math.floor((_e - tt) / 1)) ? ke += " " : ke += "█", ct += qe < 1 && ze + 1 >= Ye ? lt[ke] : dt[ke];
                ct += `
`;
              }
              return Qe % 2 && qe > 0 ? ct.substring(0, ct.length - Qe - 1) + Array(Qe + 1).join("▀") : ct.substring(0, ct.length - 1);
            }(pe);
            re -= 1, pe = pe === void 0 ? 2 * re : pe;
            var ie, ue, ve, Pe, De = I.getModuleCount() * re + 2 * pe, Ce = pe, $e = De - pe, Me = Array(re + 1).join("██"), Ne = Array(re + 1).join("  "), Ke = "", Le = "";
            for (ie = 0; ie < De; ie += 1) {
              for (ve = Math.floor((ie - Ce) / re), Le = "", ue = 0; ue < De; ue += 1) Pe = 1, Ce <= ue && ue < $e && Ce <= ie && ie < $e && I.isDark(ve, Math.floor((ue - Ce) / re)) && (Pe = 0), Le += Pe ? Me : Ne;
              for (ve = 0; ve < re; ve += 1) Ke += Le + `
`;
            }
            return Ke.substring(0, Ke.length - 1);
          }, I.renderTo2dContext = function(re, pe) {
            pe = pe || 2;
            for (var ie = I.getModuleCount(), ue = 0; ue < ie; ue++) for (var ve = 0; ve < ie; ve++) re.fillStyle = I.isDark(ue, ve) ? "black" : "white", re.fillRect(ue * pe, ve * pe, pe, pe);
          }, I;
        };
        p.stringToBytes = (p.stringToBytesFuncs = { default: function(f) {
          for (var g = [], b = 0; b < f.length; b += 1) {
            var x = f.charCodeAt(b);
            g.push(255 & x);
          }
          return g;
        } }).default, p.createStringToBytes = function(f, g) {
          var b = function() {
            for (var E = A(f), S = function() {
              var D = E.read();
              if (D == -1) throw "eof";
              return D;
            }, v = 0, M = {}; ; ) {
              var I = E.read();
              if (I == -1) break;
              var F = S(), ce = S() << 8 | S();
              M[String.fromCharCode(I << 8 | F)] = ce, v += 1;
            }
            if (v != g) throw v + " != " + g;
            return M;
          }(), x = 63;
          return function(E) {
            for (var S = [], v = 0; v < E.length; v += 1) {
              var M = E.charCodeAt(v);
              if (M < 128) S.push(M);
              else {
                var I = b[E.charAt(v)];
                typeof I == "number" ? (255 & I) == I ? S.push(I) : (S.push(I >>> 8), S.push(255 & I)) : S.push(x);
              }
            }
            return S;
          };
        };
        var w, _, P, O, L, B = { L: 1, M: 0, Q: 3, H: 2 }, k = (w = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], _ = 1335, P = 7973, L = function(f) {
          for (var g = 0; f != 0; ) g += 1, f >>>= 1;
          return g;
        }, (O = {}).getBCHTypeInfo = function(f) {
          for (var g = f << 10; L(g) - L(_) >= 0; ) g ^= _ << L(g) - L(_);
          return 21522 ^ (f << 10 | g);
        }, O.getBCHTypeNumber = function(f) {
          for (var g = f << 12; L(g) - L(P) >= 0; ) g ^= P << L(g) - L(P);
          return f << 12 | g;
        }, O.getPatternPosition = function(f) {
          return w[f - 1];
        }, O.getMaskFunction = function(f) {
          switch (f) {
            case 0:
              return function(g, b) {
                return (g + b) % 2 == 0;
              };
            case 1:
              return function(g, b) {
                return g % 2 == 0;
              };
            case 2:
              return function(g, b) {
                return b % 3 == 0;
              };
            case 3:
              return function(g, b) {
                return (g + b) % 3 == 0;
              };
            case 4:
              return function(g, b) {
                return (Math.floor(g / 2) + Math.floor(b / 3)) % 2 == 0;
              };
            case 5:
              return function(g, b) {
                return g * b % 2 + g * b % 3 == 0;
              };
            case 6:
              return function(g, b) {
                return (g * b % 2 + g * b % 3) % 2 == 0;
              };
            case 7:
              return function(g, b) {
                return (g * b % 3 + (g + b) % 2) % 2 == 0;
              };
            default:
              throw "bad maskPattern:" + f;
          }
        }, O.getErrorCorrectPolynomial = function(f) {
          for (var g = U([1], 0), b = 0; b < f; b += 1) g = g.multiply(U([1, q.gexp(b)], 0));
          return g;
        }, O.getLengthInBits = function(f, g) {
          if (1 <= g && g < 10) switch (f) {
            case 1:
              return 10;
            case 2:
              return 9;
            case 4:
            case 8:
              return 8;
            default:
              throw "mode:" + f;
          }
          else if (g < 27) switch (f) {
            case 1:
              return 12;
            case 2:
              return 11;
            case 4:
              return 16;
            case 8:
              return 10;
            default:
              throw "mode:" + f;
          }
          else {
            if (!(g < 41)) throw "type:" + g;
            switch (f) {
              case 1:
                return 14;
              case 2:
                return 13;
              case 4:
                return 16;
              case 8:
                return 12;
              default:
                throw "mode:" + f;
            }
          }
        }, O.getLostPoint = function(f) {
          for (var g = f.getModuleCount(), b = 0, x = 0; x < g; x += 1) for (var E = 0; E < g; E += 1) {
            for (var S = 0, v = f.isDark(x, E), M = -1; M <= 1; M += 1) if (!(x + M < 0 || g <= x + M)) for (var I = -1; I <= 1; I += 1) E + I < 0 || g <= E + I || M == 0 && I == 0 || v == f.isDark(x + M, E + I) && (S += 1);
            S > 5 && (b += 3 + S - 5);
          }
          for (x = 0; x < g - 1; x += 1) for (E = 0; E < g - 1; E += 1) {
            var F = 0;
            f.isDark(x, E) && (F += 1), f.isDark(x + 1, E) && (F += 1), f.isDark(x, E + 1) && (F += 1), f.isDark(x + 1, E + 1) && (F += 1), F != 0 && F != 4 || (b += 3);
          }
          for (x = 0; x < g; x += 1) for (E = 0; E < g - 6; E += 1) f.isDark(x, E) && !f.isDark(x, E + 1) && f.isDark(x, E + 2) && f.isDark(x, E + 3) && f.isDark(x, E + 4) && !f.isDark(x, E + 5) && f.isDark(x, E + 6) && (b += 40);
          for (E = 0; E < g; E += 1) for (x = 0; x < g - 6; x += 1) f.isDark(x, E) && !f.isDark(x + 1, E) && f.isDark(x + 2, E) && f.isDark(x + 3, E) && f.isDark(x + 4, E) && !f.isDark(x + 5, E) && f.isDark(x + 6, E) && (b += 40);
          var ce = 0;
          for (E = 0; E < g; E += 1) for (x = 0; x < g; x += 1) f.isDark(x, E) && (ce += 1);
          return b + Math.abs(100 * ce / g / g - 50) / 5 * 10;
        }, O), q = function() {
          for (var f = new Array(256), g = new Array(256), b = 0; b < 8; b += 1) f[b] = 1 << b;
          for (b = 8; b < 256; b += 1) f[b] = f[b - 4] ^ f[b - 5] ^ f[b - 6] ^ f[b - 8];
          for (b = 0; b < 255; b += 1) g[f[b]] = b;
          return { glog: function(x) {
            if (x < 1) throw "glog(" + x + ")";
            return g[x];
          }, gexp: function(x) {
            for (; x < 0; ) x += 255;
            for (; x >= 256; ) x -= 255;
            return f[x];
          } };
        }();
        function U(f, g) {
          if (f.length === void 0) throw f.length + "/" + g;
          var b = function() {
            for (var E = 0; E < f.length && f[E] == 0; ) E += 1;
            for (var S = new Array(f.length - E + g), v = 0; v < f.length - E; v += 1) S[v] = f[v + E];
            return S;
          }(), x = { getAt: function(E) {
            return b[E];
          }, getLength: function() {
            return b.length;
          }, multiply: function(E) {
            for (var S = new Array(x.getLength() + E.getLength() - 1), v = 0; v < x.getLength(); v += 1) for (var M = 0; M < E.getLength(); M += 1) S[v + M] ^= q.gexp(q.glog(x.getAt(v)) + q.glog(E.getAt(M)));
            return U(S, 0);
          }, mod: function(E) {
            if (x.getLength() - E.getLength() < 0) return x;
            for (var S = q.glog(x.getAt(0)) - q.glog(E.getAt(0)), v = new Array(x.getLength()), M = 0; M < x.getLength(); M += 1) v[M] = x.getAt(M);
            for (M = 0; M < E.getLength(); M += 1) v[M] ^= q.gexp(q.glog(E.getAt(M)) + S);
            return U(v, 0).mod(E);
          } };
          return x;
        }
        var V = /* @__PURE__ */ function() {
          var f = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]], g = function(x, E) {
            var S = {};
            return S.totalCount = x, S.dataCount = E, S;
          }, b = { getRSBlocks: function(x, E) {
            var S = function(Z, J) {
              switch (J) {
                case B.L:
                  return f[4 * (Z - 1) + 0];
                case B.M:
                  return f[4 * (Z - 1) + 1];
                case B.Q:
                  return f[4 * (Z - 1) + 2];
                case B.H:
                  return f[4 * (Z - 1) + 3];
                default:
                  return;
              }
            }(x, E);
            if (S === void 0) throw "bad rs block @ typeNumber:" + x + "/errorCorrectionLevel:" + E;
            for (var v = S.length / 3, M = [], I = 0; I < v; I += 1) for (var F = S[3 * I + 0], ce = S[3 * I + 1], D = S[3 * I + 2], oe = 0; oe < F; oe += 1) M.push(g(ce, D));
            return M;
          } };
          return b;
        }(), Q = function() {
          var f = [], g = 0, b = { getBuffer: function() {
            return f;
          }, getAt: function(x) {
            var E = Math.floor(x / 8);
            return (f[E] >>> 7 - x % 8 & 1) == 1;
          }, put: function(x, E) {
            for (var S = 0; S < E; S += 1) b.putBit((x >>> E - S - 1 & 1) == 1);
          }, getLengthInBits: function() {
            return g;
          }, putBit: function(x) {
            var E = Math.floor(g / 8);
            f.length <= E && f.push(0), x && (f[E] |= 128 >>> g % 8), g += 1;
          } };
          return b;
        }, R = function(f) {
          var g = f, b = { getMode: function() {
            return 1;
          }, getLength: function(S) {
            return g.length;
          }, write: function(S) {
            for (var v = g, M = 0; M + 2 < v.length; ) S.put(x(v.substring(M, M + 3)), 10), M += 3;
            M < v.length && (v.length - M == 1 ? S.put(x(v.substring(M, M + 1)), 4) : v.length - M == 2 && S.put(x(v.substring(M, M + 2)), 7));
          } }, x = function(S) {
            for (var v = 0, M = 0; M < S.length; M += 1) v = 10 * v + E(S.charAt(M));
            return v;
          }, E = function(S) {
            if ("0" <= S && S <= "9") return S.charCodeAt(0) - 48;
            throw "illegal char :" + S;
          };
          return b;
        }, K = function(f) {
          var g = f, b = { getMode: function() {
            return 2;
          }, getLength: function(E) {
            return g.length;
          }, write: function(E) {
            for (var S = g, v = 0; v + 1 < S.length; ) E.put(45 * x(S.charAt(v)) + x(S.charAt(v + 1)), 11), v += 2;
            v < S.length && E.put(x(S.charAt(v)), 6);
          } }, x = function(E) {
            if ("0" <= E && E <= "9") return E.charCodeAt(0) - 48;
            if ("A" <= E && E <= "Z") return E.charCodeAt(0) - 65 + 10;
            switch (E) {
              case " ":
                return 36;
              case "$":
                return 37;
              case "%":
                return 38;
              case "*":
                return 39;
              case "+":
                return 40;
              case "-":
                return 41;
              case ".":
                return 42;
              case "/":
                return 43;
              case ":":
                return 44;
              default:
                throw "illegal char :" + E;
            }
          };
          return b;
        }, ge = function(f) {
          var g = p.stringToBytes(f);
          return { getMode: function() {
            return 4;
          }, getLength: function(b) {
            return g.length;
          }, write: function(b) {
            for (var x = 0; x < g.length; x += 1) b.put(g[x], 8);
          } };
        }, Ee = function(f) {
          var g = p.stringToBytesFuncs.SJIS;
          if (!g) throw "sjis not supported.";
          (function() {
            var E = g("友");
            if (E.length != 2 || (E[0] << 8 | E[1]) != 38726) throw "sjis not supported.";
          })();
          var b = g(f), x = { getMode: function() {
            return 8;
          }, getLength: function(E) {
            return ~~(b.length / 2);
          }, write: function(E) {
            for (var S = b, v = 0; v + 1 < S.length; ) {
              var M = (255 & S[v]) << 8 | 255 & S[v + 1];
              if (33088 <= M && M <= 40956) M -= 33088;
              else {
                if (!(57408 <= M && M <= 60351)) throw "illegal char at " + (v + 1) + "/" + M;
                M -= 49472;
              }
              M = 192 * (M >>> 8 & 255) + (255 & M), E.put(M, 13), v += 2;
            }
            if (v < S.length) throw "illegal char at " + (v + 1);
          } };
          return x;
        }, Y = function() {
          var f = [], g = { writeByte: function(b) {
            f.push(255 & b);
          }, writeShort: function(b) {
            g.writeByte(b), g.writeByte(b >>> 8);
          }, writeBytes: function(b, x, E) {
            x = x || 0, E = E || b.length;
            for (var S = 0; S < E; S += 1) g.writeByte(b[S + x]);
          }, writeString: function(b) {
            for (var x = 0; x < b.length; x += 1) g.writeByte(b.charCodeAt(x));
          }, toByteArray: function() {
            return f;
          }, toString: function() {
            var b = "";
            b += "[";
            for (var x = 0; x < f.length; x += 1) x > 0 && (b += ","), b += f[x];
            return b + "]";
          } };
          return g;
        }, A = function(f) {
          var g = f, b = 0, x = 0, E = 0, S = { read: function() {
            for (; E < 8; ) {
              if (b >= g.length) {
                if (E == 0) return -1;
                throw "unexpected end of file./" + E;
              }
              var M = g.charAt(b);
              if (b += 1, M == "=") return E = 0, -1;
              M.match(/^\s$/) || (x = x << 6 | v(M.charCodeAt(0)), E += 6);
            }
            var I = x >>> E - 8 & 255;
            return E -= 8, I;
          } }, v = function(M) {
            if (65 <= M && M <= 90) return M - 65;
            if (97 <= M && M <= 122) return M - 97 + 26;
            if (48 <= M && M <= 57) return M - 48 + 52;
            if (M == 43) return 62;
            if (M == 47) return 63;
            throw "c:" + M;
          };
          return S;
        }, m = function(f, g, b) {
          for (var x = function(ce, D) {
            var oe = ce, Z = D, J = new Array(ce * D), ee = { setPixel: function(re, pe, ie) {
              J[pe * oe + re] = ie;
            }, write: function(re) {
              re.writeString("GIF87a"), re.writeShort(oe), re.writeShort(Z), re.writeByte(128), re.writeByte(0), re.writeByte(0), re.writeByte(0), re.writeByte(0), re.writeByte(0), re.writeByte(255), re.writeByte(255), re.writeByte(255), re.writeString(","), re.writeShort(0), re.writeShort(0), re.writeShort(oe), re.writeShort(Z), re.writeByte(0);
              var pe = T(2);
              re.writeByte(2);
              for (var ie = 0; pe.length - ie > 255; ) re.writeByte(255), re.writeBytes(pe, ie, 255), ie += 255;
              re.writeByte(pe.length - ie), re.writeBytes(pe, ie, pe.length - ie), re.writeByte(0), re.writeString(";");
            } }, T = function(re) {
              for (var pe = 1 << re, ie = 1 + (1 << re), ue = re + 1, ve = X(), Pe = 0; Pe < pe; Pe += 1) ve.add(String.fromCharCode(Pe));
              ve.add(String.fromCharCode(pe)), ve.add(String.fromCharCode(ie));
              var De, Ce, $e, Me = Y(), Ne = (De = Me, Ce = 0, $e = 0, { write: function(ze, _e) {
                if (ze >>> _e) throw "length over";
                for (; Ce + _e >= 8; ) De.writeByte(255 & (ze << Ce | $e)), _e -= 8 - Ce, ze >>>= 8 - Ce, $e = 0, Ce = 0;
                $e |= ze << Ce, Ce += _e;
              }, flush: function() {
                Ce > 0 && De.writeByte($e);
              } });
              Ne.write(pe, ue);
              var Ke = 0, Le = String.fromCharCode(J[Ke]);
              for (Ke += 1; Ke < J.length; ) {
                var qe = String.fromCharCode(J[Ke]);
                Ke += 1, ve.contains(Le + qe) ? Le += qe : (Ne.write(ve.indexOf(Le), ue), ve.size() < 4095 && (ve.size() == 1 << ue && (ue += 1), ve.add(Le + qe)), Le = qe);
              }
              return Ne.write(ve.indexOf(Le), ue), Ne.write(ie, ue), Ne.flush(), Me.toByteArray();
            }, X = function() {
              var re = {}, pe = 0, ie = { add: function(ue) {
                if (ie.contains(ue)) throw "dup key:" + ue;
                re[ue] = pe, pe += 1;
              }, size: function() {
                return pe;
              }, indexOf: function(ue) {
                return re[ue];
              }, contains: function(ue) {
                return re[ue] !== void 0;
              } };
              return ie;
            };
            return ee;
          }(f, g), E = 0; E < g; E += 1) for (var S = 0; S < f; S += 1) x.setPixel(S, E, b(S, E));
          var v = Y();
          x.write(v);
          for (var M = function() {
            var ce = 0, D = 0, oe = 0, Z = "", J = {}, ee = function(X) {
              Z += String.fromCharCode(T(63 & X));
            }, T = function(X) {
              if (!(X < 0)) {
                if (X < 26) return 65 + X;
                if (X < 52) return X - 26 + 97;
                if (X < 62) return X - 52 + 48;
                if (X == 62) return 43;
                if (X == 63) return 47;
              }
              throw "n:" + X;
            };
            return J.writeByte = function(X) {
              for (ce = ce << 8 | 255 & X, D += 8, oe += 1; D >= 6; ) ee(ce >>> D - 6), D -= 6;
            }, J.flush = function() {
              if (D > 0 && (ee(ce << 6 - D), ce = 0, D = 0), oe % 3 != 0) for (var X = 3 - oe % 3, re = 0; re < X; re += 1) Z += "=";
            }, J.toString = function() {
              return Z;
            }, J;
          }(), I = v.toByteArray(), F = 0; F < I.length; F += 1) M.writeByte(I[F]);
          return M.flush(), "data:image/gif;base64," + M;
        };
        return p;
      }();
      d.stringToBytesFuncs["UTF-8"] = function(p) {
        return function(w) {
          for (var _ = [], P = 0; P < w.length; P++) {
            var O = w.charCodeAt(P);
            O < 128 ? _.push(O) : O < 2048 ? _.push(192 | O >> 6, 128 | 63 & O) : O < 55296 || O >= 57344 ? _.push(224 | O >> 12, 128 | O >> 6 & 63, 128 | 63 & O) : (P++, O = 65536 + ((1023 & O) << 10 | 1023 & w.charCodeAt(P)), _.push(240 | O >> 18, 128 | O >> 12 & 63, 128 | O >> 6 & 63, 128 | 63 & O));
          }
          return _;
        }(p);
      }, (l = typeof (u = function() {
        return d;
      }) == "function" ? u.apply(a, []) : u) === void 0 || (o.exports = l);
    } }, n = {};
    function i(o) {
      var a = n[o];
      if (a !== void 0) return a.exports;
      var u = n[o] = { exports: {} };
      return r[o](u, u.exports, i), u.exports;
    }
    i.n = (o) => {
      var a = o && o.__esModule ? () => o.default : () => o;
      return i.d(a, { a }), a;
    }, i.d = (o, a) => {
      for (var u in a) i.o(a, u) && !i.o(o, u) && Object.defineProperty(o, u, { enumerable: !0, get: a[u] });
    }, i.o = (o, a) => Object.prototype.hasOwnProperty.call(o, a);
    var s = {};
    return (() => {
      i.d(s, { default: () => Y });
      const o = (A) => !!A && typeof A == "object" && !Array.isArray(A);
      function a(A, ...m) {
        if (!m.length) return A;
        const f = m.shift();
        return f !== void 0 && o(A) && o(f) ? (A = Object.assign({}, A), Object.keys(f).forEach((g) => {
          const b = A[g], x = f[g];
          Array.isArray(b) && Array.isArray(x) ? A[g] = x : o(b) && o(x) ? A[g] = a(Object.assign({}, b), x) : A[g] = x;
        }), a(A, ...m)) : A;
      }
      function u(A, m) {
        const f = document.createElement("a");
        f.download = m, f.href = A, document.body.appendChild(f), f.click(), document.body.removeChild(f);
      }
      const l = { L: 0.07, M: 0.15, Q: 0.25, H: 0.3 };
      class d {
        constructor({ svg: m, type: f, window: g }) {
          this._svg = m, this._type = f, this._window = g;
        }
        draw(m, f, g, b) {
          let x;
          switch (this._type) {
            case "dots":
              x = this._drawDot;
              break;
            case "classy":
              x = this._drawClassy;
              break;
            case "classy-rounded":
              x = this._drawClassyRounded;
              break;
            case "rounded":
              x = this._drawRounded;
              break;
            case "extra-rounded":
              x = this._drawExtraRounded;
              break;
            default:
              x = this._drawSquare;
          }
          x.call(this, { x: m, y: f, size: g, getNeighbor: b });
        }
        _rotateFigure({ x: m, y: f, size: g, rotation: b = 0, draw: x }) {
          var E;
          const S = m + g / 2, v = f + g / 2;
          x(), (E = this._element) === null || E === void 0 || E.setAttribute("transform", `rotate(${180 * b / Math.PI},${S},${v})`);
        }
        _basicDot(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "circle"), this._element.setAttribute("cx", String(g + f / 2)), this._element.setAttribute("cy", String(b + f / 2)), this._element.setAttribute("r", String(f / 2));
          } }));
        }
        _basicSquare(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect"), this._element.setAttribute("x", String(g)), this._element.setAttribute("y", String(b)), this._element.setAttribute("width", String(f)), this._element.setAttribute("height", String(f));
          } }));
        }
        _basicSideRounded(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${g} ${b}v ${f}h ` + f / 2 + `a ${f / 2} ${f / 2}, 0, 0, 0, 0 ${-f}`);
          } }));
        }
        _basicCornerRounded(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${g} ${b}v ${f}h ${f}v ` + -f / 2 + `a ${f / 2} ${f / 2}, 0, 0, 0, ${-f / 2} ${-f / 2}`);
          } }));
        }
        _basicCornerExtraRounded(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${g} ${b}v ${f}h ${f}a ${f} ${f}, 0, 0, 0, ${-f} ${-f}`);
          } }));
        }
        _basicCornersRounded(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${g} ${b}v ` + f / 2 + `a ${f / 2} ${f / 2}, 0, 0, 0, ${f / 2} ${f / 2}h ` + f / 2 + "v " + -f / 2 + `a ${f / 2} ${f / 2}, 0, 0, 0, ${-f / 2} ${-f / 2}`);
          } }));
        }
        _drawDot({ x: m, y: f, size: g }) {
          this._basicDot({ x: m, y: f, size: g, rotation: 0 });
        }
        _drawSquare({ x: m, y: f, size: g }) {
          this._basicSquare({ x: m, y: f, size: g, rotation: 0 });
        }
        _drawRounded({ x: m, y: f, size: g, getNeighbor: b }) {
          const x = b ? +b(-1, 0) : 0, E = b ? +b(1, 0) : 0, S = b ? +b(0, -1) : 0, v = b ? +b(0, 1) : 0, M = x + E + S + v;
          if (M !== 0) if (M > 2 || x && E || S && v) this._basicSquare({ x: m, y: f, size: g, rotation: 0 });
          else {
            if (M === 2) {
              let I = 0;
              return x && S ? I = Math.PI / 2 : S && E ? I = Math.PI : E && v && (I = -Math.PI / 2), void this._basicCornerRounded({ x: m, y: f, size: g, rotation: I });
            }
            if (M === 1) {
              let I = 0;
              return S ? I = Math.PI / 2 : E ? I = Math.PI : v && (I = -Math.PI / 2), void this._basicSideRounded({ x: m, y: f, size: g, rotation: I });
            }
          }
          else this._basicDot({ x: m, y: f, size: g, rotation: 0 });
        }
        _drawExtraRounded({ x: m, y: f, size: g, getNeighbor: b }) {
          const x = b ? +b(-1, 0) : 0, E = b ? +b(1, 0) : 0, S = b ? +b(0, -1) : 0, v = b ? +b(0, 1) : 0, M = x + E + S + v;
          if (M !== 0) if (M > 2 || x && E || S && v) this._basicSquare({ x: m, y: f, size: g, rotation: 0 });
          else {
            if (M === 2) {
              let I = 0;
              return x && S ? I = Math.PI / 2 : S && E ? I = Math.PI : E && v && (I = -Math.PI / 2), void this._basicCornerExtraRounded({ x: m, y: f, size: g, rotation: I });
            }
            if (M === 1) {
              let I = 0;
              return S ? I = Math.PI / 2 : E ? I = Math.PI : v && (I = -Math.PI / 2), void this._basicSideRounded({ x: m, y: f, size: g, rotation: I });
            }
          }
          else this._basicDot({ x: m, y: f, size: g, rotation: 0 });
        }
        _drawClassy({ x: m, y: f, size: g, getNeighbor: b }) {
          const x = b ? +b(-1, 0) : 0, E = b ? +b(1, 0) : 0, S = b ? +b(0, -1) : 0, v = b ? +b(0, 1) : 0;
          x + E + S + v !== 0 ? x || S ? E || v ? this._basicSquare({ x: m, y: f, size: g, rotation: 0 }) : this._basicCornerRounded({ x: m, y: f, size: g, rotation: Math.PI / 2 }) : this._basicCornerRounded({ x: m, y: f, size: g, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: m, y: f, size: g, rotation: Math.PI / 2 });
        }
        _drawClassyRounded({ x: m, y: f, size: g, getNeighbor: b }) {
          const x = b ? +b(-1, 0) : 0, E = b ? +b(1, 0) : 0, S = b ? +b(0, -1) : 0, v = b ? +b(0, 1) : 0;
          x + E + S + v !== 0 ? x || S ? E || v ? this._basicSquare({ x: m, y: f, size: g, rotation: 0 }) : this._basicCornerExtraRounded({ x: m, y: f, size: g, rotation: Math.PI / 2 }) : this._basicCornerExtraRounded({ x: m, y: f, size: g, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: m, y: f, size: g, rotation: Math.PI / 2 });
        }
      }
      class p {
        constructor({ svg: m, type: f, window: g }) {
          this._svg = m, this._type = f, this._window = g;
        }
        draw(m, f, g, b) {
          let x;
          switch (this._type) {
            case "square":
              x = this._drawSquare;
              break;
            case "extra-rounded":
              x = this._drawExtraRounded;
              break;
            default:
              x = this._drawDot;
          }
          x.call(this, { x: m, y: f, size: g, rotation: b });
        }
        _rotateFigure({ x: m, y: f, size: g, rotation: b = 0, draw: x }) {
          var E;
          const S = m + g / 2, v = f + g / 2;
          x(), (E = this._element) === null || E === void 0 || E.setAttribute("transform", `rotate(${180 * b / Math.PI},${S},${v})`);
        }
        _basicDot(m) {
          const { size: f, x: g, y: b } = m, x = f / 7;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${g + f / 2} ${b}a ${f / 2} ${f / 2} 0 1 0 0.1 0zm 0 ${x}a ${f / 2 - x} ${f / 2 - x} 0 1 1 -0.1 0Z`);
          } }));
        }
        _basicSquare(m) {
          const { size: f, x: g, y: b } = m, x = f / 7;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${g} ${b}v ${f}h ${f}v ` + -f + `zM ${g + x} ${b + x}h ` + (f - 2 * x) + "v " + (f - 2 * x) + "h " + (2 * x - f) + "z");
          } }));
        }
        _basicExtraRounded(m) {
          const { size: f, x: g, y: b } = m, x = f / 7;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${g} ${b + 2.5 * x}v ` + 2 * x + `a ${2.5 * x} ${2.5 * x}, 0, 0, 0, ${2.5 * x} ${2.5 * x}h ` + 2 * x + `a ${2.5 * x} ${2.5 * x}, 0, 0, 0, ${2.5 * x} ${2.5 * -x}v ` + -2 * x + `a ${2.5 * x} ${2.5 * x}, 0, 0, 0, ${2.5 * -x} ${2.5 * -x}h ` + -2 * x + `a ${2.5 * x} ${2.5 * x}, 0, 0, 0, ${2.5 * -x} ${2.5 * x}M ${g + 2.5 * x} ${b + x}h ` + 2 * x + `a ${1.5 * x} ${1.5 * x}, 0, 0, 1, ${1.5 * x} ${1.5 * x}v ` + 2 * x + `a ${1.5 * x} ${1.5 * x}, 0, 0, 1, ${1.5 * -x} ${1.5 * x}h ` + -2 * x + `a ${1.5 * x} ${1.5 * x}, 0, 0, 1, ${1.5 * -x} ${1.5 * -x}v ` + -2 * x + `a ${1.5 * x} ${1.5 * x}, 0, 0, 1, ${1.5 * x} ${1.5 * -x}`);
          } }));
        }
        _drawDot({ x: m, y: f, size: g, rotation: b }) {
          this._basicDot({ x: m, y: f, size: g, rotation: b });
        }
        _drawSquare({ x: m, y: f, size: g, rotation: b }) {
          this._basicSquare({ x: m, y: f, size: g, rotation: b });
        }
        _drawExtraRounded({ x: m, y: f, size: g, rotation: b }) {
          this._basicExtraRounded({ x: m, y: f, size: g, rotation: b });
        }
      }
      class w {
        constructor({ svg: m, type: f, window: g }) {
          this._svg = m, this._type = f, this._window = g;
        }
        draw(m, f, g, b) {
          let x;
          x = this._type === "square" ? this._drawSquare : this._drawDot, x.call(this, { x: m, y: f, size: g, rotation: b });
        }
        _rotateFigure({ x: m, y: f, size: g, rotation: b = 0, draw: x }) {
          var E;
          const S = m + g / 2, v = f + g / 2;
          x(), (E = this._element) === null || E === void 0 || E.setAttribute("transform", `rotate(${180 * b / Math.PI},${S},${v})`);
        }
        _basicDot(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "circle"), this._element.setAttribute("cx", String(g + f / 2)), this._element.setAttribute("cy", String(b + f / 2)), this._element.setAttribute("r", String(f / 2));
          } }));
        }
        _basicSquare(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect"), this._element.setAttribute("x", String(g)), this._element.setAttribute("y", String(b)), this._element.setAttribute("width", String(f)), this._element.setAttribute("height", String(f));
          } }));
        }
        _drawDot({ x: m, y: f, size: g, rotation: b }) {
          this._basicDot({ x: m, y: f, size: g, rotation: b });
        }
        _drawSquare({ x: m, y: f, size: g, rotation: b }) {
          this._basicSquare({ x: m, y: f, size: g, rotation: b });
        }
      }
      const _ = "circle", P = [[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]], O = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]];
      class L {
        constructor(m, f) {
          this._roundSize = (g) => this._options.dotsOptions.roundSize ? Math.floor(g) : g, this._window = f, this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._element.setAttribute("width", String(m.width)), this._element.setAttribute("height", String(m.height)), this._element.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), m.dotsOptions.roundSize || this._element.setAttribute("shape-rendering", "crispEdges"), this._element.setAttribute("viewBox", `0 0 ${m.width} ${m.height}`), this._defs = this._window.document.createElementNS("http://www.w3.org/2000/svg", "defs"), this._element.appendChild(this._defs), this._imageUri = m.image, this._instanceId = L.instanceCount++, this._options = m;
        }
        get width() {
          return this._options.width;
        }
        get height() {
          return this._options.height;
        }
        getElement() {
          return this._element;
        }
        async drawQR(m) {
          const f = m.getModuleCount(), g = Math.min(this._options.width, this._options.height) - 2 * this._options.margin, b = this._options.shape === _ ? g / Math.sqrt(2) : g, x = this._roundSize(b / f);
          let E = { hideXDots: 0, hideYDots: 0, width: 0, height: 0 };
          if (this._qr = m, this._options.image) {
            if (await this.loadImage(), !this._image) return;
            const { imageOptions: S, qrOptions: v } = this._options, M = S.imageSize * l[v.errorCorrectionLevel], I = Math.floor(M * f * f);
            E = function({ originalHeight: F, originalWidth: ce, maxHiddenDots: D, maxHiddenAxisDots: oe, dotSize: Z }) {
              const J = { x: 0, y: 0 }, ee = { x: 0, y: 0 };
              if (F <= 0 || ce <= 0 || D <= 0 || Z <= 0) return { height: 0, width: 0, hideYDots: 0, hideXDots: 0 };
              const T = F / ce;
              return J.x = Math.floor(Math.sqrt(D / T)), J.x <= 0 && (J.x = 1), oe && oe < J.x && (J.x = oe), J.x % 2 == 0 && J.x--, ee.x = J.x * Z, J.y = 1 + 2 * Math.ceil((J.x * T - 1) / 2), ee.y = Math.round(ee.x * T), (J.y * J.x > D || oe && oe < J.y) && (oe && oe < J.y ? (J.y = oe, J.y % 2 == 0 && J.x--) : J.y -= 2, ee.y = J.y * Z, J.x = 1 + 2 * Math.ceil((J.y / T - 1) / 2), ee.x = Math.round(ee.y / T)), { height: ee.y, width: ee.x, hideYDots: J.y, hideXDots: J.x };
            }({ originalWidth: this._image.width, originalHeight: this._image.height, maxHiddenDots: I, maxHiddenAxisDots: f - 14, dotSize: x });
          }
          this.drawBackground(), this.drawDots((S, v) => {
            var M, I, F, ce, D, oe;
            return !(this._options.imageOptions.hideBackgroundDots && S >= (f - E.hideYDots) / 2 && S < (f + E.hideYDots) / 2 && v >= (f - E.hideXDots) / 2 && v < (f + E.hideXDots) / 2 || !((M = P[S]) === null || M === void 0) && M[v] || !((I = P[S - f + 7]) === null || I === void 0) && I[v] || !((F = P[S]) === null || F === void 0) && F[v - f + 7] || !((ce = O[S]) === null || ce === void 0) && ce[v] || !((D = O[S - f + 7]) === null || D === void 0) && D[v] || !((oe = O[S]) === null || oe === void 0) && oe[v - f + 7]);
          }), this.drawCorners(), this._options.image && await this.drawImage({ width: E.width, height: E.height, count: f, dotSize: x });
        }
        drawBackground() {
          var m, f, g;
          const b = this._element, x = this._options;
          if (b) {
            const E = (m = x.backgroundOptions) === null || m === void 0 ? void 0 : m.gradient, S = (f = x.backgroundOptions) === null || f === void 0 ? void 0 : f.color;
            let v = x.height, M = x.width;
            if (E || S) {
              const I = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
              this._backgroundClipPath = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._backgroundClipPath.setAttribute("id", `clip-path-background-color-${this._instanceId}`), this._defs.appendChild(this._backgroundClipPath), !((g = x.backgroundOptions) === null || g === void 0) && g.round && (v = M = Math.min(x.width, x.height), I.setAttribute("rx", String(v / 2 * x.backgroundOptions.round))), I.setAttribute("x", String(this._roundSize((x.width - M) / 2))), I.setAttribute("y", String(this._roundSize((x.height - v) / 2))), I.setAttribute("width", String(M)), I.setAttribute("height", String(v)), this._backgroundClipPath.appendChild(I), this._createColor({ options: E, color: S, additionalRotation: 0, x: 0, y: 0, height: x.height, width: x.width, name: `background-color-${this._instanceId}` });
            }
          }
        }
        drawDots(m) {
          var f, g;
          if (!this._qr) throw "QR code is not defined";
          const b = this._options, x = this._qr.getModuleCount();
          if (x > b.width || x > b.height) throw "The canvas is too small.";
          const E = Math.min(b.width, b.height) - 2 * b.margin, S = b.shape === _ ? E / Math.sqrt(2) : E, v = this._roundSize(S / x), M = this._roundSize((b.width - x * v) / 2), I = this._roundSize((b.height - x * v) / 2), F = new d({ svg: this._element, type: b.dotsOptions.type, window: this._window });
          this._dotsClipPath = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._dotsClipPath.setAttribute("id", `clip-path-dot-color-${this._instanceId}`), this._defs.appendChild(this._dotsClipPath), this._createColor({ options: (f = b.dotsOptions) === null || f === void 0 ? void 0 : f.gradient, color: b.dotsOptions.color, additionalRotation: 0, x: 0, y: 0, height: b.height, width: b.width, name: `dot-color-${this._instanceId}` });
          for (let ce = 0; ce < x; ce++) for (let D = 0; D < x; D++) m && !m(ce, D) || !((g = this._qr) === null || g === void 0) && g.isDark(ce, D) && (F.draw(M + D * v, I + ce * v, v, (oe, Z) => !(D + oe < 0 || ce + Z < 0 || D + oe >= x || ce + Z >= x) && !(m && !m(ce + Z, D + oe)) && !!this._qr && this._qr.isDark(ce + Z, D + oe)), F._element && this._dotsClipPath && this._dotsClipPath.appendChild(F._element));
          if (b.shape === _) {
            const ce = this._roundSize((E / v - x) / 2), D = x + 2 * ce, oe = M - ce * v, Z = I - ce * v, J = [], ee = this._roundSize(D / 2);
            for (let T = 0; T < D; T++) {
              J[T] = [];
              for (let X = 0; X < D; X++) T >= ce - 1 && T <= D - ce && X >= ce - 1 && X <= D - ce || Math.sqrt((T - ee) * (T - ee) + (X - ee) * (X - ee)) > ee ? J[T][X] = 0 : J[T][X] = this._qr.isDark(X - 2 * ce < 0 ? X : X >= x ? X - 2 * ce : X - ce, T - 2 * ce < 0 ? T : T >= x ? T - 2 * ce : T - ce) ? 1 : 0;
            }
            for (let T = 0; T < D; T++) for (let X = 0; X < D; X++) J[T][X] && (F.draw(oe + X * v, Z + T * v, v, (re, pe) => {
              var ie;
              return !!(!((ie = J[T + pe]) === null || ie === void 0) && ie[X + re]);
            }), F._element && this._dotsClipPath && this._dotsClipPath.appendChild(F._element));
          }
        }
        drawCorners() {
          if (!this._qr) throw "QR code is not defined";
          const m = this._element, f = this._options;
          if (!m) throw "Element code is not defined";
          const g = this._qr.getModuleCount(), b = Math.min(f.width, f.height) - 2 * f.margin, x = f.shape === _ ? b / Math.sqrt(2) : b, E = this._roundSize(x / g), S = 7 * E, v = 3 * E, M = this._roundSize((f.width - g * E) / 2), I = this._roundSize((f.height - g * E) / 2);
          [[0, 0, 0], [1, 0, Math.PI / 2], [0, 1, -Math.PI / 2]].forEach(([F, ce, D]) => {
            var oe, Z, J, ee, T, X, re, pe, ie, ue, ve, Pe;
            const De = M + F * E * (g - 7), Ce = I + ce * E * (g - 7);
            let $e = this._dotsClipPath, Me = this._dotsClipPath;
            if ((!((oe = f.cornersSquareOptions) === null || oe === void 0) && oe.gradient || !((Z = f.cornersSquareOptions) === null || Z === void 0) && Z.color) && ($e = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), $e.setAttribute("id", `clip-path-corners-square-color-${F}-${ce}-${this._instanceId}`), this._defs.appendChild($e), this._cornersSquareClipPath = this._cornersDotClipPath = Me = $e, this._createColor({ options: (J = f.cornersSquareOptions) === null || J === void 0 ? void 0 : J.gradient, color: (ee = f.cornersSquareOptions) === null || ee === void 0 ? void 0 : ee.color, additionalRotation: D, x: De, y: Ce, height: S, width: S, name: `corners-square-color-${F}-${ce}-${this._instanceId}` })), (T = f.cornersSquareOptions) === null || T === void 0 ? void 0 : T.type) {
              const Ne = new p({ svg: this._element, type: f.cornersSquareOptions.type, window: this._window });
              Ne.draw(De, Ce, S, D), Ne._element && $e && $e.appendChild(Ne._element);
            } else {
              const Ne = new d({ svg: this._element, type: f.dotsOptions.type, window: this._window });
              for (let Ke = 0; Ke < P.length; Ke++) for (let Le = 0; Le < P[Ke].length; Le++) !((X = P[Ke]) === null || X === void 0) && X[Le] && (Ne.draw(De + Le * E, Ce + Ke * E, E, (qe, ze) => {
                var _e;
                return !!(!((_e = P[Ke + ze]) === null || _e === void 0) && _e[Le + qe]);
              }), Ne._element && $e && $e.appendChild(Ne._element));
            }
            if ((!((re = f.cornersDotOptions) === null || re === void 0) && re.gradient || !((pe = f.cornersDotOptions) === null || pe === void 0) && pe.color) && (Me = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), Me.setAttribute("id", `clip-path-corners-dot-color-${F}-${ce}-${this._instanceId}`), this._defs.appendChild(Me), this._cornersDotClipPath = Me, this._createColor({ options: (ie = f.cornersDotOptions) === null || ie === void 0 ? void 0 : ie.gradient, color: (ue = f.cornersDotOptions) === null || ue === void 0 ? void 0 : ue.color, additionalRotation: D, x: De + 2 * E, y: Ce + 2 * E, height: v, width: v, name: `corners-dot-color-${F}-${ce}-${this._instanceId}` })), (ve = f.cornersDotOptions) === null || ve === void 0 ? void 0 : ve.type) {
              const Ne = new w({ svg: this._element, type: f.cornersDotOptions.type, window: this._window });
              Ne.draw(De + 2 * E, Ce + 2 * E, v, D), Ne._element && Me && Me.appendChild(Ne._element);
            } else {
              const Ne = new d({ svg: this._element, type: f.dotsOptions.type, window: this._window });
              for (let Ke = 0; Ke < O.length; Ke++) for (let Le = 0; Le < O[Ke].length; Le++) !((Pe = O[Ke]) === null || Pe === void 0) && Pe[Le] && (Ne.draw(De + Le * E, Ce + Ke * E, E, (qe, ze) => {
                var _e;
                return !!(!((_e = O[Ke + ze]) === null || _e === void 0) && _e[Le + qe]);
              }), Ne._element && Me && Me.appendChild(Ne._element));
            }
          });
        }
        loadImage() {
          return new Promise((m, f) => {
            var g;
            const b = this._options;
            if (!b.image) return f("Image is not defined");
            if (!((g = b.nodeCanvas) === null || g === void 0) && g.loadImage) b.nodeCanvas.loadImage(b.image).then((x) => {
              var E, S;
              if (this._image = x, this._options.imageOptions.saveAsBlob) {
                const v = (E = b.nodeCanvas) === null || E === void 0 ? void 0 : E.createCanvas(this._image.width, this._image.height);
                (S = v == null ? void 0 : v.getContext("2d")) === null || S === void 0 || S.drawImage(x, 0, 0), this._imageUri = v == null ? void 0 : v.toDataURL();
              }
              m();
            }).catch(f);
            else {
              const x = new this._window.Image();
              typeof b.imageOptions.crossOrigin == "string" && (x.crossOrigin = b.imageOptions.crossOrigin), this._image = x, x.onload = async () => {
                this._options.imageOptions.saveAsBlob && (this._imageUri = await async function(E, S) {
                  return new Promise((v) => {
                    const M = new S.XMLHttpRequest();
                    M.onload = function() {
                      const I = new S.FileReader();
                      I.onloadend = function() {
                        v(I.result);
                      }, I.readAsDataURL(M.response);
                    }, M.open("GET", E), M.responseType = "blob", M.send();
                  });
                }(b.image || "", this._window)), m();
              }, x.src = b.image;
            }
          });
        }
        async drawImage({ width: m, height: f, count: g, dotSize: b }) {
          const x = this._options, E = this._roundSize((x.width - g * b) / 2), S = this._roundSize((x.height - g * b) / 2), v = E + this._roundSize(x.imageOptions.margin + (g * b - m) / 2), M = S + this._roundSize(x.imageOptions.margin + (g * b - f) / 2), I = m - 2 * x.imageOptions.margin, F = f - 2 * x.imageOptions.margin, ce = this._window.document.createElementNS("http://www.w3.org/2000/svg", "image");
          ce.setAttribute("href", this._imageUri || ""), ce.setAttribute("x", String(v)), ce.setAttribute("y", String(M)), ce.setAttribute("width", `${I}px`), ce.setAttribute("height", `${F}px`), this._element.appendChild(ce);
        }
        _createColor({ options: m, color: f, additionalRotation: g, x: b, y: x, height: E, width: S, name: v }) {
          const M = S > E ? S : E, I = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
          if (I.setAttribute("x", String(b)), I.setAttribute("y", String(x)), I.setAttribute("height", String(E)), I.setAttribute("width", String(S)), I.setAttribute("clip-path", `url('#clip-path-${v}')`), m) {
            let F;
            if (m.type === "radial") F = this._window.document.createElementNS("http://www.w3.org/2000/svg", "radialGradient"), F.setAttribute("id", v), F.setAttribute("gradientUnits", "userSpaceOnUse"), F.setAttribute("fx", String(b + S / 2)), F.setAttribute("fy", String(x + E / 2)), F.setAttribute("cx", String(b + S / 2)), F.setAttribute("cy", String(x + E / 2)), F.setAttribute("r", String(M / 2));
            else {
              const ce = ((m.rotation || 0) + g) % (2 * Math.PI), D = (ce + 2 * Math.PI) % (2 * Math.PI);
              let oe = b + S / 2, Z = x + E / 2, J = b + S / 2, ee = x + E / 2;
              D >= 0 && D <= 0.25 * Math.PI || D > 1.75 * Math.PI && D <= 2 * Math.PI ? (oe -= S / 2, Z -= E / 2 * Math.tan(ce), J += S / 2, ee += E / 2 * Math.tan(ce)) : D > 0.25 * Math.PI && D <= 0.75 * Math.PI ? (Z -= E / 2, oe -= S / 2 / Math.tan(ce), ee += E / 2, J += S / 2 / Math.tan(ce)) : D > 0.75 * Math.PI && D <= 1.25 * Math.PI ? (oe += S / 2, Z += E / 2 * Math.tan(ce), J -= S / 2, ee -= E / 2 * Math.tan(ce)) : D > 1.25 * Math.PI && D <= 1.75 * Math.PI && (Z += E / 2, oe += S / 2 / Math.tan(ce), ee -= E / 2, J -= S / 2 / Math.tan(ce)), F = this._window.document.createElementNS("http://www.w3.org/2000/svg", "linearGradient"), F.setAttribute("id", v), F.setAttribute("gradientUnits", "userSpaceOnUse"), F.setAttribute("x1", String(Math.round(oe))), F.setAttribute("y1", String(Math.round(Z))), F.setAttribute("x2", String(Math.round(J))), F.setAttribute("y2", String(Math.round(ee)));
            }
            m.colorStops.forEach(({ offset: ce, color: D }) => {
              const oe = this._window.document.createElementNS("http://www.w3.org/2000/svg", "stop");
              oe.setAttribute("offset", 100 * ce + "%"), oe.setAttribute("stop-color", D), F.appendChild(oe);
            }), I.setAttribute("fill", `url('#${v}')`), this._defs.appendChild(F);
          } else f && I.setAttribute("fill", f);
          this._element.appendChild(I);
        }
      }
      L.instanceCount = 0;
      const B = L, k = "canvas", q = {};
      for (let A = 0; A <= 40; A++) q[A] = A;
      const U = { type: k, shape: "square", width: 300, height: 300, data: "", margin: 0, qrOptions: { typeNumber: q[0], mode: void 0, errorCorrectionLevel: "Q" }, imageOptions: { saveAsBlob: !0, hideBackgroundDots: !0, imageSize: 0.4, crossOrigin: void 0, margin: 0 }, dotsOptions: { type: "square", color: "#000", roundSize: !0 }, backgroundOptions: { round: 0, color: "#fff" } };
      function V(A) {
        const m = Object.assign({}, A);
        if (!m.colorStops || !m.colorStops.length) throw "Field 'colorStops' is required in gradient";
        return m.rotation ? m.rotation = Number(m.rotation) : m.rotation = 0, m.colorStops = m.colorStops.map((f) => Object.assign(Object.assign({}, f), { offset: Number(f.offset) })), m;
      }
      function Q(A) {
        const m = Object.assign({}, A);
        return m.width = Number(m.width), m.height = Number(m.height), m.margin = Number(m.margin), m.imageOptions = Object.assign(Object.assign({}, m.imageOptions), { hideBackgroundDots: !!m.imageOptions.hideBackgroundDots, imageSize: Number(m.imageOptions.imageSize), margin: Number(m.imageOptions.margin) }), m.margin > Math.min(m.width, m.height) && (m.margin = Math.min(m.width, m.height)), m.dotsOptions = Object.assign({}, m.dotsOptions), m.dotsOptions.gradient && (m.dotsOptions.gradient = V(m.dotsOptions.gradient)), m.cornersSquareOptions && (m.cornersSquareOptions = Object.assign({}, m.cornersSquareOptions), m.cornersSquareOptions.gradient && (m.cornersSquareOptions.gradient = V(m.cornersSquareOptions.gradient))), m.cornersDotOptions && (m.cornersDotOptions = Object.assign({}, m.cornersDotOptions), m.cornersDotOptions.gradient && (m.cornersDotOptions.gradient = V(m.cornersDotOptions.gradient))), m.backgroundOptions && (m.backgroundOptions = Object.assign({}, m.backgroundOptions), m.backgroundOptions.gradient && (m.backgroundOptions.gradient = V(m.backgroundOptions.gradient))), m;
      }
      var R = i(873), K = i.n(R);
      function ge(A) {
        if (!A) throw new Error("Extension must be defined");
        A[0] === "." && (A = A.substring(1));
        const m = { bmp: "image/bmp", gif: "image/gif", ico: "image/vnd.microsoft.icon", jpeg: "image/jpeg", jpg: "image/jpeg", png: "image/png", svg: "image/svg+xml", tif: "image/tiff", tiff: "image/tiff", webp: "image/webp", pdf: "application/pdf" }[A.toLowerCase()];
        if (!m) throw new Error(`Extension "${A}" is not supported`);
        return m;
      }
      class Ee {
        constructor(m) {
          m != null && m.jsdom ? this._window = new m.jsdom("", { resources: "usable" }).window : this._window = window, this._options = m ? Q(a(U, m)) : U, this.update();
        }
        static _clearContainer(m) {
          m && (m.innerHTML = "");
        }
        _setupSvg() {
          if (!this._qr) return;
          const m = new B(this._options, this._window);
          this._svg = m.getElement(), this._svgDrawingPromise = m.drawQR(this._qr).then(() => {
            var f;
            this._svg && ((f = this._extension) === null || f === void 0 || f.call(this, m.getElement(), this._options));
          });
        }
        _setupCanvas() {
          var m, f;
          this._qr && (!((m = this._options.nodeCanvas) === null || m === void 0) && m.createCanvas ? (this._nodeCanvas = this._options.nodeCanvas.createCanvas(this._options.width, this._options.height), this._nodeCanvas.width = this._options.width, this._nodeCanvas.height = this._options.height) : (this._domCanvas = document.createElement("canvas"), this._domCanvas.width = this._options.width, this._domCanvas.height = this._options.height), this._setupSvg(), this._canvasDrawingPromise = (f = this._svgDrawingPromise) === null || f === void 0 ? void 0 : f.then(() => {
            var g;
            if (!this._svg) return;
            const b = this._svg, x = new this._window.XMLSerializer().serializeToString(b), E = btoa(x), S = `data:${ge("svg")};base64,${E}`;
            if (!((g = this._options.nodeCanvas) === null || g === void 0) && g.loadImage) return this._options.nodeCanvas.loadImage(S).then((v) => {
              var M, I;
              v.width = this._options.width, v.height = this._options.height, (I = (M = this._nodeCanvas) === null || M === void 0 ? void 0 : M.getContext("2d")) === null || I === void 0 || I.drawImage(v, 0, 0);
            });
            {
              const v = new this._window.Image();
              return new Promise((M) => {
                v.onload = () => {
                  var I, F;
                  (F = (I = this._domCanvas) === null || I === void 0 ? void 0 : I.getContext("2d")) === null || F === void 0 || F.drawImage(v, 0, 0), M();
                }, v.src = S;
              });
            }
          }));
        }
        async _getElement(m = "png") {
          if (!this._qr) throw "QR code is empty";
          return m.toLowerCase() === "svg" ? (this._svg && this._svgDrawingPromise || this._setupSvg(), await this._svgDrawingPromise, this._svg) : ((this._domCanvas || this._nodeCanvas) && this._canvasDrawingPromise || this._setupCanvas(), await this._canvasDrawingPromise, this._domCanvas || this._nodeCanvas);
        }
        update(m) {
          Ee._clearContainer(this._container), this._options = m ? Q(a(this._options, m)) : this._options, this._options.data && (this._qr = K()(this._options.qrOptions.typeNumber, this._options.qrOptions.errorCorrectionLevel), this._qr.addData(this._options.data, this._options.qrOptions.mode || function(f) {
            switch (!0) {
              case /^[0-9]*$/.test(f):
                return "Numeric";
              case /^[0-9A-Z $%*+\-./:]*$/.test(f):
                return "Alphanumeric";
              default:
                return "Byte";
            }
          }(this._options.data)), this._qr.make(), this._options.type === k ? this._setupCanvas() : this._setupSvg(), this.append(this._container));
        }
        append(m) {
          if (m) {
            if (typeof m.appendChild != "function") throw "Container should be a single DOM node";
            this._options.type === k ? this._domCanvas && m.appendChild(this._domCanvas) : this._svg && m.appendChild(this._svg), this._container = m;
          }
        }
        applyExtension(m) {
          if (!m) throw "Extension function should be defined.";
          this._extension = m, this.update();
        }
        deleteExtension() {
          this._extension = void 0, this.update();
        }
        async getRawData(m = "png") {
          if (!this._qr) throw "QR code is empty";
          const f = await this._getElement(m), g = ge(m);
          if (!f) return null;
          if (m.toLowerCase() === "svg") {
            const b = `<?xml version="1.0" standalone="no"?>\r
${new this._window.XMLSerializer().serializeToString(f)}`;
            return typeof Blob > "u" || this._options.jsdom ? Buffer.from(b) : new Blob([b], { type: g });
          }
          return new Promise((b) => {
            const x = f;
            if ("toBuffer" in x) if (g === "image/png") b(x.toBuffer(g));
            else if (g === "image/jpeg") b(x.toBuffer(g));
            else {
              if (g !== "application/pdf") throw Error("Unsupported extension");
              b(x.toBuffer(g));
            }
            else "toBlob" in x && x.toBlob(b, g, 1);
          });
        }
        async download(m) {
          if (!this._qr) throw "QR code is empty";
          if (typeof Blob > "u") throw "Cannot download in Node.js, call getRawData instead.";
          let f = "png", g = "qr";
          typeof m == "string" ? (f = m, console.warn("Extension is deprecated as argument for 'download' method, please pass object { name: '...', extension: '...' } as argument")) : typeof m == "object" && m !== null && (m.name && (g = m.name), m.extension && (f = m.extension));
          const b = await this._getElement(f);
          if (b) if (f.toLowerCase() === "svg") {
            let x = new XMLSerializer().serializeToString(b);
            x = `<?xml version="1.0" standalone="no"?>\r
` + x, u(`data:${ge(f)};charset=utf-8,${encodeURIComponent(x)}`, `${g}.svg`);
          } else u(b.toDataURL(ge(f)), `${g}.${f}`);
        }
      }
      const Y = Ee;
    })(), s.default;
  })());
})(hA);
var Aie = hA.exports;
const dA = /* @__PURE__ */ ns(Aie);
class aa extends gt {
  constructor(e) {
    const { docsPath: r, field: n, metaMessages: i } = e;
    super(`Invalid Sign-In with Ethereum message field "${n}".`, {
      docsPath: r,
      metaMessages: i,
      name: "SiweInvalidMessageFieldError"
    });
  }
}
function M5(t) {
  if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(t) || /%[^0-9a-f]/i.test(t) || /%[0-9a-f](:?[^0-9a-f]|$)/i.test(t))
    return !1;
  const e = Pie(t), r = e[1], n = e[2], i = e[3], s = e[4], o = e[5];
  if (!(r != null && r.length && i.length >= 0))
    return !1;
  if (n != null && n.length) {
    if (!(i.length === 0 || /^\//.test(i)))
      return !1;
  } else if (/^\/\//.test(i))
    return !1;
  if (!/^[a-z][a-z0-9\+\-\.]*$/.test(r.toLowerCase()))
    return !1;
  let a = "";
  return a += `${r}:`, n != null && n.length && (a += `//${n}`), a += i, s != null && s.length && (a += `?${s}`), o != null && o.length && (a += `#${o}`), a;
}
function Pie(t) {
  return t.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
}
function pA(t) {
  const { chainId: e, domain: r, expirationTime: n, issuedAt: i = /* @__PURE__ */ new Date(), nonce: s, notBefore: o, requestId: a, resources: u, scheme: l, uri: d, version: p } = t;
  {
    if (e !== Math.floor(e))
      throw new aa({
        field: "chainId",
        metaMessages: [
          "- Chain ID must be a EIP-155 chain ID.",
          "- See https://eips.ethereum.org/EIPS/eip-155",
          "",
          `Provided value: ${e}`
        ]
      });
    if (!(Mie.test(r) || Iie.test(r) || Cie.test(r)))
      throw new aa({
        field: "domain",
        metaMessages: [
          "- Domain must be an RFC 3986 authority.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${r}`
        ]
      });
    if (!Tie.test(s))
      throw new aa({
        field: "nonce",
        metaMessages: [
          "- Nonce must be at least 8 characters.",
          "- Nonce must be alphanumeric.",
          "",
          `Provided value: ${s}`
        ]
      });
    if (!M5(d))
      throw new aa({
        field: "uri",
        metaMessages: [
          "- URI must be a RFC 3986 URI referring to the resource that is the subject of the signing.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${d}`
        ]
      });
    if (p !== "1")
      throw new aa({
        field: "version",
        metaMessages: [
          "- Version must be '1'.",
          "",
          `Provided value: ${p}`
        ]
      });
    if (l && !Rie.test(l))
      throw new aa({
        field: "scheme",
        metaMessages: [
          "- Scheme must be an RFC 3986 URI scheme.",
          "- See https://www.rfc-editor.org/rfc/rfc3986#section-3.1",
          "",
          `Provided value: ${l}`
        ]
      });
    const B = t.statement;
    if (B != null && B.includes(`
`))
      throw new aa({
        field: "statement",
        metaMessages: [
          "- Statement must not include '\\n'.",
          "",
          `Provided value: ${B}`
        ]
      });
  }
  const w = Fv(t.address), _ = l ? `${l}://${r}` : r, P = t.statement ? `${t.statement}
` : "", O = `${_} wants you to sign in with your Ethereum account:
${w}

${P}`;
  let L = `URI: ${d}
Version: ${p}
Chain ID: ${e}
Nonce: ${s}
Issued At: ${i.toISOString()}`;
  if (n && (L += `
Expiration Time: ${n.toISOString()}`), o && (L += `
Not Before: ${o.toISOString()}`), a && (L += `
Request ID: ${a}`), u) {
    let B = `
Resources:`;
    for (const k of u) {
      if (!M5(k))
        throw new aa({
          field: "resources",
          metaMessages: [
            "- Every resource must be a RFC 3986 URI.",
            "- See https://www.rfc-editor.org/rfc/rfc3986",
            "",
            `Provided value: ${k}`
          ]
        });
      B += `
- ${k}`;
    }
    L += B;
  }
  return `${O}
${L}`;
}
const Mie = /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}(:[0-9]{1,5})?$/, Iie = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(:[0-9]{1,5})?$/, Cie = /^localhost(:[0-9]{1,5})?$/, Tie = /^[a-zA-Z0-9]{8,}$/, Rie = /^([a-zA-Z][a-zA-Z0-9+-.]*)$/, gA = "7a4434fefbcc9af474fb5c995e47d286", Die = {
  projectId: gA,
  metadata: {
    name: "codatta",
    description: "codatta",
    url: "https://codatta.io/",
    icons: ["https://avatars.githubusercontent.com/u/171659315"]
  }
}, Oie = {
  namespaces: {
    eip155: {
      methods: [
        "eth_sendTransaction",
        "eth_signTransaction",
        "eth_sign",
        "personal_sign",
        "eth_signTypedData"
      ],
      chains: ["eip155:1"],
      events: ["chainChanged", "accountsChanged", "disconnect"],
      rpcMap: {
        1: `https://rpc.walletconnect.com?chainId=eip155:1&projectId=${gA}`
      }
    }
  },
  skipPairing: !1
};
function Nie(t, e) {
  const r = window.location.host, n = window.location.href;
  return pA({
    address: t,
    chainId: 1,
    domain: r,
    nonce: e,
    uri: n,
    version: "1"
  });
}
function mA(t) {
  var ge, Ee, Y;
  const e = Qn(null), { wallet: r, onGetExtension: n, onSignFinish: i } = t, [s, o] = Yt(""), [a, u] = Yt(!1), [l, d] = Yt(""), [p, w] = Yt("scan"), _ = Qn(), [P, O] = Yt((ge = r.config) == null ? void 0 : ge.image), [L, B] = Yt(!1), { saveLastUsedWallet: k } = Tp();
  async function q(A) {
    var f, g, b, x;
    u(!0);
    const m = await yY.init(Die);
    m.session && await m.disconnect();
    try {
      if (w("scan"), m.on("display_uri", (ce) => {
        o(ce), u(!1), w("scan");
      }), m.on("error", (ce) => {
        console.log(ce);
      }), m.on("session_update", (ce) => {
        console.log("session_update", ce);
      }), !await m.connect(Oie)) throw new Error("Walletconnect init failed");
      const S = new Il(m);
      O(((f = S.config) == null ? void 0 : f.image) || ((g = A.config) == null ? void 0 : g.image));
      const v = await S.getAddress(), M = await ka.getNonce({ account_type: "block_chain" });
      console.log("get nonce", M);
      const I = Nie(v, M);
      w("sign");
      const F = await S.signMessage(I, v);
      w("waiting"), await i(S, {
        message: I,
        nonce: M,
        signature: F,
        address: v,
        wallet_name: ((b = S.config) == null ? void 0 : b.name) || ((x = A.config) == null ? void 0 : x.name) || ""
      }), k(S);
    } catch (E) {
      console.log("err", E), d(E.details || E.message);
    }
  }
  function U() {
    _.current = new dA({
      width: 264,
      height: 264,
      margin: 0,
      type: "svg",
      // image: wallet.config?.image,
      qrOptions: {
        errorCorrectionLevel: "M"
      },
      dotsOptions: {
        color: "black",
        type: "rounded"
      },
      backgroundOptions: {
        color: "transparent"
      }
    }), _.current.append(e.current);
  }
  function V(A) {
    var m;
    console.log(_.current), (m = _.current) == null || m.update({
      data: A
    });
  }
  Dn(() => {
    s && V(s);
  }, [s]), Dn(() => {
    q(r);
  }, [r]), Dn(() => {
    U();
  }, []);
  function Q() {
    d(""), V(""), q(r);
  }
  function R() {
    B(!0), navigator.clipboard.writeText(s), setTimeout(() => {
      B(!1);
    }, 2500);
  }
  function K() {
    var f;
    const A = (f = r.config) == null ? void 0 : f.desktop_link;
    if (!A) return;
    const m = `${A}?uri=${encodeURIComponent(s)}`;
    window.open(m, "_blank");
  }
  return /* @__PURE__ */ le.jsxs("div", { children: [
    /* @__PURE__ */ le.jsx("div", { className: "xc-text-center", children: /* @__PURE__ */ le.jsxs("div", { className: "xc-relative xc-mx-auto xc-mb-6 xc-block xc-max-h-[272px] xc-max-w-[272px] xc-rounded-xl xc-bg-white xc-p-1", children: [
      /* @__PURE__ */ le.jsx("div", { className: "xc-aspect-[1/1] xc-flex xc-h-full xc-w-full xc-justify-center", ref: e }),
      /* @__PURE__ */ le.jsx("div", { className: "xc-absolute xc-left-0 xc-top-0 xc-flex xc-h-full xc-w-full xc-items-center xc-justify-center", children: a ? /* @__PURE__ */ le.jsx(Sc, { className: "xc-h-6 xc-w-6 xc-animate-spin xc-text-black", size: 20 }) : /* @__PURE__ */ le.jsx("img", { className: "xc-h-10 xc-w-10", src: P }) })
    ] }) }),
    /* @__PURE__ */ le.jsxs("div", { className: "xc-m-auto xc-mb-6 xc-flex xc-max-w-[400px] xc-flex-wrap xc-items-center xc-justify-between xc-gap-3", children: [
      /* @__PURE__ */ le.jsx(
        "button",
        {
          disabled: !s,
          onClick: R,
          className: "xc-disabled:hover-text-white xc-flex xc-min-w-[160px] xc-flex-1 xc-shrink-0 xc-items-center xc-justify-center xc-gap-2 xc-rounded-full xc-border xc-py-2 xc-text-sm xc-transition-all xc-hover:bg-white xc-hover:text-black xc-disabled:cursor-not-allowed xc-disabled:opacity-40 xc-disabled:hover:bg-transparent",
          children: L ? /* @__PURE__ */ le.jsxs(le.Fragment, { children: [
            " ",
            /* @__PURE__ */ le.jsx(KZ, {}),
            " Copied!"
          ] }) : /* @__PURE__ */ le.jsxs(le.Fragment, { children: [
            /* @__PURE__ */ le.jsx(YZ, {}),
            "Copy QR URL"
          ] })
        }
      ),
      ((Ee = r.config) == null ? void 0 : Ee.getWallet) && /* @__PURE__ */ le.jsxs(
        "button",
        {
          className: "xc-rounded-2 xc-flex xc-min-w-[160px] xc-flex-1 xc-shrink-0 xc-items-center xc-justify-center xc-gap-2 xc-rounded-full xc-border xc-py-2 xc-text-sm xc-transition-all xc-hover:bg-white xc-hover:text-black",
          onClick: n,
          children: [
            /* @__PURE__ */ le.jsx(VZ, {}),
            "Get Extension"
          ]
        }
      ),
      ((Y = r.config) == null ? void 0 : Y.desktop_link) && /* @__PURE__ */ le.jsxs(
        "button",
        {
          disabled: !s,
          className: "xc-rounded-2 xc-flex xc-min-w-[160px] xc-flex-1 xc-shrink-0 xc-items-center xc-justify-center xc-gap-2 xc-rounded-full xc-border xc-py-2 xc-text-sm xc-transition-all xc-hover:bg-white xc-hover:text-black",
          onClick: K,
          children: [
            /* @__PURE__ */ le.jsx(y7, {}),
            "Desktop"
          ]
        }
      )
    ] }),
    /* @__PURE__ */ le.jsx("div", { className: "xc-text-center", children: l ? /* @__PURE__ */ le.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center", children: [
      /* @__PURE__ */ le.jsx("p", { className: "xc-text-danger xc-mb-2 xc-text-center", children: l }),
      /* @__PURE__ */ le.jsx("button", { className: "xc-rounded-full xc-bg-white xc-bg-opacity-10 xc-px-6 xc-py-1", onClick: Q, children: "Retry" })
    ] }) : /* @__PURE__ */ le.jsxs(le.Fragment, { children: [
      p === "scan" && /* @__PURE__ */ le.jsx("p", { children: "Scan this QR code from your mobile wallet or phone's camera to connect." }),
      p === "connect" && /* @__PURE__ */ le.jsx("p", { children: "Click connect in your wallet app" }),
      p === "sign" && /* @__PURE__ */ le.jsx("p", { children: "Click sign-in in your wallet to confirm you own this wallet." }),
      p === "waiting" && /* @__PURE__ */ le.jsx("div", { className: "xc-text-center", children: /* @__PURE__ */ le.jsx(Sc, { className: "xc-inline-block xc-animate-spin" }) })
    ] }) })
  ] });
}
const Lie = "Accept connection request in the wallet", kie = "Accept sign-in request in your wallet";
function $ie(t, e, r) {
  const n = window.location.host, i = window.location.href;
  return pA({
    address: t,
    chainId: r,
    domain: n,
    nonce: e,
    uri: i,
    version: "1"
  });
}
function vA(t) {
  var w;
  const [e, r] = Yt(), { wallet: n, onSignFinish: i } = t, s = Qn(), [o, a] = Yt("connect"), { saveLastUsedWallet: u, chains: l } = Tp();
  async function d(_) {
    var P;
    try {
      a("connect");
      const O = await n.connect();
      if (!O || O.length === 0)
        throw new Error("Wallet connect error");
      const L = await n.getChain(), B = l.find((Q) => Q.id === L), k = l[0];
      B || (console.log("switch chain", l[0]), a("switch-chain"), await n.switchChain(l[0]));
      const q = Fv(O[0]), U = $ie(q, _, k.id);
      a("sign");
      const V = await n.signMessage(U, q);
      if (!V || V.length === 0)
        throw new Error("user sign error");
      a("waiting"), await i(n, { address: q, signature: V, message: U, nonce: _, wallet_name: ((P = n.config) == null ? void 0 : P.name) || "" }), u(n);
    } catch (O) {
      console.log("walletSignin error", O.stack), console.log(O.details || O.message), r(O.details || O.message);
    }
  }
  async function p() {
    try {
      r("");
      const _ = await ka.getNonce({ account_type: "block_chain" });
      s.current = _, d(s.current);
    } catch (_) {
      console.log(_.details), r(_.message);
    }
  }
  return Dn(() => {
    p();
  }, []), /* @__PURE__ */ le.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center xc-justify-center xc-gap-4", children: [
    /* @__PURE__ */ le.jsx("img", { className: "xc-rounded-md xc-h-16 xc-w-16", src: (w = n.config) == null ? void 0 : w.image, alt: "" }),
    e && /* @__PURE__ */ le.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center", children: [
      /* @__PURE__ */ le.jsx("p", { className: "xc-text-danger xc-mb-2 xc-text-center", children: e }),
      /* @__PURE__ */ le.jsx("div", { className: "xc-flex xc-gap-2", children: /* @__PURE__ */ le.jsx("button", { className: "xc-rounded-full xc-bg-white xc-bg-opacity-10 xc-px-6 xc-py-1", onClick: p, children: "Retry" }) })
    ] }),
    !e && /* @__PURE__ */ le.jsxs(le.Fragment, { children: [
      o === "connect" && /* @__PURE__ */ le.jsx("span", { className: "xc-text-center", children: Lie }),
      o === "sign" && /* @__PURE__ */ le.jsx("span", { className: "xc-text-center", children: kie }),
      o === "waiting" && /* @__PURE__ */ le.jsx("span", { className: "xc-text-center", children: /* @__PURE__ */ le.jsx(Sc, { className: "xc-animate-spin" }) }),
      o === "switch-chain" && /* @__PURE__ */ le.jsxs("span", { className: "xc-text-center", children: [
        "Switch to ",
        l[0].name
      ] })
    ] })
  ] });
}
const iu = "https://static.codatta.io/codatta-connect/wallet-icons.svg", Bie = "https://itunes.apple.com/app/", Fie = "https://play.google.com/store/apps/details?id=", jie = "https://chromewebstore.google.com/detail/", Uie = "https://chromewebstore.google.com/detail/", qie = "https://addons.mozilla.org/en-US/firefox/addon/", zie = "https://microsoftedge.microsoft.com/addons/detail/";
function su(t) {
  const { icon: e, title: r, link: n } = t;
  return /* @__PURE__ */ le.jsxs(
    "a",
    {
      href: n,
      target: "_blank",
      className: "xc-flex xc-w-full xc-cursor-pointer xc-items-center xc-gap-2 xc-rounded-full xc-border xc-border-white xc-border-opacity-15 xc-px-6 xc-py-3 xc-transition-all xc-hover:bg-white xc-hover:bg-opacity-5",
      children: [
        /* @__PURE__ */ le.jsx("img", { className: "xc-rounded-1 xc-h-6 xc-w-6", src: e, alt: "" }),
        r,
        /* @__PURE__ */ le.jsx(b7, { className: "xc-ml-auto xc-text-gray-400" })
      ]
    }
  );
}
function Wie(t) {
  const e = {
    appStoreLink: "",
    playStoreLink: "",
    chromeStoreLink: "",
    braveStoreLink: "",
    firefoxStoreLink: "",
    edgeStoreLink: ""
  };
  return t != null && t.app_store_id && (e.appStoreLink = `${Bie}${t.app_store_id}`), t != null && t.play_store_id && (e.playStoreLink = `${Fie}${t.play_store_id}`), t != null && t.chrome_store_id && (e.chromeStoreLink = `${jie}${t.chrome_store_id}`), t != null && t.brave_store_id && (e.braveStoreLink = `${Uie}${t.brave_store_id}`), t != null && t.firefox_addon_id && (e.firefoxStoreLink = `${qie}${t.firefox_addon_id}`), t != null && t.edge_addon_id && (e.edgeStoreLink = `${zie}${t.edge_addon_id}`), e;
}
function bA(t) {
  var i, s, o;
  const { wallet: e } = t, r = (i = e.config) == null ? void 0 : i.getWallet, n = Wie(r);
  return /* @__PURE__ */ le.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center", children: [
    /* @__PURE__ */ le.jsx("img", { className: "xc-rounded-md xc-mb-2 xc-h-12 xc-w-12", src: (s = e.config) == null ? void 0 : s.image, alt: "" }),
    /* @__PURE__ */ le.jsxs("p", { className: "xc-text-lg xc-font-bold", children: [
      "Install ",
      (o = e.config) == null ? void 0 : o.name,
      " to connect"
    ] }),
    /* @__PURE__ */ le.jsx("p", { className: "xc-mb-6 xc-text-sm xc-text-gray-500", children: "Select from your preferred options below:" }),
    /* @__PURE__ */ le.jsxs("div", { className: "xc-grid xc-w-full xc-grid-cols-1 xc-gap-3", children: [
      (r == null ? void 0 : r.chrome_store_id) && /* @__PURE__ */ le.jsx(
        su,
        {
          link: n.chromeStoreLink,
          icon: `${iu}#chrome`,
          title: "Google Play Store"
        }
      ),
      (r == null ? void 0 : r.app_store_id) && /* @__PURE__ */ le.jsx(
        su,
        {
          link: n.appStoreLink,
          icon: `${iu}#apple-dark`,
          title: "Apple App Store"
        }
      ),
      (r == null ? void 0 : r.play_store_id) && /* @__PURE__ */ le.jsx(
        su,
        {
          link: n.playStoreLink,
          icon: `${iu}#android`,
          title: "Google Play Store"
        }
      ),
      (r == null ? void 0 : r.edge_addon_id) && /* @__PURE__ */ le.jsx(
        su,
        {
          link: n.edgeStoreLink,
          icon: `${iu}#edge`,
          title: "Microsoft Edge"
        }
      ),
      (r == null ? void 0 : r.brave_store_id) && /* @__PURE__ */ le.jsx(
        su,
        {
          link: n.braveStoreLink,
          icon: `${iu}#brave`,
          title: "Brave extension"
        }
      ),
      (r == null ? void 0 : r.firefox_addon_id) && /* @__PURE__ */ le.jsx(
        su,
        {
          link: n.firefoxStoreLink,
          icon: `${iu}#firefox`,
          title: "Mozilla Firefox"
        }
      )
    ] })
  ] });
}
function Hie(t) {
  const { wallet: e } = t, [r, n] = Yt(e.installed ? "connect" : "qr"), i = Ey();
  async function s(o, a) {
    var l;
    const u = await ka.walletLogin({
      account_type: "block_chain",
      account_enum: i.role,
      connector: "codatta_wallet",
      inviter_code: i.inviterCode,
      wallet_name: ((l = o.config) == null ? void 0 : l.name) || o.key,
      address: await o.getAddress(),
      chain: (await o.getChain()).toString(),
      nonce: a.nonce,
      signature: a.signature,
      message: a.message,
      source: {
        device: i.device,
        channel: i.channel,
        app: i.app
      }
    });
    await t.onLogin(u.data);
  }
  return /* @__PURE__ */ le.jsxs(Rs, { children: [
    /* @__PURE__ */ le.jsx("div", { className: "xc-mb-6", children: /* @__PURE__ */ le.jsx(kc, { title: "Connect wallet", onBack: t.onBack }) }),
    r === "qr" && /* @__PURE__ */ le.jsx(
      mA,
      {
        wallet: e,
        onGetExtension: () => n("get-extension"),
        onSignFinish: s
      }
    ),
    r === "connect" && /* @__PURE__ */ le.jsx(
      vA,
      {
        onShowQrCode: () => n("qr"),
        wallet: e,
        onSignFinish: s
      }
    ),
    r === "get-extension" && /* @__PURE__ */ le.jsx(bA, { wallet: e })
  ] });
}
function Kie(t) {
  const { wallet: e, onClick: r } = t, n = /* @__PURE__ */ le.jsx("img", { className: "xc-rounded-md xc-h-5 xc-w-5", src: e.imageUrl }), i = e.name || "";
  return /* @__PURE__ */ le.jsx(xy, { icon: n, title: i, onClick: () => r(e) });
}
function yA(t) {
  const { connector: e } = t, [r, n] = Yt(), [i, s] = Yt([]), o = wi(() => r ? i.filter((d) => d.name.toLowerCase().includes(r.toLowerCase())) : i, [r, i]);
  function a(d) {
    n(d.target.value);
  }
  async function u() {
    const d = await e.getWallets();
    s(d);
  }
  Dn(() => {
    u();
  }, []);
  function l(d) {
    t.onSelect(d);
  }
  return /* @__PURE__ */ le.jsxs(Rs, { children: [
    /* @__PURE__ */ le.jsx("div", { className: "xc-mb-6", children: /* @__PURE__ */ le.jsx(kc, { title: "Select wallet", onBack: t.onBack }) }),
    /* @__PURE__ */ le.jsxs("div", { className: "xc-mb-6 xc-flex xc-gap-3 xc-px-4 xc-py-2 xc-border xc-rounded-xl xc-w-full xc-overflow-hidden xc-items-center xc-border-opacity-15 xc-border-white focus-within:xc-border-opacity-40", children: [
      /* @__PURE__ */ le.jsx(w7, { className: "xc-shrink-0 xc-opacity-50" }),
      /* @__PURE__ */ le.jsx("input", { type: "text", className: "xc-flex-1 xc-bg-transparent xc-appearance-none xc-outline-none", placeholder: "Search wallet", onInput: a })
    ] }),
    /* @__PURE__ */ le.jsx("div", { className: "xc-mb-4 xc-flex xc-h-[309px] xc-flex-col xc-gap-4 xc-overflow-scroll no-scrollbar", children: o == null ? void 0 : o.map((d) => /* @__PURE__ */ le.jsx(Kie, { wallet: d, onClick: l }, d.name)) })
  ] });
}
var wA = { exports: {} };
(function(t) {
  (function(e, r) {
    t.exports ? t.exports = r() : (e.nacl || (e.nacl = {}), e.nacl.util = r());
  })(gn, function() {
    var e = {};
    function r(n) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(n))
        throw new TypeError("invalid encoding");
    }
    return e.decodeUTF8 = function(n) {
      if (typeof n != "string") throw new TypeError("expected string");
      var i, s = unescape(encodeURIComponent(n)), o = new Uint8Array(s.length);
      for (i = 0; i < s.length; i++) o[i] = s.charCodeAt(i);
      return o;
    }, e.encodeUTF8 = function(n) {
      var i, s = [];
      for (i = 0; i < n.length; i++) s.push(String.fromCharCode(n[i]));
      return decodeURIComponent(escape(s.join("")));
    }, typeof atob > "u" ? typeof Buffer.from < "u" ? (e.encodeBase64 = function(n) {
      return Buffer.from(n).toString("base64");
    }, e.decodeBase64 = function(n) {
      return r(n), new Uint8Array(Array.prototype.slice.call(Buffer.from(n, "base64"), 0));
    }) : (e.encodeBase64 = function(n) {
      return new Buffer(n).toString("base64");
    }, e.decodeBase64 = function(n) {
      return r(n), new Uint8Array(Array.prototype.slice.call(new Buffer(n, "base64"), 0));
    }) : (e.encodeBase64 = function(n) {
      var i, s = [], o = n.length;
      for (i = 0; i < o; i++) s.push(String.fromCharCode(n[i]));
      return btoa(s.join(""));
    }, e.decodeBase64 = function(n) {
      r(n);
      var i, s = atob(n), o = new Uint8Array(s.length);
      for (i = 0; i < s.length; i++) o[i] = s.charCodeAt(i);
      return o;
    }), e;
  });
})(wA);
var Vie = wA.exports;
const zl = /* @__PURE__ */ ns(Vie);
var xA = { exports: {} };
(function(t) {
  (function(e) {
    var r = function($) {
      var z, H = new Float64Array(16);
      if ($) for (z = 0; z < $.length; z++) H[z] = $[z];
      return H;
    }, n = function() {
      throw new Error("no PRNG");
    }, i = new Uint8Array(16), s = new Uint8Array(32);
    s[0] = 9;
    var o = r(), a = r([1]), u = r([56129, 1]), l = r([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), d = r([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), p = r([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), w = r([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), _ = r([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function P($, z, H, C) {
      $[z] = H >> 24 & 255, $[z + 1] = H >> 16 & 255, $[z + 2] = H >> 8 & 255, $[z + 3] = H & 255, $[z + 4] = C >> 24 & 255, $[z + 5] = C >> 16 & 255, $[z + 6] = C >> 8 & 255, $[z + 7] = C & 255;
    }
    function O($, z, H, C, G) {
      var j, se = 0;
      for (j = 0; j < G; j++) se |= $[z + j] ^ H[C + j];
      return (1 & se - 1 >>> 8) - 1;
    }
    function L($, z, H, C) {
      return O($, z, H, C, 16);
    }
    function B($, z, H, C) {
      return O($, z, H, C, 32);
    }
    function k($, z, H, C) {
      for (var G = C[0] & 255 | (C[1] & 255) << 8 | (C[2] & 255) << 16 | (C[3] & 255) << 24, j = H[0] & 255 | (H[1] & 255) << 8 | (H[2] & 255) << 16 | (H[3] & 255) << 24, se = H[4] & 255 | (H[5] & 255) << 8 | (H[6] & 255) << 16 | (H[7] & 255) << 24, de = H[8] & 255 | (H[9] & 255) << 8 | (H[10] & 255) << 16 | (H[11] & 255) << 24, xe = H[12] & 255 | (H[13] & 255) << 8 | (H[14] & 255) << 16 | (H[15] & 255) << 24, Te = C[4] & 255 | (C[5] & 255) << 8 | (C[6] & 255) << 16 | (C[7] & 255) << 24, Re = z[0] & 255 | (z[1] & 255) << 8 | (z[2] & 255) << 16 | (z[3] & 255) << 24, nt = z[4] & 255 | (z[5] & 255) << 8 | (z[6] & 255) << 16 | (z[7] & 255) << 24, je = z[8] & 255 | (z[9] & 255) << 8 | (z[10] & 255) << 16 | (z[11] & 255) << 24, pt = z[12] & 255 | (z[13] & 255) << 8 | (z[14] & 255) << 16 | (z[15] & 255) << 24, it = C[8] & 255 | (C[9] & 255) << 8 | (C[10] & 255) << 16 | (C[11] & 255) << 24, et = H[16] & 255 | (H[17] & 255) << 8 | (H[18] & 255) << 16 | (H[19] & 255) << 24, St = H[20] & 255 | (H[21] & 255) << 8 | (H[22] & 255) << 16 | (H[23] & 255) << 24, Tt = H[24] & 255 | (H[25] & 255) << 8 | (H[26] & 255) << 16 | (H[27] & 255) << 24, At = H[28] & 255 | (H[29] & 255) << 8 | (H[30] & 255) << 16 | (H[31] & 255) << 24, _t = C[12] & 255 | (C[13] & 255) << 8 | (C[14] & 255) << 16 | (C[15] & 255) << 24, ht = G, xt = j, st = se, yt = de, ut = xe, ot = Te, Se = Re, Ae = nt, Ve = je, Fe = pt, Ue = it, Je = et, Lt = St, zt = Tt, Zt = At, Wt = _t, he, rr = 0; rr < 20; rr += 2)
        he = ht + Lt | 0, ut ^= he << 7 | he >>> 25, he = ut + ht | 0, Ve ^= he << 9 | he >>> 23, he = Ve + ut | 0, Lt ^= he << 13 | he >>> 19, he = Lt + Ve | 0, ht ^= he << 18 | he >>> 14, he = ot + xt | 0, Fe ^= he << 7 | he >>> 25, he = Fe + ot | 0, zt ^= he << 9 | he >>> 23, he = zt + Fe | 0, xt ^= he << 13 | he >>> 19, he = xt + zt | 0, ot ^= he << 18 | he >>> 14, he = Ue + Se | 0, Zt ^= he << 7 | he >>> 25, he = Zt + Ue | 0, st ^= he << 9 | he >>> 23, he = st + Zt | 0, Se ^= he << 13 | he >>> 19, he = Se + st | 0, Ue ^= he << 18 | he >>> 14, he = Wt + Je | 0, yt ^= he << 7 | he >>> 25, he = yt + Wt | 0, Ae ^= he << 9 | he >>> 23, he = Ae + yt | 0, Je ^= he << 13 | he >>> 19, he = Je + Ae | 0, Wt ^= he << 18 | he >>> 14, he = ht + yt | 0, xt ^= he << 7 | he >>> 25, he = xt + ht | 0, st ^= he << 9 | he >>> 23, he = st + xt | 0, yt ^= he << 13 | he >>> 19, he = yt + st | 0, ht ^= he << 18 | he >>> 14, he = ot + ut | 0, Se ^= he << 7 | he >>> 25, he = Se + ot | 0, Ae ^= he << 9 | he >>> 23, he = Ae + Se | 0, ut ^= he << 13 | he >>> 19, he = ut + Ae | 0, ot ^= he << 18 | he >>> 14, he = Ue + Fe | 0, Je ^= he << 7 | he >>> 25, he = Je + Ue | 0, Ve ^= he << 9 | he >>> 23, he = Ve + Je | 0, Fe ^= he << 13 | he >>> 19, he = Fe + Ve | 0, Ue ^= he << 18 | he >>> 14, he = Wt + Zt | 0, Lt ^= he << 7 | he >>> 25, he = Lt + Wt | 0, zt ^= he << 9 | he >>> 23, he = zt + Lt | 0, Zt ^= he << 13 | he >>> 19, he = Zt + zt | 0, Wt ^= he << 18 | he >>> 14;
      ht = ht + G | 0, xt = xt + j | 0, st = st + se | 0, yt = yt + de | 0, ut = ut + xe | 0, ot = ot + Te | 0, Se = Se + Re | 0, Ae = Ae + nt | 0, Ve = Ve + je | 0, Fe = Fe + pt | 0, Ue = Ue + it | 0, Je = Je + et | 0, Lt = Lt + St | 0, zt = zt + Tt | 0, Zt = Zt + At | 0, Wt = Wt + _t | 0, $[0] = ht >>> 0 & 255, $[1] = ht >>> 8 & 255, $[2] = ht >>> 16 & 255, $[3] = ht >>> 24 & 255, $[4] = xt >>> 0 & 255, $[5] = xt >>> 8 & 255, $[6] = xt >>> 16 & 255, $[7] = xt >>> 24 & 255, $[8] = st >>> 0 & 255, $[9] = st >>> 8 & 255, $[10] = st >>> 16 & 255, $[11] = st >>> 24 & 255, $[12] = yt >>> 0 & 255, $[13] = yt >>> 8 & 255, $[14] = yt >>> 16 & 255, $[15] = yt >>> 24 & 255, $[16] = ut >>> 0 & 255, $[17] = ut >>> 8 & 255, $[18] = ut >>> 16 & 255, $[19] = ut >>> 24 & 255, $[20] = ot >>> 0 & 255, $[21] = ot >>> 8 & 255, $[22] = ot >>> 16 & 255, $[23] = ot >>> 24 & 255, $[24] = Se >>> 0 & 255, $[25] = Se >>> 8 & 255, $[26] = Se >>> 16 & 255, $[27] = Se >>> 24 & 255, $[28] = Ae >>> 0 & 255, $[29] = Ae >>> 8 & 255, $[30] = Ae >>> 16 & 255, $[31] = Ae >>> 24 & 255, $[32] = Ve >>> 0 & 255, $[33] = Ve >>> 8 & 255, $[34] = Ve >>> 16 & 255, $[35] = Ve >>> 24 & 255, $[36] = Fe >>> 0 & 255, $[37] = Fe >>> 8 & 255, $[38] = Fe >>> 16 & 255, $[39] = Fe >>> 24 & 255, $[40] = Ue >>> 0 & 255, $[41] = Ue >>> 8 & 255, $[42] = Ue >>> 16 & 255, $[43] = Ue >>> 24 & 255, $[44] = Je >>> 0 & 255, $[45] = Je >>> 8 & 255, $[46] = Je >>> 16 & 255, $[47] = Je >>> 24 & 255, $[48] = Lt >>> 0 & 255, $[49] = Lt >>> 8 & 255, $[50] = Lt >>> 16 & 255, $[51] = Lt >>> 24 & 255, $[52] = zt >>> 0 & 255, $[53] = zt >>> 8 & 255, $[54] = zt >>> 16 & 255, $[55] = zt >>> 24 & 255, $[56] = Zt >>> 0 & 255, $[57] = Zt >>> 8 & 255, $[58] = Zt >>> 16 & 255, $[59] = Zt >>> 24 & 255, $[60] = Wt >>> 0 & 255, $[61] = Wt >>> 8 & 255, $[62] = Wt >>> 16 & 255, $[63] = Wt >>> 24 & 255;
    }
    function q($, z, H, C) {
      for (var G = C[0] & 255 | (C[1] & 255) << 8 | (C[2] & 255) << 16 | (C[3] & 255) << 24, j = H[0] & 255 | (H[1] & 255) << 8 | (H[2] & 255) << 16 | (H[3] & 255) << 24, se = H[4] & 255 | (H[5] & 255) << 8 | (H[6] & 255) << 16 | (H[7] & 255) << 24, de = H[8] & 255 | (H[9] & 255) << 8 | (H[10] & 255) << 16 | (H[11] & 255) << 24, xe = H[12] & 255 | (H[13] & 255) << 8 | (H[14] & 255) << 16 | (H[15] & 255) << 24, Te = C[4] & 255 | (C[5] & 255) << 8 | (C[6] & 255) << 16 | (C[7] & 255) << 24, Re = z[0] & 255 | (z[1] & 255) << 8 | (z[2] & 255) << 16 | (z[3] & 255) << 24, nt = z[4] & 255 | (z[5] & 255) << 8 | (z[6] & 255) << 16 | (z[7] & 255) << 24, je = z[8] & 255 | (z[9] & 255) << 8 | (z[10] & 255) << 16 | (z[11] & 255) << 24, pt = z[12] & 255 | (z[13] & 255) << 8 | (z[14] & 255) << 16 | (z[15] & 255) << 24, it = C[8] & 255 | (C[9] & 255) << 8 | (C[10] & 255) << 16 | (C[11] & 255) << 24, et = H[16] & 255 | (H[17] & 255) << 8 | (H[18] & 255) << 16 | (H[19] & 255) << 24, St = H[20] & 255 | (H[21] & 255) << 8 | (H[22] & 255) << 16 | (H[23] & 255) << 24, Tt = H[24] & 255 | (H[25] & 255) << 8 | (H[26] & 255) << 16 | (H[27] & 255) << 24, At = H[28] & 255 | (H[29] & 255) << 8 | (H[30] & 255) << 16 | (H[31] & 255) << 24, _t = C[12] & 255 | (C[13] & 255) << 8 | (C[14] & 255) << 16 | (C[15] & 255) << 24, ht = G, xt = j, st = se, yt = de, ut = xe, ot = Te, Se = Re, Ae = nt, Ve = je, Fe = pt, Ue = it, Je = et, Lt = St, zt = Tt, Zt = At, Wt = _t, he, rr = 0; rr < 20; rr += 2)
        he = ht + Lt | 0, ut ^= he << 7 | he >>> 25, he = ut + ht | 0, Ve ^= he << 9 | he >>> 23, he = Ve + ut | 0, Lt ^= he << 13 | he >>> 19, he = Lt + Ve | 0, ht ^= he << 18 | he >>> 14, he = ot + xt | 0, Fe ^= he << 7 | he >>> 25, he = Fe + ot | 0, zt ^= he << 9 | he >>> 23, he = zt + Fe | 0, xt ^= he << 13 | he >>> 19, he = xt + zt | 0, ot ^= he << 18 | he >>> 14, he = Ue + Se | 0, Zt ^= he << 7 | he >>> 25, he = Zt + Ue | 0, st ^= he << 9 | he >>> 23, he = st + Zt | 0, Se ^= he << 13 | he >>> 19, he = Se + st | 0, Ue ^= he << 18 | he >>> 14, he = Wt + Je | 0, yt ^= he << 7 | he >>> 25, he = yt + Wt | 0, Ae ^= he << 9 | he >>> 23, he = Ae + yt | 0, Je ^= he << 13 | he >>> 19, he = Je + Ae | 0, Wt ^= he << 18 | he >>> 14, he = ht + yt | 0, xt ^= he << 7 | he >>> 25, he = xt + ht | 0, st ^= he << 9 | he >>> 23, he = st + xt | 0, yt ^= he << 13 | he >>> 19, he = yt + st | 0, ht ^= he << 18 | he >>> 14, he = ot + ut | 0, Se ^= he << 7 | he >>> 25, he = Se + ot | 0, Ae ^= he << 9 | he >>> 23, he = Ae + Se | 0, ut ^= he << 13 | he >>> 19, he = ut + Ae | 0, ot ^= he << 18 | he >>> 14, he = Ue + Fe | 0, Je ^= he << 7 | he >>> 25, he = Je + Ue | 0, Ve ^= he << 9 | he >>> 23, he = Ve + Je | 0, Fe ^= he << 13 | he >>> 19, he = Fe + Ve | 0, Ue ^= he << 18 | he >>> 14, he = Wt + Zt | 0, Lt ^= he << 7 | he >>> 25, he = Lt + Wt | 0, zt ^= he << 9 | he >>> 23, he = zt + Lt | 0, Zt ^= he << 13 | he >>> 19, he = Zt + zt | 0, Wt ^= he << 18 | he >>> 14;
      $[0] = ht >>> 0 & 255, $[1] = ht >>> 8 & 255, $[2] = ht >>> 16 & 255, $[3] = ht >>> 24 & 255, $[4] = ot >>> 0 & 255, $[5] = ot >>> 8 & 255, $[6] = ot >>> 16 & 255, $[7] = ot >>> 24 & 255, $[8] = Ue >>> 0 & 255, $[9] = Ue >>> 8 & 255, $[10] = Ue >>> 16 & 255, $[11] = Ue >>> 24 & 255, $[12] = Wt >>> 0 & 255, $[13] = Wt >>> 8 & 255, $[14] = Wt >>> 16 & 255, $[15] = Wt >>> 24 & 255, $[16] = Se >>> 0 & 255, $[17] = Se >>> 8 & 255, $[18] = Se >>> 16 & 255, $[19] = Se >>> 24 & 255, $[20] = Ae >>> 0 & 255, $[21] = Ae >>> 8 & 255, $[22] = Ae >>> 16 & 255, $[23] = Ae >>> 24 & 255, $[24] = Ve >>> 0 & 255, $[25] = Ve >>> 8 & 255, $[26] = Ve >>> 16 & 255, $[27] = Ve >>> 24 & 255, $[28] = Fe >>> 0 & 255, $[29] = Fe >>> 8 & 255, $[30] = Fe >>> 16 & 255, $[31] = Fe >>> 24 & 255;
    }
    function U($, z, H, C) {
      k($, z, H, C);
    }
    function V($, z, H, C) {
      q($, z, H, C);
    }
    var Q = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function R($, z, H, C, G, j, se) {
      var de = new Uint8Array(16), xe = new Uint8Array(64), Te, Re;
      for (Re = 0; Re < 16; Re++) de[Re] = 0;
      for (Re = 0; Re < 8; Re++) de[Re] = j[Re];
      for (; G >= 64; ) {
        for (U(xe, de, se, Q), Re = 0; Re < 64; Re++) $[z + Re] = H[C + Re] ^ xe[Re];
        for (Te = 1, Re = 8; Re < 16; Re++)
          Te = Te + (de[Re] & 255) | 0, de[Re] = Te & 255, Te >>>= 8;
        G -= 64, z += 64, C += 64;
      }
      if (G > 0)
        for (U(xe, de, se, Q), Re = 0; Re < G; Re++) $[z + Re] = H[C + Re] ^ xe[Re];
      return 0;
    }
    function K($, z, H, C, G) {
      var j = new Uint8Array(16), se = new Uint8Array(64), de, xe;
      for (xe = 0; xe < 16; xe++) j[xe] = 0;
      for (xe = 0; xe < 8; xe++) j[xe] = C[xe];
      for (; H >= 64; ) {
        for (U(se, j, G, Q), xe = 0; xe < 64; xe++) $[z + xe] = se[xe];
        for (de = 1, xe = 8; xe < 16; xe++)
          de = de + (j[xe] & 255) | 0, j[xe] = de & 255, de >>>= 8;
        H -= 64, z += 64;
      }
      if (H > 0)
        for (U(se, j, G, Q), xe = 0; xe < H; xe++) $[z + xe] = se[xe];
      return 0;
    }
    function ge($, z, H, C, G) {
      var j = new Uint8Array(32);
      V(j, C, G, Q);
      for (var se = new Uint8Array(8), de = 0; de < 8; de++) se[de] = C[de + 16];
      return K($, z, H, se, j);
    }
    function Ee($, z, H, C, G, j, se) {
      var de = new Uint8Array(32);
      V(de, j, se, Q);
      for (var xe = new Uint8Array(8), Te = 0; Te < 8; Te++) xe[Te] = j[Te + 16];
      return R($, z, H, C, G, xe, de);
    }
    var Y = function($) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var z, H, C, G, j, se, de, xe;
      z = $[0] & 255 | ($[1] & 255) << 8, this.r[0] = z & 8191, H = $[2] & 255 | ($[3] & 255) << 8, this.r[1] = (z >>> 13 | H << 3) & 8191, C = $[4] & 255 | ($[5] & 255) << 8, this.r[2] = (H >>> 10 | C << 6) & 7939, G = $[6] & 255 | ($[7] & 255) << 8, this.r[3] = (C >>> 7 | G << 9) & 8191, j = $[8] & 255 | ($[9] & 255) << 8, this.r[4] = (G >>> 4 | j << 12) & 255, this.r[5] = j >>> 1 & 8190, se = $[10] & 255 | ($[11] & 255) << 8, this.r[6] = (j >>> 14 | se << 2) & 8191, de = $[12] & 255 | ($[13] & 255) << 8, this.r[7] = (se >>> 11 | de << 5) & 8065, xe = $[14] & 255 | ($[15] & 255) << 8, this.r[8] = (de >>> 8 | xe << 8) & 8191, this.r[9] = xe >>> 5 & 127, this.pad[0] = $[16] & 255 | ($[17] & 255) << 8, this.pad[1] = $[18] & 255 | ($[19] & 255) << 8, this.pad[2] = $[20] & 255 | ($[21] & 255) << 8, this.pad[3] = $[22] & 255 | ($[23] & 255) << 8, this.pad[4] = $[24] & 255 | ($[25] & 255) << 8, this.pad[5] = $[26] & 255 | ($[27] & 255) << 8, this.pad[6] = $[28] & 255 | ($[29] & 255) << 8, this.pad[7] = $[30] & 255 | ($[31] & 255) << 8;
    };
    Y.prototype.blocks = function($, z, H) {
      for (var C = this.fin ? 0 : 2048, G, j, se, de, xe, Te, Re, nt, je, pt, it, et, St, Tt, At, _t, ht, xt, st, yt = this.h[0], ut = this.h[1], ot = this.h[2], Se = this.h[3], Ae = this.h[4], Ve = this.h[5], Fe = this.h[6], Ue = this.h[7], Je = this.h[8], Lt = this.h[9], zt = this.r[0], Zt = this.r[1], Wt = this.r[2], he = this.r[3], rr = this.r[4], dr = this.r[5], pr = this.r[6], Qt = this.r[7], gr = this.r[8], lr = this.r[9]; H >= 16; )
        G = $[z + 0] & 255 | ($[z + 1] & 255) << 8, yt += G & 8191, j = $[z + 2] & 255 | ($[z + 3] & 255) << 8, ut += (G >>> 13 | j << 3) & 8191, se = $[z + 4] & 255 | ($[z + 5] & 255) << 8, ot += (j >>> 10 | se << 6) & 8191, de = $[z + 6] & 255 | ($[z + 7] & 255) << 8, Se += (se >>> 7 | de << 9) & 8191, xe = $[z + 8] & 255 | ($[z + 9] & 255) << 8, Ae += (de >>> 4 | xe << 12) & 8191, Ve += xe >>> 1 & 8191, Te = $[z + 10] & 255 | ($[z + 11] & 255) << 8, Fe += (xe >>> 14 | Te << 2) & 8191, Re = $[z + 12] & 255 | ($[z + 13] & 255) << 8, Ue += (Te >>> 11 | Re << 5) & 8191, nt = $[z + 14] & 255 | ($[z + 15] & 255) << 8, Je += (Re >>> 8 | nt << 8) & 8191, Lt += nt >>> 5 | C, je = 0, pt = je, pt += yt * zt, pt += ut * (5 * lr), pt += ot * (5 * gr), pt += Se * (5 * Qt), pt += Ae * (5 * pr), je = pt >>> 13, pt &= 8191, pt += Ve * (5 * dr), pt += Fe * (5 * rr), pt += Ue * (5 * he), pt += Je * (5 * Wt), pt += Lt * (5 * Zt), je += pt >>> 13, pt &= 8191, it = je, it += yt * Zt, it += ut * zt, it += ot * (5 * lr), it += Se * (5 * gr), it += Ae * (5 * Qt), je = it >>> 13, it &= 8191, it += Ve * (5 * pr), it += Fe * (5 * dr), it += Ue * (5 * rr), it += Je * (5 * he), it += Lt * (5 * Wt), je += it >>> 13, it &= 8191, et = je, et += yt * Wt, et += ut * Zt, et += ot * zt, et += Se * (5 * lr), et += Ae * (5 * gr), je = et >>> 13, et &= 8191, et += Ve * (5 * Qt), et += Fe * (5 * pr), et += Ue * (5 * dr), et += Je * (5 * rr), et += Lt * (5 * he), je += et >>> 13, et &= 8191, St = je, St += yt * he, St += ut * Wt, St += ot * Zt, St += Se * zt, St += Ae * (5 * lr), je = St >>> 13, St &= 8191, St += Ve * (5 * gr), St += Fe * (5 * Qt), St += Ue * (5 * pr), St += Je * (5 * dr), St += Lt * (5 * rr), je += St >>> 13, St &= 8191, Tt = je, Tt += yt * rr, Tt += ut * he, Tt += ot * Wt, Tt += Se * Zt, Tt += Ae * zt, je = Tt >>> 13, Tt &= 8191, Tt += Ve * (5 * lr), Tt += Fe * (5 * gr), Tt += Ue * (5 * Qt), Tt += Je * (5 * pr), Tt += Lt * (5 * dr), je += Tt >>> 13, Tt &= 8191, At = je, At += yt * dr, At += ut * rr, At += ot * he, At += Se * Wt, At += Ae * Zt, je = At >>> 13, At &= 8191, At += Ve * zt, At += Fe * (5 * lr), At += Ue * (5 * gr), At += Je * (5 * Qt), At += Lt * (5 * pr), je += At >>> 13, At &= 8191, _t = je, _t += yt * pr, _t += ut * dr, _t += ot * rr, _t += Se * he, _t += Ae * Wt, je = _t >>> 13, _t &= 8191, _t += Ve * Zt, _t += Fe * zt, _t += Ue * (5 * lr), _t += Je * (5 * gr), _t += Lt * (5 * Qt), je += _t >>> 13, _t &= 8191, ht = je, ht += yt * Qt, ht += ut * pr, ht += ot * dr, ht += Se * rr, ht += Ae * he, je = ht >>> 13, ht &= 8191, ht += Ve * Wt, ht += Fe * Zt, ht += Ue * zt, ht += Je * (5 * lr), ht += Lt * (5 * gr), je += ht >>> 13, ht &= 8191, xt = je, xt += yt * gr, xt += ut * Qt, xt += ot * pr, xt += Se * dr, xt += Ae * rr, je = xt >>> 13, xt &= 8191, xt += Ve * he, xt += Fe * Wt, xt += Ue * Zt, xt += Je * zt, xt += Lt * (5 * lr), je += xt >>> 13, xt &= 8191, st = je, st += yt * lr, st += ut * gr, st += ot * Qt, st += Se * pr, st += Ae * dr, je = st >>> 13, st &= 8191, st += Ve * rr, st += Fe * he, st += Ue * Wt, st += Je * Zt, st += Lt * zt, je += st >>> 13, st &= 8191, je = (je << 2) + je | 0, je = je + pt | 0, pt = je & 8191, je = je >>> 13, it += je, yt = pt, ut = it, ot = et, Se = St, Ae = Tt, Ve = At, Fe = _t, Ue = ht, Je = xt, Lt = st, z += 16, H -= 16;
      this.h[0] = yt, this.h[1] = ut, this.h[2] = ot, this.h[3] = Se, this.h[4] = Ae, this.h[5] = Ve, this.h[6] = Fe, this.h[7] = Ue, this.h[8] = Je, this.h[9] = Lt;
    }, Y.prototype.finish = function($, z) {
      var H = new Uint16Array(10), C, G, j, se;
      if (this.leftover) {
        for (se = this.leftover, this.buffer[se++] = 1; se < 16; se++) this.buffer[se] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (C = this.h[1] >>> 13, this.h[1] &= 8191, se = 2; se < 10; se++)
        this.h[se] += C, C = this.h[se] >>> 13, this.h[se] &= 8191;
      for (this.h[0] += C * 5, C = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += C, C = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += C, H[0] = this.h[0] + 5, C = H[0] >>> 13, H[0] &= 8191, se = 1; se < 10; se++)
        H[se] = this.h[se] + C, C = H[se] >>> 13, H[se] &= 8191;
      for (H[9] -= 8192, G = (C ^ 1) - 1, se = 0; se < 10; se++) H[se] &= G;
      for (G = ~G, se = 0; se < 10; se++) this.h[se] = this.h[se] & G | H[se];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, j = this.h[0] + this.pad[0], this.h[0] = j & 65535, se = 1; se < 8; se++)
        j = (this.h[se] + this.pad[se] | 0) + (j >>> 16) | 0, this.h[se] = j & 65535;
      $[z + 0] = this.h[0] >>> 0 & 255, $[z + 1] = this.h[0] >>> 8 & 255, $[z + 2] = this.h[1] >>> 0 & 255, $[z + 3] = this.h[1] >>> 8 & 255, $[z + 4] = this.h[2] >>> 0 & 255, $[z + 5] = this.h[2] >>> 8 & 255, $[z + 6] = this.h[3] >>> 0 & 255, $[z + 7] = this.h[3] >>> 8 & 255, $[z + 8] = this.h[4] >>> 0 & 255, $[z + 9] = this.h[4] >>> 8 & 255, $[z + 10] = this.h[5] >>> 0 & 255, $[z + 11] = this.h[5] >>> 8 & 255, $[z + 12] = this.h[6] >>> 0 & 255, $[z + 13] = this.h[6] >>> 8 & 255, $[z + 14] = this.h[7] >>> 0 & 255, $[z + 15] = this.h[7] >>> 8 & 255;
    }, Y.prototype.update = function($, z, H) {
      var C, G;
      if (this.leftover) {
        for (G = 16 - this.leftover, G > H && (G = H), C = 0; C < G; C++)
          this.buffer[this.leftover + C] = $[z + C];
        if (H -= G, z += G, this.leftover += G, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (H >= 16 && (G = H - H % 16, this.blocks($, z, G), z += G, H -= G), H) {
        for (C = 0; C < H; C++)
          this.buffer[this.leftover + C] = $[z + C];
        this.leftover += H;
      }
    };
    function A($, z, H, C, G, j) {
      var se = new Y(j);
      return se.update(H, C, G), se.finish($, z), 0;
    }
    function m($, z, H, C, G, j) {
      var se = new Uint8Array(16);
      return A(se, 0, H, C, G, j), L($, z, se, 0);
    }
    function f($, z, H, C, G) {
      var j;
      if (H < 32) return -1;
      for (Ee($, 0, z, 0, H, C, G), A($, 16, $, 32, H - 32, $), j = 0; j < 16; j++) $[j] = 0;
      return 0;
    }
    function g($, z, H, C, G) {
      var j, se = new Uint8Array(32);
      if (H < 32 || (ge(se, 0, 32, C, G), m(z, 16, z, 32, H - 32, se) !== 0)) return -1;
      for (Ee($, 0, z, 0, H, C, G), j = 0; j < 32; j++) $[j] = 0;
      return 0;
    }
    function b($, z) {
      var H;
      for (H = 0; H < 16; H++) $[H] = z[H] | 0;
    }
    function x($) {
      var z, H, C = 1;
      for (z = 0; z < 16; z++)
        H = $[z] + C + 65535, C = Math.floor(H / 65536), $[z] = H - C * 65536;
      $[0] += C - 1 + 37 * (C - 1);
    }
    function E($, z, H) {
      for (var C, G = ~(H - 1), j = 0; j < 16; j++)
        C = G & ($[j] ^ z[j]), $[j] ^= C, z[j] ^= C;
    }
    function S($, z) {
      var H, C, G, j = r(), se = r();
      for (H = 0; H < 16; H++) se[H] = z[H];
      for (x(se), x(se), x(se), C = 0; C < 2; C++) {
        for (j[0] = se[0] - 65517, H = 1; H < 15; H++)
          j[H] = se[H] - 65535 - (j[H - 1] >> 16 & 1), j[H - 1] &= 65535;
        j[15] = se[15] - 32767 - (j[14] >> 16 & 1), G = j[15] >> 16 & 1, j[14] &= 65535, E(se, j, 1 - G);
      }
      for (H = 0; H < 16; H++)
        $[2 * H] = se[H] & 255, $[2 * H + 1] = se[H] >> 8;
    }
    function v($, z) {
      var H = new Uint8Array(32), C = new Uint8Array(32);
      return S(H, $), S(C, z), B(H, 0, C, 0);
    }
    function M($) {
      var z = new Uint8Array(32);
      return S(z, $), z[0] & 1;
    }
    function I($, z) {
      var H;
      for (H = 0; H < 16; H++) $[H] = z[2 * H] + (z[2 * H + 1] << 8);
      $[15] &= 32767;
    }
    function F($, z, H) {
      for (var C = 0; C < 16; C++) $[C] = z[C] + H[C];
    }
    function ce($, z, H) {
      for (var C = 0; C < 16; C++) $[C] = z[C] - H[C];
    }
    function D($, z, H) {
      var C, G, j = 0, se = 0, de = 0, xe = 0, Te = 0, Re = 0, nt = 0, je = 0, pt = 0, it = 0, et = 0, St = 0, Tt = 0, At = 0, _t = 0, ht = 0, xt = 0, st = 0, yt = 0, ut = 0, ot = 0, Se = 0, Ae = 0, Ve = 0, Fe = 0, Ue = 0, Je = 0, Lt = 0, zt = 0, Zt = 0, Wt = 0, he = H[0], rr = H[1], dr = H[2], pr = H[3], Qt = H[4], gr = H[5], lr = H[6], Rr = H[7], mr = H[8], wr = H[9], $r = H[10], Br = H[11], Ir = H[12], nn = H[13], sn = H[14], on = H[15];
      C = z[0], j += C * he, se += C * rr, de += C * dr, xe += C * pr, Te += C * Qt, Re += C * gr, nt += C * lr, je += C * Rr, pt += C * mr, it += C * wr, et += C * $r, St += C * Br, Tt += C * Ir, At += C * nn, _t += C * sn, ht += C * on, C = z[1], se += C * he, de += C * rr, xe += C * dr, Te += C * pr, Re += C * Qt, nt += C * gr, je += C * lr, pt += C * Rr, it += C * mr, et += C * wr, St += C * $r, Tt += C * Br, At += C * Ir, _t += C * nn, ht += C * sn, xt += C * on, C = z[2], de += C * he, xe += C * rr, Te += C * dr, Re += C * pr, nt += C * Qt, je += C * gr, pt += C * lr, it += C * Rr, et += C * mr, St += C * wr, Tt += C * $r, At += C * Br, _t += C * Ir, ht += C * nn, xt += C * sn, st += C * on, C = z[3], xe += C * he, Te += C * rr, Re += C * dr, nt += C * pr, je += C * Qt, pt += C * gr, it += C * lr, et += C * Rr, St += C * mr, Tt += C * wr, At += C * $r, _t += C * Br, ht += C * Ir, xt += C * nn, st += C * sn, yt += C * on, C = z[4], Te += C * he, Re += C * rr, nt += C * dr, je += C * pr, pt += C * Qt, it += C * gr, et += C * lr, St += C * Rr, Tt += C * mr, At += C * wr, _t += C * $r, ht += C * Br, xt += C * Ir, st += C * nn, yt += C * sn, ut += C * on, C = z[5], Re += C * he, nt += C * rr, je += C * dr, pt += C * pr, it += C * Qt, et += C * gr, St += C * lr, Tt += C * Rr, At += C * mr, _t += C * wr, ht += C * $r, xt += C * Br, st += C * Ir, yt += C * nn, ut += C * sn, ot += C * on, C = z[6], nt += C * he, je += C * rr, pt += C * dr, it += C * pr, et += C * Qt, St += C * gr, Tt += C * lr, At += C * Rr, _t += C * mr, ht += C * wr, xt += C * $r, st += C * Br, yt += C * Ir, ut += C * nn, ot += C * sn, Se += C * on, C = z[7], je += C * he, pt += C * rr, it += C * dr, et += C * pr, St += C * Qt, Tt += C * gr, At += C * lr, _t += C * Rr, ht += C * mr, xt += C * wr, st += C * $r, yt += C * Br, ut += C * Ir, ot += C * nn, Se += C * sn, Ae += C * on, C = z[8], pt += C * he, it += C * rr, et += C * dr, St += C * pr, Tt += C * Qt, At += C * gr, _t += C * lr, ht += C * Rr, xt += C * mr, st += C * wr, yt += C * $r, ut += C * Br, ot += C * Ir, Se += C * nn, Ae += C * sn, Ve += C * on, C = z[9], it += C * he, et += C * rr, St += C * dr, Tt += C * pr, At += C * Qt, _t += C * gr, ht += C * lr, xt += C * Rr, st += C * mr, yt += C * wr, ut += C * $r, ot += C * Br, Se += C * Ir, Ae += C * nn, Ve += C * sn, Fe += C * on, C = z[10], et += C * he, St += C * rr, Tt += C * dr, At += C * pr, _t += C * Qt, ht += C * gr, xt += C * lr, st += C * Rr, yt += C * mr, ut += C * wr, ot += C * $r, Se += C * Br, Ae += C * Ir, Ve += C * nn, Fe += C * sn, Ue += C * on, C = z[11], St += C * he, Tt += C * rr, At += C * dr, _t += C * pr, ht += C * Qt, xt += C * gr, st += C * lr, yt += C * Rr, ut += C * mr, ot += C * wr, Se += C * $r, Ae += C * Br, Ve += C * Ir, Fe += C * nn, Ue += C * sn, Je += C * on, C = z[12], Tt += C * he, At += C * rr, _t += C * dr, ht += C * pr, xt += C * Qt, st += C * gr, yt += C * lr, ut += C * Rr, ot += C * mr, Se += C * wr, Ae += C * $r, Ve += C * Br, Fe += C * Ir, Ue += C * nn, Je += C * sn, Lt += C * on, C = z[13], At += C * he, _t += C * rr, ht += C * dr, xt += C * pr, st += C * Qt, yt += C * gr, ut += C * lr, ot += C * Rr, Se += C * mr, Ae += C * wr, Ve += C * $r, Fe += C * Br, Ue += C * Ir, Je += C * nn, Lt += C * sn, zt += C * on, C = z[14], _t += C * he, ht += C * rr, xt += C * dr, st += C * pr, yt += C * Qt, ut += C * gr, ot += C * lr, Se += C * Rr, Ae += C * mr, Ve += C * wr, Fe += C * $r, Ue += C * Br, Je += C * Ir, Lt += C * nn, zt += C * sn, Zt += C * on, C = z[15], ht += C * he, xt += C * rr, st += C * dr, yt += C * pr, ut += C * Qt, ot += C * gr, Se += C * lr, Ae += C * Rr, Ve += C * mr, Fe += C * wr, Ue += C * $r, Je += C * Br, Lt += C * Ir, zt += C * nn, Zt += C * sn, Wt += C * on, j += 38 * xt, se += 38 * st, de += 38 * yt, xe += 38 * ut, Te += 38 * ot, Re += 38 * Se, nt += 38 * Ae, je += 38 * Ve, pt += 38 * Fe, it += 38 * Ue, et += 38 * Je, St += 38 * Lt, Tt += 38 * zt, At += 38 * Zt, _t += 38 * Wt, G = 1, C = j + G + 65535, G = Math.floor(C / 65536), j = C - G * 65536, C = se + G + 65535, G = Math.floor(C / 65536), se = C - G * 65536, C = de + G + 65535, G = Math.floor(C / 65536), de = C - G * 65536, C = xe + G + 65535, G = Math.floor(C / 65536), xe = C - G * 65536, C = Te + G + 65535, G = Math.floor(C / 65536), Te = C - G * 65536, C = Re + G + 65535, G = Math.floor(C / 65536), Re = C - G * 65536, C = nt + G + 65535, G = Math.floor(C / 65536), nt = C - G * 65536, C = je + G + 65535, G = Math.floor(C / 65536), je = C - G * 65536, C = pt + G + 65535, G = Math.floor(C / 65536), pt = C - G * 65536, C = it + G + 65535, G = Math.floor(C / 65536), it = C - G * 65536, C = et + G + 65535, G = Math.floor(C / 65536), et = C - G * 65536, C = St + G + 65535, G = Math.floor(C / 65536), St = C - G * 65536, C = Tt + G + 65535, G = Math.floor(C / 65536), Tt = C - G * 65536, C = At + G + 65535, G = Math.floor(C / 65536), At = C - G * 65536, C = _t + G + 65535, G = Math.floor(C / 65536), _t = C - G * 65536, C = ht + G + 65535, G = Math.floor(C / 65536), ht = C - G * 65536, j += G - 1 + 37 * (G - 1), G = 1, C = j + G + 65535, G = Math.floor(C / 65536), j = C - G * 65536, C = se + G + 65535, G = Math.floor(C / 65536), se = C - G * 65536, C = de + G + 65535, G = Math.floor(C / 65536), de = C - G * 65536, C = xe + G + 65535, G = Math.floor(C / 65536), xe = C - G * 65536, C = Te + G + 65535, G = Math.floor(C / 65536), Te = C - G * 65536, C = Re + G + 65535, G = Math.floor(C / 65536), Re = C - G * 65536, C = nt + G + 65535, G = Math.floor(C / 65536), nt = C - G * 65536, C = je + G + 65535, G = Math.floor(C / 65536), je = C - G * 65536, C = pt + G + 65535, G = Math.floor(C / 65536), pt = C - G * 65536, C = it + G + 65535, G = Math.floor(C / 65536), it = C - G * 65536, C = et + G + 65535, G = Math.floor(C / 65536), et = C - G * 65536, C = St + G + 65535, G = Math.floor(C / 65536), St = C - G * 65536, C = Tt + G + 65535, G = Math.floor(C / 65536), Tt = C - G * 65536, C = At + G + 65535, G = Math.floor(C / 65536), At = C - G * 65536, C = _t + G + 65535, G = Math.floor(C / 65536), _t = C - G * 65536, C = ht + G + 65535, G = Math.floor(C / 65536), ht = C - G * 65536, j += G - 1 + 37 * (G - 1), $[0] = j, $[1] = se, $[2] = de, $[3] = xe, $[4] = Te, $[5] = Re, $[6] = nt, $[7] = je, $[8] = pt, $[9] = it, $[10] = et, $[11] = St, $[12] = Tt, $[13] = At, $[14] = _t, $[15] = ht;
    }
    function oe($, z) {
      D($, z, z);
    }
    function Z($, z) {
      var H = r(), C;
      for (C = 0; C < 16; C++) H[C] = z[C];
      for (C = 253; C >= 0; C--)
        oe(H, H), C !== 2 && C !== 4 && D(H, H, z);
      for (C = 0; C < 16; C++) $[C] = H[C];
    }
    function J($, z) {
      var H = r(), C;
      for (C = 0; C < 16; C++) H[C] = z[C];
      for (C = 250; C >= 0; C--)
        oe(H, H), C !== 1 && D(H, H, z);
      for (C = 0; C < 16; C++) $[C] = H[C];
    }
    function ee($, z, H) {
      var C = new Uint8Array(32), G = new Float64Array(80), j, se, de = r(), xe = r(), Te = r(), Re = r(), nt = r(), je = r();
      for (se = 0; se < 31; se++) C[se] = z[se];
      for (C[31] = z[31] & 127 | 64, C[0] &= 248, I(G, H), se = 0; se < 16; se++)
        xe[se] = G[se], Re[se] = de[se] = Te[se] = 0;
      for (de[0] = Re[0] = 1, se = 254; se >= 0; --se)
        j = C[se >>> 3] >>> (se & 7) & 1, E(de, xe, j), E(Te, Re, j), F(nt, de, Te), ce(de, de, Te), F(Te, xe, Re), ce(xe, xe, Re), oe(Re, nt), oe(je, de), D(de, Te, de), D(Te, xe, nt), F(nt, de, Te), ce(de, de, Te), oe(xe, de), ce(Te, Re, je), D(de, Te, u), F(de, de, Re), D(Te, Te, de), D(de, Re, je), D(Re, xe, G), oe(xe, nt), E(de, xe, j), E(Te, Re, j);
      for (se = 0; se < 16; se++)
        G[se + 16] = de[se], G[se + 32] = Te[se], G[se + 48] = xe[se], G[se + 64] = Re[se];
      var pt = G.subarray(32), it = G.subarray(16);
      return Z(pt, pt), D(it, it, pt), S($, it), 0;
    }
    function T($, z) {
      return ee($, z, s);
    }
    function X($, z) {
      return n(z, 32), T($, z);
    }
    function re($, z, H) {
      var C = new Uint8Array(32);
      return ee(C, H, z), V($, i, C, Q);
    }
    var pe = f, ie = g;
    function ue($, z, H, C, G, j) {
      var se = new Uint8Array(32);
      return re(se, G, j), pe($, z, H, C, se);
    }
    function ve($, z, H, C, G, j) {
      var se = new Uint8Array(32);
      return re(se, G, j), ie($, z, H, C, se);
    }
    var Pe = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function De($, z, H, C) {
      for (var G = new Int32Array(16), j = new Int32Array(16), se, de, xe, Te, Re, nt, je, pt, it, et, St, Tt, At, _t, ht, xt, st, yt, ut, ot, Se, Ae, Ve, Fe, Ue, Je, Lt = $[0], zt = $[1], Zt = $[2], Wt = $[3], he = $[4], rr = $[5], dr = $[6], pr = $[7], Qt = z[0], gr = z[1], lr = z[2], Rr = z[3], mr = z[4], wr = z[5], $r = z[6], Br = z[7], Ir = 0; C >= 128; ) {
        for (ut = 0; ut < 16; ut++)
          ot = 8 * ut + Ir, G[ut] = H[ot + 0] << 24 | H[ot + 1] << 16 | H[ot + 2] << 8 | H[ot + 3], j[ut] = H[ot + 4] << 24 | H[ot + 5] << 16 | H[ot + 6] << 8 | H[ot + 7];
        for (ut = 0; ut < 80; ut++)
          if (se = Lt, de = zt, xe = Zt, Te = Wt, Re = he, nt = rr, je = dr, pt = pr, it = Qt, et = gr, St = lr, Tt = Rr, At = mr, _t = wr, ht = $r, xt = Br, Se = pr, Ae = Br, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = (he >>> 14 | mr << 18) ^ (he >>> 18 | mr << 14) ^ (mr >>> 9 | he << 23), Ae = (mr >>> 14 | he << 18) ^ (mr >>> 18 | he << 14) ^ (he >>> 9 | mr << 23), Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Se = he & rr ^ ~he & dr, Ae = mr & wr ^ ~mr & $r, Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Se = Pe[ut * 2], Ae = Pe[ut * 2 + 1], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Se = G[ut % 16], Ae = j[ut % 16], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, st = Ue & 65535 | Je << 16, yt = Ve & 65535 | Fe << 16, Se = st, Ae = yt, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = (Lt >>> 28 | Qt << 4) ^ (Qt >>> 2 | Lt << 30) ^ (Qt >>> 7 | Lt << 25), Ae = (Qt >>> 28 | Lt << 4) ^ (Lt >>> 2 | Qt << 30) ^ (Lt >>> 7 | Qt << 25), Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Se = Lt & zt ^ Lt & Zt ^ zt & Zt, Ae = Qt & gr ^ Qt & lr ^ gr & lr, Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, pt = Ue & 65535 | Je << 16, xt = Ve & 65535 | Fe << 16, Se = Te, Ae = Tt, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = st, Ae = yt, Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, Te = Ue & 65535 | Je << 16, Tt = Ve & 65535 | Fe << 16, zt = se, Zt = de, Wt = xe, he = Te, rr = Re, dr = nt, pr = je, Lt = pt, gr = it, lr = et, Rr = St, mr = Tt, wr = At, $r = _t, Br = ht, Qt = xt, ut % 16 === 15)
            for (ot = 0; ot < 16; ot++)
              Se = G[ot], Ae = j[ot], Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = G[(ot + 9) % 16], Ae = j[(ot + 9) % 16], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, st = G[(ot + 1) % 16], yt = j[(ot + 1) % 16], Se = (st >>> 1 | yt << 31) ^ (st >>> 8 | yt << 24) ^ st >>> 7, Ae = (yt >>> 1 | st << 31) ^ (yt >>> 8 | st << 24) ^ (yt >>> 7 | st << 25), Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, st = G[(ot + 14) % 16], yt = j[(ot + 14) % 16], Se = (st >>> 19 | yt << 13) ^ (yt >>> 29 | st << 3) ^ st >>> 6, Ae = (yt >>> 19 | st << 13) ^ (st >>> 29 | yt << 3) ^ (yt >>> 6 | st << 26), Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, G[ot] = Ue & 65535 | Je << 16, j[ot] = Ve & 65535 | Fe << 16;
        Se = Lt, Ae = Qt, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = $[0], Ae = z[0], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, $[0] = Lt = Ue & 65535 | Je << 16, z[0] = Qt = Ve & 65535 | Fe << 16, Se = zt, Ae = gr, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = $[1], Ae = z[1], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, $[1] = zt = Ue & 65535 | Je << 16, z[1] = gr = Ve & 65535 | Fe << 16, Se = Zt, Ae = lr, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = $[2], Ae = z[2], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, $[2] = Zt = Ue & 65535 | Je << 16, z[2] = lr = Ve & 65535 | Fe << 16, Se = Wt, Ae = Rr, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = $[3], Ae = z[3], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, $[3] = Wt = Ue & 65535 | Je << 16, z[3] = Rr = Ve & 65535 | Fe << 16, Se = he, Ae = mr, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = $[4], Ae = z[4], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, $[4] = he = Ue & 65535 | Je << 16, z[4] = mr = Ve & 65535 | Fe << 16, Se = rr, Ae = wr, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = $[5], Ae = z[5], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, $[5] = rr = Ue & 65535 | Je << 16, z[5] = wr = Ve & 65535 | Fe << 16, Se = dr, Ae = $r, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = $[6], Ae = z[6], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, $[6] = dr = Ue & 65535 | Je << 16, z[6] = $r = Ve & 65535 | Fe << 16, Se = pr, Ae = Br, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = $[7], Ae = z[7], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, $[7] = pr = Ue & 65535 | Je << 16, z[7] = Br = Ve & 65535 | Fe << 16, Ir += 128, C -= 128;
      }
      return C;
    }
    function Ce($, z, H) {
      var C = new Int32Array(8), G = new Int32Array(8), j = new Uint8Array(256), se, de = H;
      for (C[0] = 1779033703, C[1] = 3144134277, C[2] = 1013904242, C[3] = 2773480762, C[4] = 1359893119, C[5] = 2600822924, C[6] = 528734635, C[7] = 1541459225, G[0] = 4089235720, G[1] = 2227873595, G[2] = 4271175723, G[3] = 1595750129, G[4] = 2917565137, G[5] = 725511199, G[6] = 4215389547, G[7] = 327033209, De(C, G, z, H), H %= 128, se = 0; se < H; se++) j[se] = z[de - H + se];
      for (j[H] = 128, H = 256 - 128 * (H < 112 ? 1 : 0), j[H - 9] = 0, P(j, H - 8, de / 536870912 | 0, de << 3), De(C, G, j, H), se = 0; se < 8; se++) P($, 8 * se, C[se], G[se]);
      return 0;
    }
    function $e($, z) {
      var H = r(), C = r(), G = r(), j = r(), se = r(), de = r(), xe = r(), Te = r(), Re = r();
      ce(H, $[1], $[0]), ce(Re, z[1], z[0]), D(H, H, Re), F(C, $[0], $[1]), F(Re, z[0], z[1]), D(C, C, Re), D(G, $[3], z[3]), D(G, G, d), D(j, $[2], z[2]), F(j, j, j), ce(se, C, H), ce(de, j, G), F(xe, j, G), F(Te, C, H), D($[0], se, de), D($[1], Te, xe), D($[2], xe, de), D($[3], se, Te);
    }
    function Me($, z, H) {
      var C;
      for (C = 0; C < 4; C++)
        E($[C], z[C], H);
    }
    function Ne($, z) {
      var H = r(), C = r(), G = r();
      Z(G, z[2]), D(H, z[0], G), D(C, z[1], G), S($, C), $[31] ^= M(H) << 7;
    }
    function Ke($, z, H) {
      var C, G;
      for (b($[0], o), b($[1], a), b($[2], a), b($[3], o), G = 255; G >= 0; --G)
        C = H[G / 8 | 0] >> (G & 7) & 1, Me($, z, C), $e(z, $), $e($, $), Me($, z, C);
    }
    function Le($, z) {
      var H = [r(), r(), r(), r()];
      b(H[0], p), b(H[1], w), b(H[2], a), D(H[3], p, w), Ke($, H, z);
    }
    function qe($, z, H) {
      var C = new Uint8Array(64), G = [r(), r(), r(), r()], j;
      for (H || n(z, 32), Ce(C, z, 32), C[0] &= 248, C[31] &= 127, C[31] |= 64, Le(G, C), Ne($, G), j = 0; j < 32; j++) z[j + 32] = $[j];
      return 0;
    }
    var ze = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function _e($, z) {
      var H, C, G, j;
      for (C = 63; C >= 32; --C) {
        for (H = 0, G = C - 32, j = C - 12; G < j; ++G)
          z[G] += H - 16 * z[C] * ze[G - (C - 32)], H = Math.floor((z[G] + 128) / 256), z[G] -= H * 256;
        z[G] += H, z[C] = 0;
      }
      for (H = 0, G = 0; G < 32; G++)
        z[G] += H - (z[31] >> 4) * ze[G], H = z[G] >> 8, z[G] &= 255;
      for (G = 0; G < 32; G++) z[G] -= H * ze[G];
      for (C = 0; C < 32; C++)
        z[C + 1] += z[C] >> 8, $[C] = z[C] & 255;
    }
    function Ze($) {
      var z = new Float64Array(64), H;
      for (H = 0; H < 64; H++) z[H] = $[H];
      for (H = 0; H < 64; H++) $[H] = 0;
      _e($, z);
    }
    function at($, z, H, C) {
      var G = new Uint8Array(64), j = new Uint8Array(64), se = new Uint8Array(64), de, xe, Te = new Float64Array(64), Re = [r(), r(), r(), r()];
      Ce(G, C, 32), G[0] &= 248, G[31] &= 127, G[31] |= 64;
      var nt = H + 64;
      for (de = 0; de < H; de++) $[64 + de] = z[de];
      for (de = 0; de < 32; de++) $[32 + de] = G[32 + de];
      for (Ce(se, $.subarray(32), H + 32), Ze(se), Le(Re, se), Ne($, Re), de = 32; de < 64; de++) $[de] = C[de];
      for (Ce(j, $, H + 64), Ze(j), de = 0; de < 64; de++) Te[de] = 0;
      for (de = 0; de < 32; de++) Te[de] = se[de];
      for (de = 0; de < 32; de++)
        for (xe = 0; xe < 32; xe++)
          Te[de + xe] += j[de] * G[xe];
      return _e($.subarray(32), Te), nt;
    }
    function ke($, z) {
      var H = r(), C = r(), G = r(), j = r(), se = r(), de = r(), xe = r();
      return b($[2], a), I($[1], z), oe(G, $[1]), D(j, G, l), ce(G, G, $[2]), F(j, $[2], j), oe(se, j), oe(de, se), D(xe, de, se), D(H, xe, G), D(H, H, j), J(H, H), D(H, H, G), D(H, H, j), D(H, H, j), D($[0], H, j), oe(C, $[0]), D(C, C, j), v(C, G) && D($[0], $[0], _), oe(C, $[0]), D(C, C, j), v(C, G) ? -1 : (M($[0]) === z[31] >> 7 && ce($[0], o, $[0]), D($[3], $[0], $[1]), 0);
    }
    function Qe($, z, H, C) {
      var G, j = new Uint8Array(32), se = new Uint8Array(64), de = [r(), r(), r(), r()], xe = [r(), r(), r(), r()];
      if (H < 64 || ke(xe, C)) return -1;
      for (G = 0; G < H; G++) $[G] = z[G];
      for (G = 0; G < 32; G++) $[G + 32] = C[G];
      if (Ce(se, $, H), Ze(se), Ke(de, xe, se), Le(xe, z.subarray(32)), $e(de, xe), Ne(j, de), H -= 64, B(z, 0, j, 0)) {
        for (G = 0; G < H; G++) $[G] = 0;
        return -1;
      }
      for (G = 0; G < H; G++) $[G] = z[G + 64];
      return H;
    }
    var tt = 32, Ye = 24, dt = 32, lt = 16, ct = 32, qt = 32, Jt = 32, Et = 32, er = 32, Xt = Ye, Dt = dt, kt = lt, Ct = 64, mt = 32, Rt = 64, Nt = 32, bt = 64;
    e.lowlevel = {
      crypto_core_hsalsa20: V,
      crypto_stream_xor: Ee,
      crypto_stream: ge,
      crypto_stream_salsa20_xor: R,
      crypto_stream_salsa20: K,
      crypto_onetimeauth: A,
      crypto_onetimeauth_verify: m,
      crypto_verify_16: L,
      crypto_verify_32: B,
      crypto_secretbox: f,
      crypto_secretbox_open: g,
      crypto_scalarmult: ee,
      crypto_scalarmult_base: T,
      crypto_box_beforenm: re,
      crypto_box_afternm: pe,
      crypto_box: ue,
      crypto_box_open: ve,
      crypto_box_keypair: X,
      crypto_hash: Ce,
      crypto_sign: at,
      crypto_sign_keypair: qe,
      crypto_sign_open: Qe,
      crypto_secretbox_KEYBYTES: tt,
      crypto_secretbox_NONCEBYTES: Ye,
      crypto_secretbox_ZEROBYTES: dt,
      crypto_secretbox_BOXZEROBYTES: lt,
      crypto_scalarmult_BYTES: ct,
      crypto_scalarmult_SCALARBYTES: qt,
      crypto_box_PUBLICKEYBYTES: Jt,
      crypto_box_SECRETKEYBYTES: Et,
      crypto_box_BEFORENMBYTES: er,
      crypto_box_NONCEBYTES: Xt,
      crypto_box_ZEROBYTES: Dt,
      crypto_box_BOXZEROBYTES: kt,
      crypto_sign_BYTES: Ct,
      crypto_sign_PUBLICKEYBYTES: mt,
      crypto_sign_SECRETKEYBYTES: Rt,
      crypto_sign_SEEDBYTES: Nt,
      crypto_hash_BYTES: bt,
      gf: r,
      D: l,
      L: ze,
      pack25519: S,
      unpack25519: I,
      M: D,
      A: F,
      S: oe,
      Z: ce,
      pow2523: J,
      add: $e,
      set25519: b,
      modL: _e,
      scalarmult: Ke,
      scalarbase: Le
    };
    function $t($, z) {
      if ($.length !== tt) throw new Error("bad key size");
      if (z.length !== Ye) throw new Error("bad nonce size");
    }
    function Ft($, z) {
      if ($.length !== Jt) throw new Error("bad public key size");
      if (z.length !== Et) throw new Error("bad secret key size");
    }
    function rt() {
      for (var $ = 0; $ < arguments.length; $++)
        if (!(arguments[$] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function Bt($) {
      for (var z = 0; z < $.length; z++) $[z] = 0;
    }
    e.randomBytes = function($) {
      var z = new Uint8Array($);
      return n(z, $), z;
    }, e.secretbox = function($, z, H) {
      rt($, z, H), $t(H, z);
      for (var C = new Uint8Array(dt + $.length), G = new Uint8Array(C.length), j = 0; j < $.length; j++) C[j + dt] = $[j];
      return f(G, C, C.length, z, H), G.subarray(lt);
    }, e.secretbox.open = function($, z, H) {
      rt($, z, H), $t(H, z);
      for (var C = new Uint8Array(lt + $.length), G = new Uint8Array(C.length), j = 0; j < $.length; j++) C[j + lt] = $[j];
      return C.length < 32 || g(G, C, C.length, z, H) !== 0 ? null : G.subarray(dt);
    }, e.secretbox.keyLength = tt, e.secretbox.nonceLength = Ye, e.secretbox.overheadLength = lt, e.scalarMult = function($, z) {
      if (rt($, z), $.length !== qt) throw new Error("bad n size");
      if (z.length !== ct) throw new Error("bad p size");
      var H = new Uint8Array(ct);
      return ee(H, $, z), H;
    }, e.scalarMult.base = function($) {
      if (rt($), $.length !== qt) throw new Error("bad n size");
      var z = new Uint8Array(ct);
      return T(z, $), z;
    }, e.scalarMult.scalarLength = qt, e.scalarMult.groupElementLength = ct, e.box = function($, z, H, C) {
      var G = e.box.before(H, C);
      return e.secretbox($, z, G);
    }, e.box.before = function($, z) {
      rt($, z), Ft($, z);
      var H = new Uint8Array(er);
      return re(H, $, z), H;
    }, e.box.after = e.secretbox, e.box.open = function($, z, H, C) {
      var G = e.box.before(H, C);
      return e.secretbox.open($, z, G);
    }, e.box.open.after = e.secretbox.open, e.box.keyPair = function() {
      var $ = new Uint8Array(Jt), z = new Uint8Array(Et);
      return X($, z), { publicKey: $, secretKey: z };
    }, e.box.keyPair.fromSecretKey = function($) {
      if (rt($), $.length !== Et)
        throw new Error("bad secret key size");
      var z = new Uint8Array(Jt);
      return T(z, $), { publicKey: z, secretKey: new Uint8Array($) };
    }, e.box.publicKeyLength = Jt, e.box.secretKeyLength = Et, e.box.sharedKeyLength = er, e.box.nonceLength = Xt, e.box.overheadLength = e.secretbox.overheadLength, e.sign = function($, z) {
      if (rt($, z), z.length !== Rt)
        throw new Error("bad secret key size");
      var H = new Uint8Array(Ct + $.length);
      return at(H, $, $.length, z), H;
    }, e.sign.open = function($, z) {
      if (rt($, z), z.length !== mt)
        throw new Error("bad public key size");
      var H = new Uint8Array($.length), C = Qe(H, $, $.length, z);
      if (C < 0) return null;
      for (var G = new Uint8Array(C), j = 0; j < G.length; j++) G[j] = H[j];
      return G;
    }, e.sign.detached = function($, z) {
      for (var H = e.sign($, z), C = new Uint8Array(Ct), G = 0; G < C.length; G++) C[G] = H[G];
      return C;
    }, e.sign.detached.verify = function($, z, H) {
      if (rt($, z, H), z.length !== Ct)
        throw new Error("bad signature size");
      if (H.length !== mt)
        throw new Error("bad public key size");
      var C = new Uint8Array(Ct + $.length), G = new Uint8Array(Ct + $.length), j;
      for (j = 0; j < Ct; j++) C[j] = z[j];
      for (j = 0; j < $.length; j++) C[j + Ct] = $[j];
      return Qe(G, C, C.length, H) >= 0;
    }, e.sign.keyPair = function() {
      var $ = new Uint8Array(mt), z = new Uint8Array(Rt);
      return qe($, z), { publicKey: $, secretKey: z };
    }, e.sign.keyPair.fromSecretKey = function($) {
      if (rt($), $.length !== Rt)
        throw new Error("bad secret key size");
      for (var z = new Uint8Array(mt), H = 0; H < z.length; H++) z[H] = $[32 + H];
      return { publicKey: z, secretKey: new Uint8Array($) };
    }, e.sign.keyPair.fromSeed = function($) {
      if (rt($), $.length !== Nt)
        throw new Error("bad seed size");
      for (var z = new Uint8Array(mt), H = new Uint8Array(Rt), C = 0; C < 32; C++) H[C] = $[C];
      return qe(z, H, !0), { publicKey: z, secretKey: H };
    }, e.sign.publicKeyLength = mt, e.sign.secretKeyLength = Rt, e.sign.seedLength = Nt, e.sign.signatureLength = Ct, e.hash = function($) {
      rt($);
      var z = new Uint8Array(bt);
      return Ce(z, $, $.length), z;
    }, e.hash.hashLength = bt, e.verify = function($, z) {
      return rt($, z), $.length === 0 || z.length === 0 || $.length !== z.length ? !1 : O($, 0, z, 0, $.length) === 0;
    }, e.setPRNG = function($) {
      n = $;
    }, function() {
      var $ = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if ($ && $.getRandomValues) {
        var z = 65536;
        e.setPRNG(function(H, C) {
          var G, j = new Uint8Array(C);
          for (G = 0; G < C; G += z)
            $.getRandomValues(j.subarray(G, G + Math.min(C - G, z)));
          for (G = 0; G < C; G++) H[G] = j[G];
          Bt(j);
        });
      } else typeof e8 < "u" && ($ = Ql, $ && $.randomBytes && e.setPRNG(function(H, C) {
        var G, j = $.randomBytes(C);
        for (G = 0; G < C; G++) H[G] = j[G];
        Bt(j);
      }));
    }();
  })(t.exports ? t.exports : self.nacl = self.nacl || {});
})(xA);
var Gie = xA.exports;
const Td = /* @__PURE__ */ ns(Gie);
var ha;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR", t[t.MANIFEST_NOT_FOUND_ERROR = 2] = "MANIFEST_NOT_FOUND_ERROR", t[t.MANIFEST_CONTENT_ERROR = 3] = "MANIFEST_CONTENT_ERROR", t[t.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR", t[t.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(ha || (ha = {}));
var I5;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(I5 || (I5 = {}));
var gu;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR", t[t.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR", t[t.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(gu || (gu = {}));
var C5;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR", t[t.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR", t[t.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(C5 || (C5 = {}));
var T5;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR", t[t.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(T5 || (T5 = {}));
var R5;
(function(t) {
  t.MAINNET = "-239", t.TESTNET = "-3";
})(R5 || (R5 = {}));
function Yie(t, e) {
  const r = zl.encodeBase64(t);
  return e ? encodeURIComponent(r) : r;
}
function Jie(t, e) {
  return e && (t = decodeURIComponent(t)), zl.decodeBase64(t);
}
function Xie(t, e = !1) {
  let r;
  return t instanceof Uint8Array ? r = t : (typeof t != "string" && (t = JSON.stringify(t)), r = zl.decodeUTF8(t)), Yie(r, e);
}
function Zie(t, e = !1) {
  const r = Jie(t, e);
  return {
    toString() {
      return zl.encodeUTF8(r);
    },
    toObject() {
      try {
        return JSON.parse(zl.encodeUTF8(r));
      } catch {
        return null;
      }
    },
    toUint8Array() {
      return r;
    }
  };
}
const _A = {
  encode: Xie,
  decode: Zie
};
function Qie(t, e) {
  const r = new Uint8Array(t.length + e.length);
  return r.set(t), r.set(e, t.length), r;
}
function ese(t, e) {
  if (e >= t.length)
    throw new Error("Index is out of buffer");
  const r = t.slice(0, e), n = t.slice(e);
  return [r, n];
}
function o1(t) {
  let e = "";
  return t.forEach((r) => {
    e += ("0" + (r & 255).toString(16)).slice(-2);
  }), e;
}
function $0(t) {
  if (t.length % 2 !== 0)
    throw new Error(`Cannot convert ${t} to bytesArray`);
  const e = new Uint8Array(t.length / 2);
  for (let r = 0; r < t.length; r += 2)
    e[r / 2] = parseInt(t.slice(r, r + 2), 16);
  return e;
}
class Cv {
  constructor(e) {
    this.nonceLength = 24, this.keyPair = e ? this.createKeypairFromString(e) : this.createKeypair(), this.sessionId = o1(this.keyPair.publicKey);
  }
  createKeypair() {
    return Td.box.keyPair();
  }
  createKeypairFromString(e) {
    return {
      publicKey: $0(e.publicKey),
      secretKey: $0(e.secretKey)
    };
  }
  createNonce() {
    return Td.randomBytes(this.nonceLength);
  }
  encrypt(e, r) {
    const n = new TextEncoder().encode(e), i = this.createNonce(), s = Td.box(n, i, r, this.keyPair.secretKey);
    return Qie(i, s);
  }
  decrypt(e, r) {
    const [n, i] = ese(e, this.nonceLength), s = Td.box.open(i, n, r, this.keyPair.secretKey);
    if (!s)
      throw new Error(`Decryption error: 
 message: ${e.toString()} 
 sender pubkey: ${r.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`);
    return new TextDecoder().decode(s);
  }
  stringifyKeypair() {
    return {
      publicKey: o1(this.keyPair.publicKey),
      secretKey: o1(this.keyPair.secretKey)
    };
  }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function tse(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
  return r;
}
function Mt(t, e, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function a(d) {
      try {
        l(n.next(d));
      } catch (p) {
        o(p);
      }
    }
    function u(d) {
      try {
        l(n.throw(d));
      } catch (p) {
        o(p);
      }
    }
    function l(d) {
      d.done ? s(d.value) : i(d.value).then(a, u);
    }
    l((n = n.apply(t, [])).next());
  });
}
class jt extends Error {
  constructor(e, r) {
    super(e, r), this.message = `${jt.prefix} ${this.constructor.name}${this.info ? ": " + this.info : ""}${e ? `
` + e : ""}`, Object.setPrototypeOf(this, jt.prototype);
  }
  get info() {
    return "";
  }
}
jt.prefix = "[TON_CONNECT_SDK_ERROR]";
class Sy extends jt {
  get info() {
    return "Passed DappMetadata is in incorrect format.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Sy.prototype);
  }
}
class Fp extends jt {
  get info() {
    return "Passed `tonconnect-manifest.json` contains errors. Check format of your manifest. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Fp.prototype);
  }
}
class jp extends jt {
  get info() {
    return "Manifest not found. Make sure you added `tonconnect-manifest.json` to the root of your app or passed correct manifestUrl. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, jp.prototype);
  }
}
class Ay extends jt {
  get info() {
    return "Wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Ay.prototype);
  }
}
class B0 extends jt {
  get info() {
    return "Send transaction or other protocol methods called while wallet is not connected.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, B0.prototype);
  }
}
function rse(t) {
  return "jsBridgeKey" in t;
}
class Up extends jt {
  get info() {
    return "User rejects the action in the wallet.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Up.prototype);
  }
}
class qp extends jt {
  get info() {
    return "Request to the wallet contains errors.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, qp.prototype);
  }
}
class zp extends jt {
  get info() {
    return "App tries to send rpc request to the injected wallet while not connected.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, zp.prototype);
  }
}
class Py extends jt {
  get info() {
    return "There is an attempt to connect to the injected wallet while it is not exists in the webpage.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Py.prototype);
  }
}
class My extends jt {
  get info() {
    return "An error occurred while fetching the wallets list.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, My.prototype);
  }
}
class Ca extends jt {
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Ca.prototype);
  }
}
const D5 = {
  [ha.UNKNOWN_ERROR]: Ca,
  [ha.USER_REJECTS_ERROR]: Up,
  [ha.BAD_REQUEST_ERROR]: qp,
  [ha.UNKNOWN_APP_ERROR]: zp,
  [ha.MANIFEST_NOT_FOUND_ERROR]: jp,
  [ha.MANIFEST_CONTENT_ERROR]: Fp
};
class nse {
  parseError(e) {
    let r = Ca;
    return e.code in D5 && (r = D5[e.code] || Ca), new r(e.message);
  }
}
const ise = new nse();
class sse {
  isError(e) {
    return "error" in e;
  }
}
const O5 = {
  [gu.UNKNOWN_ERROR]: Ca,
  [gu.USER_REJECTS_ERROR]: Up,
  [gu.BAD_REQUEST_ERROR]: qp,
  [gu.UNKNOWN_APP_ERROR]: zp
};
class ose extends sse {
  convertToRpcRequest(e) {
    return {
      method: "sendTransaction",
      params: [JSON.stringify(e)]
    };
  }
  parseAndThrowError(e) {
    let r = Ca;
    throw e.error.code in O5 && (r = O5[e.error.code] || Ca), new r(e.error.message);
  }
  convertFromRpcResponse(e) {
    return {
      boc: e.result
    };
  }
}
const Rd = new ose();
class ase {
  constructor(e, r) {
    this.storage = e, this.storeKey = "ton-connect-storage_http-bridge-gateway::" + r;
  }
  storeLastEventId(e) {
    return Mt(this, void 0, void 0, function* () {
      return this.storage.setItem(this.storeKey, e);
    });
  }
  removeLastEventId() {
    return Mt(this, void 0, void 0, function* () {
      return this.storage.removeItem(this.storeKey);
    });
  }
  getLastEventId() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.storage.getItem(this.storeKey);
      return e || null;
    });
  }
}
function cse(t) {
  return t.slice(-1) === "/" ? t.slice(0, -1) : t;
}
function EA(t, e) {
  return cse(t) + "/" + e;
}
function use(t) {
  if (!t)
    return !1;
  const e = new URL(t);
  return e.protocol === "tg:" || e.hostname === "t.me";
}
function fse(t) {
  return t.replaceAll(".", "%2E").replaceAll("-", "%2D").replaceAll("_", "%5F").replaceAll("&", "-").replaceAll("=", "__").replaceAll("%", "--");
}
function SA(t, e) {
  return Mt(this, void 0, void 0, function* () {
    return new Promise((r, n) => {
      var i, s;
      if (!((i = void 0) === null || i === void 0) && i.aborted) {
        n(new jt("Delay aborted"));
        return;
      }
      const o = setTimeout(() => r(), t);
      (s = void 0) === null || s === void 0 || s.addEventListener("abort", () => {
        clearTimeout(o), n(new jt("Delay aborted"));
      });
    });
  });
}
function As(t) {
  const e = new AbortController();
  return t != null && t.aborted ? e.abort() : t == null || t.addEventListener("abort", () => e.abort(), { once: !0 }), e;
}
function sl(t, e) {
  var r, n;
  return Mt(this, void 0, void 0, function* () {
    const i = (r = e == null ? void 0 : e.attempts) !== null && r !== void 0 ? r : 10, s = (n = e == null ? void 0 : e.delayMs) !== null && n !== void 0 ? n : 200, o = As(e == null ? void 0 : e.signal);
    if (typeof t != "function")
      throw new jt(`Expected a function, got ${typeof t}`);
    let a = 0, u;
    for (; a < i; ) {
      if (o.signal.aborted)
        throw new jt(`Aborted after attempts ${a}`);
      try {
        return yield t({ signal: o.signal });
      } catch (l) {
        u = l, a++, a < i && (yield SA(s));
      }
    }
    throw u;
  });
}
function An(...t) {
  try {
    console.debug("[TON_CONNECT_SDK]", ...t);
  } catch {
  }
}
function Bo(...t) {
  try {
    console.error("[TON_CONNECT_SDK]", ...t);
  } catch {
  }
}
function lse(...t) {
  try {
    console.warn("[TON_CONNECT_SDK]", ...t);
  } catch {
  }
}
function hse(t, e) {
  let r = null, n = null, i = null, s = null, o = null;
  const a = (p, ...w) => Mt(this, void 0, void 0, function* () {
    if (s = p ?? null, o == null || o.abort(), o = As(p), o.signal.aborted)
      throw new jt("Resource creation was aborted");
    n = w ?? null;
    const _ = t(o.signal, ...w);
    i = _;
    const P = yield _;
    if (i !== _ && P !== r)
      throw yield e(P), new jt("Resource creation was aborted by a new resource creation");
    return r = P, r;
  });
  return {
    create: a,
    current: () => r ?? null,
    dispose: () => Mt(this, void 0, void 0, function* () {
      try {
        const p = r;
        r = null;
        const w = i;
        i = null;
        try {
          o == null || o.abort();
        } catch {
        }
        yield Promise.allSettled([
          p ? e(p) : Promise.resolve(),
          w ? e(yield w) : Promise.resolve()
        ]);
      } catch {
      }
    }),
    recreate: (p) => Mt(this, void 0, void 0, function* () {
      const w = r, _ = i, P = n, O = s;
      if (yield SA(p), w === r && _ === i && P === n && O === s)
        return yield a(s, ...P ?? []);
      throw new jt("Resource recreation was aborted by a new resource creation");
    })
  };
}
function dse(t, e) {
  const r = e == null ? void 0 : e.timeout, n = e == null ? void 0 : e.signal, i = As(n);
  return new Promise((s, o) => Mt(this, void 0, void 0, function* () {
    if (i.signal.aborted) {
      o(new jt("Operation aborted"));
      return;
    }
    let a;
    typeof r < "u" && (a = setTimeout(() => {
      i.abort(), o(new jt(`Timeout after ${r}ms`));
    }, r)), i.signal.addEventListener("abort", () => {
      clearTimeout(a), o(new jt("Operation aborted"));
    }, { once: !0 });
    const u = { timeout: r, abort: i.signal };
    yield t((...l) => {
      clearTimeout(a), s(...l);
    }, () => {
      clearTimeout(a), o();
    }, u);
  }));
}
class a1 {
  constructor(e, r, n, i, s) {
    this.bridgeUrl = r, this.sessionId = n, this.listener = i, this.errorsListener = s, this.ssePath = "events", this.postPath = "message", this.heartbeatMessage = "heartbeat", this.defaultTtl = 300, this.defaultReconnectDelay = 2e3, this.defaultResendDelay = 5e3, this.eventSource = hse((o, a) => Mt(this, void 0, void 0, function* () {
      const u = {
        bridgeUrl: this.bridgeUrl,
        ssePath: this.ssePath,
        sessionId: this.sessionId,
        bridgeGatewayStorage: this.bridgeGatewayStorage,
        errorHandler: this.errorsHandler.bind(this),
        messageHandler: this.messagesHandler.bind(this),
        signal: o,
        openingDeadlineMS: a
      };
      return yield pse(u);
    }), (o) => Mt(this, void 0, void 0, function* () {
      o.close();
    })), this.bridgeGatewayStorage = new ase(e, r);
  }
  get isReady() {
    const e = this.eventSource.current();
    return (e == null ? void 0 : e.readyState) === EventSource.OPEN;
  }
  get isClosed() {
    const e = this.eventSource.current();
    return (e == null ? void 0 : e.readyState) !== EventSource.OPEN;
  }
  get isConnecting() {
    const e = this.eventSource.current();
    return (e == null ? void 0 : e.readyState) === EventSource.CONNECTING;
  }
  registerSession(e) {
    return Mt(this, void 0, void 0, function* () {
      yield this.eventSource.create(e == null ? void 0 : e.signal, e == null ? void 0 : e.openingDeadlineMS);
    });
  }
  send(e, r, n, i) {
    var s;
    return Mt(this, void 0, void 0, function* () {
      const o = {};
      typeof i == "number" ? o.ttl = i : (o.ttl = i == null ? void 0 : i.ttl, o.signal = i == null ? void 0 : i.signal, o.attempts = i == null ? void 0 : i.attempts);
      const a = new URL(EA(this.bridgeUrl, this.postPath));
      a.searchParams.append("client_id", this.sessionId), a.searchParams.append("to", r), a.searchParams.append("ttl", ((o == null ? void 0 : o.ttl) || this.defaultTtl).toString()), a.searchParams.append("topic", n);
      const u = _A.encode(e);
      yield sl((l) => Mt(this, void 0, void 0, function* () {
        const d = yield this.post(a, u, l.signal);
        if (!d.ok)
          throw new jt(`Bridge send failed, status ${d.status}`);
      }), {
        attempts: (s = o == null ? void 0 : o.attempts) !== null && s !== void 0 ? s : Number.MAX_SAFE_INTEGER,
        delayMs: this.defaultResendDelay,
        signal: o == null ? void 0 : o.signal
      });
    });
  }
  pause() {
    this.eventSource.dispose().catch((e) => Bo(`Bridge pause failed, ${e}`));
  }
  unPause() {
    return Mt(this, void 0, void 0, function* () {
      yield this.eventSource.recreate(0);
    });
  }
  close() {
    return Mt(this, void 0, void 0, function* () {
      yield this.eventSource.dispose().catch((e) => Bo(`Bridge close failed, ${e}`));
    });
  }
  setListener(e) {
    this.listener = e;
  }
  setErrorsListener(e) {
    this.errorsListener = e;
  }
  post(e, r, n) {
    return Mt(this, void 0, void 0, function* () {
      const i = yield fetch(e, {
        method: "post",
        body: r,
        signal: n
      });
      if (!i.ok)
        throw new jt(`Bridge send failed, status ${i.status}`);
      return i;
    });
  }
  errorsHandler(e, r) {
    return Mt(this, void 0, void 0, function* () {
      if (this.isConnecting)
        throw e.close(), new jt("Bridge error, failed to connect");
      if (this.isReady) {
        try {
          this.errorsListener(r);
        } catch {
        }
        return;
      }
      if (this.isClosed)
        return e.close(), An(`Bridge reconnecting, ${this.defaultReconnectDelay}ms delay`), yield this.eventSource.recreate(this.defaultReconnectDelay);
      throw new jt("Bridge error, unknown state");
    });
  }
  messagesHandler(e) {
    return Mt(this, void 0, void 0, function* () {
      if (e.data === this.heartbeatMessage || (yield this.bridgeGatewayStorage.storeLastEventId(e.lastEventId), this.isClosed))
        return;
      let r;
      try {
        r = JSON.parse(e.data);
      } catch (n) {
        throw new jt(`Bridge message parse failed, message ${n.data}`);
      }
      this.listener(r);
    });
  }
}
function pse(t) {
  return Mt(this, void 0, void 0, function* () {
    return yield dse((e, r, n) => Mt(this, void 0, void 0, function* () {
      var i;
      const o = As(n.signal).signal;
      if (o.aborted) {
        r(new jt("Bridge connection aborted"));
        return;
      }
      const a = new URL(EA(t.bridgeUrl, t.ssePath));
      a.searchParams.append("client_id", t.sessionId);
      const u = yield t.bridgeGatewayStorage.getLastEventId();
      if (u && a.searchParams.append("last_event_id", u), o.aborted) {
        r(new jt("Bridge connection aborted"));
        return;
      }
      const l = new EventSource(a.toString());
      l.onerror = (d) => Mt(this, void 0, void 0, function* () {
        if (o.aborted) {
          l.close(), r(new jt("Bridge connection aborted"));
          return;
        }
        try {
          const p = yield t.errorHandler(l, d);
          p !== l && l.close(), p && p !== l && e(p);
        } catch (p) {
          l.close(), r(p);
        }
      }), l.onopen = () => {
        if (o.aborted) {
          l.close(), r(new jt("Bridge connection aborted"));
          return;
        }
        e(l);
      }, l.onmessage = (d) => {
        if (o.aborted) {
          l.close(), r(new jt("Bridge connection aborted"));
          return;
        }
        t.messageHandler(d);
      }, (i = t.signal) === null || i === void 0 || i.addEventListener("abort", () => {
        l.close(), r(new jt("Bridge connection aborted"));
      });
    }), { timeout: t.openingDeadlineMS, signal: t.signal });
  });
}
function ol(t) {
  return !("connectEvent" in t);
}
class Wl {
  constructor(e) {
    this.storage = e, this.storeKey = "ton-connect-storage_bridge-connection";
  }
  storeConnection(e) {
    return Mt(this, void 0, void 0, function* () {
      if (e.type === "injected")
        return this.storage.setItem(this.storeKey, JSON.stringify(e));
      if (!ol(e)) {
        const n = {
          sessionKeyPair: e.session.sessionCrypto.stringifyKeypair(),
          walletPublicKey: e.session.walletPublicKey,
          bridgeUrl: e.session.bridgeUrl
        }, i = {
          type: "http",
          connectEvent: e.connectEvent,
          session: n,
          lastWalletEventId: e.lastWalletEventId,
          nextRpcRequestId: e.nextRpcRequestId
        };
        return this.storage.setItem(this.storeKey, JSON.stringify(i));
      }
      const r = {
        type: "http",
        connectionSource: e.connectionSource,
        sessionCrypto: e.sessionCrypto.stringifyKeypair()
      };
      return this.storage.setItem(this.storeKey, JSON.stringify(r));
    });
  }
  removeConnection() {
    return Mt(this, void 0, void 0, function* () {
      return this.storage.removeItem(this.storeKey);
    });
  }
  getConnection() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.storage.getItem(this.storeKey);
      if (!e)
        return null;
      const r = JSON.parse(e);
      if (r.type === "injected")
        return r;
      if ("connectEvent" in r) {
        const n = new Cv(r.session.sessionKeyPair);
        return {
          type: "http",
          connectEvent: r.connectEvent,
          lastWalletEventId: r.lastWalletEventId,
          nextRpcRequestId: r.nextRpcRequestId,
          session: {
            sessionCrypto: n,
            bridgeUrl: r.session.bridgeUrl,
            walletPublicKey: r.session.walletPublicKey
          }
        };
      }
      return {
        type: "http",
        sessionCrypto: new Cv(r.sessionCrypto),
        connectionSource: r.connectionSource
      };
    });
  }
  getHttpConnection() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (!e)
        throw new jt("Trying to read HTTP connection source while nothing is stored");
      if (e.type === "injected")
        throw new jt("Trying to read HTTP connection source while injected connection is stored");
      return e;
    });
  }
  getHttpPendingConnection() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (!e)
        throw new jt("Trying to read HTTP connection source while nothing is stored");
      if (e.type === "injected")
        throw new jt("Trying to read HTTP connection source while injected connection is stored");
      if (!ol(e))
        throw new jt("Trying to read HTTP-pending connection while http connection is stored");
      return e;
    });
  }
  getInjectedConnection() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (!e)
        throw new jt("Trying to read Injected bridge connection source while nothing is stored");
      if ((e == null ? void 0 : e.type) === "http")
        throw new jt("Trying to read Injected bridge connection source while HTTP connection is stored");
      return e;
    });
  }
  storedConnectionType() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.storage.getItem(this.storeKey);
      return e ? JSON.parse(e).type : null;
    });
  }
  storeLastWalletEventId(e) {
    return Mt(this, void 0, void 0, function* () {
      const r = yield this.getConnection();
      if (r && r.type === "http" && !ol(r))
        return r.lastWalletEventId = e, this.storeConnection(r);
    });
  }
  getLastWalletEventId() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (e && "lastWalletEventId" in e)
        return e.lastWalletEventId;
    });
  }
  increaseNextRpcRequestId() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (e && "nextRpcRequestId" in e) {
        const r = e.nextRpcRequestId || 0;
        return e.nextRpcRequestId = r + 1, this.storeConnection(e);
      }
    });
  }
  getNextRpcRequestId() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      return e && "nextRpcRequestId" in e && e.nextRpcRequestId || 0;
    });
  }
}
const AA = 2;
class Hl {
  constructor(e, r) {
    this.storage = e, this.walletConnectionSource = r, this.type = "http", this.standardUniversalLink = "tc://", this.pendingRequests = /* @__PURE__ */ new Map(), this.session = null, this.gateway = null, this.pendingGateways = [], this.listeners = [], this.defaultOpeningDeadlineMS = 12e3, this.defaultRetryTimeoutMS = 2e3, this.connectionStorage = new Wl(e);
  }
  static fromStorage(e) {
    return Mt(this, void 0, void 0, function* () {
      const n = yield new Wl(e).getHttpConnection();
      return ol(n) ? new Hl(e, n.connectionSource) : new Hl(e, { bridgeUrl: n.session.bridgeUrl });
    });
  }
  connect(e, r) {
    var n;
    const i = As(r == null ? void 0 : r.signal);
    (n = this.abortController) === null || n === void 0 || n.abort(), this.abortController = i, this.closeGateways();
    const s = new Cv();
    this.session = {
      sessionCrypto: s,
      bridgeUrl: "bridgeUrl" in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
    }, this.connectionStorage.storeConnection({
      type: "http",
      connectionSource: this.walletConnectionSource,
      sessionCrypto: s
    }).then(() => Mt(this, void 0, void 0, function* () {
      i.signal.aborted || (yield sl((a) => {
        var u;
        return this.openGateways(s, {
          openingDeadlineMS: (u = r == null ? void 0 : r.openingDeadlineMS) !== null && u !== void 0 ? u : this.defaultOpeningDeadlineMS,
          signal: a == null ? void 0 : a.signal
        });
      }, {
        attempts: Number.MAX_SAFE_INTEGER,
        delayMs: this.defaultRetryTimeoutMS,
        signal: i.signal
      }));
    }));
    const o = "universalLink" in this.walletConnectionSource && this.walletConnectionSource.universalLink ? this.walletConnectionSource.universalLink : this.standardUniversalLink;
    return this.generateUniversalLink(o, e);
  }
  restoreConnection(e) {
    var r, n;
    return Mt(this, void 0, void 0, function* () {
      const i = As(e == null ? void 0 : e.signal);
      if ((r = this.abortController) === null || r === void 0 || r.abort(), this.abortController = i, i.signal.aborted)
        return;
      this.closeGateways();
      const s = yield this.connectionStorage.getHttpConnection();
      if (!s || i.signal.aborted)
        return;
      const o = (n = e == null ? void 0 : e.openingDeadlineMS) !== null && n !== void 0 ? n : this.defaultOpeningDeadlineMS;
      if (ol(s))
        return this.session = {
          sessionCrypto: s.sessionCrypto,
          bridgeUrl: "bridgeUrl" in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
        }, yield this.openGateways(s.sessionCrypto, {
          openingDeadlineMS: o,
          signal: i == null ? void 0 : i.signal
        });
      if (Array.isArray(this.walletConnectionSource))
        throw new jt("Internal error. Connection source is array while WalletConnectionSourceHTTP was expected.");
      if (this.session = s.session, this.gateway && (An("Gateway is already opened, closing previous gateway"), yield this.gateway.close()), this.gateway = new a1(this.storage, this.walletConnectionSource.bridgeUrl, s.session.sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this)), !i.signal.aborted) {
        this.listeners.forEach((a) => a(s.connectEvent));
        try {
          yield sl((a) => this.gateway.registerSession({
            openingDeadlineMS: o,
            signal: a.signal
          }), {
            attempts: Number.MAX_SAFE_INTEGER,
            delayMs: this.defaultRetryTimeoutMS,
            signal: i.signal
          });
        } catch {
          yield this.disconnect({ signal: i.signal });
          return;
        }
      }
    });
  }
  sendRequest(e, r) {
    const n = {};
    return typeof r == "function" ? n.onRequestSent = r : (n.onRequestSent = r == null ? void 0 : r.onRequestSent, n.signal = r == null ? void 0 : r.signal, n.attempts = r == null ? void 0 : r.attempts), new Promise((i, s) => Mt(this, void 0, void 0, function* () {
      var o;
      if (!this.gateway || !this.session || !("walletPublicKey" in this.session))
        throw new jt("Trying to send bridge request without session");
      const a = (yield this.connectionStorage.getNextRpcRequestId()).toString();
      yield this.connectionStorage.increaseNextRpcRequestId(), An("Send http-bridge request:", Object.assign(Object.assign({}, e), { id: a }));
      const u = this.session.sessionCrypto.encrypt(JSON.stringify(Object.assign(Object.assign({}, e), { id: a })), $0(this.session.walletPublicKey));
      try {
        yield this.gateway.send(u, this.session.walletPublicKey, e.method, { attempts: n == null ? void 0 : n.attempts, signal: n == null ? void 0 : n.signal }), (o = n == null ? void 0 : n.onRequestSent) === null || o === void 0 || o.call(n), this.pendingRequests.set(a.toString(), i);
      } catch (l) {
        s(l);
      }
    }));
  }
  closeConnection() {
    this.closeGateways(), this.listeners = [], this.session = null, this.gateway = null;
  }
  disconnect(e) {
    return Mt(this, void 0, void 0, function* () {
      return new Promise((r) => Mt(this, void 0, void 0, function* () {
        let n = !1, i = null;
        const s = () => {
          n || (n = !0, this.removeBridgeAndSession().then(r));
        };
        try {
          this.closeGateways();
          const o = As(e == null ? void 0 : e.signal);
          i = setTimeout(() => {
            o.abort();
          }, this.defaultOpeningDeadlineMS), yield this.sendRequest({ method: "disconnect", params: [] }, {
            onRequestSent: s,
            signal: o.signal,
            attempts: 1
          });
        } catch (o) {
          An("Disconnect error:", o), n || this.removeBridgeAndSession().then(r);
        } finally {
          i && clearTimeout(i), s();
        }
      }));
    });
  }
  listen(e) {
    return this.listeners.push(e), () => this.listeners = this.listeners.filter((r) => r !== e);
  }
  pause() {
    var e;
    (e = this.gateway) === null || e === void 0 || e.pause(), this.pendingGateways.forEach((r) => r.pause());
  }
  unPause() {
    return Mt(this, void 0, void 0, function* () {
      const e = this.pendingGateways.map((r) => r.unPause());
      this.gateway && e.push(this.gateway.unPause()), yield Promise.all(e);
    });
  }
  pendingGatewaysListener(e, r, n) {
    return Mt(this, void 0, void 0, function* () {
      if (!this.pendingGateways.includes(e)) {
        yield e.close();
        return;
      }
      return this.closeGateways({ except: e }), this.gateway && (An("Gateway is already opened, closing previous gateway"), yield this.gateway.close()), this.session.bridgeUrl = r, this.gateway = e, this.gateway.setErrorsListener(this.gatewayErrorsListener.bind(this)), this.gateway.setListener(this.gatewayListener.bind(this)), this.gatewayListener(n);
    });
  }
  gatewayListener(e) {
    return Mt(this, void 0, void 0, function* () {
      const r = JSON.parse(this.session.sessionCrypto.decrypt(_A.decode(e.message).toUint8Array(), $0(e.from)));
      if (An("Wallet message received:", r), !("event" in r)) {
        const i = r.id.toString(), s = this.pendingRequests.get(i);
        if (!s) {
          An(`Response id ${i} doesn't match any request's id`);
          return;
        }
        s(r), this.pendingRequests.delete(i);
        return;
      }
      if (r.id !== void 0) {
        const i = yield this.connectionStorage.getLastWalletEventId();
        if (i !== void 0 && r.id <= i) {
          Bo(`Received event id (=${r.id}) must be greater than stored last wallet event id (=${i}) `);
          return;
        }
        r.event !== "connect" && (yield this.connectionStorage.storeLastWalletEventId(r.id));
      }
      const n = this.listeners;
      r.event === "connect" && (yield this.updateSession(r, e.from)), r.event === "disconnect" && (An("Removing bridge and session: received disconnect event"), yield this.removeBridgeAndSession()), n.forEach((i) => i(r));
    });
  }
  gatewayErrorsListener(e) {
    return Mt(this, void 0, void 0, function* () {
      throw new jt(`Bridge error ${JSON.stringify(e)}`);
    });
  }
  updateSession(e, r) {
    return Mt(this, void 0, void 0, function* () {
      this.session = Object.assign(Object.assign({}, this.session), { walletPublicKey: r });
      const n = e.payload.items.find((s) => s.name === "ton_addr"), i = Object.assign(Object.assign({}, e), { payload: Object.assign(Object.assign({}, e.payload), { items: [n] }) });
      yield this.connectionStorage.storeConnection({
        type: "http",
        session: this.session,
        lastWalletEventId: e.id,
        connectEvent: i,
        nextRpcRequestId: 0
      });
    });
  }
  removeBridgeAndSession() {
    return Mt(this, void 0, void 0, function* () {
      this.closeConnection(), yield this.connectionStorage.removeConnection();
    });
  }
  generateUniversalLink(e, r) {
    return use(e) ? this.generateTGUniversalLink(e, r) : this.generateRegularUniversalLink(e, r);
  }
  generateRegularUniversalLink(e, r) {
    const n = new URL(e);
    return n.searchParams.append("v", AA.toString()), n.searchParams.append("id", this.session.sessionCrypto.sessionId), n.searchParams.append("r", JSON.stringify(r)), n.toString();
  }
  generateTGUniversalLink(e, r) {
    const i = this.generateRegularUniversalLink("about:blank", r).split("?")[1], s = "tonconnect-" + fse(i), o = this.convertToDirectLink(e), a = new URL(o);
    return a.searchParams.append("startapp", s), a.toString();
  }
  // TODO: Remove this method after all dApps and the wallets-list.json have been updated
  convertToDirectLink(e) {
    const r = new URL(e);
    return r.searchParams.has("attach") && (r.searchParams.delete("attach"), r.pathname += "/start"), r.toString();
  }
  openGateways(e, r) {
    return Mt(this, void 0, void 0, function* () {
      if (Array.isArray(this.walletConnectionSource)) {
        this.pendingGateways.map((n) => n.close().catch()), this.pendingGateways = this.walletConnectionSource.map((n) => {
          const i = new a1(this.storage, n.bridgeUrl, e.sessionId, () => {
          }, () => {
          });
          return i.setListener((s) => this.pendingGatewaysListener(i, n.bridgeUrl, s)), i;
        }), yield Promise.allSettled(this.pendingGateways.map((n) => sl((i) => {
          var s;
          return this.pendingGateways.some((o) => o === n) ? n.registerSession({
            openingDeadlineMS: (s = r == null ? void 0 : r.openingDeadlineMS) !== null && s !== void 0 ? s : this.defaultOpeningDeadlineMS,
            signal: i.signal
          }) : n.close();
        }, {
          attempts: Number.MAX_SAFE_INTEGER,
          delayMs: this.defaultRetryTimeoutMS,
          signal: r == null ? void 0 : r.signal
        })));
        return;
      } else
        return this.gateway && (An("Gateway is already opened, closing previous gateway"), yield this.gateway.close()), this.gateway = new a1(this.storage, this.walletConnectionSource.bridgeUrl, e.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this)), yield this.gateway.registerSession({
          openingDeadlineMS: r == null ? void 0 : r.openingDeadlineMS,
          signal: r == null ? void 0 : r.signal
        });
    });
  }
  closeGateways(e) {
    var r;
    (r = this.gateway) === null || r === void 0 || r.close(), this.pendingGateways.filter((n) => n !== (e == null ? void 0 : e.except)).forEach((n) => n.close()), this.pendingGateways = [];
  }
}
function N5(t, e) {
  return PA(t, [e]);
}
function PA(t, e) {
  return !t || typeof t != "object" ? !1 : e.every((r) => r in t);
}
function gse(t) {
  try {
    return !N5(t, "tonconnect") || !N5(t.tonconnect, "walletInfo") ? !1 : PA(t.tonconnect.walletInfo, [
      "name",
      "app_name",
      "image",
      "about_url",
      "platforms"
    ]);
  } catch {
    return !1;
  }
}
class mu {
  constructor() {
    this.storage = {};
  }
  static getInstance() {
    return mu.instance || (mu.instance = new mu()), mu.instance;
  }
  get length() {
    return Object.keys(this.storage).length;
  }
  clear() {
    this.storage = {};
  }
  getItem(e) {
    var r;
    return (r = this.storage[e]) !== null && r !== void 0 ? r : null;
  }
  key(e) {
    var r;
    const n = Object.keys(this.storage);
    return e < 0 || e >= n.length ? null : (r = n[e]) !== null && r !== void 0 ? r : null;
  }
  removeItem(e) {
    delete this.storage[e];
  }
  setItem(e, r) {
    this.storage[e] = r;
  }
}
function Wp() {
  if (!(typeof window > "u"))
    return window;
}
function mse() {
  const t = Wp();
  if (!t)
    return [];
  try {
    return Object.keys(t);
  } catch {
    return [];
  }
}
function vse() {
  if (!(typeof document > "u"))
    return document;
}
function bse() {
  var t;
  const e = (t = Wp()) === null || t === void 0 ? void 0 : t.location.origin;
  return e ? e + "/tonconnect-manifest.json" : "";
}
function yse() {
  if (wse())
    return localStorage;
  if (xse())
    throw new jt("`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector");
  return mu.getInstance();
}
function wse() {
  try {
    return typeof localStorage < "u";
  } catch {
    return !1;
  }
}
function xse() {
  return typeof process < "u" && process.versions != null && process.versions.node != null;
}
class bi {
  constructor(e, r) {
    this.injectedWalletKey = r, this.type = "injected", this.unsubscribeCallback = null, this.listenSubscriptions = !1, this.listeners = [];
    const n = bi.window;
    if (!bi.isWindowContainsWallet(n, r))
      throw new Py();
    this.connectionStorage = new Wl(e), this.injectedWallet = n[r].tonconnect;
  }
  static fromStorage(e) {
    return Mt(this, void 0, void 0, function* () {
      const n = yield new Wl(e).getInjectedConnection();
      return new bi(e, n.jsBridgeKey);
    });
  }
  static isWalletInjected(e) {
    return bi.isWindowContainsWallet(this.window, e);
  }
  static isInsideWalletBrowser(e) {
    return bi.isWindowContainsWallet(this.window, e) ? this.window[e].tonconnect.isWalletBrowser : !1;
  }
  static getCurrentlyInjectedWallets() {
    return this.window ? mse().filter(([n, i]) => gse(i)).map(([n, i]) => ({
      name: i.tonconnect.walletInfo.name,
      appName: i.tonconnect.walletInfo.app_name,
      aboutUrl: i.tonconnect.walletInfo.about_url,
      imageUrl: i.tonconnect.walletInfo.image,
      tondns: i.tonconnect.walletInfo.tondns,
      jsBridgeKey: n,
      injected: !0,
      embedded: i.tonconnect.isWalletBrowser,
      platforms: i.tonconnect.walletInfo.platforms
    })) : [];
  }
  static isWindowContainsWallet(e, r) {
    return !!e && r in e && typeof e[r] == "object" && "tonconnect" in e[r];
  }
  connect(e) {
    this._connect(AA, e);
  }
  restoreConnection() {
    return Mt(this, void 0, void 0, function* () {
      try {
        An("Injected Provider restoring connection...");
        const e = yield this.injectedWallet.restoreConnection();
        An("Injected Provider restoring connection response", e), e.event === "connect" ? (this.makeSubscriptions(), this.listeners.forEach((r) => r(e))) : yield this.connectionStorage.removeConnection();
      } catch (e) {
        yield this.connectionStorage.removeConnection(), console.error(e);
      }
    });
  }
  closeConnection() {
    this.listenSubscriptions && this.injectedWallet.disconnect(), this.closeAllListeners();
  }
  disconnect() {
    return Mt(this, void 0, void 0, function* () {
      return new Promise((e) => {
        const r = () => {
          this.closeAllListeners(), this.connectionStorage.removeConnection().then(e);
        };
        try {
          this.injectedWallet.disconnect(), r();
        } catch (n) {
          An(n), this.sendRequest({
            method: "disconnect",
            params: []
          }, r);
        }
      });
    });
  }
  closeAllListeners() {
    var e;
    this.listenSubscriptions = !1, this.listeners = [], (e = this.unsubscribeCallback) === null || e === void 0 || e.call(this);
  }
  listen(e) {
    return this.listeners.push(e), () => this.listeners = this.listeners.filter((r) => r !== e);
  }
  sendRequest(e, r) {
    var n;
    return Mt(this, void 0, void 0, function* () {
      const i = {};
      typeof r == "function" ? i.onRequestSent = r : (i.onRequestSent = r == null ? void 0 : r.onRequestSent, i.signal = r == null ? void 0 : r.signal);
      const s = (yield this.connectionStorage.getNextRpcRequestId()).toString();
      yield this.connectionStorage.increaseNextRpcRequestId(), An("Send injected-bridge request:", Object.assign(Object.assign({}, e), { id: s }));
      const o = this.injectedWallet.send(Object.assign(Object.assign({}, e), { id: s }));
      return o.then((a) => An("Wallet message received:", a)), (n = i == null ? void 0 : i.onRequestSent) === null || n === void 0 || n.call(i), o;
    });
  }
  _connect(e, r) {
    return Mt(this, void 0, void 0, function* () {
      try {
        An(`Injected Provider connect request: protocolVersion: ${e}, message:`, r);
        const n = yield this.injectedWallet.connect(e, r);
        An("Injected Provider connect response:", n), n.event === "connect" && (yield this.updateSession(), this.makeSubscriptions()), this.listeners.forEach((i) => i(n));
      } catch (n) {
        An("Injected Provider connect error:", n);
        const i = {
          event: "connect_error",
          payload: {
            code: 0,
            message: n == null ? void 0 : n.toString()
          }
        };
        this.listeners.forEach((s) => s(i));
      }
    });
  }
  makeSubscriptions() {
    this.listenSubscriptions = !0, this.unsubscribeCallback = this.injectedWallet.listen((e) => {
      An("Wallet message received:", e), this.listenSubscriptions && this.listeners.forEach((r) => r(e)), e.event === "disconnect" && this.disconnect();
    });
  }
  updateSession() {
    return this.connectionStorage.storeConnection({
      type: "injected",
      jsBridgeKey: this.injectedWalletKey,
      nextRpcRequestId: 0
    });
  }
}
bi.window = Wp();
class _se {
  constructor() {
    this.localStorage = yse();
  }
  getItem(e) {
    return Mt(this, void 0, void 0, function* () {
      return this.localStorage.getItem(e);
    });
  }
  removeItem(e) {
    return Mt(this, void 0, void 0, function* () {
      this.localStorage.removeItem(e);
    });
  }
  setItem(e, r) {
    return Mt(this, void 0, void 0, function* () {
      this.localStorage.setItem(e, r);
    });
  }
}
function MA(t) {
  return Sse(t) && t.injected;
}
function Ese(t) {
  return MA(t) && t.embedded;
}
function Sse(t) {
  return "jsBridgeKey" in t;
}
const Ase = [
  {
    app_name: "telegram-wallet",
    name: "Wallet",
    image: "https://wallet.tg/images/logo-288.png",
    about_url: "https://wallet.tg/",
    universal_url: "https://t.me/wallet?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://bridge.ton.space/bridge"
      }
    ],
    platforms: ["ios", "android", "macos", "windows", "linux"]
  },
  {
    app_name: "tonkeeper",
    name: "Tonkeeper",
    image: "https://tonkeeper.com/assets/tonconnect-icon.png",
    tondns: "tonkeeper.ton",
    about_url: "https://tonkeeper.com",
    universal_url: "https://app.tonkeeper.com/ton-connect",
    deepLink: "tonkeeper-tc://",
    bridge: [
      {
        type: "sse",
        url: "https://bridge.tonapi.io/bridge"
      },
      {
        type: "js",
        key: "tonkeeper"
      }
    ],
    platforms: ["ios", "android", "chrome", "firefox", "macos"]
  },
  {
    app_name: "mytonwallet",
    name: "MyTonWallet",
    image: "https://static.mytonwallet.io/icon-256.png",
    about_url: "https://mytonwallet.io",
    universal_url: "https://connect.mytonwallet.org",
    bridge: [
      {
        type: "js",
        key: "mytonwallet"
      },
      {
        type: "sse",
        url: "https://tonconnectbridge.mytonwallet.org/bridge/"
      }
    ],
    platforms: ["chrome", "windows", "macos", "linux", "ios", "android", "firefox"]
  },
  {
    app_name: "openmask",
    name: "OpenMask",
    image: "https://raw.githubusercontent.com/OpenProduct/openmask-extension/main/public/openmask-logo-288.png",
    about_url: "https://www.openmask.app/",
    bridge: [
      {
        type: "js",
        key: "openmask"
      }
    ],
    platforms: ["chrome"]
  },
  {
    app_name: "tonhub",
    name: "Tonhub",
    image: "https://tonhub.com/tonconnect_logo.png",
    about_url: "https://tonhub.com",
    universal_url: "https://tonhub.com/ton-connect",
    bridge: [
      {
        type: "js",
        key: "tonhub"
      },
      {
        type: "sse",
        url: "https://connect.tonhubapi.com/tonconnect"
      }
    ],
    platforms: ["ios", "android"]
  },
  {
    app_name: "dewallet",
    name: "DeWallet",
    image: "https://raw.githubusercontent.com/delab-team/manifests-images/main/WalletAvatar.png",
    about_url: "https://delabwallet.com",
    universal_url: "https://t.me/dewallet?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://sse-bridge.delab.team/bridge"
      }
    ],
    platforms: ["ios", "android"]
  },
  {
    app_name: "xtonwallet",
    name: "XTONWallet",
    image: "https://xtonwallet.com/assets/img/icon-256-back.png",
    about_url: "https://xtonwallet.com",
    bridge: [
      {
        type: "js",
        key: "xtonwallet"
      }
    ],
    platforms: ["chrome", "firefox"]
  },
  {
    app_name: "tonwallet",
    name: "TON Wallet",
    image: "https://wallet.ton.org/assets/ui/qr-logo.png",
    about_url: "https://chrome.google.com/webstore/detail/ton-wallet/nphplpgoakhhjchkkhmiggakijnkhfnd",
    bridge: [
      {
        type: "js",
        key: "tonwallet"
      }
    ],
    platforms: ["chrome"]
  },
  {
    app_name: "bitgetTonWallet",
    name: "Bitget Wallet",
    image: "https://raw.githubusercontent.com/bitkeepwallet/download/main/logo/png/bitget_wallet_logo_0_gas_fee.png",
    about_url: "https://web3.bitget.com",
    deepLink: "bitkeep://",
    bridge: [
      {
        type: "js",
        key: "bitgetTonWallet"
      },
      {
        type: "sse",
        url: "https://bridge.tonapi.io/bridge"
      }
    ],
    platforms: ["ios", "android", "chrome"],
    universal_url: "https://bkcode.vip/ton-connect"
  },
  {
    app_name: "safepalwallet",
    name: "SafePal",
    image: "https://s.pvcliping.com/web/public_image/SafePal_x288.png",
    tondns: "",
    about_url: "https://www.safepal.com",
    universal_url: "https://link.safepal.io/ton-connect",
    deepLink: "safepal-tc://",
    bridge: [
      {
        type: "sse",
        url: "https://ton-bridge.safepal.com/tonbridge/v1/bridge"
      },
      {
        type: "js",
        key: "safepalwallet"
      }
    ],
    platforms: ["ios", "android", "chrome", "firefox"]
  },
  {
    app_name: "okxTonWallet",
    name: "OKX Wallet",
    image: "https://static.okx.com/cdn/assets/imgs/247/58E63FEA47A2B7D7.png",
    about_url: "https://www.okx.com/web3",
    universal_url: "https://www.okx.com/download?appendQuery=true&deeplink=okx://web3/wallet/tonconnect",
    bridge: [
      {
        type: "js",
        key: "okxTonWallet"
      },
      {
        type: "sse",
        url: "https://www.okx.com/tonbridge/discover/rpc/bridge"
      }
    ],
    platforms: ["chrome", "safari", "firefox", "ios", "android"]
  },
  {
    app_name: "okxTonWalletTr",
    name: "OKX TR Wallet",
    image: "https://static.okx.com/cdn/assets/imgs/247/587A8296F0BB640F.png",
    about_url: "https://tr.okx.com/web3",
    universal_url: "https://tr.okx.com/download?appendQuery=true&deeplink=okxtr://web3/wallet/tonconnect",
    bridge: [
      {
        type: "js",
        key: "okxTonWallet"
      },
      {
        type: "sse",
        url: "https://www.okx.com/tonbridge/discover/rpc/bridge"
      }
    ],
    platforms: ["chrome", "safari", "firefox", "ios", "android"]
  }
];
class Tv {
  constructor(e) {
    this.walletsListCache = null, this.walletsListCacheCreationTimestamp = null, this.walletsListSource = "https://raw.githubusercontent.com/ton-blockchain/wallets-list/main/wallets-v2.json", e != null && e.walletsListSource && (this.walletsListSource = e.walletsListSource), e != null && e.cacheTTLMs && (this.cacheTTLMs = e.cacheTTLMs);
  }
  getWallets() {
    return Mt(this, void 0, void 0, function* () {
      return this.cacheTTLMs && this.walletsListCacheCreationTimestamp && Date.now() > this.walletsListCacheCreationTimestamp + this.cacheTTLMs && (this.walletsListCache = null), this.walletsListCache || (this.walletsListCache = this.fetchWalletsList(), this.walletsListCache.then(() => {
        this.walletsListCacheCreationTimestamp = Date.now();
      }).catch(() => {
        this.walletsListCache = null, this.walletsListCacheCreationTimestamp = null;
      })), this.walletsListCache;
    });
  }
  getEmbeddedWallet() {
    return Mt(this, void 0, void 0, function* () {
      const r = (yield this.getWallets()).filter(Ese);
      return r.length !== 1 ? null : r[0];
    });
  }
  fetchWalletsList() {
    return Mt(this, void 0, void 0, function* () {
      let e = [];
      try {
        if (e = yield (yield fetch(this.walletsListSource)).json(), !Array.isArray(e))
          throw new My("Wrong wallets list format, wallets list must be an array.");
        const i = e.filter((s) => !this.isCorrectWalletConfigDTO(s));
        i.length && (Bo(`Wallet(s) ${i.map((s) => s.name).join(", ")} config format is wrong. They were removed from the wallets list.`), e = e.filter((s) => this.isCorrectWalletConfigDTO(s)));
      } catch (n) {
        Bo(n), e = Ase;
      }
      let r = [];
      try {
        r = bi.getCurrentlyInjectedWallets();
      } catch (n) {
        Bo(n);
      }
      return this.mergeWalletsLists(this.walletConfigDTOListToWalletConfigList(e), r);
    });
  }
  walletConfigDTOListToWalletConfigList(e) {
    return e.map((r) => {
      const i = {
        name: r.name,
        appName: r.app_name,
        imageUrl: r.image,
        aboutUrl: r.about_url,
        tondns: r.tondns,
        platforms: r.platforms
      };
      return r.bridge.forEach((s) => {
        if (s.type === "sse" && (i.bridgeUrl = s.url, i.universalLink = r.universal_url, i.deepLink = r.deepLink), s.type === "js") {
          const o = s.key;
          i.jsBridgeKey = o, i.injected = bi.isWalletInjected(o), i.embedded = bi.isInsideWalletBrowser(o);
        }
      }), i;
    });
  }
  mergeWalletsLists(e, r) {
    return [...new Set(e.concat(r).map((i) => i.name)).values()].map((i) => {
      const s = e.find((a) => a.name === i), o = r.find((a) => a.name === i);
      return Object.assign(Object.assign({}, s && Object.assign({}, s)), o && Object.assign({}, o));
    });
  }
  // eslint-disable-next-line complexity
  isCorrectWalletConfigDTO(e) {
    if (!e || typeof e != "object")
      return !1;
    const r = "name" in e, n = "app_name" in e, i = "image" in e, s = "about_url" in e, o = "platforms" in e;
    if (!r || !i || !s || !o || !n || !e.platforms || !Array.isArray(e.platforms) || !e.platforms.length || !("bridge" in e) || !Array.isArray(e.bridge) || !e.bridge.length)
      return !1;
    const a = e.bridge;
    if (a.some((d) => !d || typeof d != "object" || !("type" in d)))
      return !1;
    const u = a.find((d) => d.type === "sse");
    if (u && (!("url" in u) || !u.url || !e.universal_url))
      return !1;
    const l = a.find((d) => d.type === "js");
    return !(l && (!("key" in l) || !l.key));
  }
}
class F0 extends jt {
  get info() {
    return "Wallet doesn't support requested feature method.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, F0.prototype);
  }
}
function Pse(t, e) {
  const r = t.includes("SendTransaction"), n = t.find((i) => i && typeof i == "object" && i.name === "SendTransaction");
  if (!r && !n)
    throw new F0("Wallet doesn't support SendTransaction feature.");
  if (n && n.maxMessages !== void 0) {
    if (n.maxMessages < e.requiredMessagesNumber)
      throw new F0(`Wallet is not able to handle such SendTransaction request. Max support messages number is ${n.maxMessages}, but ${e.requiredMessagesNumber} is required.`);
    return;
  }
  lse("Connected wallet didn't provide information about max allowed messages in the SendTransaction request. Request may be rejected by the wallet.");
}
function Mse() {
  return {
    type: "request-version"
  };
}
function Ise(t) {
  return {
    type: "response-version",
    version: t
  };
}
function rf(t) {
  return {
    ton_connect_sdk_lib: t.ton_connect_sdk_lib,
    ton_connect_ui_lib: t.ton_connect_ui_lib
  };
}
function nf(t, e) {
  var r, n, i, s, o, a, u, l;
  const p = ((r = e == null ? void 0 : e.connectItems) === null || r === void 0 ? void 0 : r.tonProof) && "proof" in e.connectItems.tonProof ? "ton_proof" : "ton_addr";
  return {
    wallet_address: (i = (n = e == null ? void 0 : e.account) === null || n === void 0 ? void 0 : n.address) !== null && i !== void 0 ? i : null,
    wallet_type: (s = e == null ? void 0 : e.device.appName) !== null && s !== void 0 ? s : null,
    wallet_version: (o = e == null ? void 0 : e.device.appVersion) !== null && o !== void 0 ? o : null,
    auth_type: p,
    custom_data: Object.assign({ chain_id: (u = (a = e == null ? void 0 : e.account) === null || a === void 0 ? void 0 : a.chain) !== null && u !== void 0 ? u : null, provider: (l = e == null ? void 0 : e.provider) !== null && l !== void 0 ? l : null }, rf(t))
  };
}
function Cse(t) {
  return {
    type: "connection-started",
    custom_data: rf(t)
  };
}
function Tse(t, e) {
  return Object.assign({ type: "connection-completed", is_success: !0 }, nf(t, e));
}
function Rse(t, e, r) {
  return {
    type: "connection-error",
    is_success: !1,
    error_message: e,
    error_code: r ?? null,
    custom_data: rf(t)
  };
}
function Dse(t) {
  return {
    type: "connection-restoring-started",
    custom_data: rf(t)
  };
}
function Ose(t, e) {
  return Object.assign({ type: "connection-restoring-completed", is_success: !0 }, nf(t, e));
}
function Nse(t, e) {
  return {
    type: "connection-restoring-error",
    is_success: !1,
    error_message: e,
    custom_data: rf(t)
  };
}
function Iy(t, e) {
  var r, n, i, s;
  return {
    valid_until: (r = String(e.validUntil)) !== null && r !== void 0 ? r : null,
    from: (s = (n = e.from) !== null && n !== void 0 ? n : (i = t == null ? void 0 : t.account) === null || i === void 0 ? void 0 : i.address) !== null && s !== void 0 ? s : null,
    messages: e.messages.map((o) => {
      var a, u;
      return {
        address: (a = o.address) !== null && a !== void 0 ? a : null,
        amount: (u = o.amount) !== null && u !== void 0 ? u : null
      };
    })
  };
}
function Lse(t, e, r) {
  return Object.assign(Object.assign({ type: "transaction-sent-for-signature" }, nf(t, e)), Iy(e, r));
}
function kse(t, e, r, n) {
  return Object.assign(Object.assign({ type: "transaction-signed", is_success: !0, signed_transaction: n.boc }, nf(t, e)), Iy(e, r));
}
function $se(t, e, r, n, i) {
  return Object.assign(Object.assign({ type: "transaction-signing-failed", is_success: !1, error_message: n, error_code: i ?? null }, nf(t, e)), Iy(e, r));
}
function Bse(t, e, r) {
  return Object.assign({ type: "disconnection", scope: r }, nf(t, e));
}
class Fse {
  constructor() {
    this.window = Wp();
  }
  /**
   * Dispatches an event with the given name and details to the browser window.
   * @param eventName - The name of the event to dispatch.
   * @param eventDetails - The details of the event to dispatch.
   * @returns A promise that resolves when the event has been dispatched.
   */
  dispatchEvent(e, r) {
    var n;
    return Mt(this, void 0, void 0, function* () {
      const i = new CustomEvent(e, { detail: r });
      (n = this.window) === null || n === void 0 || n.dispatchEvent(i);
    });
  }
  /**
   * Adds an event listener to the browser window.
   * @param eventName - The name of the event to listen for.
   * @param listener - The listener to add.
   * @param options - The options for the listener.
   * @returns A function that removes the listener.
   */
  addEventListener(e, r, n) {
    var i;
    return Mt(this, void 0, void 0, function* () {
      return (i = this.window) === null || i === void 0 || i.addEventListener(e, r, n), () => {
        var s;
        return (s = this.window) === null || s === void 0 ? void 0 : s.removeEventListener(e, r);
      };
    });
  }
}
class jse {
  constructor(e) {
    var r;
    this.eventPrefix = "ton-connect-", this.tonConnectUiVersion = null, this.eventDispatcher = (r = e == null ? void 0 : e.eventDispatcher) !== null && r !== void 0 ? r : new Fse(), this.tonConnectSdkVersion = e.tonConnectSdkVersion, this.init().catch();
  }
  /**
   * Version of the library.
   */
  get version() {
    return rf({
      ton_connect_sdk_lib: this.tonConnectSdkVersion,
      ton_connect_ui_lib: this.tonConnectUiVersion
    });
  }
  /**
   * Called once when the tracker is created and request version other libraries.
   */
  init() {
    return Mt(this, void 0, void 0, function* () {
      try {
        yield this.setRequestVersionHandler(), this.tonConnectUiVersion = yield this.requestTonConnectUiVersion();
      } catch {
      }
    });
  }
  /**
   * Set request version handler.
   * @private
   */
  setRequestVersionHandler() {
    return Mt(this, void 0, void 0, function* () {
      yield this.eventDispatcher.addEventListener("ton-connect-request-version", () => Mt(this, void 0, void 0, function* () {
        yield this.eventDispatcher.dispatchEvent("ton-connect-response-version", Ise(this.tonConnectSdkVersion));
      }));
    });
  }
  /**
   * Request TonConnect UI version.
   * @private
   */
  requestTonConnectUiVersion() {
    return Mt(this, void 0, void 0, function* () {
      return new Promise((e, r) => Mt(this, void 0, void 0, function* () {
        try {
          yield this.eventDispatcher.addEventListener("ton-connect-ui-response-version", (n) => {
            e(n.detail.version);
          }, { once: !0 }), yield this.eventDispatcher.dispatchEvent("ton-connect-ui-request-version", Mse());
        } catch (n) {
          r(n);
        }
      }));
    });
  }
  /**
   * Emit user action event to the window.
   * @param eventDetails
   * @private
   */
  dispatchUserActionEvent(e) {
    try {
      this.eventDispatcher.dispatchEvent(`${this.eventPrefix}${e.type}`, e).catch();
    } catch {
    }
  }
  /**
   * Track connection init event.
   * @param args
   */
  trackConnectionStarted(...e) {
    try {
      const r = Cse(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection success event.
   * @param args
   */
  trackConnectionCompleted(...e) {
    try {
      const r = Tse(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection error event.
   * @param args
   */
  trackConnectionError(...e) {
    try {
      const r = Rse(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection restoring init event.
   * @param args
   */
  trackConnectionRestoringStarted(...e) {
    try {
      const r = Dse(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection restoring success event.
   * @param args
   */
  trackConnectionRestoringCompleted(...e) {
    try {
      const r = Ose(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection restoring error event.
   * @param args
   */
  trackConnectionRestoringError(...e) {
    try {
      const r = Nse(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track disconnect event.
   * @param args
   */
  trackDisconnection(...e) {
    try {
      const r = Bse(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track transaction init event.
   * @param args
   */
  trackTransactionSentForSignature(...e) {
    try {
      const r = Lse(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track transaction signed event.
   * @param args
   */
  trackTransactionSigned(...e) {
    try {
      const r = kse(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track transaction error event.
   * @param args
   */
  trackTransactionSigningFailed(...e) {
    try {
      const r = $se(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
}
const Use = "3.0.5";
class yh {
  constructor(e) {
    if (this.walletsList = new Tv(), this._wallet = null, this.provider = null, this.statusChangeSubscriptions = [], this.statusChangeErrorSubscriptions = [], this.dappSettings = {
      manifestUrl: (e == null ? void 0 : e.manifestUrl) || bse(),
      storage: (e == null ? void 0 : e.storage) || new _se()
    }, this.walletsList = new Tv({
      walletsListSource: e == null ? void 0 : e.walletsListSource,
      cacheTTLMs: e == null ? void 0 : e.walletsListCacheTTLMs
    }), this.tracker = new jse({
      eventDispatcher: e == null ? void 0 : e.eventDispatcher,
      tonConnectSdkVersion: Use
    }), !this.dappSettings.manifestUrl)
      throw new Sy("Dapp tonconnect-manifest.json must be specified if window.location.origin is undefined. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest");
    this.bridgeConnectionStorage = new Wl(this.dappSettings.storage), e != null && e.disableAutoPauseConnection || this.addWindowFocusAndBlurSubscriptions();
  }
  /**
   * Returns available wallets list.
   */
  static getWallets() {
    return this.walletsList.getWallets();
  }
  /**
   * Shows if the wallet is connected right now.
   */
  get connected() {
    return this._wallet !== null;
  }
  /**
   * Current connected account or null if no account is connected.
   */
  get account() {
    var e;
    return ((e = this._wallet) === null || e === void 0 ? void 0 : e.account) || null;
  }
  /**
   * Current connected wallet or null if no account is connected.
   */
  get wallet() {
    return this._wallet;
  }
  set wallet(e) {
    this._wallet = e, this.statusChangeSubscriptions.forEach((r) => r(this._wallet));
  }
  /**
   * Returns available wallets list.
   */
  getWallets() {
    return this.walletsList.getWallets();
  }
  /**
   * Allows to subscribe to connection status changes and handle connection errors.
   * @param callback will be called after connections status changes with actual wallet or null.
   * @param errorsHandler (optional) will be called with some instance of TonConnectError when connect error is received.
   * @returns unsubscribe callback.
   */
  onStatusChange(e, r) {
    return this.statusChangeSubscriptions.push(e), r && this.statusChangeErrorSubscriptions.push(r), () => {
      this.statusChangeSubscriptions = this.statusChangeSubscriptions.filter((n) => n !== e), r && (this.statusChangeErrorSubscriptions = this.statusChangeErrorSubscriptions.filter((n) => n !== r));
    };
  }
  connect(e, r) {
    var n, i;
    const s = {};
    if (typeof r == "object" && "tonProof" in r && (s.request = r), typeof r == "object" && ("openingDeadlineMS" in r || "signal" in r || "request" in r) && (s.request = r == null ? void 0 : r.request, s.openingDeadlineMS = r == null ? void 0 : r.openingDeadlineMS, s.signal = r == null ? void 0 : r.signal), this.connected)
      throw new Ay();
    const o = As(s == null ? void 0 : s.signal);
    if ((n = this.abortController) === null || n === void 0 || n.abort(), this.abortController = o, o.signal.aborted)
      throw new jt("Connection was aborted");
    return (i = this.provider) === null || i === void 0 || i.closeConnection(), this.provider = this.createProvider(e), o.signal.addEventListener("abort", () => {
      var a;
      (a = this.provider) === null || a === void 0 || a.closeConnection(), this.provider = null;
    }), this.tracker.trackConnectionStarted(), this.provider.connect(this.createConnectRequest(s == null ? void 0 : s.request), {
      openingDeadlineMS: s == null ? void 0 : s.openingDeadlineMS,
      signal: o.signal
    });
  }
  /**
   * Try to restore existing session and reconnect to the corresponding wallet. Call it immediately when your app is loaded.
   */
  restoreConnection(e) {
    var r, n;
    return Mt(this, void 0, void 0, function* () {
      this.tracker.trackConnectionRestoringStarted();
      const i = As(e == null ? void 0 : e.signal);
      if ((r = this.abortController) === null || r === void 0 || r.abort(), this.abortController = i, i.signal.aborted) {
        this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
        return;
      }
      const [s, o] = yield Promise.all([
        this.bridgeConnectionStorage.storedConnectionType(),
        this.walletsList.getEmbeddedWallet()
      ]);
      if (i.signal.aborted) {
        this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
        return;
      }
      let a = null;
      try {
        switch (s) {
          case "http":
            a = yield Hl.fromStorage(this.dappSettings.storage);
            break;
          case "injected":
            a = yield bi.fromStorage(this.dappSettings.storage);
            break;
          default:
            if (o)
              a = this.createProvider(o);
            else
              return;
        }
      } catch {
        this.tracker.trackConnectionRestoringError("Provider is not restored"), yield this.bridgeConnectionStorage.removeConnection(), a == null || a.closeConnection(), a = null;
        return;
      }
      if (i.signal.aborted) {
        a == null || a.closeConnection(), this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
        return;
      }
      if (!a) {
        Bo("Provider is not restored"), this.tracker.trackConnectionRestoringError("Provider is not restored");
        return;
      }
      (n = this.provider) === null || n === void 0 || n.closeConnection(), this.provider = a, a.listen(this.walletEventsListener.bind(this));
      const u = () => {
        this.tracker.trackConnectionRestoringError("Connection restoring was aborted"), a == null || a.closeConnection(), a = null;
      };
      i.signal.addEventListener("abort", u);
      const l = sl((p) => Mt(this, void 0, void 0, function* () {
        yield a == null ? void 0 : a.restoreConnection({
          openingDeadlineMS: e == null ? void 0 : e.openingDeadlineMS,
          signal: p.signal
        }), i.signal.removeEventListener("abort", u), this.connected ? this.tracker.trackConnectionRestoringCompleted(this.wallet) : this.tracker.trackConnectionRestoringError("Connection restoring failed");
      }), {
        attempts: Number.MAX_SAFE_INTEGER,
        delayMs: 2e3,
        signal: e == null ? void 0 : e.signal
      }), d = new Promise(
        (p) => setTimeout(() => p(), 12e3)
        // connection deadline
      );
      return Promise.race([l, d]);
    });
  }
  sendTransaction(e, r) {
    return Mt(this, void 0, void 0, function* () {
      const n = {};
      typeof r == "function" ? n.onRequestSent = r : (n.onRequestSent = r == null ? void 0 : r.onRequestSent, n.signal = r == null ? void 0 : r.signal);
      const i = As(n == null ? void 0 : n.signal);
      if (i.signal.aborted)
        throw new jt("Transaction sending was aborted");
      this.checkConnection(), Pse(this.wallet.device.features, {
        requiredMessagesNumber: e.messages.length
      }), this.tracker.trackTransactionSentForSignature(this.wallet, e);
      const { validUntil: s } = e, o = tse(e, ["validUntil"]), a = e.from || this.account.address, u = e.network || this.account.chain, l = yield this.provider.sendRequest(Rd.convertToRpcRequest(Object.assign(Object.assign({}, o), {
        valid_until: s,
        from: a,
        network: u
      })), { onRequestSent: n.onRequestSent, signal: i.signal });
      if (Rd.isError(l))
        return this.tracker.trackTransactionSigningFailed(this.wallet, e, l.error.message, l.error.code), Rd.parseAndThrowError(l);
      const d = Rd.convertFromRpcResponse(l);
      return this.tracker.trackTransactionSigned(this.wallet, e, d), d;
    });
  }
  /**
   * Disconnect form thw connected wallet and drop current session.
   */
  disconnect(e) {
    var r;
    return Mt(this, void 0, void 0, function* () {
      if (!this.connected)
        throw new B0();
      const n = As(e == null ? void 0 : e.signal), i = this.abortController;
      if (this.abortController = n, n.signal.aborted)
        throw new jt("Disconnect was aborted");
      this.onWalletDisconnected("dapp"), yield (r = this.provider) === null || r === void 0 ? void 0 : r.disconnect({
        signal: n.signal
      }), i == null || i.abort();
    });
  }
  /**
   * Pause bridge HTTP connection. Might be helpful, if you want to pause connections while browser tab is unfocused,
   * or if you use SDK with NodeJS and want to save server resources.
   */
  pauseConnection() {
    var e;
    ((e = this.provider) === null || e === void 0 ? void 0 : e.type) === "http" && this.provider.pause();
  }
  /**
   * Unpause bridge HTTP connection if it is paused.
   */
  unPauseConnection() {
    var e;
    return ((e = this.provider) === null || e === void 0 ? void 0 : e.type) !== "http" ? Promise.resolve() : this.provider.unPause();
  }
  addWindowFocusAndBlurSubscriptions() {
    const e = vse();
    if (e)
      try {
        e.addEventListener("visibilitychange", () => {
          e.hidden ? this.pauseConnection() : this.unPauseConnection().catch();
        });
      } catch (r) {
        Bo("Cannot subscribe to the document.visibilitychange: ", r);
      }
  }
  createProvider(e) {
    let r;
    return !Array.isArray(e) && rse(e) ? r = new bi(this.dappSettings.storage, e.jsBridgeKey) : r = new Hl(this.dappSettings.storage, e), r.listen(this.walletEventsListener.bind(this)), r;
  }
  walletEventsListener(e) {
    switch (e.event) {
      case "connect":
        this.onWalletConnected(e.payload);
        break;
      case "connect_error":
        this.onWalletConnectError(e.payload);
        break;
      case "disconnect":
        this.onWalletDisconnected("wallet");
    }
  }
  onWalletConnected(e) {
    const r = e.items.find((s) => s.name === "ton_addr"), n = e.items.find((s) => s.name === "ton_proof");
    if (!r)
      throw new jt("ton_addr connection item was not found");
    const i = {
      device: e.device,
      provider: this.provider.type,
      account: {
        address: r.address,
        chain: r.network,
        walletStateInit: r.walletStateInit,
        publicKey: r.publicKey
      }
    };
    n && (i.connectItems = {
      tonProof: n
    }), this.wallet = i, this.tracker.trackConnectionCompleted(i);
  }
  onWalletConnectError(e) {
    const r = ise.parseError(e);
    if (this.statusChangeErrorSubscriptions.forEach((n) => n(r)), An(r), this.tracker.trackConnectionError(e.message, e.code), r instanceof jp || r instanceof Fp)
      throw Bo(r), r;
  }
  onWalletDisconnected(e) {
    this.tracker.trackDisconnection(this.wallet, e), this.wallet = null;
  }
  checkConnection() {
    if (!this.connected)
      throw new B0();
  }
  createConnectRequest(e) {
    const r = [
      {
        name: "ton_addr"
      }
    ];
    return e != null && e.tonProof && r.push({
      name: "ton_proof",
      payload: e.tonProof
    }), {
      manifestUrl: this.dappSettings.manifestUrl,
      items: r
    };
  }
}
yh.walletsList = new Tv();
yh.isWalletInjected = (t) => bi.isWalletInjected(t);
yh.isInsideWalletBrowser = (t) => bi.isInsideWalletBrowser(t);
for (let t = 0; t <= 255; t++) {
  let e = t.toString(16);
  e.length < 2 && (e = "0" + e);
}
function c1(t) {
  const { children: e, onClick: r } = t;
  return /* @__PURE__ */ le.jsx("button", { onClick: r, className: "xc-border xc-px-4 xc-py-2 xc-rounded-full xc-text-sm xc-flex xc-gap-2 xc-items-center", children: e });
}
function IA(t) {
  const { wallet: e, connector: r, loading: n } = t, i = Qn(null), s = Qn(), [o, a] = Yt(), [u, l] = Yt(), [d, p] = Yt("connect"), [w, _] = Yt(!1), [P, O] = Yt();
  function L(K) {
    var ge;
    (ge = s.current) == null || ge.update({
      data: K
    });
  }
  async function B() {
    _(!0);
    try {
      a("");
      const K = await ka.getNonce({ account_type: "block_chain" });
      if ("universalLink" in e && e.universalLink) {
        const ge = r.connect({
          universalLink: e.universalLink,
          bridgeUrl: e.bridgeUrl
        }, {
          request: { tonProof: K }
        });
        if (!ge) return;
        O(ge), L(ge), l(K);
      }
    } catch (K) {
      a(K.message);
    }
    _(!1);
  }
  function k() {
    s.current = new dA({
      width: 264,
      height: 264,
      margin: 0,
      type: "svg",
      qrOptions: {
        errorCorrectionLevel: "M"
      },
      dotsOptions: {
        color: "black",
        type: "rounded"
      },
      backgroundOptions: {
        color: "transparent"
      }
    }), s.current.append(i.current);
  }
  function q() {
    r.connect(e, {
      request: { tonProof: u }
    });
  }
  function U() {
    if ("deepLink" in e) {
      if (!e.deepLink || !P) return;
      const K = new URL(P), ge = `${e.deepLink}${K.search}`;
      window.open(ge);
    }
  }
  function V() {
    "universalLink" in e && e.universalLink && /t.me/.test(e.universalLink) && window.open(P);
  }
  const Q = wi(() => !!("deepLink" in e && e.deepLink), [e]), R = wi(() => !!("universalLink" in e && e.universalLink && /t.me/.test(e.universalLink)), [e]);
  return Dn(() => {
    k(), B();
  }, []), /* @__PURE__ */ le.jsxs(Rs, { children: [
    /* @__PURE__ */ le.jsx("div", { className: "xc-mb-6", children: /* @__PURE__ */ le.jsx(kc, { title: "Connect wallet", onBack: t.onBack }) }),
    /* @__PURE__ */ le.jsxs("div", { className: "xc-text-center xc-mb-6", children: [
      /* @__PURE__ */ le.jsxs("div", { className: "xc-relative xc-mx-auto xc-mb-6 xc-block xc-max-h-[272px] xc-max-w-[272px] xc-rounded-xl xc-bg-white xc-p-1", children: [
        /* @__PURE__ */ le.jsx("div", { className: "xc-aspect-[1/1] xc-flex xc-h-full xc-w-full xc-justify-center", ref: i }),
        /* @__PURE__ */ le.jsx("div", { className: "xc-absolute xc-left-0 xc-top-0 xc-flex xc-h-full xc-w-full xc-items-center xc-justify-center", children: w ? /* @__PURE__ */ le.jsx(Sc, { className: "xc-h-6 xc-w-6 xc-animate-spin xc-text-black", size: 20 }) : /* @__PURE__ */ le.jsx("img", { className: "xc-h-10 xc-w-10 xc-rounded-md", src: e.imageUrl }) })
      ] }),
      /* @__PURE__ */ le.jsx("p", { className: "xc-text-center", children: "Scan the QR code below with your phone's camera. " })
    ] }),
    /* @__PURE__ */ le.jsxs("div", { className: "xc-flex xc-justify-center xc-gap-2", children: [
      n && /* @__PURE__ */ le.jsx(Sc, { className: "xc-animate-spin" }),
      !w && !n && /* @__PURE__ */ le.jsxs(le.Fragment, { children: [
        MA(e) && /* @__PURE__ */ le.jsxs(c1, { onClick: q, children: [
          /* @__PURE__ */ le.jsx(GZ, { className: "xc-opacity-80" }),
          "Extension"
        ] }),
        Q && /* @__PURE__ */ le.jsxs(c1, { onClick: U, children: [
          /* @__PURE__ */ le.jsx(y7, { className: "xc-opacity-80" }),
          "Desktop"
        ] }),
        R && /* @__PURE__ */ le.jsx(c1, { onClick: V, children: "Telegram Mini App" })
      ] })
    ] })
  ] });
}
function qse(t) {
  const [e, r] = Yt(""), [n, i] = Yt(), [s, o] = Yt(), a = Ey(), [u, l] = Yt(!1);
  async function d(w) {
    var P, O;
    if (!w || !((P = w.connectItems) != null && P.tonProof)) return;
    l(!0);
    const _ = await ka.tonLogin({
      account_type: "block_chain",
      connector: "codatta_ton",
      account_enum: "C",
      wallet_name: w == null ? void 0 : w.device.appName,
      inviter_code: a.inviterCode,
      address: w.account.address,
      chain: w.account.chain,
      connect_info: [
        { name: "ton_addr", network: w.account.chain, ...w.account },
        (O = w.connectItems) == null ? void 0 : O.tonProof
      ],
      source: {
        device: a.device,
        channel: a.channel,
        app: a.app
      }
    });
    await t.onLogin(_.data), l(!1);
  }
  Dn(() => {
    const w = new yh({
      manifestUrl: "https://static.codatta.io/static/tonconnect-manifest.json?v=2"
    }), _ = w.onStatusChange(d);
    return o(w), r("select"), _;
  }, []);
  function p(w) {
    r("connect"), i(w);
  }
  return /* @__PURE__ */ le.jsxs(Rs, { children: [
    e === "select" && /* @__PURE__ */ le.jsx(
      yA,
      {
        connector: s,
        onSelect: p,
        onBack: t.onBack
      }
    ),
    e === "connect" && /* @__PURE__ */ le.jsx(
      IA,
      {
        connector: s,
        wallet: n,
        onBack: t.onBack,
        loading: u
      }
    )
  ] });
}
function CA(t) {
  const { children: e, className: r } = t, n = Qn(null), [i, s] = Rv.useState(0);
  function o() {
    var a;
    try {
      const u = ((a = n.current) == null ? void 0 : a.children) || [];
      let l = 0;
      for (let d = 0; d < u.length; d++)
        l += u[d].offsetHeight;
      s(l);
    } catch (u) {
      console.error(u);
    }
  }
  return Dn(() => {
    const a = new MutationObserver(o);
    return a.observe(n.current, { childList: !0, subtree: !0 }), () => a.disconnect();
  }, []), Dn(() => {
    console.log("maxHeight", i);
  }, [i]), /* @__PURE__ */ le.jsx(
    "div",
    {
      ref: n,
      className: r,
      style: {
        transition: "all 0.2s ease-in-out",
        overflow: "hidden",
        height: i
      },
      children: e
    }
  );
}
function zse() {
  return /* @__PURE__ */ le.jsxs("svg", { width: "121", height: "120", viewBox: "0 0 121 120", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ le.jsx("rect", { x: "0.5", width: "120", height: "120", rx: "60", fill: "#404049" }),
    /* @__PURE__ */ le.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M52.8709 61.106C52.8208 61.4482 52.7948 61.7979 52.7948 62.1535C52.7948 66.2529 56.2445 69.5761 60.5 69.5761C64.7554 69.5761 68.2052 66.2529 68.2052 62.1535C68.2052 61.7979 68.1792 61.4482 68.129 61.106H86.826V77.6174C86.826 78.6422 85.9636 79.473 84.8997 79.473H36.1002C35.0364 79.473 34.174 78.6422 34.174 77.6174V61.106H52.8709Z", fill: "#252532" }),
    /* @__PURE__ */ le.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M69.061 60.9416C69.061 65.6697 65.2281 69.5026 60.5 69.5026C55.7719 69.5026 51.939 65.6697 51.939 60.9416C51.939 60.7884 51.943 60.6362 51.951 60.485H33.5L39.7959 41.8696C40.0673 41.0671 40.8202 40.527 41.6674 40.527H79.3326C80.1798 40.527 80.9327 41.0671 81.2041 41.8696L87.5 60.485H69.049C69.057 60.6362 69.061 60.7884 69.061 60.9416Z", fill: "#252532" }),
    /* @__PURE__ */ le.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M67.8081 61.5708C67.8081 65.2243 64.5361 68.8446 60.4999 68.8446C56.4637 68.8446 53.1918 65.2243 53.1918 61.5708C53.1918 61.4524 53.1952 60.6762 53.202 60.5594H39.4268L44.8013 47.4919C45.033 46.8717 45.6757 46.4543 46.3989 46.4543H74.601C75.3242 46.4543 75.9669 46.8717 76.1986 47.4919L81.5731 60.5594H67.7979C67.8046 60.6762 67.8081 61.4524 67.8081 61.5708Z", fill: "#404049" }),
    /* @__PURE__ */ le.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M34.3232 60.6199V78.063C34.3232 78.6995 34.8392 79.2155 35.4757 79.2155H85.5245C86.1609 79.2155 86.6769 78.6995 86.6769 78.063V60.6199L80.4244 42.1328C80.2661 41.6647 79.8269 41.3496 79.3327 41.3496H41.6674C41.1733 41.3496 40.7341 41.6647 40.5758 42.1328L34.3232 60.6199Z", stroke: "#77777D", "stroke-width": "2" }),
    /* @__PURE__ */ le.jsx("path", { d: "M34.817 60.2823C37.4094 60.2823 48.1095 60.2823 51.1124 60.2823C52.348 60.2823 52.348 61.1507 52.348 61.5994C52.348 65.9638 55.9675 69.5019 60.4323 69.5019C64.8971 69.5019 68.5165 65.9638 68.5165 61.5994C68.5165 61.1507 68.5165 60.2823 69.7521 60.2823H86.1829", stroke: "#77777D", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" })
  ] });
}
function TA(t) {
  const { wallets: e } = Tp(), [r, n] = Yt(), i = wi(() => r ? e.filter((a) => a.key.toLowerCase().includes(r.toLowerCase())) : e, [r]);
  function s(a) {
    t.onSelectWallet(a);
  }
  function o(a) {
    n(a.target.value);
  }
  return /* @__PURE__ */ le.jsxs(Rs, { children: [
    /* @__PURE__ */ le.jsx("div", { className: "xc-mb-6", children: /* @__PURE__ */ le.jsx(kc, { title: "Select wallet", onBack: t.onBack }) }),
    /* @__PURE__ */ le.jsxs("div", { className: "xc-mb-6 xc-flex xc-gap-3 xc-px-4 xc-py-2 xc-border xc-rounded-xl xc-w-full xc-overflow-hidden xc-items-center xc-border-opacity-15 xc-border-white focus-within:xc-border-opacity-40", children: [
      /* @__PURE__ */ le.jsx(w7, { className: "xc-shrink-0 xc-opacity-50" }),
      /* @__PURE__ */ le.jsx("input", { type: "text", className: "xc-flex-1 xc-bg-transparent xc-appearance-none xc-outline-none", placeholder: "Search wallet", onInput: o })
    ] }),
    /* @__PURE__ */ le.jsx("div", { className: "xc-mb-4 xc-flex xc-h-[309px] xc-flex-col xc-gap-4 xc-overflow-scroll no-scrollbar", children: i.length ? i.map((a) => /* @__PURE__ */ le.jsx(
      V9,
      {
        wallet: a,
        onClick: s
      },
      `feature-${a.key}`
    )) : /* @__PURE__ */ le.jsx(zse, {}) })
  ] });
}
function tae(t) {
  const { onLogin: e, header: r, showEmailSignIn: n = !0, showMoreWallets: i = !0, showTonConnect: s = !0, showFeaturedWallets: o = !0 } = t, [a, u] = Yt(""), [l, d] = Yt(null), [p, w] = Yt("");
  function _(B) {
    d(B), u("evm-wallet");
  }
  function P(B) {
    u("email"), w(B);
  }
  async function O(B) {
    await e(B);
  }
  function L() {
    u("ton-wallet");
  }
  return Dn(() => {
    u("index");
  }, []), /* @__PURE__ */ le.jsx(uie, { config: t.config, children: /* @__PURE__ */ le.jsxs(CA, { className: "xc-rounded-2xl xc-transition-height xc-box-content xc-w-full xc-min-w-[277px] xc-max-w-[420px] xc-p-6 xc-bg-[rgb(28,28,38)] xc-text-white", children: [
    a === "evm-wallet" && /* @__PURE__ */ le.jsx(
      Hie,
      {
        onBack: () => u("index"),
        onLogin: O,
        wallet: l
      }
    ),
    a === "ton-wallet" && /* @__PURE__ */ le.jsx(
      qse,
      {
        onBack: () => u("index"),
        onLogin: O
      }
    ),
    a === "email" && /* @__PURE__ */ le.jsx(Sie, { email: p, onBack: () => u("index"), onLogin: O }),
    a === "index" && /* @__PURE__ */ le.jsx(
      tA,
      {
        header: r,
        onEmailConfirm: P,
        onSelectWallet: _,
        onSelectMoreWallets: () => {
          u("all-wallet");
        },
        onSelectTonConnect: L,
        config: {
          showEmailSignIn: n,
          showFeaturedWallets: o,
          showMoreWallets: i,
          showTonConnect: s
        }
      }
    ),
    a === "all-wallet" && /* @__PURE__ */ le.jsx(
      TA,
      {
        onBack: () => u("index"),
        onSelectWallet: _
      }
    )
  ] }) });
}
function Wse(t) {
  const { wallet: e, onConnect: r } = t, [n, i] = Yt(e.installed ? "connect" : "qr");
  async function s(o, a) {
    await r(o, a);
  }
  return /* @__PURE__ */ le.jsxs(Rs, { children: [
    /* @__PURE__ */ le.jsx("div", { className: "xc-mb-6", children: /* @__PURE__ */ le.jsx(kc, { title: "Connect wallet", onBack: t.onBack }) }),
    n === "qr" && /* @__PURE__ */ le.jsx(
      mA,
      {
        wallet: e,
        onGetExtension: () => i("get-extension"),
        onSignFinish: s
      }
    ),
    n === "connect" && /* @__PURE__ */ le.jsx(
      vA,
      {
        onShowQrCode: () => i("qr"),
        wallet: e,
        onSignFinish: s
      }
    ),
    n === "get-extension" && /* @__PURE__ */ le.jsx(bA, { wallet: e })
  ] });
}
function Hse(t) {
  const { email: e } = t, [r, n] = Yt("captcha");
  return /* @__PURE__ */ le.jsxs(Rs, { children: [
    /* @__PURE__ */ le.jsx("div", { className: "xc-mb-12", children: /* @__PURE__ */ le.jsx(kc, { title: "Sign in with email", onBack: t.onBack }) }),
    r === "captcha" && /* @__PURE__ */ le.jsx(lA, { email: e, onCodeSend: () => n("verify-email") }),
    r === "verify-email" && /* @__PURE__ */ le.jsx(fA, { email: e, onInputCode: t.onInputCode, onResendCode: () => n("captcha") })
  ] });
}
function rae(t) {
  const { onEvmWalletConnect: e, onTonWalletConnect: r, onEmailConnect: n, config: i = {
    showEmailSignIn: !1,
    showFeaturedWallets: !0,
    showMoreWallets: !0,
    showTonConnect: !0
  } } = t, [s, o] = Yt(""), [a, u] = Yt(), [l, d] = Yt(), p = Qn(), [w, _] = Yt("");
  function P(U) {
    u(U), o("evm-wallet-connect");
  }
  function O(U) {
    _(U), o("email-connect");
  }
  async function L(U, V) {
    await (e == null ? void 0 : e({
      chain_type: "eip155",
      client: U.client,
      connect_info: V,
      wallet: U
    })), o("index");
  }
  async function B(U, V) {
    await (n == null ? void 0 : n(U, V));
  }
  function k(U) {
    d(U), o("ton-wallet-connect");
  }
  async function q(U) {
    U && await (r == null ? void 0 : r({
      chain_type: "ton",
      client: p.current,
      connect_info: U,
      wallet: U
    }));
  }
  return Dn(() => {
    p.current = new yh({
      manifestUrl: "https://static.codatta.io/static/tonconnect-manifest.json?v=2"
    });
    const U = p.current.onStatusChange(q);
    return o("index"), U;
  }, []), /* @__PURE__ */ le.jsxs(CA, { className: "xc-rounded-2xl xc-transition-height xc-box-content xc-w-full xc-min-w-[277px] xc-max-w-[420px] xc-p-6 xc-bg-[rgb(28,28,38)] xc-text-white", children: [
    s === "evm-wallet-select" && /* @__PURE__ */ le.jsx(
      TA,
      {
        onBack: () => o("index"),
        onSelectWallet: P
      }
    ),
    s === "evm-wallet-connect" && /* @__PURE__ */ le.jsx(
      Wse,
      {
        onBack: () => o("index"),
        onConnect: L,
        wallet: a
      }
    ),
    s === "ton-wallet-select" && /* @__PURE__ */ le.jsx(
      yA,
      {
        connector: p.current,
        onSelect: k,
        onBack: () => o("index")
      }
    ),
    s === "ton-wallet-connect" && /* @__PURE__ */ le.jsx(
      IA,
      {
        connector: p.current,
        wallet: l,
        onBack: () => o("index")
      }
    ),
    s === "email-connect" && /* @__PURE__ */ le.jsx(Hse, { email: w, onBack: () => o("index"), onInputCode: B }),
    s === "index" && /* @__PURE__ */ le.jsx(
      tA,
      {
        onEmailConfirm: O,
        onSelectWallet: P,
        onSelectMoreWallets: () => o("evm-wallet-select"),
        onSelectTonConnect: () => o("ton-wallet-select"),
        config: i
      }
    )
  ] });
}
export {
  Qoe as C,
  V5 as H,
  Il as W,
  mc as a,
  XD as b,
  Xse as c,
  Yse as d,
  al as e,
  n0 as f,
  r0 as g,
  Jse as h,
  HD as i,
  jZ as j,
  tae as k,
  rae as l,
  Zse as r,
  qN as s,
  q0 as t,
  Tp as u
};
