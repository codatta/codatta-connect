var OR = Object.defineProperty;
var NR = (t, e, r) => e in t ? OR(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;
var Ds = (t, e, r) => NR(t, typeof e != "symbol" ? e + "" : e, r);
import * as Yt from "react";
import pv, { createContext as Ma, useContext as Tn, useState as Gt, useEffect as Dn, forwardRef as gv, createElement as qd, useId as mv, useCallback as vv, Component as LR, useLayoutEffect as kR, useRef as oi, useInsertionEffect as w5, useMemo as Ni, Fragment as x5, Children as $R, isValidElement as BR } from "react";
import "https://o.alicdn.com/captcha-frontend/aliyunCaptcha/AliyunCaptcha.js";
var gn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function rs(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function bv(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(t, n);
    Object.defineProperty(r, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return t[n];
      }
    });
  }), r;
}
var Ym = { exports: {} }, gf = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var g2;
function FR() {
  if (g2) return gf;
  g2 = 1;
  var t = pv, e = Symbol.for("react.element"), r = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(a, u, l) {
    var d, p = {}, w = null, A = null;
    l !== void 0 && (w = "" + l), u.key !== void 0 && (w = "" + u.key), u.ref !== void 0 && (A = u.ref);
    for (d in u) n.call(u, d) && !s.hasOwnProperty(d) && (p[d] = u[d]);
    if (a && a.defaultProps) for (d in u = a.defaultProps, u) p[d] === void 0 && (p[d] = u[d]);
    return { $$typeof: e, type: a, key: w, ref: A, props: p, _owner: i.current };
  }
  return gf.Fragment = r, gf.jsx = o, gf.jsxs = o, gf;
}
var mf = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var m2;
function jR() {
  return m2 || (m2 = 1, process.env.NODE_ENV !== "production" && function() {
    var t = pv, e = Symbol.for("react.element"), r = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), a = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), w = Symbol.for("react.lazy"), A = Symbol.for("react.offscreen"), P = Symbol.iterator, N = "@@iterator";
    function L(j) {
      if (j === null || typeof j != "object")
        return null;
      var se = P && j[P] || j[N];
      return typeof se == "function" ? se : null;
    }
    var $ = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function B(j) {
      {
        for (var se = arguments.length, de = new Array(se > 1 ? se - 1 : 0), xe = 1; xe < se; xe++)
          de[xe - 1] = arguments[xe];
        H("error", j, de);
      }
    }
    function H(j, se, de) {
      {
        var xe = $.ReactDebugCurrentFrame, Te = xe.getStackAddendum();
        Te !== "" && (se += "%s", de = de.concat([Te]));
        var Re = de.map(function(nt) {
          return String(nt);
        });
        Re.unshift("Warning: " + se), Function.prototype.apply.call(console[j], console, Re);
      }
    }
    var W = !1, V = !1, te = !1, R = !1, K = !1, ge;
    ge = Symbol.for("react.module.reference");
    function Ee(j) {
      return !!(typeof j == "string" || typeof j == "function" || j === n || j === s || K || j === i || j === l || j === d || R || j === A || W || V || te || typeof j == "object" && j !== null && (j.$$typeof === w || j.$$typeof === p || j.$$typeof === o || j.$$typeof === a || j.$$typeof === u || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      j.$$typeof === ge || j.getModuleId !== void 0));
    }
    function Y(j, se, de) {
      var xe = j.displayName;
      if (xe)
        return xe;
      var Te = se.displayName || se.name || "";
      return Te !== "" ? de + "(" + Te + ")" : de;
    }
    function S(j) {
      return j.displayName || "Context";
    }
    function m(j) {
      if (j == null)
        return null;
      if (typeof j.tag == "number" && B("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof j == "function")
        return j.displayName || j.name || null;
      if (typeof j == "string")
        return j;
      switch (j) {
        case n:
          return "Fragment";
        case r:
          return "Portal";
        case s:
          return "Profiler";
        case i:
          return "StrictMode";
        case l:
          return "Suspense";
        case d:
          return "SuspenseList";
      }
      if (typeof j == "object")
        switch (j.$$typeof) {
          case a:
            var se = j;
            return S(se) + ".Consumer";
          case o:
            var de = j;
            return S(de._context) + ".Provider";
          case u:
            return Y(j, j.render, "ForwardRef");
          case p:
            var xe = j.displayName || null;
            return xe !== null ? xe : m(j.type) || "Memo";
          case w: {
            var Te = j, Re = Te._payload, nt = Te._init;
            try {
              return m(nt(Re));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var f = Object.assign, g = 0, b, x, _, E, v, M, I;
    function F() {
    }
    F.__reactDisabledLog = !0;
    function ce() {
      {
        if (g === 0) {
          b = console.log, x = console.info, _ = console.warn, E = console.error, v = console.group, M = console.groupCollapsed, I = console.groupEnd;
          var j = {
            configurable: !0,
            enumerable: !0,
            value: F,
            writable: !0
          };
          Object.defineProperties(console, {
            info: j,
            log: j,
            warn: j,
            error: j,
            group: j,
            groupCollapsed: j,
            groupEnd: j
          });
        }
        g++;
      }
    }
    function D() {
      {
        if (g--, g === 0) {
          var j = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: f({}, j, {
              value: b
            }),
            info: f({}, j, {
              value: x
            }),
            warn: f({}, j, {
              value: _
            }),
            error: f({}, j, {
              value: E
            }),
            group: f({}, j, {
              value: v
            }),
            groupCollapsed: f({}, j, {
              value: M
            }),
            groupEnd: f({}, j, {
              value: I
            })
          });
        }
        g < 0 && B("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var oe = $.ReactCurrentDispatcher, Z;
    function J(j, se, de) {
      {
        if (Z === void 0)
          try {
            throw Error();
          } catch (Te) {
            var xe = Te.stack.trim().match(/\n( *(at )?)/);
            Z = xe && xe[1] || "";
          }
        return `
` + Z + j;
      }
    }
    var Q = !1, T;
    {
      var X = typeof WeakMap == "function" ? WeakMap : Map;
      T = new X();
    }
    function re(j, se) {
      if (!j || Q)
        return "";
      {
        var de = T.get(j);
        if (de !== void 0)
          return de;
      }
      var xe;
      Q = !0;
      var Te = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Re;
      Re = oe.current, oe.current = null, ce();
      try {
        if (se) {
          var nt = function() {
            throw Error();
          };
          if (Object.defineProperty(nt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(nt, []);
            } catch (_t) {
              xe = _t;
            }
            Reflect.construct(j, [], nt);
          } else {
            try {
              nt.call();
            } catch (_t) {
              xe = _t;
            }
            j.call(nt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (_t) {
            xe = _t;
          }
          j();
        }
      } catch (_t) {
        if (_t && xe && typeof _t.stack == "string") {
          for (var je = _t.stack.split(`
`), pt = xe.stack.split(`
`), it = je.length - 1, et = pt.length - 1; it >= 1 && et >= 0 && je[it] !== pt[et]; )
            et--;
          for (; it >= 1 && et >= 0; it--, et--)
            if (je[it] !== pt[et]) {
              if (it !== 1 || et !== 1)
                do
                  if (it--, et--, et < 0 || je[it] !== pt[et]) {
                    var St = `
` + je[it].replace(" at new ", " at ");
                    return j.displayName && St.includes("<anonymous>") && (St = St.replace("<anonymous>", j.displayName)), typeof j == "function" && T.set(j, St), St;
                  }
                while (it >= 1 && et >= 0);
              break;
            }
        }
      } finally {
        Q = !1, oe.current = Re, D(), Error.prepareStackTrace = Te;
      }
      var Tt = j ? j.displayName || j.name : "", At = Tt ? J(Tt) : "";
      return typeof j == "function" && T.set(j, At), At;
    }
    function pe(j, se, de) {
      return re(j, !1);
    }
    function ie(j) {
      var se = j.prototype;
      return !!(se && se.isReactComponent);
    }
    function ue(j, se, de) {
      if (j == null)
        return "";
      if (typeof j == "function")
        return re(j, ie(j));
      if (typeof j == "string")
        return J(j);
      switch (j) {
        case l:
          return J("Suspense");
        case d:
          return J("SuspenseList");
      }
      if (typeof j == "object")
        switch (j.$$typeof) {
          case u:
            return pe(j.render);
          case p:
            return ue(j.type, se, de);
          case w: {
            var xe = j, Te = xe._payload, Re = xe._init;
            try {
              return ue(Re(Te), se, de);
            } catch {
            }
          }
        }
      return "";
    }
    var ve = Object.prototype.hasOwnProperty, Pe = {}, De = $.ReactDebugCurrentFrame;
    function Ce(j) {
      if (j) {
        var se = j._owner, de = ue(j.type, j._source, se ? se.type : null);
        De.setExtraStackFrame(de);
      } else
        De.setExtraStackFrame(null);
    }
    function $e(j, se, de, xe, Te) {
      {
        var Re = Function.call.bind(ve);
        for (var nt in j)
          if (Re(j, nt)) {
            var je = void 0;
            try {
              if (typeof j[nt] != "function") {
                var pt = Error((xe || "React class") + ": " + de + " type `" + nt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof j[nt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw pt.name = "Invariant Violation", pt;
              }
              je = j[nt](se, nt, xe, de, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (it) {
              je = it;
            }
            je && !(je instanceof Error) && (Ce(Te), B("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", xe || "React class", de, nt, typeof je), Ce(null)), je instanceof Error && !(je.message in Pe) && (Pe[je.message] = !0, Ce(Te), B("Failed %s type: %s", de, je.message), Ce(null));
          }
      }
    }
    var Me = Array.isArray;
    function Ne(j) {
      return Me(j);
    }
    function Ke(j) {
      {
        var se = typeof Symbol == "function" && Symbol.toStringTag, de = se && j[Symbol.toStringTag] || j.constructor.name || "Object";
        return de;
      }
    }
    function Le(j) {
      try {
        return qe(j), !1;
      } catch {
        return !0;
      }
    }
    function qe(j) {
      return "" + j;
    }
    function ze(j) {
      if (Le(j))
        return B("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ke(j)), qe(j);
    }
    var _e = $.ReactCurrentOwner, Ze = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, at, ke, Qe;
    Qe = {};
    function tt(j) {
      if (ve.call(j, "ref")) {
        var se = Object.getOwnPropertyDescriptor(j, "ref").get;
        if (se && se.isReactWarning)
          return !1;
      }
      return j.ref !== void 0;
    }
    function Ye(j) {
      if (ve.call(j, "key")) {
        var se = Object.getOwnPropertyDescriptor(j, "key").get;
        if (se && se.isReactWarning)
          return !1;
      }
      return j.key !== void 0;
    }
    function dt(j, se) {
      if (typeof j.ref == "string" && _e.current && se && _e.current.stateNode !== se) {
        var de = m(_e.current.type);
        Qe[de] || (B('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', m(_e.current.type), j.ref), Qe[de] = !0);
      }
    }
    function lt(j, se) {
      {
        var de = function() {
          at || (at = !0, B("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", se));
        };
        de.isReactWarning = !0, Object.defineProperty(j, "key", {
          get: de,
          configurable: !0
        });
      }
    }
    function ct(j, se) {
      {
        var de = function() {
          ke || (ke = !0, B("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", se));
        };
        de.isReactWarning = !0, Object.defineProperty(j, "ref", {
          get: de,
          configurable: !0
        });
      }
    }
    var qt = function(j, se, de, xe, Te, Re, nt) {
      var je = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: j,
        key: se,
        ref: de,
        props: nt,
        // Record the component responsible for creating this element.
        _owner: Re
      };
      return je._store = {}, Object.defineProperty(je._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(je, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: xe
      }), Object.defineProperty(je, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Te
      }), Object.freeze && (Object.freeze(je.props), Object.freeze(je)), je;
    };
    function Jt(j, se, de, xe, Te) {
      {
        var Re, nt = {}, je = null, pt = null;
        de !== void 0 && (ze(de), je = "" + de), Ye(se) && (ze(se.key), je = "" + se.key), tt(se) && (pt = se.ref, dt(se, Te));
        for (Re in se)
          ve.call(se, Re) && !Ze.hasOwnProperty(Re) && (nt[Re] = se[Re]);
        if (j && j.defaultProps) {
          var it = j.defaultProps;
          for (Re in it)
            nt[Re] === void 0 && (nt[Re] = it[Re]);
        }
        if (je || pt) {
          var et = typeof j == "function" ? j.displayName || j.name || "Unknown" : j;
          je && lt(nt, et), pt && ct(nt, et);
        }
        return qt(j, je, pt, Te, xe, _e.current, nt);
      }
    }
    var Et = $.ReactCurrentOwner, er = $.ReactDebugCurrentFrame;
    function Xt(j) {
      if (j) {
        var se = j._owner, de = ue(j.type, j._source, se ? se.type : null);
        er.setExtraStackFrame(de);
      } else
        er.setExtraStackFrame(null);
    }
    var Dt;
    Dt = !1;
    function kt(j) {
      return typeof j == "object" && j !== null && j.$$typeof === e;
    }
    function Ct() {
      {
        if (Et.current) {
          var j = m(Et.current.type);
          if (j)
            return `

Check the render method of \`` + j + "`.";
        }
        return "";
      }
    }
    function gt(j) {
      return "";
    }
    var Rt = {};
    function Nt(j) {
      {
        var se = Ct();
        if (!se) {
          var de = typeof j == "string" ? j : j.displayName || j.name;
          de && (se = `

Check the top-level render call using <` + de + ">.");
        }
        return se;
      }
    }
    function vt(j, se) {
      {
        if (!j._store || j._store.validated || j.key != null)
          return;
        j._store.validated = !0;
        var de = Nt(se);
        if (Rt[de])
          return;
        Rt[de] = !0;
        var xe = "";
        j && j._owner && j._owner !== Et.current && (xe = " It was passed a child from " + m(j._owner.type) + "."), Xt(j), B('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', de, xe), Xt(null);
      }
    }
    function $t(j, se) {
      {
        if (typeof j != "object")
          return;
        if (Ne(j))
          for (var de = 0; de < j.length; de++) {
            var xe = j[de];
            kt(xe) && vt(xe, se);
          }
        else if (kt(j))
          j._store && (j._store.validated = !0);
        else if (j) {
          var Te = L(j);
          if (typeof Te == "function" && Te !== j.entries)
            for (var Re = Te.call(j), nt; !(nt = Re.next()).done; )
              kt(nt.value) && vt(nt.value, se);
        }
      }
    }
    function Ft(j) {
      {
        var se = j.type;
        if (se == null || typeof se == "string")
          return;
        var de;
        if (typeof se == "function")
          de = se.propTypes;
        else if (typeof se == "object" && (se.$$typeof === u || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        se.$$typeof === p))
          de = se.propTypes;
        else
          return;
        if (de) {
          var xe = m(se);
          $e(de, j.props, "prop", xe, j);
        } else if (se.PropTypes !== void 0 && !Dt) {
          Dt = !0;
          var Te = m(se);
          B("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Te || "Unknown");
        }
        typeof se.getDefaultProps == "function" && !se.getDefaultProps.isReactClassApproved && B("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function rt(j) {
      {
        for (var se = Object.keys(j.props), de = 0; de < se.length; de++) {
          var xe = se[de];
          if (xe !== "children" && xe !== "key") {
            Xt(j), B("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", xe), Xt(null);
            break;
          }
        }
        j.ref !== null && (Xt(j), B("Invalid attribute `ref` supplied to `React.Fragment`."), Xt(null));
      }
    }
    var Bt = {};
    function k(j, se, de, xe, Te, Re) {
      {
        var nt = Ee(j);
        if (!nt) {
          var je = "";
          (j === void 0 || typeof j == "object" && j !== null && Object.keys(j).length === 0) && (je += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var pt = gt();
          pt ? je += pt : je += Ct();
          var it;
          j === null ? it = "null" : Ne(j) ? it = "array" : j !== void 0 && j.$$typeof === e ? (it = "<" + (m(j.type) || "Unknown") + " />", je = " Did you accidentally export a JSX literal instead of a component?") : it = typeof j, B("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", it, je);
        }
        var et = Jt(j, se, de, Te, Re);
        if (et == null)
          return et;
        if (nt) {
          var St = se.children;
          if (St !== void 0)
            if (xe)
              if (Ne(St)) {
                for (var Tt = 0; Tt < St.length; Tt++)
                  $t(St[Tt], j);
                Object.freeze && Object.freeze(St);
              } else
                B("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              $t(St, j);
        }
        if (ve.call(se, "key")) {
          var At = m(j), _t = Object.keys(se).filter(function(st) {
            return st !== "key";
          }), ht = _t.length > 0 ? "{key: someKey, " + _t.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Bt[At + ht]) {
            var xt = _t.length > 0 ? "{" + _t.join(": ..., ") + ": ...}" : "{}";
            B(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ht, At, xt, At), Bt[At + ht] = !0;
          }
        }
        return j === n ? rt(et) : Ft(et), et;
      }
    }
    function U(j, se, de) {
      return k(j, se, de, !0);
    }
    function z(j, se, de) {
      return k(j, se, de, !1);
    }
    var C = z, G = U;
    mf.Fragment = n, mf.jsx = C, mf.jsxs = G;
  }()), mf;
}
process.env.NODE_ENV === "production" ? Ym.exports = FR() : Ym.exports = jR();
var fe = Ym.exports;
const Os = "https://static.codatta.io/codatta-connect/wallet-icons.svg?v=2", UR = [
  {
    featured: !0,
    name: "MetaMask",
    rdns: "io.metamask",
    image: `${Os}#metamask`,
    getWallet: {
      chrome_store_id: "nkbihfbeogaeaoehlefnkodbefgpgknn",
      brave_store_id: "nkbihfbeogaeaoehlefnkodbefgpgknn",
      edge_addon_id: "ejbalbakoplchlghecdalmeeeajnimhm",
      firefox_addon_id: "ether-metamask",
      play_store_id: "io.metamask",
      app_store_id: "id1438144202"
    },
    deep_link: "metamask://wc",
    universal_link: "https://metamask.app.link/wc"
  },
  {
    featured: !0,
    name: "OKX Wallet",
    rdns: "com.okex.wallet",
    image: `${Os}#okx`,
    getWallet: {
      chrome_store_id: "mcohilncbfahbmgdjkbpemcciiolgcge",
      brave_store_id: "mcohilncbfahbmgdjkbpemcciiolgcge",
      edge_addon_id: "pbpjkcldjiffchgbbndmhojiacbgflha",
      play_store_id: "com.okinc.okex.gp",
      app_store_id: "id1327268470"
    },
    deep_link: "okex://main/wc",
    universal_link: "okex://main/wc"
  },
  {
    featured: !0,
    name: "WalletConnect",
    image: `${Os}#walletconnect`
  },
  {
    featured: !1,
    name: "Coinbase Wallet",
    image: `${Os}#coinbase`
  },
  {
    featured: !1,
    name: "GateWallet",
    rdns: "io.gate.wallet",
    image: `${Os}#6e528abf-7a7d-47bd-d84d-481f169b1200`,
    getWallet: {
      chrome_store_id: "cpmkedoipcpimgecpmgpldfpohjplkpp",
      brave_store_id: "cpmkedoipcpimgecpmgpldfpohjplkpp",
      play_store_id: "com.gateio.gateio",
      app_store_id: "id1294998195",
      mac_app_store_id: "id1609559473"
    },
    deep_link: "https://www.gate.io/mobileapp",
    universal_link: "https://www.gate.io/mobileapp"
  },
  {
    featured: !1,
    name: "Onekey",
    rdns: "so.onekey.app.wallet",
    image: `${Os}#onekey`,
    getWallet: {
      chrome_store_id: "jnmbobjmhlngoefaiojfljckilhhlhcj",
      brave_store_id: "jnmbobjmhlngoefaiojfljckilhhlhcj",
      play_store_id: "so.onekey.app.wallet",
      app_store_id: "id1609559473"
    },
    deep_link: "onekey-wallet://",
    universal_link: "onekey://wc"
  },
  {
    featured: !1,
    name: "Infinity Wallet",
    image: `${Os}#9f259366-0bcd-4817-0af9-f78773e41900`,
    desktop_link: "infinity://wc"
  },
  {
    name: "Rabby Wallet",
    rdns: "io.rabby",
    featured: !1,
    image: `${Os}#rabby`,
    getWallet: {
      chrome_store_id: "acmacodkjbdgmoleebolmdjonilkdbch",
      brave_store_id: "acmacodkjbdgmoleebolmdjonilkdbch",
      play_store_id: "com.debank.rabbymobile",
      app_store_id: "id6474381673"
    }
  },
  {
    name: "Binance Web3 Wallet",
    featured: !1,
    image: `${Os}#ebac7b39-688c-41e3-7912-a4fefba74600`,
    getWallet: {
      play_store_id: "com.binance.dev",
      app_store_id: "id1436799971"
    }
  },
  {
    name: "Rainbow Wallet",
    rdns: "me.rainbow",
    featured: !1,
    image: `${Os}#rainbow`,
    getWallet: {
      chrome_store_id: "opfgelmcmbiajamepnmloijbpoleiama",
      edge_addon_id: "cpojfbodiccabbabgimdeohkkpjfpbnf",
      firefox_addon_id: "rainbow-extension",
      app_store_id: "id1457119021",
      play_store_id: "me.rainbow"
    }
  }
];
function qR(t, e) {
  const r = t.exec(e);
  return r == null ? void 0 : r.groups;
}
const v2 = /^tuple(?<array>(\[(\d*)\])*)$/;
function Jm(t) {
  let e = t.type;
  if (v2.test(t.type) && "components" in t) {
    e = "(";
    const r = t.components.length;
    for (let i = 0; i < r; i++) {
      const s = t.components[i];
      e += Jm(s), i < r - 1 && (e += ", ");
    }
    const n = qR(v2, t.type);
    return e += `)${(n == null ? void 0 : n.array) ?? ""}`, Jm({
      ...t,
      type: e
    });
  }
  return "indexed" in t && t.indexed && (e = `${e} indexed`), t.name ? `${e} ${t.name}` : e;
}
function vf(t) {
  let e = "";
  const r = t.length;
  for (let n = 0; n < r; n++) {
    const i = t[n];
    e += Jm(i), n !== r - 1 && (e += ", ");
  }
  return e;
}
function zR(t) {
  return t.type === "function" ? `function ${t.name}(${vf(t.inputs)})${t.stateMutability && t.stateMutability !== "nonpayable" ? ` ${t.stateMutability}` : ""}${t.outputs.length ? ` returns (${vf(t.outputs)})` : ""}` : t.type === "event" ? `event ${t.name}(${vf(t.inputs)})` : t.type === "error" ? `error ${t.name}(${vf(t.inputs)})` : t.type === "constructor" ? `constructor(${vf(t.inputs)})${t.stateMutability === "payable" ? " payable" : ""}` : t.type === "fallback" ? "fallback()" : "receive() external payable";
}
function bi(t, e, r) {
  const n = t[e.name];
  if (typeof n == "function")
    return n;
  const i = t[r];
  return typeof i == "function" ? i : (s) => e(t, s);
}
function vu(t, { includeName: e = !1 } = {}) {
  if (t.type !== "function" && t.type !== "event" && t.type !== "error")
    throw new tD(t.type);
  return `${t.name}(${yv(t.inputs, { includeName: e })})`;
}
function yv(t, { includeName: e = !1 } = {}) {
  return t ? t.map((r) => WR(r, { includeName: e })).join(e ? ", " : ",") : "";
}
function WR(t, { includeName: e }) {
  return t.type.startsWith("tuple") ? `(${yv(t.components, { includeName: e })})${t.type.slice(5)}` : t.type + (e && t.name ? ` ${t.name}` : "");
}
function ya(t, { strict: e = !0 } = {}) {
  return !t || typeof t != "string" ? !1 : e ? /^0x[0-9a-fA-F]*$/.test(t) : t.startsWith("0x");
}
function An(t) {
  return ya(t, { strict: !1 }) ? Math.ceil((t.length - 2) / 2) : t.length;
}
const _5 = "2.21.45";
let bf = {
  getDocsUrl: ({ docsBaseUrl: t, docsPath: e = "", docsSlug: r }) => e ? `${t ?? "https://viem.sh"}${e}${r ? `#${r}` : ""}` : void 0,
  version: `viem@${_5}`
};
class yt extends Error {
  constructor(e, r = {}) {
    var a;
    const n = (() => {
      var u;
      return r.cause instanceof yt ? r.cause.details : (u = r.cause) != null && u.message ? r.cause.message : r.details;
    })(), i = r.cause instanceof yt && r.cause.docsPath || r.docsPath, s = (a = bf.getDocsUrl) == null ? void 0 : a.call(bf, { ...r, docsPath: i }), o = [
      e || "An error occurred.",
      "",
      ...r.metaMessages ? [...r.metaMessages, ""] : [],
      ...s ? [`Docs: ${s}`] : [],
      ...n ? [`Details: ${n}`] : [],
      ...bf.version ? [`Version: ${bf.version}`] : []
    ].join(`
`);
    super(o, r.cause ? { cause: r.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = n, this.docsPath = i, this.metaMessages = r.metaMessages, this.name = r.name ?? this.name, this.shortMessage = e, this.version = _5;
  }
  walk(e) {
    return E5(this, e);
  }
}
function E5(t, e) {
  return e != null && e(t) ? t : t && typeof t == "object" && "cause" in t && t.cause !== void 0 ? E5(t.cause, e) : e ? null : t;
}
class HR extends yt {
  constructor({ docsPath: e }) {
    super([
      "A constructor was not found on the ABI.",
      "Make sure you are using the correct ABI and that the constructor exists on it."
    ].join(`
`), {
      docsPath: e,
      name: "AbiConstructorNotFoundError"
    });
  }
}
class b2 extends yt {
  constructor({ docsPath: e }) {
    super([
      "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
      "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
    ].join(`
`), {
      docsPath: e,
      name: "AbiConstructorParamsNotFoundError"
    });
  }
}
class KR extends yt {
  constructor({ data: e, params: r, size: n }) {
    super([`Data size of ${n} bytes is too small for given parameters.`].join(`
`), {
      metaMessages: [
        `Params: (${yv(r, { includeName: !0 })})`,
        `Data:   ${e} (${n} bytes)`
      ],
      name: "AbiDecodingDataSizeTooSmallError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "params", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "size", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = e, this.params = r, this.size = n;
  }
}
class wv extends yt {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.', {
      name: "AbiDecodingZeroDataError"
    });
  }
}
class VR extends yt {
  constructor({ expectedLength: e, givenLength: r, type: n }) {
    super([
      `ABI encoding array length mismatch for type ${n}.`,
      `Expected length: ${e}`,
      `Given length: ${r}`
    ].join(`
`), { name: "AbiEncodingArrayLengthMismatchError" });
  }
}
class GR extends yt {
  constructor({ expectedSize: e, value: r }) {
    super(`Size of bytes "${r}" (bytes${An(r)}) does not match expected size (bytes${e}).`, { name: "AbiEncodingBytesSizeMismatchError" });
  }
}
class YR extends yt {
  constructor({ expectedLength: e, givenLength: r }) {
    super([
      "ABI encoding params/values length mismatch.",
      `Expected length (params): ${e}`,
      `Given length (values): ${r}`
    ].join(`
`), { name: "AbiEncodingLengthMismatchError" });
  }
}
class S5 extends yt {
  constructor(e, { docsPath: r }) {
    super([
      `Encoded error signature "${e}" not found on ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${e}.`
    ].join(`
`), {
      docsPath: r,
      name: "AbiErrorSignatureNotFoundError"
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.signature = e;
  }
}
class y2 extends yt {
  constructor(e, { docsPath: r } = {}) {
    super([
      `Function ${e ? `"${e}" ` : ""}not found on ABI.`,
      "Make sure you are using the correct ABI and that the function exists on it."
    ].join(`
`), {
      docsPath: r,
      name: "AbiFunctionNotFoundError"
    });
  }
}
class JR extends yt {
  constructor(e, r) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${e.type}\` in \`${vu(e.abiItem)}\`, and`,
        `\`${r.type}\` in \`${vu(r.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI."
      ],
      name: "AbiItemAmbiguityError"
    });
  }
}
class XR extends yt {
  constructor({ expectedSize: e, givenSize: r }) {
    super(`Expected bytes${e}, got bytes${r}.`, {
      name: "BytesSizeMismatchError"
    });
  }
}
class ZR extends yt {
  constructor(e, { docsPath: r }) {
    super([
      `Type "${e}" is not a valid encoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: r, name: "InvalidAbiEncodingType" });
  }
}
class QR extends yt {
  constructor(e, { docsPath: r }) {
    super([
      `Type "${e}" is not a valid decoding type.`,
      "Please provide a valid ABI type."
    ].join(`
`), { docsPath: r, name: "InvalidAbiDecodingType" });
  }
}
class eD extends yt {
  constructor(e) {
    super([`Value "${e}" is not a valid array.`].join(`
`), {
      name: "InvalidArrayError"
    });
  }
}
class tD extends yt {
  constructor(e) {
    super([
      `"${e}" is not a valid definition type.`,
      'Valid types: "function", "event", "error"'
    ].join(`
`), { name: "InvalidDefinitionTypeError" });
  }
}
class A5 extends yt {
  constructor({ offset: e, position: r, size: n }) {
    super(`Slice ${r === "start" ? "starting" : "ending"} at offset "${e}" is out-of-bounds (size: ${n}).`, { name: "SliceOffsetOutOfBoundsError" });
  }
}
class P5 extends yt {
  constructor({ size: e, targetSize: r, type: n }) {
    super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${e}) exceeds padding size (${r}).`, { name: "SizeExceedsPaddingSizeError" });
  }
}
class w2 extends yt {
  constructor({ size: e, targetSize: r, type: n }) {
    super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} is expected to be ${r} ${n} long, but is ${e} ${n} long.`, { name: "InvalidBytesLengthError" });
  }
}
function Tu(t, { dir: e, size: r = 32 } = {}) {
  return typeof t == "string" ? ba(t, { dir: e, size: r }) : rD(t, { dir: e, size: r });
}
function ba(t, { dir: e, size: r = 32 } = {}) {
  if (r === null)
    return t;
  const n = t.replace("0x", "");
  if (n.length > r * 2)
    throw new P5({
      size: Math.ceil(n.length / 2),
      targetSize: r,
      type: "hex"
    });
  return `0x${n[e === "right" ? "padEnd" : "padStart"](r * 2, "0")}`;
}
function rD(t, { dir: e, size: r = 32 } = {}) {
  if (r === null)
    return t;
  if (t.length > r)
    throw new P5({
      size: t.length,
      targetSize: r,
      type: "bytes"
    });
  const n = new Uint8Array(r);
  for (let i = 0; i < r; i++) {
    const s = e === "right";
    n[s ? i : r - i - 1] = t[s ? i : t.length - i - 1];
  }
  return n;
}
class nD extends yt {
  constructor({ max: e, min: r, signed: n, size: i, value: s }) {
    super(`Number "${s}" is not in safe ${i ? `${i * 8}-bit ${n ? "signed" : "unsigned"} ` : ""}integer range ${e ? `(${r} to ${e})` : `(above ${r})`}`, { name: "IntegerOutOfRangeError" });
  }
}
class iD extends yt {
  constructor(e) {
    super(`Bytes value "${e}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
      name: "InvalidBytesBooleanError"
    });
  }
}
class sD extends yt {
  constructor({ givenSize: e, maxSize: r }) {
    super(`Size cannot exceed ${r} bytes. Given size: ${e} bytes.`, { name: "SizeOverflowError" });
  }
}
function xv(t, { dir: e = "left" } = {}) {
  let r = typeof t == "string" ? t.replace("0x", "") : t, n = 0;
  for (let i = 0; i < r.length - 1 && r[e === "left" ? i : r.length - i - 1].toString() === "0"; i++)
    n++;
  return r = e === "left" ? r.slice(n) : r.slice(0, r.length - n), typeof t == "string" ? (r.length === 1 && e === "right" && (r = `${r}0`), `0x${r.length % 2 === 1 ? `0${r}` : r}`) : r;
}
function ro(t, { size: e }) {
  if (An(t) > e)
    throw new sD({
      givenSize: An(t),
      maxSize: e
    });
}
function el(t, e = {}) {
  const { signed: r } = e;
  e.size && ro(t, { size: e.size });
  const n = BigInt(t);
  if (!r)
    return n;
  const i = (t.length - 2) / 2, s = (1n << BigInt(i) * 8n - 1n) - 1n;
  return n <= s ? n : n - BigInt(`0x${"f".padStart(i * 2, "f")}`) - 1n;
}
function bu(t, e = {}) {
  return Number(el(t, e));
}
const oD = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function zd(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint" ? Mr(t, e) : typeof t == "string" ? I0(t, e) : typeof t == "boolean" ? M5(t, e) : wi(t, e);
}
function M5(t, e = {}) {
  const r = `0x${Number(t)}`;
  return typeof e.size == "number" ? (ro(r, { size: e.size }), Tu(r, { size: e.size })) : r;
}
function wi(t, e = {}) {
  let r = "";
  for (let i = 0; i < t.length; i++)
    r += oD[t[i]];
  const n = `0x${r}`;
  return typeof e.size == "number" ? (ro(n, { size: e.size }), Tu(n, { dir: "right", size: e.size })) : n;
}
function Mr(t, e = {}) {
  const { signed: r, size: n } = e, i = BigInt(t);
  let s;
  n ? r ? s = (1n << BigInt(n) * 8n - 1n) - 1n : s = 2n ** (BigInt(n) * 8n) - 1n : typeof t == "number" && (s = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof s == "bigint" && r ? -s - 1n : 0;
  if (s && i > s || i < o) {
    const u = typeof t == "bigint" ? "n" : "";
    throw new nD({
      max: s ? `${s}${u}` : void 0,
      min: `${o}${u}`,
      signed: r,
      size: n,
      value: `${t}${u}`
    });
  }
  const a = `0x${(r && i < 0 ? (1n << BigInt(n * 8)) + BigInt(i) : i).toString(16)}`;
  return n ? Tu(a, { size: n }) : a;
}
const aD = /* @__PURE__ */ new TextEncoder();
function I0(t, e = {}) {
  const r = aD.encode(t);
  return wi(r, e);
}
const cD = /* @__PURE__ */ new TextEncoder();
function _v(t, e = {}) {
  return typeof t == "number" || typeof t == "bigint" ? fD(t, e) : typeof t == "boolean" ? uD(t, e) : ya(t) ? ko(t, e) : I5(t, e);
}
function uD(t, e = {}) {
  const r = new Uint8Array(1);
  return r[0] = Number(t), typeof e.size == "number" ? (ro(r, { size: e.size }), Tu(r, { size: e.size })) : r;
}
const vo = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function x2(t) {
  if (t >= vo.zero && t <= vo.nine)
    return t - vo.zero;
  if (t >= vo.A && t <= vo.F)
    return t - (vo.A - 10);
  if (t >= vo.a && t <= vo.f)
    return t - (vo.a - 10);
}
function ko(t, e = {}) {
  let r = t;
  e.size && (ro(r, { size: e.size }), r = Tu(r, { dir: "right", size: e.size }));
  let n = r.slice(2);
  n.length % 2 && (n = `0${n}`);
  const i = n.length / 2, s = new Uint8Array(i);
  for (let o = 0, a = 0; o < i; o++) {
    const u = x2(n.charCodeAt(a++)), l = x2(n.charCodeAt(a++));
    if (u === void 0 || l === void 0)
      throw new yt(`Invalid byte sequence ("${n[a - 2]}${n[a - 1]}" in "${n}").`);
    s[o] = u * 16 + l;
  }
  return s;
}
function fD(t, e) {
  const r = Mr(t, e);
  return ko(r);
}
function I5(t, e = {}) {
  const r = cD.encode(t);
  return typeof e.size == "number" ? (ro(r, { size: e.size }), Tu(r, { dir: "right", size: e.size })) : r;
}
function Wd(t) {
  if (!Number.isSafeInteger(t) || t < 0)
    throw new Error(`positive integer expected, not ${t}`);
}
function lD(t) {
  return t instanceof Uint8Array || t != null && typeof t == "object" && t.constructor.name === "Uint8Array";
}
function Ll(t, ...e) {
  if (!lD(t))
    throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length))
    throw new Error(`Uint8Array expected of length ${e}, not of length=${t.length}`);
}
function hse(t) {
  if (typeof t != "function" || typeof t.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Wd(t.outputLen), Wd(t.blockLen);
}
function Hd(t, e = !0) {
  if (t.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (e && t.finished)
    throw new Error("Hash#digest() has already been called");
}
function C5(t, e) {
  Ll(t);
  const r = e.outputLen;
  if (t.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
const rd = /* @__PURE__ */ BigInt(2 ** 32 - 1), _2 = /* @__PURE__ */ BigInt(32);
function hD(t, e = !1) {
  return e ? { h: Number(t & rd), l: Number(t >> _2 & rd) } : { h: Number(t >> _2 & rd) | 0, l: Number(t & rd) | 0 };
}
function dD(t, e = !1) {
  let r = new Uint32Array(t.length), n = new Uint32Array(t.length);
  for (let i = 0; i < t.length; i++) {
    const { h: s, l: o } = hD(t[i], e);
    [r[i], n[i]] = [s, o];
  }
  return [r, n];
}
const pD = (t, e, r) => t << r | e >>> 32 - r, gD = (t, e, r) => e << r | t >>> 32 - r, mD = (t, e, r) => e << r - 32 | t >>> 64 - r, vD = (t, e, r) => t << r - 32 | e >>> 64 - r, qc = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const bD = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)), Bg = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), Ns = (t, e) => t << 32 - e | t >>> e, E2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, yD = (t) => t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
function S2(t) {
  for (let e = 0; e < t.length; e++)
    t[e] = yD(t[e]);
}
const wD = /* @__PURE__ */ Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function xD(t) {
  Ll(t);
  let e = "";
  for (let r = 0; r < t.length; r++)
    e += wD[t[r]];
  return e;
}
function _D(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new Uint8Array(new TextEncoder().encode(t));
}
function C0(t) {
  return typeof t == "string" && (t = _D(t)), Ll(t), t;
}
function dse(...t) {
  let e = 0;
  for (let n = 0; n < t.length; n++) {
    const i = t[n];
    Ll(i), e += i.length;
  }
  const r = new Uint8Array(e);
  for (let n = 0, i = 0; n < t.length; n++) {
    const s = t[n];
    r.set(s, i), i += s.length;
  }
  return r;
}
class T5 {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function R5(t) {
  const e = (n) => t().update(C0(n)).digest(), r = t();
  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e;
}
function ED(t) {
  const e = (n, i) => t(i).update(C0(n)).digest(), r = t({});
  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = (n) => t(n), e;
}
function pse(t = 32) {
  if (qc && typeof qc.getRandomValues == "function")
    return qc.getRandomValues(new Uint8Array(t));
  if (qc && typeof qc.randomBytes == "function")
    return qc.randomBytes(t);
  throw new Error("crypto.getRandomValues must be defined");
}
const D5 = [], O5 = [], N5 = [], SD = /* @__PURE__ */ BigInt(0), yf = /* @__PURE__ */ BigInt(1), AD = /* @__PURE__ */ BigInt(2), PD = /* @__PURE__ */ BigInt(7), MD = /* @__PURE__ */ BigInt(256), ID = /* @__PURE__ */ BigInt(113);
for (let t = 0, e = yf, r = 1, n = 0; t < 24; t++) {
  [r, n] = [n, (2 * r + 3 * n) % 5], D5.push(2 * (5 * n + r)), O5.push((t + 1) * (t + 2) / 2 % 64);
  let i = SD;
  for (let s = 0; s < 7; s++)
    e = (e << yf ^ (e >> PD) * ID) % MD, e & AD && (i ^= yf << (yf << /* @__PURE__ */ BigInt(s)) - yf);
  N5.push(i);
}
const [CD, TD] = /* @__PURE__ */ dD(N5, !0), A2 = (t, e, r) => r > 32 ? mD(t, e, r) : pD(t, e, r), P2 = (t, e, r) => r > 32 ? vD(t, e, r) : gD(t, e, r);
function L5(t, e = 24) {
  const r = new Uint32Array(10);
  for (let n = 24 - e; n < 24; n++) {
    for (let o = 0; o < 10; o++)
      r[o] = t[o] ^ t[o + 10] ^ t[o + 20] ^ t[o + 30] ^ t[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10, u = (o + 2) % 10, l = r[u], d = r[u + 1], p = A2(l, d, 1) ^ r[a], w = P2(l, d, 1) ^ r[a + 1];
      for (let A = 0; A < 50; A += 10)
        t[o + A] ^= p, t[o + A + 1] ^= w;
    }
    let i = t[2], s = t[3];
    for (let o = 0; o < 24; o++) {
      const a = O5[o], u = A2(i, s, a), l = P2(i, s, a), d = D5[o];
      i = t[d], s = t[d + 1], t[d] = u, t[d + 1] = l;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++)
        r[a] = t[o + a];
      for (let a = 0; a < 10; a++)
        t[o + a] ^= ~r[(a + 2) % 10] & r[(a + 4) % 10];
    }
    t[0] ^= CD[n], t[1] ^= TD[n];
  }
  r.fill(0);
}
class kl extends T5 {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(e, r, n, i = !1, s = 24) {
    if (super(), this.blockLen = e, this.suffix = r, this.outputLen = n, this.enableXOF = i, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, Wd(n), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = bD(this.state);
  }
  keccak() {
    E2 || S2(this.state32), L5(this.state32, this.rounds), E2 || S2(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Hd(this);
    const { blockLen: r, state: n } = this;
    e = C0(e);
    const i = e.length;
    for (let s = 0; s < i; ) {
      const o = Math.min(r - this.pos, i - s);
      for (let a = 0; a < o; a++)
        n[this.pos++] ^= e[s++];
      this.pos === r && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: e, suffix: r, pos: n, blockLen: i } = this;
    e[n] ^= r, r & 128 && n === i - 1 && this.keccak(), e[i - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Hd(this, !1), Ll(e), this.finish();
    const r = this.state, { blockLen: n } = this;
    for (let i = 0, s = e.length; i < s; ) {
      this.posOut >= n && this.keccak();
      const o = Math.min(n - this.posOut, s - i);
      e.set(r.subarray(this.posOut, this.posOut + o), i), this.posOut += o, i += o;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Wd(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (C5(e, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: r, suffix: n, outputLen: i, rounds: s, enableXOF: o } = this;
    return e || (e = new kl(r, n, i, o, s)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = s, e.suffix = n, e.outputLen = i, e.enableXOF = o, e.destroyed = this.destroyed, e;
  }
}
const Ia = (t, e, r) => R5(() => new kl(e, t, r)), RD = /* @__PURE__ */ Ia(6, 144, 224 / 8), DD = /* @__PURE__ */ Ia(6, 136, 256 / 8), OD = /* @__PURE__ */ Ia(6, 104, 384 / 8), ND = /* @__PURE__ */ Ia(6, 72, 512 / 8), LD = /* @__PURE__ */ Ia(1, 144, 224 / 8), k5 = /* @__PURE__ */ Ia(1, 136, 256 / 8), kD = /* @__PURE__ */ Ia(1, 104, 384 / 8), $D = /* @__PURE__ */ Ia(1, 72, 512 / 8), $5 = (t, e, r) => ED((n = {}) => new kl(e, t, n.dkLen === void 0 ? r : n.dkLen, !0)), BD = /* @__PURE__ */ $5(31, 168, 128 / 8), FD = /* @__PURE__ */ $5(31, 136, 256 / 8), jD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Keccak: kl,
  keccakP: L5,
  keccak_224: LD,
  keccak_256: k5,
  keccak_384: kD,
  keccak_512: $D,
  sha3_224: RD,
  sha3_256: DD,
  sha3_384: OD,
  sha3_512: ND,
  shake128: BD,
  shake256: FD
}, Symbol.toStringTag, { value: "Module" }));
function $l(t, e) {
  const r = e || "hex", n = k5(ya(t, { strict: !1 }) ? _v(t) : t);
  return r === "bytes" ? n : zd(n);
}
const UD = (t) => $l(_v(t));
function qD(t) {
  return UD(t);
}
function zD(t) {
  let e = !0, r = "", n = 0, i = "", s = !1;
  for (let o = 0; o < t.length; o++) {
    const a = t[o];
    if (["(", ")", ","].includes(a) && (e = !0), a === "(" && n++, a === ")" && n--, !!e) {
      if (n === 0) {
        if (a === " " && ["event", "function", ""].includes(i))
          i = "";
        else if (i += a, a === ")") {
          s = !0;
          break;
        }
        continue;
      }
      if (a === " ") {
        t[o - 1] !== "," && r !== "," && r !== ",(" && (r = "", e = !1);
        continue;
      }
      i += a, r += a;
    }
  }
  if (!s)
    throw new yt("Unable to normalize signature.");
  return i;
}
const WD = (t) => {
  const e = typeof t == "string" ? t : zR(t);
  return zD(e);
};
function B5(t) {
  return qD(WD(t));
}
const HD = B5;
class yu extends yt {
  constructor({ address: e }) {
    super(`Address "${e}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
}
class T0 extends Map {
  constructor(e) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = e;
  }
  get(e) {
    const r = super.get(e);
    return super.has(e) && r !== void 0 && (this.delete(e), super.set(e, r)), r;
  }
  set(e, r) {
    if (super.set(e, r), this.maxSize && this.size > this.maxSize) {
      const n = this.keys().next().value;
      n && this.delete(n);
    }
    return this;
  }
}
const Fg = /* @__PURE__ */ new T0(8192);
function Bl(t, e) {
  if (Fg.has(`${t}.${e}`))
    return Fg.get(`${t}.${e}`);
  const r = t.substring(2).toLowerCase(), n = $l(I5(r), "bytes"), i = r.split("");
  for (let o = 0; o < 40; o += 2)
    n[o >> 1] >> 4 >= 8 && i[o] && (i[o] = i[o].toUpperCase()), (n[o >> 1] & 15) >= 8 && i[o + 1] && (i[o + 1] = i[o + 1].toUpperCase());
  const s = `0x${i.join("")}`;
  return Fg.set(`${t}.${e}`, s), s;
}
function Ev(t, e) {
  if (!$o(t, { strict: !1 }))
    throw new yu({ address: t });
  return Bl(t, e);
}
const KD = /^0x[a-fA-F0-9]{40}$/, jg = /* @__PURE__ */ new T0(8192);
function $o(t, e) {
  const { strict: r = !0 } = e ?? {}, n = `${t}.${r}`;
  if (jg.has(n))
    return jg.get(n);
  const i = KD.test(t) ? t.toLowerCase() === t ? !0 : r ? Bl(t) === t : !0 : !1;
  return jg.set(n, i), i;
}
function wu(t) {
  return typeof t[0] == "string" ? R0(t) : VD(t);
}
function VD(t) {
  let e = 0;
  for (const i of t)
    e += i.length;
  const r = new Uint8Array(e);
  let n = 0;
  for (const i of t)
    r.set(i, n), n += i.length;
  return r;
}
function R0(t) {
  return `0x${t.reduce((e, r) => e + r.replace("0x", ""), "")}`;
}
function Kd(t, e, r, { strict: n } = {}) {
  return ya(t, { strict: !1 }) ? GD(t, e, r, {
    strict: n
  }) : U5(t, e, r, {
    strict: n
  });
}
function F5(t, e) {
  if (typeof e == "number" && e > 0 && e > An(t) - 1)
    throw new A5({
      offset: e,
      position: "start",
      size: An(t)
    });
}
function j5(t, e, r) {
  if (typeof e == "number" && typeof r == "number" && An(t) !== r - e)
    throw new A5({
      offset: r,
      position: "end",
      size: An(t)
    });
}
function U5(t, e, r, { strict: n } = {}) {
  F5(t, e);
  const i = t.slice(e, r);
  return n && j5(i, e, r), i;
}
function GD(t, e, r, { strict: n } = {}) {
  F5(t, e);
  const i = `0x${t.replace("0x", "").slice((e ?? 0) * 2, (r ?? t.length) * 2)}`;
  return n && j5(i, e, r), i;
}
function q5(t, e) {
  if (t.length !== e.length)
    throw new YR({
      expectedLength: t.length,
      givenLength: e.length
    });
  const r = YD({
    params: t,
    values: e
  }), n = Av(r);
  return n.length === 0 ? "0x" : n;
}
function YD({ params: t, values: e }) {
  const r = [];
  for (let n = 0; n < t.length; n++)
    r.push(Sv({ param: t[n], value: e[n] }));
  return r;
}
function Sv({ param: t, value: e }) {
  const r = Pv(t.type);
  if (r) {
    const [n, i] = r;
    return XD(e, { length: n, param: { ...t, type: i } });
  }
  if (t.type === "tuple")
    return rO(e, {
      param: t
    });
  if (t.type === "address")
    return JD(e);
  if (t.type === "bool")
    return QD(e);
  if (t.type.startsWith("uint") || t.type.startsWith("int")) {
    const n = t.type.startsWith("int");
    return eO(e, { signed: n });
  }
  if (t.type.startsWith("bytes"))
    return ZD(e, { param: t });
  if (t.type === "string")
    return tO(e);
  throw new ZR(t.type, {
    docsPath: "/docs/contract/encodeAbiParameters"
  });
}
function Av(t) {
  let e = 0;
  for (let s = 0; s < t.length; s++) {
    const { dynamic: o, encoded: a } = t[s];
    o ? e += 32 : e += An(a);
  }
  const r = [], n = [];
  let i = 0;
  for (let s = 0; s < t.length; s++) {
    const { dynamic: o, encoded: a } = t[s];
    o ? (r.push(Mr(e + i, { size: 32 })), n.push(a), i += An(a)) : r.push(a);
  }
  return wu([...r, ...n]);
}
function JD(t) {
  if (!$o(t))
    throw new yu({ address: t });
  return { dynamic: !1, encoded: ba(t.toLowerCase()) };
}
function XD(t, { length: e, param: r }) {
  const n = e === null;
  if (!Array.isArray(t))
    throw new eD(t);
  if (!n && t.length !== e)
    throw new VR({
      expectedLength: e,
      givenLength: t.length,
      type: `${r.type}[${e}]`
    });
  let i = !1;
  const s = [];
  for (let o = 0; o < t.length; o++) {
    const a = Sv({ param: r, value: t[o] });
    a.dynamic && (i = !0), s.push(a);
  }
  if (n || i) {
    const o = Av(s);
    if (n) {
      const a = Mr(s.length, { size: 32 });
      return {
        dynamic: !0,
        encoded: s.length > 0 ? wu([a, o]) : a
      };
    }
    if (i)
      return { dynamic: !0, encoded: o };
  }
  return {
    dynamic: !1,
    encoded: wu(s.map(({ encoded: o }) => o))
  };
}
function ZD(t, { param: e }) {
  const [, r] = e.type.split("bytes"), n = An(t);
  if (!r) {
    let i = t;
    return n % 32 !== 0 && (i = ba(i, {
      dir: "right",
      size: Math.ceil((t.length - 2) / 2 / 32) * 32
    })), {
      dynamic: !0,
      encoded: wu([ba(Mr(n, { size: 32 })), i])
    };
  }
  if (n !== Number.parseInt(r))
    throw new GR({
      expectedSize: Number.parseInt(r),
      value: t
    });
  return { dynamic: !1, encoded: ba(t, { dir: "right" }) };
}
function QD(t) {
  if (typeof t != "boolean")
    throw new yt(`Invalid boolean value: "${t}" (type: ${typeof t}). Expected: \`true\` or \`false\`.`);
  return { dynamic: !1, encoded: ba(M5(t)) };
}
function eO(t, { signed: e }) {
  return {
    dynamic: !1,
    encoded: Mr(t, {
      size: 32,
      signed: e
    })
  };
}
function tO(t) {
  const e = I0(t), r = Math.ceil(An(e) / 32), n = [];
  for (let i = 0; i < r; i++)
    n.push(ba(Kd(e, i * 32, (i + 1) * 32), {
      dir: "right"
    }));
  return {
    dynamic: !0,
    encoded: wu([
      ba(Mr(An(e), { size: 32 })),
      ...n
    ])
  };
}
function rO(t, { param: e }) {
  let r = !1;
  const n = [];
  for (let i = 0; i < e.components.length; i++) {
    const s = e.components[i], o = Array.isArray(t) ? i : s.name, a = Sv({
      param: s,
      value: t[o]
    });
    n.push(a), a.dynamic && (r = !0);
  }
  return {
    dynamic: r,
    encoded: r ? Av(n) : wu(n.map(({ encoded: i }) => i))
  };
}
function Pv(t) {
  const e = t.match(/^(.*)\[(\d+)?\]$/);
  return e ? (
    // Return `null` if the array is dynamic.
    [e[2] ? Number(e[2]) : null, e[1]]
  ) : void 0;
}
const Mv = (t) => Kd(B5(t), 0, 4);
function z5(t) {
  const { abi: e, args: r = [], name: n } = t, i = ya(n, { strict: !1 }), s = e.filter((a) => i ? a.type === "function" ? Mv(a) === n : a.type === "event" ? HD(a) === n : !1 : "name" in a && a.name === n);
  if (s.length === 0)
    return;
  if (s.length === 1)
    return s[0];
  let o;
  for (const a of s) {
    if (!("inputs" in a))
      continue;
    if (!r || r.length === 0) {
      if (!a.inputs || a.inputs.length === 0)
        return a;
      continue;
    }
    if (!a.inputs || a.inputs.length === 0 || a.inputs.length !== r.length)
      continue;
    if (r.every((l, d) => {
      const p = "inputs" in a && a.inputs[d];
      return p ? Xm(l, p) : !1;
    })) {
      if (o && "inputs" in o && o.inputs) {
        const l = W5(a.inputs, o.inputs, r);
        if (l)
          throw new JR({
            abiItem: a,
            type: l[0]
          }, {
            abiItem: o,
            type: l[1]
          });
      }
      o = a;
    }
  }
  return o || s[0];
}
function Xm(t, e) {
  const r = typeof t, n = e.type;
  switch (n) {
    case "address":
      return $o(t, { strict: !1 });
    case "bool":
      return r === "boolean";
    case "function":
      return r === "string";
    case "string":
      return r === "string";
    default:
      return n === "tuple" && "components" in e ? Object.values(e.components).every((i, s) => Xm(Object.values(t)[s], i)) : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(n) ? r === "number" || r === "bigint" : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(n) ? r === "string" || t instanceof Uint8Array : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(n) ? Array.isArray(t) && t.every((i) => Xm(i, {
        ...e,
        // Pop off `[]` or `[M]` from end of type
        type: n.replace(/(\[[0-9]{0,}\])$/, "")
      })) : !1;
  }
}
function W5(t, e, r) {
  for (const n in t) {
    const i = t[n], s = e[n];
    if (i.type === "tuple" && s.type === "tuple" && "components" in i && "components" in s)
      return W5(i.components, s.components, r[n]);
    const o = [i.type, s.type];
    if (o.includes("address") && o.includes("bytes20") ? !0 : o.includes("address") && o.includes("string") ? $o(r[n], { strict: !1 }) : o.includes("address") && o.includes("bytes") ? $o(r[n], { strict: !1 }) : !1)
      return o;
  }
}
function Wo(t) {
  return typeof t == "string" ? { address: t, type: "json-rpc" } : t;
}
const M2 = "/docs/contract/encodeFunctionData";
function nO(t) {
  const { abi: e, args: r, functionName: n } = t;
  let i = e[0];
  if (n) {
    const s = z5({
      abi: e,
      args: r,
      name: n
    });
    if (!s)
      throw new y2(n, { docsPath: M2 });
    i = s;
  }
  if (i.type !== "function")
    throw new y2(void 0, { docsPath: M2 });
  return {
    abi: [i],
    functionName: Mv(vu(i))
  };
}
function iO(t) {
  const { args: e } = t, { abi: r, functionName: n } = (() => {
    var a;
    return t.abi.length === 1 && ((a = t.functionName) != null && a.startsWith("0x")) ? t : nO(t);
  })(), i = r[0], s = n, o = "inputs" in i && i.inputs ? q5(i.inputs, e ?? []) : void 0;
  return R0([s, o ?? "0x"]);
}
const sO = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
}, oO = {
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
}, aO = {
  inputs: [
    {
      name: "reason",
      type: "uint256"
    }
  ],
  name: "Panic",
  type: "error"
};
class I2 extends yt {
  constructor({ offset: e }) {
    super(`Offset \`${e}\` cannot be negative.`, {
      name: "NegativeOffsetError"
    });
  }
}
class cO extends yt {
  constructor({ length: e, position: r }) {
    super(`Position \`${r}\` is out of bounds (\`0 < position < ${e}\`).`, { name: "PositionOutOfBoundsError" });
  }
}
class uO extends yt {
  constructor({ count: e, limit: r }) {
    super(`Recursive read limit of \`${r}\` exceeded (recursive read count: \`${e}\`).`, { name: "RecursiveReadLimitExceededError" });
  }
}
const fO = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new uO({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(t) {
    if (t < 0 || t > this.bytes.length - 1)
      throw new cO({
        length: this.bytes.length,
        position: t
      });
  },
  decrementPosition(t) {
    if (t < 0)
      throw new I2({ offset: t });
    const e = this.position - t;
    this.assertPosition(e), this.position = e;
  },
  getReadCount(t) {
    return this.positionReadCount.get(t || this.position) || 0;
  },
  incrementPosition(t) {
    if (t < 0)
      throw new I2({ offset: t });
    const e = this.position + t;
    this.assertPosition(e), this.position = e;
  },
  inspectByte(t) {
    const e = t ?? this.position;
    return this.assertPosition(e), this.bytes[e];
  },
  inspectBytes(t, e) {
    const r = e ?? this.position;
    return this.assertPosition(r + t - 1), this.bytes.subarray(r, r + t);
  },
  inspectUint8(t) {
    const e = t ?? this.position;
    return this.assertPosition(e), this.bytes[e];
  },
  inspectUint16(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 1), this.dataView.getUint16(e);
  },
  inspectUint24(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 2), (this.dataView.getUint16(e) << 8) + this.dataView.getUint8(e + 2);
  },
  inspectUint32(t) {
    const e = t ?? this.position;
    return this.assertPosition(e + 3), this.dataView.getUint32(e);
  },
  pushByte(t) {
    this.assertPosition(this.position), this.bytes[this.position] = t, this.position++;
  },
  pushBytes(t) {
    this.assertPosition(this.position + t.length - 1), this.bytes.set(t, this.position), this.position += t.length;
  },
  pushUint8(t) {
    this.assertPosition(this.position), this.bytes[this.position] = t, this.position++;
  },
  pushUint16(t) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, t), this.position += 2;
  },
  pushUint24(t) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, t >> 8), this.dataView.setUint8(this.position + 2, t & 255), this.position += 3;
  },
  pushUint32(t) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, t), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectByte();
    return this.position++, t;
  },
  readBytes(t, e) {
    this.assertReadLimit(), this._touch();
    const r = this.inspectBytes(t);
    return this.position += e ?? t, r;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint8();
    return this.position += 1, t;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint16();
    return this.position += 2, t;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint24();
    return this.position += 3, t;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const t = this.inspectUint32();
    return this.position += 4, t;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(t) {
    const e = this.position;
    return this.assertPosition(t), this.position = t, () => this.position = e;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const t = this.getReadCount();
    this.positionReadCount.set(this.position, t + 1), t > 0 && this.recursiveReadCount++;
  }
};
function Iv(t, { recursiveReadLimit: e = 8192 } = {}) {
  const r = Object.create(fO);
  return r.bytes = t, r.dataView = new DataView(t.buffer, t.byteOffset, t.byteLength), r.positionReadCount = /* @__PURE__ */ new Map(), r.recursiveReadLimit = e, r;
}
function lO(t, e = {}) {
  typeof e.size < "u" && ro(t, { size: e.size });
  const r = wi(t, e);
  return el(r, e);
}
function hO(t, e = {}) {
  let r = t;
  if (typeof e.size < "u" && (ro(r, { size: e.size }), r = xv(r)), r.length > 1 || r[0] > 1)
    throw new iD(r);
  return !!r[0];
}
function To(t, e = {}) {
  typeof e.size < "u" && ro(t, { size: e.size });
  const r = wi(t, e);
  return bu(r, e);
}
function dO(t, e = {}) {
  let r = t;
  return typeof e.size < "u" && (ro(r, { size: e.size }), r = xv(r, { dir: "right" })), new TextDecoder().decode(r);
}
function pO(t, e) {
  const r = typeof e == "string" ? ko(e) : e, n = Iv(r);
  if (An(r) === 0 && t.length > 0)
    throw new wv();
  if (An(e) && An(e) < 32)
    throw new KR({
      data: typeof e == "string" ? e : wi(e),
      params: t,
      size: An(e)
    });
  let i = 0;
  const s = [];
  for (let o = 0; o < t.length; ++o) {
    const a = t[o];
    n.setPosition(i);
    const [u, l] = au(n, a, {
      staticPosition: 0
    });
    i += l, s.push(u);
  }
  return s;
}
function au(t, e, { staticPosition: r }) {
  const n = Pv(e.type);
  if (n) {
    const [i, s] = n;
    return mO(t, { ...e, type: s }, { length: i, staticPosition: r });
  }
  if (e.type === "tuple")
    return wO(t, e, { staticPosition: r });
  if (e.type === "address")
    return gO(t);
  if (e.type === "bool")
    return vO(t);
  if (e.type.startsWith("bytes"))
    return bO(t, e, { staticPosition: r });
  if (e.type.startsWith("uint") || e.type.startsWith("int"))
    return yO(t, e);
  if (e.type === "string")
    return xO(t, { staticPosition: r });
  throw new QR(e.type, {
    docsPath: "/docs/contract/decodeAbiParameters"
  });
}
const C2 = 32, Zm = 32;
function gO(t) {
  const e = t.readBytes(32);
  return [Bl(wi(U5(e, -20))), 32];
}
function mO(t, e, { length: r, staticPosition: n }) {
  if (!r) {
    const o = To(t.readBytes(Zm)), a = n + o, u = a + C2;
    t.setPosition(a);
    const l = To(t.readBytes(C2)), d = tl(e);
    let p = 0;
    const w = [];
    for (let A = 0; A < l; ++A) {
      t.setPosition(u + (d ? A * 32 : p));
      const [P, N] = au(t, e, {
        staticPosition: u
      });
      p += N, w.push(P);
    }
    return t.setPosition(n + 32), [w, 32];
  }
  if (tl(e)) {
    const o = To(t.readBytes(Zm)), a = n + o, u = [];
    for (let l = 0; l < r; ++l) {
      t.setPosition(a + l * 32);
      const [d] = au(t, e, {
        staticPosition: a
      });
      u.push(d);
    }
    return t.setPosition(n + 32), [u, 32];
  }
  let i = 0;
  const s = [];
  for (let o = 0; o < r; ++o) {
    const [a, u] = au(t, e, {
      staticPosition: n + i
    });
    i += u, s.push(a);
  }
  return [s, i];
}
function vO(t) {
  return [hO(t.readBytes(32), { size: 32 }), 32];
}
function bO(t, e, { staticPosition: r }) {
  const [n, i] = e.type.split("bytes");
  if (!i) {
    const o = To(t.readBytes(32));
    t.setPosition(r + o);
    const a = To(t.readBytes(32));
    if (a === 0)
      return t.setPosition(r + 32), ["0x", 32];
    const u = t.readBytes(a);
    return t.setPosition(r + 32), [wi(u), 32];
  }
  return [wi(t.readBytes(Number.parseInt(i), 32)), 32];
}
function yO(t, e) {
  const r = e.type.startsWith("int"), n = Number.parseInt(e.type.split("int")[1] || "256"), i = t.readBytes(32);
  return [
    n > 48 ? lO(i, { signed: r }) : To(i, { signed: r }),
    32
  ];
}
function wO(t, e, { staticPosition: r }) {
  const n = e.components.length === 0 || e.components.some(({ name: o }) => !o), i = n ? [] : {};
  let s = 0;
  if (tl(e)) {
    const o = To(t.readBytes(Zm)), a = r + o;
    for (let u = 0; u < e.components.length; ++u) {
      const l = e.components[u];
      t.setPosition(a + s);
      const [d, p] = au(t, l, {
        staticPosition: a
      });
      s += p, i[n ? u : l == null ? void 0 : l.name] = d;
    }
    return t.setPosition(r + 32), [i, 32];
  }
  for (let o = 0; o < e.components.length; ++o) {
    const a = e.components[o], [u, l] = au(t, a, {
      staticPosition: r
    });
    i[n ? o : a == null ? void 0 : a.name] = u, s += l;
  }
  return [i, s];
}
function xO(t, { staticPosition: e }) {
  const r = To(t.readBytes(32)), n = e + r;
  t.setPosition(n);
  const i = To(t.readBytes(32));
  if (i === 0)
    return t.setPosition(e + 32), ["", 32];
  const s = t.readBytes(i, 32), o = dO(xv(s));
  return t.setPosition(e + 32), [o, 32];
}
function tl(t) {
  var n;
  const { type: e } = t;
  if (e === "string" || e === "bytes" || e.endsWith("[]"))
    return !0;
  if (e === "tuple")
    return (n = t.components) == null ? void 0 : n.some(tl);
  const r = Pv(t.type);
  return !!(r && tl({ ...t, type: r[1] }));
}
function _O(t) {
  const { abi: e, data: r } = t, n = Kd(r, 0, 4);
  if (n === "0x")
    throw new wv();
  const s = [...e || [], oO, aO].find((o) => o.type === "error" && n === Mv(vu(o)));
  if (!s)
    throw new S5(n, {
      docsPath: "/docs/contract/decodeErrorResult"
    });
  return {
    abiItem: s,
    args: "inputs" in s && s.inputs && s.inputs.length > 0 ? pO(s.inputs, Kd(r, 4)) : void 0,
    errorName: s.name
  };
}
const Ru = (t, e, r) => JSON.stringify(t, (n, i) => typeof i == "bigint" ? i.toString() : i, r);
function H5({ abiItem: t, args: e, includeFunctionName: r = !0, includeName: n = !1 }) {
  if ("name" in t && "inputs" in t && t.inputs)
    return `${r ? t.name : ""}(${t.inputs.map((i, s) => `${n && i.name ? `${i.name}: ` : ""}${typeof e[s] == "object" ? Ru(e[s]) : e[s]}`).join(", ")})`;
}
const EO = {
  gwei: 9,
  wei: 18
}, SO = {
  ether: -9,
  wei: 9
};
function K5(t, e) {
  let r = t.toString();
  const n = r.startsWith("-");
  n && (r = r.slice(1)), r = r.padStart(e, "0");
  let [i, s] = [
    r.slice(0, r.length - e),
    r.slice(r.length - e)
  ];
  return s = s.replace(/(0+)$/, ""), `${n ? "-" : ""}${i || "0"}${s ? `.${s}` : ""}`;
}
function V5(t, e = "wei") {
  return K5(t, EO[e]);
}
function Es(t, e = "wei") {
  return K5(t, SO[e]);
}
class AO extends yt {
  constructor({ address: e }) {
    super(`State for account "${e}" is set multiple times.`, {
      name: "AccountStateConflictError"
    });
  }
}
class PO extends yt {
  constructor() {
    super("state and stateDiff are set on the same account.", {
      name: "StateAssignmentConflictError"
    });
  }
}
function D0(t) {
  const e = Object.entries(t).map(([n, i]) => i === void 0 || i === !1 ? null : [n, i]).filter(Boolean), r = e.reduce((n, [i]) => Math.max(n, i.length), 0);
  return e.map(([n, i]) => `  ${`${n}:`.padEnd(r + 1)}  ${i}`).join(`
`);
}
class MO extends yt {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join(`
`), { name: "FeeConflictError" });
  }
}
class IO extends yt {
  constructor({ transaction: e }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        D0(e),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- an EIP-7702 Transaction with `authorizationList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ],
      name: "InvalidSerializableTransactionError"
    });
  }
}
class CO extends yt {
  constructor(e, { account: r, docsPath: n, chain: i, data: s, gas: o, gasPrice: a, maxFeePerGas: u, maxPriorityFeePerGas: l, nonce: d, to: p, value: w }) {
    var P;
    const A = D0({
      chain: i && `${i == null ? void 0 : i.name} (id: ${i == null ? void 0 : i.id})`,
      from: r == null ? void 0 : r.address,
      to: p,
      value: typeof w < "u" && `${V5(w)} ${((P = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : P.symbol) || "ETH"}`,
      data: s,
      gas: o,
      gasPrice: typeof a < "u" && `${Es(a)} gwei`,
      maxFeePerGas: typeof u < "u" && `${Es(u)} gwei`,
      maxPriorityFeePerGas: typeof l < "u" && `${Es(l)} gwei`,
      nonce: d
    });
    super(e.shortMessage, {
      cause: e,
      docsPath: n,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        "Request Arguments:",
        A
      ].filter(Boolean),
      name: "TransactionExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = e;
  }
}
const TO = (t) => t, G5 = (t) => t;
class RO extends yt {
  constructor(e, { abi: r, args: n, contractAddress: i, docsPath: s, functionName: o, sender: a }) {
    const u = z5({ abi: r, args: n, name: o }), l = u ? H5({
      abiItem: u,
      args: n,
      includeFunctionName: !1,
      includeName: !1
    }) : void 0, d = u ? vu(u, { includeName: !0 }) : void 0, p = D0({
      address: i && TO(i),
      function: d,
      args: l && l !== "()" && `${[...Array((o == null ? void 0 : o.length) ?? 0).keys()].map(() => " ").join("")}${l}`,
      sender: a
    });
    super(e.shortMessage || `An unknown error occurred while executing the contract function "${o}".`, {
      cause: e,
      docsPath: s,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        p && "Contract Call:",
        p
      ].filter(Boolean),
      name: "ContractFunctionExecutionError"
    }), Object.defineProperty(this, "abi", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "args", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "contractAddress", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "formattedArgs", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "functionName", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "sender", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.abi = r, this.args = n, this.cause = e, this.contractAddress = i, this.functionName = o, this.sender = a;
  }
}
class DO extends yt {
  constructor({ abi: e, data: r, functionName: n, message: i }) {
    let s, o, a, u;
    if (r && r !== "0x")
      try {
        o = _O({ abi: e, data: r });
        const { abiItem: d, errorName: p, args: w } = o;
        if (p === "Error")
          u = w[0];
        else if (p === "Panic") {
          const [A] = w;
          u = sO[A];
        } else {
          const A = d ? vu(d, { includeName: !0 }) : void 0, P = d && w ? H5({
            abiItem: d,
            args: w,
            includeFunctionName: !1,
            includeName: !1
          }) : void 0;
          a = [
            A ? `Error: ${A}` : "",
            P && P !== "()" ? `       ${[...Array((p == null ? void 0 : p.length) ?? 0).keys()].map(() => " ").join("")}${P}` : ""
          ];
        }
      } catch (d) {
        s = d;
      }
    else i && (u = i);
    let l;
    s instanceof S5 && (l = s.signature, a = [
      `Unable to decode signature "${l}" as it was not found on the provided ABI.`,
      "Make sure you are using the correct ABI and that the error exists on it.",
      `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${l}.`
    ]), super(u && u !== "execution reverted" || l ? [
      `The contract function "${n}" reverted with the following ${l ? "signature" : "reason"}:`,
      u || l
    ].join(`
`) : `The contract function "${n}" reverted.`, {
      cause: s,
      metaMessages: a,
      name: "ContractFunctionRevertedError"
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "reason", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "signature", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = o, this.reason = u, this.signature = l;
  }
}
class OO extends yt {
  constructor({ functionName: e }) {
    super(`The contract function "${e}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${e}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract."
      ],
      name: "ContractFunctionZeroDataError"
    });
  }
}
class NO extends yt {
  constructor({ data: e, message: r }) {
    super(r || "", { name: "RawContractError" }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: 3
    }), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = e;
  }
}
class Y5 extends yt {
  constructor({ body: e, cause: r, details: n, headers: i, status: s, url: o }) {
    super("HTTP request failed.", {
      cause: r,
      details: n,
      metaMessages: [
        s && `Status: ${s}`,
        `URL: ${G5(o)}`,
        e && `Request body: ${Ru(e)}`
      ].filter(Boolean),
      name: "HttpRequestError"
    }), Object.defineProperty(this, "body", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "headers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "status", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "url", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.body = e, this.headers = i, this.status = s, this.url = o;
  }
}
class LO extends yt {
  constructor({ body: e, error: r, url: n }) {
    super("RPC Request failed.", {
      cause: r,
      details: r.message,
      metaMessages: [`URL: ${G5(n)}`, `Request body: ${Ru(e)}`],
      name: "RpcRequestError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.code = r.code;
  }
}
const kO = -1;
class Ei extends yt {
  constructor(e, { code: r, docsPath: n, metaMessages: i, name: s, shortMessage: o }) {
    super(o, {
      cause: e,
      docsPath: n,
      metaMessages: i || (e == null ? void 0 : e.metaMessages),
      name: s || "RpcError"
    }), Object.defineProperty(this, "code", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.name = s || e.name, this.code = e instanceof LO ? e.code : r ?? kO;
  }
}
class Du extends Ei {
  constructor(e, r) {
    super(e, r), Object.defineProperty(this, "data", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.data = r.data;
  }
}
class rl extends Ei {
  constructor(e) {
    super(e, {
      code: rl.code,
      name: "ParseRpcError",
      shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    });
  }
}
Object.defineProperty(rl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32700
});
class nl extends Ei {
  constructor(e) {
    super(e, {
      code: nl.code,
      name: "InvalidRequestRpcError",
      shortMessage: "JSON is not a valid request object."
    });
  }
}
Object.defineProperty(nl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32600
});
class il extends Ei {
  constructor(e, { method: r } = {}) {
    super(e, {
      code: il.code,
      name: "MethodNotFoundRpcError",
      shortMessage: `The method${r ? ` "${r}"` : ""} does not exist / is not available.`
    });
  }
}
Object.defineProperty(il, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32601
});
class sl extends Ei {
  constructor(e) {
    super(e, {
      code: sl.code,
      name: "InvalidParamsRpcError",
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    });
  }
}
Object.defineProperty(sl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602
});
class fc extends Ei {
  constructor(e) {
    super(e, {
      code: fc.code,
      name: "InternalRpcError",
      shortMessage: "An internal error was received."
    });
  }
}
Object.defineProperty(fc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603
});
class ol extends Ei {
  constructor(e) {
    super(e, {
      code: ol.code,
      name: "InvalidInputRpcError",
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters."
      ].join(`
`)
    });
  }
}
Object.defineProperty(ol, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32e3
});
class al extends Ei {
  constructor(e) {
    super(e, {
      code: al.code,
      name: "ResourceNotFoundRpcError",
      shortMessage: "Requested resource not found."
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "ResourceNotFoundRpcError"
    });
  }
}
Object.defineProperty(al, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32001
});
class cl extends Ei {
  constructor(e) {
    super(e, {
      code: cl.code,
      name: "ResourceUnavailableRpcError",
      shortMessage: "Requested resource not available."
    });
  }
}
Object.defineProperty(cl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32002
});
class ul extends Ei {
  constructor(e) {
    super(e, {
      code: ul.code,
      name: "TransactionRejectedRpcError",
      shortMessage: "Transaction creation failed."
    });
  }
}
Object.defineProperty(ul, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32003
});
class fl extends Ei {
  constructor(e, { method: r } = {}) {
    super(e, {
      code: fl.code,
      name: "MethodNotSupportedRpcError",
      shortMessage: `Method${r ? ` "${r}"` : ""} is not implemented.`
    });
  }
}
Object.defineProperty(fl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32004
});
class xu extends Ei {
  constructor(e) {
    super(e, {
      code: xu.code,
      name: "LimitExceededRpcError",
      shortMessage: "Request exceeds defined limit."
    });
  }
}
Object.defineProperty(xu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32005
});
class ll extends Ei {
  constructor(e) {
    super(e, {
      code: ll.code,
      name: "JsonRpcVersionUnsupportedError",
      shortMessage: "Version of JSON-RPC protocol is not supported."
    });
  }
}
Object.defineProperty(ll, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32006
});
class cu extends Du {
  constructor(e) {
    super(e, {
      code: cu.code,
      name: "UserRejectedRequestError",
      shortMessage: "User rejected the request."
    });
  }
}
Object.defineProperty(cu, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4001
});
class hl extends Du {
  constructor(e) {
    super(e, {
      code: hl.code,
      name: "UnauthorizedProviderError",
      shortMessage: "The requested method and/or account has not been authorized by the user."
    });
  }
}
Object.defineProperty(hl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4100
});
class dl extends Du {
  constructor(e, { method: r } = {}) {
    super(e, {
      code: dl.code,
      name: "UnsupportedProviderMethodError",
      shortMessage: `The Provider does not support the requested method${r ? ` " ${r}"` : ""}.`
    });
  }
}
Object.defineProperty(dl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4200
});
class pl extends Du {
  constructor(e) {
    super(e, {
      code: pl.code,
      name: "ProviderDisconnectedError",
      shortMessage: "The Provider is disconnected from all chains."
    });
  }
}
Object.defineProperty(pl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4900
});
class gl extends Du {
  constructor(e) {
    super(e, {
      code: gl.code,
      name: "ChainDisconnectedError",
      shortMessage: "The Provider is not connected to the requested chain."
    });
  }
}
Object.defineProperty(gl, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4901
});
class ml extends Du {
  constructor(e) {
    super(e, {
      code: ml.code,
      name: "SwitchChainError",
      shortMessage: "An error occurred when attempting to switch chain."
    });
  }
}
Object.defineProperty(ml, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4902
});
class $O extends Ei {
  constructor(e) {
    super(e, {
      name: "UnknownRpcError",
      shortMessage: "An unknown RPC error occurred."
    });
  }
}
const BO = 3;
function FO(t, { abi: e, address: r, args: n, docsPath: i, functionName: s, sender: o }) {
  const { code: a, data: u, message: l, shortMessage: d } = t instanceof NO ? t : t instanceof yt ? t.walk((w) => "data" in w) || t.walk() : {}, p = t instanceof wv ? new OO({ functionName: s }) : [BO, fc.code].includes(a) && (u || l || d) ? new DO({
    abi: e,
    data: typeof u == "object" ? u.data : u,
    functionName: s,
    message: d ?? l
  }) : t;
  return new RO(p, {
    abi: e,
    args: n,
    contractAddress: r,
    docsPath: i,
    functionName: s,
    sender: o
  });
}
function jO(t) {
  const e = $l(`0x${t.substring(4)}`).substring(26);
  return Bl(`0x${e}`);
}
async function UO({ hash: t, signature: e }) {
  const r = ya(t) ? t : zd(t), { secp256k1: n } = await import("./secp256k1-S2RhtMGq.js");
  return `0x${(() => {
    if (typeof e == "object" && "r" in e && "s" in e) {
      const { r: l, s: d, v: p, yParity: w } = e, A = Number(w ?? p), P = T2(A);
      return new n.Signature(el(l), el(d)).addRecoveryBit(P);
    }
    const o = ya(e) ? e : zd(e), a = bu(`0x${o.slice(130)}`), u = T2(a);
    return n.Signature.fromCompact(o.substring(2, 130)).addRecoveryBit(u);
  })().recoverPublicKey(r.substring(2)).toHex(!1)}`;
}
function T2(t) {
  if (t === 0 || t === 1)
    return t;
  if (t === 27)
    return 0;
  if (t === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}
async function qO({ hash: t, signature: e }) {
  return jO(await UO({ hash: t, signature: e }));
}
function zO(t, e = "hex") {
  const r = J5(t), n = Iv(new Uint8Array(r.length));
  return r.encode(n), e === "hex" ? wi(n.bytes) : n.bytes;
}
function J5(t) {
  return Array.isArray(t) ? WO(t.map((e) => J5(e))) : HO(t);
}
function WO(t) {
  const e = t.reduce((i, s) => i + s.length, 0), r = X5(e);
  return {
    length: e <= 55 ? 1 + e : 1 + r + e,
    encode(i) {
      e <= 55 ? i.pushByte(192 + e) : (i.pushByte(247 + r), r === 1 ? i.pushUint8(e) : r === 2 ? i.pushUint16(e) : r === 3 ? i.pushUint24(e) : i.pushUint32(e));
      for (const { encode: s } of t)
        s(i);
    }
  };
}
function HO(t) {
  const e = typeof t == "string" ? ko(t) : t, r = X5(e.length);
  return {
    length: e.length === 1 && e[0] < 128 ? 1 : e.length <= 55 ? 1 + e.length : 1 + r + e.length,
    encode(i) {
      e.length === 1 && e[0] < 128 ? i.pushBytes(e) : e.length <= 55 ? (i.pushByte(128 + e.length), i.pushBytes(e)) : (i.pushByte(183 + r), r === 1 ? i.pushUint8(e.length) : r === 2 ? i.pushUint16(e.length) : r === 3 ? i.pushUint24(e.length) : i.pushUint32(e.length), i.pushBytes(e));
    }
  };
}
function X5(t) {
  if (t < 2 ** 8)
    return 1;
  if (t < 2 ** 16)
    return 2;
  if (t < 2 ** 24)
    return 3;
  if (t < 2 ** 32)
    return 4;
  throw new yt("Length is too large.");
}
function KO(t) {
  const { chainId: e, contractAddress: r, nonce: n, to: i } = t, s = $l(R0([
    "0x05",
    zO([
      e ? Mr(e) : "0x",
      r,
      n ? Mr(n) : "0x"
    ])
  ]));
  return i === "bytes" ? ko(s) : s;
}
async function Z5(t) {
  const { authorization: e, signature: r } = t;
  return qO({
    hash: KO(e),
    signature: r ?? e
  });
}
class VO extends yt {
  constructor(e, { account: r, docsPath: n, chain: i, data: s, gas: o, gasPrice: a, maxFeePerGas: u, maxPriorityFeePerGas: l, nonce: d, to: p, value: w }) {
    var P;
    const A = D0({
      from: r == null ? void 0 : r.address,
      to: p,
      value: typeof w < "u" && `${V5(w)} ${((P = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : P.symbol) || "ETH"}`,
      data: s,
      gas: o,
      gasPrice: typeof a < "u" && `${Es(a)} gwei`,
      maxFeePerGas: typeof u < "u" && `${Es(u)} gwei`,
      maxPriorityFeePerGas: typeof l < "u" && `${Es(l)} gwei`,
      nonce: d
    });
    super(e.shortMessage, {
      cause: e,
      docsPath: n,
      metaMessages: [
        ...e.metaMessages ? [...e.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        A
      ].filter(Boolean),
      name: "EstimateGasExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = e;
  }
}
class Zc extends yt {
  constructor({ cause: e, message: r } = {}) {
    var i;
    const n = (i = r == null ? void 0 : r.replace("execution reverted: ", "")) == null ? void 0 : i.replace("execution reverted", "");
    super(`Execution reverted ${n ? `with reason: ${n}` : "for an unknown reason"}.`, {
      cause: e,
      name: "ExecutionRevertedError"
    });
  }
}
Object.defineProperty(Zc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3
});
Object.defineProperty(Zc, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class Vd extends yt {
  constructor({ cause: e, maxFeePerGas: r } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${r ? ` = ${Es(r)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: e,
      name: "FeeCapTooHighError"
    });
  }
}
Object.defineProperty(Vd, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class Qm extends yt {
  constructor({ cause: e, maxFeePerGas: r } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${r ? ` = ${Es(r)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause: e,
      name: "FeeCapTooLowError"
    });
  }
}
Object.defineProperty(Qm, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class e1 extends yt {
  constructor({ cause: e, nonce: r } = {}) {
    super(`Nonce provided for the transaction ${r ? `(${r}) ` : ""}is higher than the next one expected.`, { cause: e, name: "NonceTooHighError" });
  }
}
Object.defineProperty(e1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/
});
class t1 extends yt {
  constructor({ cause: e, nonce: r } = {}) {
    super([
      `Nonce provided for the transaction ${r ? `(${r}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join(`
`), { cause: e, name: "NonceTooLowError" });
  }
}
Object.defineProperty(t1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/
});
class r1 extends yt {
  constructor({ cause: e, nonce: r } = {}) {
    super(`Nonce provided for the transaction ${r ? `(${r}) ` : ""}exceeds the maximum allowed nonce.`, { cause: e, name: "NonceMaxValueError" });
  }
}
Object.defineProperty(r1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/
});
class n1 extends yt {
  constructor({ cause: e } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join(`
`), {
      cause: e,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ],
      name: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(n1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds|exceeds transaction sender account balance/
});
class i1 extends yt {
  constructor({ cause: e, gas: r } = {}) {
    super(`The amount of gas ${r ? `(${r}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause: e,
      name: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(i1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/
});
class s1 extends yt {
  constructor({ cause: e, gas: r } = {}) {
    super(`The amount of gas ${r ? `(${r}) ` : ""}provided for the transaction is too low.`, {
      cause: e,
      name: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(s1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/
});
class o1 extends yt {
  constructor({ cause: e }) {
    super("The transaction type is not supported for this chain.", {
      cause: e,
      name: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(o1, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/
});
class Gd extends yt {
  constructor({ cause: e, maxPriorityFeePerGas: r, maxFeePerGas: n } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${r ? ` = ${Es(r)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${n ? ` = ${Es(n)} gwei` : ""}).`
    ].join(`
`), {
      cause: e,
      name: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(Gd, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class Cv extends yt {
  constructor({ cause: e }) {
    super(`An error occurred while executing: ${e == null ? void 0 : e.shortMessage}`, {
      cause: e,
      name: "UnknownNodeError"
    });
  }
}
function Q5(t, e) {
  const r = (t.details || "").toLowerCase(), n = t instanceof yt ? t.walk((i) => (i == null ? void 0 : i.code) === Zc.code) : t;
  return n instanceof yt ? new Zc({
    cause: t,
    message: n.details
  }) : Zc.nodeMessage.test(r) ? new Zc({
    cause: t,
    message: t.details
  }) : Vd.nodeMessage.test(r) ? new Vd({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas
  }) : Qm.nodeMessage.test(r) ? new Qm({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas
  }) : e1.nodeMessage.test(r) ? new e1({ cause: t, nonce: e == null ? void 0 : e.nonce }) : t1.nodeMessage.test(r) ? new t1({ cause: t, nonce: e == null ? void 0 : e.nonce }) : r1.nodeMessage.test(r) ? new r1({ cause: t, nonce: e == null ? void 0 : e.nonce }) : n1.nodeMessage.test(r) ? new n1({ cause: t }) : i1.nodeMessage.test(r) ? new i1({ cause: t, gas: e == null ? void 0 : e.gas }) : s1.nodeMessage.test(r) ? new s1({ cause: t, gas: e == null ? void 0 : e.gas }) : o1.nodeMessage.test(r) ? new o1({ cause: t }) : Gd.nodeMessage.test(r) ? new Gd({
    cause: t,
    maxFeePerGas: e == null ? void 0 : e.maxFeePerGas,
    maxPriorityFeePerGas: e == null ? void 0 : e.maxPriorityFeePerGas
  }) : new Cv({
    cause: t
  });
}
function GO(t, { docsPath: e, ...r }) {
  const n = (() => {
    const i = Q5(t, r);
    return i instanceof Cv ? t : i;
  })();
  return new VO(n, {
    docsPath: e,
    ...r
  });
}
function e4(t, { format: e }) {
  if (!e)
    return {};
  const r = {};
  function n(s) {
    const o = Object.keys(s);
    for (const a of o)
      a in t && (r[a] = t[a]), s[a] && typeof s[a] == "object" && !Array.isArray(s[a]) && n(s[a]);
  }
  const i = e(t || {});
  return n(i), r;
}
const YO = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
function Tv(t) {
  const e = {};
  return typeof t.authorizationList < "u" && (e.authorizationList = JO(t.authorizationList)), typeof t.accessList < "u" && (e.accessList = t.accessList), typeof t.blobVersionedHashes < "u" && (e.blobVersionedHashes = t.blobVersionedHashes), typeof t.blobs < "u" && (typeof t.blobs[0] != "string" ? e.blobs = t.blobs.map((r) => wi(r)) : e.blobs = t.blobs), typeof t.data < "u" && (e.data = t.data), typeof t.from < "u" && (e.from = t.from), typeof t.gas < "u" && (e.gas = Mr(t.gas)), typeof t.gasPrice < "u" && (e.gasPrice = Mr(t.gasPrice)), typeof t.maxFeePerBlobGas < "u" && (e.maxFeePerBlobGas = Mr(t.maxFeePerBlobGas)), typeof t.maxFeePerGas < "u" && (e.maxFeePerGas = Mr(t.maxFeePerGas)), typeof t.maxPriorityFeePerGas < "u" && (e.maxPriorityFeePerGas = Mr(t.maxPriorityFeePerGas)), typeof t.nonce < "u" && (e.nonce = Mr(t.nonce)), typeof t.to < "u" && (e.to = t.to), typeof t.type < "u" && (e.type = YO[t.type]), typeof t.value < "u" && (e.value = Mr(t.value)), e;
}
function JO(t) {
  return t.map((e) => ({
    address: e.contractAddress,
    r: e.r,
    s: e.s,
    chainId: Mr(e.chainId),
    nonce: Mr(e.nonce),
    ...typeof e.yParity < "u" ? { yParity: Mr(e.yParity) } : {},
    ...typeof e.v < "u" && typeof e.yParity > "u" ? { v: Mr(e.v) } : {}
  }));
}
function R2(t) {
  if (!(!t || t.length === 0))
    return t.reduce((e, { slot: r, value: n }) => {
      if (r.length !== 66)
        throw new w2({
          size: r.length,
          targetSize: 66,
          type: "hex"
        });
      if (n.length !== 66)
        throw new w2({
          size: n.length,
          targetSize: 66,
          type: "hex"
        });
      return e[r] = n, e;
    }, {});
}
function XO(t) {
  const { balance: e, nonce: r, state: n, stateDiff: i, code: s } = t, o = {};
  if (s !== void 0 && (o.code = s), e !== void 0 && (o.balance = Mr(e)), r !== void 0 && (o.nonce = Mr(r)), n !== void 0 && (o.state = R2(n)), i !== void 0) {
    if (o.state)
      throw new PO();
    o.stateDiff = R2(i);
  }
  return o;
}
function ZO(t) {
  if (!t)
    return;
  const e = {};
  for (const { address: r, ...n } of t) {
    if (!$o(r, { strict: !1 }))
      throw new yu({ address: r });
    if (e[r])
      throw new AO({ address: r });
    e[r] = XO(n);
  }
  return e;
}
const QO = 2n ** 256n - 1n;
function O0(t) {
  const { account: e, gasPrice: r, maxFeePerGas: n, maxPriorityFeePerGas: i, to: s } = t, o = e ? Wo(e) : void 0;
  if (o && !$o(o.address))
    throw new yu({ address: o.address });
  if (s && !$o(s))
    throw new yu({ address: s });
  if (typeof r < "u" && (typeof n < "u" || typeof i < "u"))
    throw new MO();
  if (n && n > QO)
    throw new Vd({ maxFeePerGas: n });
  if (i && n && i > n)
    throw new Gd({ maxFeePerGas: n, maxPriorityFeePerGas: i });
}
class eN extends yt {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError"
    });
  }
}
class Rv extends yt {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError"
    });
  }
}
class tN extends yt {
  constructor({ maxPriorityFeePerGas: e }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${Es(e)} gwei).`, { name: "MaxFeePerGasTooLowError" });
  }
}
class rN extends yt {
  constructor({ blockHash: e, blockNumber: r }) {
    let n = "Block";
    e && (n = `Block at hash "${e}"`), r && (n = `Block at number "${r}"`), super(`${n} could not be found.`, { name: "BlockNotFoundError" });
  }
}
const nN = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function iN(t) {
  const e = {
    ...t,
    blockHash: t.blockHash ? t.blockHash : null,
    blockNumber: t.blockNumber ? BigInt(t.blockNumber) : null,
    chainId: t.chainId ? bu(t.chainId) : void 0,
    gas: t.gas ? BigInt(t.gas) : void 0,
    gasPrice: t.gasPrice ? BigInt(t.gasPrice) : void 0,
    maxFeePerBlobGas: t.maxFeePerBlobGas ? BigInt(t.maxFeePerBlobGas) : void 0,
    maxFeePerGas: t.maxFeePerGas ? BigInt(t.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: t.maxPriorityFeePerGas ? BigInt(t.maxPriorityFeePerGas) : void 0,
    nonce: t.nonce ? bu(t.nonce) : void 0,
    to: t.to ? t.to : null,
    transactionIndex: t.transactionIndex ? Number(t.transactionIndex) : null,
    type: t.type ? nN[t.type] : void 0,
    typeHex: t.type ? t.type : void 0,
    value: t.value ? BigInt(t.value) : void 0,
    v: t.v ? BigInt(t.v) : void 0
  };
  return t.authorizationList && (e.authorizationList = sN(t.authorizationList)), e.yParity = (() => {
    if (t.yParity)
      return Number(t.yParity);
    if (typeof e.v == "bigint") {
      if (e.v === 0n || e.v === 27n)
        return 0;
      if (e.v === 1n || e.v === 28n)
        return 1;
      if (e.v >= 35n)
        return e.v % 2n === 0n ? 1 : 0;
    }
  })(), e.type === "legacy" && (delete e.accessList, delete e.maxFeePerBlobGas, delete e.maxFeePerGas, delete e.maxPriorityFeePerGas, delete e.yParity), e.type === "eip2930" && (delete e.maxFeePerBlobGas, delete e.maxFeePerGas, delete e.maxPriorityFeePerGas), e.type === "eip1559" && delete e.maxFeePerBlobGas, e;
}
function sN(t) {
  return t.map((e) => ({
    contractAddress: e.address,
    chainId: Number(e.chainId),
    nonce: Number(e.nonce),
    r: e.r,
    s: e.s,
    yParity: Number(e.yParity)
  }));
}
function oN(t) {
  const e = (t.transactions ?? []).map((r) => typeof r == "string" ? r : iN(r));
  return {
    ...t,
    baseFeePerGas: t.baseFeePerGas ? BigInt(t.baseFeePerGas) : null,
    blobGasUsed: t.blobGasUsed ? BigInt(t.blobGasUsed) : void 0,
    difficulty: t.difficulty ? BigInt(t.difficulty) : void 0,
    excessBlobGas: t.excessBlobGas ? BigInt(t.excessBlobGas) : void 0,
    gasLimit: t.gasLimit ? BigInt(t.gasLimit) : void 0,
    gasUsed: t.gasUsed ? BigInt(t.gasUsed) : void 0,
    hash: t.hash ? t.hash : null,
    logsBloom: t.logsBloom ? t.logsBloom : null,
    nonce: t.nonce ? t.nonce : null,
    number: t.number ? BigInt(t.number) : null,
    size: t.size ? BigInt(t.size) : void 0,
    timestamp: t.timestamp ? BigInt(t.timestamp) : void 0,
    transactions: e,
    totalDifficulty: t.totalDifficulty ? BigInt(t.totalDifficulty) : null
  };
}
async function Yd(t, { blockHash: e, blockNumber: r, blockTag: n, includeTransactions: i } = {}) {
  var d, p, w;
  const s = n ?? "latest", o = i ?? !1, a = r !== void 0 ? Mr(r) : void 0;
  let u = null;
  if (e ? u = await t.request({
    method: "eth_getBlockByHash",
    params: [e, o]
  }, { dedupe: !0 }) : u = await t.request({
    method: "eth_getBlockByNumber",
    params: [a || s, o]
  }, { dedupe: !!a }), !u)
    throw new rN({ blockHash: e, blockNumber: r });
  return (((w = (p = (d = t.chain) == null ? void 0 : d.formatters) == null ? void 0 : p.block) == null ? void 0 : w.format) || oN)(u);
}
async function t4(t) {
  const e = await t.request({
    method: "eth_gasPrice"
  });
  return BigInt(e);
}
async function aN(t, e) {
  var s, o;
  const { block: r, chain: n = t.chain, request: i } = e || {};
  try {
    const a = ((s = n == null ? void 0 : n.fees) == null ? void 0 : s.maxPriorityFeePerGas) ?? ((o = n == null ? void 0 : n.fees) == null ? void 0 : o.defaultPriorityFee);
    if (typeof a == "function") {
      const l = r || await bi(t, Yd, "getBlock")({}), d = await a({
        block: l,
        client: t,
        request: i
      });
      if (d === null)
        throw new Error();
      return d;
    }
    if (typeof a < "u")
      return a;
    const u = await t.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return el(u);
  } catch {
    const [a, u] = await Promise.all([
      r ? Promise.resolve(r) : bi(t, Yd, "getBlock")({}),
      bi(t, t4, "getGasPrice")({})
    ]);
    if (typeof a.baseFeePerGas != "bigint")
      throw new Rv();
    const l = u - a.baseFeePerGas;
    return l < 0n ? 0n : l;
  }
}
async function D2(t, e) {
  var w, A;
  const { block: r, chain: n = t.chain, request: i, type: s = "eip1559" } = e || {}, o = await (async () => {
    var P, N;
    return typeof ((P = n == null ? void 0 : n.fees) == null ? void 0 : P.baseFeeMultiplier) == "function" ? n.fees.baseFeeMultiplier({
      block: r,
      client: t,
      request: i
    }) : ((N = n == null ? void 0 : n.fees) == null ? void 0 : N.baseFeeMultiplier) ?? 1.2;
  })();
  if (o < 1)
    throw new eN();
  const u = 10 ** (((w = o.toString().split(".")[1]) == null ? void 0 : w.length) ?? 0), l = (P) => P * BigInt(Math.ceil(o * u)) / BigInt(u), d = r || await bi(t, Yd, "getBlock")({});
  if (typeof ((A = n == null ? void 0 : n.fees) == null ? void 0 : A.estimateFeesPerGas) == "function") {
    const P = await n.fees.estimateFeesPerGas({
      block: r,
      client: t,
      multiply: l,
      request: i,
      type: s
    });
    if (P !== null)
      return P;
  }
  if (s === "eip1559") {
    if (typeof d.baseFeePerGas != "bigint")
      throw new Rv();
    const P = typeof (i == null ? void 0 : i.maxPriorityFeePerGas) == "bigint" ? i.maxPriorityFeePerGas : await aN(t, {
      block: d,
      chain: n,
      request: i
    }), N = l(d.baseFeePerGas);
    return {
      maxFeePerGas: (i == null ? void 0 : i.maxFeePerGas) ?? N + P,
      maxPriorityFeePerGas: P
    };
  }
  return {
    gasPrice: (i == null ? void 0 : i.gasPrice) ?? l(await bi(t, t4, "getGasPrice")({}))
  };
}
async function cN(t, { address: e, blockTag: r = "latest", blockNumber: n }) {
  const i = await t.request({
    method: "eth_getTransactionCount",
    params: [e, n ? Mr(n) : r]
  }, { dedupe: !!n });
  return bu(i);
}
function r4(t) {
  const { kzg: e } = t, r = t.to ?? (typeof t.blobs[0] == "string" ? "hex" : "bytes"), n = typeof t.blobs[0] == "string" ? t.blobs.map((s) => ko(s)) : t.blobs, i = [];
  for (const s of n)
    i.push(Uint8Array.from(e.blobToKzgCommitment(s)));
  return r === "bytes" ? i : i.map((s) => wi(s));
}
function n4(t) {
  const { kzg: e } = t, r = t.to ?? (typeof t.blobs[0] == "string" ? "hex" : "bytes"), n = typeof t.blobs[0] == "string" ? t.blobs.map((o) => ko(o)) : t.blobs, i = typeof t.commitments[0] == "string" ? t.commitments.map((o) => ko(o)) : t.commitments, s = [];
  for (let o = 0; o < n.length; o++) {
    const a = n[o], u = i[o];
    s.push(Uint8Array.from(e.computeBlobKzgProof(a, u)));
  }
  return r === "bytes" ? s : s.map((o) => wi(o));
}
function uN(t, e, r, n) {
  if (typeof t.setBigUint64 == "function")
    return t.setBigUint64(e, r, n);
  const i = BigInt(32), s = BigInt(4294967295), o = Number(r >> i & s), a = Number(r & s), u = n ? 4 : 0, l = n ? 0 : 4;
  t.setUint32(e + u, o, n), t.setUint32(e + l, a, n);
}
const fN = (t, e, r) => t & e ^ ~t & r, lN = (t, e, r) => t & e ^ t & r ^ e & r;
class hN extends T5 {
  constructor(e, r, n, i) {
    super(), this.blockLen = e, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = Bg(this.buffer);
  }
  update(e) {
    Hd(this);
    const { view: r, buffer: n, blockLen: i } = this;
    e = C0(e);
    const s = e.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const u = Bg(e);
        for (; i <= s - o; o += i)
          this.process(u, o);
        continue;
      }
      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Hd(this), C5(e, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    r[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(n, 0), o = 0);
    for (let p = o; p < i; p++)
      r[p] = 0;
    uN(n, i - 8, BigInt(this.length * 8), s), this.process(n, 0);
    const a = Bg(e), u = this.outputLen;
    if (u % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = u / 4, d = this.get();
    if (l > d.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let p = 0; p < l; p++)
      a.setUint32(4 * p, d[p], s);
  }
  digest() {
    const { buffer: e, outputLen: r } = this;
    this.digestInto(e);
    const n = e.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: s, destroyed: o, pos: a } = this;
    return e.length = i, e.pos = a, e.finished = s, e.destroyed = o, i % r && e.buffer.set(n), e;
  }
}
const dN = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), ta = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), ra = /* @__PURE__ */ new Uint32Array(64);
let pN = class extends hN {
  constructor() {
    super(64, 32, 8, !1), this.A = ta[0] | 0, this.B = ta[1] | 0, this.C = ta[2] | 0, this.D = ta[3] | 0, this.E = ta[4] | 0, this.F = ta[5] | 0, this.G = ta[6] | 0, this.H = ta[7] | 0;
  }
  get() {
    const { A: e, B: r, C: n, D: i, E: s, F: o, G: a, H: u } = this;
    return [e, r, n, i, s, o, a, u];
  }
  // prettier-ignore
  set(e, r, n, i, s, o, a, u) {
    this.A = e | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = u | 0;
  }
  process(e, r) {
    for (let p = 0; p < 16; p++, r += 4)
      ra[p] = e.getUint32(r, !1);
    for (let p = 16; p < 64; p++) {
      const w = ra[p - 15], A = ra[p - 2], P = Ns(w, 7) ^ Ns(w, 18) ^ w >>> 3, N = Ns(A, 17) ^ Ns(A, 19) ^ A >>> 10;
      ra[p] = N + ra[p - 7] + P + ra[p - 16] | 0;
    }
    let { A: n, B: i, C: s, D: o, E: a, F: u, G: l, H: d } = this;
    for (let p = 0; p < 64; p++) {
      const w = Ns(a, 6) ^ Ns(a, 11) ^ Ns(a, 25), A = d + w + fN(a, u, l) + dN[p] + ra[p] | 0, N = (Ns(n, 2) ^ Ns(n, 13) ^ Ns(n, 22)) + lN(n, i, s) | 0;
      d = l, l = u, u = a, a = o + A | 0, o = s, s = i, i = n, n = A + N | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, u = u + this.F | 0, l = l + this.G | 0, d = d + this.H | 0, this.set(n, i, s, o, a, u, l, d);
  }
  roundClean() {
    ra.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
const i4 = /* @__PURE__ */ R5(() => new pN());
function gN(t, e) {
  return i4(ya(t, { strict: !1 }) ? _v(t) : t);
}
function mN(t) {
  const { commitment: e, version: r = 1 } = t, n = t.to ?? (typeof e == "string" ? "hex" : "bytes"), i = gN(e);
  return i.set([r], 0), n === "bytes" ? i : wi(i);
}
function vN(t) {
  const { commitments: e, version: r } = t, n = t.to ?? (typeof e[0] == "string" ? "hex" : "bytes"), i = [];
  for (const s of e)
    i.push(mN({
      commitment: s,
      to: n,
      version: r
    }));
  return i;
}
const O2 = 6, s4 = 32, Dv = 4096, o4 = s4 * Dv, N2 = o4 * O2 - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * Dv * O2;
class bN extends yt {
  constructor({ maxSize: e, size: r }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${e} bytes`, `Given: ${r} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
}
class yN extends yt {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}
function wN(t) {
  const e = t.to ?? (typeof t.data == "string" ? "hex" : "bytes"), r = typeof t.data == "string" ? ko(t.data) : t.data, n = An(r);
  if (!n)
    throw new yN();
  if (n > N2)
    throw new bN({
      maxSize: N2,
      size: n
    });
  const i = [];
  let s = !0, o = 0;
  for (; s; ) {
    const a = Iv(new Uint8Array(o4));
    let u = 0;
    for (; u < Dv; ) {
      const l = r.slice(o, o + (s4 - 1));
      if (a.pushByte(0), a.pushBytes(l), l.length < 31) {
        a.pushByte(128), s = !1;
        break;
      }
      u++, o += 31;
    }
    i.push(a);
  }
  return e === "bytes" ? i.map((a) => a.bytes) : i.map((a) => wi(a.bytes));
}
function xN(t) {
  const { data: e, kzg: r, to: n } = t, i = t.blobs ?? wN({ data: e, to: n }), s = t.commitments ?? r4({ blobs: i, kzg: r, to: n }), o = t.proofs ?? n4({ blobs: i, commitments: s, kzg: r, to: n }), a = [];
  for (let u = 0; u < i.length; u++)
    a.push({
      blob: i[u],
      commitment: s[u],
      proof: o[u]
    });
  return a;
}
function _N(t) {
  if (t.type)
    return t.type;
  if (typeof t.authorizationList < "u")
    return "eip7702";
  if (typeof t.blobs < "u" || typeof t.blobVersionedHashes < "u" || typeof t.maxFeePerBlobGas < "u" || typeof t.sidecars < "u")
    return "eip4844";
  if (typeof t.maxFeePerGas < "u" || typeof t.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof t.gasPrice < "u")
    return typeof t.accessList < "u" ? "eip2930" : "legacy";
  throw new IO({ transaction: t });
}
async function N0(t) {
  const e = await t.request({
    method: "eth_chainId"
  }, { dedupe: !0 });
  return bu(e);
}
const a4 = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];
async function Ov(t, e) {
  const { account: r = t.account, blobs: n, chain: i, gas: s, kzg: o, nonce: a, nonceManager: u, parameters: l = a4, type: d } = e, p = r && Wo(r), w = { ...e, ...p ? { from: p == null ? void 0 : p.address } : {} };
  let A;
  async function P() {
    return A || (A = await bi(t, Yd, "getBlock")({ blockTag: "latest" }), A);
  }
  let N;
  async function L() {
    return N || (i ? i.id : typeof e.chainId < "u" ? e.chainId : (N = await bi(t, N0, "getChainId")({}), N));
  }
  if ((l.includes("blobVersionedHashes") || l.includes("sidecars")) && n && o) {
    const $ = r4({ blobs: n, kzg: o });
    if (l.includes("blobVersionedHashes")) {
      const B = vN({
        commitments: $,
        to: "hex"
      });
      w.blobVersionedHashes = B;
    }
    if (l.includes("sidecars")) {
      const B = n4({ blobs: n, commitments: $, kzg: o }), H = xN({
        blobs: n,
        commitments: $,
        proofs: B,
        to: "hex"
      });
      w.sidecars = H;
    }
  }
  if (l.includes("chainId") && (w.chainId = await L()), l.includes("nonce") && typeof a > "u" && p)
    if (u) {
      const $ = await L();
      w.nonce = await u.consume({
        address: p.address,
        chainId: $,
        client: t
      });
    } else
      w.nonce = await bi(t, cN, "getTransactionCount")({
        address: p.address,
        blockTag: "pending"
      });
  if ((l.includes("fees") || l.includes("type")) && typeof d > "u")
    try {
      w.type = _N(w);
    } catch {
      const $ = await P();
      w.type = typeof ($ == null ? void 0 : $.baseFeePerGas) == "bigint" ? "eip1559" : "legacy";
    }
  if (l.includes("fees"))
    if (w.type !== "legacy" && w.type !== "eip2930") {
      if (typeof w.maxFeePerGas > "u" || typeof w.maxPriorityFeePerGas > "u") {
        const $ = await P(), { maxFeePerGas: B, maxPriorityFeePerGas: H } = await D2(t, {
          block: $,
          chain: i,
          request: w
        });
        if (typeof e.maxPriorityFeePerGas > "u" && e.maxFeePerGas && e.maxFeePerGas < H)
          throw new tN({
            maxPriorityFeePerGas: H
          });
        w.maxPriorityFeePerGas = H, w.maxFeePerGas = B;
      }
    } else {
      if (typeof e.maxFeePerGas < "u" || typeof e.maxPriorityFeePerGas < "u")
        throw new Rv();
      const $ = await P(), { gasPrice: B } = await D2(t, {
        block: $,
        chain: i,
        request: w,
        type: "legacy"
      });
      w.gasPrice = B;
    }
  return l.includes("gas") && typeof s > "u" && (w.gas = await bi(t, SN, "estimateGas")({
    ...w,
    account: p && { address: p.address, type: "json-rpc" }
  })), O0(w), delete w.parameters, w;
}
async function EN(t, { address: e, blockNumber: r, blockTag: n = "latest" }) {
  const i = r ? Mr(r) : void 0, s = await t.request({
    method: "eth_getBalance",
    params: [e, i || n]
  });
  return BigInt(s);
}
async function SN(t, e) {
  var i, s, o;
  const { account: r = t.account } = e, n = r ? Wo(r) : void 0;
  try {
    let f = function(b) {
      const { block: x, request: _, rpcStateOverride: E } = b;
      return t.request({
        method: "eth_estimateGas",
        params: E ? [_, x ?? "latest", E] : x ? [_, x] : [_]
      });
    };
    const { accessList: a, authorizationList: u, blobs: l, blobVersionedHashes: d, blockNumber: p, blockTag: w, data: A, gas: P, gasPrice: N, maxFeePerBlobGas: L, maxFeePerGas: $, maxPriorityFeePerGas: B, nonce: H, value: W, stateOverride: V, ...te } = await Ov(t, {
      ...e,
      parameters: (
        // Some RPC Providers do not compute versioned hashes from blobs. We will need
        // to compute them.
        (n == null ? void 0 : n.type) === "local" ? void 0 : ["blobVersionedHashes"]
      )
    }), K = (p ? Mr(p) : void 0) || w, ge = ZO(V), Ee = await (async () => {
      if (te.to)
        return te.to;
      if (u && u.length > 0)
        return await Z5({
          authorization: u[0]
        }).catch(() => {
          throw new yt("`to` is required. Could not infer from `authorizationList`");
        });
    })();
    O0(e);
    const Y = (o = (s = (i = t.chain) == null ? void 0 : i.formatters) == null ? void 0 : s.transactionRequest) == null ? void 0 : o.format, m = (Y || Tv)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...e4(te, { format: Y }),
      from: n == null ? void 0 : n.address,
      accessList: a,
      authorizationList: u,
      blobs: l,
      blobVersionedHashes: d,
      data: A,
      gas: P,
      gasPrice: N,
      maxFeePerBlobGas: L,
      maxFeePerGas: $,
      maxPriorityFeePerGas: B,
      nonce: H,
      to: Ee,
      value: W
    });
    let g = BigInt(await f({ block: K, request: m, rpcStateOverride: ge }));
    if (u) {
      const b = await EN(t, { address: m.from }), x = await Promise.all(u.map(async (_) => {
        const { contractAddress: E } = _, v = await f({
          block: K,
          request: {
            authorizationList: void 0,
            data: A,
            from: n == null ? void 0 : n.address,
            to: E,
            value: Mr(b)
          },
          rpcStateOverride: ge
        }).catch(() => 100000n);
        return 2n * BigInt(v);
      }));
      g += x.reduce((_, E) => _ + E, 0n);
    }
    return g;
  } catch (a) {
    throw GO(a, {
      ...e,
      account: n,
      chain: t.chain
    });
  }
}
class AN extends yt {
  constructor({ chain: e, currentChainId: r }) {
    super(`The current chain of the wallet (id: ${r}) does not match the target chain for the transaction (id: ${e.id}  ${e.name}).`, {
      metaMessages: [
        `Current Chain ID:  ${r}`,
        `Expected Chain ID: ${e.id}  ${e.name}`
      ],
      name: "ChainMismatchError"
    });
  }
}
class PN extends yt {
  constructor() {
    super([
      "No chain was provided to the request.",
      "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
    ].join(`
`), {
      name: "ChainNotFoundError"
    });
  }
}
const Ug = "/docs/contract/encodeDeployData";
function MN(t) {
  const { abi: e, args: r, bytecode: n } = t;
  if (!r || r.length === 0)
    return n;
  const i = e.find((o) => "type" in o && o.type === "constructor");
  if (!i)
    throw new HR({ docsPath: Ug });
  if (!("inputs" in i))
    throw new b2({ docsPath: Ug });
  if (!i.inputs || i.inputs.length === 0)
    throw new b2({ docsPath: Ug });
  const s = q5(i.inputs, r);
  return R0([n, s]);
}
async function IN(t) {
  return new Promise((e) => setTimeout(e, t));
}
class Fl extends yt {
  constructor({ docsPath: e } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join(`
`), {
      docsPath: e,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
}
class qg extends yt {
  constructor({ docsPath: e, metaMessages: r, type: n }) {
    super(`Account type "${n}" is not supported.`, {
      docsPath: e,
      metaMessages: r,
      name: "AccountTypeNotSupportedError"
    });
  }
}
function c4({ chain: t, currentChainId: e }) {
  if (!t)
    throw new PN();
  if (e !== t.id)
    throw new AN({ chain: t, currentChainId: e });
}
function CN(t, { docsPath: e, ...r }) {
  const n = (() => {
    const i = Q5(t, r);
    return i instanceof Cv ? t : i;
  })();
  return new CO(n, {
    docsPath: e,
    ...r
  });
}
async function u4(t, { serializedTransaction: e }) {
  return t.request({
    method: "eth_sendRawTransaction",
    params: [e]
  }, { retryCount: 0 });
}
const zg = new T0(128);
async function Nv(t, e) {
  var $, B, H, W;
  const { account: r = t.account, chain: n = t.chain, accessList: i, authorizationList: s, blobs: o, data: a, gas: u, gasPrice: l, maxFeePerBlobGas: d, maxFeePerGas: p, maxPriorityFeePerGas: w, nonce: A, value: P, ...N } = e;
  if (typeof r > "u")
    throw new Fl({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const L = r ? Wo(r) : null;
  try {
    O0(e);
    const V = await (async () => {
      if (e.to)
        return e.to;
      if (s && s.length > 0)
        return await Z5({
          authorization: s[0]
        }).catch(() => {
          throw new yt("`to` is required. Could not infer from `authorizationList`.");
        });
    })();
    if ((L == null ? void 0 : L.type) === "json-rpc" || L === null) {
      let te;
      n !== null && (te = await bi(t, N0, "getChainId")({}), c4({
        currentChainId: te,
        chain: n
      }));
      const R = (H = (B = ($ = t.chain) == null ? void 0 : $.formatters) == null ? void 0 : B.transactionRequest) == null ? void 0 : H.format, ge = (R || Tv)({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...e4(N, { format: R }),
        accessList: i,
        authorizationList: s,
        blobs: o,
        chainId: te,
        data: a,
        from: L == null ? void 0 : L.address,
        gas: u,
        gasPrice: l,
        maxFeePerBlobGas: d,
        maxFeePerGas: p,
        maxPriorityFeePerGas: w,
        nonce: A,
        to: V,
        value: P
      }), Ee = zg.get(t.uid), Y = Ee ? "wallet_sendTransaction" : "eth_sendTransaction";
      try {
        return await t.request({
          method: Y,
          params: [ge]
        }, { retryCount: 0 });
      } catch (S) {
        if (Ee === !1)
          throw S;
        const m = S;
        if (m.name === "InvalidInputRpcError" || m.name === "InvalidParamsRpcError" || m.name === "MethodNotFoundRpcError" || m.name === "MethodNotSupportedRpcError")
          return await t.request({
            method: "wallet_sendTransaction",
            params: [ge]
          }, { retryCount: 0 }).then((f) => (zg.set(t.uid, !0), f)).catch((f) => {
            const g = f;
            throw g.name === "MethodNotFoundRpcError" || g.name === "MethodNotSupportedRpcError" ? (zg.set(t.uid, !1), m) : g;
          });
        throw m;
      }
    }
    if ((L == null ? void 0 : L.type) === "local") {
      const te = await bi(t, Ov, "prepareTransactionRequest")({
        account: L,
        accessList: i,
        authorizationList: s,
        blobs: o,
        chain: n,
        data: a,
        gas: u,
        gasPrice: l,
        maxFeePerBlobGas: d,
        maxFeePerGas: p,
        maxPriorityFeePerGas: w,
        nonce: A,
        nonceManager: L.nonceManager,
        parameters: [...a4, "sidecars"],
        value: P,
        ...N,
        to: V
      }), R = (W = n == null ? void 0 : n.serializers) == null ? void 0 : W.transaction, K = await L.signTransaction(te, {
        serializer: R
      });
      return await bi(t, u4, "sendRawTransaction")({
        serializedTransaction: K
      });
    }
    throw (L == null ? void 0 : L.type) === "smart" ? new qg({
      metaMessages: [
        "Consider using the `sendUserOperation` Action instead."
      ],
      docsPath: "/docs/actions/bundler/sendUserOperation",
      type: "smart"
    }) : new qg({
      docsPath: "/docs/actions/wallet/sendTransaction",
      type: L == null ? void 0 : L.type
    });
  } catch (V) {
    throw V instanceof qg ? V : CN(V, {
      ...e,
      account: L,
      chain: e.chain || void 0
    });
  }
}
async function TN(t, e) {
  const { abi: r, account: n = t.account, address: i, args: s, dataSuffix: o, functionName: a, ...u } = e;
  if (typeof n > "u")
    throw new Fl({
      docsPath: "/docs/contract/writeContract"
    });
  const l = n ? Wo(n) : null, d = iO({
    abi: r,
    args: s,
    functionName: a
  });
  try {
    return await bi(t, Nv, "sendTransaction")({
      data: `${d}${o ? o.replace("0x", "") : ""}`,
      to: i,
      account: l,
      ...u
    });
  } catch (p) {
    throw FO(p, {
      abi: r,
      address: i,
      args: s,
      docsPath: "/docs/contract/writeContract",
      functionName: a,
      sender: l == null ? void 0 : l.address
    });
  }
}
async function RN(t, { chain: e }) {
  const { id: r, name: n, nativeCurrency: i, rpcUrls: s, blockExplorers: o } = e;
  await t.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: Mr(r),
        chainName: n,
        nativeCurrency: i,
        rpcUrls: s.default.http,
        blockExplorerUrls: o ? Object.values(o).map(({ url: a }) => a) : void 0
      }
    ]
  }, { dedupe: !0, retryCount: 0 });
}
const a1 = 256;
let nd = a1, id;
function f4(t = 11) {
  if (!id || nd + t > a1 * 2) {
    id = "", nd = 0;
    for (let e = 0; e < a1; e++)
      id += (256 + Math.random() * 256 | 0).toString(16).substring(1);
  }
  return id.substring(nd, nd++ + t);
}
function DN(t) {
  const { batch: e, cacheTime: r = t.pollingInterval ?? 4e3, ccipRead: n, key: i = "base", name: s = "Base Client", pollingInterval: o = 4e3, type: a = "base" } = t, u = t.chain, l = t.account ? Wo(t.account) : void 0, { config: d, request: p, value: w } = t.transport({
    chain: u,
    pollingInterval: o
  }), A = { ...d, ...w }, P = {
    account: l,
    batch: e,
    cacheTime: r,
    ccipRead: n,
    chain: u,
    key: i,
    name: s,
    pollingInterval: o,
    request: p,
    transport: A,
    type: a,
    uid: f4()
  };
  function N(L) {
    return ($) => {
      const B = $(L);
      for (const W in P)
        delete B[W];
      const H = { ...L, ...B };
      return Object.assign(H, { extend: N(H) });
    };
  }
  return Object.assign(P, { extend: N(P) });
}
const sd = /* @__PURE__ */ new T0(8192);
function ON(t, { enabled: e = !0, id: r }) {
  if (!e || !r)
    return t();
  if (sd.get(r))
    return sd.get(r);
  const n = t().finally(() => sd.delete(r));
  return sd.set(r, n), n;
}
function NN(t, { delay: e = 100, retryCount: r = 2, shouldRetry: n = () => !0 } = {}) {
  return new Promise((i, s) => {
    const o = async ({ count: a = 0 } = {}) => {
      const u = async ({ error: l }) => {
        const d = typeof e == "function" ? e({ count: a, error: l }) : e;
        d && await IN(d), o({ count: a + 1 });
      };
      try {
        const l = await t();
        i(l);
      } catch (l) {
        if (a < r && await n({ count: a, error: l }))
          return u({ error: l });
        s(l);
      }
    };
    o();
  });
}
function LN(t, e = {}) {
  return async (r, n = {}) => {
    const { dedupe: i = !1, retryDelay: s = 150, retryCount: o = 3, uid: a } = {
      ...e,
      ...n
    }, u = i ? $l(I0(`${a}.${Ru(r)}`)) : void 0;
    return ON(() => NN(async () => {
      try {
        return await t(r);
      } catch (l) {
        const d = l;
        switch (d.code) {
          case rl.code:
            throw new rl(d);
          case nl.code:
            throw new nl(d);
          case il.code:
            throw new il(d, { method: r.method });
          case sl.code:
            throw new sl(d);
          case fc.code:
            throw new fc(d);
          case ol.code:
            throw new ol(d);
          case al.code:
            throw new al(d);
          case cl.code:
            throw new cl(d);
          case ul.code:
            throw new ul(d);
          case fl.code:
            throw new fl(d, {
              method: r.method
            });
          case xu.code:
            throw new xu(d);
          case ll.code:
            throw new ll(d);
          case cu.code:
            throw new cu(d);
          case hl.code:
            throw new hl(d);
          case dl.code:
            throw new dl(d);
          case pl.code:
            throw new pl(d);
          case gl.code:
            throw new gl(d);
          case ml.code:
            throw new ml(d);
          case 5e3:
            throw new cu(d);
          default:
            throw l instanceof yt ? l : new $O(d);
        }
      }
    }, {
      delay: ({ count: l, error: d }) => {
        var p;
        if (d && d instanceof Y5) {
          const w = (p = d == null ? void 0 : d.headers) == null ? void 0 : p.get("Retry-After");
          if (w != null && w.match(/\d/))
            return Number.parseInt(w) * 1e3;
        }
        return ~~(1 << l) * s;
      },
      retryCount: o,
      shouldRetry: ({ error: l }) => kN(l)
    }), { enabled: i, id: u });
  };
}
function kN(t) {
  return "code" in t && typeof t.code == "number" ? t.code === -1 || t.code === xu.code || t.code === fc.code : t instanceof Y5 && t.status ? t.status === 403 || t.status === 408 || t.status === 413 || t.status === 429 || t.status === 500 || t.status === 502 || t.status === 503 || t.status === 504 : !0;
}
function $N({ key: t, name: e, request: r, retryCount: n = 3, retryDelay: i = 150, timeout: s, type: o }, a) {
  const u = f4();
  return {
    config: {
      key: t,
      name: e,
      request: r,
      retryCount: n,
      retryDelay: i,
      timeout: s,
      type: o
    },
    request: LN(r, { retryCount: n, retryDelay: i, uid: u }),
    value: a
  };
}
function BN(t, e = {}) {
  const { key: r = "custom", name: n = "Custom Provider", retryDelay: i } = e;
  return ({ retryCount: s }) => $N({
    key: r,
    name: n,
    request: t.request.bind(t),
    retryCount: e.retryCount ?? s,
    retryDelay: i,
    type: "custom"
  });
}
const FN = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/, jN = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
class UN extends yt {
  constructor({ domain: e }) {
    super(`Invalid domain "${Ru(e)}".`, {
      metaMessages: ["Must be a valid EIP-712 domain."]
    });
  }
}
class qN extends yt {
  constructor({ primaryType: e, types: r }) {
    super(`Invalid primary type \`${e}\` must be one of \`${JSON.stringify(Object.keys(r))}\`.`, {
      docsPath: "/api/glossary/Errors#typeddatainvalidprimarytypeerror",
      metaMessages: ["Check that the primary type is a key in `types`."]
    });
  }
}
class zN extends yt {
  constructor({ type: e }) {
    super(`Struct type "${e}" is invalid.`, {
      metaMessages: ["Struct type must not be a Solidity type."],
      name: "InvalidStructTypeError"
    });
  }
}
function WN(t) {
  const { domain: e, message: r, primaryType: n, types: i } = t, s = (u, l) => {
    const d = { ...l };
    for (const p of u) {
      const { name: w, type: A } = p;
      A === "address" && (d[w] = d[w].toLowerCase());
    }
    return d;
  }, o = i.EIP712Domain ? e ? s(i.EIP712Domain, e) : {} : {}, a = (() => {
    if (n !== "EIP712Domain")
      return s(i[n], r);
  })();
  return Ru({ domain: o, message: a, primaryType: n, types: i });
}
function HN(t) {
  const { domain: e, message: r, primaryType: n, types: i } = t, s = (o, a) => {
    for (const u of o) {
      const { name: l, type: d } = u, p = a[l], w = d.match(jN);
      if (w && (typeof p == "number" || typeof p == "bigint")) {
        const [N, L, $] = w;
        Mr(p, {
          signed: L === "int",
          size: Number.parseInt($) / 8
        });
      }
      if (d === "address" && typeof p == "string" && !$o(p))
        throw new yu({ address: p });
      const A = d.match(FN);
      if (A) {
        const [N, L] = A;
        if (L && An(p) !== Number.parseInt(L))
          throw new XR({
            expectedSize: Number.parseInt(L),
            givenSize: An(p)
          });
      }
      const P = i[d];
      P && (VN(d), s(P, p));
    }
  };
  if (i.EIP712Domain && e) {
    if (typeof e != "object")
      throw new UN({ domain: e });
    s(i.EIP712Domain, e);
  }
  if (n !== "EIP712Domain")
    if (i[n])
      s(i[n], r);
    else
      throw new qN({ primaryType: n, types: i });
}
function KN({ domain: t }) {
  return [
    typeof (t == null ? void 0 : t.name) == "string" && { name: "name", type: "string" },
    (t == null ? void 0 : t.version) && { name: "version", type: "string" },
    typeof (t == null ? void 0 : t.chainId) == "number" && {
      name: "chainId",
      type: "uint256"
    },
    (t == null ? void 0 : t.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (t == null ? void 0 : t.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
function VN(t) {
  if (t === "address" || t === "bool" || t === "string" || t.startsWith("bytes") || t.startsWith("uint") || t.startsWith("int"))
    throw new zN({ type: t });
}
function GN(t, e) {
  const { abi: r, args: n, bytecode: i, ...s } = e, o = MN({ abi: r, args: n, bytecode: i });
  return Nv(t, {
    ...s,
    data: o
  });
}
async function YN(t) {
  var r;
  return ((r = t.account) == null ? void 0 : r.type) === "local" ? [t.account.address] : (await t.request({ method: "eth_accounts" }, { dedupe: !0 })).map((n) => Bl(n));
}
async function JN(t) {
  return await t.request({ method: "wallet_getPermissions" }, { dedupe: !0 });
}
async function XN(t) {
  return (await t.request({ method: "eth_requestAccounts" }, { dedupe: !0, retryCount: 0 })).map((r) => Ev(r));
}
async function ZN(t, e) {
  return t.request({
    method: "wallet_requestPermissions",
    params: [e]
  }, { retryCount: 0 });
}
async function QN(t, { account: e = t.account, message: r }) {
  if (!e)
    throw new Fl({
      docsPath: "/docs/actions/wallet/signMessage"
    });
  const n = Wo(e);
  if (n.signMessage)
    return n.signMessage({ message: r });
  const i = typeof r == "string" ? I0(r) : r.raw instanceof Uint8Array ? zd(r.raw) : r.raw;
  return t.request({
    method: "personal_sign",
    params: [i, n.address]
  }, { retryCount: 0 });
}
async function eL(t, e) {
  var l, d, p, w;
  const { account: r = t.account, chain: n = t.chain, ...i } = e;
  if (!r)
    throw new Fl({
      docsPath: "/docs/actions/wallet/signTransaction"
    });
  const s = Wo(r);
  O0({
    account: s,
    ...e
  });
  const o = await bi(t, N0, "getChainId")({});
  n !== null && c4({
    currentChainId: o,
    chain: n
  });
  const a = (n == null ? void 0 : n.formatters) || ((l = t.chain) == null ? void 0 : l.formatters), u = ((d = a == null ? void 0 : a.transactionRequest) == null ? void 0 : d.format) || Tv;
  return s.signTransaction ? s.signTransaction({
    ...i,
    chainId: o
  }, { serializer: (w = (p = t.chain) == null ? void 0 : p.serializers) == null ? void 0 : w.transaction }) : await t.request({
    method: "eth_signTransaction",
    params: [
      {
        ...u(i),
        chainId: Mr(o),
        from: s.address
      }
    ]
  }, { retryCount: 0 });
}
async function tL(t, e) {
  const { account: r = t.account, domain: n, message: i, primaryType: s } = e;
  if (!r)
    throw new Fl({
      docsPath: "/docs/actions/wallet/signTypedData"
    });
  const o = Wo(r), a = {
    EIP712Domain: KN({ domain: n }),
    ...e.types
  };
  if (HN({ domain: n, message: i, primaryType: s, types: a }), o.signTypedData)
    return o.signTypedData({ domain: n, message: i, primaryType: s, types: a });
  const u = WN({ domain: n, message: i, primaryType: s, types: a });
  return t.request({
    method: "eth_signTypedData_v4",
    params: [o.address, u]
  }, { retryCount: 0 });
}
async function rL(t, { id: e }) {
  await t.request({
    method: "wallet_switchEthereumChain",
    params: [
      {
        chainId: Mr(e)
      }
    ]
  }, { retryCount: 0 });
}
async function nL(t, e) {
  return await t.request({
    method: "wallet_watchAsset",
    params: e
  }, { retryCount: 0 });
}
function iL(t) {
  return {
    addChain: (e) => RN(t, e),
    deployContract: (e) => GN(t, e),
    getAddresses: () => YN(t),
    getChainId: () => N0(t),
    getPermissions: () => JN(t),
    prepareTransactionRequest: (e) => Ov(t, e),
    requestAddresses: () => XN(t),
    requestPermissions: (e) => ZN(t, e),
    sendRawTransaction: (e) => u4(t, e),
    sendTransaction: (e) => Nv(t, e),
    signMessage: (e) => QN(t, e),
    signTransaction: (e) => eL(t, e),
    signTypedData: (e) => tL(t, e),
    switchChain: (e) => rL(t, e),
    watchAsset: (e) => nL(t, e),
    writeContract: (e) => TN(t, e)
  };
}
function sL(t) {
  const { key: e = "wallet", name: r = "Wallet Client", transport: n } = t;
  return DN({
    ...t,
    key: e,
    name: r,
    transport: n,
    type: "walletClient"
  }).extend(iL);
}
class vl {
  constructor(e) {
    Ds(this, "_key");
    Ds(this, "_config", null);
    Ds(this, "_provider", null);
    Ds(this, "_connected", !1);
    Ds(this, "_address", null);
    Ds(this, "_fatured", !1);
    Ds(this, "_installed", !1);
    Ds(this, "lastUsed", !1);
    var r;
    if ("name" in e && "image" in e)
      this._key = e.name, this._config = e, this._fatured = e.featured;
    else if ("session" in e) {
      if (!e.session) throw new Error("session is null");
      this._key = (r = e.session) == null ? void 0 : r.peer.metadata.name, this._provider = e, this._config = {
        name: e.session.peer.metadata.name,
        image: e.session.peer.metadata.icons[0],
        featured: !1
      };
    } else if ("info" in e)
      console.log(e.info, "installed"), this._key = e.info.name, this._provider = e.provider, this._installed = !0, this._config = {
        name: e.info.name,
        image: e.info.icon,
        featured: !1
      }, this.testConnect();
    else
      throw new Error("unknown params");
  }
  get address() {
    return this._address;
  }
  get connected() {
    return this._connected;
  }
  get featured() {
    return this._fatured;
  }
  get key() {
    return this._key;
  }
  get installed() {
    return this._installed;
  }
  get client() {
    return this._provider ? sL({ transport: BN(this._provider) }) : null;
  }
  get config() {
    return this._config;
  }
  static fromWalletConfig(e) {
    return new vl(e);
  }
  EIP6963Detected(e) {
    this._provider = e.provider, this._installed = !0, this._provider.on("disconnect", this.disconnect), this._provider.on("accountsChanged", (r) => {
      this._address = r[0], this._connected = !0;
    }), this.testConnect();
  }
  setUniversalProvider(e) {
    this._provider = e, this.testConnect();
  }
  async testConnect() {
    var r;
    const e = await ((r = this.client) == null ? void 0 : r.getAddresses());
    e && e.length > 0 ? (this._address = e[0], this._connected = !0) : (this._address = null, this._connected = !1);
  }
  async connect() {
    var r;
    const e = await ((r = this.client) == null ? void 0 : r.request({ method: "eth_requestAccounts", params: void 0 }));
    if (!e) throw new Error("connect failed");
    return e;
  }
  async getAddress() {
    var r;
    const e = await ((r = this.client) == null ? void 0 : r.getAddresses());
    if (!e) throw new Error("get address failed");
    return e[0];
  }
  async getChain() {
    var r;
    const e = await ((r = this.client) == null ? void 0 : r.getChainId());
    if (!e) throw new Error("get chain failed");
    return e;
  }
  async signMessage(e, r) {
    var i;
    return await ((i = this.client) == null ? void 0 : i.signMessage({ message: e, account: r }));
  }
  async disconnect() {
    this._provider && "session" in this._provider && await this._provider.disconnect(), this._connected = !1, this._address = null;
  }
}
var Lv = { exports: {} }, uu = typeof Reflect == "object" ? Reflect : null, L2 = uu && typeof uu.apply == "function" ? uu.apply : function(e, r, n) {
  return Function.prototype.apply.call(e, r, n);
}, xd;
uu && typeof uu.ownKeys == "function" ? xd = uu.ownKeys : Object.getOwnPropertySymbols ? xd = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : xd = function(e) {
  return Object.getOwnPropertyNames(e);
};
function oL(t) {
  console && console.warn && console.warn(t);
}
var l4 = Number.isNaN || function(e) {
  return e !== e;
};
function kr() {
  kr.init.call(this);
}
Lv.exports = kr;
Lv.exports.once = fL;
kr.EventEmitter = kr;
kr.prototype._events = void 0;
kr.prototype._eventsCount = 0;
kr.prototype._maxListeners = void 0;
var k2 = 10;
function L0(t) {
  if (typeof t != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
}
Object.defineProperty(kr, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return k2;
  },
  set: function(t) {
    if (typeof t != "number" || t < 0 || l4(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    k2 = t;
  }
});
kr.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
kr.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || l4(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function h4(t) {
  return t._maxListeners === void 0 ? kr.defaultMaxListeners : t._maxListeners;
}
kr.prototype.getMaxListeners = function() {
  return h4(this);
};
kr.prototype.emit = function(e) {
  for (var r = [], n = 1; n < arguments.length; n++) r.push(arguments[n]);
  var i = e === "error", s = this._events;
  if (s !== void 0)
    i = i && s.error === void 0;
  else if (!i)
    return !1;
  if (i) {
    var o;
    if (r.length > 0 && (o = r[0]), o instanceof Error)
      throw o;
    var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
    throw a.context = o, a;
  }
  var u = s[e];
  if (u === void 0)
    return !1;
  if (typeof u == "function")
    L2(u, this, r);
  else
    for (var l = u.length, d = v4(u, l), n = 0; n < l; ++n)
      L2(d[n], this, r);
  return !0;
};
function d4(t, e, r, n) {
  var i, s, o;
  if (L0(r), s = t._events, s === void 0 ? (s = t._events = /* @__PURE__ */ Object.create(null), t._eventsCount = 0) : (s.newListener !== void 0 && (t.emit(
    "newListener",
    e,
    r.listener ? r.listener : r
  ), s = t._events), o = s[e]), o === void 0)
    o = s[e] = r, ++t._eventsCount;
  else if (typeof o == "function" ? o = s[e] = n ? [r, o] : [o, r] : n ? o.unshift(r) : o.push(r), i = h4(t), i > 0 && o.length > i && !o.warned) {
    o.warned = !0;
    var a = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a.name = "MaxListenersExceededWarning", a.emitter = t, a.type = e, a.count = o.length, oL(a);
  }
  return t;
}
kr.prototype.addListener = function(e, r) {
  return d4(this, e, r, !1);
};
kr.prototype.on = kr.prototype.addListener;
kr.prototype.prependListener = function(e, r) {
  return d4(this, e, r, !0);
};
function aL() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function p4(t, e, r) {
  var n = { fired: !1, wrapFn: void 0, target: t, type: e, listener: r }, i = aL.bind(n);
  return i.listener = r, n.wrapFn = i, i;
}
kr.prototype.once = function(e, r) {
  return L0(r), this.on(e, p4(this, e, r)), this;
};
kr.prototype.prependOnceListener = function(e, r) {
  return L0(r), this.prependListener(e, p4(this, e, r)), this;
};
kr.prototype.removeListener = function(e, r) {
  var n, i, s, o, a;
  if (L0(r), i = this._events, i === void 0)
    return this;
  if (n = i[e], n === void 0)
    return this;
  if (n === r || n.listener === r)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || r));
  else if (typeof n != "function") {
    for (s = -1, o = n.length - 1; o >= 0; o--)
      if (n[o] === r || n[o].listener === r) {
        a = n[o].listener, s = o;
        break;
      }
    if (s < 0)
      return this;
    s === 0 ? n.shift() : cL(n, s), n.length === 1 && (i[e] = n[0]), i.removeListener !== void 0 && this.emit("removeListener", e, a || r);
  }
  return this;
};
kr.prototype.off = kr.prototype.removeListener;
kr.prototype.removeAllListeners = function(e) {
  var r, n, i;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[e]), this;
  if (arguments.length === 0) {
    var s = Object.keys(n), o;
    for (i = 0; i < s.length; ++i)
      o = s[i], o !== "removeListener" && this.removeAllListeners(o);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r = n[e], typeof r == "function")
    this.removeListener(e, r);
  else if (r !== void 0)
    for (i = r.length - 1; i >= 0; i--)
      this.removeListener(e, r[i]);
  return this;
};
function g4(t, e, r) {
  var n = t._events;
  if (n === void 0)
    return [];
  var i = n[e];
  return i === void 0 ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? uL(i) : v4(i, i.length);
}
kr.prototype.listeners = function(e) {
  return g4(this, e, !0);
};
kr.prototype.rawListeners = function(e) {
  return g4(this, e, !1);
};
kr.listenerCount = function(t, e) {
  return typeof t.listenerCount == "function" ? t.listenerCount(e) : m4.call(t, e);
};
kr.prototype.listenerCount = m4;
function m4(t) {
  var e = this._events;
  if (e !== void 0) {
    var r = e[t];
    if (typeof r == "function")
      return 1;
    if (r !== void 0)
      return r.length;
  }
  return 0;
}
kr.prototype.eventNames = function() {
  return this._eventsCount > 0 ? xd(this._events) : [];
};
function v4(t, e) {
  for (var r = new Array(e), n = 0; n < e; ++n)
    r[n] = t[n];
  return r;
}
function cL(t, e) {
  for (; e + 1 < t.length; e++)
    t[e] = t[e + 1];
  t.pop();
}
function uL(t) {
  for (var e = new Array(t.length), r = 0; r < e.length; ++r)
    e[r] = t[r].listener || t[r];
  return e;
}
function fL(t, e) {
  return new Promise(function(r, n) {
    function i(o) {
      t.removeListener(e, s), n(o);
    }
    function s() {
      typeof t.removeListener == "function" && t.removeListener("error", i), r([].slice.call(arguments));
    }
    b4(t, e, s, { once: !0 }), e !== "error" && lL(t, i, { once: !0 });
  });
}
function lL(t, e, r) {
  typeof t.on == "function" && b4(t, "error", e, r);
}
function b4(t, e, r, n) {
  if (typeof t.on == "function")
    n.once ? t.once(e, r) : t.on(e, r);
  else if (typeof t.addEventListener == "function")
    t.addEventListener(e, function i(s) {
      n.once && t.removeEventListener(e, i), r(s);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
}
var ns = Lv.exports;
const kv = /* @__PURE__ */ rs(ns);
var mt = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var c1 = function(t, e) {
  return c1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var i in n) n.hasOwnProperty(i) && (r[i] = n[i]);
  }, c1(t, e);
};
function hL(t, e) {
  c1(t, e);
  function r() {
    this.constructor = t;
  }
  t.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
}
var u1 = function() {
  return u1 = Object.assign || function(e) {
    for (var r, n = 1, i = arguments.length; n < i; n++) {
      r = arguments[n];
      for (var s in r) Object.prototype.hasOwnProperty.call(r, s) && (e[s] = r[s]);
    }
    return e;
  }, u1.apply(this, arguments);
};
function dL(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
  return r;
}
function pL(t, e, r, n) {
  var i = arguments.length, s = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, r) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") s = Reflect.decorate(t, e, r, n);
  else for (var a = t.length - 1; a >= 0; a--) (o = t[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, r, s) : o(e, r)) || s);
  return i > 3 && s && Object.defineProperty(e, r, s), s;
}
function gL(t, e) {
  return function(r, n) {
    e(r, n, t);
  };
}
function mL(t, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(t, e);
}
function vL(t, e, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function a(d) {
      try {
        l(n.next(d));
      } catch (p) {
        o(p);
      }
    }
    function u(d) {
      try {
        l(n.throw(d));
      } catch (p) {
        o(p);
      }
    }
    function l(d) {
      d.done ? s(d.value) : i(d.value).then(a, u);
    }
    l((n = n.apply(t, e || [])).next());
  });
}
function bL(t, e) {
  var r = { label: 0, sent: function() {
    if (s[0] & 1) throw s[1];
    return s[1];
  }, trys: [], ops: [] }, n, i, s, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(l) {
    return function(d) {
      return u([l, d]);
    };
  }
  function u(l) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; r; ) try {
      if (n = 1, i && (s = l[0] & 2 ? i.return : l[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, l[1])).done) return s;
      switch (i = 0, s && (l = [l[0] & 2, s.value]), l[0]) {
        case 0:
        case 1:
          s = l;
          break;
        case 4:
          return r.label++, { value: l[1], done: !1 };
        case 5:
          r.label++, i = l[1], l = [0];
          continue;
        case 7:
          l = r.ops.pop(), r.trys.pop();
          continue;
        default:
          if (s = r.trys, !(s = s.length > 0 && s[s.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            r = 0;
            continue;
          }
          if (l[0] === 3 && (!s || l[1] > s[0] && l[1] < s[3])) {
            r.label = l[1];
            break;
          }
          if (l[0] === 6 && r.label < s[1]) {
            r.label = s[1], s = l;
            break;
          }
          if (s && r.label < s[2]) {
            r.label = s[2], r.ops.push(l);
            break;
          }
          s[2] && r.ops.pop(), r.trys.pop();
          continue;
      }
      l = e.call(t, r);
    } catch (d) {
      l = [6, d], i = 0;
    } finally {
      n = s = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function yL(t, e, r, n) {
  n === void 0 && (n = r), t[n] = e[r];
}
function wL(t, e) {
  for (var r in t) r !== "default" && !e.hasOwnProperty(r) && (e[r] = t[r]);
}
function f1(t) {
  var e = typeof Symbol == "function" && Symbol.iterator, r = e && t[e], n = 0;
  if (r) return r.call(t);
  if (t && typeof t.length == "number") return {
    next: function() {
      return t && n >= t.length && (t = void 0), { value: t && t[n++], done: !t };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function y4(t, e) {
  var r = typeof Symbol == "function" && t[Symbol.iterator];
  if (!r) return t;
  var n = r.call(t), i, s = [], o;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = n.next()).done; ) s.push(i.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      i && !i.done && (r = n.return) && r.call(n);
    } finally {
      if (o) throw o.error;
    }
  }
  return s;
}
function xL() {
  for (var t = [], e = 0; e < arguments.length; e++)
    t = t.concat(y4(arguments[e]));
  return t;
}
function _L() {
  for (var t = 0, e = 0, r = arguments.length; e < r; e++) t += arguments[e].length;
  for (var n = Array(t), i = 0, e = 0; e < r; e++)
    for (var s = arguments[e], o = 0, a = s.length; o < a; o++, i++)
      n[i] = s[o];
  return n;
}
function bl(t) {
  return this instanceof bl ? (this.v = t, this) : new bl(t);
}
function EL(t, e, r) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = r.apply(t, e || []), i, s = [];
  return i = {}, o("next"), o("throw"), o("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function o(w) {
    n[w] && (i[w] = function(A) {
      return new Promise(function(P, N) {
        s.push([w, A, P, N]) > 1 || a(w, A);
      });
    });
  }
  function a(w, A) {
    try {
      u(n[w](A));
    } catch (P) {
      p(s[0][3], P);
    }
  }
  function u(w) {
    w.value instanceof bl ? Promise.resolve(w.value.v).then(l, d) : p(s[0][2], w);
  }
  function l(w) {
    a("next", w);
  }
  function d(w) {
    a("throw", w);
  }
  function p(w, A) {
    w(A), s.shift(), s.length && a(s[0][0], s[0][1]);
  }
}
function SL(t) {
  var e, r;
  return e = {}, n("next"), n("throw", function(i) {
    throw i;
  }), n("return"), e[Symbol.iterator] = function() {
    return this;
  }, e;
  function n(i, s) {
    e[i] = t[i] ? function(o) {
      return (r = !r) ? { value: bl(t[i](o)), done: i === "return" } : s ? s(o) : o;
    } : s;
  }
}
function AL(t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = t[Symbol.asyncIterator], r;
  return e ? e.call(t) : (t = typeof f1 == "function" ? f1(t) : t[Symbol.iterator](), r = {}, n("next"), n("throw"), n("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function n(s) {
    r[s] = t[s] && function(o) {
      return new Promise(function(a, u) {
        o = t[s](o), i(a, u, o.done, o.value);
      });
    };
  }
  function i(s, o, a, u) {
    Promise.resolve(u).then(function(l) {
      s({ value: l, done: a });
    }, o);
  }
}
function PL(t, e) {
  return Object.defineProperty ? Object.defineProperty(t, "raw", { value: e }) : t.raw = e, t;
}
function ML(t) {
  if (t && t.__esModule) return t;
  var e = {};
  if (t != null) for (var r in t) Object.hasOwnProperty.call(t, r) && (e[r] = t[r]);
  return e.default = t, e;
}
function IL(t) {
  return t && t.__esModule ? t : { default: t };
}
function CL(t, e) {
  if (!e.has(t))
    throw new TypeError("attempted to get private field on non-instance");
  return e.get(t);
}
function TL(t, e, r) {
  if (!e.has(t))
    throw new TypeError("attempted to set private field on non-instance");
  return e.set(t, r), r;
}
const RL = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return u1;
  },
  __asyncDelegator: SL,
  __asyncGenerator: EL,
  __asyncValues: AL,
  __await: bl,
  __awaiter: vL,
  __classPrivateFieldGet: CL,
  __classPrivateFieldSet: TL,
  __createBinding: yL,
  __decorate: pL,
  __exportStar: wL,
  __extends: hL,
  __generator: bL,
  __importDefault: IL,
  __importStar: ML,
  __makeTemplateObject: PL,
  __metadata: mL,
  __param: gL,
  __read: y4,
  __rest: dL,
  __spread: xL,
  __spreadArrays: _L,
  __values: f1
}, Symbol.toStringTag, { value: "Module" })), jl = /* @__PURE__ */ bv(RL);
var Wg = {}, wf = {}, $2;
function DL() {
  if ($2) return wf;
  $2 = 1, Object.defineProperty(wf, "__esModule", { value: !0 }), wf.delay = void 0;
  function t(e) {
    return new Promise((r) => {
      setTimeout(() => {
        r(!0);
      }, e);
    });
  }
  return wf.delay = t, wf;
}
var Wa = {}, Hg = {}, Ha = {}, B2;
function OL() {
  return B2 || (B2 = 1, Object.defineProperty(Ha, "__esModule", { value: !0 }), Ha.ONE_THOUSAND = Ha.ONE_HUNDRED = void 0, Ha.ONE_HUNDRED = 100, Ha.ONE_THOUSAND = 1e3), Ha;
}
var Kg = {}, F2;
function NL() {
  return F2 || (F2 = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ONE_YEAR = t.FOUR_WEEKS = t.THREE_WEEKS = t.TWO_WEEKS = t.ONE_WEEK = t.THIRTY_DAYS = t.SEVEN_DAYS = t.FIVE_DAYS = t.THREE_DAYS = t.ONE_DAY = t.TWENTY_FOUR_HOURS = t.TWELVE_HOURS = t.SIX_HOURS = t.THREE_HOURS = t.ONE_HOUR = t.SIXTY_MINUTES = t.THIRTY_MINUTES = t.TEN_MINUTES = t.FIVE_MINUTES = t.ONE_MINUTE = t.SIXTY_SECONDS = t.THIRTY_SECONDS = t.TEN_SECONDS = t.FIVE_SECONDS = t.ONE_SECOND = void 0, t.ONE_SECOND = 1, t.FIVE_SECONDS = 5, t.TEN_SECONDS = 10, t.THIRTY_SECONDS = 30, t.SIXTY_SECONDS = 60, t.ONE_MINUTE = t.SIXTY_SECONDS, t.FIVE_MINUTES = t.ONE_MINUTE * 5, t.TEN_MINUTES = t.ONE_MINUTE * 10, t.THIRTY_MINUTES = t.ONE_MINUTE * 30, t.SIXTY_MINUTES = t.ONE_MINUTE * 60, t.ONE_HOUR = t.SIXTY_MINUTES, t.THREE_HOURS = t.ONE_HOUR * 3, t.SIX_HOURS = t.ONE_HOUR * 6, t.TWELVE_HOURS = t.ONE_HOUR * 12, t.TWENTY_FOUR_HOURS = t.ONE_HOUR * 24, t.ONE_DAY = t.TWENTY_FOUR_HOURS, t.THREE_DAYS = t.ONE_DAY * 3, t.FIVE_DAYS = t.ONE_DAY * 5, t.SEVEN_DAYS = t.ONE_DAY * 7, t.THIRTY_DAYS = t.ONE_DAY * 30, t.ONE_WEEK = t.SEVEN_DAYS, t.TWO_WEEKS = t.ONE_WEEK * 2, t.THREE_WEEKS = t.ONE_WEEK * 3, t.FOUR_WEEKS = t.ONE_WEEK * 4, t.ONE_YEAR = t.ONE_DAY * 365;
  }(Kg)), Kg;
}
var j2;
function w4() {
  return j2 || (j2 = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const e = jl;
    e.__exportStar(OL(), t), e.__exportStar(NL(), t);
  }(Hg)), Hg;
}
var U2;
function LL() {
  if (U2) return Wa;
  U2 = 1, Object.defineProperty(Wa, "__esModule", { value: !0 }), Wa.fromMiliseconds = Wa.toMiliseconds = void 0;
  const t = w4();
  function e(n) {
    return n * t.ONE_THOUSAND;
  }
  Wa.toMiliseconds = e;
  function r(n) {
    return Math.floor(n / t.ONE_THOUSAND);
  }
  return Wa.fromMiliseconds = r, Wa;
}
var q2;
function kL() {
  return q2 || (q2 = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    const e = jl;
    e.__exportStar(DL(), t), e.__exportStar(LL(), t);
  }(Wg)), Wg;
}
var zc = {}, z2;
function $L() {
  if (z2) return zc;
  z2 = 1, Object.defineProperty(zc, "__esModule", { value: !0 }), zc.Watch = void 0;
  class t {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(r) {
      if (this.timestamps.has(r))
        throw new Error(`Watch already started for label: ${r}`);
      this.timestamps.set(r, { started: Date.now() });
    }
    stop(r) {
      const n = this.get(r);
      if (typeof n.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${r}`);
      const i = Date.now() - n.started;
      this.timestamps.set(r, { started: n.started, elapsed: i });
    }
    get(r) {
      const n = this.timestamps.get(r);
      if (typeof n > "u")
        throw new Error(`No timestamp found for label: ${r}`);
      return n;
    }
    elapsed(r) {
      const n = this.get(r);
      return n.elapsed || Date.now() - n.started;
    }
  }
  return zc.Watch = t, zc.default = t, zc;
}
var Vg = {}, xf = {}, W2;
function BL() {
  if (W2) return xf;
  W2 = 1, Object.defineProperty(xf, "__esModule", { value: !0 }), xf.IWatch = void 0;
  class t {
  }
  return xf.IWatch = t, xf;
}
var H2;
function FL() {
  return H2 || (H2 = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), jl.__exportStar(BL(), t);
  }(Vg)), Vg;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = jl;
  e.__exportStar(kL(), t), e.__exportStar($L(), t), e.__exportStar(FL(), t), e.__exportStar(w4(), t);
})(mt);
class vc {
}
let jL = class extends vc {
  constructor(e) {
    super();
  }
};
const K2 = mt.FIVE_SECONDS, Ou = { pulse: "heartbeat_pulse" };
let UL = class x4 extends jL {
  constructor(e) {
    super(e), this.events = new ns.EventEmitter(), this.interval = K2, this.interval = (e == null ? void 0 : e.interval) || K2;
  }
  static async init(e) {
    const r = new x4(e);
    return await r.init(), r;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), mt.toMiliseconds(this.interval));
  }
  pulse() {
    this.events.emit(Ou.pulse);
  }
};
const qL = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/, zL = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/, WL = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function HL(t, e) {
  if (t === "__proto__" || t === "constructor" && e && typeof e == "object" && "prototype" in e) {
    KL(t);
    return;
  }
  return e;
}
function KL(t) {
  console.warn(`[destr] Dropping "${t}" key to prevent prototype pollution.`);
}
function od(t, e = {}) {
  if (typeof t != "string")
    return t;
  const r = t.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    t[0] === '"' && t.endsWith('"') && !t.includes("\\")
  )
    return r.slice(1, -1);
  if (r.length <= 9) {
    const n = r.toLowerCase();
    if (n === "true")
      return !0;
    if (n === "false")
      return !1;
    if (n === "undefined")
      return;
    if (n === "null")
      return null;
    if (n === "nan")
      return Number.NaN;
    if (n === "infinity")
      return Number.POSITIVE_INFINITY;
    if (n === "-infinity")
      return Number.NEGATIVE_INFINITY;
  }
  if (!WL.test(t)) {
    if (e.strict)
      throw new SyntaxError("[destr] Invalid JSON");
    return t;
  }
  try {
    if (qL.test(t) || zL.test(t)) {
      if (e.strict)
        throw new Error("[destr] Possible prototype pollution");
      return JSON.parse(t, HL);
    }
    return JSON.parse(t);
  } catch (n) {
    if (e.strict)
      throw n;
    return t;
  }
}
function VL(t) {
  return !t || typeof t.then != "function" ? Promise.resolve(t) : t;
}
function Cn(t, ...e) {
  try {
    return VL(t(...e));
  } catch (r) {
    return Promise.reject(r);
  }
}
function GL(t) {
  const e = typeof t;
  return t === null || e !== "object" && e !== "function";
}
function YL(t) {
  const e = Object.getPrototypeOf(t);
  return !e || e.isPrototypeOf(Object);
}
function _d(t) {
  if (GL(t))
    return String(t);
  if (YL(t) || Array.isArray(t))
    return JSON.stringify(t);
  if (typeof t.toJSON == "function")
    return _d(t.toJSON());
  throw new Error("[unstorage] Cannot stringify value!");
}
function _4() {
  if (typeof Buffer > "u")
    throw new TypeError("[unstorage] Buffer is not supported!");
}
const l1 = "base64:";
function JL(t) {
  if (typeof t == "string")
    return t;
  _4();
  const e = Buffer.from(t).toString("base64");
  return l1 + e;
}
function XL(t) {
  return typeof t != "string" || !t.startsWith(l1) ? t : (_4(), Buffer.from(t.slice(l1.length), "base64"));
}
function pi(t) {
  return t ? t.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") : "";
}
function ZL(...t) {
  return pi(t.join(":"));
}
function ad(t) {
  return t = pi(t), t ? t + ":" : "";
}
const QL = "memory", ek = () => {
  const t = /* @__PURE__ */ new Map();
  return {
    name: QL,
    getInstance: () => t,
    hasItem(e) {
      return t.has(e);
    },
    getItem(e) {
      return t.get(e) ?? null;
    },
    getItemRaw(e) {
      return t.get(e) ?? null;
    },
    setItem(e, r) {
      t.set(e, r);
    },
    setItemRaw(e, r) {
      t.set(e, r);
    },
    removeItem(e) {
      t.delete(e);
    },
    getKeys() {
      return [...t.keys()];
    },
    clear() {
      t.clear();
    },
    dispose() {
      t.clear();
    }
  };
};
function tk(t = {}) {
  const e = {
    mounts: { "": t.driver || ek() },
    mountpoints: [""],
    watching: !1,
    watchListeners: [],
    unwatch: {}
  }, r = (l) => {
    for (const d of e.mountpoints)
      if (l.startsWith(d))
        return {
          base: d,
          relativeKey: l.slice(d.length),
          driver: e.mounts[d]
        };
    return {
      base: "",
      relativeKey: l,
      driver: e.mounts[""]
    };
  }, n = (l, d) => e.mountpoints.filter(
    (p) => p.startsWith(l) || d && l.startsWith(p)
  ).map((p) => ({
    relativeBase: l.length > p.length ? l.slice(p.length) : void 0,
    mountpoint: p,
    driver: e.mounts[p]
  })), i = (l, d) => {
    if (e.watching) {
      d = pi(d);
      for (const p of e.watchListeners)
        p(l, d);
    }
  }, s = async () => {
    if (!e.watching) {
      e.watching = !0;
      for (const l in e.mounts)
        e.unwatch[l] = await V2(
          e.mounts[l],
          i,
          l
        );
    }
  }, o = async () => {
    if (e.watching) {
      for (const l in e.unwatch)
        await e.unwatch[l]();
      e.unwatch = {}, e.watching = !1;
    }
  }, a = (l, d, p) => {
    const w = /* @__PURE__ */ new Map(), A = (P) => {
      let N = w.get(P.base);
      return N || (N = {
        driver: P.driver,
        base: P.base,
        items: []
      }, w.set(P.base, N)), N;
    };
    for (const P of l) {
      const N = typeof P == "string", L = pi(N ? P : P.key), $ = N ? void 0 : P.value, B = N || !P.options ? d : { ...d, ...P.options }, H = r(L);
      A(H).items.push({
        key: L,
        value: $,
        relativeKey: H.relativeKey,
        options: B
      });
    }
    return Promise.all([...w.values()].map((P) => p(P))).then(
      (P) => P.flat()
    );
  }, u = {
    // Item
    hasItem(l, d = {}) {
      l = pi(l);
      const { relativeKey: p, driver: w } = r(l);
      return Cn(w.hasItem, p, d);
    },
    getItem(l, d = {}) {
      l = pi(l);
      const { relativeKey: p, driver: w } = r(l);
      return Cn(w.getItem, p, d).then(
        (A) => od(A)
      );
    },
    getItems(l, d) {
      return a(l, d, (p) => p.driver.getItems ? Cn(
        p.driver.getItems,
        p.items.map((w) => ({
          key: w.relativeKey,
          options: w.options
        })),
        d
      ).then(
        (w) => w.map((A) => ({
          key: ZL(p.base, A.key),
          value: od(A.value)
        }))
      ) : Promise.all(
        p.items.map((w) => Cn(
          p.driver.getItem,
          w.relativeKey,
          w.options
        ).then((A) => ({
          key: w.key,
          value: od(A)
        })))
      ));
    },
    getItemRaw(l, d = {}) {
      l = pi(l);
      const { relativeKey: p, driver: w } = r(l);
      return w.getItemRaw ? Cn(w.getItemRaw, p, d) : Cn(w.getItem, p, d).then(
        (A) => XL(A)
      );
    },
    async setItem(l, d, p = {}) {
      if (d === void 0)
        return u.removeItem(l);
      l = pi(l);
      const { relativeKey: w, driver: A } = r(l);
      A.setItem && (await Cn(A.setItem, w, _d(d), p), A.watch || i("update", l));
    },
    async setItems(l, d) {
      await a(l, d, async (p) => {
        if (p.driver.setItems)
          return Cn(
            p.driver.setItems,
            p.items.map((w) => ({
              key: w.relativeKey,
              value: _d(w.value),
              options: w.options
            })),
            d
          );
        p.driver.setItem && await Promise.all(
          p.items.map((w) => Cn(
            p.driver.setItem,
            w.relativeKey,
            _d(w.value),
            w.options
          ))
        );
      });
    },
    async setItemRaw(l, d, p = {}) {
      if (d === void 0)
        return u.removeItem(l, p);
      l = pi(l);
      const { relativeKey: w, driver: A } = r(l);
      if (A.setItemRaw)
        await Cn(A.setItemRaw, w, d, p);
      else if (A.setItem)
        await Cn(A.setItem, w, JL(d), p);
      else
        return;
      A.watch || i("update", l);
    },
    async removeItem(l, d = {}) {
      typeof d == "boolean" && (d = { removeMeta: d }), l = pi(l);
      const { relativeKey: p, driver: w } = r(l);
      w.removeItem && (await Cn(w.removeItem, p, d), (d.removeMeta || d.removeMata) && await Cn(w.removeItem, p + "$", d), w.watch || i("remove", l));
    },
    // Meta
    async getMeta(l, d = {}) {
      typeof d == "boolean" && (d = { nativeOnly: d }), l = pi(l);
      const { relativeKey: p, driver: w } = r(l), A = /* @__PURE__ */ Object.create(null);
      if (w.getMeta && Object.assign(A, await Cn(w.getMeta, p, d)), !d.nativeOnly) {
        const P = await Cn(
          w.getItem,
          p + "$",
          d
        ).then((N) => od(N));
        P && typeof P == "object" && (typeof P.atime == "string" && (P.atime = new Date(P.atime)), typeof P.mtime == "string" && (P.mtime = new Date(P.mtime)), Object.assign(A, P));
      }
      return A;
    },
    setMeta(l, d, p = {}) {
      return this.setItem(l + "$", d, p);
    },
    removeMeta(l, d = {}) {
      return this.removeItem(l + "$", d);
    },
    // Keys
    async getKeys(l, d = {}) {
      l = ad(l);
      const p = n(l, !0);
      let w = [];
      const A = [];
      for (const P of p) {
        const N = await Cn(
          P.driver.getKeys,
          P.relativeBase,
          d
        );
        for (const L of N) {
          const $ = P.mountpoint + pi(L);
          w.some((B) => $.startsWith(B)) || A.push($);
        }
        w = [
          P.mountpoint,
          ...w.filter((L) => !L.startsWith(P.mountpoint))
        ];
      }
      return l ? A.filter(
        (P) => P.startsWith(l) && P[P.length - 1] !== "$"
      ) : A.filter((P) => P[P.length - 1] !== "$");
    },
    // Utils
    async clear(l, d = {}) {
      l = ad(l), await Promise.all(
        n(l, !1).map(async (p) => {
          if (p.driver.clear)
            return Cn(p.driver.clear, p.relativeBase, d);
          if (p.driver.removeItem) {
            const w = await p.driver.getKeys(p.relativeBase || "", d);
            return Promise.all(
              w.map((A) => p.driver.removeItem(A, d))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(e.mounts).map((l) => G2(l))
      );
    },
    async watch(l) {
      return await s(), e.watchListeners.push(l), async () => {
        e.watchListeners = e.watchListeners.filter(
          (d) => d !== l
        ), e.watchListeners.length === 0 && await o();
      };
    },
    async unwatch() {
      e.watchListeners = [], await o();
    },
    // Mount
    mount(l, d) {
      if (l = ad(l), l && e.mounts[l])
        throw new Error(`already mounted at ${l}`);
      return l && (e.mountpoints.push(l), e.mountpoints.sort((p, w) => w.length - p.length)), e.mounts[l] = d, e.watching && Promise.resolve(V2(d, i, l)).then((p) => {
        e.unwatch[l] = p;
      }).catch(console.error), u;
    },
    async unmount(l, d = !0) {
      l = ad(l), !(!l || !e.mounts[l]) && (e.watching && l in e.unwatch && (e.unwatch[l](), delete e.unwatch[l]), d && await G2(e.mounts[l]), e.mountpoints = e.mountpoints.filter((p) => p !== l), delete e.mounts[l]);
    },
    getMount(l = "") {
      l = pi(l) + ":";
      const d = r(l);
      return {
        driver: d.driver,
        base: d.base
      };
    },
    getMounts(l = "", d = {}) {
      return l = pi(l), n(l, d.parents).map((w) => ({
        driver: w.driver,
        base: w.mountpoint
      }));
    },
    // Aliases
    keys: (l, d = {}) => u.getKeys(l, d),
    get: (l, d = {}) => u.getItem(l, d),
    set: (l, d, p = {}) => u.setItem(l, d, p),
    has: (l, d = {}) => u.hasItem(l, d),
    del: (l, d = {}) => u.removeItem(l, d),
    remove: (l, d = {}) => u.removeItem(l, d)
  };
  return u;
}
function V2(t, e, r) {
  return t.watch ? t.watch((n, i) => e(n, r + i)) : () => {
  };
}
async function G2(t) {
  typeof t.dispose == "function" && await Cn(t.dispose);
}
function bc(t) {
  return new Promise((e, r) => {
    t.oncomplete = t.onsuccess = () => e(t.result), t.onabort = t.onerror = () => r(t.error);
  });
}
function E4(t, e) {
  const r = indexedDB.open(t);
  r.onupgradeneeded = () => r.result.createObjectStore(e);
  const n = bc(r);
  return (i, s) => n.then((o) => s(o.transaction(e, i).objectStore(e)));
}
let Gg;
function Ul() {
  return Gg || (Gg = E4("keyval-store", "keyval")), Gg;
}
function Y2(t, e = Ul()) {
  return e("readonly", (r) => bc(r.get(t)));
}
function rk(t, e, r = Ul()) {
  return r("readwrite", (n) => (n.put(e, t), bc(n.transaction)));
}
function nk(t, e = Ul()) {
  return e("readwrite", (r) => (r.delete(t), bc(r.transaction)));
}
function ik(t = Ul()) {
  return t("readwrite", (e) => (e.clear(), bc(e.transaction)));
}
function sk(t, e) {
  return t.openCursor().onsuccess = function() {
    this.result && (e(this.result), this.result.continue());
  }, bc(t.transaction);
}
function ok(t = Ul()) {
  return t("readonly", (e) => {
    if (e.getAllKeys)
      return bc(e.getAllKeys());
    const r = [];
    return sk(e, (n) => r.push(n.key)).then(() => r);
  });
}
const ak = (t) => JSON.stringify(t, (e, r) => typeof r == "bigint" ? r.toString() + "n" : r), ck = (t) => {
  const e = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g, r = t.replace(e, '$1"$2n"$3');
  return JSON.parse(r, (n, i) => typeof i == "string" && i.match(/^\d+n$/) ? BigInt(i.substring(0, i.length - 1)) : i);
};
function lc(t) {
  if (typeof t != "string")
    throw new Error(`Cannot safe json parse value of type ${typeof t}`);
  try {
    return ck(t);
  } catch {
    return t;
  }
}
function Bo(t) {
  return typeof t == "string" ? t : ak(t) || "";
}
const uk = "idb-keyval";
var fk = (t = {}) => {
  const e = t.base && t.base.length > 0 ? `${t.base}:` : "", r = (i) => e + i;
  let n;
  return t.dbName && t.storeName && (n = E4(t.dbName, t.storeName)), { name: uk, options: t, async hasItem(i) {
    return !(typeof await Y2(r(i), n) > "u");
  }, async getItem(i) {
    return await Y2(r(i), n) ?? null;
  }, setItem(i, s) {
    return rk(r(i), s, n);
  }, removeItem(i) {
    return nk(r(i), n);
  }, getKeys() {
    return ok(n);
  }, clear() {
    return ik(n);
  } };
};
const lk = "WALLET_CONNECT_V2_INDEXED_DB", hk = "keyvaluestorage";
let dk = class {
  constructor() {
    this.indexedDb = tk({ driver: fk({ dbName: lk, storeName: hk }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((e) => [e.key, e.value]);
  }
  async getItem(e) {
    const r = await this.indexedDb.getItem(e);
    if (r !== null) return r;
  }
  async setItem(e, r) {
    await this.indexedDb.setItem(e, Bo(r));
  }
  async removeItem(e) {
    await this.indexedDb.removeItem(e);
  }
};
var Yg = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Ed = { exports: {} };
(function() {
  let t;
  function e() {
  }
  t = e, t.prototype.getItem = function(r) {
    return this.hasOwnProperty(r) ? String(this[r]) : null;
  }, t.prototype.setItem = function(r, n) {
    this[r] = String(n);
  }, t.prototype.removeItem = function(r) {
    delete this[r];
  }, t.prototype.clear = function() {
    const r = this;
    Object.keys(r).forEach(function(n) {
      r[n] = void 0, delete r[n];
    });
  }, t.prototype.key = function(r) {
    return r = r || 0, Object.keys(this)[r];
  }, t.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof Yg < "u" && Yg.localStorage ? Ed.exports = Yg.localStorage : typeof window < "u" && window.localStorage ? Ed.exports = window.localStorage : Ed.exports = new e();
})();
function pk(t) {
  var e;
  return [t[0], lc((e = t[1]) != null ? e : "")];
}
let gk = class {
  constructor() {
    this.localStorage = Ed.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(pk);
  }
  async getItem(e) {
    const r = this.localStorage.getItem(e);
    if (r !== null) return lc(r);
  }
  async setItem(e, r) {
    this.localStorage.setItem(e, Bo(r));
  }
  async removeItem(e) {
    this.localStorage.removeItem(e);
  }
};
const mk = "wc_storage_version", J2 = 1, vk = async (t, e, r) => {
  const n = mk, i = await e.getItem(n);
  if (i && i >= J2) {
    r(e);
    return;
  }
  const s = await t.getKeys();
  if (!s.length) {
    r(e);
    return;
  }
  const o = [];
  for (; s.length; ) {
    const a = s.shift();
    if (!a) continue;
    const u = a.toLowerCase();
    if (u.includes("wc@") || u.includes("walletconnect") || u.includes("wc_") || u.includes("wallet_connect")) {
      const l = await t.getItem(a);
      await e.setItem(a, l), o.push(a);
    }
  }
  await e.setItem(n, J2), r(e), bk(t, o);
}, bk = async (t, e) => {
  e.length && e.forEach(async (r) => {
    await t.removeItem(r);
  });
};
let yk = class {
  constructor() {
    this.initialized = !1, this.setInitialized = (r) => {
      this.storage = r, this.initialized = !0;
    };
    const e = new gk();
    this.storage = e;
    try {
      const r = new dk();
      vk(e, r, this.setInitialized);
    } catch {
      this.initialized = !0;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(e) {
    return await this.initialize(), this.storage.getItem(e);
  }
  async setItem(e, r) {
    return await this.initialize(), this.storage.setItem(e, r);
  }
  async removeItem(e) {
    return await this.initialize(), this.storage.removeItem(e);
  }
  async initialize() {
    this.initialized || await new Promise((e) => {
      const r = setInterval(() => {
        this.initialized && (clearInterval(r), e());
      }, 20);
    });
  }
};
function wk(t) {
  try {
    return JSON.stringify(t);
  } catch {
    return '"[Circular]"';
  }
}
var xk = _k;
function _k(t, e, r) {
  var n = r && r.stringify || wk, i = 1;
  if (typeof t == "object" && t !== null) {
    var s = e.length + i;
    if (s === 1) return t;
    var o = new Array(s);
    o[0] = n(t);
    for (var a = 1; a < s; a++)
      o[a] = n(e[a]);
    return o.join(" ");
  }
  if (typeof t != "string")
    return t;
  var u = e.length;
  if (u === 0) return t;
  for (var l = "", d = 1 - i, p = -1, w = t && t.length || 0, A = 0; A < w; ) {
    if (t.charCodeAt(A) === 37 && A + 1 < w) {
      switch (p = p > -1 ? p : 0, t.charCodeAt(A + 1)) {
        case 100:
        case 102:
          if (d >= u || e[d] == null) break;
          p < A && (l += t.slice(p, A)), l += Number(e[d]), p = A + 2, A++;
          break;
        case 105:
          if (d >= u || e[d] == null) break;
          p < A && (l += t.slice(p, A)), l += Math.floor(Number(e[d])), p = A + 2, A++;
          break;
        case 79:
        case 111:
        case 106:
          if (d >= u || e[d] === void 0) break;
          p < A && (l += t.slice(p, A));
          var P = typeof e[d];
          if (P === "string") {
            l += "'" + e[d] + "'", p = A + 2, A++;
            break;
          }
          if (P === "function") {
            l += e[d].name || "<anonymous>", p = A + 2, A++;
            break;
          }
          l += n(e[d]), p = A + 2, A++;
          break;
        case 115:
          if (d >= u)
            break;
          p < A && (l += t.slice(p, A)), l += String(e[d]), p = A + 2, A++;
          break;
        case 37:
          p < A && (l += t.slice(p, A)), l += "%", p = A + 2, A++, d--;
          break;
      }
      ++d;
    }
    ++A;
  }
  return p === -1 ? t : (p < w && (l += t.slice(p)), l);
}
const X2 = xk;
var Jc = Fo;
const yl = Dk().console || {}, Ek = {
  mapHttpRequest: cd,
  mapHttpResponse: cd,
  wrapRequestSerializer: Jg,
  wrapResponseSerializer: Jg,
  wrapErrorSerializer: Jg,
  req: cd,
  res: cd,
  err: Ik
};
function Sk(t, e) {
  return Array.isArray(t) ? t.filter(function(n) {
    return n !== "!stdSerializers.err";
  }) : t === !0 ? Object.keys(e) : !1;
}
function Fo(t) {
  t = t || {}, t.browser = t.browser || {};
  const e = t.browser.transmit;
  if (e && typeof e.send != "function")
    throw Error("pino: transmit option must have a send function");
  const r = t.browser.write || yl;
  t.browser.write && (t.browser.asObject = !0);
  const n = t.serializers || {}, i = Sk(t.browser.serialize, n);
  let s = t.browser.serialize;
  Array.isArray(t.browser.serialize) && t.browser.serialize.indexOf("!stdSerializers.err") > -1 && (s = !1);
  const o = ["error", "fatal", "warn", "info", "debug", "trace"];
  typeof r == "function" && (r.error = r.fatal = r.warn = r.info = r.debug = r.trace = r), t.enabled === !1 && (t.level = "silent");
  const a = t.level || "info", u = Object.create(r);
  u.log || (u.log = wl), Object.defineProperty(u, "levelVal", {
    get: d
  }), Object.defineProperty(u, "level", {
    get: p,
    set: w
  });
  const l = {
    transmit: e,
    serialize: i,
    asObject: t.browser.asObject,
    levels: o,
    timestamp: Ck(t)
  };
  u.levels = Fo.levels, u.level = a, u.setMaxListeners = u.getMaxListeners = u.emit = u.addListener = u.on = u.prependListener = u.once = u.prependOnceListener = u.removeListener = u.removeAllListeners = u.listeners = u.listenerCount = u.eventNames = u.write = u.flush = wl, u.serializers = n, u._serialize = i, u._stdErrSerialize = s, u.child = A, e && (u._logEvent = h1());
  function d() {
    return this.level === "silent" ? 1 / 0 : this.levels.values[this.level];
  }
  function p() {
    return this._level;
  }
  function w(P) {
    if (P !== "silent" && !this.levels.values[P])
      throw Error("unknown level " + P);
    this._level = P, Wc(l, u, "error", "log"), Wc(l, u, "fatal", "error"), Wc(l, u, "warn", "error"), Wc(l, u, "info", "log"), Wc(l, u, "debug", "log"), Wc(l, u, "trace", "log");
  }
  function A(P, N) {
    if (!P)
      throw new Error("missing bindings for child Pino");
    N = N || {}, i && P.serializers && (N.serializers = P.serializers);
    const L = N.serializers;
    if (i && L) {
      var $ = Object.assign({}, n, L), B = t.browser.serialize === !0 ? Object.keys($) : i;
      delete P.serializers, k0([P], B, $, this._stdErrSerialize);
    }
    function H(W) {
      this._childLevel = (W._childLevel | 0) + 1, this.error = Hc(W, P, "error"), this.fatal = Hc(W, P, "fatal"), this.warn = Hc(W, P, "warn"), this.info = Hc(W, P, "info"), this.debug = Hc(W, P, "debug"), this.trace = Hc(W, P, "trace"), $ && (this.serializers = $, this._serialize = B), e && (this._logEvent = h1(
        [].concat(W._logEvent.bindings, P)
      ));
    }
    return H.prototype = this, new H(this);
  }
  return u;
}
Fo.levels = {
  values: {
    fatal: 60,
    error: 50,
    warn: 40,
    info: 30,
    debug: 20,
    trace: 10
  },
  labels: {
    10: "trace",
    20: "debug",
    30: "info",
    40: "warn",
    50: "error",
    60: "fatal"
  }
};
Fo.stdSerializers = Ek;
Fo.stdTimeFunctions = Object.assign({}, { nullTime: S4, epochTime: A4, unixTime: Tk, isoTime: Rk });
function Wc(t, e, r, n) {
  const i = Object.getPrototypeOf(e);
  e[r] = e.levelVal > e.levels.values[r] ? wl : i[r] ? i[r] : yl[r] || yl[n] || wl, Ak(t, e, r);
}
function Ak(t, e, r) {
  !t.transmit && e[r] === wl || (e[r] = /* @__PURE__ */ function(n) {
    return function() {
      const s = t.timestamp(), o = new Array(arguments.length), a = Object.getPrototypeOf && Object.getPrototypeOf(this) === yl ? yl : this;
      for (var u = 0; u < o.length; u++) o[u] = arguments[u];
      if (t.serialize && !t.asObject && k0(o, this._serialize, this.serializers, this._stdErrSerialize), t.asObject ? n.call(a, Pk(this, r, o, s)) : n.apply(a, o), t.transmit) {
        const l = t.transmit.level || e.level, d = Fo.levels.values[l], p = Fo.levels.values[r];
        if (p < d) return;
        Mk(this, {
          ts: s,
          methodLevel: r,
          methodValue: p,
          send: t.transmit.send,
          val: e.levelVal
        }, o);
      }
    };
  }(e[r]));
}
function Pk(t, e, r, n) {
  t._serialize && k0(r, t._serialize, t.serializers, t._stdErrSerialize);
  const i = r.slice();
  let s = i[0];
  const o = {};
  n && (o.time = n), o.level = Fo.levels.values[e];
  let a = (t._childLevel | 0) + 1;
  if (a < 1 && (a = 1), s !== null && typeof s == "object") {
    for (; a-- && typeof i[0] == "object"; )
      Object.assign(o, i.shift());
    s = i.length ? X2(i.shift(), i) : void 0;
  } else typeof s == "string" && (s = X2(i.shift(), i));
  return s !== void 0 && (o.msg = s), o;
}
function k0(t, e, r, n) {
  for (const i in t)
    if (n && t[i] instanceof Error)
      t[i] = Fo.stdSerializers.err(t[i]);
    else if (typeof t[i] == "object" && !Array.isArray(t[i]))
      for (const s in t[i])
        e && e.indexOf(s) > -1 && s in r && (t[i][s] = r[s](t[i][s]));
}
function Hc(t, e, r) {
  return function() {
    const n = new Array(1 + arguments.length);
    n[0] = e;
    for (var i = 1; i < n.length; i++)
      n[i] = arguments[i - 1];
    return t[r].apply(this, n);
  };
}
function Mk(t, e, r) {
  const n = e.send, i = e.ts, s = e.methodLevel, o = e.methodValue, a = e.val, u = t._logEvent.bindings;
  k0(
    r,
    t._serialize || Object.keys(t.serializers),
    t.serializers,
    t._stdErrSerialize === void 0 ? !0 : t._stdErrSerialize
  ), t._logEvent.ts = i, t._logEvent.messages = r.filter(function(l) {
    return u.indexOf(l) === -1;
  }), t._logEvent.level.label = s, t._logEvent.level.value = o, n(s, t._logEvent, a), t._logEvent = h1(u);
}
function h1(t) {
  return {
    ts: 0,
    messages: [],
    bindings: t || [],
    level: { label: "", value: 0 }
  };
}
function Ik(t) {
  const e = {
    type: t.constructor.name,
    msg: t.message,
    stack: t.stack
  };
  for (const r in t)
    e[r] === void 0 && (e[r] = t[r]);
  return e;
}
function Ck(t) {
  return typeof t.timestamp == "function" ? t.timestamp : t.timestamp === !1 ? S4 : A4;
}
function cd() {
  return {};
}
function Jg(t) {
  return t;
}
function wl() {
}
function S4() {
  return !1;
}
function A4() {
  return Date.now();
}
function Tk() {
  return Math.round(Date.now() / 1e3);
}
function Rk() {
  return new Date(Date.now()).toISOString();
}
function Dk() {
  function t(e) {
    return typeof e < "u" && e;
  }
  try {
    return typeof globalThis < "u" || Object.defineProperty(Object.prototype, "globalThis", {
      get: function() {
        return delete Object.prototype.globalThis, this.globalThis = this;
      },
      configurable: !0
    }), globalThis;
  } catch {
    return t(self) || t(window) || t(this) || {};
  }
}
const ql = /* @__PURE__ */ rs(Jc), Ok = { level: "info" }, zl = "custom_context", $v = 1e3 * 1024;
let Nk = class {
  constructor(e) {
    this.nodeValue = e, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
}, Z2 = class {
  constructor(e) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e, this.sizeInBytes = 0;
  }
  append(e) {
    const r = new Nk(e);
    if (r.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${r.size}`);
    for (; this.size + r.size > this.maxSizeInBytes; ) this.shift();
    this.head ? (this.tail && (this.tail.next = r), this.tail = r) : (this.head = r, this.tail = r), this.lengthInNodes++, this.sizeInBytes += r.size;
  }
  shift() {
    if (!this.head) return;
    const e = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e.size;
  }
  toArray() {
    const e = [];
    let r = this.head;
    for (; r !== null; ) e.push(r.value), r = r.next;
    return e;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e = this.head;
    return { next: () => {
      if (!e) return { done: !0, value: null };
      const r = e.value;
      return e = e.next, { done: !1, value: r };
    } };
  }
}, P4 = class {
  constructor(e, r = $v) {
    this.level = e ?? "error", this.levelValue = Jc.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = r, this.logs = new Z2(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(e, r) {
    r === Jc.levels.values.error ? console.error(e) : r === Jc.levels.values.warn ? console.warn(e) : r === Jc.levels.values.debug ? console.debug(e) : r === Jc.levels.values.trace ? console.trace(e) : console.log(e);
  }
  appendToLogs(e) {
    this.logs.append(Bo({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: e }));
    const r = typeof e == "string" ? JSON.parse(e).level : e.level;
    r >= this.levelValue && this.forwardToConsole(e, r);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new Z2(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(e) {
    const r = this.getLogArray();
    return r.push(Bo({ extraMetadata: e })), new Blob(r, { type: "application/json" });
  }
}, Lk = class {
  constructor(e, r = $v) {
    this.baseChunkLogger = new P4(e, r);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
  downloadLogsBlobInBrowser(e) {
    const r = URL.createObjectURL(this.logsToBlob(e)), n = document.createElement("a");
    n.href = r, n.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(n), n.click(), document.body.removeChild(n), URL.revokeObjectURL(r);
  }
}, kk = class {
  constructor(e, r = $v) {
    this.baseChunkLogger = new P4(e, r);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
};
var $k = Object.defineProperty, Bk = Object.defineProperties, Fk = Object.getOwnPropertyDescriptors, Q2 = Object.getOwnPropertySymbols, jk = Object.prototype.hasOwnProperty, Uk = Object.prototype.propertyIsEnumerable, ex = (t, e, r) => e in t ? $k(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Jd = (t, e) => {
  for (var r in e || (e = {})) jk.call(e, r) && ex(t, r, e[r]);
  if (Q2) for (var r of Q2(e)) Uk.call(e, r) && ex(t, r, e[r]);
  return t;
}, Xd = (t, e) => Bk(t, Fk(e));
function $0(t) {
  return Xd(Jd({}, t), { level: (t == null ? void 0 : t.level) || Ok.level });
}
function qk(t, e = zl) {
  return t[e] || "";
}
function zk(t, e, r = zl) {
  return t[r] = e, t;
}
function Si(t, e = zl) {
  let r = "";
  return typeof t.bindings > "u" ? r = qk(t, e) : r = t.bindings().context || "", r;
}
function Wk(t, e, r = zl) {
  const n = Si(t, r);
  return n.trim() ? `${n}/${e}` : e;
}
function ci(t, e, r = zl) {
  const n = Wk(t, e, r), i = t.child({ context: n });
  return zk(i, n, r);
}
function Hk(t) {
  var e, r;
  const n = new Lk((e = t.opts) == null ? void 0 : e.level, t.maxSizeInBytes);
  return { logger: ql(Xd(Jd({}, t.opts), { level: "trace", browser: Xd(Jd({}, (r = t.opts) == null ? void 0 : r.browser), { write: (i) => n.write(i) }) })), chunkLoggerController: n };
}
function Kk(t) {
  var e;
  const r = new kk((e = t.opts) == null ? void 0 : e.level, t.maxSizeInBytes);
  return { logger: ql(Xd(Jd({}, t.opts), { level: "trace" }), r), chunkLoggerController: r };
}
function Vk(t) {
  return typeof t.loggerOverride < "u" && typeof t.loggerOverride != "string" ? { logger: t.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? Hk(t) : Kk(t);
}
let Gk = class extends vc {
  constructor(e) {
    super(), this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, Yk = class extends vc {
  constructor(e, r) {
    super(), this.core = e, this.logger = r, this.records = /* @__PURE__ */ new Map();
  }
}, Jk = class {
  constructor(e, r) {
    this.logger = e, this.core = r;
  }
}, Xk = class extends vc {
  constructor(e, r) {
    super(), this.relayer = e, this.logger = r;
  }
}, Zk = class extends vc {
  constructor(e) {
    super();
  }
}, Qk = class {
  constructor(e, r, n, i) {
    this.core = e, this.logger = r, this.name = n;
  }
}, e$ = class extends vc {
  constructor(e, r) {
    super(), this.relayer = e, this.logger = r;
  }
}, t$ = class extends vc {
  constructor(e, r) {
    super(), this.core = e, this.logger = r;
  }
}, r$ = class {
  constructor(e, r, n) {
    this.core = e, this.logger = r, this.store = n;
  }
}, n$ = class {
  constructor(e, r) {
    this.projectId = e, this.logger = r;
  }
}, i$ = class {
  constructor(e, r, n) {
    this.core = e, this.logger = r, this.telemetryEnabled = n;
  }
}, s$ = class {
  constructor(e) {
    this.opts = e, this.protocol = "wc", this.version = 2;
  }
}, o$ = class {
  constructor(e) {
    this.client = e;
  }
};
var Bv = {}, Ca = {}, B0 = {}, F0 = {};
Object.defineProperty(F0, "__esModule", { value: !0 });
F0.BrowserRandomSource = void 0;
const tx = 65536;
class a$ {
  constructor() {
    this.isAvailable = !1, this.isInstantiated = !1;
    const e = typeof self < "u" ? self.crypto || self.msCrypto : null;
    e && e.getRandomValues !== void 0 && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Browser random byte generator is not available.");
    const r = new Uint8Array(e);
    for (let n = 0; n < r.length; n += tx)
      this._crypto.getRandomValues(r.subarray(n, n + Math.min(r.length - n, tx)));
    return r;
  }
}
F0.BrowserRandomSource = a$;
function M4(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var j0 = {}, $i = {};
Object.defineProperty($i, "__esModule", { value: !0 });
function c$(t) {
  for (var e = 0; e < t.length; e++)
    t[e] = 0;
  return t;
}
$i.wipe = c$;
const u$ = {}, f$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: u$
}, Symbol.toStringTag, { value: "Module" })), Wl = /* @__PURE__ */ bv(f$);
Object.defineProperty(j0, "__esModule", { value: !0 });
j0.NodeRandomSource = void 0;
const l$ = $i;
class h$ {
  constructor() {
    if (this.isAvailable = !1, this.isInstantiated = !1, typeof M4 < "u") {
      const e = Wl;
      e && e.randomBytes && (this._crypto = e, this.isAvailable = !0, this.isInstantiated = !0);
    }
  }
  randomBytes(e) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Node.js random byte generator is not available.");
    let r = this._crypto.randomBytes(e);
    if (r.length !== e)
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    const n = new Uint8Array(e);
    for (let i = 0; i < n.length; i++)
      n[i] = r[i];
    return (0, l$.wipe)(r), n;
  }
}
j0.NodeRandomSource = h$;
Object.defineProperty(B0, "__esModule", { value: !0 });
B0.SystemRandomSource = void 0;
const d$ = F0, p$ = j0;
class g$ {
  constructor() {
    if (this.isAvailable = !1, this.name = "", this._source = new d$.BrowserRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Browser";
      return;
    }
    if (this._source = new p$.NodeRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Node";
      return;
    }
  }
  randomBytes(e) {
    if (!this.isAvailable)
      throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(e);
  }
}
B0.SystemRandomSource = g$;
var ar = {}, I4 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function e(a, u) {
    var l = a >>> 16 & 65535, d = a & 65535, p = u >>> 16 & 65535, w = u & 65535;
    return d * w + (l * w + d * p << 16 >>> 0) | 0;
  }
  t.mul = Math.imul || e;
  function r(a, u) {
    return a + u | 0;
  }
  t.add = r;
  function n(a, u) {
    return a - u | 0;
  }
  t.sub = n;
  function i(a, u) {
    return a << u | a >>> 32 - u;
  }
  t.rotl = i;
  function s(a, u) {
    return a << 32 - u | a >>> u;
  }
  t.rotr = s;
  function o(a) {
    return typeof a == "number" && isFinite(a) && Math.floor(a) === a;
  }
  t.isInteger = Number.isInteger || o, t.MAX_SAFE_INTEGER = 9007199254740991, t.isSafeInteger = function(a) {
    return t.isInteger(a) && a >= -t.MAX_SAFE_INTEGER && a <= t.MAX_SAFE_INTEGER;
  };
})(I4);
Object.defineProperty(ar, "__esModule", { value: !0 });
var C4 = I4;
function m$(t, e) {
  return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) << 16 >> 16;
}
ar.readInt16BE = m$;
function v$(t, e) {
  return e === void 0 && (e = 0), (t[e + 0] << 8 | t[e + 1]) >>> 0;
}
ar.readUint16BE = v$;
function b$(t, e) {
  return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) << 16 >> 16;
}
ar.readInt16LE = b$;
function y$(t, e) {
  return e === void 0 && (e = 0), (t[e + 1] << 8 | t[e]) >>> 0;
}
ar.readUint16LE = y$;
function T4(t, e, r) {
  return e === void 0 && (e = new Uint8Array(2)), r === void 0 && (r = 0), e[r + 0] = t >>> 8, e[r + 1] = t >>> 0, e;
}
ar.writeUint16BE = T4;
ar.writeInt16BE = T4;
function R4(t, e, r) {
  return e === void 0 && (e = new Uint8Array(2)), r === void 0 && (r = 0), e[r + 0] = t >>> 0, e[r + 1] = t >>> 8, e;
}
ar.writeUint16LE = R4;
ar.writeInt16LE = R4;
function d1(t, e) {
  return e === void 0 && (e = 0), t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3];
}
ar.readInt32BE = d1;
function p1(t, e) {
  return e === void 0 && (e = 0), (t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3]) >>> 0;
}
ar.readUint32BE = p1;
function g1(t, e) {
  return e === void 0 && (e = 0), t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e];
}
ar.readInt32LE = g1;
function m1(t, e) {
  return e === void 0 && (e = 0), (t[e + 3] << 24 | t[e + 2] << 16 | t[e + 1] << 8 | t[e]) >>> 0;
}
ar.readUint32LE = m1;
function Zd(t, e, r) {
  return e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0), e[r + 0] = t >>> 24, e[r + 1] = t >>> 16, e[r + 2] = t >>> 8, e[r + 3] = t >>> 0, e;
}
ar.writeUint32BE = Zd;
ar.writeInt32BE = Zd;
function Qd(t, e, r) {
  return e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0), e[r + 0] = t >>> 0, e[r + 1] = t >>> 8, e[r + 2] = t >>> 16, e[r + 3] = t >>> 24, e;
}
ar.writeUint32LE = Qd;
ar.writeInt32LE = Qd;
function w$(t, e) {
  e === void 0 && (e = 0);
  var r = d1(t, e), n = d1(t, e + 4);
  return r * 4294967296 + n - (n >> 31) * 4294967296;
}
ar.readInt64BE = w$;
function x$(t, e) {
  e === void 0 && (e = 0);
  var r = p1(t, e), n = p1(t, e + 4);
  return r * 4294967296 + n;
}
ar.readUint64BE = x$;
function _$(t, e) {
  e === void 0 && (e = 0);
  var r = g1(t, e), n = g1(t, e + 4);
  return n * 4294967296 + r - (r >> 31) * 4294967296;
}
ar.readInt64LE = _$;
function E$(t, e) {
  e === void 0 && (e = 0);
  var r = m1(t, e), n = m1(t, e + 4);
  return n * 4294967296 + r;
}
ar.readUint64LE = E$;
function D4(t, e, r) {
  return e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0), Zd(t / 4294967296 >>> 0, e, r), Zd(t >>> 0, e, r + 4), e;
}
ar.writeUint64BE = D4;
ar.writeInt64BE = D4;
function O4(t, e, r) {
  return e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0), Qd(t >>> 0, e, r), Qd(t / 4294967296 >>> 0, e, r + 4), e;
}
ar.writeUint64LE = O4;
ar.writeInt64LE = O4;
function S$(t, e, r) {
  if (r === void 0 && (r = 0), t % 8 !== 0)
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (t / 8 > e.length - r)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var n = 0, i = 1, s = t / 8 + r - 1; s >= r; s--)
    n += e[s] * i, i *= 256;
  return n;
}
ar.readUintBE = S$;
function A$(t, e, r) {
  if (r === void 0 && (r = 0), t % 8 !== 0)
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (t / 8 > e.length - r)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var n = 0, i = 1, s = r; s < r + t / 8; s++)
    n += e[s] * i, i *= 256;
  return n;
}
ar.readUintLE = A$;
function P$(t, e, r, n) {
  if (r === void 0 && (r = new Uint8Array(t / 8)), n === void 0 && (n = 0), t % 8 !== 0)
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!C4.isSafeInteger(e))
    throw new Error("writeUintBE value must be an integer");
  for (var i = 1, s = t / 8 + n - 1; s >= n; s--)
    r[s] = e / i & 255, i *= 256;
  return r;
}
ar.writeUintBE = P$;
function M$(t, e, r, n) {
  if (r === void 0 && (r = new Uint8Array(t / 8)), n === void 0 && (n = 0), t % 8 !== 0)
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!C4.isSafeInteger(e))
    throw new Error("writeUintLE value must be an integer");
  for (var i = 1, s = n; s < n + t / 8; s++)
    r[s] = e / i & 255, i *= 256;
  return r;
}
ar.writeUintLE = M$;
function I$(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat32(e);
}
ar.readFloat32BE = I$;
function C$(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat32(e, !0);
}
ar.readFloat32LE = C$;
function T$(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat64(e);
}
ar.readFloat64BE = T$;
function R$(t, e) {
  e === void 0 && (e = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.getFloat64(e, !0);
}
ar.readFloat64LE = R$;
function D$(t, e, r) {
  e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat32(r, t), e;
}
ar.writeFloat32BE = D$;
function O$(t, e, r) {
  e === void 0 && (e = new Uint8Array(4)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat32(r, t, !0), e;
}
ar.writeFloat32LE = O$;
function N$(t, e, r) {
  e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat64(r, t), e;
}
ar.writeFloat64BE = N$;
function L$(t, e, r) {
  e === void 0 && (e = new Uint8Array(8)), r === void 0 && (r = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.setFloat64(r, t, !0), e;
}
ar.writeFloat64LE = L$;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.randomStringForEntropy = t.randomString = t.randomUint32 = t.randomBytes = t.defaultRandomSource = void 0;
  const e = B0, r = ar, n = $i;
  t.defaultRandomSource = new e.SystemRandomSource();
  function i(l, d = t.defaultRandomSource) {
    return d.randomBytes(l);
  }
  t.randomBytes = i;
  function s(l = t.defaultRandomSource) {
    const d = i(4, l), p = (0, r.readUint32LE)(d);
    return (0, n.wipe)(d), p;
  }
  t.randomUint32 = s;
  const o = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function a(l, d = o, p = t.defaultRandomSource) {
    if (d.length < 2)
      throw new Error("randomString charset is too short");
    if (d.length > 256)
      throw new Error("randomString charset is too long");
    let w = "";
    const A = d.length, P = 256 - 256 % A;
    for (; l > 0; ) {
      const N = i(Math.ceil(l * 256 / P), p);
      for (let L = 0; L < N.length && l > 0; L++) {
        const $ = N[L];
        $ < P && (w += d.charAt($ % A), l--);
      }
      (0, n.wipe)(N);
    }
    return w;
  }
  t.randomString = a;
  function u(l, d = o, p = t.defaultRandomSource) {
    const w = Math.ceil(l / (Math.log(d.length) / Math.LN2));
    return a(w, d, p);
  }
  t.randomStringForEntropy = u;
})(Ca);
var N4 = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = ar, r = $i;
  t.DIGEST_LENGTH = 64, t.BLOCK_SIZE = 128;
  var n = (
    /** @class */
    function() {
      function a() {
        this.digestLength = t.DIGEST_LENGTH, this.blockSize = t.BLOCK_SIZE, this._stateHi = new Int32Array(8), this._stateLo = new Int32Array(8), this._tempHi = new Int32Array(16), this._tempLo = new Int32Array(16), this._buffer = new Uint8Array(256), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return a.prototype._initState = function() {
        this._stateHi[0] = 1779033703, this._stateHi[1] = 3144134277, this._stateHi[2] = 1013904242, this._stateHi[3] = 2773480762, this._stateHi[4] = 1359893119, this._stateHi[5] = 2600822924, this._stateHi[6] = 528734635, this._stateHi[7] = 1541459225, this._stateLo[0] = 4089235720, this._stateLo[1] = 2227873595, this._stateLo[2] = 4271175723, this._stateLo[3] = 1595750129, this._stateLo[4] = 2917565137, this._stateLo[5] = 725511199, this._stateLo[6] = 4215389547, this._stateLo[7] = 327033209;
      }, a.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, a.prototype.clean = function() {
        r.wipe(this._buffer), r.wipe(this._tempHi), r.wipe(this._tempLo), this.reset();
      }, a.prototype.update = function(u, l) {
        if (l === void 0 && (l = u.length), this._finished)
          throw new Error("SHA512: can't update because hash was finished.");
        var d = 0;
        if (this._bytesHashed += l, this._bufferLength > 0) {
          for (; this._bufferLength < t.BLOCK_SIZE && l > 0; )
            this._buffer[this._bufferLength++] = u[d++], l--;
          this._bufferLength === this.blockSize && (s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (l >= this.blockSize && (d = s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, u, d, l), l %= this.blockSize); l > 0; )
          this._buffer[this._bufferLength++] = u[d++], l--;
        return this;
      }, a.prototype.finish = function(u) {
        if (!this._finished) {
          var l = this._bytesHashed, d = this._bufferLength, p = l / 536870912 | 0, w = l << 3, A = l % 128 < 112 ? 128 : 256;
          this._buffer[d] = 128;
          for (var P = d + 1; P < A - 8; P++)
            this._buffer[P] = 0;
          e.writeUint32BE(p, this._buffer, A - 8), e.writeUint32BE(w, this._buffer, A - 4), s(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, A), this._finished = !0;
        }
        for (var P = 0; P < this.digestLength / 8; P++)
          e.writeUint32BE(this._stateHi[P], u, P * 8), e.writeUint32BE(this._stateLo[P], u, P * 8 + 4);
        return this;
      }, a.prototype.digest = function() {
        var u = new Uint8Array(this.digestLength);
        return this.finish(u), u;
      }, a.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, a.prototype.restoreState = function(u) {
        return this._stateHi.set(u.stateHi), this._stateLo.set(u.stateLo), this._bufferLength = u.bufferLength, u.buffer && this._buffer.set(u.buffer), this._bytesHashed = u.bytesHashed, this._finished = !1, this;
      }, a.prototype.cleanSavedState = function(u) {
        r.wipe(u.stateHi), r.wipe(u.stateLo), u.buffer && r.wipe(u.buffer), u.bufferLength = 0, u.bytesHashed = 0;
      }, a;
    }()
  );
  t.SHA512 = n;
  var i = new Int32Array([
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ]);
  function s(a, u, l, d, p, w, A) {
    for (var P = l[0], N = l[1], L = l[2], $ = l[3], B = l[4], H = l[5], W = l[6], V = l[7], te = d[0], R = d[1], K = d[2], ge = d[3], Ee = d[4], Y = d[5], S = d[6], m = d[7], f, g, b, x, _, E, v, M; A >= 128; ) {
      for (var I = 0; I < 16; I++) {
        var F = 8 * I + w;
        a[I] = e.readUint32BE(p, F), u[I] = e.readUint32BE(p, F + 4);
      }
      for (var I = 0; I < 80; I++) {
        var ce = P, D = N, oe = L, Z = $, J = B, Q = H, T = W, X = V, re = te, pe = R, ie = K, ue = ge, ve = Ee, Pe = Y, De = S, Ce = m;
        if (f = V, g = m, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = (B >>> 14 | Ee << 18) ^ (B >>> 18 | Ee << 14) ^ (Ee >>> 9 | B << 23), g = (Ee >>> 14 | B << 18) ^ (Ee >>> 18 | B << 14) ^ (B >>> 9 | Ee << 23), _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, f = B & H ^ ~B & W, g = Ee & Y ^ ~Ee & S, _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, f = i[I * 2], g = i[I * 2 + 1], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, f = a[I % 16], g = u[I % 16], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, b = v & 65535 | M << 16, x = _ & 65535 | E << 16, f = b, g = x, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = (P >>> 28 | te << 4) ^ (te >>> 2 | P << 30) ^ (te >>> 7 | P << 25), g = (te >>> 28 | P << 4) ^ (P >>> 2 | te << 30) ^ (P >>> 7 | te << 25), _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, f = P & N ^ P & L ^ N & L, g = te & R ^ te & K ^ R & K, _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, X = v & 65535 | M << 16, Ce = _ & 65535 | E << 16, f = Z, g = ue, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = b, g = x, _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, Z = v & 65535 | M << 16, ue = _ & 65535 | E << 16, N = ce, L = D, $ = oe, B = Z, H = J, W = Q, V = T, P = X, R = re, K = pe, ge = ie, Ee = ue, Y = ve, S = Pe, m = De, te = Ce, I % 16 === 15)
          for (var F = 0; F < 16; F++)
            f = a[F], g = u[F], _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = a[(F + 9) % 16], g = u[(F + 9) % 16], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, b = a[(F + 1) % 16], x = u[(F + 1) % 16], f = (b >>> 1 | x << 31) ^ (b >>> 8 | x << 24) ^ b >>> 7, g = (x >>> 1 | b << 31) ^ (x >>> 8 | b << 24) ^ (x >>> 7 | b << 25), _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, b = a[(F + 14) % 16], x = u[(F + 14) % 16], f = (b >>> 19 | x << 13) ^ (x >>> 29 | b << 3) ^ b >>> 6, g = (x >>> 19 | b << 13) ^ (b >>> 29 | x << 3) ^ (x >>> 6 | b << 26), _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, a[F] = v & 65535 | M << 16, u[F] = _ & 65535 | E << 16;
      }
      f = P, g = te, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = l[0], g = d[0], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, l[0] = P = v & 65535 | M << 16, d[0] = te = _ & 65535 | E << 16, f = N, g = R, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = l[1], g = d[1], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, l[1] = N = v & 65535 | M << 16, d[1] = R = _ & 65535 | E << 16, f = L, g = K, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = l[2], g = d[2], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, l[2] = L = v & 65535 | M << 16, d[2] = K = _ & 65535 | E << 16, f = $, g = ge, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = l[3], g = d[3], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, l[3] = $ = v & 65535 | M << 16, d[3] = ge = _ & 65535 | E << 16, f = B, g = Ee, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = l[4], g = d[4], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, l[4] = B = v & 65535 | M << 16, d[4] = Ee = _ & 65535 | E << 16, f = H, g = Y, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = l[5], g = d[5], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, l[5] = H = v & 65535 | M << 16, d[5] = Y = _ & 65535 | E << 16, f = W, g = S, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = l[6], g = d[6], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, l[6] = W = v & 65535 | M << 16, d[6] = S = _ & 65535 | E << 16, f = V, g = m, _ = g & 65535, E = g >>> 16, v = f & 65535, M = f >>> 16, f = l[7], g = d[7], _ += g & 65535, E += g >>> 16, v += f & 65535, M += f >>> 16, E += _ >>> 16, v += E >>> 16, M += v >>> 16, l[7] = V = v & 65535 | M << 16, d[7] = m = _ & 65535 | E << 16, w += 128, A -= 128;
    }
    return w;
  }
  function o(a) {
    var u = new n();
    u.update(a);
    var l = u.digest();
    return u.clean(), l;
  }
  t.hash = o;
})(N4);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.convertSecretKeyToX25519 = t.convertPublicKeyToX25519 = t.verify = t.sign = t.extractPublicKeyFromSecretKey = t.generateKeyPair = t.generateKeyPairFromSeed = t.SEED_LENGTH = t.SECRET_KEY_LENGTH = t.PUBLIC_KEY_LENGTH = t.SIGNATURE_LENGTH = void 0;
  const e = Ca, r = N4, n = $i;
  t.SIGNATURE_LENGTH = 64, t.PUBLIC_KEY_LENGTH = 32, t.SECRET_KEY_LENGTH = 64, t.SEED_LENGTH = 32;
  function i(Z) {
    const J = new Float64Array(16);
    if (Z)
      for (let Q = 0; Q < Z.length; Q++)
        J[Q] = Z[Q];
    return J;
  }
  const s = new Uint8Array(32);
  s[0] = 9;
  const o = i(), a = i([1]), u = i([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]), l = i([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]), d = i([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]), p = i([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]), w = i([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function A(Z, J) {
    for (let Q = 0; Q < 16; Q++)
      Z[Q] = J[Q] | 0;
  }
  function P(Z) {
    let J = 1;
    for (let Q = 0; Q < 16; Q++) {
      let T = Z[Q] + J + 65535;
      J = Math.floor(T / 65536), Z[Q] = T - J * 65536;
    }
    Z[0] += J - 1 + 37 * (J - 1);
  }
  function N(Z, J, Q) {
    const T = ~(Q - 1);
    for (let X = 0; X < 16; X++) {
      const re = T & (Z[X] ^ J[X]);
      Z[X] ^= re, J[X] ^= re;
    }
  }
  function L(Z, J) {
    const Q = i(), T = i();
    for (let X = 0; X < 16; X++)
      T[X] = J[X];
    P(T), P(T), P(T);
    for (let X = 0; X < 2; X++) {
      Q[0] = T[0] - 65517;
      for (let pe = 1; pe < 15; pe++)
        Q[pe] = T[pe] - 65535 - (Q[pe - 1] >> 16 & 1), Q[pe - 1] &= 65535;
      Q[15] = T[15] - 32767 - (Q[14] >> 16 & 1);
      const re = Q[15] >> 16 & 1;
      Q[14] &= 65535, N(T, Q, 1 - re);
    }
    for (let X = 0; X < 16; X++)
      Z[2 * X] = T[X] & 255, Z[2 * X + 1] = T[X] >> 8;
  }
  function $(Z, J) {
    let Q = 0;
    for (let T = 0; T < 32; T++)
      Q |= Z[T] ^ J[T];
    return (1 & Q - 1 >>> 8) - 1;
  }
  function B(Z, J) {
    const Q = new Uint8Array(32), T = new Uint8Array(32);
    return L(Q, Z), L(T, J), $(Q, T);
  }
  function H(Z) {
    const J = new Uint8Array(32);
    return L(J, Z), J[0] & 1;
  }
  function W(Z, J) {
    for (let Q = 0; Q < 16; Q++)
      Z[Q] = J[2 * Q] + (J[2 * Q + 1] << 8);
    Z[15] &= 32767;
  }
  function V(Z, J, Q) {
    for (let T = 0; T < 16; T++)
      Z[T] = J[T] + Q[T];
  }
  function te(Z, J, Q) {
    for (let T = 0; T < 16; T++)
      Z[T] = J[T] - Q[T];
  }
  function R(Z, J, Q) {
    let T, X, re = 0, pe = 0, ie = 0, ue = 0, ve = 0, Pe = 0, De = 0, Ce = 0, $e = 0, Me = 0, Ne = 0, Ke = 0, Le = 0, qe = 0, ze = 0, _e = 0, Ze = 0, at = 0, ke = 0, Qe = 0, tt = 0, Ye = 0, dt = 0, lt = 0, ct = 0, qt = 0, Jt = 0, Et = 0, er = 0, Xt = 0, Dt = 0, kt = Q[0], Ct = Q[1], gt = Q[2], Rt = Q[3], Nt = Q[4], vt = Q[5], $t = Q[6], Ft = Q[7], rt = Q[8], Bt = Q[9], k = Q[10], U = Q[11], z = Q[12], C = Q[13], G = Q[14], j = Q[15];
    T = J[0], re += T * kt, pe += T * Ct, ie += T * gt, ue += T * Rt, ve += T * Nt, Pe += T * vt, De += T * $t, Ce += T * Ft, $e += T * rt, Me += T * Bt, Ne += T * k, Ke += T * U, Le += T * z, qe += T * C, ze += T * G, _e += T * j, T = J[1], pe += T * kt, ie += T * Ct, ue += T * gt, ve += T * Rt, Pe += T * Nt, De += T * vt, Ce += T * $t, $e += T * Ft, Me += T * rt, Ne += T * Bt, Ke += T * k, Le += T * U, qe += T * z, ze += T * C, _e += T * G, Ze += T * j, T = J[2], ie += T * kt, ue += T * Ct, ve += T * gt, Pe += T * Rt, De += T * Nt, Ce += T * vt, $e += T * $t, Me += T * Ft, Ne += T * rt, Ke += T * Bt, Le += T * k, qe += T * U, ze += T * z, _e += T * C, Ze += T * G, at += T * j, T = J[3], ue += T * kt, ve += T * Ct, Pe += T * gt, De += T * Rt, Ce += T * Nt, $e += T * vt, Me += T * $t, Ne += T * Ft, Ke += T * rt, Le += T * Bt, qe += T * k, ze += T * U, _e += T * z, Ze += T * C, at += T * G, ke += T * j, T = J[4], ve += T * kt, Pe += T * Ct, De += T * gt, Ce += T * Rt, $e += T * Nt, Me += T * vt, Ne += T * $t, Ke += T * Ft, Le += T * rt, qe += T * Bt, ze += T * k, _e += T * U, Ze += T * z, at += T * C, ke += T * G, Qe += T * j, T = J[5], Pe += T * kt, De += T * Ct, Ce += T * gt, $e += T * Rt, Me += T * Nt, Ne += T * vt, Ke += T * $t, Le += T * Ft, qe += T * rt, ze += T * Bt, _e += T * k, Ze += T * U, at += T * z, ke += T * C, Qe += T * G, tt += T * j, T = J[6], De += T * kt, Ce += T * Ct, $e += T * gt, Me += T * Rt, Ne += T * Nt, Ke += T * vt, Le += T * $t, qe += T * Ft, ze += T * rt, _e += T * Bt, Ze += T * k, at += T * U, ke += T * z, Qe += T * C, tt += T * G, Ye += T * j, T = J[7], Ce += T * kt, $e += T * Ct, Me += T * gt, Ne += T * Rt, Ke += T * Nt, Le += T * vt, qe += T * $t, ze += T * Ft, _e += T * rt, Ze += T * Bt, at += T * k, ke += T * U, Qe += T * z, tt += T * C, Ye += T * G, dt += T * j, T = J[8], $e += T * kt, Me += T * Ct, Ne += T * gt, Ke += T * Rt, Le += T * Nt, qe += T * vt, ze += T * $t, _e += T * Ft, Ze += T * rt, at += T * Bt, ke += T * k, Qe += T * U, tt += T * z, Ye += T * C, dt += T * G, lt += T * j, T = J[9], Me += T * kt, Ne += T * Ct, Ke += T * gt, Le += T * Rt, qe += T * Nt, ze += T * vt, _e += T * $t, Ze += T * Ft, at += T * rt, ke += T * Bt, Qe += T * k, tt += T * U, Ye += T * z, dt += T * C, lt += T * G, ct += T * j, T = J[10], Ne += T * kt, Ke += T * Ct, Le += T * gt, qe += T * Rt, ze += T * Nt, _e += T * vt, Ze += T * $t, at += T * Ft, ke += T * rt, Qe += T * Bt, tt += T * k, Ye += T * U, dt += T * z, lt += T * C, ct += T * G, qt += T * j, T = J[11], Ke += T * kt, Le += T * Ct, qe += T * gt, ze += T * Rt, _e += T * Nt, Ze += T * vt, at += T * $t, ke += T * Ft, Qe += T * rt, tt += T * Bt, Ye += T * k, dt += T * U, lt += T * z, ct += T * C, qt += T * G, Jt += T * j, T = J[12], Le += T * kt, qe += T * Ct, ze += T * gt, _e += T * Rt, Ze += T * Nt, at += T * vt, ke += T * $t, Qe += T * Ft, tt += T * rt, Ye += T * Bt, dt += T * k, lt += T * U, ct += T * z, qt += T * C, Jt += T * G, Et += T * j, T = J[13], qe += T * kt, ze += T * Ct, _e += T * gt, Ze += T * Rt, at += T * Nt, ke += T * vt, Qe += T * $t, tt += T * Ft, Ye += T * rt, dt += T * Bt, lt += T * k, ct += T * U, qt += T * z, Jt += T * C, Et += T * G, er += T * j, T = J[14], ze += T * kt, _e += T * Ct, Ze += T * gt, at += T * Rt, ke += T * Nt, Qe += T * vt, tt += T * $t, Ye += T * Ft, dt += T * rt, lt += T * Bt, ct += T * k, qt += T * U, Jt += T * z, Et += T * C, er += T * G, Xt += T * j, T = J[15], _e += T * kt, Ze += T * Ct, at += T * gt, ke += T * Rt, Qe += T * Nt, tt += T * vt, Ye += T * $t, dt += T * Ft, lt += T * rt, ct += T * Bt, qt += T * k, Jt += T * U, Et += T * z, er += T * C, Xt += T * G, Dt += T * j, re += 38 * Ze, pe += 38 * at, ie += 38 * ke, ue += 38 * Qe, ve += 38 * tt, Pe += 38 * Ye, De += 38 * dt, Ce += 38 * lt, $e += 38 * ct, Me += 38 * qt, Ne += 38 * Jt, Ke += 38 * Et, Le += 38 * er, qe += 38 * Xt, ze += 38 * Dt, X = 1, T = re + X + 65535, X = Math.floor(T / 65536), re = T - X * 65536, T = pe + X + 65535, X = Math.floor(T / 65536), pe = T - X * 65536, T = ie + X + 65535, X = Math.floor(T / 65536), ie = T - X * 65536, T = ue + X + 65535, X = Math.floor(T / 65536), ue = T - X * 65536, T = ve + X + 65535, X = Math.floor(T / 65536), ve = T - X * 65536, T = Pe + X + 65535, X = Math.floor(T / 65536), Pe = T - X * 65536, T = De + X + 65535, X = Math.floor(T / 65536), De = T - X * 65536, T = Ce + X + 65535, X = Math.floor(T / 65536), Ce = T - X * 65536, T = $e + X + 65535, X = Math.floor(T / 65536), $e = T - X * 65536, T = Me + X + 65535, X = Math.floor(T / 65536), Me = T - X * 65536, T = Ne + X + 65535, X = Math.floor(T / 65536), Ne = T - X * 65536, T = Ke + X + 65535, X = Math.floor(T / 65536), Ke = T - X * 65536, T = Le + X + 65535, X = Math.floor(T / 65536), Le = T - X * 65536, T = qe + X + 65535, X = Math.floor(T / 65536), qe = T - X * 65536, T = ze + X + 65535, X = Math.floor(T / 65536), ze = T - X * 65536, T = _e + X + 65535, X = Math.floor(T / 65536), _e = T - X * 65536, re += X - 1 + 37 * (X - 1), X = 1, T = re + X + 65535, X = Math.floor(T / 65536), re = T - X * 65536, T = pe + X + 65535, X = Math.floor(T / 65536), pe = T - X * 65536, T = ie + X + 65535, X = Math.floor(T / 65536), ie = T - X * 65536, T = ue + X + 65535, X = Math.floor(T / 65536), ue = T - X * 65536, T = ve + X + 65535, X = Math.floor(T / 65536), ve = T - X * 65536, T = Pe + X + 65535, X = Math.floor(T / 65536), Pe = T - X * 65536, T = De + X + 65535, X = Math.floor(T / 65536), De = T - X * 65536, T = Ce + X + 65535, X = Math.floor(T / 65536), Ce = T - X * 65536, T = $e + X + 65535, X = Math.floor(T / 65536), $e = T - X * 65536, T = Me + X + 65535, X = Math.floor(T / 65536), Me = T - X * 65536, T = Ne + X + 65535, X = Math.floor(T / 65536), Ne = T - X * 65536, T = Ke + X + 65535, X = Math.floor(T / 65536), Ke = T - X * 65536, T = Le + X + 65535, X = Math.floor(T / 65536), Le = T - X * 65536, T = qe + X + 65535, X = Math.floor(T / 65536), qe = T - X * 65536, T = ze + X + 65535, X = Math.floor(T / 65536), ze = T - X * 65536, T = _e + X + 65535, X = Math.floor(T / 65536), _e = T - X * 65536, re += X - 1 + 37 * (X - 1), Z[0] = re, Z[1] = pe, Z[2] = ie, Z[3] = ue, Z[4] = ve, Z[5] = Pe, Z[6] = De, Z[7] = Ce, Z[8] = $e, Z[9] = Me, Z[10] = Ne, Z[11] = Ke, Z[12] = Le, Z[13] = qe, Z[14] = ze, Z[15] = _e;
  }
  function K(Z, J) {
    R(Z, J, J);
  }
  function ge(Z, J) {
    const Q = i();
    let T;
    for (T = 0; T < 16; T++)
      Q[T] = J[T];
    for (T = 253; T >= 0; T--)
      K(Q, Q), T !== 2 && T !== 4 && R(Q, Q, J);
    for (T = 0; T < 16; T++)
      Z[T] = Q[T];
  }
  function Ee(Z, J) {
    const Q = i();
    let T;
    for (T = 0; T < 16; T++)
      Q[T] = J[T];
    for (T = 250; T >= 0; T--)
      K(Q, Q), T !== 1 && R(Q, Q, J);
    for (T = 0; T < 16; T++)
      Z[T] = Q[T];
  }
  function Y(Z, J) {
    const Q = i(), T = i(), X = i(), re = i(), pe = i(), ie = i(), ue = i(), ve = i(), Pe = i();
    te(Q, Z[1], Z[0]), te(Pe, J[1], J[0]), R(Q, Q, Pe), V(T, Z[0], Z[1]), V(Pe, J[0], J[1]), R(T, T, Pe), R(X, Z[3], J[3]), R(X, X, l), R(re, Z[2], J[2]), V(re, re, re), te(pe, T, Q), te(ie, re, X), V(ue, re, X), V(ve, T, Q), R(Z[0], pe, ie), R(Z[1], ve, ue), R(Z[2], ue, ie), R(Z[3], pe, ve);
  }
  function S(Z, J, Q) {
    for (let T = 0; T < 4; T++)
      N(Z[T], J[T], Q);
  }
  function m(Z, J) {
    const Q = i(), T = i(), X = i();
    ge(X, J[2]), R(Q, J[0], X), R(T, J[1], X), L(Z, T), Z[31] ^= H(Q) << 7;
  }
  function f(Z, J, Q) {
    A(Z[0], o), A(Z[1], a), A(Z[2], a), A(Z[3], o);
    for (let T = 255; T >= 0; --T) {
      const X = Q[T / 8 | 0] >> (T & 7) & 1;
      S(Z, J, X), Y(J, Z), Y(Z, Z), S(Z, J, X);
    }
  }
  function g(Z, J) {
    const Q = [i(), i(), i(), i()];
    A(Q[0], d), A(Q[1], p), A(Q[2], a), R(Q[3], d, p), f(Z, Q, J);
  }
  function b(Z) {
    if (Z.length !== t.SEED_LENGTH)
      throw new Error(`ed25519: seed must be ${t.SEED_LENGTH} bytes`);
    const J = (0, r.hash)(Z);
    J[0] &= 248, J[31] &= 127, J[31] |= 64;
    const Q = new Uint8Array(32), T = [i(), i(), i(), i()];
    g(T, J), m(Q, T);
    const X = new Uint8Array(64);
    return X.set(Z), X.set(Q, 32), {
      publicKey: Q,
      secretKey: X
    };
  }
  t.generateKeyPairFromSeed = b;
  function x(Z) {
    const J = (0, e.randomBytes)(32, Z), Q = b(J);
    return (0, n.wipe)(J), Q;
  }
  t.generateKeyPair = x;
  function _(Z) {
    if (Z.length !== t.SECRET_KEY_LENGTH)
      throw new Error(`ed25519: secret key must be ${t.SECRET_KEY_LENGTH} bytes`);
    return new Uint8Array(Z.subarray(32));
  }
  t.extractPublicKeyFromSecretKey = _;
  const E = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  function v(Z, J) {
    let Q, T, X, re;
    for (T = 63; T >= 32; --T) {
      for (Q = 0, X = T - 32, re = T - 12; X < re; ++X)
        J[X] += Q - 16 * J[T] * E[X - (T - 32)], Q = Math.floor((J[X] + 128) / 256), J[X] -= Q * 256;
      J[X] += Q, J[T] = 0;
    }
    for (Q = 0, X = 0; X < 32; X++)
      J[X] += Q - (J[31] >> 4) * E[X], Q = J[X] >> 8, J[X] &= 255;
    for (X = 0; X < 32; X++)
      J[X] -= Q * E[X];
    for (T = 0; T < 32; T++)
      J[T + 1] += J[T] >> 8, Z[T] = J[T] & 255;
  }
  function M(Z) {
    const J = new Float64Array(64);
    for (let Q = 0; Q < 64; Q++)
      J[Q] = Z[Q];
    for (let Q = 0; Q < 64; Q++)
      Z[Q] = 0;
    v(Z, J);
  }
  function I(Z, J) {
    const Q = new Float64Array(64), T = [i(), i(), i(), i()], X = (0, r.hash)(Z.subarray(0, 32));
    X[0] &= 248, X[31] &= 127, X[31] |= 64;
    const re = new Uint8Array(64);
    re.set(X.subarray(32), 32);
    const pe = new r.SHA512();
    pe.update(re.subarray(32)), pe.update(J);
    const ie = pe.digest();
    pe.clean(), M(ie), g(T, ie), m(re, T), pe.reset(), pe.update(re.subarray(0, 32)), pe.update(Z.subarray(32)), pe.update(J);
    const ue = pe.digest();
    M(ue);
    for (let ve = 0; ve < 32; ve++)
      Q[ve] = ie[ve];
    for (let ve = 0; ve < 32; ve++)
      for (let Pe = 0; Pe < 32; Pe++)
        Q[ve + Pe] += ue[ve] * X[Pe];
    return v(re.subarray(32), Q), re;
  }
  t.sign = I;
  function F(Z, J) {
    const Q = i(), T = i(), X = i(), re = i(), pe = i(), ie = i(), ue = i();
    return A(Z[2], a), W(Z[1], J), K(X, Z[1]), R(re, X, u), te(X, X, Z[2]), V(re, Z[2], re), K(pe, re), K(ie, pe), R(ue, ie, pe), R(Q, ue, X), R(Q, Q, re), Ee(Q, Q), R(Q, Q, X), R(Q, Q, re), R(Q, Q, re), R(Z[0], Q, re), K(T, Z[0]), R(T, T, re), B(T, X) && R(Z[0], Z[0], w), K(T, Z[0]), R(T, T, re), B(T, X) ? -1 : (H(Z[0]) === J[31] >> 7 && te(Z[0], o, Z[0]), R(Z[3], Z[0], Z[1]), 0);
  }
  function ce(Z, J, Q) {
    const T = new Uint8Array(32), X = [i(), i(), i(), i()], re = [i(), i(), i(), i()];
    if (Q.length !== t.SIGNATURE_LENGTH)
      throw new Error(`ed25519: signature must be ${t.SIGNATURE_LENGTH} bytes`);
    if (F(re, Z))
      return !1;
    const pe = new r.SHA512();
    pe.update(Q.subarray(0, 32)), pe.update(Z), pe.update(J);
    const ie = pe.digest();
    return M(ie), f(X, re, ie), g(re, Q.subarray(32)), Y(X, re), m(T, X), !$(Q, T);
  }
  t.verify = ce;
  function D(Z) {
    let J = [i(), i(), i(), i()];
    if (F(J, Z))
      throw new Error("Ed25519: invalid public key");
    let Q = i(), T = i(), X = J[1];
    V(Q, a, X), te(T, a, X), ge(T, T), R(Q, Q, T);
    let re = new Uint8Array(32);
    return L(re, Q), re;
  }
  t.convertPublicKeyToX25519 = D;
  function oe(Z) {
    const J = (0, r.hash)(Z.subarray(0, 32));
    J[0] &= 248, J[31] &= 127, J[31] |= 64;
    const Q = new Uint8Array(J.subarray(0, 32));
    return (0, n.wipe)(J), Q;
  }
  t.convertSecretKeyToX25519 = oe;
})(Bv);
const k$ = "EdDSA", $$ = "JWT", e0 = ".", U0 = "base64url", L4 = "utf8", k4 = "utf8", B$ = ":", F$ = "did", j$ = "key", rx = "base58btc", U$ = "z", q$ = "K36", z$ = 32;
function $4(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(t) : new Uint8Array(t);
}
function Sd(t, e) {
  e || (e = t.reduce((i, s) => i + s.length, 0));
  const r = $4(e);
  let n = 0;
  for (const i of t)
    r.set(i, n), n += i.length;
  return r;
}
function W$(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++)
    r[n] = 255;
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i), o = s.charCodeAt(0);
    if (r[o] !== 255)
      throw new TypeError(s + " is ambiguous");
    r[o] = i;
  }
  var a = t.length, u = t.charAt(0), l = Math.log(a) / Math.log(256), d = Math.log(256) / Math.log(a);
  function p(P) {
    if (P instanceof Uint8Array || (ArrayBuffer.isView(P) ? P = new Uint8Array(P.buffer, P.byteOffset, P.byteLength) : Array.isArray(P) && (P = Uint8Array.from(P))), !(P instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (P.length === 0)
      return "";
    for (var N = 0, L = 0, $ = 0, B = P.length; $ !== B && P[$] === 0; )
      $++, N++;
    for (var H = (B - $) * d + 1 >>> 0, W = new Uint8Array(H); $ !== B; ) {
      for (var V = P[$], te = 0, R = H - 1; (V !== 0 || te < L) && R !== -1; R--, te++)
        V += 256 * W[R] >>> 0, W[R] = V % a >>> 0, V = V / a >>> 0;
      if (V !== 0)
        throw new Error("Non-zero carry");
      L = te, $++;
    }
    for (var K = H - L; K !== H && W[K] === 0; )
      K++;
    for (var ge = u.repeat(N); K < H; ++K)
      ge += t.charAt(W[K]);
    return ge;
  }
  function w(P) {
    if (typeof P != "string")
      throw new TypeError("Expected String");
    if (P.length === 0)
      return new Uint8Array();
    var N = 0;
    if (P[N] !== " ") {
      for (var L = 0, $ = 0; P[N] === u; )
        L++, N++;
      for (var B = (P.length - N) * l + 1 >>> 0, H = new Uint8Array(B); P[N]; ) {
        var W = r[P.charCodeAt(N)];
        if (W === 255)
          return;
        for (var V = 0, te = B - 1; (W !== 0 || V < $) && te !== -1; te--, V++)
          W += a * H[te] >>> 0, H[te] = W % 256 >>> 0, W = W / 256 >>> 0;
        if (W !== 0)
          throw new Error("Non-zero carry");
        $ = V, N++;
      }
      if (P[N] !== " ") {
        for (var R = B - $; R !== B && H[R] === 0; )
          R++;
        for (var K = new Uint8Array(L + (B - R)), ge = L; R !== B; )
          K[ge++] = H[R++];
        return K;
      }
    }
  }
  function A(P) {
    var N = w(P);
    if (N)
      return N;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: p,
    decodeUnsafe: w,
    decode: A
  };
}
var H$ = W$, K$ = H$;
const V$ = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
    return t;
  if (t instanceof ArrayBuffer)
    return new Uint8Array(t);
  if (ArrayBuffer.isView(t))
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, G$ = (t) => new TextEncoder().encode(t), Y$ = (t) => new TextDecoder().decode(t);
class J$ {
  constructor(e, r, n) {
    this.name = e, this.prefix = r, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class X$ {
  constructor(e, r, n) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return B4(this, e);
  }
}
class Z$ {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return B4(this, e);
  }
  decode(e) {
    const r = e[0], n = this.decoders[r];
    if (n)
      return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const B4 = (t, e) => new Z$({
  ...t.decoders || { [t.prefix]: t },
  ...e.decoders || { [e.prefix]: e }
});
class Q$ {
  constructor(e, r, n, i) {
    this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = i, this.encoder = new J$(e, r, n), this.decoder = new X$(e, r, i);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const q0 = ({ name: t, prefix: e, encode: r, decode: n }) => new Q$(t, e, r, n), Hl = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: n, decode: i } = K$(r, e);
  return q0({
    prefix: t,
    name: e,
    encode: n,
    decode: (s) => V$(i(s))
  });
}, eB = (t, e, r, n) => {
  const i = {};
  for (let d = 0; d < e.length; ++d)
    i[e[d]] = d;
  let s = t.length;
  for (; t[s - 1] === "="; )
    --s;
  const o = new Uint8Array(s * r / 8 | 0);
  let a = 0, u = 0, l = 0;
  for (let d = 0; d < s; ++d) {
    const p = i[t[d]];
    if (p === void 0)
      throw new SyntaxError(`Non-${n} character`);
    u = u << r | p, a += r, a >= 8 && (a -= 8, o[l++] = 255 & u >> a);
  }
  if (a >= r || 255 & u << 8 - a)
    throw new SyntaxError("Unexpected end of data");
  return o;
}, tB = (t, e, r) => {
  const n = e[e.length - 1] === "=", i = (1 << r) - 1;
  let s = "", o = 0, a = 0;
  for (let u = 0; u < t.length; ++u)
    for (a = a << 8 | t[u], o += 8; o > r; )
      o -= r, s += e[i & a >> o];
  if (o && (s += e[i & a << r - o]), n)
    for (; s.length * r & 7; )
      s += "=";
  return s;
}, qn = ({ name: t, prefix: e, bitsPerChar: r, alphabet: n }) => q0({
  prefix: e,
  name: t,
  encode(i) {
    return tB(i, n, r);
  },
  decode(i) {
    return eB(i, n, r, t);
  }
}), rB = q0({
  prefix: "\0",
  name: "identity",
  encode: (t) => Y$(t),
  decode: (t) => G$(t)
}), nB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: rB
}, Symbol.toStringTag, { value: "Module" })), iB = qn({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), sB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: iB
}, Symbol.toStringTag, { value: "Module" })), oB = qn({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), aB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: oB
}, Symbol.toStringTag, { value: "Module" })), cB = Hl({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), uB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: cB
}, Symbol.toStringTag, { value: "Module" })), fB = qn({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), lB = qn({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), hB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: fB,
  base16upper: lB
}, Symbol.toStringTag, { value: "Module" })), dB = qn({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), pB = qn({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), gB = qn({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), mB = qn({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), vB = qn({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), bB = qn({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), yB = qn({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), wB = qn({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), xB = qn({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), _B = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: dB,
  base32hex: vB,
  base32hexpad: yB,
  base32hexpadupper: wB,
  base32hexupper: bB,
  base32pad: gB,
  base32padupper: mB,
  base32upper: pB,
  base32z: xB
}, Symbol.toStringTag, { value: "Module" })), EB = Hl({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), SB = Hl({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), AB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: EB,
  base36upper: SB
}, Symbol.toStringTag, { value: "Module" })), PB = Hl({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), MB = Hl({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), IB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: PB,
  base58flickr: MB
}, Symbol.toStringTag, { value: "Module" })), CB = qn({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), TB = qn({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), RB = qn({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), DB = qn({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), OB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: CB,
  base64pad: TB,
  base64url: RB,
  base64urlpad: DB
}, Symbol.toStringTag, { value: "Module" })), F4 = Array.from(""), NB = F4.reduce((t, e, r) => (t[r] = e, t), []), LB = F4.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function kB(t) {
  return t.reduce((e, r) => (e += NB[r], e), "");
}
function $B(t) {
  const e = [];
  for (const r of t) {
    const n = LB[r.codePointAt(0)];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const BB = q0({
  prefix: "",
  name: "base256emoji",
  encode: kB,
  decode: $B
}), FB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: BB
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const nx = {
  ...nB,
  ...sB,
  ...aB,
  ...uB,
  ...hB,
  ..._B,
  ...AB,
  ...IB,
  ...OB,
  ...FB
};
function j4(t, e, r, n) {
  return {
    name: t,
    prefix: e,
    encoder: {
      name: t,
      prefix: e,
      encode: r
    },
    decoder: { decode: n }
  };
}
const ix = j4("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), Xg = j4("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++)
    e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = $4(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = t.charCodeAt(r);
  return e;
}), U4 = {
  utf8: ix,
  "utf-8": ix,
  hex: nx.base16,
  latin1: Xg,
  ascii: Xg,
  binary: Xg,
  ...nx
};
function On(t, e = "utf8") {
  const r = U4[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8") : r.encoder.encode(t).substring(1);
}
function Rn(t, e = "utf8") {
  const r = U4[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t, "utf8") : r.decoder.decode(`${r.prefix}${t}`);
}
function sx(t) {
  return lc(On(Rn(t, U0), L4));
}
function t0(t) {
  return On(Rn(Bo(t), L4), U0);
}
function q4(t) {
  const e = Rn(q$, rx), r = U$ + On(Sd([e, t]), rx);
  return [F$, j$, r].join(B$);
}
function jB(t) {
  return On(t, U0);
}
function UB(t) {
  return Rn(t, U0);
}
function qB(t) {
  return Rn([t0(t.header), t0(t.payload)].join(e0), k4);
}
function zB(t) {
  return [
    t0(t.header),
    t0(t.payload),
    jB(t.signature)
  ].join(e0);
}
function v1(t) {
  const e = t.split(e0), r = sx(e[0]), n = sx(e[1]), i = UB(e[2]), s = Rn(e.slice(0, 2).join(e0), k4);
  return { header: r, payload: n, signature: i, data: s };
}
function ox(t = Ca.randomBytes(z$)) {
  return Bv.generateKeyPairFromSeed(t);
}
async function WB(t, e, r, n, i = mt.fromMiliseconds(Date.now())) {
  const s = { alg: k$, typ: $$ }, o = q4(n.publicKey), a = i + r, u = { iss: o, sub: t, aud: e, iat: i, exp: a }, l = qB({ header: s, payload: u }), d = Bv.sign(n.secretKey, l);
  return zB({ header: s, payload: u, signature: d });
}
var ax = function(t, e, r) {
  if (r || arguments.length === 2) for (var n = 0, i = e.length, s; n < i; n++)
    (s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
  return t.concat(s || Array.prototype.slice.call(e));
}, HB = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e, r, n) {
      this.name = e, this.version = r, this.os = n, this.type = "browser";
    }
    return t;
  }()
), KB = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e) {
      this.version = e, this.type = "node", this.name = "node", this.os = process.platform;
    }
    return t;
  }()
), VB = (
  /** @class */
  /* @__PURE__ */ function() {
    function t(e, r, n, i) {
      this.name = e, this.version = r, this.os = n, this.bot = i, this.type = "bot-device";
    }
    return t;
  }()
), GB = (
  /** @class */
  /* @__PURE__ */ function() {
    function t() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return t;
  }()
), YB = (
  /** @class */
  /* @__PURE__ */ function() {
    function t() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return t;
  }()
), JB = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, XB = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, cx = 3, ZB = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", JB]
], ux = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function QB(t) {
  return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new YB() : typeof navigator < "u" ? tF(navigator.userAgent) : nF();
}
function eF(t) {
  return t !== "" && ZB.reduce(function(e, r) {
    var n = r[0], i = r[1];
    if (e)
      return e;
    var s = i.exec(t);
    return !!s && [n, s];
  }, !1);
}
function tF(t) {
  var e = eF(t);
  if (!e)
    return null;
  var r = e[0], n = e[1];
  if (r === "searchbot")
    return new GB();
  var i = n[1] && n[1].split(".").join("_").split("_").slice(0, 3);
  i ? i.length < cx && (i = ax(ax([], i, !0), iF(cx - i.length), !0)) : i = [];
  var s = i.join("."), o = rF(t), a = XB.exec(t);
  return a && a[1] ? new VB(r, s, o, a[1]) : new HB(r, s, o);
}
function rF(t) {
  for (var e = 0, r = ux.length; e < r; e++) {
    var n = ux[e], i = n[0], s = n[1], o = s.exec(t);
    if (o)
      return i;
  }
  return null;
}
function nF() {
  var t = typeof process < "u" && process.version;
  return t ? new KB(process.version.slice(1)) : null;
}
function iF(t) {
  for (var e = [], r = 0; r < t; r++)
    e.push("0");
  return e;
}
var Wr = {};
Object.defineProperty(Wr, "__esModule", { value: !0 });
Wr.getLocalStorage = Wr.getLocalStorageOrThrow = Wr.getCrypto = Wr.getCryptoOrThrow = z4 = Wr.getLocation = Wr.getLocationOrThrow = Fv = Wr.getNavigator = Wr.getNavigatorOrThrow = Kl = Wr.getDocument = Wr.getDocumentOrThrow = Wr.getFromWindowOrThrow = Wr.getFromWindow = void 0;
function yc(t) {
  let e;
  return typeof window < "u" && typeof window[t] < "u" && (e = window[t]), e;
}
Wr.getFromWindow = yc;
function Nu(t) {
  const e = yc(t);
  if (!e)
    throw new Error(`${t} is not defined in Window`);
  return e;
}
Wr.getFromWindowOrThrow = Nu;
function sF() {
  return Nu("document");
}
Wr.getDocumentOrThrow = sF;
function oF() {
  return yc("document");
}
var Kl = Wr.getDocument = oF;
function aF() {
  return Nu("navigator");
}
Wr.getNavigatorOrThrow = aF;
function cF() {
  return yc("navigator");
}
var Fv = Wr.getNavigator = cF;
function uF() {
  return Nu("location");
}
Wr.getLocationOrThrow = uF;
function fF() {
  return yc("location");
}
var z4 = Wr.getLocation = fF;
function lF() {
  return Nu("crypto");
}
Wr.getCryptoOrThrow = lF;
function hF() {
  return yc("crypto");
}
Wr.getCrypto = hF;
function dF() {
  return Nu("localStorage");
}
Wr.getLocalStorageOrThrow = dF;
function pF() {
  return yc("localStorage");
}
Wr.getLocalStorage = pF;
var jv = {};
Object.defineProperty(jv, "__esModule", { value: !0 });
var W4 = jv.getWindowMetadata = void 0;
const fx = Wr;
function gF() {
  let t, e;
  try {
    t = fx.getDocumentOrThrow(), e = fx.getLocationOrThrow();
  } catch {
    return null;
  }
  function r() {
    const p = t.getElementsByTagName("link"), w = [];
    for (let A = 0; A < p.length; A++) {
      const P = p[A], N = P.getAttribute("rel");
      if (N && N.toLowerCase().indexOf("icon") > -1) {
        const L = P.getAttribute("href");
        if (L)
          if (L.toLowerCase().indexOf("https:") === -1 && L.toLowerCase().indexOf("http:") === -1 && L.indexOf("//") !== 0) {
            let $ = e.protocol + "//" + e.host;
            if (L.indexOf("/") === 0)
              $ += L;
            else {
              const B = e.pathname.split("/");
              B.pop();
              const H = B.join("/");
              $ += H + "/" + L;
            }
            w.push($);
          } else if (L.indexOf("//") === 0) {
            const $ = e.protocol + L;
            w.push($);
          } else
            w.push(L);
      }
    }
    return w;
  }
  function n(...p) {
    const w = t.getElementsByTagName("meta");
    for (let A = 0; A < w.length; A++) {
      const P = w[A], N = ["itemprop", "property", "name"].map((L) => P.getAttribute(L)).filter((L) => L ? p.includes(L) : !1);
      if (N.length && N) {
        const L = P.getAttribute("content");
        if (L)
          return L;
      }
    }
    return "";
  }
  function i() {
    let p = n("name", "og:site_name", "og:title", "twitter:title");
    return p || (p = t.title), p;
  }
  function s() {
    return n("description", "og:description", "twitter:description", "keywords");
  }
  const o = i(), a = s(), u = e.origin, l = r();
  return {
    description: a,
    url: u,
    icons: l,
    name: o
  };
}
W4 = jv.getWindowMetadata = gF;
var xl = {}, mF = (t) => encodeURIComponent(t).replace(/[!'()*]/g, (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`), H4 = "%[a-f0-9]{2}", lx = new RegExp("(" + H4 + ")|([^%]+?)", "gi"), hx = new RegExp("(" + H4 + ")+", "gi");
function b1(t, e) {
  try {
    return [decodeURIComponent(t.join(""))];
  } catch {
  }
  if (t.length === 1)
    return t;
  e = e || 1;
  var r = t.slice(0, e), n = t.slice(e);
  return Array.prototype.concat.call([], b1(r), b1(n));
}
function vF(t) {
  try {
    return decodeURIComponent(t);
  } catch {
    for (var e = t.match(lx) || [], r = 1; r < e.length; r++)
      t = b1(e, r).join(""), e = t.match(lx) || [];
    return t;
  }
}
function bF(t) {
  for (var e = {
    "%FE%FF": "",
    "%FF%FE": ""
  }, r = hx.exec(t); r; ) {
    try {
      e[r[0]] = decodeURIComponent(r[0]);
    } catch {
      var n = vF(r[0]);
      n !== r[0] && (e[r[0]] = n);
    }
    r = hx.exec(t);
  }
  e["%C2"] = "";
  for (var i = Object.keys(e), s = 0; s < i.length; s++) {
    var o = i[s];
    t = t.replace(new RegExp(o, "g"), e[o]);
  }
  return t;
}
var yF = function(t) {
  if (typeof t != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof t + "`");
  try {
    return t = t.replace(/\+/g, " "), decodeURIComponent(t);
  } catch {
    return bF(t);
  }
}, wF = (t, e) => {
  if (!(typeof t == "string" && typeof e == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (e === "")
    return [t];
  const r = t.indexOf(e);
  return r === -1 ? [t] : [
    t.slice(0, r),
    t.slice(r + e.length)
  ];
}, xF = function(t, e) {
  for (var r = {}, n = Object.keys(t), i = Array.isArray(e), s = 0; s < n.length; s++) {
    var o = n[s], a = t[o];
    (i ? e.indexOf(o) !== -1 : e(o, a, t)) && (r[o] = a);
  }
  return r;
};
(function(t) {
  const e = mF, r = yF, n = wF, i = xF, s = (B) => B == null, o = Symbol("encodeFragmentIdentifier");
  function a(B) {
    switch (B.arrayFormat) {
      case "index":
        return (H) => (W, V) => {
          const te = W.length;
          return V === void 0 || B.skipNull && V === null || B.skipEmptyString && V === "" ? W : V === null ? [...W, [d(H, B), "[", te, "]"].join("")] : [
            ...W,
            [d(H, B), "[", d(te, B), "]=", d(V, B)].join("")
          ];
        };
      case "bracket":
        return (H) => (W, V) => V === void 0 || B.skipNull && V === null || B.skipEmptyString && V === "" ? W : V === null ? [...W, [d(H, B), "[]"].join("")] : [...W, [d(H, B), "[]=", d(V, B)].join("")];
      case "colon-list-separator":
        return (H) => (W, V) => V === void 0 || B.skipNull && V === null || B.skipEmptyString && V === "" ? W : V === null ? [...W, [d(H, B), ":list="].join("")] : [...W, [d(H, B), ":list=", d(V, B)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const H = B.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (W) => (V, te) => te === void 0 || B.skipNull && te === null || B.skipEmptyString && te === "" ? V : (te = te === null ? "" : te, V.length === 0 ? [[d(W, B), H, d(te, B)].join("")] : [[V, d(te, B)].join(B.arrayFormatSeparator)]);
      }
      default:
        return (H) => (W, V) => V === void 0 || B.skipNull && V === null || B.skipEmptyString && V === "" ? W : V === null ? [...W, d(H, B)] : [...W, [d(H, B), "=", d(V, B)].join("")];
    }
  }
  function u(B) {
    let H;
    switch (B.arrayFormat) {
      case "index":
        return (W, V, te) => {
          if (H = /\[(\d*)\]$/.exec(W), W = W.replace(/\[\d*\]$/, ""), !H) {
            te[W] = V;
            return;
          }
          te[W] === void 0 && (te[W] = {}), te[W][H[1]] = V;
        };
      case "bracket":
        return (W, V, te) => {
          if (H = /(\[\])$/.exec(W), W = W.replace(/\[\]$/, ""), !H) {
            te[W] = V;
            return;
          }
          if (te[W] === void 0) {
            te[W] = [V];
            return;
          }
          te[W] = [].concat(te[W], V);
        };
      case "colon-list-separator":
        return (W, V, te) => {
          if (H = /(:list)$/.exec(W), W = W.replace(/:list$/, ""), !H) {
            te[W] = V;
            return;
          }
          if (te[W] === void 0) {
            te[W] = [V];
            return;
          }
          te[W] = [].concat(te[W], V);
        };
      case "comma":
      case "separator":
        return (W, V, te) => {
          const R = typeof V == "string" && V.includes(B.arrayFormatSeparator), K = typeof V == "string" && !R && p(V, B).includes(B.arrayFormatSeparator);
          V = K ? p(V, B) : V;
          const ge = R || K ? V.split(B.arrayFormatSeparator).map((Ee) => p(Ee, B)) : V === null ? V : p(V, B);
          te[W] = ge;
        };
      case "bracket-separator":
        return (W, V, te) => {
          const R = /(\[\])$/.test(W);
          if (W = W.replace(/\[\]$/, ""), !R) {
            te[W] = V && p(V, B);
            return;
          }
          const K = V === null ? [] : V.split(B.arrayFormatSeparator).map((ge) => p(ge, B));
          if (te[W] === void 0) {
            te[W] = K;
            return;
          }
          te[W] = [].concat(te[W], K);
        };
      default:
        return (W, V, te) => {
          if (te[W] === void 0) {
            te[W] = V;
            return;
          }
          te[W] = [].concat(te[W], V);
        };
    }
  }
  function l(B) {
    if (typeof B != "string" || B.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  function d(B, H) {
    return H.encode ? H.strict ? e(B) : encodeURIComponent(B) : B;
  }
  function p(B, H) {
    return H.decode ? r(B) : B;
  }
  function w(B) {
    return Array.isArray(B) ? B.sort() : typeof B == "object" ? w(Object.keys(B)).sort((H, W) => Number(H) - Number(W)).map((H) => B[H]) : B;
  }
  function A(B) {
    const H = B.indexOf("#");
    return H !== -1 && (B = B.slice(0, H)), B;
  }
  function P(B) {
    let H = "";
    const W = B.indexOf("#");
    return W !== -1 && (H = B.slice(W)), H;
  }
  function N(B) {
    B = A(B);
    const H = B.indexOf("?");
    return H === -1 ? "" : B.slice(H + 1);
  }
  function L(B, H) {
    return H.parseNumbers && !Number.isNaN(Number(B)) && typeof B == "string" && B.trim() !== "" ? B = Number(B) : H.parseBooleans && B !== null && (B.toLowerCase() === "true" || B.toLowerCase() === "false") && (B = B.toLowerCase() === "true"), B;
  }
  function $(B, H) {
    H = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, H), l(H.arrayFormatSeparator);
    const W = u(H), V = /* @__PURE__ */ Object.create(null);
    if (typeof B != "string" || (B = B.trim().replace(/^[?#&]/, ""), !B))
      return V;
    for (const te of B.split("&")) {
      if (te === "")
        continue;
      let [R, K] = n(H.decode ? te.replace(/\+/g, " ") : te, "=");
      K = K === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(H.arrayFormat) ? K : p(K, H), W(p(R, H), K, V);
    }
    for (const te of Object.keys(V)) {
      const R = V[te];
      if (typeof R == "object" && R !== null)
        for (const K of Object.keys(R))
          R[K] = L(R[K], H);
      else
        V[te] = L(R, H);
    }
    return H.sort === !1 ? V : (H.sort === !0 ? Object.keys(V).sort() : Object.keys(V).sort(H.sort)).reduce((te, R) => {
      const K = V[R];
      return K && typeof K == "object" && !Array.isArray(K) ? te[R] = w(K) : te[R] = K, te;
    }, /* @__PURE__ */ Object.create(null));
  }
  t.extract = N, t.parse = $, t.stringify = (B, H) => {
    if (!B)
      return "";
    H = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, H), l(H.arrayFormatSeparator);
    const W = (K) => H.skipNull && s(B[K]) || H.skipEmptyString && B[K] === "", V = a(H), te = {};
    for (const K of Object.keys(B))
      W(K) || (te[K] = B[K]);
    const R = Object.keys(te);
    return H.sort !== !1 && R.sort(H.sort), R.map((K) => {
      const ge = B[K];
      return ge === void 0 ? "" : ge === null ? d(K, H) : Array.isArray(ge) ? ge.length === 0 && H.arrayFormat === "bracket-separator" ? d(K, H) + "[]" : ge.reduce(V(K), []).join("&") : d(K, H) + "=" + d(ge, H);
    }).filter((K) => K.length > 0).join("&");
  }, t.parseUrl = (B, H) => {
    H = Object.assign({
      decode: !0
    }, H);
    const [W, V] = n(B, "#");
    return Object.assign(
      {
        url: W.split("?")[0] || "",
        query: $(N(B), H)
      },
      H && H.parseFragmentIdentifier && V ? { fragmentIdentifier: p(V, H) } : {}
    );
  }, t.stringifyUrl = (B, H) => {
    H = Object.assign({
      encode: !0,
      strict: !0,
      [o]: !0
    }, H);
    const W = A(B.url).split("?")[0] || "", V = t.extract(B.url), te = t.parse(V, { sort: !1 }), R = Object.assign(te, B.query);
    let K = t.stringify(R, H);
    K && (K = `?${K}`);
    let ge = P(B.url);
    return B.fragmentIdentifier && (ge = `#${H[o] ? d(B.fragmentIdentifier, H) : B.fragmentIdentifier}`), `${W}${K}${ge}`;
  }, t.pick = (B, H, W) => {
    W = Object.assign({
      parseFragmentIdentifier: !0,
      [o]: !1
    }, W);
    const { url: V, query: te, fragmentIdentifier: R } = t.parseUrl(B, W);
    return t.stringifyUrl({
      url: V,
      query: i(te, H),
      fragmentIdentifier: R
    }, W);
  }, t.exclude = (B, H, W) => {
    const V = Array.isArray(H) ? (te) => !H.includes(te) : (te, R) => !H(te, R);
    return t.pick(B, V, W);
  };
})(xl);
var K4 = { exports: {} };
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
(function(t) {
  (function() {
    var e = "input is invalid type", r = "finalize already called", n = typeof window == "object", i = n ? window : {};
    i.JS_SHA3_NO_WINDOW && (n = !1);
    var s = !n && typeof self == "object", o = !i.JS_SHA3_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node;
    o ? i = gn : s && (i = self);
    var a = !i.JS_SHA3_NO_COMMON_JS && !0 && t.exports, u = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", l = "0123456789abcdef".split(""), d = [31, 7936, 2031616, 520093696], p = [4, 1024, 262144, 67108864], w = [1, 256, 65536, 16777216], A = [6, 1536, 393216, 100663296], P = [0, 8, 16, 24], N = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ], L = [224, 256, 384, 512], $ = [128, 256], B = ["hex", "buffer", "arrayBuffer", "array", "digest"], H = {
      128: 168,
      256: 136
    };
    (i.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(D) {
      return Object.prototype.toString.call(D) === "[object Array]";
    }), u && (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(D) {
      return typeof D == "object" && D.buffer && D.buffer.constructor === ArrayBuffer;
    });
    for (var W = function(D, oe, Z) {
      return function(J) {
        return new I(D, oe, D).update(J)[Z]();
      };
    }, V = function(D, oe, Z) {
      return function(J, Q) {
        return new I(D, oe, Q).update(J)[Z]();
      };
    }, te = function(D, oe, Z) {
      return function(J, Q, T, X) {
        return f["cshake" + D].update(J, Q, T, X)[Z]();
      };
    }, R = function(D, oe, Z) {
      return function(J, Q, T, X) {
        return f["kmac" + D].update(J, Q, T, X)[Z]();
      };
    }, K = function(D, oe, Z, J) {
      for (var Q = 0; Q < B.length; ++Q) {
        var T = B[Q];
        D[T] = oe(Z, J, T);
      }
      return D;
    }, ge = function(D, oe) {
      var Z = W(D, oe, "hex");
      return Z.create = function() {
        return new I(D, oe, D);
      }, Z.update = function(J) {
        return Z.create().update(J);
      }, K(Z, W, D, oe);
    }, Ee = function(D, oe) {
      var Z = V(D, oe, "hex");
      return Z.create = function(J) {
        return new I(D, oe, J);
      }, Z.update = function(J, Q) {
        return Z.create(Q).update(J);
      }, K(Z, V, D, oe);
    }, Y = function(D, oe) {
      var Z = H[D], J = te(D, oe, "hex");
      return J.create = function(Q, T, X) {
        return !T && !X ? f["shake" + D].create(Q) : new I(D, oe, Q).bytepad([T, X], Z);
      }, J.update = function(Q, T, X, re) {
        return J.create(T, X, re).update(Q);
      }, K(J, te, D, oe);
    }, S = function(D, oe) {
      var Z = H[D], J = R(D, oe, "hex");
      return J.create = function(Q, T, X) {
        return new F(D, oe, T).bytepad(["KMAC", X], Z).bytepad([Q], Z);
      }, J.update = function(Q, T, X, re) {
        return J.create(Q, X, re).update(T);
      }, K(J, R, D, oe);
    }, m = [
      { name: "keccak", padding: w, bits: L, createMethod: ge },
      { name: "sha3", padding: A, bits: L, createMethod: ge },
      { name: "shake", padding: d, bits: $, createMethod: Ee },
      { name: "cshake", padding: p, bits: $, createMethod: Y },
      { name: "kmac", padding: p, bits: $, createMethod: S }
    ], f = {}, g = [], b = 0; b < m.length; ++b)
      for (var x = m[b], _ = x.bits, E = 0; E < _.length; ++E) {
        var v = x.name + "_" + _[E];
        if (g.push(v), f[v] = x.createMethod(_[E], x.padding), x.name !== "sha3") {
          var M = x.name + _[E];
          g.push(M), f[M] = f[v];
        }
      }
    function I(D, oe, Z) {
      this.blocks = [], this.s = [], this.padding = oe, this.outputBits = Z, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (D << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = Z >> 5, this.extraBytes = (Z & 31) >> 3;
      for (var J = 0; J < 50; ++J)
        this.s[J] = 0;
    }
    I.prototype.update = function(D) {
      if (this.finalized)
        throw new Error(r);
      var oe, Z = typeof D;
      if (Z !== "string") {
        if (Z === "object") {
          if (D === null)
            throw new Error(e);
          if (u && D.constructor === ArrayBuffer)
            D = new Uint8Array(D);
          else if (!Array.isArray(D) && (!u || !ArrayBuffer.isView(D)))
            throw new Error(e);
        } else
          throw new Error(e);
        oe = !0;
      }
      for (var J = this.blocks, Q = this.byteCount, T = D.length, X = this.blockCount, re = 0, pe = this.s, ie, ue; re < T; ) {
        if (this.reset)
          for (this.reset = !1, J[0] = this.block, ie = 1; ie < X + 1; ++ie)
            J[ie] = 0;
        if (oe)
          for (ie = this.start; re < T && ie < Q; ++re)
            J[ie >> 2] |= D[re] << P[ie++ & 3];
        else
          for (ie = this.start; re < T && ie < Q; ++re)
            ue = D.charCodeAt(re), ue < 128 ? J[ie >> 2] |= ue << P[ie++ & 3] : ue < 2048 ? (J[ie >> 2] |= (192 | ue >> 6) << P[ie++ & 3], J[ie >> 2] |= (128 | ue & 63) << P[ie++ & 3]) : ue < 55296 || ue >= 57344 ? (J[ie >> 2] |= (224 | ue >> 12) << P[ie++ & 3], J[ie >> 2] |= (128 | ue >> 6 & 63) << P[ie++ & 3], J[ie >> 2] |= (128 | ue & 63) << P[ie++ & 3]) : (ue = 65536 + ((ue & 1023) << 10 | D.charCodeAt(++re) & 1023), J[ie >> 2] |= (240 | ue >> 18) << P[ie++ & 3], J[ie >> 2] |= (128 | ue >> 12 & 63) << P[ie++ & 3], J[ie >> 2] |= (128 | ue >> 6 & 63) << P[ie++ & 3], J[ie >> 2] |= (128 | ue & 63) << P[ie++ & 3]);
        if (this.lastByteIndex = ie, ie >= Q) {
          for (this.start = ie - Q, this.block = J[X], ie = 0; ie < X; ++ie)
            pe[ie] ^= J[ie];
          ce(pe), this.reset = !0;
        } else
          this.start = ie;
      }
      return this;
    }, I.prototype.encode = function(D, oe) {
      var Z = D & 255, J = 1, Q = [Z];
      for (D = D >> 8, Z = D & 255; Z > 0; )
        Q.unshift(Z), D = D >> 8, Z = D & 255, ++J;
      return oe ? Q.push(J) : Q.unshift(J), this.update(Q), Q.length;
    }, I.prototype.encodeString = function(D) {
      var oe, Z = typeof D;
      if (Z !== "string") {
        if (Z === "object") {
          if (D === null)
            throw new Error(e);
          if (u && D.constructor === ArrayBuffer)
            D = new Uint8Array(D);
          else if (!Array.isArray(D) && (!u || !ArrayBuffer.isView(D)))
            throw new Error(e);
        } else
          throw new Error(e);
        oe = !0;
      }
      var J = 0, Q = D.length;
      if (oe)
        J = Q;
      else
        for (var T = 0; T < D.length; ++T) {
          var X = D.charCodeAt(T);
          X < 128 ? J += 1 : X < 2048 ? J += 2 : X < 55296 || X >= 57344 ? J += 3 : (X = 65536 + ((X & 1023) << 10 | D.charCodeAt(++T) & 1023), J += 4);
        }
      return J += this.encode(J * 8), this.update(D), J;
    }, I.prototype.bytepad = function(D, oe) {
      for (var Z = this.encode(oe), J = 0; J < D.length; ++J)
        Z += this.encodeString(D[J]);
      var Q = oe - Z % oe, T = [];
      return T.length = Q, this.update(T), this;
    }, I.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var D = this.blocks, oe = this.lastByteIndex, Z = this.blockCount, J = this.s;
        if (D[oe >> 2] |= this.padding[oe & 3], this.lastByteIndex === this.byteCount)
          for (D[0] = D[Z], oe = 1; oe < Z + 1; ++oe)
            D[oe] = 0;
        for (D[Z - 1] |= 2147483648, oe = 0; oe < Z; ++oe)
          J[oe] ^= D[oe];
        ce(J);
      }
    }, I.prototype.toString = I.prototype.hex = function() {
      this.finalize();
      for (var D = this.blockCount, oe = this.s, Z = this.outputBlocks, J = this.extraBytes, Q = 0, T = 0, X = "", re; T < Z; ) {
        for (Q = 0; Q < D && T < Z; ++Q, ++T)
          re = oe[Q], X += l[re >> 4 & 15] + l[re & 15] + l[re >> 12 & 15] + l[re >> 8 & 15] + l[re >> 20 & 15] + l[re >> 16 & 15] + l[re >> 28 & 15] + l[re >> 24 & 15];
        T % D === 0 && (ce(oe), Q = 0);
      }
      return J && (re = oe[Q], X += l[re >> 4 & 15] + l[re & 15], J > 1 && (X += l[re >> 12 & 15] + l[re >> 8 & 15]), J > 2 && (X += l[re >> 20 & 15] + l[re >> 16 & 15])), X;
    }, I.prototype.arrayBuffer = function() {
      this.finalize();
      var D = this.blockCount, oe = this.s, Z = this.outputBlocks, J = this.extraBytes, Q = 0, T = 0, X = this.outputBits >> 3, re;
      J ? re = new ArrayBuffer(Z + 1 << 2) : re = new ArrayBuffer(X);
      for (var pe = new Uint32Array(re); T < Z; ) {
        for (Q = 0; Q < D && T < Z; ++Q, ++T)
          pe[T] = oe[Q];
        T % D === 0 && ce(oe);
      }
      return J && (pe[Q] = oe[Q], re = re.slice(0, X)), re;
    }, I.prototype.buffer = I.prototype.arrayBuffer, I.prototype.digest = I.prototype.array = function() {
      this.finalize();
      for (var D = this.blockCount, oe = this.s, Z = this.outputBlocks, J = this.extraBytes, Q = 0, T = 0, X = [], re, pe; T < Z; ) {
        for (Q = 0; Q < D && T < Z; ++Q, ++T)
          re = T << 2, pe = oe[Q], X[re] = pe & 255, X[re + 1] = pe >> 8 & 255, X[re + 2] = pe >> 16 & 255, X[re + 3] = pe >> 24 & 255;
        T % D === 0 && ce(oe);
      }
      return J && (re = T << 2, pe = oe[Q], X[re] = pe & 255, J > 1 && (X[re + 1] = pe >> 8 & 255), J > 2 && (X[re + 2] = pe >> 16 & 255)), X;
    };
    function F(D, oe, Z) {
      I.call(this, D, oe, Z);
    }
    F.prototype = new I(), F.prototype.finalize = function() {
      return this.encode(this.outputBits, !0), I.prototype.finalize.call(this);
    };
    var ce = function(D) {
      var oe, Z, J, Q, T, X, re, pe, ie, ue, ve, Pe, De, Ce, $e, Me, Ne, Ke, Le, qe, ze, _e, Ze, at, ke, Qe, tt, Ye, dt, lt, ct, qt, Jt, Et, er, Xt, Dt, kt, Ct, gt, Rt, Nt, vt, $t, Ft, rt, Bt, k, U, z, C, G, j, se, de, xe, Te, Re, nt, je, pt, it, et;
      for (J = 0; J < 48; J += 2)
        Q = D[0] ^ D[10] ^ D[20] ^ D[30] ^ D[40], T = D[1] ^ D[11] ^ D[21] ^ D[31] ^ D[41], X = D[2] ^ D[12] ^ D[22] ^ D[32] ^ D[42], re = D[3] ^ D[13] ^ D[23] ^ D[33] ^ D[43], pe = D[4] ^ D[14] ^ D[24] ^ D[34] ^ D[44], ie = D[5] ^ D[15] ^ D[25] ^ D[35] ^ D[45], ue = D[6] ^ D[16] ^ D[26] ^ D[36] ^ D[46], ve = D[7] ^ D[17] ^ D[27] ^ D[37] ^ D[47], Pe = D[8] ^ D[18] ^ D[28] ^ D[38] ^ D[48], De = D[9] ^ D[19] ^ D[29] ^ D[39] ^ D[49], oe = Pe ^ (X << 1 | re >>> 31), Z = De ^ (re << 1 | X >>> 31), D[0] ^= oe, D[1] ^= Z, D[10] ^= oe, D[11] ^= Z, D[20] ^= oe, D[21] ^= Z, D[30] ^= oe, D[31] ^= Z, D[40] ^= oe, D[41] ^= Z, oe = Q ^ (pe << 1 | ie >>> 31), Z = T ^ (ie << 1 | pe >>> 31), D[2] ^= oe, D[3] ^= Z, D[12] ^= oe, D[13] ^= Z, D[22] ^= oe, D[23] ^= Z, D[32] ^= oe, D[33] ^= Z, D[42] ^= oe, D[43] ^= Z, oe = X ^ (ue << 1 | ve >>> 31), Z = re ^ (ve << 1 | ue >>> 31), D[4] ^= oe, D[5] ^= Z, D[14] ^= oe, D[15] ^= Z, D[24] ^= oe, D[25] ^= Z, D[34] ^= oe, D[35] ^= Z, D[44] ^= oe, D[45] ^= Z, oe = pe ^ (Pe << 1 | De >>> 31), Z = ie ^ (De << 1 | Pe >>> 31), D[6] ^= oe, D[7] ^= Z, D[16] ^= oe, D[17] ^= Z, D[26] ^= oe, D[27] ^= Z, D[36] ^= oe, D[37] ^= Z, D[46] ^= oe, D[47] ^= Z, oe = ue ^ (Q << 1 | T >>> 31), Z = ve ^ (T << 1 | Q >>> 31), D[8] ^= oe, D[9] ^= Z, D[18] ^= oe, D[19] ^= Z, D[28] ^= oe, D[29] ^= Z, D[38] ^= oe, D[39] ^= Z, D[48] ^= oe, D[49] ^= Z, Ce = D[0], $e = D[1], rt = D[11] << 4 | D[10] >>> 28, Bt = D[10] << 4 | D[11] >>> 28, Ye = D[20] << 3 | D[21] >>> 29, dt = D[21] << 3 | D[20] >>> 29, je = D[31] << 9 | D[30] >>> 23, pt = D[30] << 9 | D[31] >>> 23, Nt = D[40] << 18 | D[41] >>> 14, vt = D[41] << 18 | D[40] >>> 14, Et = D[2] << 1 | D[3] >>> 31, er = D[3] << 1 | D[2] >>> 31, Me = D[13] << 12 | D[12] >>> 20, Ne = D[12] << 12 | D[13] >>> 20, k = D[22] << 10 | D[23] >>> 22, U = D[23] << 10 | D[22] >>> 22, lt = D[33] << 13 | D[32] >>> 19, ct = D[32] << 13 | D[33] >>> 19, it = D[42] << 2 | D[43] >>> 30, et = D[43] << 2 | D[42] >>> 30, se = D[5] << 30 | D[4] >>> 2, de = D[4] << 30 | D[5] >>> 2, Xt = D[14] << 6 | D[15] >>> 26, Dt = D[15] << 6 | D[14] >>> 26, Ke = D[25] << 11 | D[24] >>> 21, Le = D[24] << 11 | D[25] >>> 21, z = D[34] << 15 | D[35] >>> 17, C = D[35] << 15 | D[34] >>> 17, qt = D[45] << 29 | D[44] >>> 3, Jt = D[44] << 29 | D[45] >>> 3, at = D[6] << 28 | D[7] >>> 4, ke = D[7] << 28 | D[6] >>> 4, xe = D[17] << 23 | D[16] >>> 9, Te = D[16] << 23 | D[17] >>> 9, kt = D[26] << 25 | D[27] >>> 7, Ct = D[27] << 25 | D[26] >>> 7, qe = D[36] << 21 | D[37] >>> 11, ze = D[37] << 21 | D[36] >>> 11, G = D[47] << 24 | D[46] >>> 8, j = D[46] << 24 | D[47] >>> 8, $t = D[8] << 27 | D[9] >>> 5, Ft = D[9] << 27 | D[8] >>> 5, Qe = D[18] << 20 | D[19] >>> 12, tt = D[19] << 20 | D[18] >>> 12, Re = D[29] << 7 | D[28] >>> 25, nt = D[28] << 7 | D[29] >>> 25, gt = D[38] << 8 | D[39] >>> 24, Rt = D[39] << 8 | D[38] >>> 24, _e = D[48] << 14 | D[49] >>> 18, Ze = D[49] << 14 | D[48] >>> 18, D[0] = Ce ^ ~Me & Ke, D[1] = $e ^ ~Ne & Le, D[10] = at ^ ~Qe & Ye, D[11] = ke ^ ~tt & dt, D[20] = Et ^ ~Xt & kt, D[21] = er ^ ~Dt & Ct, D[30] = $t ^ ~rt & k, D[31] = Ft ^ ~Bt & U, D[40] = se ^ ~xe & Re, D[41] = de ^ ~Te & nt, D[2] = Me ^ ~Ke & qe, D[3] = Ne ^ ~Le & ze, D[12] = Qe ^ ~Ye & lt, D[13] = tt ^ ~dt & ct, D[22] = Xt ^ ~kt & gt, D[23] = Dt ^ ~Ct & Rt, D[32] = rt ^ ~k & z, D[33] = Bt ^ ~U & C, D[42] = xe ^ ~Re & je, D[43] = Te ^ ~nt & pt, D[4] = Ke ^ ~qe & _e, D[5] = Le ^ ~ze & Ze, D[14] = Ye ^ ~lt & qt, D[15] = dt ^ ~ct & Jt, D[24] = kt ^ ~gt & Nt, D[25] = Ct ^ ~Rt & vt, D[34] = k ^ ~z & G, D[35] = U ^ ~C & j, D[44] = Re ^ ~je & it, D[45] = nt ^ ~pt & et, D[6] = qe ^ ~_e & Ce, D[7] = ze ^ ~Ze & $e, D[16] = lt ^ ~qt & at, D[17] = ct ^ ~Jt & ke, D[26] = gt ^ ~Nt & Et, D[27] = Rt ^ ~vt & er, D[36] = z ^ ~G & $t, D[37] = C ^ ~j & Ft, D[46] = je ^ ~it & se, D[47] = pt ^ ~et & de, D[8] = _e ^ ~Ce & Me, D[9] = Ze ^ ~$e & Ne, D[18] = qt ^ ~at & Qe, D[19] = Jt ^ ~ke & tt, D[28] = Nt ^ ~Et & Xt, D[29] = vt ^ ~er & Dt, D[38] = G ^ ~$t & rt, D[39] = j ^ ~Ft & Bt, D[48] = it ^ ~se & xe, D[49] = et ^ ~de & Te, D[0] ^= N[J], D[1] ^= N[J + 1];
    };
    if (a)
      t.exports = f;
    else
      for (b = 0; b < g.length; ++b)
        i[g[b]] = f[g[b]];
  })();
})(K4);
var _F = K4.exports;
const EF = /* @__PURE__ */ rs(_F), SF = "logger/5.7.0";
let dx = !1, px = !1;
const Ad = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let gx = Ad.default, Zg = null;
function AF() {
  try {
    const t = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((e) => {
      try {
        if ("test".normalize(e) !== "test")
          throw new Error("bad normalize");
      } catch {
        t.push(e);
      }
    }), t.length)
      throw new Error("missing " + t.join(", "));
    if ("".normalize("NFD") !== "e")
      throw new Error("broken implementation");
  } catch (t) {
    return t.message;
  }
  return null;
}
const mx = AF();
var y1;
(function(t) {
  t.DEBUG = "DEBUG", t.INFO = "INFO", t.WARNING = "WARNING", t.ERROR = "ERROR", t.OFF = "OFF";
})(y1 || (y1 = {}));
var ws;
(function(t) {
  t.UNKNOWN_ERROR = "UNKNOWN_ERROR", t.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", t.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", t.NETWORK_ERROR = "NETWORK_ERROR", t.SERVER_ERROR = "SERVER_ERROR", t.TIMEOUT = "TIMEOUT", t.BUFFER_OVERRUN = "BUFFER_OVERRUN", t.NUMERIC_FAULT = "NUMERIC_FAULT", t.MISSING_NEW = "MISSING_NEW", t.INVALID_ARGUMENT = "INVALID_ARGUMENT", t.MISSING_ARGUMENT = "MISSING_ARGUMENT", t.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", t.CALL_EXCEPTION = "CALL_EXCEPTION", t.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", t.NONCE_EXPIRED = "NONCE_EXPIRED", t.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", t.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", t.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", t.ACTION_REJECTED = "ACTION_REJECTED";
})(ws || (ws = {}));
const vx = "0123456789abcdef";
class Yr {
  constructor(e) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: e,
      writable: !1
    });
  }
  _log(e, r) {
    const n = e.toLowerCase();
    Ad[n] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(gx > Ad[n]) && console.log.apply(console, r);
  }
  debug(...e) {
    this._log(Yr.levels.DEBUG, e);
  }
  info(...e) {
    this._log(Yr.levels.INFO, e);
  }
  warn(...e) {
    this._log(Yr.levels.WARNING, e);
  }
  makeError(e, r, n) {
    if (px)
      return this.makeError("censored error", r, {});
    r || (r = Yr.errors.UNKNOWN_ERROR), n || (n = {});
    const i = [];
    Object.keys(n).forEach((u) => {
      const l = n[u];
      try {
        if (l instanceof Uint8Array) {
          let d = "";
          for (let p = 0; p < l.length; p++)
            d += vx[l[p] >> 4], d += vx[l[p] & 15];
          i.push(u + "=Uint8Array(0x" + d + ")");
        } else
          i.push(u + "=" + JSON.stringify(l));
      } catch {
        i.push(u + "=" + JSON.stringify(n[u].toString()));
      }
    }), i.push(`code=${r}`), i.push(`version=${this.version}`);
    const s = e;
    let o = "";
    switch (r) {
      case ws.NUMERIC_FAULT: {
        o = "NUMERIC_FAULT";
        const u = e;
        switch (u) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            o += "-" + u;
            break;
          case "negative-power":
          case "negative-width":
            o += "-unsupported";
            break;
          case "unbound-bitwise-result":
            o += "-unbound-result";
            break;
        }
        break;
      }
      case ws.CALL_EXCEPTION:
      case ws.INSUFFICIENT_FUNDS:
      case ws.MISSING_NEW:
      case ws.NONCE_EXPIRED:
      case ws.REPLACEMENT_UNDERPRICED:
      case ws.TRANSACTION_REPLACED:
      case ws.UNPREDICTABLE_GAS_LIMIT:
        o = r;
        break;
    }
    o && (e += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), i.length && (e += " (" + i.join(", ") + ")");
    const a = new Error(e);
    return a.reason = s, a.code = r, Object.keys(n).forEach(function(u) {
      a[u] = n[u];
    }), a;
  }
  throwError(e, r, n) {
    throw this.makeError(e, r, n);
  }
  throwArgumentError(e, r, n) {
    return this.throwError(e, Yr.errors.INVALID_ARGUMENT, {
      argument: r,
      value: n
    });
  }
  assert(e, r, n, i) {
    e || this.throwError(r, n, i);
  }
  assertArgument(e, r, n, i) {
    e || this.throwArgumentError(r, n, i);
  }
  checkNormalize(e) {
    mx && this.throwError("platform missing String.prototype.normalize", Yr.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: mx
    });
  }
  checkSafeUint53(e, r) {
    typeof e == "number" && (r == null && (r = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(r, Yr.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: e
    }), e % 1 && this.throwError(r, Yr.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: e
    }));
  }
  checkArgumentCount(e, r, n) {
    n ? n = ": " + n : n = "", e < r && this.throwError("missing argument" + n, Yr.errors.MISSING_ARGUMENT, {
      count: e,
      expectedCount: r
    }), e > r && this.throwError("too many arguments" + n, Yr.errors.UNEXPECTED_ARGUMENT, {
      count: e,
      expectedCount: r
    });
  }
  checkNew(e, r) {
    (e === Object || e == null) && this.throwError("missing new", Yr.errors.MISSING_NEW, { name: r.name });
  }
  checkAbstract(e, r) {
    e === r ? this.throwError("cannot instantiate abstract class " + JSON.stringify(r.name) + " directly; use a sub-class", Yr.errors.UNSUPPORTED_OPERATION, { name: e.name, operation: "new" }) : (e === Object || e == null) && this.throwError("missing new", Yr.errors.MISSING_NEW, { name: r.name });
  }
  static globalLogger() {
    return Zg || (Zg = new Yr(SF)), Zg;
  }
  static setCensorship(e, r) {
    if (!e && r && this.globalLogger().throwError("cannot permanently disable censorship", Yr.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), dx) {
      if (!e)
        return;
      this.globalLogger().throwError("error censorship permanent", Yr.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    px = !!e, dx = !!r;
  }
  static setLogLevel(e) {
    const r = Ad[e.toLowerCase()];
    if (r == null) {
      Yr.globalLogger().warn("invalid log level - " + e);
      return;
    }
    gx = r;
  }
  static from(e) {
    return new Yr(e);
  }
}
Yr.errors = ws;
Yr.levels = y1;
const PF = "bytes/5.7.0", hn = new Yr(PF);
function V4(t) {
  return !!t.toHexString;
}
function fu(t) {
  return t.slice || (t.slice = function() {
    const e = Array.prototype.slice.call(arguments);
    return fu(new Uint8Array(Array.prototype.slice.apply(t, e)));
  }), t;
}
function MF(t) {
  return zs(t) && !(t.length % 2) || Uv(t);
}
function bx(t) {
  return typeof t == "number" && t == t && t % 1 === 0;
}
function Uv(t) {
  if (t == null)
    return !1;
  if (t.constructor === Uint8Array)
    return !0;
  if (typeof t == "string" || !bx(t.length) || t.length < 0)
    return !1;
  for (let e = 0; e < t.length; e++) {
    const r = t[e];
    if (!bx(r) || r < 0 || r >= 256)
      return !1;
  }
  return !0;
}
function wn(t, e) {
  if (e || (e = {}), typeof t == "number") {
    hn.checkSafeUint53(t, "invalid arrayify value");
    const r = [];
    for (; t; )
      r.unshift(t & 255), t = parseInt(String(t / 256));
    return r.length === 0 && r.push(0), fu(new Uint8Array(r));
  }
  if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), V4(t) && (t = t.toHexString()), zs(t)) {
    let r = t.substring(2);
    r.length % 2 && (e.hexPad === "left" ? r = "0" + r : e.hexPad === "right" ? r += "0" : hn.throwArgumentError("hex data is odd-length", "value", t));
    const n = [];
    for (let i = 0; i < r.length; i += 2)
      n.push(parseInt(r.substring(i, i + 2), 16));
    return fu(new Uint8Array(n));
  }
  return Uv(t) ? fu(new Uint8Array(t)) : hn.throwArgumentError("invalid arrayify value", "value", t);
}
function IF(t) {
  const e = t.map((i) => wn(i)), r = e.reduce((i, s) => i + s.length, 0), n = new Uint8Array(r);
  return e.reduce((i, s) => (n.set(s, i), i + s.length), 0), fu(n);
}
function CF(t, e) {
  t = wn(t), t.length > e && hn.throwArgumentError("value out of range", "value", arguments[0]);
  const r = new Uint8Array(e);
  return r.set(t, e - t.length), fu(r);
}
function zs(t, e) {
  return !(typeof t != "string" || !t.match(/^0x[0-9A-Fa-f]*$/) || e && t.length !== 2 + 2 * e);
}
const Qg = "0123456789abcdef";
function Ti(t, e) {
  if (e || (e = {}), typeof t == "number") {
    hn.checkSafeUint53(t, "invalid hexlify value");
    let r = "";
    for (; t; )
      r = Qg[t & 15] + r, t = Math.floor(t / 16);
    return r.length ? (r.length % 2 && (r = "0" + r), "0x" + r) : "0x00";
  }
  if (typeof t == "bigint")
    return t = t.toString(16), t.length % 2 ? "0x0" + t : "0x" + t;
  if (e.allowMissingPrefix && typeof t == "string" && t.substring(0, 2) !== "0x" && (t = "0x" + t), V4(t))
    return t.toHexString();
  if (zs(t))
    return t.length % 2 && (e.hexPad === "left" ? t = "0x0" + t.substring(2) : e.hexPad === "right" ? t += "0" : hn.throwArgumentError("hex data is odd-length", "value", t)), t.toLowerCase();
  if (Uv(t)) {
    let r = "0x";
    for (let n = 0; n < t.length; n++) {
      let i = t[n];
      r += Qg[(i & 240) >> 4] + Qg[i & 15];
    }
    return r;
  }
  return hn.throwArgumentError("invalid hexlify value", "value", t);
}
function TF(t) {
  if (typeof t != "string")
    t = Ti(t);
  else if (!zs(t) || t.length % 2)
    return null;
  return (t.length - 2) / 2;
}
function yx(t, e, r) {
  return typeof t != "string" ? t = Ti(t) : (!zs(t) || t.length % 2) && hn.throwArgumentError("invalid hexData", "value", t), e = 2 + 2 * e, "0x" + t.substring(e);
}
function lu(t, e) {
  for (typeof t != "string" ? t = Ti(t) : zs(t) || hn.throwArgumentError("invalid hex string", "value", t), t.length > 2 * e + 2 && hn.throwArgumentError("value out of range", "value", arguments[1]); t.length < 2 * e + 2; )
    t = "0x0" + t.substring(2);
  return t;
}
function G4(t) {
  const e = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (MF(t)) {
    let r = wn(t);
    r.length === 64 ? (e.v = 27 + (r[32] >> 7), r[32] &= 127, e.r = Ti(r.slice(0, 32)), e.s = Ti(r.slice(32, 64))) : r.length === 65 ? (e.r = Ti(r.slice(0, 32)), e.s = Ti(r.slice(32, 64)), e.v = r[64]) : hn.throwArgumentError("invalid signature string", "signature", t), e.v < 27 && (e.v === 0 || e.v === 1 ? e.v += 27 : hn.throwArgumentError("signature invalid v byte", "signature", t)), e.recoveryParam = 1 - e.v % 2, e.recoveryParam && (r[32] |= 128), e._vs = Ti(r.slice(32, 64));
  } else {
    if (e.r = t.r, e.s = t.s, e.v = t.v, e.recoveryParam = t.recoveryParam, e._vs = t._vs, e._vs != null) {
      const i = CF(wn(e._vs), 32);
      e._vs = Ti(i);
      const s = i[0] >= 128 ? 1 : 0;
      e.recoveryParam == null ? e.recoveryParam = s : e.recoveryParam !== s && hn.throwArgumentError("signature recoveryParam mismatch _vs", "signature", t), i[0] &= 127;
      const o = Ti(i);
      e.s == null ? e.s = o : e.s !== o && hn.throwArgumentError("signature v mismatch _vs", "signature", t);
    }
    if (e.recoveryParam == null)
      e.v == null ? hn.throwArgumentError("signature missing v and recoveryParam", "signature", t) : e.v === 0 || e.v === 1 ? e.recoveryParam = e.v : e.recoveryParam = 1 - e.v % 2;
    else if (e.v == null)
      e.v = 27 + e.recoveryParam;
    else {
      const i = e.v === 0 || e.v === 1 ? e.v : 1 - e.v % 2;
      e.recoveryParam !== i && hn.throwArgumentError("signature recoveryParam mismatch v", "signature", t);
    }
    e.r == null || !zs(e.r) ? hn.throwArgumentError("signature missing or invalid r", "signature", t) : e.r = lu(e.r, 32), e.s == null || !zs(e.s) ? hn.throwArgumentError("signature missing or invalid s", "signature", t) : e.s = lu(e.s, 32);
    const r = wn(e.s);
    r[0] >= 128 && hn.throwArgumentError("signature s out of range", "signature", t), e.recoveryParam && (r[0] |= 128);
    const n = Ti(r);
    e._vs && (zs(e._vs) || hn.throwArgumentError("signature invalid _vs", "signature", t), e._vs = lu(e._vs, 32)), e._vs == null ? e._vs = n : e._vs !== n && hn.throwArgumentError("signature _vs mismatch v and s", "signature", t);
  }
  return e.yParityAndS = e._vs, e.compact = e.r + e.yParityAndS.substring(2), e;
}
function qv(t) {
  return "0x" + EF.keccak_256(wn(t));
}
var zv = { exports: {} };
zv.exports;
(function(t) {
  (function(e, r) {
    function n(m, f) {
      if (!m) throw new Error(f || "Assertion failed");
    }
    function i(m, f) {
      m.super_ = f;
      var g = function() {
      };
      g.prototype = f.prototype, m.prototype = new g(), m.prototype.constructor = m;
    }
    function s(m, f, g) {
      if (s.isBN(m))
        return m;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, m !== null && ((f === "le" || f === "be") && (g = f, f = 10), this._init(m || 0, f || 10, g || "be"));
    }
    typeof e == "object" ? e.exports = s : r.BN = s, s.BN = s, s.wordSize = 26;
    var o;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = Wl.Buffer;
    } catch {
    }
    s.isBN = function(f) {
      return f instanceof s ? !0 : f !== null && typeof f == "object" && f.constructor.wordSize === s.wordSize && Array.isArray(f.words);
    }, s.max = function(f, g) {
      return f.cmp(g) > 0 ? f : g;
    }, s.min = function(f, g) {
      return f.cmp(g) < 0 ? f : g;
    }, s.prototype._init = function(f, g, b) {
      if (typeof f == "number")
        return this._initNumber(f, g, b);
      if (typeof f == "object")
        return this._initArray(f, g, b);
      g === "hex" && (g = 16), n(g === (g | 0) && g >= 2 && g <= 36), f = f.toString().replace(/\s+/g, "");
      var x = 0;
      f[0] === "-" && (x++, this.negative = 1), x < f.length && (g === 16 ? this._parseHex(f, x, b) : (this._parseBase(f, g, x), b === "le" && this._initArray(this.toArray(), g, b)));
    }, s.prototype._initNumber = function(f, g, b) {
      f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [f & 67108863], this.length = 1) : f < 4503599627370496 ? (this.words = [
        f & 67108863,
        f / 67108864 & 67108863
      ], this.length = 2) : (n(f < 9007199254740992), this.words = [
        f & 67108863,
        f / 67108864 & 67108863,
        1
      ], this.length = 3), b === "le" && this._initArray(this.toArray(), g, b);
    }, s.prototype._initArray = function(f, g, b) {
      if (n(typeof f.length == "number"), f.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        this.words[x] = 0;
      var _, E, v = 0;
      if (b === "be")
        for (x = f.length - 1, _ = 0; x >= 0; x -= 3)
          E = f[x] | f[x - 1] << 8 | f[x - 2] << 16, this.words[_] |= E << v & 67108863, this.words[_ + 1] = E >>> 26 - v & 67108863, v += 24, v >= 26 && (v -= 26, _++);
      else if (b === "le")
        for (x = 0, _ = 0; x < f.length; x += 3)
          E = f[x] | f[x + 1] << 8 | f[x + 2] << 16, this.words[_] |= E << v & 67108863, this.words[_ + 1] = E >>> 26 - v & 67108863, v += 24, v >= 26 && (v -= 26, _++);
      return this._strip();
    };
    function a(m, f) {
      var g = m.charCodeAt(f);
      if (g >= 48 && g <= 57)
        return g - 48;
      if (g >= 65 && g <= 70)
        return g - 55;
      if (g >= 97 && g <= 102)
        return g - 87;
      n(!1, "Invalid character in " + m);
    }
    function u(m, f, g) {
      var b = a(m, g);
      return g - 1 >= f && (b |= a(m, g - 1) << 4), b;
    }
    s.prototype._parseHex = function(f, g, b) {
      this.length = Math.ceil((f.length - g) / 6), this.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        this.words[x] = 0;
      var _ = 0, E = 0, v;
      if (b === "be")
        for (x = f.length - 1; x >= g; x -= 2)
          v = u(f, g, x) << _, this.words[E] |= v & 67108863, _ >= 18 ? (_ -= 18, E += 1, this.words[E] |= v >>> 26) : _ += 8;
      else {
        var M = f.length - g;
        for (x = M % 2 === 0 ? g + 1 : g; x < f.length; x += 2)
          v = u(f, g, x) << _, this.words[E] |= v & 67108863, _ >= 18 ? (_ -= 18, E += 1, this.words[E] |= v >>> 26) : _ += 8;
      }
      this._strip();
    };
    function l(m, f, g, b) {
      for (var x = 0, _ = 0, E = Math.min(m.length, g), v = f; v < E; v++) {
        var M = m.charCodeAt(v) - 48;
        x *= b, M >= 49 ? _ = M - 49 + 10 : M >= 17 ? _ = M - 17 + 10 : _ = M, n(M >= 0 && _ < b, "Invalid character"), x += _;
      }
      return x;
    }
    s.prototype._parseBase = function(f, g, b) {
      this.words = [0], this.length = 1;
      for (var x = 0, _ = 1; _ <= 67108863; _ *= g)
        x++;
      x--, _ = _ / g | 0;
      for (var E = f.length - b, v = E % x, M = Math.min(E, E - v) + b, I = 0, F = b; F < M; F += x)
        I = l(f, F, F + x, g), this.imuln(_), this.words[0] + I < 67108864 ? this.words[0] += I : this._iaddn(I);
      if (v !== 0) {
        var ce = 1;
        for (I = l(f, F, f.length, g), F = 0; F < v; F++)
          ce *= g;
        this.imuln(ce), this.words[0] + I < 67108864 ? this.words[0] += I : this._iaddn(I);
      }
      this._strip();
    }, s.prototype.copy = function(f) {
      f.words = new Array(this.length);
      for (var g = 0; g < this.length; g++)
        f.words[g] = this.words[g];
      f.length = this.length, f.negative = this.negative, f.red = this.red;
    };
    function d(m, f) {
      m.words = f.words, m.length = f.length, m.negative = f.negative, m.red = f.red;
    }
    if (s.prototype._move = function(f) {
      d(f, this);
    }, s.prototype.clone = function() {
      var f = new s(null);
      return this.copy(f), f;
    }, s.prototype._expand = function(f) {
      for (; this.length < f; )
        this.words[this.length++] = 0;
      return this;
    }, s.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, s.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        s.prototype[Symbol.for("nodejs.util.inspect.custom")] = p;
      } catch {
        s.prototype.inspect = p;
      }
    else
      s.prototype.inspect = p;
    function p() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var w = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], A = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], P = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    s.prototype.toString = function(f, g) {
      f = f || 10, g = g | 0 || 1;
      var b;
      if (f === 16 || f === "hex") {
        b = "";
        for (var x = 0, _ = 0, E = 0; E < this.length; E++) {
          var v = this.words[E], M = ((v << x | _) & 16777215).toString(16);
          _ = v >>> 24 - x & 16777215, x += 2, x >= 26 && (x -= 26, E--), _ !== 0 || E !== this.length - 1 ? b = w[6 - M.length] + M + b : b = M + b;
        }
        for (_ !== 0 && (b = _.toString(16) + b); b.length % g !== 0; )
          b = "0" + b;
        return this.negative !== 0 && (b = "-" + b), b;
      }
      if (f === (f | 0) && f >= 2 && f <= 36) {
        var I = A[f], F = P[f];
        b = "";
        var ce = this.clone();
        for (ce.negative = 0; !ce.isZero(); ) {
          var D = ce.modrn(F).toString(f);
          ce = ce.idivn(F), ce.isZero() ? b = D + b : b = w[I - D.length] + D + b;
        }
        for (this.isZero() && (b = "0" + b); b.length % g !== 0; )
          b = "0" + b;
        return this.negative !== 0 && (b = "-" + b), b;
      }
      n(!1, "Base should be between 2 and 36");
    }, s.prototype.toNumber = function() {
      var f = this.words[0];
      return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f : f;
    }, s.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, o && (s.prototype.toBuffer = function(f, g) {
      return this.toArrayLike(o, f, g);
    }), s.prototype.toArray = function(f, g) {
      return this.toArrayLike(Array, f, g);
    };
    var N = function(f, g) {
      return f.allocUnsafe ? f.allocUnsafe(g) : new f(g);
    };
    s.prototype.toArrayLike = function(f, g, b) {
      this._strip();
      var x = this.byteLength(), _ = b || Math.max(1, x);
      n(x <= _, "byte array longer than desired length"), n(_ > 0, "Requested array length <= 0");
      var E = N(f, _), v = g === "le" ? "LE" : "BE";
      return this["_toArrayLike" + v](E, x), E;
    }, s.prototype._toArrayLikeLE = function(f, g) {
      for (var b = 0, x = 0, _ = 0, E = 0; _ < this.length; _++) {
        var v = this.words[_] << E | x;
        f[b++] = v & 255, b < f.length && (f[b++] = v >> 8 & 255), b < f.length && (f[b++] = v >> 16 & 255), E === 6 ? (b < f.length && (f[b++] = v >> 24 & 255), x = 0, E = 0) : (x = v >>> 24, E += 2);
      }
      if (b < f.length)
        for (f[b++] = x; b < f.length; )
          f[b++] = 0;
    }, s.prototype._toArrayLikeBE = function(f, g) {
      for (var b = f.length - 1, x = 0, _ = 0, E = 0; _ < this.length; _++) {
        var v = this.words[_] << E | x;
        f[b--] = v & 255, b >= 0 && (f[b--] = v >> 8 & 255), b >= 0 && (f[b--] = v >> 16 & 255), E === 6 ? (b >= 0 && (f[b--] = v >> 24 & 255), x = 0, E = 0) : (x = v >>> 24, E += 2);
      }
      if (b >= 0)
        for (f[b--] = x; b >= 0; )
          f[b--] = 0;
    }, Math.clz32 ? s.prototype._countBits = function(f) {
      return 32 - Math.clz32(f);
    } : s.prototype._countBits = function(f) {
      var g = f, b = 0;
      return g >= 4096 && (b += 13, g >>>= 13), g >= 64 && (b += 7, g >>>= 7), g >= 8 && (b += 4, g >>>= 4), g >= 2 && (b += 2, g >>>= 2), b + g;
    }, s.prototype._zeroBits = function(f) {
      if (f === 0) return 26;
      var g = f, b = 0;
      return g & 8191 || (b += 13, g >>>= 13), g & 127 || (b += 7, g >>>= 7), g & 15 || (b += 4, g >>>= 4), g & 3 || (b += 2, g >>>= 2), g & 1 || b++, b;
    }, s.prototype.bitLength = function() {
      var f = this.words[this.length - 1], g = this._countBits(f);
      return (this.length - 1) * 26 + g;
    };
    function L(m) {
      for (var f = new Array(m.bitLength()), g = 0; g < f.length; g++) {
        var b = g / 26 | 0, x = g % 26;
        f[g] = m.words[b] >>> x & 1;
      }
      return f;
    }
    s.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var f = 0, g = 0; g < this.length; g++) {
        var b = this._zeroBits(this.words[g]);
        if (f += b, b !== 26) break;
      }
      return f;
    }, s.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, s.prototype.toTwos = function(f) {
      return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone();
    }, s.prototype.fromTwos = function(f) {
      return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone();
    }, s.prototype.isNeg = function() {
      return this.negative !== 0;
    }, s.prototype.neg = function() {
      return this.clone().ineg();
    }, s.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, s.prototype.iuor = function(f) {
      for (; this.length < f.length; )
        this.words[this.length++] = 0;
      for (var g = 0; g < f.length; g++)
        this.words[g] = this.words[g] | f.words[g];
      return this._strip();
    }, s.prototype.ior = function(f) {
      return n((this.negative | f.negative) === 0), this.iuor(f);
    }, s.prototype.or = function(f) {
      return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this);
    }, s.prototype.uor = function(f) {
      return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this);
    }, s.prototype.iuand = function(f) {
      var g;
      this.length > f.length ? g = f : g = this;
      for (var b = 0; b < g.length; b++)
        this.words[b] = this.words[b] & f.words[b];
      return this.length = g.length, this._strip();
    }, s.prototype.iand = function(f) {
      return n((this.negative | f.negative) === 0), this.iuand(f);
    }, s.prototype.and = function(f) {
      return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this);
    }, s.prototype.uand = function(f) {
      return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this);
    }, s.prototype.iuxor = function(f) {
      var g, b;
      this.length > f.length ? (g = this, b = f) : (g = f, b = this);
      for (var x = 0; x < b.length; x++)
        this.words[x] = g.words[x] ^ b.words[x];
      if (this !== g)
        for (; x < g.length; x++)
          this.words[x] = g.words[x];
      return this.length = g.length, this._strip();
    }, s.prototype.ixor = function(f) {
      return n((this.negative | f.negative) === 0), this.iuxor(f);
    }, s.prototype.xor = function(f) {
      return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this);
    }, s.prototype.uxor = function(f) {
      return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this);
    }, s.prototype.inotn = function(f) {
      n(typeof f == "number" && f >= 0);
      var g = Math.ceil(f / 26) | 0, b = f % 26;
      this._expand(g), b > 0 && g--;
      for (var x = 0; x < g; x++)
        this.words[x] = ~this.words[x] & 67108863;
      return b > 0 && (this.words[x] = ~this.words[x] & 67108863 >> 26 - b), this._strip();
    }, s.prototype.notn = function(f) {
      return this.clone().inotn(f);
    }, s.prototype.setn = function(f, g) {
      n(typeof f == "number" && f >= 0);
      var b = f / 26 | 0, x = f % 26;
      return this._expand(b + 1), g ? this.words[b] = this.words[b] | 1 << x : this.words[b] = this.words[b] & ~(1 << x), this._strip();
    }, s.prototype.iadd = function(f) {
      var g;
      if (this.negative !== 0 && f.negative === 0)
        return this.negative = 0, g = this.isub(f), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && f.negative !== 0)
        return f.negative = 0, g = this.isub(f), f.negative = 1, g._normSign();
      var b, x;
      this.length > f.length ? (b = this, x = f) : (b = f, x = this);
      for (var _ = 0, E = 0; E < x.length; E++)
        g = (b.words[E] | 0) + (x.words[E] | 0) + _, this.words[E] = g & 67108863, _ = g >>> 26;
      for (; _ !== 0 && E < b.length; E++)
        g = (b.words[E] | 0) + _, this.words[E] = g & 67108863, _ = g >>> 26;
      if (this.length = b.length, _ !== 0)
        this.words[this.length] = _, this.length++;
      else if (b !== this)
        for (; E < b.length; E++)
          this.words[E] = b.words[E];
      return this;
    }, s.prototype.add = function(f) {
      var g;
      return f.negative !== 0 && this.negative === 0 ? (f.negative = 0, g = this.sub(f), f.negative ^= 1, g) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0, g = f.sub(this), this.negative = 1, g) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this);
    }, s.prototype.isub = function(f) {
      if (f.negative !== 0) {
        f.negative = 0;
        var g = this.iadd(f);
        return f.negative = 1, g._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
      var b = this.cmp(f);
      if (b === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var x, _;
      b > 0 ? (x = this, _ = f) : (x = f, _ = this);
      for (var E = 0, v = 0; v < _.length; v++)
        g = (x.words[v] | 0) - (_.words[v] | 0) + E, E = g >> 26, this.words[v] = g & 67108863;
      for (; E !== 0 && v < x.length; v++)
        g = (x.words[v] | 0) + E, E = g >> 26, this.words[v] = g & 67108863;
      if (E === 0 && v < x.length && x !== this)
        for (; v < x.length; v++)
          this.words[v] = x.words[v];
      return this.length = Math.max(this.length, v), x !== this && (this.negative = 1), this._strip();
    }, s.prototype.sub = function(f) {
      return this.clone().isub(f);
    };
    function $(m, f, g) {
      g.negative = f.negative ^ m.negative;
      var b = m.length + f.length | 0;
      g.length = b, b = b - 1 | 0;
      var x = m.words[0] | 0, _ = f.words[0] | 0, E = x * _, v = E & 67108863, M = E / 67108864 | 0;
      g.words[0] = v;
      for (var I = 1; I < b; I++) {
        for (var F = M >>> 26, ce = M & 67108863, D = Math.min(I, f.length - 1), oe = Math.max(0, I - m.length + 1); oe <= D; oe++) {
          var Z = I - oe | 0;
          x = m.words[Z] | 0, _ = f.words[oe] | 0, E = x * _ + ce, F += E / 67108864 | 0, ce = E & 67108863;
        }
        g.words[I] = ce | 0, M = F | 0;
      }
      return M !== 0 ? g.words[I] = M | 0 : g.length--, g._strip();
    }
    var B = function(f, g, b) {
      var x = f.words, _ = g.words, E = b.words, v = 0, M, I, F, ce = x[0] | 0, D = ce & 8191, oe = ce >>> 13, Z = x[1] | 0, J = Z & 8191, Q = Z >>> 13, T = x[2] | 0, X = T & 8191, re = T >>> 13, pe = x[3] | 0, ie = pe & 8191, ue = pe >>> 13, ve = x[4] | 0, Pe = ve & 8191, De = ve >>> 13, Ce = x[5] | 0, $e = Ce & 8191, Me = Ce >>> 13, Ne = x[6] | 0, Ke = Ne & 8191, Le = Ne >>> 13, qe = x[7] | 0, ze = qe & 8191, _e = qe >>> 13, Ze = x[8] | 0, at = Ze & 8191, ke = Ze >>> 13, Qe = x[9] | 0, tt = Qe & 8191, Ye = Qe >>> 13, dt = _[0] | 0, lt = dt & 8191, ct = dt >>> 13, qt = _[1] | 0, Jt = qt & 8191, Et = qt >>> 13, er = _[2] | 0, Xt = er & 8191, Dt = er >>> 13, kt = _[3] | 0, Ct = kt & 8191, gt = kt >>> 13, Rt = _[4] | 0, Nt = Rt & 8191, vt = Rt >>> 13, $t = _[5] | 0, Ft = $t & 8191, rt = $t >>> 13, Bt = _[6] | 0, k = Bt & 8191, U = Bt >>> 13, z = _[7] | 0, C = z & 8191, G = z >>> 13, j = _[8] | 0, se = j & 8191, de = j >>> 13, xe = _[9] | 0, Te = xe & 8191, Re = xe >>> 13;
      b.negative = f.negative ^ g.negative, b.length = 19, M = Math.imul(D, lt), I = Math.imul(D, ct), I = I + Math.imul(oe, lt) | 0, F = Math.imul(oe, ct);
      var nt = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, M = Math.imul(J, lt), I = Math.imul(J, ct), I = I + Math.imul(Q, lt) | 0, F = Math.imul(Q, ct), M = M + Math.imul(D, Jt) | 0, I = I + Math.imul(D, Et) | 0, I = I + Math.imul(oe, Jt) | 0, F = F + Math.imul(oe, Et) | 0;
      var je = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, M = Math.imul(X, lt), I = Math.imul(X, ct), I = I + Math.imul(re, lt) | 0, F = Math.imul(re, ct), M = M + Math.imul(J, Jt) | 0, I = I + Math.imul(J, Et) | 0, I = I + Math.imul(Q, Jt) | 0, F = F + Math.imul(Q, Et) | 0, M = M + Math.imul(D, Xt) | 0, I = I + Math.imul(D, Dt) | 0, I = I + Math.imul(oe, Xt) | 0, F = F + Math.imul(oe, Dt) | 0;
      var pt = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, M = Math.imul(ie, lt), I = Math.imul(ie, ct), I = I + Math.imul(ue, lt) | 0, F = Math.imul(ue, ct), M = M + Math.imul(X, Jt) | 0, I = I + Math.imul(X, Et) | 0, I = I + Math.imul(re, Jt) | 0, F = F + Math.imul(re, Et) | 0, M = M + Math.imul(J, Xt) | 0, I = I + Math.imul(J, Dt) | 0, I = I + Math.imul(Q, Xt) | 0, F = F + Math.imul(Q, Dt) | 0, M = M + Math.imul(D, Ct) | 0, I = I + Math.imul(D, gt) | 0, I = I + Math.imul(oe, Ct) | 0, F = F + Math.imul(oe, gt) | 0;
      var it = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, M = Math.imul(Pe, lt), I = Math.imul(Pe, ct), I = I + Math.imul(De, lt) | 0, F = Math.imul(De, ct), M = M + Math.imul(ie, Jt) | 0, I = I + Math.imul(ie, Et) | 0, I = I + Math.imul(ue, Jt) | 0, F = F + Math.imul(ue, Et) | 0, M = M + Math.imul(X, Xt) | 0, I = I + Math.imul(X, Dt) | 0, I = I + Math.imul(re, Xt) | 0, F = F + Math.imul(re, Dt) | 0, M = M + Math.imul(J, Ct) | 0, I = I + Math.imul(J, gt) | 0, I = I + Math.imul(Q, Ct) | 0, F = F + Math.imul(Q, gt) | 0, M = M + Math.imul(D, Nt) | 0, I = I + Math.imul(D, vt) | 0, I = I + Math.imul(oe, Nt) | 0, F = F + Math.imul(oe, vt) | 0;
      var et = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, M = Math.imul($e, lt), I = Math.imul($e, ct), I = I + Math.imul(Me, lt) | 0, F = Math.imul(Me, ct), M = M + Math.imul(Pe, Jt) | 0, I = I + Math.imul(Pe, Et) | 0, I = I + Math.imul(De, Jt) | 0, F = F + Math.imul(De, Et) | 0, M = M + Math.imul(ie, Xt) | 0, I = I + Math.imul(ie, Dt) | 0, I = I + Math.imul(ue, Xt) | 0, F = F + Math.imul(ue, Dt) | 0, M = M + Math.imul(X, Ct) | 0, I = I + Math.imul(X, gt) | 0, I = I + Math.imul(re, Ct) | 0, F = F + Math.imul(re, gt) | 0, M = M + Math.imul(J, Nt) | 0, I = I + Math.imul(J, vt) | 0, I = I + Math.imul(Q, Nt) | 0, F = F + Math.imul(Q, vt) | 0, M = M + Math.imul(D, Ft) | 0, I = I + Math.imul(D, rt) | 0, I = I + Math.imul(oe, Ft) | 0, F = F + Math.imul(oe, rt) | 0;
      var St = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, M = Math.imul(Ke, lt), I = Math.imul(Ke, ct), I = I + Math.imul(Le, lt) | 0, F = Math.imul(Le, ct), M = M + Math.imul($e, Jt) | 0, I = I + Math.imul($e, Et) | 0, I = I + Math.imul(Me, Jt) | 0, F = F + Math.imul(Me, Et) | 0, M = M + Math.imul(Pe, Xt) | 0, I = I + Math.imul(Pe, Dt) | 0, I = I + Math.imul(De, Xt) | 0, F = F + Math.imul(De, Dt) | 0, M = M + Math.imul(ie, Ct) | 0, I = I + Math.imul(ie, gt) | 0, I = I + Math.imul(ue, Ct) | 0, F = F + Math.imul(ue, gt) | 0, M = M + Math.imul(X, Nt) | 0, I = I + Math.imul(X, vt) | 0, I = I + Math.imul(re, Nt) | 0, F = F + Math.imul(re, vt) | 0, M = M + Math.imul(J, Ft) | 0, I = I + Math.imul(J, rt) | 0, I = I + Math.imul(Q, Ft) | 0, F = F + Math.imul(Q, rt) | 0, M = M + Math.imul(D, k) | 0, I = I + Math.imul(D, U) | 0, I = I + Math.imul(oe, k) | 0, F = F + Math.imul(oe, U) | 0;
      var Tt = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, M = Math.imul(ze, lt), I = Math.imul(ze, ct), I = I + Math.imul(_e, lt) | 0, F = Math.imul(_e, ct), M = M + Math.imul(Ke, Jt) | 0, I = I + Math.imul(Ke, Et) | 0, I = I + Math.imul(Le, Jt) | 0, F = F + Math.imul(Le, Et) | 0, M = M + Math.imul($e, Xt) | 0, I = I + Math.imul($e, Dt) | 0, I = I + Math.imul(Me, Xt) | 0, F = F + Math.imul(Me, Dt) | 0, M = M + Math.imul(Pe, Ct) | 0, I = I + Math.imul(Pe, gt) | 0, I = I + Math.imul(De, Ct) | 0, F = F + Math.imul(De, gt) | 0, M = M + Math.imul(ie, Nt) | 0, I = I + Math.imul(ie, vt) | 0, I = I + Math.imul(ue, Nt) | 0, F = F + Math.imul(ue, vt) | 0, M = M + Math.imul(X, Ft) | 0, I = I + Math.imul(X, rt) | 0, I = I + Math.imul(re, Ft) | 0, F = F + Math.imul(re, rt) | 0, M = M + Math.imul(J, k) | 0, I = I + Math.imul(J, U) | 0, I = I + Math.imul(Q, k) | 0, F = F + Math.imul(Q, U) | 0, M = M + Math.imul(D, C) | 0, I = I + Math.imul(D, G) | 0, I = I + Math.imul(oe, C) | 0, F = F + Math.imul(oe, G) | 0;
      var At = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, M = Math.imul(at, lt), I = Math.imul(at, ct), I = I + Math.imul(ke, lt) | 0, F = Math.imul(ke, ct), M = M + Math.imul(ze, Jt) | 0, I = I + Math.imul(ze, Et) | 0, I = I + Math.imul(_e, Jt) | 0, F = F + Math.imul(_e, Et) | 0, M = M + Math.imul(Ke, Xt) | 0, I = I + Math.imul(Ke, Dt) | 0, I = I + Math.imul(Le, Xt) | 0, F = F + Math.imul(Le, Dt) | 0, M = M + Math.imul($e, Ct) | 0, I = I + Math.imul($e, gt) | 0, I = I + Math.imul(Me, Ct) | 0, F = F + Math.imul(Me, gt) | 0, M = M + Math.imul(Pe, Nt) | 0, I = I + Math.imul(Pe, vt) | 0, I = I + Math.imul(De, Nt) | 0, F = F + Math.imul(De, vt) | 0, M = M + Math.imul(ie, Ft) | 0, I = I + Math.imul(ie, rt) | 0, I = I + Math.imul(ue, Ft) | 0, F = F + Math.imul(ue, rt) | 0, M = M + Math.imul(X, k) | 0, I = I + Math.imul(X, U) | 0, I = I + Math.imul(re, k) | 0, F = F + Math.imul(re, U) | 0, M = M + Math.imul(J, C) | 0, I = I + Math.imul(J, G) | 0, I = I + Math.imul(Q, C) | 0, F = F + Math.imul(Q, G) | 0, M = M + Math.imul(D, se) | 0, I = I + Math.imul(D, de) | 0, I = I + Math.imul(oe, se) | 0, F = F + Math.imul(oe, de) | 0;
      var _t = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, M = Math.imul(tt, lt), I = Math.imul(tt, ct), I = I + Math.imul(Ye, lt) | 0, F = Math.imul(Ye, ct), M = M + Math.imul(at, Jt) | 0, I = I + Math.imul(at, Et) | 0, I = I + Math.imul(ke, Jt) | 0, F = F + Math.imul(ke, Et) | 0, M = M + Math.imul(ze, Xt) | 0, I = I + Math.imul(ze, Dt) | 0, I = I + Math.imul(_e, Xt) | 0, F = F + Math.imul(_e, Dt) | 0, M = M + Math.imul(Ke, Ct) | 0, I = I + Math.imul(Ke, gt) | 0, I = I + Math.imul(Le, Ct) | 0, F = F + Math.imul(Le, gt) | 0, M = M + Math.imul($e, Nt) | 0, I = I + Math.imul($e, vt) | 0, I = I + Math.imul(Me, Nt) | 0, F = F + Math.imul(Me, vt) | 0, M = M + Math.imul(Pe, Ft) | 0, I = I + Math.imul(Pe, rt) | 0, I = I + Math.imul(De, Ft) | 0, F = F + Math.imul(De, rt) | 0, M = M + Math.imul(ie, k) | 0, I = I + Math.imul(ie, U) | 0, I = I + Math.imul(ue, k) | 0, F = F + Math.imul(ue, U) | 0, M = M + Math.imul(X, C) | 0, I = I + Math.imul(X, G) | 0, I = I + Math.imul(re, C) | 0, F = F + Math.imul(re, G) | 0, M = M + Math.imul(J, se) | 0, I = I + Math.imul(J, de) | 0, I = I + Math.imul(Q, se) | 0, F = F + Math.imul(Q, de) | 0, M = M + Math.imul(D, Te) | 0, I = I + Math.imul(D, Re) | 0, I = I + Math.imul(oe, Te) | 0, F = F + Math.imul(oe, Re) | 0;
      var ht = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, M = Math.imul(tt, Jt), I = Math.imul(tt, Et), I = I + Math.imul(Ye, Jt) | 0, F = Math.imul(Ye, Et), M = M + Math.imul(at, Xt) | 0, I = I + Math.imul(at, Dt) | 0, I = I + Math.imul(ke, Xt) | 0, F = F + Math.imul(ke, Dt) | 0, M = M + Math.imul(ze, Ct) | 0, I = I + Math.imul(ze, gt) | 0, I = I + Math.imul(_e, Ct) | 0, F = F + Math.imul(_e, gt) | 0, M = M + Math.imul(Ke, Nt) | 0, I = I + Math.imul(Ke, vt) | 0, I = I + Math.imul(Le, Nt) | 0, F = F + Math.imul(Le, vt) | 0, M = M + Math.imul($e, Ft) | 0, I = I + Math.imul($e, rt) | 0, I = I + Math.imul(Me, Ft) | 0, F = F + Math.imul(Me, rt) | 0, M = M + Math.imul(Pe, k) | 0, I = I + Math.imul(Pe, U) | 0, I = I + Math.imul(De, k) | 0, F = F + Math.imul(De, U) | 0, M = M + Math.imul(ie, C) | 0, I = I + Math.imul(ie, G) | 0, I = I + Math.imul(ue, C) | 0, F = F + Math.imul(ue, G) | 0, M = M + Math.imul(X, se) | 0, I = I + Math.imul(X, de) | 0, I = I + Math.imul(re, se) | 0, F = F + Math.imul(re, de) | 0, M = M + Math.imul(J, Te) | 0, I = I + Math.imul(J, Re) | 0, I = I + Math.imul(Q, Te) | 0, F = F + Math.imul(Q, Re) | 0;
      var xt = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, M = Math.imul(tt, Xt), I = Math.imul(tt, Dt), I = I + Math.imul(Ye, Xt) | 0, F = Math.imul(Ye, Dt), M = M + Math.imul(at, Ct) | 0, I = I + Math.imul(at, gt) | 0, I = I + Math.imul(ke, Ct) | 0, F = F + Math.imul(ke, gt) | 0, M = M + Math.imul(ze, Nt) | 0, I = I + Math.imul(ze, vt) | 0, I = I + Math.imul(_e, Nt) | 0, F = F + Math.imul(_e, vt) | 0, M = M + Math.imul(Ke, Ft) | 0, I = I + Math.imul(Ke, rt) | 0, I = I + Math.imul(Le, Ft) | 0, F = F + Math.imul(Le, rt) | 0, M = M + Math.imul($e, k) | 0, I = I + Math.imul($e, U) | 0, I = I + Math.imul(Me, k) | 0, F = F + Math.imul(Me, U) | 0, M = M + Math.imul(Pe, C) | 0, I = I + Math.imul(Pe, G) | 0, I = I + Math.imul(De, C) | 0, F = F + Math.imul(De, G) | 0, M = M + Math.imul(ie, se) | 0, I = I + Math.imul(ie, de) | 0, I = I + Math.imul(ue, se) | 0, F = F + Math.imul(ue, de) | 0, M = M + Math.imul(X, Te) | 0, I = I + Math.imul(X, Re) | 0, I = I + Math.imul(re, Te) | 0, F = F + Math.imul(re, Re) | 0;
      var st = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, M = Math.imul(tt, Ct), I = Math.imul(tt, gt), I = I + Math.imul(Ye, Ct) | 0, F = Math.imul(Ye, gt), M = M + Math.imul(at, Nt) | 0, I = I + Math.imul(at, vt) | 0, I = I + Math.imul(ke, Nt) | 0, F = F + Math.imul(ke, vt) | 0, M = M + Math.imul(ze, Ft) | 0, I = I + Math.imul(ze, rt) | 0, I = I + Math.imul(_e, Ft) | 0, F = F + Math.imul(_e, rt) | 0, M = M + Math.imul(Ke, k) | 0, I = I + Math.imul(Ke, U) | 0, I = I + Math.imul(Le, k) | 0, F = F + Math.imul(Le, U) | 0, M = M + Math.imul($e, C) | 0, I = I + Math.imul($e, G) | 0, I = I + Math.imul(Me, C) | 0, F = F + Math.imul(Me, G) | 0, M = M + Math.imul(Pe, se) | 0, I = I + Math.imul(Pe, de) | 0, I = I + Math.imul(De, se) | 0, F = F + Math.imul(De, de) | 0, M = M + Math.imul(ie, Te) | 0, I = I + Math.imul(ie, Re) | 0, I = I + Math.imul(ue, Te) | 0, F = F + Math.imul(ue, Re) | 0;
      var bt = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, M = Math.imul(tt, Nt), I = Math.imul(tt, vt), I = I + Math.imul(Ye, Nt) | 0, F = Math.imul(Ye, vt), M = M + Math.imul(at, Ft) | 0, I = I + Math.imul(at, rt) | 0, I = I + Math.imul(ke, Ft) | 0, F = F + Math.imul(ke, rt) | 0, M = M + Math.imul(ze, k) | 0, I = I + Math.imul(ze, U) | 0, I = I + Math.imul(_e, k) | 0, F = F + Math.imul(_e, U) | 0, M = M + Math.imul(Ke, C) | 0, I = I + Math.imul(Ke, G) | 0, I = I + Math.imul(Le, C) | 0, F = F + Math.imul(Le, G) | 0, M = M + Math.imul($e, se) | 0, I = I + Math.imul($e, de) | 0, I = I + Math.imul(Me, se) | 0, F = F + Math.imul(Me, de) | 0, M = M + Math.imul(Pe, Te) | 0, I = I + Math.imul(Pe, Re) | 0, I = I + Math.imul(De, Te) | 0, F = F + Math.imul(De, Re) | 0;
      var ut = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, M = Math.imul(tt, Ft), I = Math.imul(tt, rt), I = I + Math.imul(Ye, Ft) | 0, F = Math.imul(Ye, rt), M = M + Math.imul(at, k) | 0, I = I + Math.imul(at, U) | 0, I = I + Math.imul(ke, k) | 0, F = F + Math.imul(ke, U) | 0, M = M + Math.imul(ze, C) | 0, I = I + Math.imul(ze, G) | 0, I = I + Math.imul(_e, C) | 0, F = F + Math.imul(_e, G) | 0, M = M + Math.imul(Ke, se) | 0, I = I + Math.imul(Ke, de) | 0, I = I + Math.imul(Le, se) | 0, F = F + Math.imul(Le, de) | 0, M = M + Math.imul($e, Te) | 0, I = I + Math.imul($e, Re) | 0, I = I + Math.imul(Me, Te) | 0, F = F + Math.imul(Me, Re) | 0;
      var ot = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, M = Math.imul(tt, k), I = Math.imul(tt, U), I = I + Math.imul(Ye, k) | 0, F = Math.imul(Ye, U), M = M + Math.imul(at, C) | 0, I = I + Math.imul(at, G) | 0, I = I + Math.imul(ke, C) | 0, F = F + Math.imul(ke, G) | 0, M = M + Math.imul(ze, se) | 0, I = I + Math.imul(ze, de) | 0, I = I + Math.imul(_e, se) | 0, F = F + Math.imul(_e, de) | 0, M = M + Math.imul(Ke, Te) | 0, I = I + Math.imul(Ke, Re) | 0, I = I + Math.imul(Le, Te) | 0, F = F + Math.imul(Le, Re) | 0;
      var Se = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, M = Math.imul(tt, C), I = Math.imul(tt, G), I = I + Math.imul(Ye, C) | 0, F = Math.imul(Ye, G), M = M + Math.imul(at, se) | 0, I = I + Math.imul(at, de) | 0, I = I + Math.imul(ke, se) | 0, F = F + Math.imul(ke, de) | 0, M = M + Math.imul(ze, Te) | 0, I = I + Math.imul(ze, Re) | 0, I = I + Math.imul(_e, Te) | 0, F = F + Math.imul(_e, Re) | 0;
      var Ae = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, M = Math.imul(tt, se), I = Math.imul(tt, de), I = I + Math.imul(Ye, se) | 0, F = Math.imul(Ye, de), M = M + Math.imul(at, Te) | 0, I = I + Math.imul(at, Re) | 0, I = I + Math.imul(ke, Te) | 0, F = F + Math.imul(ke, Re) | 0;
      var Ve = (v + M | 0) + ((I & 8191) << 13) | 0;
      v = (F + (I >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, M = Math.imul(tt, Te), I = Math.imul(tt, Re), I = I + Math.imul(Ye, Te) | 0, F = Math.imul(Ye, Re);
      var Fe = (v + M | 0) + ((I & 8191) << 13) | 0;
      return v = (F + (I >>> 13) | 0) + (Fe >>> 26) | 0, Fe &= 67108863, E[0] = nt, E[1] = je, E[2] = pt, E[3] = it, E[4] = et, E[5] = St, E[6] = Tt, E[7] = At, E[8] = _t, E[9] = ht, E[10] = xt, E[11] = st, E[12] = bt, E[13] = ut, E[14] = ot, E[15] = Se, E[16] = Ae, E[17] = Ve, E[18] = Fe, v !== 0 && (E[19] = v, b.length++), b;
    };
    Math.imul || (B = $);
    function H(m, f, g) {
      g.negative = f.negative ^ m.negative, g.length = m.length + f.length;
      for (var b = 0, x = 0, _ = 0; _ < g.length - 1; _++) {
        var E = x;
        x = 0;
        for (var v = b & 67108863, M = Math.min(_, f.length - 1), I = Math.max(0, _ - m.length + 1); I <= M; I++) {
          var F = _ - I, ce = m.words[F] | 0, D = f.words[I] | 0, oe = ce * D, Z = oe & 67108863;
          E = E + (oe / 67108864 | 0) | 0, Z = Z + v | 0, v = Z & 67108863, E = E + (Z >>> 26) | 0, x += E >>> 26, E &= 67108863;
        }
        g.words[_] = v, b = E, E = x;
      }
      return b !== 0 ? g.words[_] = b : g.length--, g._strip();
    }
    function W(m, f, g) {
      return H(m, f, g);
    }
    s.prototype.mulTo = function(f, g) {
      var b, x = this.length + f.length;
      return this.length === 10 && f.length === 10 ? b = B(this, f, g) : x < 63 ? b = $(this, f, g) : x < 1024 ? b = H(this, f, g) : b = W(this, f, g), b;
    }, s.prototype.mul = function(f) {
      var g = new s(null);
      return g.words = new Array(this.length + f.length), this.mulTo(f, g);
    }, s.prototype.mulf = function(f) {
      var g = new s(null);
      return g.words = new Array(this.length + f.length), W(this, f, g);
    }, s.prototype.imul = function(f) {
      return this.clone().mulTo(f, this);
    }, s.prototype.imuln = function(f) {
      var g = f < 0;
      g && (f = -f), n(typeof f == "number"), n(f < 67108864);
      for (var b = 0, x = 0; x < this.length; x++) {
        var _ = (this.words[x] | 0) * f, E = (_ & 67108863) + (b & 67108863);
        b >>= 26, b += _ / 67108864 | 0, b += E >>> 26, this.words[x] = E & 67108863;
      }
      return b !== 0 && (this.words[x] = b, this.length++), g ? this.ineg() : this;
    }, s.prototype.muln = function(f) {
      return this.clone().imuln(f);
    }, s.prototype.sqr = function() {
      return this.mul(this);
    }, s.prototype.isqr = function() {
      return this.imul(this.clone());
    }, s.prototype.pow = function(f) {
      var g = L(f);
      if (g.length === 0) return new s(1);
      for (var b = this, x = 0; x < g.length && g[x] === 0; x++, b = b.sqr())
        ;
      if (++x < g.length)
        for (var _ = b.sqr(); x < g.length; x++, _ = _.sqr())
          g[x] !== 0 && (b = b.mul(_));
      return b;
    }, s.prototype.iushln = function(f) {
      n(typeof f == "number" && f >= 0);
      var g = f % 26, b = (f - g) / 26, x = 67108863 >>> 26 - g << 26 - g, _;
      if (g !== 0) {
        var E = 0;
        for (_ = 0; _ < this.length; _++) {
          var v = this.words[_] & x, M = (this.words[_] | 0) - v << g;
          this.words[_] = M | E, E = v >>> 26 - g;
        }
        E && (this.words[_] = E, this.length++);
      }
      if (b !== 0) {
        for (_ = this.length - 1; _ >= 0; _--)
          this.words[_ + b] = this.words[_];
        for (_ = 0; _ < b; _++)
          this.words[_] = 0;
        this.length += b;
      }
      return this._strip();
    }, s.prototype.ishln = function(f) {
      return n(this.negative === 0), this.iushln(f);
    }, s.prototype.iushrn = function(f, g, b) {
      n(typeof f == "number" && f >= 0);
      var x;
      g ? x = (g - g % 26) / 26 : x = 0;
      var _ = f % 26, E = Math.min((f - _) / 26, this.length), v = 67108863 ^ 67108863 >>> _ << _, M = b;
      if (x -= E, x = Math.max(0, x), M) {
        for (var I = 0; I < E; I++)
          M.words[I] = this.words[I];
        M.length = E;
      }
      if (E !== 0) if (this.length > E)
        for (this.length -= E, I = 0; I < this.length; I++)
          this.words[I] = this.words[I + E];
      else
        this.words[0] = 0, this.length = 1;
      var F = 0;
      for (I = this.length - 1; I >= 0 && (F !== 0 || I >= x); I--) {
        var ce = this.words[I] | 0;
        this.words[I] = F << 26 - _ | ce >>> _, F = ce & v;
      }
      return M && F !== 0 && (M.words[M.length++] = F), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, s.prototype.ishrn = function(f, g, b) {
      return n(this.negative === 0), this.iushrn(f, g, b);
    }, s.prototype.shln = function(f) {
      return this.clone().ishln(f);
    }, s.prototype.ushln = function(f) {
      return this.clone().iushln(f);
    }, s.prototype.shrn = function(f) {
      return this.clone().ishrn(f);
    }, s.prototype.ushrn = function(f) {
      return this.clone().iushrn(f);
    }, s.prototype.testn = function(f) {
      n(typeof f == "number" && f >= 0);
      var g = f % 26, b = (f - g) / 26, x = 1 << g;
      if (this.length <= b) return !1;
      var _ = this.words[b];
      return !!(_ & x);
    }, s.prototype.imaskn = function(f) {
      n(typeof f == "number" && f >= 0);
      var g = f % 26, b = (f - g) / 26;
      if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= b)
        return this;
      if (g !== 0 && b++, this.length = Math.min(b, this.length), g !== 0) {
        var x = 67108863 ^ 67108863 >>> g << g;
        this.words[this.length - 1] &= x;
      }
      return this._strip();
    }, s.prototype.maskn = function(f) {
      return this.clone().imaskn(f);
    }, s.prototype.iaddn = function(f) {
      return n(typeof f == "number"), n(f < 67108864), f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f);
    }, s.prototype._iaddn = function(f) {
      this.words[0] += f;
      for (var g = 0; g < this.length && this.words[g] >= 67108864; g++)
        this.words[g] -= 67108864, g === this.length - 1 ? this.words[g + 1] = 1 : this.words[g + 1]++;
      return this.length = Math.max(this.length, g + 1), this;
    }, s.prototype.isubn = function(f) {
      if (n(typeof f == "number"), n(f < 67108864), f < 0) return this.iaddn(-f);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(f), this.negative = 1, this;
      if (this.words[0] -= f, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var g = 0; g < this.length && this.words[g] < 0; g++)
          this.words[g] += 67108864, this.words[g + 1] -= 1;
      return this._strip();
    }, s.prototype.addn = function(f) {
      return this.clone().iaddn(f);
    }, s.prototype.subn = function(f) {
      return this.clone().isubn(f);
    }, s.prototype.iabs = function() {
      return this.negative = 0, this;
    }, s.prototype.abs = function() {
      return this.clone().iabs();
    }, s.prototype._ishlnsubmul = function(f, g, b) {
      var x = f.length + b, _;
      this._expand(x);
      var E, v = 0;
      for (_ = 0; _ < f.length; _++) {
        E = (this.words[_ + b] | 0) + v;
        var M = (f.words[_] | 0) * g;
        E -= M & 67108863, v = (E >> 26) - (M / 67108864 | 0), this.words[_ + b] = E & 67108863;
      }
      for (; _ < this.length - b; _++)
        E = (this.words[_ + b] | 0) + v, v = E >> 26, this.words[_ + b] = E & 67108863;
      if (v === 0) return this._strip();
      for (n(v === -1), v = 0, _ = 0; _ < this.length; _++)
        E = -(this.words[_] | 0) + v, v = E >> 26, this.words[_] = E & 67108863;
      return this.negative = 1, this._strip();
    }, s.prototype._wordDiv = function(f, g) {
      var b = this.length - f.length, x = this.clone(), _ = f, E = _.words[_.length - 1] | 0, v = this._countBits(E);
      b = 26 - v, b !== 0 && (_ = _.ushln(b), x.iushln(b), E = _.words[_.length - 1] | 0);
      var M = x.length - _.length, I;
      if (g !== "mod") {
        I = new s(null), I.length = M + 1, I.words = new Array(I.length);
        for (var F = 0; F < I.length; F++)
          I.words[F] = 0;
      }
      var ce = x.clone()._ishlnsubmul(_, 1, M);
      ce.negative === 0 && (x = ce, I && (I.words[M] = 1));
      for (var D = M - 1; D >= 0; D--) {
        var oe = (x.words[_.length + D] | 0) * 67108864 + (x.words[_.length + D - 1] | 0);
        for (oe = Math.min(oe / E | 0, 67108863), x._ishlnsubmul(_, oe, D); x.negative !== 0; )
          oe--, x.negative = 0, x._ishlnsubmul(_, 1, D), x.isZero() || (x.negative ^= 1);
        I && (I.words[D] = oe);
      }
      return I && I._strip(), x._strip(), g !== "div" && b !== 0 && x.iushrn(b), {
        div: I || null,
        mod: x
      };
    }, s.prototype.divmod = function(f, g, b) {
      if (n(!f.isZero()), this.isZero())
        return {
          div: new s(0),
          mod: new s(0)
        };
      var x, _, E;
      return this.negative !== 0 && f.negative === 0 ? (E = this.neg().divmod(f, g), g !== "mod" && (x = E.div.neg()), g !== "div" && (_ = E.mod.neg(), b && _.negative !== 0 && _.iadd(f)), {
        div: x,
        mod: _
      }) : this.negative === 0 && f.negative !== 0 ? (E = this.divmod(f.neg(), g), g !== "mod" && (x = E.div.neg()), {
        div: x,
        mod: E.mod
      }) : this.negative & f.negative ? (E = this.neg().divmod(f.neg(), g), g !== "div" && (_ = E.mod.neg(), b && _.negative !== 0 && _.isub(f)), {
        div: E.div,
        mod: _
      }) : f.length > this.length || this.cmp(f) < 0 ? {
        div: new s(0),
        mod: this
      } : f.length === 1 ? g === "div" ? {
        div: this.divn(f.words[0]),
        mod: null
      } : g === "mod" ? {
        div: null,
        mod: new s(this.modrn(f.words[0]))
      } : {
        div: this.divn(f.words[0]),
        mod: new s(this.modrn(f.words[0]))
      } : this._wordDiv(f, g);
    }, s.prototype.div = function(f) {
      return this.divmod(f, "div", !1).div;
    }, s.prototype.mod = function(f) {
      return this.divmod(f, "mod", !1).mod;
    }, s.prototype.umod = function(f) {
      return this.divmod(f, "mod", !0).mod;
    }, s.prototype.divRound = function(f) {
      var g = this.divmod(f);
      if (g.mod.isZero()) return g.div;
      var b = g.div.negative !== 0 ? g.mod.isub(f) : g.mod, x = f.ushrn(1), _ = f.andln(1), E = b.cmp(x);
      return E < 0 || _ === 1 && E === 0 ? g.div : g.div.negative !== 0 ? g.div.isubn(1) : g.div.iaddn(1);
    }, s.prototype.modrn = function(f) {
      var g = f < 0;
      g && (f = -f), n(f <= 67108863);
      for (var b = (1 << 26) % f, x = 0, _ = this.length - 1; _ >= 0; _--)
        x = (b * x + (this.words[_] | 0)) % f;
      return g ? -x : x;
    }, s.prototype.modn = function(f) {
      return this.modrn(f);
    }, s.prototype.idivn = function(f) {
      var g = f < 0;
      g && (f = -f), n(f <= 67108863);
      for (var b = 0, x = this.length - 1; x >= 0; x--) {
        var _ = (this.words[x] | 0) + b * 67108864;
        this.words[x] = _ / f | 0, b = _ % f;
      }
      return this._strip(), g ? this.ineg() : this;
    }, s.prototype.divn = function(f) {
      return this.clone().idivn(f);
    }, s.prototype.egcd = function(f) {
      n(f.negative === 0), n(!f.isZero());
      var g = this, b = f.clone();
      g.negative !== 0 ? g = g.umod(f) : g = g.clone();
      for (var x = new s(1), _ = new s(0), E = new s(0), v = new s(1), M = 0; g.isEven() && b.isEven(); )
        g.iushrn(1), b.iushrn(1), ++M;
      for (var I = b.clone(), F = g.clone(); !g.isZero(); ) {
        for (var ce = 0, D = 1; !(g.words[0] & D) && ce < 26; ++ce, D <<= 1) ;
        if (ce > 0)
          for (g.iushrn(ce); ce-- > 0; )
            (x.isOdd() || _.isOdd()) && (x.iadd(I), _.isub(F)), x.iushrn(1), _.iushrn(1);
        for (var oe = 0, Z = 1; !(b.words[0] & Z) && oe < 26; ++oe, Z <<= 1) ;
        if (oe > 0)
          for (b.iushrn(oe); oe-- > 0; )
            (E.isOdd() || v.isOdd()) && (E.iadd(I), v.isub(F)), E.iushrn(1), v.iushrn(1);
        g.cmp(b) >= 0 ? (g.isub(b), x.isub(E), _.isub(v)) : (b.isub(g), E.isub(x), v.isub(_));
      }
      return {
        a: E,
        b: v,
        gcd: b.iushln(M)
      };
    }, s.prototype._invmp = function(f) {
      n(f.negative === 0), n(!f.isZero());
      var g = this, b = f.clone();
      g.negative !== 0 ? g = g.umod(f) : g = g.clone();
      for (var x = new s(1), _ = new s(0), E = b.clone(); g.cmpn(1) > 0 && b.cmpn(1) > 0; ) {
        for (var v = 0, M = 1; !(g.words[0] & M) && v < 26; ++v, M <<= 1) ;
        if (v > 0)
          for (g.iushrn(v); v-- > 0; )
            x.isOdd() && x.iadd(E), x.iushrn(1);
        for (var I = 0, F = 1; !(b.words[0] & F) && I < 26; ++I, F <<= 1) ;
        if (I > 0)
          for (b.iushrn(I); I-- > 0; )
            _.isOdd() && _.iadd(E), _.iushrn(1);
        g.cmp(b) >= 0 ? (g.isub(b), x.isub(_)) : (b.isub(g), _.isub(x));
      }
      var ce;
      return g.cmpn(1) === 0 ? ce = x : ce = _, ce.cmpn(0) < 0 && ce.iadd(f), ce;
    }, s.prototype.gcd = function(f) {
      if (this.isZero()) return f.abs();
      if (f.isZero()) return this.abs();
      var g = this.clone(), b = f.clone();
      g.negative = 0, b.negative = 0;
      for (var x = 0; g.isEven() && b.isEven(); x++)
        g.iushrn(1), b.iushrn(1);
      do {
        for (; g.isEven(); )
          g.iushrn(1);
        for (; b.isEven(); )
          b.iushrn(1);
        var _ = g.cmp(b);
        if (_ < 0) {
          var E = g;
          g = b, b = E;
        } else if (_ === 0 || b.cmpn(1) === 0)
          break;
        g.isub(b);
      } while (!0);
      return b.iushln(x);
    }, s.prototype.invm = function(f) {
      return this.egcd(f).a.umod(f);
    }, s.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, s.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, s.prototype.andln = function(f) {
      return this.words[0] & f;
    }, s.prototype.bincn = function(f) {
      n(typeof f == "number");
      var g = f % 26, b = (f - g) / 26, x = 1 << g;
      if (this.length <= b)
        return this._expand(b + 1), this.words[b] |= x, this;
      for (var _ = x, E = b; _ !== 0 && E < this.length; E++) {
        var v = this.words[E] | 0;
        v += _, _ = v >>> 26, v &= 67108863, this.words[E] = v;
      }
      return _ !== 0 && (this.words[E] = _, this.length++), this;
    }, s.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, s.prototype.cmpn = function(f) {
      var g = f < 0;
      if (this.negative !== 0 && !g) return -1;
      if (this.negative === 0 && g) return 1;
      this._strip();
      var b;
      if (this.length > 1)
        b = 1;
      else {
        g && (f = -f), n(f <= 67108863, "Number is too big");
        var x = this.words[0] | 0;
        b = x === f ? 0 : x < f ? -1 : 1;
      }
      return this.negative !== 0 ? -b | 0 : b;
    }, s.prototype.cmp = function(f) {
      if (this.negative !== 0 && f.negative === 0) return -1;
      if (this.negative === 0 && f.negative !== 0) return 1;
      var g = this.ucmp(f);
      return this.negative !== 0 ? -g | 0 : g;
    }, s.prototype.ucmp = function(f) {
      if (this.length > f.length) return 1;
      if (this.length < f.length) return -1;
      for (var g = 0, b = this.length - 1; b >= 0; b--) {
        var x = this.words[b] | 0, _ = f.words[b] | 0;
        if (x !== _) {
          x < _ ? g = -1 : x > _ && (g = 1);
          break;
        }
      }
      return g;
    }, s.prototype.gtn = function(f) {
      return this.cmpn(f) === 1;
    }, s.prototype.gt = function(f) {
      return this.cmp(f) === 1;
    }, s.prototype.gten = function(f) {
      return this.cmpn(f) >= 0;
    }, s.prototype.gte = function(f) {
      return this.cmp(f) >= 0;
    }, s.prototype.ltn = function(f) {
      return this.cmpn(f) === -1;
    }, s.prototype.lt = function(f) {
      return this.cmp(f) === -1;
    }, s.prototype.lten = function(f) {
      return this.cmpn(f) <= 0;
    }, s.prototype.lte = function(f) {
      return this.cmp(f) <= 0;
    }, s.prototype.eqn = function(f) {
      return this.cmpn(f) === 0;
    }, s.prototype.eq = function(f) {
      return this.cmp(f) === 0;
    }, s.red = function(f) {
      return new Y(f);
    }, s.prototype.toRed = function(f) {
      return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), f.convertTo(this)._forceRed(f);
    }, s.prototype.fromRed = function() {
      return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, s.prototype._forceRed = function(f) {
      return this.red = f, this;
    }, s.prototype.forceRed = function(f) {
      return n(!this.red, "Already a number in reduction context"), this._forceRed(f);
    }, s.prototype.redAdd = function(f) {
      return n(this.red, "redAdd works only with red numbers"), this.red.add(this, f);
    }, s.prototype.redIAdd = function(f) {
      return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f);
    }, s.prototype.redSub = function(f) {
      return n(this.red, "redSub works only with red numbers"), this.red.sub(this, f);
    }, s.prototype.redISub = function(f) {
      return n(this.red, "redISub works only with red numbers"), this.red.isub(this, f);
    }, s.prototype.redShl = function(f) {
      return n(this.red, "redShl works only with red numbers"), this.red.shl(this, f);
    }, s.prototype.redMul = function(f) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f);
    }, s.prototype.redIMul = function(f) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f);
    }, s.prototype.redSqr = function() {
      return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, s.prototype.redISqr = function() {
      return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, s.prototype.redSqrt = function() {
      return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, s.prototype.redInvm = function() {
      return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, s.prototype.redNeg = function() {
      return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, s.prototype.redPow = function(f) {
      return n(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f);
    };
    var V = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function te(m, f) {
      this.name = m, this.p = new s(f, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    te.prototype._tmp = function() {
      var f = new s(null);
      return f.words = new Array(Math.ceil(this.n / 13)), f;
    }, te.prototype.ireduce = function(f) {
      var g = f, b;
      do
        this.split(g, this.tmp), g = this.imulK(g), g = g.iadd(this.tmp), b = g.bitLength();
      while (b > this.n);
      var x = b < this.n ? -1 : g.ucmp(this.p);
      return x === 0 ? (g.words[0] = 0, g.length = 1) : x > 0 ? g.isub(this.p) : g.strip !== void 0 ? g.strip() : g._strip(), g;
    }, te.prototype.split = function(f, g) {
      f.iushrn(this.n, 0, g);
    }, te.prototype.imulK = function(f) {
      return f.imul(this.k);
    };
    function R() {
      te.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(R, te), R.prototype.split = function(f, g) {
      for (var b = 4194303, x = Math.min(f.length, 9), _ = 0; _ < x; _++)
        g.words[_] = f.words[_];
      if (g.length = x, f.length <= 9) {
        f.words[0] = 0, f.length = 1;
        return;
      }
      var E = f.words[9];
      for (g.words[g.length++] = E & b, _ = 10; _ < f.length; _++) {
        var v = f.words[_] | 0;
        f.words[_ - 10] = (v & b) << 4 | E >>> 22, E = v;
      }
      E >>>= 22, f.words[_ - 10] = E, E === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9;
    }, R.prototype.imulK = function(f) {
      f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
      for (var g = 0, b = 0; b < f.length; b++) {
        var x = f.words[b] | 0;
        g += x * 977, f.words[b] = g & 67108863, g = x * 64 + (g / 67108864 | 0);
      }
      return f.words[f.length - 1] === 0 && (f.length--, f.words[f.length - 1] === 0 && f.length--), f;
    };
    function K() {
      te.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(K, te);
    function ge() {
      te.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(ge, te);
    function Ee() {
      te.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(Ee, te), Ee.prototype.imulK = function(f) {
      for (var g = 0, b = 0; b < f.length; b++) {
        var x = (f.words[b] | 0) * 19 + g, _ = x & 67108863;
        x >>>= 26, f.words[b] = _, g = x;
      }
      return g !== 0 && (f.words[f.length++] = g), f;
    }, s._prime = function(f) {
      if (V[f]) return V[f];
      var g;
      if (f === "k256")
        g = new R();
      else if (f === "p224")
        g = new K();
      else if (f === "p192")
        g = new ge();
      else if (f === "p25519")
        g = new Ee();
      else
        throw new Error("Unknown prime " + f);
      return V[f] = g, g;
    };
    function Y(m) {
      if (typeof m == "string") {
        var f = s._prime(m);
        this.m = f.p, this.prime = f;
      } else
        n(m.gtn(1), "modulus must be greater than 1"), this.m = m, this.prime = null;
    }
    Y.prototype._verify1 = function(f) {
      n(f.negative === 0, "red works only with positives"), n(f.red, "red works only with red numbers");
    }, Y.prototype._verify2 = function(f, g) {
      n((f.negative | g.negative) === 0, "red works only with positives"), n(
        f.red && f.red === g.red,
        "red works only with red numbers"
      );
    }, Y.prototype.imod = function(f) {
      return this.prime ? this.prime.ireduce(f)._forceRed(this) : (d(f, f.umod(this.m)._forceRed(this)), f);
    }, Y.prototype.neg = function(f) {
      return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this);
    }, Y.prototype.add = function(f, g) {
      this._verify2(f, g);
      var b = f.add(g);
      return b.cmp(this.m) >= 0 && b.isub(this.m), b._forceRed(this);
    }, Y.prototype.iadd = function(f, g) {
      this._verify2(f, g);
      var b = f.iadd(g);
      return b.cmp(this.m) >= 0 && b.isub(this.m), b;
    }, Y.prototype.sub = function(f, g) {
      this._verify2(f, g);
      var b = f.sub(g);
      return b.cmpn(0) < 0 && b.iadd(this.m), b._forceRed(this);
    }, Y.prototype.isub = function(f, g) {
      this._verify2(f, g);
      var b = f.isub(g);
      return b.cmpn(0) < 0 && b.iadd(this.m), b;
    }, Y.prototype.shl = function(f, g) {
      return this._verify1(f), this.imod(f.ushln(g));
    }, Y.prototype.imul = function(f, g) {
      return this._verify2(f, g), this.imod(f.imul(g));
    }, Y.prototype.mul = function(f, g) {
      return this._verify2(f, g), this.imod(f.mul(g));
    }, Y.prototype.isqr = function(f) {
      return this.imul(f, f.clone());
    }, Y.prototype.sqr = function(f) {
      return this.mul(f, f);
    }, Y.prototype.sqrt = function(f) {
      if (f.isZero()) return f.clone();
      var g = this.m.andln(3);
      if (n(g % 2 === 1), g === 3) {
        var b = this.m.add(new s(1)).iushrn(2);
        return this.pow(f, b);
      }
      for (var x = this.m.subn(1), _ = 0; !x.isZero() && x.andln(1) === 0; )
        _++, x.iushrn(1);
      n(!x.isZero());
      var E = new s(1).toRed(this), v = E.redNeg(), M = this.m.subn(1).iushrn(1), I = this.m.bitLength();
      for (I = new s(2 * I * I).toRed(this); this.pow(I, M).cmp(v) !== 0; )
        I.redIAdd(v);
      for (var F = this.pow(I, x), ce = this.pow(f, x.addn(1).iushrn(1)), D = this.pow(f, x), oe = _; D.cmp(E) !== 0; ) {
        for (var Z = D, J = 0; Z.cmp(E) !== 0; J++)
          Z = Z.redSqr();
        n(J < oe);
        var Q = this.pow(F, new s(1).iushln(oe - J - 1));
        ce = ce.redMul(Q), F = Q.redSqr(), D = D.redMul(F), oe = J;
      }
      return ce;
    }, Y.prototype.invm = function(f) {
      var g = f._invmp(this.m);
      return g.negative !== 0 ? (g.negative = 0, this.imod(g).redNeg()) : this.imod(g);
    }, Y.prototype.pow = function(f, g) {
      if (g.isZero()) return new s(1).toRed(this);
      if (g.cmpn(1) === 0) return f.clone();
      var b = 4, x = new Array(1 << b);
      x[0] = new s(1).toRed(this), x[1] = f;
      for (var _ = 2; _ < x.length; _++)
        x[_] = this.mul(x[_ - 1], f);
      var E = x[0], v = 0, M = 0, I = g.bitLength() % 26;
      for (I === 0 && (I = 26), _ = g.length - 1; _ >= 0; _--) {
        for (var F = g.words[_], ce = I - 1; ce >= 0; ce--) {
          var D = F >> ce & 1;
          if (E !== x[0] && (E = this.sqr(E)), D === 0 && v === 0) {
            M = 0;
            continue;
          }
          v <<= 1, v |= D, M++, !(M !== b && (_ !== 0 || ce !== 0)) && (E = this.mul(E, x[v]), M = 0, v = 0);
        }
        I = 26;
      }
      return E;
    }, Y.prototype.convertTo = function(f) {
      var g = f.umod(this.m);
      return g === f ? g.clone() : g;
    }, Y.prototype.convertFrom = function(f) {
      var g = f.clone();
      return g.red = null, g;
    }, s.mont = function(f) {
      return new S(f);
    };
    function S(m) {
      Y.call(this, m), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(S, Y), S.prototype.convertTo = function(f) {
      return this.imod(f.ushln(this.shift));
    }, S.prototype.convertFrom = function(f) {
      var g = this.imod(f.mul(this.rinv));
      return g.red = null, g;
    }, S.prototype.imul = function(f, g) {
      if (f.isZero() || g.isZero())
        return f.words[0] = 0, f.length = 1, f;
      var b = f.imul(g), x = b.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), _ = b.isub(x).iushrn(this.shift), E = _;
      return _.cmp(this.m) >= 0 ? E = _.isub(this.m) : _.cmpn(0) < 0 && (E = _.iadd(this.m)), E._forceRed(this);
    }, S.prototype.mul = function(f, g) {
      if (f.isZero() || g.isZero()) return new s(0)._forceRed(this);
      var b = f.mul(g), x = b.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), _ = b.isub(x).iushrn(this.shift), E = _;
      return _.cmp(this.m) >= 0 ? E = _.isub(this.m) : _.cmpn(0) < 0 && (E = _.iadd(this.m)), E._forceRed(this);
    }, S.prototype.invm = function(f) {
      var g = this.imod(f._invmp(this.m).mul(this.r2));
      return g._forceRed(this);
    };
  })(t, gn);
})(zv);
var RF = zv.exports;
const sr = /* @__PURE__ */ rs(RF);
var DF = sr.BN;
function OF(t) {
  return new DF(t, 36).toString(16);
}
const NF = "strings/5.7.0", LF = new Yr(NF);
var r0;
(function(t) {
  t.current = "", t.NFC = "NFC", t.NFD = "NFD", t.NFKC = "NFKC", t.NFKD = "NFKD";
})(r0 || (r0 = {}));
var wx;
(function(t) {
  t.UNEXPECTED_CONTINUE = "unexpected continuation byte", t.BAD_PREFIX = "bad codepoint prefix", t.OVERRUN = "string overrun", t.MISSING_CONTINUE = "missing continuation byte", t.OUT_OF_RANGE = "out of UTF-8 range", t.UTF16_SURROGATE = "UTF-16 surrogate", t.OVERLONG = "overlong representation";
})(wx || (wx = {}));
function em(t, e = r0.current) {
  e != r0.current && (LF.checkNormalize(), t = t.normalize(e));
  let r = [];
  for (let n = 0; n < t.length; n++) {
    const i = t.charCodeAt(n);
    if (i < 128)
      r.push(i);
    else if (i < 2048)
      r.push(i >> 6 | 192), r.push(i & 63 | 128);
    else if ((i & 64512) == 55296) {
      n++;
      const s = t.charCodeAt(n);
      if (n >= t.length || (s & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const o = 65536 + ((i & 1023) << 10) + (s & 1023);
      r.push(o >> 18 | 240), r.push(o >> 12 & 63 | 128), r.push(o >> 6 & 63 | 128), r.push(o & 63 | 128);
    } else
      r.push(i >> 12 | 224), r.push(i >> 6 & 63 | 128), r.push(i & 63 | 128);
  }
  return wn(r);
}
const kF = `Ethereum Signed Message:
`;
function Y4(t) {
  return typeof t == "string" && (t = em(t)), qv(IF([
    em(kF),
    em(String(t.length)),
    t
  ]));
}
const $F = "address/5.7.0", $f = new Yr($F);
function xx(t) {
  zs(t, 20) || $f.throwArgumentError("invalid address", "address", t), t = t.toLowerCase();
  const e = t.substring(2).split(""), r = new Uint8Array(40);
  for (let i = 0; i < 40; i++)
    r[i] = e[i].charCodeAt(0);
  const n = wn(qv(r));
  for (let i = 0; i < 40; i += 2)
    n[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (n[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
  return "0x" + e.join("");
}
const BF = 9007199254740991;
function FF(t) {
  return Math.log10 ? Math.log10(t) : Math.log(t) / Math.LN10;
}
const Wv = {};
for (let t = 0; t < 10; t++)
  Wv[String(t)] = String(t);
for (let t = 0; t < 26; t++)
  Wv[String.fromCharCode(65 + t)] = String(10 + t);
const _x = Math.floor(FF(BF));
function jF(t) {
  t = t.toUpperCase(), t = t.substring(4) + t.substring(0, 2) + "00";
  let e = t.split("").map((n) => Wv[n]).join("");
  for (; e.length >= _x; ) {
    let n = e.substring(0, _x);
    e = parseInt(n, 10) % 97 + e.substring(n.length);
  }
  let r = String(98 - parseInt(e, 10) % 97);
  for (; r.length < 2; )
    r = "0" + r;
  return r;
}
function UF(t) {
  let e = null;
  if (typeof t != "string" && $f.throwArgumentError("invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/))
    t.substring(0, 2) !== "0x" && (t = "0x" + t), e = xx(t), t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== t && $f.throwArgumentError("bad address checksum", "address", t);
  else if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (t.substring(2, 4) !== jF(t) && $f.throwArgumentError("bad icap checksum", "address", t), e = OF(t.substring(4)); e.length < 40; )
      e = "0" + e;
    e = xx("0x" + e);
  } else
    $f.throwArgumentError("invalid address", "address", t);
  return e;
}
function _f(t, e, r) {
  Object.defineProperty(t, e, {
    enumerable: !0,
    value: r,
    writable: !1
  });
}
var Vl = {}, xr = {}, wc = J4;
function J4(t, e) {
  if (!t)
    throw new Error(e || "Assertion failed");
}
J4.equal = function(e, r, n) {
  if (e != r)
    throw new Error(n || "Assertion failed: " + e + " != " + r);
};
var w1 = { exports: {} };
typeof Object.create == "function" ? w1.exports = function(e, r) {
  r && (e.super_ = r, e.prototype = Object.create(r.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : w1.exports = function(e, r) {
  if (r) {
    e.super_ = r;
    var n = function() {
    };
    n.prototype = r.prototype, e.prototype = new n(), e.prototype.constructor = e;
  }
};
var z0 = w1.exports, qF = wc, zF = z0;
xr.inherits = zF;
function WF(t, e) {
  return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? !1 : (t.charCodeAt(e + 1) & 64512) === 56320;
}
function HF(t, e) {
  if (Array.isArray(t))
    return t.slice();
  if (!t)
    return [];
  var r = [];
  if (typeof t == "string")
    if (e) {
      if (e === "hex")
        for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), i = 0; i < t.length; i += 2)
          r.push(parseInt(t[i] + t[i + 1], 16));
    } else for (var n = 0, i = 0; i < t.length; i++) {
      var s = t.charCodeAt(i);
      s < 128 ? r[n++] = s : s < 2048 ? (r[n++] = s >> 6 | 192, r[n++] = s & 63 | 128) : WF(t, i) ? (s = 65536 + ((s & 1023) << 10) + (t.charCodeAt(++i) & 1023), r[n++] = s >> 18 | 240, r[n++] = s >> 12 & 63 | 128, r[n++] = s >> 6 & 63 | 128, r[n++] = s & 63 | 128) : (r[n++] = s >> 12 | 224, r[n++] = s >> 6 & 63 | 128, r[n++] = s & 63 | 128);
    }
  else
    for (i = 0; i < t.length; i++)
      r[i] = t[i] | 0;
  return r;
}
xr.toArray = HF;
function KF(t) {
  for (var e = "", r = 0; r < t.length; r++)
    e += Z4(t[r].toString(16));
  return e;
}
xr.toHex = KF;
function X4(t) {
  var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
  return e >>> 0;
}
xr.htonl = X4;
function VF(t, e) {
  for (var r = "", n = 0; n < t.length; n++) {
    var i = t[n];
    e === "little" && (i = X4(i)), r += Q4(i.toString(16));
  }
  return r;
}
xr.toHex32 = VF;
function Z4(t) {
  return t.length === 1 ? "0" + t : t;
}
xr.zero2 = Z4;
function Q4(t) {
  return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
}
xr.zero8 = Q4;
function GF(t, e, r, n) {
  var i = r - e;
  qF(i % 4 === 0);
  for (var s = new Array(i / 4), o = 0, a = e; o < s.length; o++, a += 4) {
    var u;
    n === "big" ? u = t[a] << 24 | t[a + 1] << 16 | t[a + 2] << 8 | t[a + 3] : u = t[a + 3] << 24 | t[a + 2] << 16 | t[a + 1] << 8 | t[a], s[o] = u >>> 0;
  }
  return s;
}
xr.join32 = GF;
function YF(t, e) {
  for (var r = new Array(t.length * 4), n = 0, i = 0; n < t.length; n++, i += 4) {
    var s = t[n];
    e === "big" ? (r[i] = s >>> 24, r[i + 1] = s >>> 16 & 255, r[i + 2] = s >>> 8 & 255, r[i + 3] = s & 255) : (r[i + 3] = s >>> 24, r[i + 2] = s >>> 16 & 255, r[i + 1] = s >>> 8 & 255, r[i] = s & 255);
  }
  return r;
}
xr.split32 = YF;
function JF(t, e) {
  return t >>> e | t << 32 - e;
}
xr.rotr32 = JF;
function XF(t, e) {
  return t << e | t >>> 32 - e;
}
xr.rotl32 = XF;
function ZF(t, e) {
  return t + e >>> 0;
}
xr.sum32 = ZF;
function QF(t, e, r) {
  return t + e + r >>> 0;
}
xr.sum32_3 = QF;
function ej(t, e, r, n) {
  return t + e + r + n >>> 0;
}
xr.sum32_4 = ej;
function tj(t, e, r, n, i) {
  return t + e + r + n + i >>> 0;
}
xr.sum32_5 = tj;
function rj(t, e, r, n) {
  var i = t[e], s = t[e + 1], o = n + s >>> 0, a = (o < n ? 1 : 0) + r + i;
  t[e] = a >>> 0, t[e + 1] = o;
}
xr.sum64 = rj;
function nj(t, e, r, n) {
  var i = e + n >>> 0, s = (i < e ? 1 : 0) + t + r;
  return s >>> 0;
}
xr.sum64_hi = nj;
function ij(t, e, r, n) {
  var i = e + n;
  return i >>> 0;
}
xr.sum64_lo = ij;
function sj(t, e, r, n, i, s, o, a) {
  var u = 0, l = e;
  l = l + n >>> 0, u += l < e ? 1 : 0, l = l + s >>> 0, u += l < s ? 1 : 0, l = l + a >>> 0, u += l < a ? 1 : 0;
  var d = t + r + i + o + u;
  return d >>> 0;
}
xr.sum64_4_hi = sj;
function oj(t, e, r, n, i, s, o, a) {
  var u = e + n + s + a;
  return u >>> 0;
}
xr.sum64_4_lo = oj;
function aj(t, e, r, n, i, s, o, a, u, l) {
  var d = 0, p = e;
  p = p + n >>> 0, d += p < e ? 1 : 0, p = p + s >>> 0, d += p < s ? 1 : 0, p = p + a >>> 0, d += p < a ? 1 : 0, p = p + l >>> 0, d += p < l ? 1 : 0;
  var w = t + r + i + o + u + d;
  return w >>> 0;
}
xr.sum64_5_hi = aj;
function cj(t, e, r, n, i, s, o, a, u, l) {
  var d = e + n + s + a + l;
  return d >>> 0;
}
xr.sum64_5_lo = cj;
function uj(t, e, r) {
  var n = e << 32 - r | t >>> r;
  return n >>> 0;
}
xr.rotr64_hi = uj;
function fj(t, e, r) {
  var n = t << 32 - r | e >>> r;
  return n >>> 0;
}
xr.rotr64_lo = fj;
function lj(t, e, r) {
  return t >>> r;
}
xr.shr64_hi = lj;
function hj(t, e, r) {
  var n = t << 32 - r | e >>> r;
  return n >>> 0;
}
xr.shr64_lo = hj;
var Lu = {}, Ex = xr, dj = wc;
function W0() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
Lu.BlockHash = W0;
W0.prototype.update = function(e, r) {
  if (e = Ex.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
    e = this.pending;
    var n = e.length % this._delta8;
    this.pending = e.slice(e.length - n, e.length), this.pending.length === 0 && (this.pending = null), e = Ex.join32(e, 0, e.length - n, this.endian);
    for (var i = 0; i < e.length; i += this._delta32)
      this._update(e, i, i + this._delta32);
  }
  return this;
};
W0.prototype.digest = function(e) {
  return this.update(this._pad()), dj(this.pending === null), this._digest(e);
};
W0.prototype._pad = function() {
  var e = this.pendingTotal, r = this._delta8, n = r - (e + this.padLength) % r, i = new Array(n + this.padLength);
  i[0] = 128;
  for (var s = 1; s < n; s++)
    i[s] = 0;
  if (e <<= 3, this.endian === "big") {
    for (var o = 8; o < this.padLength; o++)
      i[s++] = 0;
    i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = e >>> 24 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 8 & 255, i[s++] = e & 255;
  } else
    for (i[s++] = e & 255, i[s++] = e >>> 8 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 24 & 255, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, o = 8; o < this.padLength; o++)
      i[s++] = 0;
  return i;
};
var ku = {}, no = {}, pj = xr, Ws = pj.rotr32;
function gj(t, e, r, n) {
  if (t === 0)
    return e8(e, r, n);
  if (t === 1 || t === 3)
    return r8(e, r, n);
  if (t === 2)
    return t8(e, r, n);
}
no.ft_1 = gj;
function e8(t, e, r) {
  return t & e ^ ~t & r;
}
no.ch32 = e8;
function t8(t, e, r) {
  return t & e ^ t & r ^ e & r;
}
no.maj32 = t8;
function r8(t, e, r) {
  return t ^ e ^ r;
}
no.p32 = r8;
function mj(t) {
  return Ws(t, 2) ^ Ws(t, 13) ^ Ws(t, 22);
}
no.s0_256 = mj;
function vj(t) {
  return Ws(t, 6) ^ Ws(t, 11) ^ Ws(t, 25);
}
no.s1_256 = vj;
function bj(t) {
  return Ws(t, 7) ^ Ws(t, 18) ^ t >>> 3;
}
no.g0_256 = bj;
function yj(t) {
  return Ws(t, 17) ^ Ws(t, 19) ^ t >>> 10;
}
no.g1_256 = yj;
var _u = xr, wj = Lu, xj = no, tm = _u.rotl32, Ef = _u.sum32, _j = _u.sum32_5, Ej = xj.ft_1, n8 = wj.BlockHash, Sj = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function Xs() {
  if (!(this instanceof Xs))
    return new Xs();
  n8.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
_u.inherits(Xs, n8);
var Aj = Xs;
Xs.blockSize = 512;
Xs.outSize = 160;
Xs.hmacStrength = 80;
Xs.padLength = 64;
Xs.prototype._update = function(e, r) {
  for (var n = this.W, i = 0; i < 16; i++)
    n[i] = e[r + i];
  for (; i < n.length; i++)
    n[i] = tm(n[i - 3] ^ n[i - 8] ^ n[i - 14] ^ n[i - 16], 1);
  var s = this.h[0], o = this.h[1], a = this.h[2], u = this.h[3], l = this.h[4];
  for (i = 0; i < n.length; i++) {
    var d = ~~(i / 20), p = _j(tm(s, 5), Ej(d, o, a, u), l, n[i], Sj[d]);
    l = u, u = a, a = tm(o, 30), o = s, s = p;
  }
  this.h[0] = Ef(this.h[0], s), this.h[1] = Ef(this.h[1], o), this.h[2] = Ef(this.h[2], a), this.h[3] = Ef(this.h[3], u), this.h[4] = Ef(this.h[4], l);
};
Xs.prototype._digest = function(e) {
  return e === "hex" ? _u.toHex32(this.h, "big") : _u.split32(this.h, "big");
};
var Eu = xr, Pj = Lu, $u = no, Mj = wc, gs = Eu.sum32, Ij = Eu.sum32_4, Cj = Eu.sum32_5, Tj = $u.ch32, Rj = $u.maj32, Dj = $u.s0_256, Oj = $u.s1_256, Nj = $u.g0_256, Lj = $u.g1_256, i8 = Pj.BlockHash, kj = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function Zs() {
  if (!(this instanceof Zs))
    return new Zs();
  i8.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = kj, this.W = new Array(64);
}
Eu.inherits(Zs, i8);
var s8 = Zs;
Zs.blockSize = 512;
Zs.outSize = 256;
Zs.hmacStrength = 192;
Zs.padLength = 64;
Zs.prototype._update = function(e, r) {
  for (var n = this.W, i = 0; i < 16; i++)
    n[i] = e[r + i];
  for (; i < n.length; i++)
    n[i] = Ij(Lj(n[i - 2]), n[i - 7], Nj(n[i - 15]), n[i - 16]);
  var s = this.h[0], o = this.h[1], a = this.h[2], u = this.h[3], l = this.h[4], d = this.h[5], p = this.h[6], w = this.h[7];
  for (Mj(this.k.length === n.length), i = 0; i < n.length; i++) {
    var A = Cj(w, Oj(l), Tj(l, d, p), this.k[i], n[i]), P = gs(Dj(s), Rj(s, o, a));
    w = p, p = d, d = l, l = gs(u, A), u = a, a = o, o = s, s = gs(A, P);
  }
  this.h[0] = gs(this.h[0], s), this.h[1] = gs(this.h[1], o), this.h[2] = gs(this.h[2], a), this.h[3] = gs(this.h[3], u), this.h[4] = gs(this.h[4], l), this.h[5] = gs(this.h[5], d), this.h[6] = gs(this.h[6], p), this.h[7] = gs(this.h[7], w);
};
Zs.prototype._digest = function(e) {
  return e === "hex" ? Eu.toHex32(this.h, "big") : Eu.split32(this.h, "big");
};
var x1 = xr, o8 = s8;
function jo() {
  if (!(this instanceof jo))
    return new jo();
  o8.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
x1.inherits(jo, o8);
var $j = jo;
jo.blockSize = 512;
jo.outSize = 224;
jo.hmacStrength = 192;
jo.padLength = 64;
jo.prototype._digest = function(e) {
  return e === "hex" ? x1.toHex32(this.h.slice(0, 7), "big") : x1.split32(this.h.slice(0, 7), "big");
};
var xi = xr, Bj = Lu, Fj = wc, Hs = xi.rotr64_hi, Ks = xi.rotr64_lo, a8 = xi.shr64_hi, c8 = xi.shr64_lo, na = xi.sum64, rm = xi.sum64_hi, nm = xi.sum64_lo, jj = xi.sum64_4_hi, Uj = xi.sum64_4_lo, qj = xi.sum64_5_hi, zj = xi.sum64_5_lo, u8 = Bj.BlockHash, Wj = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function Ss() {
  if (!(this instanceof Ss))
    return new Ss();
  u8.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = Wj, this.W = new Array(160);
}
xi.inherits(Ss, u8);
var f8 = Ss;
Ss.blockSize = 1024;
Ss.outSize = 512;
Ss.hmacStrength = 192;
Ss.padLength = 128;
Ss.prototype._prepareBlock = function(e, r) {
  for (var n = this.W, i = 0; i < 32; i++)
    n[i] = e[r + i];
  for (; i < n.length; i += 2) {
    var s = tU(n[i - 4], n[i - 3]), o = rU(n[i - 4], n[i - 3]), a = n[i - 14], u = n[i - 13], l = Qj(n[i - 30], n[i - 29]), d = eU(n[i - 30], n[i - 29]), p = n[i - 32], w = n[i - 31];
    n[i] = jj(
      s,
      o,
      a,
      u,
      l,
      d,
      p,
      w
    ), n[i + 1] = Uj(
      s,
      o,
      a,
      u,
      l,
      d,
      p,
      w
    );
  }
};
Ss.prototype._update = function(e, r) {
  this._prepareBlock(e, r);
  var n = this.W, i = this.h[0], s = this.h[1], o = this.h[2], a = this.h[3], u = this.h[4], l = this.h[5], d = this.h[6], p = this.h[7], w = this.h[8], A = this.h[9], P = this.h[10], N = this.h[11], L = this.h[12], $ = this.h[13], B = this.h[14], H = this.h[15];
  Fj(this.k.length === n.length);
  for (var W = 0; W < n.length; W += 2) {
    var V = B, te = H, R = Xj(w, A), K = Zj(w, A), ge = Hj(w, A, P, N, L), Ee = Kj(w, A, P, N, L, $), Y = this.k[W], S = this.k[W + 1], m = n[W], f = n[W + 1], g = qj(
      V,
      te,
      R,
      K,
      ge,
      Ee,
      Y,
      S,
      m,
      f
    ), b = zj(
      V,
      te,
      R,
      K,
      ge,
      Ee,
      Y,
      S,
      m,
      f
    );
    V = Yj(i, s), te = Jj(i, s), R = Vj(i, s, o, a, u), K = Gj(i, s, o, a, u, l);
    var x = rm(V, te, R, K), _ = nm(V, te, R, K);
    B = L, H = $, L = P, $ = N, P = w, N = A, w = rm(d, p, g, b), A = nm(p, p, g, b), d = u, p = l, u = o, l = a, o = i, a = s, i = rm(g, b, x, _), s = nm(g, b, x, _);
  }
  na(this.h, 0, i, s), na(this.h, 2, o, a), na(this.h, 4, u, l), na(this.h, 6, d, p), na(this.h, 8, w, A), na(this.h, 10, P, N), na(this.h, 12, L, $), na(this.h, 14, B, H);
};
Ss.prototype._digest = function(e) {
  return e === "hex" ? xi.toHex32(this.h, "big") : xi.split32(this.h, "big");
};
function Hj(t, e, r, n, i) {
  var s = t & r ^ ~t & i;
  return s < 0 && (s += 4294967296), s;
}
function Kj(t, e, r, n, i, s) {
  var o = e & n ^ ~e & s;
  return o < 0 && (o += 4294967296), o;
}
function Vj(t, e, r, n, i) {
  var s = t & r ^ t & i ^ r & i;
  return s < 0 && (s += 4294967296), s;
}
function Gj(t, e, r, n, i, s) {
  var o = e & n ^ e & s ^ n & s;
  return o < 0 && (o += 4294967296), o;
}
function Yj(t, e) {
  var r = Hs(t, e, 28), n = Hs(e, t, 2), i = Hs(e, t, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function Jj(t, e) {
  var r = Ks(t, e, 28), n = Ks(e, t, 2), i = Ks(e, t, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function Xj(t, e) {
  var r = Hs(t, e, 14), n = Hs(t, e, 18), i = Hs(e, t, 9), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function Zj(t, e) {
  var r = Ks(t, e, 14), n = Ks(t, e, 18), i = Ks(e, t, 9), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function Qj(t, e) {
  var r = Hs(t, e, 1), n = Hs(t, e, 8), i = a8(t, e, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function eU(t, e) {
  var r = Ks(t, e, 1), n = Ks(t, e, 8), i = c8(t, e, 7), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function tU(t, e) {
  var r = Hs(t, e, 19), n = Hs(e, t, 29), i = a8(t, e, 6), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
function rU(t, e) {
  var r = Ks(t, e, 19), n = Ks(e, t, 29), i = c8(t, e, 6), s = r ^ n ^ i;
  return s < 0 && (s += 4294967296), s;
}
var _1 = xr, l8 = f8;
function Uo() {
  if (!(this instanceof Uo))
    return new Uo();
  l8.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
_1.inherits(Uo, l8);
var nU = Uo;
Uo.blockSize = 1024;
Uo.outSize = 384;
Uo.hmacStrength = 192;
Uo.padLength = 128;
Uo.prototype._digest = function(e) {
  return e === "hex" ? _1.toHex32(this.h.slice(0, 12), "big") : _1.split32(this.h.slice(0, 12), "big");
};
ku.sha1 = Aj;
ku.sha224 = $j;
ku.sha256 = s8;
ku.sha384 = nU;
ku.sha512 = f8;
var h8 = {}, hc = xr, iU = Lu, ud = hc.rotl32, Sx = hc.sum32, Sf = hc.sum32_3, Ax = hc.sum32_4, d8 = iU.BlockHash;
function Qs() {
  if (!(this instanceof Qs))
    return new Qs();
  d8.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
hc.inherits(Qs, d8);
h8.ripemd160 = Qs;
Qs.blockSize = 512;
Qs.outSize = 160;
Qs.hmacStrength = 192;
Qs.padLength = 64;
Qs.prototype._update = function(e, r) {
  for (var n = this.h[0], i = this.h[1], s = this.h[2], o = this.h[3], a = this.h[4], u = n, l = i, d = s, p = o, w = a, A = 0; A < 80; A++) {
    var P = Sx(
      ud(
        Ax(n, Px(A, i, s, o), e[aU[A] + r], sU(A)),
        uU[A]
      ),
      a
    );
    n = a, a = o, o = ud(s, 10), s = i, i = P, P = Sx(
      ud(
        Ax(u, Px(79 - A, l, d, p), e[cU[A] + r], oU(A)),
        fU[A]
      ),
      w
    ), u = w, w = p, p = ud(d, 10), d = l, l = P;
  }
  P = Sf(this.h[1], s, p), this.h[1] = Sf(this.h[2], o, w), this.h[2] = Sf(this.h[3], a, u), this.h[3] = Sf(this.h[4], n, l), this.h[4] = Sf(this.h[0], i, d), this.h[0] = P;
};
Qs.prototype._digest = function(e) {
  return e === "hex" ? hc.toHex32(this.h, "little") : hc.split32(this.h, "little");
};
function Px(t, e, r, n) {
  return t <= 15 ? e ^ r ^ n : t <= 31 ? e & r | ~e & n : t <= 47 ? (e | ~r) ^ n : t <= 63 ? e & n | r & ~n : e ^ (r | ~n);
}
function sU(t) {
  return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
}
function oU(t) {
  return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
}
var aU = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], cU = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], uU = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], fU = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], lU = xr, hU = wc;
function Su(t, e, r) {
  if (!(this instanceof Su))
    return new Su(t, e, r);
  this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(lU.toArray(e, r));
}
var dU = Su;
Su.prototype._init = function(e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), hU(e.length <= this.blockSize);
  for (var r = e.length; r < this.blockSize; r++)
    e.push(0);
  for (r = 0; r < e.length; r++)
    e[r] ^= 54;
  for (this.inner = new this.Hash().update(e), r = 0; r < e.length; r++)
    e[r] ^= 106;
  this.outer = new this.Hash().update(e);
};
Su.prototype.update = function(e, r) {
  return this.inner.update(e, r), this;
};
Su.prototype.digest = function(e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function(t) {
  var e = t;
  e.utils = xr, e.common = Lu, e.sha = ku, e.ripemd = h8, e.hmac = dU, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160;
})(Vl);
const xo = /* @__PURE__ */ rs(Vl);
function Bu(t, e, r) {
  return r = {
    path: e,
    exports: {},
    require: function(n, i) {
      return pU(n, i ?? r.path);
    }
  }, t(r, r.exports), r.exports;
}
function pU() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var Hv = p8;
function p8(t, e) {
  if (!t)
    throw new Error(e || "Assertion failed");
}
p8.equal = function(e, r, n) {
  if (e != r)
    throw new Error(n || "Assertion failed: " + e + " != " + r);
};
var xs = Bu(function(t, e) {
  var r = e;
  function n(o, a) {
    if (Array.isArray(o))
      return o.slice();
    if (!o)
      return [];
    var u = [];
    if (typeof o != "string") {
      for (var l = 0; l < o.length; l++)
        u[l] = o[l] | 0;
      return u;
    }
    if (a === "hex") {
      o = o.replace(/[^a-z0-9]+/ig, ""), o.length % 2 !== 0 && (o = "0" + o);
      for (var l = 0; l < o.length; l += 2)
        u.push(parseInt(o[l] + o[l + 1], 16));
    } else
      for (var l = 0; l < o.length; l++) {
        var d = o.charCodeAt(l), p = d >> 8, w = d & 255;
        p ? u.push(p, w) : u.push(w);
      }
    return u;
  }
  r.toArray = n;
  function i(o) {
    return o.length === 1 ? "0" + o : o;
  }
  r.zero2 = i;
  function s(o) {
    for (var a = "", u = 0; u < o.length; u++)
      a += i(o[u].toString(16));
    return a;
  }
  r.toHex = s, r.encode = function(a, u) {
    return u === "hex" ? s(a) : a;
  };
}), Bi = Bu(function(t, e) {
  var r = e;
  r.assert = Hv, r.toArray = xs.toArray, r.zero2 = xs.zero2, r.toHex = xs.toHex, r.encode = xs.encode;
  function n(u, l, d) {
    var p = new Array(Math.max(u.bitLength(), d) + 1);
    p.fill(0);
    for (var w = 1 << l + 1, A = u.clone(), P = 0; P < p.length; P++) {
      var N, L = A.andln(w - 1);
      A.isOdd() ? (L > (w >> 1) - 1 ? N = (w >> 1) - L : N = L, A.isubn(N)) : N = 0, p[P] = N, A.iushrn(1);
    }
    return p;
  }
  r.getNAF = n;
  function i(u, l) {
    var d = [
      [],
      []
    ];
    u = u.clone(), l = l.clone();
    for (var p = 0, w = 0, A; u.cmpn(-p) > 0 || l.cmpn(-w) > 0; ) {
      var P = u.andln(3) + p & 3, N = l.andln(3) + w & 3;
      P === 3 && (P = -1), N === 3 && (N = -1);
      var L;
      P & 1 ? (A = u.andln(7) + p & 7, (A === 3 || A === 5) && N === 2 ? L = -P : L = P) : L = 0, d[0].push(L);
      var $;
      N & 1 ? (A = l.andln(7) + w & 7, (A === 3 || A === 5) && P === 2 ? $ = -N : $ = N) : $ = 0, d[1].push($), 2 * p === L + 1 && (p = 1 - p), 2 * w === $ + 1 && (w = 1 - w), u.iushrn(1), l.iushrn(1);
    }
    return d;
  }
  r.getJSF = i;
  function s(u, l, d) {
    var p = "_" + l;
    u.prototype[l] = function() {
      return this[p] !== void 0 ? this[p] : this[p] = d.call(this);
    };
  }
  r.cachedProperty = s;
  function o(u) {
    return typeof u == "string" ? r.toArray(u, "hex") : u;
  }
  r.parseBytes = o;
  function a(u) {
    return new sr(u, "hex", "le");
  }
  r.intFromLE = a;
}), n0 = Bi.getNAF, gU = Bi.getJSF, i0 = Bi.assert;
function Ta(t, e) {
  this.type = t, this.p = new sr(e.p, 16), this.red = e.prime ? sr.red(e.prime) : sr.mont(this.p), this.zero = new sr(0).toRed(this.red), this.one = new sr(1).toRed(this.red), this.two = new sr(2).toRed(this.red), this.n = e.n && new sr(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var r = this.n && this.p.div(this.n);
  !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var xc = Ta;
Ta.prototype.point = function() {
  throw new Error("Not implemented");
};
Ta.prototype.validate = function() {
  throw new Error("Not implemented");
};
Ta.prototype._fixedNafMul = function(e, r) {
  i0(e.precomputed);
  var n = e._getDoubles(), i = n0(r, 1, this._bitLength), s = (1 << n.step + 1) - (n.step % 2 === 0 ? 2 : 1);
  s /= 3;
  var o = [], a, u;
  for (a = 0; a < i.length; a += n.step) {
    u = 0;
    for (var l = a + n.step - 1; l >= a; l--)
      u = (u << 1) + i[l];
    o.push(u);
  }
  for (var d = this.jpoint(null, null, null), p = this.jpoint(null, null, null), w = s; w > 0; w--) {
    for (a = 0; a < o.length; a++)
      u = o[a], u === w ? p = p.mixedAdd(n.points[a]) : u === -w && (p = p.mixedAdd(n.points[a].neg()));
    d = d.add(p);
  }
  return d.toP();
};
Ta.prototype._wnafMul = function(e, r) {
  var n = 4, i = e._getNAFPoints(n);
  n = i.wnd;
  for (var s = i.points, o = n0(r, n, this._bitLength), a = this.jpoint(null, null, null), u = o.length - 1; u >= 0; u--) {
    for (var l = 0; u >= 0 && o[u] === 0; u--)
      l++;
    if (u >= 0 && l++, a = a.dblp(l), u < 0)
      break;
    var d = o[u];
    i0(d !== 0), e.type === "affine" ? d > 0 ? a = a.mixedAdd(s[d - 1 >> 1]) : a = a.mixedAdd(s[-d - 1 >> 1].neg()) : d > 0 ? a = a.add(s[d - 1 >> 1]) : a = a.add(s[-d - 1 >> 1].neg());
  }
  return e.type === "affine" ? a.toP() : a;
};
Ta.prototype._wnafMulAdd = function(e, r, n, i, s) {
  var o = this._wnafT1, a = this._wnafT2, u = this._wnafT3, l = 0, d, p, w;
  for (d = 0; d < i; d++) {
    w = r[d];
    var A = w._getNAFPoints(e);
    o[d] = A.wnd, a[d] = A.points;
  }
  for (d = i - 1; d >= 1; d -= 2) {
    var P = d - 1, N = d;
    if (o[P] !== 1 || o[N] !== 1) {
      u[P] = n0(n[P], o[P], this._bitLength), u[N] = n0(n[N], o[N], this._bitLength), l = Math.max(u[P].length, l), l = Math.max(u[N].length, l);
      continue;
    }
    var L = [
      r[P],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      r[N]
      /* 7 */
    ];
    r[P].y.cmp(r[N].y) === 0 ? (L[1] = r[P].add(r[N]), L[2] = r[P].toJ().mixedAdd(r[N].neg())) : r[P].y.cmp(r[N].y.redNeg()) === 0 ? (L[1] = r[P].toJ().mixedAdd(r[N]), L[2] = r[P].add(r[N].neg())) : (L[1] = r[P].toJ().mixedAdd(r[N]), L[2] = r[P].toJ().mixedAdd(r[N].neg()));
    var $ = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], B = gU(n[P], n[N]);
    for (l = Math.max(B[0].length, l), u[P] = new Array(l), u[N] = new Array(l), p = 0; p < l; p++) {
      var H = B[0][p] | 0, W = B[1][p] | 0;
      u[P][p] = $[(H + 1) * 3 + (W + 1)], u[N][p] = 0, a[P] = L;
    }
  }
  var V = this.jpoint(null, null, null), te = this._wnafT4;
  for (d = l; d >= 0; d--) {
    for (var R = 0; d >= 0; ) {
      var K = !0;
      for (p = 0; p < i; p++)
        te[p] = u[p][d] | 0, te[p] !== 0 && (K = !1);
      if (!K)
        break;
      R++, d--;
    }
    if (d >= 0 && R++, V = V.dblp(R), d < 0)
      break;
    for (p = 0; p < i; p++) {
      var ge = te[p];
      ge !== 0 && (ge > 0 ? w = a[p][ge - 1 >> 1] : ge < 0 && (w = a[p][-ge - 1 >> 1].neg()), w.type === "affine" ? V = V.mixedAdd(w) : V = V.add(w));
    }
  }
  for (d = 0; d < i; d++)
    a[d] = null;
  return s ? V : V.toP();
};
function is(t, e) {
  this.curve = t, this.type = e, this.precomputed = null;
}
Ta.BasePoint = is;
is.prototype.eq = function() {
  throw new Error("Not implemented");
};
is.prototype.validate = function() {
  return this.curve.validate(this);
};
Ta.prototype.decodePoint = function(e, r) {
  e = Bi.toArray(e, r);
  var n = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * n) {
    e[0] === 6 ? i0(e[e.length - 1] % 2 === 0) : e[0] === 7 && i0(e[e.length - 1] % 2 === 1);
    var i = this.point(
      e.slice(1, 1 + n),
      e.slice(1 + n, 1 + 2 * n)
    );
    return i;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n)
    return this.pointFromX(e.slice(1, 1 + n), e[0] === 3);
  throw new Error("Unknown point format");
};
is.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
is.prototype._encode = function(e) {
  var r = this.curve.p.byteLength(), n = this.getX().toArray("be", r);
  return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", r));
};
is.prototype.encode = function(e, r) {
  return Bi.encode(this._encode(r), e);
};
is.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var r = {
    doubles: null,
    naf: null,
    beta: null
  };
  return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
};
is.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var r = this.precomputed.doubles;
  return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : !1;
};
is.prototype._getDoubles = function(e, r) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var n = [this], i = this, s = 0; s < r; s += e) {
    for (var o = 0; o < e; o++)
      i = i.dbl();
    n.push(i);
  }
  return {
    step: e,
    points: n
  };
};
is.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var r = [this], n = (1 << e) - 1, i = n === 1 ? null : this.dbl(), s = 1; s < n; s++)
    r[s] = r[s - 1].add(i);
  return {
    wnd: e,
    points: r
  };
};
is.prototype._getBeta = function() {
  return null;
};
is.prototype.dblp = function(e) {
  for (var r = this, n = 0; n < e; n++)
    r = r.dbl();
  return r;
};
var Kv = Bu(function(t) {
  typeof Object.create == "function" ? t.exports = function(r, n) {
    n && (r.super_ = n, r.prototype = Object.create(n.prototype, {
      constructor: {
        value: r,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : t.exports = function(r, n) {
    if (n) {
      r.super_ = n;
      var i = function() {
      };
      i.prototype = n.prototype, r.prototype = new i(), r.prototype.constructor = r;
    }
  };
}), mU = Bi.assert;
function ss(t) {
  xc.call(this, "short", t), this.a = new sr(t.a, 16).toRed(this.red), this.b = new sr(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
Kv(ss, xc);
var vU = ss;
ss.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var r, n;
    if (e.beta)
      r = new sr(e.beta, 16).toRed(this.red);
    else {
      var i = this._getEndoRoots(this.p);
      r = i[0].cmp(i[1]) < 0 ? i[0] : i[1], r = r.toRed(this.red);
    }
    if (e.lambda)
      n = new sr(e.lambda, 16);
    else {
      var s = this._getEndoRoots(this.n);
      this.g.mul(s[0]).x.cmp(this.g.x.redMul(r)) === 0 ? n = s[0] : (n = s[1], mU(this.g.mul(n).x.cmp(this.g.x.redMul(r)) === 0));
    }
    var o;
    return e.basis ? o = e.basis.map(function(a) {
      return {
        a: new sr(a.a, 16),
        b: new sr(a.b, 16)
      };
    }) : o = this._getEndoBasis(n), {
      beta: r,
      lambda: n,
      basis: o
    };
  }
};
ss.prototype._getEndoRoots = function(e) {
  var r = e === this.p ? this.red : sr.mont(e), n = new sr(2).toRed(r).redInvm(), i = n.redNeg(), s = new sr(3).toRed(r).redNeg().redSqrt().redMul(n), o = i.redAdd(s).fromRed(), a = i.redSub(s).fromRed();
  return [o, a];
};
ss.prototype._getEndoBasis = function(e) {
  for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), n = e, i = this.n.clone(), s = new sr(1), o = new sr(0), a = new sr(0), u = new sr(1), l, d, p, w, A, P, N, L = 0, $, B; n.cmpn(0) !== 0; ) {
    var H = i.div(n);
    $ = i.sub(H.mul(n)), B = a.sub(H.mul(s));
    var W = u.sub(H.mul(o));
    if (!p && $.cmp(r) < 0)
      l = N.neg(), d = s, p = $.neg(), w = B;
    else if (p && ++L === 2)
      break;
    N = $, i = n, n = $, a = s, s = B, u = o, o = W;
  }
  A = $.neg(), P = B;
  var V = p.sqr().add(w.sqr()), te = A.sqr().add(P.sqr());
  return te.cmp(V) >= 0 && (A = l, P = d), p.negative && (p = p.neg(), w = w.neg()), A.negative && (A = A.neg(), P = P.neg()), [
    { a: p, b: w },
    { a: A, b: P }
  ];
};
ss.prototype._endoSplit = function(e) {
  var r = this.endo.basis, n = r[0], i = r[1], s = i.b.mul(e).divRound(this.n), o = n.b.neg().mul(e).divRound(this.n), a = s.mul(n.a), u = o.mul(i.a), l = s.mul(n.b), d = o.mul(i.b), p = e.sub(a).sub(u), w = l.add(d).neg();
  return { k1: p, k2: w };
};
ss.prototype.pointFromX = function(e, r) {
  e = new sr(e, 16), e.red || (e = e.toRed(this.red));
  var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), i = n.redSqrt();
  if (i.redSqr().redSub(n).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var s = i.fromRed().isOdd();
  return (r && !s || !r && s) && (i = i.redNeg()), this.point(e, i);
};
ss.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var r = e.x, n = e.y, i = this.a.redMul(r), s = r.redSqr().redMul(r).redIAdd(i).redIAdd(this.b);
  return n.redSqr().redISub(s).cmpn(0) === 0;
};
ss.prototype._endoWnafMulAdd = function(e, r, n) {
  for (var i = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < e.length; o++) {
    var a = this._endoSplit(r[o]), u = e[o], l = u._getBeta();
    a.k1.negative && (a.k1.ineg(), u = u.neg(!0)), a.k2.negative && (a.k2.ineg(), l = l.neg(!0)), i[o * 2] = u, i[o * 2 + 1] = l, s[o * 2] = a.k1, s[o * 2 + 1] = a.k2;
  }
  for (var d = this._wnafMulAdd(1, i, s, o * 2, n), p = 0; p < o * 2; p++)
    i[p] = null, s[p] = null;
  return d;
};
function kn(t, e, r, n) {
  xc.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new sr(e, 16), this.y = new sr(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
Kv(kn, xc.BasePoint);
ss.prototype.point = function(e, r, n) {
  return new kn(this, e, r, n);
};
ss.prototype.pointFromJSON = function(e, r) {
  return kn.fromJSON(this, e, r);
};
kn.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var n = this.curve, i = function(s) {
        return n.point(s.x.redMul(n.endo.beta), s.y);
      };
      e.beta = r, r.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(i)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(i)
        }
      };
    }
    return r;
  }
};
kn.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
kn.fromJSON = function(e, r, n) {
  typeof r == "string" && (r = JSON.parse(r));
  var i = e.point(r[0], r[1], n);
  if (!r[2])
    return i;
  function s(a) {
    return e.point(a[0], a[1], n);
  }
  var o = r[2];
  return i.precomputed = {
    beta: null,
    doubles: o.doubles && {
      step: o.doubles.step,
      points: [i].concat(o.doubles.points.map(s))
    },
    naf: o.naf && {
      wnd: o.naf.wnd,
      points: [i].concat(o.naf.points.map(s))
    }
  }, i;
};
kn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
kn.prototype.isInfinity = function() {
  return this.inf;
};
kn.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var r = this.y.redSub(e.y);
  r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
  var n = r.redSqr().redISub(this.x).redISub(e.x), i = r.redMul(this.x.redSub(n)).redISub(this.y);
  return this.curve.point(n, i);
};
kn.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var r = this.curve.a, n = this.x.redSqr(), i = e.redInvm(), s = n.redAdd(n).redIAdd(n).redIAdd(r).redMul(i), o = s.redSqr().redISub(this.x.redAdd(this.x)), a = s.redMul(this.x.redSub(o)).redISub(this.y);
  return this.curve.point(o, a);
};
kn.prototype.getX = function() {
  return this.x.fromRed();
};
kn.prototype.getY = function() {
  return this.y.fromRed();
};
kn.prototype.mul = function(e) {
  return e = new sr(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
kn.prototype.mulAdd = function(e, r, n) {
  var i = [this, r], s = [e, n];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2);
};
kn.prototype.jmulAdd = function(e, r, n) {
  var i = [this, r], s = [e, n];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, !0) : this.curve._wnafMulAdd(1, i, s, 2, !0);
};
kn.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
kn.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var r = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var n = this.precomputed, i = function(s) {
      return s.neg();
    };
    r.precomputed = {
      naf: n.naf && {
        wnd: n.naf.wnd,
        points: n.naf.points.map(i)
      },
      doubles: n.doubles && {
        step: n.doubles.step,
        points: n.doubles.points.map(i)
      }
    };
  }
  return r;
};
kn.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function zn(t, e, r, n) {
  xc.BasePoint.call(this, t, "jacobian"), e === null && r === null && n === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new sr(0)) : (this.x = new sr(e, 16), this.y = new sr(r, 16), this.z = new sr(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
Kv(zn, xc.BasePoint);
ss.prototype.jpoint = function(e, r, n) {
  return new zn(this, e, r, n);
};
zn.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), r = e.redSqr(), n = this.x.redMul(r), i = this.y.redMul(r).redMul(e);
  return this.curve.point(n, i);
};
zn.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
zn.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var r = e.z.redSqr(), n = this.z.redSqr(), i = this.x.redMul(r), s = e.x.redMul(n), o = this.y.redMul(r.redMul(e.z)), a = e.y.redMul(n.redMul(this.z)), u = i.redSub(s), l = o.redSub(a);
  if (u.cmpn(0) === 0)
    return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var d = u.redSqr(), p = d.redMul(u), w = i.redMul(d), A = l.redSqr().redIAdd(p).redISub(w).redISub(w), P = l.redMul(w.redISub(A)).redISub(o.redMul(p)), N = this.z.redMul(e.z).redMul(u);
  return this.curve.jpoint(A, P, N);
};
zn.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var r = this.z.redSqr(), n = this.x, i = e.x.redMul(r), s = this.y, o = e.y.redMul(r).redMul(this.z), a = n.redSub(i), u = s.redSub(o);
  if (a.cmpn(0) === 0)
    return u.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var l = a.redSqr(), d = l.redMul(a), p = n.redMul(l), w = u.redSqr().redIAdd(d).redISub(p).redISub(p), A = u.redMul(p.redISub(w)).redISub(s.redMul(d)), P = this.z.redMul(a);
  return this.curve.jpoint(w, A, P);
};
zn.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var r;
  if (this.curve.zeroA || this.curve.threeA) {
    var n = this;
    for (r = 0; r < e; r++)
      n = n.dbl();
    return n;
  }
  var i = this.curve.a, s = this.curve.tinv, o = this.x, a = this.y, u = this.z, l = u.redSqr().redSqr(), d = a.redAdd(a);
  for (r = 0; r < e; r++) {
    var p = o.redSqr(), w = d.redSqr(), A = w.redSqr(), P = p.redAdd(p).redIAdd(p).redIAdd(i.redMul(l)), N = o.redMul(w), L = P.redSqr().redISub(N.redAdd(N)), $ = N.redISub(L), B = P.redMul($);
    B = B.redIAdd(B).redISub(A);
    var H = d.redMul(u);
    r + 1 < e && (l = l.redMul(A)), o = L, u = H, d = B;
  }
  return this.curve.jpoint(o, d.redMul(s), u);
};
zn.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
zn.prototype._zeroDbl = function() {
  var e, r, n;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
    a = a.redIAdd(a);
    var u = i.redAdd(i).redIAdd(i), l = u.redSqr().redISub(a).redISub(a), d = o.redIAdd(o);
    d = d.redIAdd(d), d = d.redIAdd(d), e = l, r = u.redMul(a.redISub(l)).redISub(d), n = this.y.redAdd(this.y);
  } else {
    var p = this.x.redSqr(), w = this.y.redSqr(), A = w.redSqr(), P = this.x.redAdd(w).redSqr().redISub(p).redISub(A);
    P = P.redIAdd(P);
    var N = p.redAdd(p).redIAdd(p), L = N.redSqr(), $ = A.redIAdd(A);
    $ = $.redIAdd($), $ = $.redIAdd($), e = L.redISub(P).redISub(P), r = N.redMul(P.redISub(e)).redISub($), n = this.y.redMul(this.z), n = n.redIAdd(n);
  }
  return this.curve.jpoint(e, r, n);
};
zn.prototype._threeDbl = function() {
  var e, r, n;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
    a = a.redIAdd(a);
    var u = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a), l = u.redSqr().redISub(a).redISub(a);
    e = l;
    var d = o.redIAdd(o);
    d = d.redIAdd(d), d = d.redIAdd(d), r = u.redMul(a.redISub(l)).redISub(d), n = this.y.redAdd(this.y);
  } else {
    var p = this.z.redSqr(), w = this.y.redSqr(), A = this.x.redMul(w), P = this.x.redSub(p).redMul(this.x.redAdd(p));
    P = P.redAdd(P).redIAdd(P);
    var N = A.redIAdd(A);
    N = N.redIAdd(N);
    var L = N.redAdd(N);
    e = P.redSqr().redISub(L), n = this.y.redAdd(this.z).redSqr().redISub(w).redISub(p);
    var $ = w.redSqr();
    $ = $.redIAdd($), $ = $.redIAdd($), $ = $.redIAdd($), r = P.redMul(N.redISub(e)).redISub($);
  }
  return this.curve.jpoint(e, r, n);
};
zn.prototype._dbl = function() {
  var e = this.curve.a, r = this.x, n = this.y, i = this.z, s = i.redSqr().redSqr(), o = r.redSqr(), a = n.redSqr(), u = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(s)), l = r.redAdd(r);
  l = l.redIAdd(l);
  var d = l.redMul(a), p = u.redSqr().redISub(d.redAdd(d)), w = d.redISub(p), A = a.redSqr();
  A = A.redIAdd(A), A = A.redIAdd(A), A = A.redIAdd(A);
  var P = u.redMul(w).redISub(A), N = n.redAdd(n).redMul(i);
  return this.curve.jpoint(p, P, N);
};
zn.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr(), i = r.redSqr(), s = e.redAdd(e).redIAdd(e), o = s.redSqr(), a = this.x.redAdd(r).redSqr().redISub(e).redISub(i);
  a = a.redIAdd(a), a = a.redAdd(a).redIAdd(a), a = a.redISub(o);
  var u = a.redSqr(), l = i.redIAdd(i);
  l = l.redIAdd(l), l = l.redIAdd(l), l = l.redIAdd(l);
  var d = s.redIAdd(a).redSqr().redISub(o).redISub(u).redISub(l), p = r.redMul(d);
  p = p.redIAdd(p), p = p.redIAdd(p);
  var w = this.x.redMul(u).redISub(p);
  w = w.redIAdd(w), w = w.redIAdd(w);
  var A = this.y.redMul(d.redMul(l.redISub(d)).redISub(a.redMul(u)));
  A = A.redIAdd(A), A = A.redIAdd(A), A = A.redIAdd(A);
  var P = this.z.redAdd(a).redSqr().redISub(n).redISub(u);
  return this.curve.jpoint(w, A, P);
};
zn.prototype.mul = function(e, r) {
  return e = new sr(e, r), this.curve._wnafMul(this, e);
};
zn.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var r = this.z.redSqr(), n = e.z.redSqr();
  if (this.x.redMul(n).redISub(e.x.redMul(r)).cmpn(0) !== 0)
    return !1;
  var i = r.redMul(this.z), s = n.redMul(e.z);
  return this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0) === 0;
};
zn.prototype.eqXToP = function(e) {
  var r = this.z.redSqr(), n = e.toRed(this.curve.red).redMul(r);
  if (this.x.cmp(n) === 0)
    return !0;
  for (var i = e.clone(), s = this.curve.redN.redMul(r); ; ) {
    if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)
      return !1;
    if (n.redIAdd(s), this.x.cmp(n) === 0)
      return !0;
  }
};
zn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
zn.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var Pd = Bu(function(t, e) {
  var r = e;
  r.base = xc, r.short = vU, r.mont = /*RicMoo:ethers:require(./mont)*/
  null, r.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
}), Md = Bu(function(t, e) {
  var r = e, n = Bi.assert;
  function i(a) {
    a.type === "short" ? this.curve = new Pd.short(a) : a.type === "edwards" ? this.curve = new Pd.edwards(a) : this.curve = new Pd.mont(a), this.g = this.curve.g, this.n = this.curve.n, this.hash = a.hash, n(this.g.validate(), "Invalid curve"), n(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  r.PresetCurve = i;
  function s(a, u) {
    Object.defineProperty(r, a, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var l = new i(u);
        return Object.defineProperty(r, a, {
          configurable: !0,
          enumerable: !0,
          value: l
        }), l;
      }
    });
  }
  s("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: xo.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), s("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: xo.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), s("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: xo.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), s("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: xo.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), s("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: xo.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), s("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: xo.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), s("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: xo.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var o;
  try {
    o = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch {
    o = void 0;
  }
  s("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: xo.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      o
    ]
  });
});
function wa(t) {
  if (!(this instanceof wa))
    return new wa(t);
  this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var e = xs.toArray(t.entropy, t.entropyEnc || "hex"), r = xs.toArray(t.nonce, t.nonceEnc || "hex"), n = xs.toArray(t.pers, t.persEnc || "hex");
  Hv(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(e, r, n);
}
var g8 = wa;
wa.prototype._init = function(e, r, n) {
  var i = e.concat(r).concat(n);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var s = 0; s < this.V.length; s++)
    this.K[s] = 0, this.V[s] = 1;
  this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656;
};
wa.prototype._hmac = function() {
  return new xo.hmac(this.hash, this.K);
};
wa.prototype._update = function(e) {
  var r = this._hmac().update(this.V).update([0]);
  e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
wa.prototype.reseed = function(e, r, n, i) {
  typeof r != "string" && (i = n, n = r, r = null), e = xs.toArray(e, r), n = xs.toArray(n, i), Hv(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(n || [])), this._reseed = 1;
};
wa.prototype.generate = function(e, r, n, i) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof r != "string" && (i = n, n = r, r = null), n && (n = xs.toArray(n, i || "hex"), this._update(n));
  for (var s = []; s.length < e; )
    this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
  var o = s.slice(0, e);
  return this._update(n), this._reseed++, xs.encode(o, r);
};
var E1 = Bi.assert;
function Zn(t, e) {
  this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var Vv = Zn;
Zn.fromPublic = function(e, r, n) {
  return r instanceof Zn ? r : new Zn(e, {
    pub: r,
    pubEnc: n
  });
};
Zn.fromPrivate = function(e, r, n) {
  return r instanceof Zn ? r : new Zn(e, {
    priv: r,
    privEnc: n
  });
};
Zn.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
Zn.prototype.getPublic = function(e, r) {
  return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
};
Zn.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
Zn.prototype._importPrivate = function(e, r) {
  this.priv = new sr(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
Zn.prototype._importPublic = function(e, r) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? E1(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && E1(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, r);
};
Zn.prototype.derive = function(e) {
  return e.validate() || E1(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
Zn.prototype.sign = function(e, r, n) {
  return this.ec.sign(e, this, r, n);
};
Zn.prototype.verify = function(e, r) {
  return this.ec.verify(e, r, this);
};
Zn.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var bU = Bi.assert;
function H0(t, e) {
  if (t instanceof H0)
    return t;
  this._importDER(t, e) || (bU(t.r && t.s, "Signature without r or s"), this.r = new sr(t.r, 16), this.s = new sr(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
}
var K0 = H0;
function yU() {
  this.place = 0;
}
function im(t, e) {
  var r = t[e.place++];
  if (!(r & 128))
    return r;
  var n = r & 15;
  if (n === 0 || n > 4)
    return !1;
  for (var i = 0, s = 0, o = e.place; s < n; s++, o++)
    i <<= 8, i |= t[o], i >>>= 0;
  return i <= 127 ? !1 : (e.place = o, i);
}
function Mx(t) {
  for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r; )
    e++;
  return e === 0 ? t : t.slice(e);
}
H0.prototype._importDER = function(e, r) {
  e = Bi.toArray(e, r);
  var n = new yU();
  if (e[n.place++] !== 48)
    return !1;
  var i = im(e, n);
  if (i === !1 || i + n.place !== e.length || e[n.place++] !== 2)
    return !1;
  var s = im(e, n);
  if (s === !1)
    return !1;
  var o = e.slice(n.place, s + n.place);
  if (n.place += s, e[n.place++] !== 2)
    return !1;
  var a = im(e, n);
  if (a === !1 || e.length !== a + n.place)
    return !1;
  var u = e.slice(n.place, a + n.place);
  if (o[0] === 0)
    if (o[1] & 128)
      o = o.slice(1);
    else
      return !1;
  if (u[0] === 0)
    if (u[1] & 128)
      u = u.slice(1);
    else
      return !1;
  return this.r = new sr(o), this.s = new sr(u), this.recoveryParam = null, !0;
};
function sm(t, e) {
  if (e < 128) {
    t.push(e);
    return;
  }
  var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
  for (t.push(r | 128); --r; )
    t.push(e >>> (r << 3) & 255);
  t.push(e);
}
H0.prototype.toDER = function(e) {
  var r = this.r.toArray(), n = this.s.toArray();
  for (r[0] & 128 && (r = [0].concat(r)), n[0] & 128 && (n = [0].concat(n)), r = Mx(r), n = Mx(n); !n[0] && !(n[1] & 128); )
    n = n.slice(1);
  var i = [2];
  sm(i, r.length), i = i.concat(r), i.push(2), sm(i, n.length);
  var s = i.concat(n), o = [48];
  return sm(o, s.length), o = o.concat(s), Bi.encode(o, e);
};
var wU = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
), m8 = Bi.assert;
function es(t) {
  if (!(this instanceof es))
    return new es(t);
  typeof t == "string" && (m8(
    Object.prototype.hasOwnProperty.call(Md, t),
    "Unknown curve " + t
  ), t = Md[t]), t instanceof Md.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
}
var xU = es;
es.prototype.keyPair = function(e) {
  return new Vv(this, e);
};
es.prototype.keyFromPrivate = function(e, r) {
  return Vv.fromPrivate(this, e, r);
};
es.prototype.keyFromPublic = function(e, r) {
  return Vv.fromPublic(this, e, r);
};
es.prototype.genKeyPair = function(e) {
  e || (e = {});
  for (var r = new g8({
    hash: this.hash,
    pers: e.pers,
    persEnc: e.persEnc || "utf8",
    entropy: e.entropy || wU(this.hash.hmacStrength),
    entropyEnc: e.entropy && e.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), n = this.n.byteLength(), i = this.n.sub(new sr(2)); ; ) {
    var s = new sr(r.generate(n));
    if (!(s.cmp(i) > 0))
      return s.iaddn(1), this.keyFromPrivate(s);
  }
};
es.prototype._truncateToN = function(e, r) {
  var n = e.byteLength() * 8 - this.n.bitLength();
  return n > 0 && (e = e.ushrn(n)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
};
es.prototype.sign = function(e, r, n, i) {
  typeof n == "object" && (i = n, n = null), i || (i = {}), r = this.keyFromPrivate(r, n), e = this._truncateToN(new sr(e, 16));
  for (var s = this.n.byteLength(), o = r.getPrivate().toArray("be", s), a = e.toArray("be", s), u = new g8({
    hash: this.hash,
    entropy: o,
    nonce: a,
    pers: i.pers,
    persEnc: i.persEnc || "utf8"
  }), l = this.n.sub(new sr(1)), d = 0; ; d++) {
    var p = i.k ? i.k(d) : new sr(u.generate(this.n.byteLength()));
    if (p = this._truncateToN(p, !0), !(p.cmpn(1) <= 0 || p.cmp(l) >= 0)) {
      var w = this.g.mul(p);
      if (!w.isInfinity()) {
        var A = w.getX(), P = A.umod(this.n);
        if (P.cmpn(0) !== 0) {
          var N = p.invm(this.n).mul(P.mul(r.getPrivate()).iadd(e));
          if (N = N.umod(this.n), N.cmpn(0) !== 0) {
            var L = (w.getY().isOdd() ? 1 : 0) | (A.cmp(P) !== 0 ? 2 : 0);
            return i.canonical && N.cmp(this.nh) > 0 && (N = this.n.sub(N), L ^= 1), new K0({ r: P, s: N, recoveryParam: L });
          }
        }
      }
    }
  }
};
es.prototype.verify = function(e, r, n, i) {
  e = this._truncateToN(new sr(e, 16)), n = this.keyFromPublic(n, i), r = new K0(r, "hex");
  var s = r.r, o = r.s;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0 || o.cmpn(1) < 0 || o.cmp(this.n) >= 0)
    return !1;
  var a = o.invm(this.n), u = a.mul(e).umod(this.n), l = a.mul(s).umod(this.n), d;
  return this.curve._maxwellTrick ? (d = this.g.jmulAdd(u, n.getPublic(), l), d.isInfinity() ? !1 : d.eqXToP(s)) : (d = this.g.mulAdd(u, n.getPublic(), l), d.isInfinity() ? !1 : d.getX().umod(this.n).cmp(s) === 0);
};
es.prototype.recoverPubKey = function(t, e, r, n) {
  m8((3 & r) === r, "The recovery param is more than two bits"), e = new K0(e, n);
  var i = this.n, s = new sr(t), o = e.r, a = e.s, u = r & 1, l = r >> 1;
  if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && l)
    throw new Error("Unable to find sencond key candinate");
  l ? o = this.curve.pointFromX(o.add(this.curve.n), u) : o = this.curve.pointFromX(o, u);
  var d = e.r.invm(i), p = i.sub(s).mul(d).umod(i), w = a.mul(d).umod(i);
  return this.g.mulAdd(p, o, w);
};
es.prototype.getKeyRecoveryParam = function(t, e, r, n) {
  if (e = new K0(e, n), e.recoveryParam !== null)
    return e.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var s;
    try {
      s = this.recoverPubKey(t, e, i);
    } catch {
      continue;
    }
    if (s.eq(r))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var _U = Bu(function(t, e) {
  var r = e;
  r.version = "6.5.4", r.utils = Bi, r.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }, r.curve = Pd, r.curves = Md, r.ec = xU, r.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
}), EU = _U.ec;
const SU = "signing-key/5.7.0", S1 = new Yr(SU);
let om = null;
function ua() {
  return om || (om = new EU("secp256k1")), om;
}
class AU {
  constructor(e) {
    _f(this, "curve", "secp256k1"), _f(this, "privateKey", Ti(e)), TF(this.privateKey) !== 32 && S1.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    const r = ua().keyFromPrivate(wn(this.privateKey));
    _f(this, "publicKey", "0x" + r.getPublic(!1, "hex")), _f(this, "compressedPublicKey", "0x" + r.getPublic(!0, "hex")), _f(this, "_isSigningKey", !0);
  }
  _addPoint(e) {
    const r = ua().keyFromPublic(wn(this.publicKey)), n = ua().keyFromPublic(wn(e));
    return "0x" + r.pub.add(n.pub).encodeCompressed("hex");
  }
  signDigest(e) {
    const r = ua().keyFromPrivate(wn(this.privateKey)), n = wn(e);
    n.length !== 32 && S1.throwArgumentError("bad digest length", "digest", e);
    const i = r.sign(n, { canonical: !0 });
    return G4({
      recoveryParam: i.recoveryParam,
      r: lu("0x" + i.r.toString(16), 32),
      s: lu("0x" + i.s.toString(16), 32)
    });
  }
  computeSharedSecret(e) {
    const r = ua().keyFromPrivate(wn(this.privateKey)), n = ua().keyFromPublic(wn(v8(e)));
    return lu("0x" + r.derive(n.getPublic()).toString(16), 32);
  }
  static isSigningKey(e) {
    return !!(e && e._isSigningKey);
  }
}
function PU(t, e) {
  const r = G4(e), n = { r: wn(r.r), s: wn(r.s) };
  return "0x" + ua().recoverPubKey(wn(t), n, r.recoveryParam).encode("hex", !1);
}
function v8(t, e) {
  const r = wn(t);
  return r.length === 32 ? new AU(r).publicKey : r.length === 33 ? "0x" + ua().keyFromPublic(r).getPublic(!1, "hex") : r.length === 65 ? Ti(r) : S1.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
var Ix;
(function(t) {
  t[t.legacy = 0] = "legacy", t[t.eip2930 = 1] = "eip2930", t[t.eip1559 = 2] = "eip1559";
})(Ix || (Ix = {}));
function MU(t) {
  const e = v8(t);
  return UF(yx(qv(yx(e, 1)), 12));
}
function IU(t, e) {
  return MU(PU(wn(t), e));
}
var Gv = {}, V0 = {};
Object.defineProperty(V0, "__esModule", { value: !0 });
var Gn = ar, A1 = $i, CU = 20;
function TU(t, e, r) {
  for (var n = 1634760805, i = 857760878, s = 2036477234, o = 1797285236, a = r[3] << 24 | r[2] << 16 | r[1] << 8 | r[0], u = r[7] << 24 | r[6] << 16 | r[5] << 8 | r[4], l = r[11] << 24 | r[10] << 16 | r[9] << 8 | r[8], d = r[15] << 24 | r[14] << 16 | r[13] << 8 | r[12], p = r[19] << 24 | r[18] << 16 | r[17] << 8 | r[16], w = r[23] << 24 | r[22] << 16 | r[21] << 8 | r[20], A = r[27] << 24 | r[26] << 16 | r[25] << 8 | r[24], P = r[31] << 24 | r[30] << 16 | r[29] << 8 | r[28], N = e[3] << 24 | e[2] << 16 | e[1] << 8 | e[0], L = e[7] << 24 | e[6] << 16 | e[5] << 8 | e[4], $ = e[11] << 24 | e[10] << 16 | e[9] << 8 | e[8], B = e[15] << 24 | e[14] << 16 | e[13] << 8 | e[12], H = n, W = i, V = s, te = o, R = a, K = u, ge = l, Ee = d, Y = p, S = w, m = A, f = P, g = N, b = L, x = $, _ = B, E = 0; E < CU; E += 2)
    H = H + R | 0, g ^= H, g = g >>> 16 | g << 16, Y = Y + g | 0, R ^= Y, R = R >>> 20 | R << 12, W = W + K | 0, b ^= W, b = b >>> 16 | b << 16, S = S + b | 0, K ^= S, K = K >>> 20 | K << 12, V = V + ge | 0, x ^= V, x = x >>> 16 | x << 16, m = m + x | 0, ge ^= m, ge = ge >>> 20 | ge << 12, te = te + Ee | 0, _ ^= te, _ = _ >>> 16 | _ << 16, f = f + _ | 0, Ee ^= f, Ee = Ee >>> 20 | Ee << 12, V = V + ge | 0, x ^= V, x = x >>> 24 | x << 8, m = m + x | 0, ge ^= m, ge = ge >>> 25 | ge << 7, te = te + Ee | 0, _ ^= te, _ = _ >>> 24 | _ << 8, f = f + _ | 0, Ee ^= f, Ee = Ee >>> 25 | Ee << 7, W = W + K | 0, b ^= W, b = b >>> 24 | b << 8, S = S + b | 0, K ^= S, K = K >>> 25 | K << 7, H = H + R | 0, g ^= H, g = g >>> 24 | g << 8, Y = Y + g | 0, R ^= Y, R = R >>> 25 | R << 7, H = H + K | 0, _ ^= H, _ = _ >>> 16 | _ << 16, m = m + _ | 0, K ^= m, K = K >>> 20 | K << 12, W = W + ge | 0, g ^= W, g = g >>> 16 | g << 16, f = f + g | 0, ge ^= f, ge = ge >>> 20 | ge << 12, V = V + Ee | 0, b ^= V, b = b >>> 16 | b << 16, Y = Y + b | 0, Ee ^= Y, Ee = Ee >>> 20 | Ee << 12, te = te + R | 0, x ^= te, x = x >>> 16 | x << 16, S = S + x | 0, R ^= S, R = R >>> 20 | R << 12, V = V + Ee | 0, b ^= V, b = b >>> 24 | b << 8, Y = Y + b | 0, Ee ^= Y, Ee = Ee >>> 25 | Ee << 7, te = te + R | 0, x ^= te, x = x >>> 24 | x << 8, S = S + x | 0, R ^= S, R = R >>> 25 | R << 7, W = W + ge | 0, g ^= W, g = g >>> 24 | g << 8, f = f + g | 0, ge ^= f, ge = ge >>> 25 | ge << 7, H = H + K | 0, _ ^= H, _ = _ >>> 24 | _ << 8, m = m + _ | 0, K ^= m, K = K >>> 25 | K << 7;
  Gn.writeUint32LE(H + n | 0, t, 0), Gn.writeUint32LE(W + i | 0, t, 4), Gn.writeUint32LE(V + s | 0, t, 8), Gn.writeUint32LE(te + o | 0, t, 12), Gn.writeUint32LE(R + a | 0, t, 16), Gn.writeUint32LE(K + u | 0, t, 20), Gn.writeUint32LE(ge + l | 0, t, 24), Gn.writeUint32LE(Ee + d | 0, t, 28), Gn.writeUint32LE(Y + p | 0, t, 32), Gn.writeUint32LE(S + w | 0, t, 36), Gn.writeUint32LE(m + A | 0, t, 40), Gn.writeUint32LE(f + P | 0, t, 44), Gn.writeUint32LE(g + N | 0, t, 48), Gn.writeUint32LE(b + L | 0, t, 52), Gn.writeUint32LE(x + $ | 0, t, 56), Gn.writeUint32LE(_ + B | 0, t, 60);
}
function b8(t, e, r, n, i) {
  if (i === void 0 && (i = 0), t.length !== 32)
    throw new Error("ChaCha: key size must be 32 bytes");
  if (n.length < r.length)
    throw new Error("ChaCha: destination is shorter than source");
  var s, o;
  if (i === 0) {
    if (e.length !== 8 && e.length !== 12)
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    s = new Uint8Array(16), o = s.length - e.length, s.set(e, o);
  } else {
    if (e.length !== 16)
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    s = e, o = i;
  }
  for (var a = new Uint8Array(64), u = 0; u < r.length; u += 64) {
    TU(a, s, t);
    for (var l = u; l < u + 64 && l < r.length; l++)
      n[l] = r[l] ^ a[l - u];
    DU(s, 0, o);
  }
  return A1.wipe(a), i === 0 && A1.wipe(s), n;
}
V0.streamXOR = b8;
function RU(t, e, r, n) {
  return n === void 0 && (n = 0), A1.wipe(r), b8(t, e, r, r, n);
}
V0.stream = RU;
function DU(t, e, r) {
  for (var n = 1; r--; )
    n = n + (t[e] & 255) | 0, t[e] = n & 255, n >>>= 8, e++;
  if (n > 0)
    throw new Error("ChaCha: counter overflow");
}
var y8 = {}, Ra = {};
Object.defineProperty(Ra, "__esModule", { value: !0 });
function OU(t, e, r) {
  return ~(t - 1) & e | t - 1 & r;
}
Ra.select = OU;
function NU(t, e) {
  return (t | 0) - (e | 0) - 1 >>> 31 & 1;
}
Ra.lessOrEqual = NU;
function w8(t, e) {
  if (t.length !== e.length)
    return 0;
  for (var r = 0, n = 0; n < t.length; n++)
    r |= t[n] ^ e[n];
  return 1 & r - 1 >>> 8;
}
Ra.compare = w8;
function LU(t, e) {
  return t.length === 0 || e.length === 0 ? !1 : w8(t, e) !== 0;
}
Ra.equal = LU;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = Ra, r = $i;
  t.DIGEST_LENGTH = 16;
  var n = (
    /** @class */
    function() {
      function o(a) {
        this.digestLength = t.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
        var u = a[0] | a[1] << 8;
        this._r[0] = u & 8191;
        var l = a[2] | a[3] << 8;
        this._r[1] = (u >>> 13 | l << 3) & 8191;
        var d = a[4] | a[5] << 8;
        this._r[2] = (l >>> 10 | d << 6) & 7939;
        var p = a[6] | a[7] << 8;
        this._r[3] = (d >>> 7 | p << 9) & 8191;
        var w = a[8] | a[9] << 8;
        this._r[4] = (p >>> 4 | w << 12) & 255, this._r[5] = w >>> 1 & 8190;
        var A = a[10] | a[11] << 8;
        this._r[6] = (w >>> 14 | A << 2) & 8191;
        var P = a[12] | a[13] << 8;
        this._r[7] = (A >>> 11 | P << 5) & 8065;
        var N = a[14] | a[15] << 8;
        this._r[8] = (P >>> 8 | N << 8) & 8191, this._r[9] = N >>> 5 & 127, this._pad[0] = a[16] | a[17] << 8, this._pad[1] = a[18] | a[19] << 8, this._pad[2] = a[20] | a[21] << 8, this._pad[3] = a[22] | a[23] << 8, this._pad[4] = a[24] | a[25] << 8, this._pad[5] = a[26] | a[27] << 8, this._pad[6] = a[28] | a[29] << 8, this._pad[7] = a[30] | a[31] << 8;
      }
      return o.prototype._blocks = function(a, u, l) {
        for (var d = this._fin ? 0 : 2048, p = this._h[0], w = this._h[1], A = this._h[2], P = this._h[3], N = this._h[4], L = this._h[5], $ = this._h[6], B = this._h[7], H = this._h[8], W = this._h[9], V = this._r[0], te = this._r[1], R = this._r[2], K = this._r[3], ge = this._r[4], Ee = this._r[5], Y = this._r[6], S = this._r[7], m = this._r[8], f = this._r[9]; l >= 16; ) {
          var g = a[u + 0] | a[u + 1] << 8;
          p += g & 8191;
          var b = a[u + 2] | a[u + 3] << 8;
          w += (g >>> 13 | b << 3) & 8191;
          var x = a[u + 4] | a[u + 5] << 8;
          A += (b >>> 10 | x << 6) & 8191;
          var _ = a[u + 6] | a[u + 7] << 8;
          P += (x >>> 7 | _ << 9) & 8191;
          var E = a[u + 8] | a[u + 9] << 8;
          N += (_ >>> 4 | E << 12) & 8191, L += E >>> 1 & 8191;
          var v = a[u + 10] | a[u + 11] << 8;
          $ += (E >>> 14 | v << 2) & 8191;
          var M = a[u + 12] | a[u + 13] << 8;
          B += (v >>> 11 | M << 5) & 8191;
          var I = a[u + 14] | a[u + 15] << 8;
          H += (M >>> 8 | I << 8) & 8191, W += I >>> 5 | d;
          var F = 0, ce = F;
          ce += p * V, ce += w * (5 * f), ce += A * (5 * m), ce += P * (5 * S), ce += N * (5 * Y), F = ce >>> 13, ce &= 8191, ce += L * (5 * Ee), ce += $ * (5 * ge), ce += B * (5 * K), ce += H * (5 * R), ce += W * (5 * te), F += ce >>> 13, ce &= 8191;
          var D = F;
          D += p * te, D += w * V, D += A * (5 * f), D += P * (5 * m), D += N * (5 * S), F = D >>> 13, D &= 8191, D += L * (5 * Y), D += $ * (5 * Ee), D += B * (5 * ge), D += H * (5 * K), D += W * (5 * R), F += D >>> 13, D &= 8191;
          var oe = F;
          oe += p * R, oe += w * te, oe += A * V, oe += P * (5 * f), oe += N * (5 * m), F = oe >>> 13, oe &= 8191, oe += L * (5 * S), oe += $ * (5 * Y), oe += B * (5 * Ee), oe += H * (5 * ge), oe += W * (5 * K), F += oe >>> 13, oe &= 8191;
          var Z = F;
          Z += p * K, Z += w * R, Z += A * te, Z += P * V, Z += N * (5 * f), F = Z >>> 13, Z &= 8191, Z += L * (5 * m), Z += $ * (5 * S), Z += B * (5 * Y), Z += H * (5 * Ee), Z += W * (5 * ge), F += Z >>> 13, Z &= 8191;
          var J = F;
          J += p * ge, J += w * K, J += A * R, J += P * te, J += N * V, F = J >>> 13, J &= 8191, J += L * (5 * f), J += $ * (5 * m), J += B * (5 * S), J += H * (5 * Y), J += W * (5 * Ee), F += J >>> 13, J &= 8191;
          var Q = F;
          Q += p * Ee, Q += w * ge, Q += A * K, Q += P * R, Q += N * te, F = Q >>> 13, Q &= 8191, Q += L * V, Q += $ * (5 * f), Q += B * (5 * m), Q += H * (5 * S), Q += W * (5 * Y), F += Q >>> 13, Q &= 8191;
          var T = F;
          T += p * Y, T += w * Ee, T += A * ge, T += P * K, T += N * R, F = T >>> 13, T &= 8191, T += L * te, T += $ * V, T += B * (5 * f), T += H * (5 * m), T += W * (5 * S), F += T >>> 13, T &= 8191;
          var X = F;
          X += p * S, X += w * Y, X += A * Ee, X += P * ge, X += N * K, F = X >>> 13, X &= 8191, X += L * R, X += $ * te, X += B * V, X += H * (5 * f), X += W * (5 * m), F += X >>> 13, X &= 8191;
          var re = F;
          re += p * m, re += w * S, re += A * Y, re += P * Ee, re += N * ge, F = re >>> 13, re &= 8191, re += L * K, re += $ * R, re += B * te, re += H * V, re += W * (5 * f), F += re >>> 13, re &= 8191;
          var pe = F;
          pe += p * f, pe += w * m, pe += A * S, pe += P * Y, pe += N * Ee, F = pe >>> 13, pe &= 8191, pe += L * ge, pe += $ * K, pe += B * R, pe += H * te, pe += W * V, F += pe >>> 13, pe &= 8191, F = (F << 2) + F | 0, F = F + ce | 0, ce = F & 8191, F = F >>> 13, D += F, p = ce, w = D, A = oe, P = Z, N = J, L = Q, $ = T, B = X, H = re, W = pe, u += 16, l -= 16;
        }
        this._h[0] = p, this._h[1] = w, this._h[2] = A, this._h[3] = P, this._h[4] = N, this._h[5] = L, this._h[6] = $, this._h[7] = B, this._h[8] = H, this._h[9] = W;
      }, o.prototype.finish = function(a, u) {
        u === void 0 && (u = 0);
        var l = new Uint16Array(10), d, p, w, A;
        if (this._leftover) {
          for (A = this._leftover, this._buffer[A++] = 1; A < 16; A++)
            this._buffer[A] = 0;
          this._fin = 1, this._blocks(this._buffer, 0, 16);
        }
        for (d = this._h[1] >>> 13, this._h[1] &= 8191, A = 2; A < 10; A++)
          this._h[A] += d, d = this._h[A] >>> 13, this._h[A] &= 8191;
        for (this._h[0] += d * 5, d = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += d, d = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += d, l[0] = this._h[0] + 5, d = l[0] >>> 13, l[0] &= 8191, A = 1; A < 10; A++)
          l[A] = this._h[A] + d, d = l[A] >>> 13, l[A] &= 8191;
        for (l[9] -= 8192, p = (d ^ 1) - 1, A = 0; A < 10; A++)
          l[A] &= p;
        for (p = ~p, A = 0; A < 10; A++)
          this._h[A] = this._h[A] & p | l[A];
        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, w = this._h[0] + this._pad[0], this._h[0] = w & 65535, A = 1; A < 8; A++)
          w = (this._h[A] + this._pad[A] | 0) + (w >>> 16) | 0, this._h[A] = w & 65535;
        return a[u + 0] = this._h[0] >>> 0, a[u + 1] = this._h[0] >>> 8, a[u + 2] = this._h[1] >>> 0, a[u + 3] = this._h[1] >>> 8, a[u + 4] = this._h[2] >>> 0, a[u + 5] = this._h[2] >>> 8, a[u + 6] = this._h[3] >>> 0, a[u + 7] = this._h[3] >>> 8, a[u + 8] = this._h[4] >>> 0, a[u + 9] = this._h[4] >>> 8, a[u + 10] = this._h[5] >>> 0, a[u + 11] = this._h[5] >>> 8, a[u + 12] = this._h[6] >>> 0, a[u + 13] = this._h[6] >>> 8, a[u + 14] = this._h[7] >>> 0, a[u + 15] = this._h[7] >>> 8, this._finished = !0, this;
      }, o.prototype.update = function(a) {
        var u = 0, l = a.length, d;
        if (this._leftover) {
          d = 16 - this._leftover, d > l && (d = l);
          for (var p = 0; p < d; p++)
            this._buffer[this._leftover + p] = a[u + p];
          if (l -= d, u += d, this._leftover += d, this._leftover < 16)
            return this;
          this._blocks(this._buffer, 0, 16), this._leftover = 0;
        }
        if (l >= 16 && (d = l - l % 16, this._blocks(a, u, d), u += d, l -= d), l) {
          for (var p = 0; p < l; p++)
            this._buffer[this._leftover + p] = a[u + p];
          this._leftover += l;
        }
        return this;
      }, o.prototype.digest = function() {
        if (this._finished)
          throw new Error("Poly1305 was finished");
        var a = new Uint8Array(16);
        return this.finish(a), a;
      }, o.prototype.clean = function() {
        return r.wipe(this._buffer), r.wipe(this._r), r.wipe(this._h), r.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;
      }, o;
    }()
  );
  t.Poly1305 = n;
  function i(o, a) {
    var u = new n(o);
    u.update(a);
    var l = u.digest();
    return u.clean(), l;
  }
  t.oneTimeAuth = i;
  function s(o, a) {
    return o.length !== t.DIGEST_LENGTH || a.length !== t.DIGEST_LENGTH ? !1 : e.equal(o, a);
  }
  t.equal = s;
})(y8);
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = V0, r = y8, n = $i, i = ar, s = Ra;
  t.KEY_LENGTH = 32, t.NONCE_LENGTH = 12, t.TAG_LENGTH = 16;
  var o = new Uint8Array(16), a = (
    /** @class */
    function() {
      function u(l) {
        if (this.nonceLength = t.NONCE_LENGTH, this.tagLength = t.TAG_LENGTH, l.length !== t.KEY_LENGTH)
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(l);
      }
      return u.prototype.seal = function(l, d, p, w) {
        if (l.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        var A = new Uint8Array(16);
        A.set(l, A.length - l.length);
        var P = new Uint8Array(32);
        e.stream(this._key, A, P, 4);
        var N = d.length + this.tagLength, L;
        if (w) {
          if (w.length !== N)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          L = w;
        } else
          L = new Uint8Array(N);
        return e.streamXOR(this._key, A, d, L, 4), this._authenticate(L.subarray(L.length - this.tagLength, L.length), P, L.subarray(0, L.length - this.tagLength), p), n.wipe(A), L;
      }, u.prototype.open = function(l, d, p, w) {
        if (l.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        if (d.length < this.tagLength)
          return null;
        var A = new Uint8Array(16);
        A.set(l, A.length - l.length);
        var P = new Uint8Array(32);
        e.stream(this._key, A, P, 4);
        var N = new Uint8Array(this.tagLength);
        if (this._authenticate(N, P, d.subarray(0, d.length - this.tagLength), p), !s.equal(N, d.subarray(d.length - this.tagLength, d.length)))
          return null;
        var L = d.length - this.tagLength, $;
        if (w) {
          if (w.length !== L)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          $ = w;
        } else
          $ = new Uint8Array(L);
        return e.streamXOR(this._key, A, d.subarray(0, d.length - this.tagLength), $, 4), n.wipe(A), $;
      }, u.prototype.clean = function() {
        return n.wipe(this._key), this;
      }, u.prototype._authenticate = function(l, d, p, w) {
        var A = new r.Poly1305(d);
        w && (A.update(w), w.length % 16 > 0 && A.update(o.subarray(w.length % 16))), A.update(p), p.length % 16 > 0 && A.update(o.subarray(p.length % 16));
        var P = new Uint8Array(8);
        w && i.writeUint64LE(w.length, P), A.update(P), i.writeUint64LE(p.length, P), A.update(P);
        for (var N = A.digest(), L = 0; L < N.length; L++)
          l[L] = N[L];
        A.clean(), n.wipe(N), n.wipe(P);
      }, u;
    }()
  );
  t.ChaCha20Poly1305 = a;
})(Gv);
var x8 = {}, Gl = {}, Yv = {};
Object.defineProperty(Yv, "__esModule", { value: !0 });
function kU(t) {
  return typeof t.saveState < "u" && typeof t.restoreState < "u" && typeof t.cleanSavedState < "u";
}
Yv.isSerializableHash = kU;
Object.defineProperty(Gl, "__esModule", { value: !0 });
var Ls = Yv, $U = Ra, BU = $i, _8 = (
  /** @class */
  function() {
    function t(e, r) {
      this._finished = !1, this._inner = new e(), this._outer = new e(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
      var n = new Uint8Array(this.blockSize);
      r.length > this.blockSize ? this._inner.update(r).finish(n).clean() : n.set(r);
      for (var i = 0; i < n.length; i++)
        n[i] ^= 54;
      this._inner.update(n);
      for (var i = 0; i < n.length; i++)
        n[i] ^= 106;
      this._outer.update(n), Ls.isSerializableHash(this._inner) && Ls.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), BU.wipe(n);
    }
    return t.prototype.reset = function() {
      if (!Ls.isSerializableHash(this._inner) || !Ls.isSerializableHash(this._outer))
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, t.prototype.clean = function() {
      Ls.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), Ls.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();
    }, t.prototype.update = function(e) {
      return this._inner.update(e), this;
    }, t.prototype.finish = function(e) {
      return this._finished ? (this._outer.finish(e), this) : (this._inner.finish(e), this._outer.update(e.subarray(0, this.digestLength)).finish(e), this._finished = !0, this);
    }, t.prototype.digest = function() {
      var e = new Uint8Array(this.digestLength);
      return this.finish(e), e;
    }, t.prototype.saveState = function() {
      if (!Ls.isSerializableHash(this._inner))
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      return this._inner.saveState();
    }, t.prototype.restoreState = function(e) {
      if (!Ls.isSerializableHash(this._inner) || !Ls.isSerializableHash(this._outer))
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      return this._inner.restoreState(e), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, t.prototype.cleanSavedState = function(e) {
      if (!Ls.isSerializableHash(this._inner))
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      this._inner.cleanSavedState(e);
    }, t;
  }()
);
Gl.HMAC = _8;
function FU(t, e, r) {
  var n = new _8(t, e);
  n.update(r);
  var i = n.digest();
  return n.clean(), i;
}
Gl.hmac = FU;
Gl.equal = $U.equal;
Object.defineProperty(x8, "__esModule", { value: !0 });
var Cx = Gl, Tx = $i, jU = (
  /** @class */
  function() {
    function t(e, r, n, i) {
      n === void 0 && (n = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = e, this._info = i;
      var s = Cx.hmac(this._hash, n, r);
      this._hmac = new Cx.HMAC(e, s), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;
    }
    return t.prototype._fillBuffer = function() {
      this._counter[0]++;
      var e = this._counter[0];
      if (e === 0)
        throw new Error("hkdf: cannot expand more");
      this._hmac.reset(), e > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;
    }, t.prototype.expand = function(e) {
      for (var r = new Uint8Array(e), n = 0; n < r.length; n++)
        this._bufpos === this._buffer.length && this._fillBuffer(), r[n] = this._buffer[this._bufpos++];
      return r;
    }, t.prototype.clean = function() {
      this._hmac.clean(), Tx.wipe(this._buffer), Tx.wipe(this._counter), this._bufpos = 0;
    }, t;
  }()
), UU = x8.HKDF = jU, Yl = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = ar, r = $i;
  t.DIGEST_LENGTH = 32, t.BLOCK_SIZE = 64;
  var n = (
    /** @class */
    function() {
      function a() {
        this.digestLength = t.DIGEST_LENGTH, this.blockSize = t.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return a.prototype._initState = function() {
        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
      }, a.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, a.prototype.clean = function() {
        r.wipe(this._buffer), r.wipe(this._temp), this.reset();
      }, a.prototype.update = function(u, l) {
        if (l === void 0 && (l = u.length), this._finished)
          throw new Error("SHA256: can't update because hash was finished.");
        var d = 0;
        if (this._bytesHashed += l, this._bufferLength > 0) {
          for (; this._bufferLength < this.blockSize && l > 0; )
            this._buffer[this._bufferLength++] = u[d++], l--;
          this._bufferLength === this.blockSize && (s(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (l >= this.blockSize && (d = s(this._temp, this._state, u, d, l), l %= this.blockSize); l > 0; )
          this._buffer[this._bufferLength++] = u[d++], l--;
        return this;
      }, a.prototype.finish = function(u) {
        if (!this._finished) {
          var l = this._bytesHashed, d = this._bufferLength, p = l / 536870912 | 0, w = l << 3, A = l % 64 < 56 ? 64 : 128;
          this._buffer[d] = 128;
          for (var P = d + 1; P < A - 8; P++)
            this._buffer[P] = 0;
          e.writeUint32BE(p, this._buffer, A - 8), e.writeUint32BE(w, this._buffer, A - 4), s(this._temp, this._state, this._buffer, 0, A), this._finished = !0;
        }
        for (var P = 0; P < this.digestLength / 4; P++)
          e.writeUint32BE(this._state[P], u, P * 4);
        return this;
      }, a.prototype.digest = function() {
        var u = new Uint8Array(this.digestLength);
        return this.finish(u), u;
      }, a.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, a.prototype.restoreState = function(u) {
        return this._state.set(u.state), this._bufferLength = u.bufferLength, u.buffer && this._buffer.set(u.buffer), this._bytesHashed = u.bytesHashed, this._finished = !1, this;
      }, a.prototype.cleanSavedState = function(u) {
        r.wipe(u.state), u.buffer && r.wipe(u.buffer), u.bufferLength = 0, u.bytesHashed = 0;
      }, a;
    }()
  );
  t.SHA256 = n;
  var i = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function s(a, u, l, d, p) {
    for (; p >= 64; ) {
      for (var w = u[0], A = u[1], P = u[2], N = u[3], L = u[4], $ = u[5], B = u[6], H = u[7], W = 0; W < 16; W++) {
        var V = d + W * 4;
        a[W] = e.readUint32BE(l, V);
      }
      for (var W = 16; W < 64; W++) {
        var te = a[W - 2], R = (te >>> 17 | te << 15) ^ (te >>> 19 | te << 13) ^ te >>> 10;
        te = a[W - 15];
        var K = (te >>> 7 | te << 25) ^ (te >>> 18 | te << 14) ^ te >>> 3;
        a[W] = (R + a[W - 7] | 0) + (K + a[W - 16] | 0);
      }
      for (var W = 0; W < 64; W++) {
        var R = (((L >>> 6 | L << 26) ^ (L >>> 11 | L << 21) ^ (L >>> 25 | L << 7)) + (L & $ ^ ~L & B) | 0) + (H + (i[W] + a[W] | 0) | 0) | 0, K = ((w >>> 2 | w << 30) ^ (w >>> 13 | w << 19) ^ (w >>> 22 | w << 10)) + (w & A ^ w & P ^ A & P) | 0;
        H = B, B = $, $ = L, L = N + R | 0, N = P, P = A, A = w, w = R + K | 0;
      }
      u[0] += w, u[1] += A, u[2] += P, u[3] += N, u[4] += L, u[5] += $, u[6] += B, u[7] += H, d += 64, p -= 64;
    }
    return d;
  }
  function o(a) {
    var u = new n();
    u.update(a);
    var l = u.digest();
    return u.clean(), l;
  }
  t.hash = o;
})(Yl);
var Jv = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.sharedKey = t.generateKeyPair = t.generateKeyPairFromSeed = t.scalarMultBase = t.scalarMult = t.SHARED_KEY_LENGTH = t.SECRET_KEY_LENGTH = t.PUBLIC_KEY_LENGTH = void 0;
  const e = Ca, r = $i;
  t.PUBLIC_KEY_LENGTH = 32, t.SECRET_KEY_LENGTH = 32, t.SHARED_KEY_LENGTH = 32;
  function n(W) {
    const V = new Float64Array(16);
    if (W)
      for (let te = 0; te < W.length; te++)
        V[te] = W[te];
    return V;
  }
  const i = new Uint8Array(32);
  i[0] = 9;
  const s = n([56129, 1]);
  function o(W) {
    let V = 1;
    for (let te = 0; te < 16; te++) {
      let R = W[te] + V + 65535;
      V = Math.floor(R / 65536), W[te] = R - V * 65536;
    }
    W[0] += V - 1 + 37 * (V - 1);
  }
  function a(W, V, te) {
    const R = ~(te - 1);
    for (let K = 0; K < 16; K++) {
      const ge = R & (W[K] ^ V[K]);
      W[K] ^= ge, V[K] ^= ge;
    }
  }
  function u(W, V) {
    const te = n(), R = n();
    for (let K = 0; K < 16; K++)
      R[K] = V[K];
    o(R), o(R), o(R);
    for (let K = 0; K < 2; K++) {
      te[0] = R[0] - 65517;
      for (let Ee = 1; Ee < 15; Ee++)
        te[Ee] = R[Ee] - 65535 - (te[Ee - 1] >> 16 & 1), te[Ee - 1] &= 65535;
      te[15] = R[15] - 32767 - (te[14] >> 16 & 1);
      const ge = te[15] >> 16 & 1;
      te[14] &= 65535, a(R, te, 1 - ge);
    }
    for (let K = 0; K < 16; K++)
      W[2 * K] = R[K] & 255, W[2 * K + 1] = R[K] >> 8;
  }
  function l(W, V) {
    for (let te = 0; te < 16; te++)
      W[te] = V[2 * te] + (V[2 * te + 1] << 8);
    W[15] &= 32767;
  }
  function d(W, V, te) {
    for (let R = 0; R < 16; R++)
      W[R] = V[R] + te[R];
  }
  function p(W, V, te) {
    for (let R = 0; R < 16; R++)
      W[R] = V[R] - te[R];
  }
  function w(W, V, te) {
    let R, K, ge = 0, Ee = 0, Y = 0, S = 0, m = 0, f = 0, g = 0, b = 0, x = 0, _ = 0, E = 0, v = 0, M = 0, I = 0, F = 0, ce = 0, D = 0, oe = 0, Z = 0, J = 0, Q = 0, T = 0, X = 0, re = 0, pe = 0, ie = 0, ue = 0, ve = 0, Pe = 0, De = 0, Ce = 0, $e = te[0], Me = te[1], Ne = te[2], Ke = te[3], Le = te[4], qe = te[5], ze = te[6], _e = te[7], Ze = te[8], at = te[9], ke = te[10], Qe = te[11], tt = te[12], Ye = te[13], dt = te[14], lt = te[15];
    R = V[0], ge += R * $e, Ee += R * Me, Y += R * Ne, S += R * Ke, m += R * Le, f += R * qe, g += R * ze, b += R * _e, x += R * Ze, _ += R * at, E += R * ke, v += R * Qe, M += R * tt, I += R * Ye, F += R * dt, ce += R * lt, R = V[1], Ee += R * $e, Y += R * Me, S += R * Ne, m += R * Ke, f += R * Le, g += R * qe, b += R * ze, x += R * _e, _ += R * Ze, E += R * at, v += R * ke, M += R * Qe, I += R * tt, F += R * Ye, ce += R * dt, D += R * lt, R = V[2], Y += R * $e, S += R * Me, m += R * Ne, f += R * Ke, g += R * Le, b += R * qe, x += R * ze, _ += R * _e, E += R * Ze, v += R * at, M += R * ke, I += R * Qe, F += R * tt, ce += R * Ye, D += R * dt, oe += R * lt, R = V[3], S += R * $e, m += R * Me, f += R * Ne, g += R * Ke, b += R * Le, x += R * qe, _ += R * ze, E += R * _e, v += R * Ze, M += R * at, I += R * ke, F += R * Qe, ce += R * tt, D += R * Ye, oe += R * dt, Z += R * lt, R = V[4], m += R * $e, f += R * Me, g += R * Ne, b += R * Ke, x += R * Le, _ += R * qe, E += R * ze, v += R * _e, M += R * Ze, I += R * at, F += R * ke, ce += R * Qe, D += R * tt, oe += R * Ye, Z += R * dt, J += R * lt, R = V[5], f += R * $e, g += R * Me, b += R * Ne, x += R * Ke, _ += R * Le, E += R * qe, v += R * ze, M += R * _e, I += R * Ze, F += R * at, ce += R * ke, D += R * Qe, oe += R * tt, Z += R * Ye, J += R * dt, Q += R * lt, R = V[6], g += R * $e, b += R * Me, x += R * Ne, _ += R * Ke, E += R * Le, v += R * qe, M += R * ze, I += R * _e, F += R * Ze, ce += R * at, D += R * ke, oe += R * Qe, Z += R * tt, J += R * Ye, Q += R * dt, T += R * lt, R = V[7], b += R * $e, x += R * Me, _ += R * Ne, E += R * Ke, v += R * Le, M += R * qe, I += R * ze, F += R * _e, ce += R * Ze, D += R * at, oe += R * ke, Z += R * Qe, J += R * tt, Q += R * Ye, T += R * dt, X += R * lt, R = V[8], x += R * $e, _ += R * Me, E += R * Ne, v += R * Ke, M += R * Le, I += R * qe, F += R * ze, ce += R * _e, D += R * Ze, oe += R * at, Z += R * ke, J += R * Qe, Q += R * tt, T += R * Ye, X += R * dt, re += R * lt, R = V[9], _ += R * $e, E += R * Me, v += R * Ne, M += R * Ke, I += R * Le, F += R * qe, ce += R * ze, D += R * _e, oe += R * Ze, Z += R * at, J += R * ke, Q += R * Qe, T += R * tt, X += R * Ye, re += R * dt, pe += R * lt, R = V[10], E += R * $e, v += R * Me, M += R * Ne, I += R * Ke, F += R * Le, ce += R * qe, D += R * ze, oe += R * _e, Z += R * Ze, J += R * at, Q += R * ke, T += R * Qe, X += R * tt, re += R * Ye, pe += R * dt, ie += R * lt, R = V[11], v += R * $e, M += R * Me, I += R * Ne, F += R * Ke, ce += R * Le, D += R * qe, oe += R * ze, Z += R * _e, J += R * Ze, Q += R * at, T += R * ke, X += R * Qe, re += R * tt, pe += R * Ye, ie += R * dt, ue += R * lt, R = V[12], M += R * $e, I += R * Me, F += R * Ne, ce += R * Ke, D += R * Le, oe += R * qe, Z += R * ze, J += R * _e, Q += R * Ze, T += R * at, X += R * ke, re += R * Qe, pe += R * tt, ie += R * Ye, ue += R * dt, ve += R * lt, R = V[13], I += R * $e, F += R * Me, ce += R * Ne, D += R * Ke, oe += R * Le, Z += R * qe, J += R * ze, Q += R * _e, T += R * Ze, X += R * at, re += R * ke, pe += R * Qe, ie += R * tt, ue += R * Ye, ve += R * dt, Pe += R * lt, R = V[14], F += R * $e, ce += R * Me, D += R * Ne, oe += R * Ke, Z += R * Le, J += R * qe, Q += R * ze, T += R * _e, X += R * Ze, re += R * at, pe += R * ke, ie += R * Qe, ue += R * tt, ve += R * Ye, Pe += R * dt, De += R * lt, R = V[15], ce += R * $e, D += R * Me, oe += R * Ne, Z += R * Ke, J += R * Le, Q += R * qe, T += R * ze, X += R * _e, re += R * Ze, pe += R * at, ie += R * ke, ue += R * Qe, ve += R * tt, Pe += R * Ye, De += R * dt, Ce += R * lt, ge += 38 * D, Ee += 38 * oe, Y += 38 * Z, S += 38 * J, m += 38 * Q, f += 38 * T, g += 38 * X, b += 38 * re, x += 38 * pe, _ += 38 * ie, E += 38 * ue, v += 38 * ve, M += 38 * Pe, I += 38 * De, F += 38 * Ce, K = 1, R = ge + K + 65535, K = Math.floor(R / 65536), ge = R - K * 65536, R = Ee + K + 65535, K = Math.floor(R / 65536), Ee = R - K * 65536, R = Y + K + 65535, K = Math.floor(R / 65536), Y = R - K * 65536, R = S + K + 65535, K = Math.floor(R / 65536), S = R - K * 65536, R = m + K + 65535, K = Math.floor(R / 65536), m = R - K * 65536, R = f + K + 65535, K = Math.floor(R / 65536), f = R - K * 65536, R = g + K + 65535, K = Math.floor(R / 65536), g = R - K * 65536, R = b + K + 65535, K = Math.floor(R / 65536), b = R - K * 65536, R = x + K + 65535, K = Math.floor(R / 65536), x = R - K * 65536, R = _ + K + 65535, K = Math.floor(R / 65536), _ = R - K * 65536, R = E + K + 65535, K = Math.floor(R / 65536), E = R - K * 65536, R = v + K + 65535, K = Math.floor(R / 65536), v = R - K * 65536, R = M + K + 65535, K = Math.floor(R / 65536), M = R - K * 65536, R = I + K + 65535, K = Math.floor(R / 65536), I = R - K * 65536, R = F + K + 65535, K = Math.floor(R / 65536), F = R - K * 65536, R = ce + K + 65535, K = Math.floor(R / 65536), ce = R - K * 65536, ge += K - 1 + 37 * (K - 1), K = 1, R = ge + K + 65535, K = Math.floor(R / 65536), ge = R - K * 65536, R = Ee + K + 65535, K = Math.floor(R / 65536), Ee = R - K * 65536, R = Y + K + 65535, K = Math.floor(R / 65536), Y = R - K * 65536, R = S + K + 65535, K = Math.floor(R / 65536), S = R - K * 65536, R = m + K + 65535, K = Math.floor(R / 65536), m = R - K * 65536, R = f + K + 65535, K = Math.floor(R / 65536), f = R - K * 65536, R = g + K + 65535, K = Math.floor(R / 65536), g = R - K * 65536, R = b + K + 65535, K = Math.floor(R / 65536), b = R - K * 65536, R = x + K + 65535, K = Math.floor(R / 65536), x = R - K * 65536, R = _ + K + 65535, K = Math.floor(R / 65536), _ = R - K * 65536, R = E + K + 65535, K = Math.floor(R / 65536), E = R - K * 65536, R = v + K + 65535, K = Math.floor(R / 65536), v = R - K * 65536, R = M + K + 65535, K = Math.floor(R / 65536), M = R - K * 65536, R = I + K + 65535, K = Math.floor(R / 65536), I = R - K * 65536, R = F + K + 65535, K = Math.floor(R / 65536), F = R - K * 65536, R = ce + K + 65535, K = Math.floor(R / 65536), ce = R - K * 65536, ge += K - 1 + 37 * (K - 1), W[0] = ge, W[1] = Ee, W[2] = Y, W[3] = S, W[4] = m, W[5] = f, W[6] = g, W[7] = b, W[8] = x, W[9] = _, W[10] = E, W[11] = v, W[12] = M, W[13] = I, W[14] = F, W[15] = ce;
  }
  function A(W, V) {
    w(W, V, V);
  }
  function P(W, V) {
    const te = n();
    for (let R = 0; R < 16; R++)
      te[R] = V[R];
    for (let R = 253; R >= 0; R--)
      A(te, te), R !== 2 && R !== 4 && w(te, te, V);
    for (let R = 0; R < 16; R++)
      W[R] = te[R];
  }
  function N(W, V) {
    const te = new Uint8Array(32), R = new Float64Array(80), K = n(), ge = n(), Ee = n(), Y = n(), S = n(), m = n();
    for (let x = 0; x < 31; x++)
      te[x] = W[x];
    te[31] = W[31] & 127 | 64, te[0] &= 248, l(R, V);
    for (let x = 0; x < 16; x++)
      ge[x] = R[x];
    K[0] = Y[0] = 1;
    for (let x = 254; x >= 0; --x) {
      const _ = te[x >>> 3] >>> (x & 7) & 1;
      a(K, ge, _), a(Ee, Y, _), d(S, K, Ee), p(K, K, Ee), d(Ee, ge, Y), p(ge, ge, Y), A(Y, S), A(m, K), w(K, Ee, K), w(Ee, ge, S), d(S, K, Ee), p(K, K, Ee), A(ge, K), p(Ee, Y, m), w(K, Ee, s), d(K, K, Y), w(Ee, Ee, K), w(K, Y, m), w(Y, ge, R), A(ge, S), a(K, ge, _), a(Ee, Y, _);
    }
    for (let x = 0; x < 16; x++)
      R[x + 16] = K[x], R[x + 32] = Ee[x], R[x + 48] = ge[x], R[x + 64] = Y[x];
    const f = R.subarray(32), g = R.subarray(16);
    P(f, f), w(g, g, f);
    const b = new Uint8Array(32);
    return u(b, g), b;
  }
  t.scalarMult = N;
  function L(W) {
    return N(W, i);
  }
  t.scalarMultBase = L;
  function $(W) {
    if (W.length !== t.SECRET_KEY_LENGTH)
      throw new Error(`x25519: seed must be ${t.SECRET_KEY_LENGTH} bytes`);
    const V = new Uint8Array(W);
    return {
      publicKey: L(V),
      secretKey: V
    };
  }
  t.generateKeyPairFromSeed = $;
  function B(W) {
    const V = (0, e.randomBytes)(32, W), te = $(V);
    return (0, r.wipe)(V), te;
  }
  t.generateKeyPair = B;
  function H(W, V, te = !1) {
    if (W.length !== t.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect secret key length");
    if (V.length !== t.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect public key length");
    const R = N(W, V);
    if (te) {
      let K = 0;
      for (let ge = 0; ge < R.length; ge++)
        K |= R[ge];
      if (K === 0)
        throw new Error("X25519: invalid shared key");
    }
    return R;
  }
  t.sharedKey = H;
})(Jv);
var E8 = {};
const qU = "elliptic", zU = "6.6.0", WU = "EC cryptography", HU = "lib/elliptic.js", KU = [
  "lib"
], VU = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, GU = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, YU = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], JU = "Fedor Indutny <fedor@indutny.com>", XU = "MIT", ZU = {
  url: "https://github.com/indutny/elliptic/issues"
}, QU = "https://github.com/indutny/elliptic", eq = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, tq = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, rq = {
  name: qU,
  version: zU,
  description: WU,
  main: HU,
  files: KU,
  scripts: VU,
  repository: GU,
  keywords: YU,
  author: JU,
  license: XU,
  bugs: ZU,
  homepage: QU,
  devDependencies: eq,
  dependencies: tq
};
var Fi = {}, Xv = { exports: {} };
Xv.exports;
(function(t) {
  (function(e, r) {
    function n(Y, S) {
      if (!Y) throw new Error(S || "Assertion failed");
    }
    function i(Y, S) {
      Y.super_ = S;
      var m = function() {
      };
      m.prototype = S.prototype, Y.prototype = new m(), Y.prototype.constructor = Y;
    }
    function s(Y, S, m) {
      if (s.isBN(Y))
        return Y;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, Y !== null && ((S === "le" || S === "be") && (m = S, S = 10), this._init(Y || 0, S || 10, m || "be"));
    }
    typeof e == "object" ? e.exports = s : r.BN = s, s.BN = s, s.wordSize = 26;
    var o;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = Wl.Buffer;
    } catch {
    }
    s.isBN = function(S) {
      return S instanceof s ? !0 : S !== null && typeof S == "object" && S.constructor.wordSize === s.wordSize && Array.isArray(S.words);
    }, s.max = function(S, m) {
      return S.cmp(m) > 0 ? S : m;
    }, s.min = function(S, m) {
      return S.cmp(m) < 0 ? S : m;
    }, s.prototype._init = function(S, m, f) {
      if (typeof S == "number")
        return this._initNumber(S, m, f);
      if (typeof S == "object")
        return this._initArray(S, m, f);
      m === "hex" && (m = 16), n(m === (m | 0) && m >= 2 && m <= 36), S = S.toString().replace(/\s+/g, "");
      var g = 0;
      S[0] === "-" && (g++, this.negative = 1), g < S.length && (m === 16 ? this._parseHex(S, g, f) : (this._parseBase(S, m, g), f === "le" && this._initArray(this.toArray(), m, f)));
    }, s.prototype._initNumber = function(S, m, f) {
      S < 0 && (this.negative = 1, S = -S), S < 67108864 ? (this.words = [S & 67108863], this.length = 1) : S < 4503599627370496 ? (this.words = [
        S & 67108863,
        S / 67108864 & 67108863
      ], this.length = 2) : (n(S < 9007199254740992), this.words = [
        S & 67108863,
        S / 67108864 & 67108863,
        1
      ], this.length = 3), f === "le" && this._initArray(this.toArray(), m, f);
    }, s.prototype._initArray = function(S, m, f) {
      if (n(typeof S.length == "number"), S.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(S.length / 3), this.words = new Array(this.length);
      for (var g = 0; g < this.length; g++)
        this.words[g] = 0;
      var b, x, _ = 0;
      if (f === "be")
        for (g = S.length - 1, b = 0; g >= 0; g -= 3)
          x = S[g] | S[g - 1] << 8 | S[g - 2] << 16, this.words[b] |= x << _ & 67108863, this.words[b + 1] = x >>> 26 - _ & 67108863, _ += 24, _ >= 26 && (_ -= 26, b++);
      else if (f === "le")
        for (g = 0, b = 0; g < S.length; g += 3)
          x = S[g] | S[g + 1] << 8 | S[g + 2] << 16, this.words[b] |= x << _ & 67108863, this.words[b + 1] = x >>> 26 - _ & 67108863, _ += 24, _ >= 26 && (_ -= 26, b++);
      return this.strip();
    };
    function a(Y, S) {
      var m = Y.charCodeAt(S);
      return m >= 65 && m <= 70 ? m - 55 : m >= 97 && m <= 102 ? m - 87 : m - 48 & 15;
    }
    function u(Y, S, m) {
      var f = a(Y, m);
      return m - 1 >= S && (f |= a(Y, m - 1) << 4), f;
    }
    s.prototype._parseHex = function(S, m, f) {
      this.length = Math.ceil((S.length - m) / 6), this.words = new Array(this.length);
      for (var g = 0; g < this.length; g++)
        this.words[g] = 0;
      var b = 0, x = 0, _;
      if (f === "be")
        for (g = S.length - 1; g >= m; g -= 2)
          _ = u(S, m, g) << b, this.words[x] |= _ & 67108863, b >= 18 ? (b -= 18, x += 1, this.words[x] |= _ >>> 26) : b += 8;
      else {
        var E = S.length - m;
        for (g = E % 2 === 0 ? m + 1 : m; g < S.length; g += 2)
          _ = u(S, m, g) << b, this.words[x] |= _ & 67108863, b >= 18 ? (b -= 18, x += 1, this.words[x] |= _ >>> 26) : b += 8;
      }
      this.strip();
    };
    function l(Y, S, m, f) {
      for (var g = 0, b = Math.min(Y.length, m), x = S; x < b; x++) {
        var _ = Y.charCodeAt(x) - 48;
        g *= f, _ >= 49 ? g += _ - 49 + 10 : _ >= 17 ? g += _ - 17 + 10 : g += _;
      }
      return g;
    }
    s.prototype._parseBase = function(S, m, f) {
      this.words = [0], this.length = 1;
      for (var g = 0, b = 1; b <= 67108863; b *= m)
        g++;
      g--, b = b / m | 0;
      for (var x = S.length - f, _ = x % g, E = Math.min(x, x - _) + f, v = 0, M = f; M < E; M += g)
        v = l(S, M, M + g, m), this.imuln(b), this.words[0] + v < 67108864 ? this.words[0] += v : this._iaddn(v);
      if (_ !== 0) {
        var I = 1;
        for (v = l(S, M, S.length, m), M = 0; M < _; M++)
          I *= m;
        this.imuln(I), this.words[0] + v < 67108864 ? this.words[0] += v : this._iaddn(v);
      }
      this.strip();
    }, s.prototype.copy = function(S) {
      S.words = new Array(this.length);
      for (var m = 0; m < this.length; m++)
        S.words[m] = this.words[m];
      S.length = this.length, S.negative = this.negative, S.red = this.red;
    }, s.prototype.clone = function() {
      var S = new s(null);
      return this.copy(S), S;
    }, s.prototype._expand = function(S) {
      for (; this.length < S; )
        this.words[this.length++] = 0;
      return this;
    }, s.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, s.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, s.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var d = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], p = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], w = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    s.prototype.toString = function(S, m) {
      S = S || 10, m = m | 0 || 1;
      var f;
      if (S === 16 || S === "hex") {
        f = "";
        for (var g = 0, b = 0, x = 0; x < this.length; x++) {
          var _ = this.words[x], E = ((_ << g | b) & 16777215).toString(16);
          b = _ >>> 24 - g & 16777215, g += 2, g >= 26 && (g -= 26, x--), b !== 0 || x !== this.length - 1 ? f = d[6 - E.length] + E + f : f = E + f;
        }
        for (b !== 0 && (f = b.toString(16) + f); f.length % m !== 0; )
          f = "0" + f;
        return this.negative !== 0 && (f = "-" + f), f;
      }
      if (S === (S | 0) && S >= 2 && S <= 36) {
        var v = p[S], M = w[S];
        f = "";
        var I = this.clone();
        for (I.negative = 0; !I.isZero(); ) {
          var F = I.modn(M).toString(S);
          I = I.idivn(M), I.isZero() ? f = F + f : f = d[v - F.length] + F + f;
        }
        for (this.isZero() && (f = "0" + f); f.length % m !== 0; )
          f = "0" + f;
        return this.negative !== 0 && (f = "-" + f), f;
      }
      n(!1, "Base should be between 2 and 36");
    }, s.prototype.toNumber = function() {
      var S = this.words[0];
      return this.length === 2 ? S += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? S += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -S : S;
    }, s.prototype.toJSON = function() {
      return this.toString(16);
    }, s.prototype.toBuffer = function(S, m) {
      return n(typeof o < "u"), this.toArrayLike(o, S, m);
    }, s.prototype.toArray = function(S, m) {
      return this.toArrayLike(Array, S, m);
    }, s.prototype.toArrayLike = function(S, m, f) {
      var g = this.byteLength(), b = f || Math.max(1, g);
      n(g <= b, "byte array longer than desired length"), n(b > 0, "Requested array length <= 0"), this.strip();
      var x = m === "le", _ = new S(b), E, v, M = this.clone();
      if (x) {
        for (v = 0; !M.isZero(); v++)
          E = M.andln(255), M.iushrn(8), _[v] = E;
        for (; v < b; v++)
          _[v] = 0;
      } else {
        for (v = 0; v < b - g; v++)
          _[v] = 0;
        for (v = 0; !M.isZero(); v++)
          E = M.andln(255), M.iushrn(8), _[b - v - 1] = E;
      }
      return _;
    }, Math.clz32 ? s.prototype._countBits = function(S) {
      return 32 - Math.clz32(S);
    } : s.prototype._countBits = function(S) {
      var m = S, f = 0;
      return m >= 4096 && (f += 13, m >>>= 13), m >= 64 && (f += 7, m >>>= 7), m >= 8 && (f += 4, m >>>= 4), m >= 2 && (f += 2, m >>>= 2), f + m;
    }, s.prototype._zeroBits = function(S) {
      if (S === 0) return 26;
      var m = S, f = 0;
      return m & 8191 || (f += 13, m >>>= 13), m & 127 || (f += 7, m >>>= 7), m & 15 || (f += 4, m >>>= 4), m & 3 || (f += 2, m >>>= 2), m & 1 || f++, f;
    }, s.prototype.bitLength = function() {
      var S = this.words[this.length - 1], m = this._countBits(S);
      return (this.length - 1) * 26 + m;
    };
    function A(Y) {
      for (var S = new Array(Y.bitLength()), m = 0; m < S.length; m++) {
        var f = m / 26 | 0, g = m % 26;
        S[m] = (Y.words[f] & 1 << g) >>> g;
      }
      return S;
    }
    s.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var S = 0, m = 0; m < this.length; m++) {
        var f = this._zeroBits(this.words[m]);
        if (S += f, f !== 26) break;
      }
      return S;
    }, s.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, s.prototype.toTwos = function(S) {
      return this.negative !== 0 ? this.abs().inotn(S).iaddn(1) : this.clone();
    }, s.prototype.fromTwos = function(S) {
      return this.testn(S - 1) ? this.notn(S).iaddn(1).ineg() : this.clone();
    }, s.prototype.isNeg = function() {
      return this.negative !== 0;
    }, s.prototype.neg = function() {
      return this.clone().ineg();
    }, s.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, s.prototype.iuor = function(S) {
      for (; this.length < S.length; )
        this.words[this.length++] = 0;
      for (var m = 0; m < S.length; m++)
        this.words[m] = this.words[m] | S.words[m];
      return this.strip();
    }, s.prototype.ior = function(S) {
      return n((this.negative | S.negative) === 0), this.iuor(S);
    }, s.prototype.or = function(S) {
      return this.length > S.length ? this.clone().ior(S) : S.clone().ior(this);
    }, s.prototype.uor = function(S) {
      return this.length > S.length ? this.clone().iuor(S) : S.clone().iuor(this);
    }, s.prototype.iuand = function(S) {
      var m;
      this.length > S.length ? m = S : m = this;
      for (var f = 0; f < m.length; f++)
        this.words[f] = this.words[f] & S.words[f];
      return this.length = m.length, this.strip();
    }, s.prototype.iand = function(S) {
      return n((this.negative | S.negative) === 0), this.iuand(S);
    }, s.prototype.and = function(S) {
      return this.length > S.length ? this.clone().iand(S) : S.clone().iand(this);
    }, s.prototype.uand = function(S) {
      return this.length > S.length ? this.clone().iuand(S) : S.clone().iuand(this);
    }, s.prototype.iuxor = function(S) {
      var m, f;
      this.length > S.length ? (m = this, f = S) : (m = S, f = this);
      for (var g = 0; g < f.length; g++)
        this.words[g] = m.words[g] ^ f.words[g];
      if (this !== m)
        for (; g < m.length; g++)
          this.words[g] = m.words[g];
      return this.length = m.length, this.strip();
    }, s.prototype.ixor = function(S) {
      return n((this.negative | S.negative) === 0), this.iuxor(S);
    }, s.prototype.xor = function(S) {
      return this.length > S.length ? this.clone().ixor(S) : S.clone().ixor(this);
    }, s.prototype.uxor = function(S) {
      return this.length > S.length ? this.clone().iuxor(S) : S.clone().iuxor(this);
    }, s.prototype.inotn = function(S) {
      n(typeof S == "number" && S >= 0);
      var m = Math.ceil(S / 26) | 0, f = S % 26;
      this._expand(m), f > 0 && m--;
      for (var g = 0; g < m; g++)
        this.words[g] = ~this.words[g] & 67108863;
      return f > 0 && (this.words[g] = ~this.words[g] & 67108863 >> 26 - f), this.strip();
    }, s.prototype.notn = function(S) {
      return this.clone().inotn(S);
    }, s.prototype.setn = function(S, m) {
      n(typeof S == "number" && S >= 0);
      var f = S / 26 | 0, g = S % 26;
      return this._expand(f + 1), m ? this.words[f] = this.words[f] | 1 << g : this.words[f] = this.words[f] & ~(1 << g), this.strip();
    }, s.prototype.iadd = function(S) {
      var m;
      if (this.negative !== 0 && S.negative === 0)
        return this.negative = 0, m = this.isub(S), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && S.negative !== 0)
        return S.negative = 0, m = this.isub(S), S.negative = 1, m._normSign();
      var f, g;
      this.length > S.length ? (f = this, g = S) : (f = S, g = this);
      for (var b = 0, x = 0; x < g.length; x++)
        m = (f.words[x] | 0) + (g.words[x] | 0) + b, this.words[x] = m & 67108863, b = m >>> 26;
      for (; b !== 0 && x < f.length; x++)
        m = (f.words[x] | 0) + b, this.words[x] = m & 67108863, b = m >>> 26;
      if (this.length = f.length, b !== 0)
        this.words[this.length] = b, this.length++;
      else if (f !== this)
        for (; x < f.length; x++)
          this.words[x] = f.words[x];
      return this;
    }, s.prototype.add = function(S) {
      var m;
      return S.negative !== 0 && this.negative === 0 ? (S.negative = 0, m = this.sub(S), S.negative ^= 1, m) : S.negative === 0 && this.negative !== 0 ? (this.negative = 0, m = S.sub(this), this.negative = 1, m) : this.length > S.length ? this.clone().iadd(S) : S.clone().iadd(this);
    }, s.prototype.isub = function(S) {
      if (S.negative !== 0) {
        S.negative = 0;
        var m = this.iadd(S);
        return S.negative = 1, m._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(S), this.negative = 1, this._normSign();
      var f = this.cmp(S);
      if (f === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var g, b;
      f > 0 ? (g = this, b = S) : (g = S, b = this);
      for (var x = 0, _ = 0; _ < b.length; _++)
        m = (g.words[_] | 0) - (b.words[_] | 0) + x, x = m >> 26, this.words[_] = m & 67108863;
      for (; x !== 0 && _ < g.length; _++)
        m = (g.words[_] | 0) + x, x = m >> 26, this.words[_] = m & 67108863;
      if (x === 0 && _ < g.length && g !== this)
        for (; _ < g.length; _++)
          this.words[_] = g.words[_];
      return this.length = Math.max(this.length, _), g !== this && (this.negative = 1), this.strip();
    }, s.prototype.sub = function(S) {
      return this.clone().isub(S);
    };
    function P(Y, S, m) {
      m.negative = S.negative ^ Y.negative;
      var f = Y.length + S.length | 0;
      m.length = f, f = f - 1 | 0;
      var g = Y.words[0] | 0, b = S.words[0] | 0, x = g * b, _ = x & 67108863, E = x / 67108864 | 0;
      m.words[0] = _;
      for (var v = 1; v < f; v++) {
        for (var M = E >>> 26, I = E & 67108863, F = Math.min(v, S.length - 1), ce = Math.max(0, v - Y.length + 1); ce <= F; ce++) {
          var D = v - ce | 0;
          g = Y.words[D] | 0, b = S.words[ce] | 0, x = g * b + I, M += x / 67108864 | 0, I = x & 67108863;
        }
        m.words[v] = I | 0, E = M | 0;
      }
      return E !== 0 ? m.words[v] = E | 0 : m.length--, m.strip();
    }
    var N = function(S, m, f) {
      var g = S.words, b = m.words, x = f.words, _ = 0, E, v, M, I = g[0] | 0, F = I & 8191, ce = I >>> 13, D = g[1] | 0, oe = D & 8191, Z = D >>> 13, J = g[2] | 0, Q = J & 8191, T = J >>> 13, X = g[3] | 0, re = X & 8191, pe = X >>> 13, ie = g[4] | 0, ue = ie & 8191, ve = ie >>> 13, Pe = g[5] | 0, De = Pe & 8191, Ce = Pe >>> 13, $e = g[6] | 0, Me = $e & 8191, Ne = $e >>> 13, Ke = g[7] | 0, Le = Ke & 8191, qe = Ke >>> 13, ze = g[8] | 0, _e = ze & 8191, Ze = ze >>> 13, at = g[9] | 0, ke = at & 8191, Qe = at >>> 13, tt = b[0] | 0, Ye = tt & 8191, dt = tt >>> 13, lt = b[1] | 0, ct = lt & 8191, qt = lt >>> 13, Jt = b[2] | 0, Et = Jt & 8191, er = Jt >>> 13, Xt = b[3] | 0, Dt = Xt & 8191, kt = Xt >>> 13, Ct = b[4] | 0, gt = Ct & 8191, Rt = Ct >>> 13, Nt = b[5] | 0, vt = Nt & 8191, $t = Nt >>> 13, Ft = b[6] | 0, rt = Ft & 8191, Bt = Ft >>> 13, k = b[7] | 0, U = k & 8191, z = k >>> 13, C = b[8] | 0, G = C & 8191, j = C >>> 13, se = b[9] | 0, de = se & 8191, xe = se >>> 13;
      f.negative = S.negative ^ m.negative, f.length = 19, E = Math.imul(F, Ye), v = Math.imul(F, dt), v = v + Math.imul(ce, Ye) | 0, M = Math.imul(ce, dt);
      var Te = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, E = Math.imul(oe, Ye), v = Math.imul(oe, dt), v = v + Math.imul(Z, Ye) | 0, M = Math.imul(Z, dt), E = E + Math.imul(F, ct) | 0, v = v + Math.imul(F, qt) | 0, v = v + Math.imul(ce, ct) | 0, M = M + Math.imul(ce, qt) | 0;
      var Re = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (Re >>> 26) | 0, Re &= 67108863, E = Math.imul(Q, Ye), v = Math.imul(Q, dt), v = v + Math.imul(T, Ye) | 0, M = Math.imul(T, dt), E = E + Math.imul(oe, ct) | 0, v = v + Math.imul(oe, qt) | 0, v = v + Math.imul(Z, ct) | 0, M = M + Math.imul(Z, qt) | 0, E = E + Math.imul(F, Et) | 0, v = v + Math.imul(F, er) | 0, v = v + Math.imul(ce, Et) | 0, M = M + Math.imul(ce, er) | 0;
      var nt = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (nt >>> 26) | 0, nt &= 67108863, E = Math.imul(re, Ye), v = Math.imul(re, dt), v = v + Math.imul(pe, Ye) | 0, M = Math.imul(pe, dt), E = E + Math.imul(Q, ct) | 0, v = v + Math.imul(Q, qt) | 0, v = v + Math.imul(T, ct) | 0, M = M + Math.imul(T, qt) | 0, E = E + Math.imul(oe, Et) | 0, v = v + Math.imul(oe, er) | 0, v = v + Math.imul(Z, Et) | 0, M = M + Math.imul(Z, er) | 0, E = E + Math.imul(F, Dt) | 0, v = v + Math.imul(F, kt) | 0, v = v + Math.imul(ce, Dt) | 0, M = M + Math.imul(ce, kt) | 0;
      var je = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, E = Math.imul(ue, Ye), v = Math.imul(ue, dt), v = v + Math.imul(ve, Ye) | 0, M = Math.imul(ve, dt), E = E + Math.imul(re, ct) | 0, v = v + Math.imul(re, qt) | 0, v = v + Math.imul(pe, ct) | 0, M = M + Math.imul(pe, qt) | 0, E = E + Math.imul(Q, Et) | 0, v = v + Math.imul(Q, er) | 0, v = v + Math.imul(T, Et) | 0, M = M + Math.imul(T, er) | 0, E = E + Math.imul(oe, Dt) | 0, v = v + Math.imul(oe, kt) | 0, v = v + Math.imul(Z, Dt) | 0, M = M + Math.imul(Z, kt) | 0, E = E + Math.imul(F, gt) | 0, v = v + Math.imul(F, Rt) | 0, v = v + Math.imul(ce, gt) | 0, M = M + Math.imul(ce, Rt) | 0;
      var pt = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, E = Math.imul(De, Ye), v = Math.imul(De, dt), v = v + Math.imul(Ce, Ye) | 0, M = Math.imul(Ce, dt), E = E + Math.imul(ue, ct) | 0, v = v + Math.imul(ue, qt) | 0, v = v + Math.imul(ve, ct) | 0, M = M + Math.imul(ve, qt) | 0, E = E + Math.imul(re, Et) | 0, v = v + Math.imul(re, er) | 0, v = v + Math.imul(pe, Et) | 0, M = M + Math.imul(pe, er) | 0, E = E + Math.imul(Q, Dt) | 0, v = v + Math.imul(Q, kt) | 0, v = v + Math.imul(T, Dt) | 0, M = M + Math.imul(T, kt) | 0, E = E + Math.imul(oe, gt) | 0, v = v + Math.imul(oe, Rt) | 0, v = v + Math.imul(Z, gt) | 0, M = M + Math.imul(Z, Rt) | 0, E = E + Math.imul(F, vt) | 0, v = v + Math.imul(F, $t) | 0, v = v + Math.imul(ce, vt) | 0, M = M + Math.imul(ce, $t) | 0;
      var it = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (it >>> 26) | 0, it &= 67108863, E = Math.imul(Me, Ye), v = Math.imul(Me, dt), v = v + Math.imul(Ne, Ye) | 0, M = Math.imul(Ne, dt), E = E + Math.imul(De, ct) | 0, v = v + Math.imul(De, qt) | 0, v = v + Math.imul(Ce, ct) | 0, M = M + Math.imul(Ce, qt) | 0, E = E + Math.imul(ue, Et) | 0, v = v + Math.imul(ue, er) | 0, v = v + Math.imul(ve, Et) | 0, M = M + Math.imul(ve, er) | 0, E = E + Math.imul(re, Dt) | 0, v = v + Math.imul(re, kt) | 0, v = v + Math.imul(pe, Dt) | 0, M = M + Math.imul(pe, kt) | 0, E = E + Math.imul(Q, gt) | 0, v = v + Math.imul(Q, Rt) | 0, v = v + Math.imul(T, gt) | 0, M = M + Math.imul(T, Rt) | 0, E = E + Math.imul(oe, vt) | 0, v = v + Math.imul(oe, $t) | 0, v = v + Math.imul(Z, vt) | 0, M = M + Math.imul(Z, $t) | 0, E = E + Math.imul(F, rt) | 0, v = v + Math.imul(F, Bt) | 0, v = v + Math.imul(ce, rt) | 0, M = M + Math.imul(ce, Bt) | 0;
      var et = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, E = Math.imul(Le, Ye), v = Math.imul(Le, dt), v = v + Math.imul(qe, Ye) | 0, M = Math.imul(qe, dt), E = E + Math.imul(Me, ct) | 0, v = v + Math.imul(Me, qt) | 0, v = v + Math.imul(Ne, ct) | 0, M = M + Math.imul(Ne, qt) | 0, E = E + Math.imul(De, Et) | 0, v = v + Math.imul(De, er) | 0, v = v + Math.imul(Ce, Et) | 0, M = M + Math.imul(Ce, er) | 0, E = E + Math.imul(ue, Dt) | 0, v = v + Math.imul(ue, kt) | 0, v = v + Math.imul(ve, Dt) | 0, M = M + Math.imul(ve, kt) | 0, E = E + Math.imul(re, gt) | 0, v = v + Math.imul(re, Rt) | 0, v = v + Math.imul(pe, gt) | 0, M = M + Math.imul(pe, Rt) | 0, E = E + Math.imul(Q, vt) | 0, v = v + Math.imul(Q, $t) | 0, v = v + Math.imul(T, vt) | 0, M = M + Math.imul(T, $t) | 0, E = E + Math.imul(oe, rt) | 0, v = v + Math.imul(oe, Bt) | 0, v = v + Math.imul(Z, rt) | 0, M = M + Math.imul(Z, Bt) | 0, E = E + Math.imul(F, U) | 0, v = v + Math.imul(F, z) | 0, v = v + Math.imul(ce, U) | 0, M = M + Math.imul(ce, z) | 0;
      var St = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, E = Math.imul(_e, Ye), v = Math.imul(_e, dt), v = v + Math.imul(Ze, Ye) | 0, M = Math.imul(Ze, dt), E = E + Math.imul(Le, ct) | 0, v = v + Math.imul(Le, qt) | 0, v = v + Math.imul(qe, ct) | 0, M = M + Math.imul(qe, qt) | 0, E = E + Math.imul(Me, Et) | 0, v = v + Math.imul(Me, er) | 0, v = v + Math.imul(Ne, Et) | 0, M = M + Math.imul(Ne, er) | 0, E = E + Math.imul(De, Dt) | 0, v = v + Math.imul(De, kt) | 0, v = v + Math.imul(Ce, Dt) | 0, M = M + Math.imul(Ce, kt) | 0, E = E + Math.imul(ue, gt) | 0, v = v + Math.imul(ue, Rt) | 0, v = v + Math.imul(ve, gt) | 0, M = M + Math.imul(ve, Rt) | 0, E = E + Math.imul(re, vt) | 0, v = v + Math.imul(re, $t) | 0, v = v + Math.imul(pe, vt) | 0, M = M + Math.imul(pe, $t) | 0, E = E + Math.imul(Q, rt) | 0, v = v + Math.imul(Q, Bt) | 0, v = v + Math.imul(T, rt) | 0, M = M + Math.imul(T, Bt) | 0, E = E + Math.imul(oe, U) | 0, v = v + Math.imul(oe, z) | 0, v = v + Math.imul(Z, U) | 0, M = M + Math.imul(Z, z) | 0, E = E + Math.imul(F, G) | 0, v = v + Math.imul(F, j) | 0, v = v + Math.imul(ce, G) | 0, M = M + Math.imul(ce, j) | 0;
      var Tt = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, E = Math.imul(ke, Ye), v = Math.imul(ke, dt), v = v + Math.imul(Qe, Ye) | 0, M = Math.imul(Qe, dt), E = E + Math.imul(_e, ct) | 0, v = v + Math.imul(_e, qt) | 0, v = v + Math.imul(Ze, ct) | 0, M = M + Math.imul(Ze, qt) | 0, E = E + Math.imul(Le, Et) | 0, v = v + Math.imul(Le, er) | 0, v = v + Math.imul(qe, Et) | 0, M = M + Math.imul(qe, er) | 0, E = E + Math.imul(Me, Dt) | 0, v = v + Math.imul(Me, kt) | 0, v = v + Math.imul(Ne, Dt) | 0, M = M + Math.imul(Ne, kt) | 0, E = E + Math.imul(De, gt) | 0, v = v + Math.imul(De, Rt) | 0, v = v + Math.imul(Ce, gt) | 0, M = M + Math.imul(Ce, Rt) | 0, E = E + Math.imul(ue, vt) | 0, v = v + Math.imul(ue, $t) | 0, v = v + Math.imul(ve, vt) | 0, M = M + Math.imul(ve, $t) | 0, E = E + Math.imul(re, rt) | 0, v = v + Math.imul(re, Bt) | 0, v = v + Math.imul(pe, rt) | 0, M = M + Math.imul(pe, Bt) | 0, E = E + Math.imul(Q, U) | 0, v = v + Math.imul(Q, z) | 0, v = v + Math.imul(T, U) | 0, M = M + Math.imul(T, z) | 0, E = E + Math.imul(oe, G) | 0, v = v + Math.imul(oe, j) | 0, v = v + Math.imul(Z, G) | 0, M = M + Math.imul(Z, j) | 0, E = E + Math.imul(F, de) | 0, v = v + Math.imul(F, xe) | 0, v = v + Math.imul(ce, de) | 0, M = M + Math.imul(ce, xe) | 0;
      var At = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, E = Math.imul(ke, ct), v = Math.imul(ke, qt), v = v + Math.imul(Qe, ct) | 0, M = Math.imul(Qe, qt), E = E + Math.imul(_e, Et) | 0, v = v + Math.imul(_e, er) | 0, v = v + Math.imul(Ze, Et) | 0, M = M + Math.imul(Ze, er) | 0, E = E + Math.imul(Le, Dt) | 0, v = v + Math.imul(Le, kt) | 0, v = v + Math.imul(qe, Dt) | 0, M = M + Math.imul(qe, kt) | 0, E = E + Math.imul(Me, gt) | 0, v = v + Math.imul(Me, Rt) | 0, v = v + Math.imul(Ne, gt) | 0, M = M + Math.imul(Ne, Rt) | 0, E = E + Math.imul(De, vt) | 0, v = v + Math.imul(De, $t) | 0, v = v + Math.imul(Ce, vt) | 0, M = M + Math.imul(Ce, $t) | 0, E = E + Math.imul(ue, rt) | 0, v = v + Math.imul(ue, Bt) | 0, v = v + Math.imul(ve, rt) | 0, M = M + Math.imul(ve, Bt) | 0, E = E + Math.imul(re, U) | 0, v = v + Math.imul(re, z) | 0, v = v + Math.imul(pe, U) | 0, M = M + Math.imul(pe, z) | 0, E = E + Math.imul(Q, G) | 0, v = v + Math.imul(Q, j) | 0, v = v + Math.imul(T, G) | 0, M = M + Math.imul(T, j) | 0, E = E + Math.imul(oe, de) | 0, v = v + Math.imul(oe, xe) | 0, v = v + Math.imul(Z, de) | 0, M = M + Math.imul(Z, xe) | 0;
      var _t = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, E = Math.imul(ke, Et), v = Math.imul(ke, er), v = v + Math.imul(Qe, Et) | 0, M = Math.imul(Qe, er), E = E + Math.imul(_e, Dt) | 0, v = v + Math.imul(_e, kt) | 0, v = v + Math.imul(Ze, Dt) | 0, M = M + Math.imul(Ze, kt) | 0, E = E + Math.imul(Le, gt) | 0, v = v + Math.imul(Le, Rt) | 0, v = v + Math.imul(qe, gt) | 0, M = M + Math.imul(qe, Rt) | 0, E = E + Math.imul(Me, vt) | 0, v = v + Math.imul(Me, $t) | 0, v = v + Math.imul(Ne, vt) | 0, M = M + Math.imul(Ne, $t) | 0, E = E + Math.imul(De, rt) | 0, v = v + Math.imul(De, Bt) | 0, v = v + Math.imul(Ce, rt) | 0, M = M + Math.imul(Ce, Bt) | 0, E = E + Math.imul(ue, U) | 0, v = v + Math.imul(ue, z) | 0, v = v + Math.imul(ve, U) | 0, M = M + Math.imul(ve, z) | 0, E = E + Math.imul(re, G) | 0, v = v + Math.imul(re, j) | 0, v = v + Math.imul(pe, G) | 0, M = M + Math.imul(pe, j) | 0, E = E + Math.imul(Q, de) | 0, v = v + Math.imul(Q, xe) | 0, v = v + Math.imul(T, de) | 0, M = M + Math.imul(T, xe) | 0;
      var ht = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, E = Math.imul(ke, Dt), v = Math.imul(ke, kt), v = v + Math.imul(Qe, Dt) | 0, M = Math.imul(Qe, kt), E = E + Math.imul(_e, gt) | 0, v = v + Math.imul(_e, Rt) | 0, v = v + Math.imul(Ze, gt) | 0, M = M + Math.imul(Ze, Rt) | 0, E = E + Math.imul(Le, vt) | 0, v = v + Math.imul(Le, $t) | 0, v = v + Math.imul(qe, vt) | 0, M = M + Math.imul(qe, $t) | 0, E = E + Math.imul(Me, rt) | 0, v = v + Math.imul(Me, Bt) | 0, v = v + Math.imul(Ne, rt) | 0, M = M + Math.imul(Ne, Bt) | 0, E = E + Math.imul(De, U) | 0, v = v + Math.imul(De, z) | 0, v = v + Math.imul(Ce, U) | 0, M = M + Math.imul(Ce, z) | 0, E = E + Math.imul(ue, G) | 0, v = v + Math.imul(ue, j) | 0, v = v + Math.imul(ve, G) | 0, M = M + Math.imul(ve, j) | 0, E = E + Math.imul(re, de) | 0, v = v + Math.imul(re, xe) | 0, v = v + Math.imul(pe, de) | 0, M = M + Math.imul(pe, xe) | 0;
      var xt = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, E = Math.imul(ke, gt), v = Math.imul(ke, Rt), v = v + Math.imul(Qe, gt) | 0, M = Math.imul(Qe, Rt), E = E + Math.imul(_e, vt) | 0, v = v + Math.imul(_e, $t) | 0, v = v + Math.imul(Ze, vt) | 0, M = M + Math.imul(Ze, $t) | 0, E = E + Math.imul(Le, rt) | 0, v = v + Math.imul(Le, Bt) | 0, v = v + Math.imul(qe, rt) | 0, M = M + Math.imul(qe, Bt) | 0, E = E + Math.imul(Me, U) | 0, v = v + Math.imul(Me, z) | 0, v = v + Math.imul(Ne, U) | 0, M = M + Math.imul(Ne, z) | 0, E = E + Math.imul(De, G) | 0, v = v + Math.imul(De, j) | 0, v = v + Math.imul(Ce, G) | 0, M = M + Math.imul(Ce, j) | 0, E = E + Math.imul(ue, de) | 0, v = v + Math.imul(ue, xe) | 0, v = v + Math.imul(ve, de) | 0, M = M + Math.imul(ve, xe) | 0;
      var st = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (st >>> 26) | 0, st &= 67108863, E = Math.imul(ke, vt), v = Math.imul(ke, $t), v = v + Math.imul(Qe, vt) | 0, M = Math.imul(Qe, $t), E = E + Math.imul(_e, rt) | 0, v = v + Math.imul(_e, Bt) | 0, v = v + Math.imul(Ze, rt) | 0, M = M + Math.imul(Ze, Bt) | 0, E = E + Math.imul(Le, U) | 0, v = v + Math.imul(Le, z) | 0, v = v + Math.imul(qe, U) | 0, M = M + Math.imul(qe, z) | 0, E = E + Math.imul(Me, G) | 0, v = v + Math.imul(Me, j) | 0, v = v + Math.imul(Ne, G) | 0, M = M + Math.imul(Ne, j) | 0, E = E + Math.imul(De, de) | 0, v = v + Math.imul(De, xe) | 0, v = v + Math.imul(Ce, de) | 0, M = M + Math.imul(Ce, xe) | 0;
      var bt = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, E = Math.imul(ke, rt), v = Math.imul(ke, Bt), v = v + Math.imul(Qe, rt) | 0, M = Math.imul(Qe, Bt), E = E + Math.imul(_e, U) | 0, v = v + Math.imul(_e, z) | 0, v = v + Math.imul(Ze, U) | 0, M = M + Math.imul(Ze, z) | 0, E = E + Math.imul(Le, G) | 0, v = v + Math.imul(Le, j) | 0, v = v + Math.imul(qe, G) | 0, M = M + Math.imul(qe, j) | 0, E = E + Math.imul(Me, de) | 0, v = v + Math.imul(Me, xe) | 0, v = v + Math.imul(Ne, de) | 0, M = M + Math.imul(Ne, xe) | 0;
      var ut = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, E = Math.imul(ke, U), v = Math.imul(ke, z), v = v + Math.imul(Qe, U) | 0, M = Math.imul(Qe, z), E = E + Math.imul(_e, G) | 0, v = v + Math.imul(_e, j) | 0, v = v + Math.imul(Ze, G) | 0, M = M + Math.imul(Ze, j) | 0, E = E + Math.imul(Le, de) | 0, v = v + Math.imul(Le, xe) | 0, v = v + Math.imul(qe, de) | 0, M = M + Math.imul(qe, xe) | 0;
      var ot = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (ot >>> 26) | 0, ot &= 67108863, E = Math.imul(ke, G), v = Math.imul(ke, j), v = v + Math.imul(Qe, G) | 0, M = Math.imul(Qe, j), E = E + Math.imul(_e, de) | 0, v = v + Math.imul(_e, xe) | 0, v = v + Math.imul(Ze, de) | 0, M = M + Math.imul(Ze, xe) | 0;
      var Se = (_ + E | 0) + ((v & 8191) << 13) | 0;
      _ = (M + (v >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, E = Math.imul(ke, de), v = Math.imul(ke, xe), v = v + Math.imul(Qe, de) | 0, M = Math.imul(Qe, xe);
      var Ae = (_ + E | 0) + ((v & 8191) << 13) | 0;
      return _ = (M + (v >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, x[0] = Te, x[1] = Re, x[2] = nt, x[3] = je, x[4] = pt, x[5] = it, x[6] = et, x[7] = St, x[8] = Tt, x[9] = At, x[10] = _t, x[11] = ht, x[12] = xt, x[13] = st, x[14] = bt, x[15] = ut, x[16] = ot, x[17] = Se, x[18] = Ae, _ !== 0 && (x[19] = _, f.length++), f;
    };
    Math.imul || (N = P);
    function L(Y, S, m) {
      m.negative = S.negative ^ Y.negative, m.length = Y.length + S.length;
      for (var f = 0, g = 0, b = 0; b < m.length - 1; b++) {
        var x = g;
        g = 0;
        for (var _ = f & 67108863, E = Math.min(b, S.length - 1), v = Math.max(0, b - Y.length + 1); v <= E; v++) {
          var M = b - v, I = Y.words[M] | 0, F = S.words[v] | 0, ce = I * F, D = ce & 67108863;
          x = x + (ce / 67108864 | 0) | 0, D = D + _ | 0, _ = D & 67108863, x = x + (D >>> 26) | 0, g += x >>> 26, x &= 67108863;
        }
        m.words[b] = _, f = x, x = g;
      }
      return f !== 0 ? m.words[b] = f : m.length--, m.strip();
    }
    function $(Y, S, m) {
      var f = new B();
      return f.mulp(Y, S, m);
    }
    s.prototype.mulTo = function(S, m) {
      var f, g = this.length + S.length;
      return this.length === 10 && S.length === 10 ? f = N(this, S, m) : g < 63 ? f = P(this, S, m) : g < 1024 ? f = L(this, S, m) : f = $(this, S, m), f;
    };
    function B(Y, S) {
      this.x = Y, this.y = S;
    }
    B.prototype.makeRBT = function(S) {
      for (var m = new Array(S), f = s.prototype._countBits(S) - 1, g = 0; g < S; g++)
        m[g] = this.revBin(g, f, S);
      return m;
    }, B.prototype.revBin = function(S, m, f) {
      if (S === 0 || S === f - 1) return S;
      for (var g = 0, b = 0; b < m; b++)
        g |= (S & 1) << m - b - 1, S >>= 1;
      return g;
    }, B.prototype.permute = function(S, m, f, g, b, x) {
      for (var _ = 0; _ < x; _++)
        g[_] = m[S[_]], b[_] = f[S[_]];
    }, B.prototype.transform = function(S, m, f, g, b, x) {
      this.permute(x, S, m, f, g, b);
      for (var _ = 1; _ < b; _ <<= 1)
        for (var E = _ << 1, v = Math.cos(2 * Math.PI / E), M = Math.sin(2 * Math.PI / E), I = 0; I < b; I += E)
          for (var F = v, ce = M, D = 0; D < _; D++) {
            var oe = f[I + D], Z = g[I + D], J = f[I + D + _], Q = g[I + D + _], T = F * J - ce * Q;
            Q = F * Q + ce * J, J = T, f[I + D] = oe + J, g[I + D] = Z + Q, f[I + D + _] = oe - J, g[I + D + _] = Z - Q, D !== E && (T = v * F - M * ce, ce = v * ce + M * F, F = T);
          }
    }, B.prototype.guessLen13b = function(S, m) {
      var f = Math.max(m, S) | 1, g = f & 1, b = 0;
      for (f = f / 2 | 0; f; f = f >>> 1)
        b++;
      return 1 << b + 1 + g;
    }, B.prototype.conjugate = function(S, m, f) {
      if (!(f <= 1))
        for (var g = 0; g < f / 2; g++) {
          var b = S[g];
          S[g] = S[f - g - 1], S[f - g - 1] = b, b = m[g], m[g] = -m[f - g - 1], m[f - g - 1] = -b;
        }
    }, B.prototype.normalize13b = function(S, m) {
      for (var f = 0, g = 0; g < m / 2; g++) {
        var b = Math.round(S[2 * g + 1] / m) * 8192 + Math.round(S[2 * g] / m) + f;
        S[g] = b & 67108863, b < 67108864 ? f = 0 : f = b / 67108864 | 0;
      }
      return S;
    }, B.prototype.convert13b = function(S, m, f, g) {
      for (var b = 0, x = 0; x < m; x++)
        b = b + (S[x] | 0), f[2 * x] = b & 8191, b = b >>> 13, f[2 * x + 1] = b & 8191, b = b >>> 13;
      for (x = 2 * m; x < g; ++x)
        f[x] = 0;
      n(b === 0), n((b & -8192) === 0);
    }, B.prototype.stub = function(S) {
      for (var m = new Array(S), f = 0; f < S; f++)
        m[f] = 0;
      return m;
    }, B.prototype.mulp = function(S, m, f) {
      var g = 2 * this.guessLen13b(S.length, m.length), b = this.makeRBT(g), x = this.stub(g), _ = new Array(g), E = new Array(g), v = new Array(g), M = new Array(g), I = new Array(g), F = new Array(g), ce = f.words;
      ce.length = g, this.convert13b(S.words, S.length, _, g), this.convert13b(m.words, m.length, M, g), this.transform(_, x, E, v, g, b), this.transform(M, x, I, F, g, b);
      for (var D = 0; D < g; D++) {
        var oe = E[D] * I[D] - v[D] * F[D];
        v[D] = E[D] * F[D] + v[D] * I[D], E[D] = oe;
      }
      return this.conjugate(E, v, g), this.transform(E, v, ce, x, g, b), this.conjugate(ce, x, g), this.normalize13b(ce, g), f.negative = S.negative ^ m.negative, f.length = S.length + m.length, f.strip();
    }, s.prototype.mul = function(S) {
      var m = new s(null);
      return m.words = new Array(this.length + S.length), this.mulTo(S, m);
    }, s.prototype.mulf = function(S) {
      var m = new s(null);
      return m.words = new Array(this.length + S.length), $(this, S, m);
    }, s.prototype.imul = function(S) {
      return this.clone().mulTo(S, this);
    }, s.prototype.imuln = function(S) {
      n(typeof S == "number"), n(S < 67108864);
      for (var m = 0, f = 0; f < this.length; f++) {
        var g = (this.words[f] | 0) * S, b = (g & 67108863) + (m & 67108863);
        m >>= 26, m += g / 67108864 | 0, m += b >>> 26, this.words[f] = b & 67108863;
      }
      return m !== 0 && (this.words[f] = m, this.length++), this;
    }, s.prototype.muln = function(S) {
      return this.clone().imuln(S);
    }, s.prototype.sqr = function() {
      return this.mul(this);
    }, s.prototype.isqr = function() {
      return this.imul(this.clone());
    }, s.prototype.pow = function(S) {
      var m = A(S);
      if (m.length === 0) return new s(1);
      for (var f = this, g = 0; g < m.length && m[g] === 0; g++, f = f.sqr())
        ;
      if (++g < m.length)
        for (var b = f.sqr(); g < m.length; g++, b = b.sqr())
          m[g] !== 0 && (f = f.mul(b));
      return f;
    }, s.prototype.iushln = function(S) {
      n(typeof S == "number" && S >= 0);
      var m = S % 26, f = (S - m) / 26, g = 67108863 >>> 26 - m << 26 - m, b;
      if (m !== 0) {
        var x = 0;
        for (b = 0; b < this.length; b++) {
          var _ = this.words[b] & g, E = (this.words[b] | 0) - _ << m;
          this.words[b] = E | x, x = _ >>> 26 - m;
        }
        x && (this.words[b] = x, this.length++);
      }
      if (f !== 0) {
        for (b = this.length - 1; b >= 0; b--)
          this.words[b + f] = this.words[b];
        for (b = 0; b < f; b++)
          this.words[b] = 0;
        this.length += f;
      }
      return this.strip();
    }, s.prototype.ishln = function(S) {
      return n(this.negative === 0), this.iushln(S);
    }, s.prototype.iushrn = function(S, m, f) {
      n(typeof S == "number" && S >= 0);
      var g;
      m ? g = (m - m % 26) / 26 : g = 0;
      var b = S % 26, x = Math.min((S - b) / 26, this.length), _ = 67108863 ^ 67108863 >>> b << b, E = f;
      if (g -= x, g = Math.max(0, g), E) {
        for (var v = 0; v < x; v++)
          E.words[v] = this.words[v];
        E.length = x;
      }
      if (x !== 0) if (this.length > x)
        for (this.length -= x, v = 0; v < this.length; v++)
          this.words[v] = this.words[v + x];
      else
        this.words[0] = 0, this.length = 1;
      var M = 0;
      for (v = this.length - 1; v >= 0 && (M !== 0 || v >= g); v--) {
        var I = this.words[v] | 0;
        this.words[v] = M << 26 - b | I >>> b, M = I & _;
      }
      return E && M !== 0 && (E.words[E.length++] = M), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, s.prototype.ishrn = function(S, m, f) {
      return n(this.negative === 0), this.iushrn(S, m, f);
    }, s.prototype.shln = function(S) {
      return this.clone().ishln(S);
    }, s.prototype.ushln = function(S) {
      return this.clone().iushln(S);
    }, s.prototype.shrn = function(S) {
      return this.clone().ishrn(S);
    }, s.prototype.ushrn = function(S) {
      return this.clone().iushrn(S);
    }, s.prototype.testn = function(S) {
      n(typeof S == "number" && S >= 0);
      var m = S % 26, f = (S - m) / 26, g = 1 << m;
      if (this.length <= f) return !1;
      var b = this.words[f];
      return !!(b & g);
    }, s.prototype.imaskn = function(S) {
      n(typeof S == "number" && S >= 0);
      var m = S % 26, f = (S - m) / 26;
      if (n(this.negative === 0, "imaskn works only with positive numbers"), this.length <= f)
        return this;
      if (m !== 0 && f++, this.length = Math.min(f, this.length), m !== 0) {
        var g = 67108863 ^ 67108863 >>> m << m;
        this.words[this.length - 1] &= g;
      }
      return this.strip();
    }, s.prototype.maskn = function(S) {
      return this.clone().imaskn(S);
    }, s.prototype.iaddn = function(S) {
      return n(typeof S == "number"), n(S < 67108864), S < 0 ? this.isubn(-S) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < S ? (this.words[0] = S - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(S), this.negative = 1, this) : this._iaddn(S);
    }, s.prototype._iaddn = function(S) {
      this.words[0] += S;
      for (var m = 0; m < this.length && this.words[m] >= 67108864; m++)
        this.words[m] -= 67108864, m === this.length - 1 ? this.words[m + 1] = 1 : this.words[m + 1]++;
      return this.length = Math.max(this.length, m + 1), this;
    }, s.prototype.isubn = function(S) {
      if (n(typeof S == "number"), n(S < 67108864), S < 0) return this.iaddn(-S);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(S), this.negative = 1, this;
      if (this.words[0] -= S, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var m = 0; m < this.length && this.words[m] < 0; m++)
          this.words[m] += 67108864, this.words[m + 1] -= 1;
      return this.strip();
    }, s.prototype.addn = function(S) {
      return this.clone().iaddn(S);
    }, s.prototype.subn = function(S) {
      return this.clone().isubn(S);
    }, s.prototype.iabs = function() {
      return this.negative = 0, this;
    }, s.prototype.abs = function() {
      return this.clone().iabs();
    }, s.prototype._ishlnsubmul = function(S, m, f) {
      var g = S.length + f, b;
      this._expand(g);
      var x, _ = 0;
      for (b = 0; b < S.length; b++) {
        x = (this.words[b + f] | 0) + _;
        var E = (S.words[b] | 0) * m;
        x -= E & 67108863, _ = (x >> 26) - (E / 67108864 | 0), this.words[b + f] = x & 67108863;
      }
      for (; b < this.length - f; b++)
        x = (this.words[b + f] | 0) + _, _ = x >> 26, this.words[b + f] = x & 67108863;
      if (_ === 0) return this.strip();
      for (n(_ === -1), _ = 0, b = 0; b < this.length; b++)
        x = -(this.words[b] | 0) + _, _ = x >> 26, this.words[b] = x & 67108863;
      return this.negative = 1, this.strip();
    }, s.prototype._wordDiv = function(S, m) {
      var f = this.length - S.length, g = this.clone(), b = S, x = b.words[b.length - 1] | 0, _ = this._countBits(x);
      f = 26 - _, f !== 0 && (b = b.ushln(f), g.iushln(f), x = b.words[b.length - 1] | 0);
      var E = g.length - b.length, v;
      if (m !== "mod") {
        v = new s(null), v.length = E + 1, v.words = new Array(v.length);
        for (var M = 0; M < v.length; M++)
          v.words[M] = 0;
      }
      var I = g.clone()._ishlnsubmul(b, 1, E);
      I.negative === 0 && (g = I, v && (v.words[E] = 1));
      for (var F = E - 1; F >= 0; F--) {
        var ce = (g.words[b.length + F] | 0) * 67108864 + (g.words[b.length + F - 1] | 0);
        for (ce = Math.min(ce / x | 0, 67108863), g._ishlnsubmul(b, ce, F); g.negative !== 0; )
          ce--, g.negative = 0, g._ishlnsubmul(b, 1, F), g.isZero() || (g.negative ^= 1);
        v && (v.words[F] = ce);
      }
      return v && v.strip(), g.strip(), m !== "div" && f !== 0 && g.iushrn(f), {
        div: v || null,
        mod: g
      };
    }, s.prototype.divmod = function(S, m, f) {
      if (n(!S.isZero()), this.isZero())
        return {
          div: new s(0),
          mod: new s(0)
        };
      var g, b, x;
      return this.negative !== 0 && S.negative === 0 ? (x = this.neg().divmod(S, m), m !== "mod" && (g = x.div.neg()), m !== "div" && (b = x.mod.neg(), f && b.negative !== 0 && b.iadd(S)), {
        div: g,
        mod: b
      }) : this.negative === 0 && S.negative !== 0 ? (x = this.divmod(S.neg(), m), m !== "mod" && (g = x.div.neg()), {
        div: g,
        mod: x.mod
      }) : this.negative & S.negative ? (x = this.neg().divmod(S.neg(), m), m !== "div" && (b = x.mod.neg(), f && b.negative !== 0 && b.isub(S)), {
        div: x.div,
        mod: b
      }) : S.length > this.length || this.cmp(S) < 0 ? {
        div: new s(0),
        mod: this
      } : S.length === 1 ? m === "div" ? {
        div: this.divn(S.words[0]),
        mod: null
      } : m === "mod" ? {
        div: null,
        mod: new s(this.modn(S.words[0]))
      } : {
        div: this.divn(S.words[0]),
        mod: new s(this.modn(S.words[0]))
      } : this._wordDiv(S, m);
    }, s.prototype.div = function(S) {
      return this.divmod(S, "div", !1).div;
    }, s.prototype.mod = function(S) {
      return this.divmod(S, "mod", !1).mod;
    }, s.prototype.umod = function(S) {
      return this.divmod(S, "mod", !0).mod;
    }, s.prototype.divRound = function(S) {
      var m = this.divmod(S);
      if (m.mod.isZero()) return m.div;
      var f = m.div.negative !== 0 ? m.mod.isub(S) : m.mod, g = S.ushrn(1), b = S.andln(1), x = f.cmp(g);
      return x < 0 || b === 1 && x === 0 ? m.div : m.div.negative !== 0 ? m.div.isubn(1) : m.div.iaddn(1);
    }, s.prototype.modn = function(S) {
      n(S <= 67108863);
      for (var m = (1 << 26) % S, f = 0, g = this.length - 1; g >= 0; g--)
        f = (m * f + (this.words[g] | 0)) % S;
      return f;
    }, s.prototype.idivn = function(S) {
      n(S <= 67108863);
      for (var m = 0, f = this.length - 1; f >= 0; f--) {
        var g = (this.words[f] | 0) + m * 67108864;
        this.words[f] = g / S | 0, m = g % S;
      }
      return this.strip();
    }, s.prototype.divn = function(S) {
      return this.clone().idivn(S);
    }, s.prototype.egcd = function(S) {
      n(S.negative === 0), n(!S.isZero());
      var m = this, f = S.clone();
      m.negative !== 0 ? m = m.umod(S) : m = m.clone();
      for (var g = new s(1), b = new s(0), x = new s(0), _ = new s(1), E = 0; m.isEven() && f.isEven(); )
        m.iushrn(1), f.iushrn(1), ++E;
      for (var v = f.clone(), M = m.clone(); !m.isZero(); ) {
        for (var I = 0, F = 1; !(m.words[0] & F) && I < 26; ++I, F <<= 1) ;
        if (I > 0)
          for (m.iushrn(I); I-- > 0; )
            (g.isOdd() || b.isOdd()) && (g.iadd(v), b.isub(M)), g.iushrn(1), b.iushrn(1);
        for (var ce = 0, D = 1; !(f.words[0] & D) && ce < 26; ++ce, D <<= 1) ;
        if (ce > 0)
          for (f.iushrn(ce); ce-- > 0; )
            (x.isOdd() || _.isOdd()) && (x.iadd(v), _.isub(M)), x.iushrn(1), _.iushrn(1);
        m.cmp(f) >= 0 ? (m.isub(f), g.isub(x), b.isub(_)) : (f.isub(m), x.isub(g), _.isub(b));
      }
      return {
        a: x,
        b: _,
        gcd: f.iushln(E)
      };
    }, s.prototype._invmp = function(S) {
      n(S.negative === 0), n(!S.isZero());
      var m = this, f = S.clone();
      m.negative !== 0 ? m = m.umod(S) : m = m.clone();
      for (var g = new s(1), b = new s(0), x = f.clone(); m.cmpn(1) > 0 && f.cmpn(1) > 0; ) {
        for (var _ = 0, E = 1; !(m.words[0] & E) && _ < 26; ++_, E <<= 1) ;
        if (_ > 0)
          for (m.iushrn(_); _-- > 0; )
            g.isOdd() && g.iadd(x), g.iushrn(1);
        for (var v = 0, M = 1; !(f.words[0] & M) && v < 26; ++v, M <<= 1) ;
        if (v > 0)
          for (f.iushrn(v); v-- > 0; )
            b.isOdd() && b.iadd(x), b.iushrn(1);
        m.cmp(f) >= 0 ? (m.isub(f), g.isub(b)) : (f.isub(m), b.isub(g));
      }
      var I;
      return m.cmpn(1) === 0 ? I = g : I = b, I.cmpn(0) < 0 && I.iadd(S), I;
    }, s.prototype.gcd = function(S) {
      if (this.isZero()) return S.abs();
      if (S.isZero()) return this.abs();
      var m = this.clone(), f = S.clone();
      m.negative = 0, f.negative = 0;
      for (var g = 0; m.isEven() && f.isEven(); g++)
        m.iushrn(1), f.iushrn(1);
      do {
        for (; m.isEven(); )
          m.iushrn(1);
        for (; f.isEven(); )
          f.iushrn(1);
        var b = m.cmp(f);
        if (b < 0) {
          var x = m;
          m = f, f = x;
        } else if (b === 0 || f.cmpn(1) === 0)
          break;
        m.isub(f);
      } while (!0);
      return f.iushln(g);
    }, s.prototype.invm = function(S) {
      return this.egcd(S).a.umod(S);
    }, s.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, s.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, s.prototype.andln = function(S) {
      return this.words[0] & S;
    }, s.prototype.bincn = function(S) {
      n(typeof S == "number");
      var m = S % 26, f = (S - m) / 26, g = 1 << m;
      if (this.length <= f)
        return this._expand(f + 1), this.words[f] |= g, this;
      for (var b = g, x = f; b !== 0 && x < this.length; x++) {
        var _ = this.words[x] | 0;
        _ += b, b = _ >>> 26, _ &= 67108863, this.words[x] = _;
      }
      return b !== 0 && (this.words[x] = b, this.length++), this;
    }, s.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, s.prototype.cmpn = function(S) {
      var m = S < 0;
      if (this.negative !== 0 && !m) return -1;
      if (this.negative === 0 && m) return 1;
      this.strip();
      var f;
      if (this.length > 1)
        f = 1;
      else {
        m && (S = -S), n(S <= 67108863, "Number is too big");
        var g = this.words[0] | 0;
        f = g === S ? 0 : g < S ? -1 : 1;
      }
      return this.negative !== 0 ? -f | 0 : f;
    }, s.prototype.cmp = function(S) {
      if (this.negative !== 0 && S.negative === 0) return -1;
      if (this.negative === 0 && S.negative !== 0) return 1;
      var m = this.ucmp(S);
      return this.negative !== 0 ? -m | 0 : m;
    }, s.prototype.ucmp = function(S) {
      if (this.length > S.length) return 1;
      if (this.length < S.length) return -1;
      for (var m = 0, f = this.length - 1; f >= 0; f--) {
        var g = this.words[f] | 0, b = S.words[f] | 0;
        if (g !== b) {
          g < b ? m = -1 : g > b && (m = 1);
          break;
        }
      }
      return m;
    }, s.prototype.gtn = function(S) {
      return this.cmpn(S) === 1;
    }, s.prototype.gt = function(S) {
      return this.cmp(S) === 1;
    }, s.prototype.gten = function(S) {
      return this.cmpn(S) >= 0;
    }, s.prototype.gte = function(S) {
      return this.cmp(S) >= 0;
    }, s.prototype.ltn = function(S) {
      return this.cmpn(S) === -1;
    }, s.prototype.lt = function(S) {
      return this.cmp(S) === -1;
    }, s.prototype.lten = function(S) {
      return this.cmpn(S) <= 0;
    }, s.prototype.lte = function(S) {
      return this.cmp(S) <= 0;
    }, s.prototype.eqn = function(S) {
      return this.cmpn(S) === 0;
    }, s.prototype.eq = function(S) {
      return this.cmp(S) === 0;
    }, s.red = function(S) {
      return new ge(S);
    }, s.prototype.toRed = function(S) {
      return n(!this.red, "Already a number in reduction context"), n(this.negative === 0, "red works only with positives"), S.convertTo(this)._forceRed(S);
    }, s.prototype.fromRed = function() {
      return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, s.prototype._forceRed = function(S) {
      return this.red = S, this;
    }, s.prototype.forceRed = function(S) {
      return n(!this.red, "Already a number in reduction context"), this._forceRed(S);
    }, s.prototype.redAdd = function(S) {
      return n(this.red, "redAdd works only with red numbers"), this.red.add(this, S);
    }, s.prototype.redIAdd = function(S) {
      return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, S);
    }, s.prototype.redSub = function(S) {
      return n(this.red, "redSub works only with red numbers"), this.red.sub(this, S);
    }, s.prototype.redISub = function(S) {
      return n(this.red, "redISub works only with red numbers"), this.red.isub(this, S);
    }, s.prototype.redShl = function(S) {
      return n(this.red, "redShl works only with red numbers"), this.red.shl(this, S);
    }, s.prototype.redMul = function(S) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.mul(this, S);
    }, s.prototype.redIMul = function(S) {
      return n(this.red, "redMul works only with red numbers"), this.red._verify2(this, S), this.red.imul(this, S);
    }, s.prototype.redSqr = function() {
      return n(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, s.prototype.redISqr = function() {
      return n(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, s.prototype.redSqrt = function() {
      return n(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, s.prototype.redInvm = function() {
      return n(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, s.prototype.redNeg = function() {
      return n(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, s.prototype.redPow = function(S) {
      return n(this.red && !S.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, S);
    };
    var H = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function W(Y, S) {
      this.name = Y, this.p = new s(S, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    W.prototype._tmp = function() {
      var S = new s(null);
      return S.words = new Array(Math.ceil(this.n / 13)), S;
    }, W.prototype.ireduce = function(S) {
      var m = S, f;
      do
        this.split(m, this.tmp), m = this.imulK(m), m = m.iadd(this.tmp), f = m.bitLength();
      while (f > this.n);
      var g = f < this.n ? -1 : m.ucmp(this.p);
      return g === 0 ? (m.words[0] = 0, m.length = 1) : g > 0 ? m.isub(this.p) : m.strip !== void 0 ? m.strip() : m._strip(), m;
    }, W.prototype.split = function(S, m) {
      S.iushrn(this.n, 0, m);
    }, W.prototype.imulK = function(S) {
      return S.imul(this.k);
    };
    function V() {
      W.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(V, W), V.prototype.split = function(S, m) {
      for (var f = 4194303, g = Math.min(S.length, 9), b = 0; b < g; b++)
        m.words[b] = S.words[b];
      if (m.length = g, S.length <= 9) {
        S.words[0] = 0, S.length = 1;
        return;
      }
      var x = S.words[9];
      for (m.words[m.length++] = x & f, b = 10; b < S.length; b++) {
        var _ = S.words[b] | 0;
        S.words[b - 10] = (_ & f) << 4 | x >>> 22, x = _;
      }
      x >>>= 22, S.words[b - 10] = x, x === 0 && S.length > 10 ? S.length -= 10 : S.length -= 9;
    }, V.prototype.imulK = function(S) {
      S.words[S.length] = 0, S.words[S.length + 1] = 0, S.length += 2;
      for (var m = 0, f = 0; f < S.length; f++) {
        var g = S.words[f] | 0;
        m += g * 977, S.words[f] = m & 67108863, m = g * 64 + (m / 67108864 | 0);
      }
      return S.words[S.length - 1] === 0 && (S.length--, S.words[S.length - 1] === 0 && S.length--), S;
    };
    function te() {
      W.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(te, W);
    function R() {
      W.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(R, W);
    function K() {
      W.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(K, W), K.prototype.imulK = function(S) {
      for (var m = 0, f = 0; f < S.length; f++) {
        var g = (S.words[f] | 0) * 19 + m, b = g & 67108863;
        g >>>= 26, S.words[f] = b, m = g;
      }
      return m !== 0 && (S.words[S.length++] = m), S;
    }, s._prime = function(S) {
      if (H[S]) return H[S];
      var m;
      if (S === "k256")
        m = new V();
      else if (S === "p224")
        m = new te();
      else if (S === "p192")
        m = new R();
      else if (S === "p25519")
        m = new K();
      else
        throw new Error("Unknown prime " + S);
      return H[S] = m, m;
    };
    function ge(Y) {
      if (typeof Y == "string") {
        var S = s._prime(Y);
        this.m = S.p, this.prime = S;
      } else
        n(Y.gtn(1), "modulus must be greater than 1"), this.m = Y, this.prime = null;
    }
    ge.prototype._verify1 = function(S) {
      n(S.negative === 0, "red works only with positives"), n(S.red, "red works only with red numbers");
    }, ge.prototype._verify2 = function(S, m) {
      n((S.negative | m.negative) === 0, "red works only with positives"), n(
        S.red && S.red === m.red,
        "red works only with red numbers"
      );
    }, ge.prototype.imod = function(S) {
      return this.prime ? this.prime.ireduce(S)._forceRed(this) : S.umod(this.m)._forceRed(this);
    }, ge.prototype.neg = function(S) {
      return S.isZero() ? S.clone() : this.m.sub(S)._forceRed(this);
    }, ge.prototype.add = function(S, m) {
      this._verify2(S, m);
      var f = S.add(m);
      return f.cmp(this.m) >= 0 && f.isub(this.m), f._forceRed(this);
    }, ge.prototype.iadd = function(S, m) {
      this._verify2(S, m);
      var f = S.iadd(m);
      return f.cmp(this.m) >= 0 && f.isub(this.m), f;
    }, ge.prototype.sub = function(S, m) {
      this._verify2(S, m);
      var f = S.sub(m);
      return f.cmpn(0) < 0 && f.iadd(this.m), f._forceRed(this);
    }, ge.prototype.isub = function(S, m) {
      this._verify2(S, m);
      var f = S.isub(m);
      return f.cmpn(0) < 0 && f.iadd(this.m), f;
    }, ge.prototype.shl = function(S, m) {
      return this._verify1(S), this.imod(S.ushln(m));
    }, ge.prototype.imul = function(S, m) {
      return this._verify2(S, m), this.imod(S.imul(m));
    }, ge.prototype.mul = function(S, m) {
      return this._verify2(S, m), this.imod(S.mul(m));
    }, ge.prototype.isqr = function(S) {
      return this.imul(S, S.clone());
    }, ge.prototype.sqr = function(S) {
      return this.mul(S, S);
    }, ge.prototype.sqrt = function(S) {
      if (S.isZero()) return S.clone();
      var m = this.m.andln(3);
      if (n(m % 2 === 1), m === 3) {
        var f = this.m.add(new s(1)).iushrn(2);
        return this.pow(S, f);
      }
      for (var g = this.m.subn(1), b = 0; !g.isZero() && g.andln(1) === 0; )
        b++, g.iushrn(1);
      n(!g.isZero());
      var x = new s(1).toRed(this), _ = x.redNeg(), E = this.m.subn(1).iushrn(1), v = this.m.bitLength();
      for (v = new s(2 * v * v).toRed(this); this.pow(v, E).cmp(_) !== 0; )
        v.redIAdd(_);
      for (var M = this.pow(v, g), I = this.pow(S, g.addn(1).iushrn(1)), F = this.pow(S, g), ce = b; F.cmp(x) !== 0; ) {
        for (var D = F, oe = 0; D.cmp(x) !== 0; oe++)
          D = D.redSqr();
        n(oe < ce);
        var Z = this.pow(M, new s(1).iushln(ce - oe - 1));
        I = I.redMul(Z), M = Z.redSqr(), F = F.redMul(M), ce = oe;
      }
      return I;
    }, ge.prototype.invm = function(S) {
      var m = S._invmp(this.m);
      return m.negative !== 0 ? (m.negative = 0, this.imod(m).redNeg()) : this.imod(m);
    }, ge.prototype.pow = function(S, m) {
      if (m.isZero()) return new s(1).toRed(this);
      if (m.cmpn(1) === 0) return S.clone();
      var f = 4, g = new Array(1 << f);
      g[0] = new s(1).toRed(this), g[1] = S;
      for (var b = 2; b < g.length; b++)
        g[b] = this.mul(g[b - 1], S);
      var x = g[0], _ = 0, E = 0, v = m.bitLength() % 26;
      for (v === 0 && (v = 26), b = m.length - 1; b >= 0; b--) {
        for (var M = m.words[b], I = v - 1; I >= 0; I--) {
          var F = M >> I & 1;
          if (x !== g[0] && (x = this.sqr(x)), F === 0 && _ === 0) {
            E = 0;
            continue;
          }
          _ <<= 1, _ |= F, E++, !(E !== f && (b !== 0 || I !== 0)) && (x = this.mul(x, g[_]), E = 0, _ = 0);
        }
        v = 26;
      }
      return x;
    }, ge.prototype.convertTo = function(S) {
      var m = S.umod(this.m);
      return m === S ? m.clone() : m;
    }, ge.prototype.convertFrom = function(S) {
      var m = S.clone();
      return m.red = null, m;
    }, s.mont = function(S) {
      return new Ee(S);
    };
    function Ee(Y) {
      ge.call(this, Y), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(Ee, ge), Ee.prototype.convertTo = function(S) {
      return this.imod(S.ushln(this.shift));
    }, Ee.prototype.convertFrom = function(S) {
      var m = this.imod(S.mul(this.rinv));
      return m.red = null, m;
    }, Ee.prototype.imul = function(S, m) {
      if (S.isZero() || m.isZero())
        return S.words[0] = 0, S.length = 1, S;
      var f = S.imul(m), g = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), b = f.isub(g).iushrn(this.shift), x = b;
      return b.cmp(this.m) >= 0 ? x = b.isub(this.m) : b.cmpn(0) < 0 && (x = b.iadd(this.m)), x._forceRed(this);
    }, Ee.prototype.mul = function(S, m) {
      if (S.isZero() || m.isZero()) return new s(0)._forceRed(this);
      var f = S.mul(m), g = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), b = f.isub(g).iushrn(this.shift), x = b;
      return b.cmp(this.m) >= 0 ? x = b.isub(this.m) : b.cmpn(0) < 0 && (x = b.iadd(this.m)), x._forceRed(this);
    }, Ee.prototype.invm = function(S) {
      var m = this.imod(S._invmp(this.m).mul(this.r2));
      return m._forceRed(this);
    };
  })(t, gn);
})(Xv);
var Ho = Xv.exports, Zv = {};
(function(t) {
  var e = t;
  function r(s, o) {
    if (Array.isArray(s))
      return s.slice();
    if (!s)
      return [];
    var a = [];
    if (typeof s != "string") {
      for (var u = 0; u < s.length; u++)
        a[u] = s[u] | 0;
      return a;
    }
    if (o === "hex") {
      s = s.replace(/[^a-z0-9]+/ig, ""), s.length % 2 !== 0 && (s = "0" + s);
      for (var u = 0; u < s.length; u += 2)
        a.push(parseInt(s[u] + s[u + 1], 16));
    } else
      for (var u = 0; u < s.length; u++) {
        var l = s.charCodeAt(u), d = l >> 8, p = l & 255;
        d ? a.push(d, p) : a.push(p);
      }
    return a;
  }
  e.toArray = r;
  function n(s) {
    return s.length === 1 ? "0" + s : s;
  }
  e.zero2 = n;
  function i(s) {
    for (var o = "", a = 0; a < s.length; a++)
      o += n(s[a].toString(16));
    return o;
  }
  e.toHex = i, e.encode = function(o, a) {
    return a === "hex" ? i(o) : o;
  };
})(Zv);
(function(t) {
  var e = t, r = Ho, n = wc, i = Zv;
  e.assert = n, e.toArray = i.toArray, e.zero2 = i.zero2, e.toHex = i.toHex, e.encode = i.encode;
  function s(d, p, w) {
    var A = new Array(Math.max(d.bitLength(), w) + 1), P;
    for (P = 0; P < A.length; P += 1)
      A[P] = 0;
    var N = 1 << p + 1, L = d.clone();
    for (P = 0; P < A.length; P++) {
      var $, B = L.andln(N - 1);
      L.isOdd() ? (B > (N >> 1) - 1 ? $ = (N >> 1) - B : $ = B, L.isubn($)) : $ = 0, A[P] = $, L.iushrn(1);
    }
    return A;
  }
  e.getNAF = s;
  function o(d, p) {
    var w = [
      [],
      []
    ];
    d = d.clone(), p = p.clone();
    for (var A = 0, P = 0, N; d.cmpn(-A) > 0 || p.cmpn(-P) > 0; ) {
      var L = d.andln(3) + A & 3, $ = p.andln(3) + P & 3;
      L === 3 && (L = -1), $ === 3 && ($ = -1);
      var B;
      L & 1 ? (N = d.andln(7) + A & 7, (N === 3 || N === 5) && $ === 2 ? B = -L : B = L) : B = 0, w[0].push(B);
      var H;
      $ & 1 ? (N = p.andln(7) + P & 7, (N === 3 || N === 5) && L === 2 ? H = -$ : H = $) : H = 0, w[1].push(H), 2 * A === B + 1 && (A = 1 - A), 2 * P === H + 1 && (P = 1 - P), d.iushrn(1), p.iushrn(1);
    }
    return w;
  }
  e.getJSF = o;
  function a(d, p, w) {
    var A = "_" + p;
    d.prototype[p] = function() {
      return this[A] !== void 0 ? this[A] : this[A] = w.call(this);
    };
  }
  e.cachedProperty = a;
  function u(d) {
    return typeof d == "string" ? e.toArray(d, "hex") : d;
  }
  e.parseBytes = u;
  function l(d) {
    return new r(d, "hex", "le");
  }
  e.intFromLE = l;
})(Fi);
var Qv = { exports: {} }, am;
Qv.exports = function(e) {
  return am || (am = new da(null)), am.generate(e);
};
function da(t) {
  this.rand = t;
}
Qv.exports.Rand = da;
da.prototype.generate = function(e) {
  return this._rand(e);
};
da.prototype._rand = function(e) {
  if (this.rand.getBytes)
    return this.rand.getBytes(e);
  for (var r = new Uint8Array(e), n = 0; n < r.length; n++)
    r[n] = this.rand.getByte();
  return r;
};
if (typeof self == "object")
  self.crypto && self.crypto.getRandomValues ? da.prototype._rand = function(e) {
    var r = new Uint8Array(e);
    return self.crypto.getRandomValues(r), r;
  } : self.msCrypto && self.msCrypto.getRandomValues ? da.prototype._rand = function(e) {
    var r = new Uint8Array(e);
    return self.msCrypto.getRandomValues(r), r;
  } : typeof window == "object" && (da.prototype._rand = function() {
    throw new Error("Not implemented yet");
  });
else
  try {
    var Rx = Wl;
    if (typeof Rx.randomBytes != "function")
      throw new Error("Not supported");
    da.prototype._rand = function(e) {
      return Rx.randomBytes(e);
    };
  } catch {
  }
var S8 = Qv.exports, eb = {}, Ka = Ho, Jl = Fi, s0 = Jl.getNAF, nq = Jl.getJSF, o0 = Jl.assert;
function Da(t, e) {
  this.type = t, this.p = new Ka(e.p, 16), this.red = e.prime ? Ka.red(e.prime) : Ka.mont(this.p), this.zero = new Ka(0).toRed(this.red), this.one = new Ka(1).toRed(this.red), this.two = new Ka(2).toRed(this.red), this.n = e.n && new Ka(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var r = this.n && this.p.div(this.n);
  !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var G0 = Da;
Da.prototype.point = function() {
  throw new Error("Not implemented");
};
Da.prototype.validate = function() {
  throw new Error("Not implemented");
};
Da.prototype._fixedNafMul = function(e, r) {
  o0(e.precomputed);
  var n = e._getDoubles(), i = s0(r, 1, this._bitLength), s = (1 << n.step + 1) - (n.step % 2 === 0 ? 2 : 1);
  s /= 3;
  var o = [], a, u;
  for (a = 0; a < i.length; a += n.step) {
    u = 0;
    for (var l = a + n.step - 1; l >= a; l--)
      u = (u << 1) + i[l];
    o.push(u);
  }
  for (var d = this.jpoint(null, null, null), p = this.jpoint(null, null, null), w = s; w > 0; w--) {
    for (a = 0; a < o.length; a++)
      u = o[a], u === w ? p = p.mixedAdd(n.points[a]) : u === -w && (p = p.mixedAdd(n.points[a].neg()));
    d = d.add(p);
  }
  return d.toP();
};
Da.prototype._wnafMul = function(e, r) {
  var n = 4, i = e._getNAFPoints(n);
  n = i.wnd;
  for (var s = i.points, o = s0(r, n, this._bitLength), a = this.jpoint(null, null, null), u = o.length - 1; u >= 0; u--) {
    for (var l = 0; u >= 0 && o[u] === 0; u--)
      l++;
    if (u >= 0 && l++, a = a.dblp(l), u < 0)
      break;
    var d = o[u];
    o0(d !== 0), e.type === "affine" ? d > 0 ? a = a.mixedAdd(s[d - 1 >> 1]) : a = a.mixedAdd(s[-d - 1 >> 1].neg()) : d > 0 ? a = a.add(s[d - 1 >> 1]) : a = a.add(s[-d - 1 >> 1].neg());
  }
  return e.type === "affine" ? a.toP() : a;
};
Da.prototype._wnafMulAdd = function(e, r, n, i, s) {
  var o = this._wnafT1, a = this._wnafT2, u = this._wnafT3, l = 0, d, p, w;
  for (d = 0; d < i; d++) {
    w = r[d];
    var A = w._getNAFPoints(e);
    o[d] = A.wnd, a[d] = A.points;
  }
  for (d = i - 1; d >= 1; d -= 2) {
    var P = d - 1, N = d;
    if (o[P] !== 1 || o[N] !== 1) {
      u[P] = s0(n[P], o[P], this._bitLength), u[N] = s0(n[N], o[N], this._bitLength), l = Math.max(u[P].length, l), l = Math.max(u[N].length, l);
      continue;
    }
    var L = [
      r[P],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      r[N]
      /* 7 */
    ];
    r[P].y.cmp(r[N].y) === 0 ? (L[1] = r[P].add(r[N]), L[2] = r[P].toJ().mixedAdd(r[N].neg())) : r[P].y.cmp(r[N].y.redNeg()) === 0 ? (L[1] = r[P].toJ().mixedAdd(r[N]), L[2] = r[P].add(r[N].neg())) : (L[1] = r[P].toJ().mixedAdd(r[N]), L[2] = r[P].toJ().mixedAdd(r[N].neg()));
    var $ = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], B = nq(n[P], n[N]);
    for (l = Math.max(B[0].length, l), u[P] = new Array(l), u[N] = new Array(l), p = 0; p < l; p++) {
      var H = B[0][p] | 0, W = B[1][p] | 0;
      u[P][p] = $[(H + 1) * 3 + (W + 1)], u[N][p] = 0, a[P] = L;
    }
  }
  var V = this.jpoint(null, null, null), te = this._wnafT4;
  for (d = l; d >= 0; d--) {
    for (var R = 0; d >= 0; ) {
      var K = !0;
      for (p = 0; p < i; p++)
        te[p] = u[p][d] | 0, te[p] !== 0 && (K = !1);
      if (!K)
        break;
      R++, d--;
    }
    if (d >= 0 && R++, V = V.dblp(R), d < 0)
      break;
    for (p = 0; p < i; p++) {
      var ge = te[p];
      ge !== 0 && (ge > 0 ? w = a[p][ge - 1 >> 1] : ge < 0 && (w = a[p][-ge - 1 >> 1].neg()), w.type === "affine" ? V = V.mixedAdd(w) : V = V.add(w));
    }
  }
  for (d = 0; d < i; d++)
    a[d] = null;
  return s ? V : V.toP();
};
function os(t, e) {
  this.curve = t, this.type = e, this.precomputed = null;
}
Da.BasePoint = os;
os.prototype.eq = function() {
  throw new Error("Not implemented");
};
os.prototype.validate = function() {
  return this.curve.validate(this);
};
Da.prototype.decodePoint = function(e, r) {
  e = Jl.toArray(e, r);
  var n = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * n) {
    e[0] === 6 ? o0(e[e.length - 1] % 2 === 0) : e[0] === 7 && o0(e[e.length - 1] % 2 === 1);
    var i = this.point(
      e.slice(1, 1 + n),
      e.slice(1 + n, 1 + 2 * n)
    );
    return i;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === n)
    return this.pointFromX(e.slice(1, 1 + n), e[0] === 3);
  throw new Error("Unknown point format");
};
os.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
os.prototype._encode = function(e) {
  var r = this.curve.p.byteLength(), n = this.getX().toArray("be", r);
  return e ? [this.getY().isEven() ? 2 : 3].concat(n) : [4].concat(n, this.getY().toArray("be", r));
};
os.prototype.encode = function(e, r) {
  return Jl.encode(this._encode(r), e);
};
os.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var r = {
    doubles: null,
    naf: null,
    beta: null
  };
  return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
};
os.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var r = this.precomputed.doubles;
  return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : !1;
};
os.prototype._getDoubles = function(e, r) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var n = [this], i = this, s = 0; s < r; s += e) {
    for (var o = 0; o < e; o++)
      i = i.dbl();
    n.push(i);
  }
  return {
    step: e,
    points: n
  };
};
os.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var r = [this], n = (1 << e) - 1, i = n === 1 ? null : this.dbl(), s = 1; s < n; s++)
    r[s] = r[s - 1].add(i);
  return {
    wnd: e,
    points: r
  };
};
os.prototype._getBeta = function() {
  return null;
};
os.prototype.dblp = function(e) {
  for (var r = this, n = 0; n < e; n++)
    r = r.dbl();
  return r;
};
var iq = Fi, rn = Ho, tb = z0, Fu = G0, sq = iq.assert;
function as(t) {
  Fu.call(this, "short", t), this.a = new rn(t.a, 16).toRed(this.red), this.b = new rn(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
tb(as, Fu);
var oq = as;
as.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var r, n;
    if (e.beta)
      r = new rn(e.beta, 16).toRed(this.red);
    else {
      var i = this._getEndoRoots(this.p);
      r = i[0].cmp(i[1]) < 0 ? i[0] : i[1], r = r.toRed(this.red);
    }
    if (e.lambda)
      n = new rn(e.lambda, 16);
    else {
      var s = this._getEndoRoots(this.n);
      this.g.mul(s[0]).x.cmp(this.g.x.redMul(r)) === 0 ? n = s[0] : (n = s[1], sq(this.g.mul(n).x.cmp(this.g.x.redMul(r)) === 0));
    }
    var o;
    return e.basis ? o = e.basis.map(function(a) {
      return {
        a: new rn(a.a, 16),
        b: new rn(a.b, 16)
      };
    }) : o = this._getEndoBasis(n), {
      beta: r,
      lambda: n,
      basis: o
    };
  }
};
as.prototype._getEndoRoots = function(e) {
  var r = e === this.p ? this.red : rn.mont(e), n = new rn(2).toRed(r).redInvm(), i = n.redNeg(), s = new rn(3).toRed(r).redNeg().redSqrt().redMul(n), o = i.redAdd(s).fromRed(), a = i.redSub(s).fromRed();
  return [o, a];
};
as.prototype._getEndoBasis = function(e) {
  for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), n = e, i = this.n.clone(), s = new rn(1), o = new rn(0), a = new rn(0), u = new rn(1), l, d, p, w, A, P, N, L = 0, $, B; n.cmpn(0) !== 0; ) {
    var H = i.div(n);
    $ = i.sub(H.mul(n)), B = a.sub(H.mul(s));
    var W = u.sub(H.mul(o));
    if (!p && $.cmp(r) < 0)
      l = N.neg(), d = s, p = $.neg(), w = B;
    else if (p && ++L === 2)
      break;
    N = $, i = n, n = $, a = s, s = B, u = o, o = W;
  }
  A = $.neg(), P = B;
  var V = p.sqr().add(w.sqr()), te = A.sqr().add(P.sqr());
  return te.cmp(V) >= 0 && (A = l, P = d), p.negative && (p = p.neg(), w = w.neg()), A.negative && (A = A.neg(), P = P.neg()), [
    { a: p, b: w },
    { a: A, b: P }
  ];
};
as.prototype._endoSplit = function(e) {
  var r = this.endo.basis, n = r[0], i = r[1], s = i.b.mul(e).divRound(this.n), o = n.b.neg().mul(e).divRound(this.n), a = s.mul(n.a), u = o.mul(i.a), l = s.mul(n.b), d = o.mul(i.b), p = e.sub(a).sub(u), w = l.add(d).neg();
  return { k1: p, k2: w };
};
as.prototype.pointFromX = function(e, r) {
  e = new rn(e, 16), e.red || (e = e.toRed(this.red));
  var n = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), i = n.redSqrt();
  if (i.redSqr().redSub(n).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var s = i.fromRed().isOdd();
  return (r && !s || !r && s) && (i = i.redNeg()), this.point(e, i);
};
as.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var r = e.x, n = e.y, i = this.a.redMul(r), s = r.redSqr().redMul(r).redIAdd(i).redIAdd(this.b);
  return n.redSqr().redISub(s).cmpn(0) === 0;
};
as.prototype._endoWnafMulAdd = function(e, r, n) {
  for (var i = this._endoWnafT1, s = this._endoWnafT2, o = 0; o < e.length; o++) {
    var a = this._endoSplit(r[o]), u = e[o], l = u._getBeta();
    a.k1.negative && (a.k1.ineg(), u = u.neg(!0)), a.k2.negative && (a.k2.ineg(), l = l.neg(!0)), i[o * 2] = u, i[o * 2 + 1] = l, s[o * 2] = a.k1, s[o * 2 + 1] = a.k2;
  }
  for (var d = this._wnafMulAdd(1, i, s, o * 2, n), p = 0; p < o * 2; p++)
    i[p] = null, s[p] = null;
  return d;
};
function $n(t, e, r, n) {
  Fu.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new rn(e, 16), this.y = new rn(r, 16), n && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
tb($n, Fu.BasePoint);
as.prototype.point = function(e, r, n) {
  return new $n(this, e, r, n);
};
as.prototype.pointFromJSON = function(e, r) {
  return $n.fromJSON(this, e, r);
};
$n.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var n = this.curve, i = function(s) {
        return n.point(s.x.redMul(n.endo.beta), s.y);
      };
      e.beta = r, r.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(i)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(i)
        }
      };
    }
    return r;
  }
};
$n.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
$n.fromJSON = function(e, r, n) {
  typeof r == "string" && (r = JSON.parse(r));
  var i = e.point(r[0], r[1], n);
  if (!r[2])
    return i;
  function s(a) {
    return e.point(a[0], a[1], n);
  }
  var o = r[2];
  return i.precomputed = {
    beta: null,
    doubles: o.doubles && {
      step: o.doubles.step,
      points: [i].concat(o.doubles.points.map(s))
    },
    naf: o.naf && {
      wnd: o.naf.wnd,
      points: [i].concat(o.naf.points.map(s))
    }
  }, i;
};
$n.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
$n.prototype.isInfinity = function() {
  return this.inf;
};
$n.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var r = this.y.redSub(e.y);
  r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
  var n = r.redSqr().redISub(this.x).redISub(e.x), i = r.redMul(this.x.redSub(n)).redISub(this.y);
  return this.curve.point(n, i);
};
$n.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var r = this.curve.a, n = this.x.redSqr(), i = e.redInvm(), s = n.redAdd(n).redIAdd(n).redIAdd(r).redMul(i), o = s.redSqr().redISub(this.x.redAdd(this.x)), a = s.redMul(this.x.redSub(o)).redISub(this.y);
  return this.curve.point(o, a);
};
$n.prototype.getX = function() {
  return this.x.fromRed();
};
$n.prototype.getY = function() {
  return this.y.fromRed();
};
$n.prototype.mul = function(e) {
  return e = new rn(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
$n.prototype.mulAdd = function(e, r, n) {
  var i = [this, r], s = [e, n];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2);
};
$n.prototype.jmulAdd = function(e, r, n) {
  var i = [this, r], s = [e, n];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, !0) : this.curve._wnafMulAdd(1, i, s, 2, !0);
};
$n.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
$n.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var r = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var n = this.precomputed, i = function(s) {
      return s.neg();
    };
    r.precomputed = {
      naf: n.naf && {
        wnd: n.naf.wnd,
        points: n.naf.points.map(i)
      },
      doubles: n.doubles && {
        step: n.doubles.step,
        points: n.doubles.points.map(i)
      }
    };
  }
  return r;
};
$n.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function Wn(t, e, r, n) {
  Fu.BasePoint.call(this, t, "jacobian"), e === null && r === null && n === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new rn(0)) : (this.x = new rn(e, 16), this.y = new rn(r, 16), this.z = new rn(n, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
tb(Wn, Fu.BasePoint);
as.prototype.jpoint = function(e, r, n) {
  return new Wn(this, e, r, n);
};
Wn.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), r = e.redSqr(), n = this.x.redMul(r), i = this.y.redMul(r).redMul(e);
  return this.curve.point(n, i);
};
Wn.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
Wn.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var r = e.z.redSqr(), n = this.z.redSqr(), i = this.x.redMul(r), s = e.x.redMul(n), o = this.y.redMul(r.redMul(e.z)), a = e.y.redMul(n.redMul(this.z)), u = i.redSub(s), l = o.redSub(a);
  if (u.cmpn(0) === 0)
    return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var d = u.redSqr(), p = d.redMul(u), w = i.redMul(d), A = l.redSqr().redIAdd(p).redISub(w).redISub(w), P = l.redMul(w.redISub(A)).redISub(o.redMul(p)), N = this.z.redMul(e.z).redMul(u);
  return this.curve.jpoint(A, P, N);
};
Wn.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var r = this.z.redSqr(), n = this.x, i = e.x.redMul(r), s = this.y, o = e.y.redMul(r).redMul(this.z), a = n.redSub(i), u = s.redSub(o);
  if (a.cmpn(0) === 0)
    return u.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var l = a.redSqr(), d = l.redMul(a), p = n.redMul(l), w = u.redSqr().redIAdd(d).redISub(p).redISub(p), A = u.redMul(p.redISub(w)).redISub(s.redMul(d)), P = this.z.redMul(a);
  return this.curve.jpoint(w, A, P);
};
Wn.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var r;
  if (this.curve.zeroA || this.curve.threeA) {
    var n = this;
    for (r = 0; r < e; r++)
      n = n.dbl();
    return n;
  }
  var i = this.curve.a, s = this.curve.tinv, o = this.x, a = this.y, u = this.z, l = u.redSqr().redSqr(), d = a.redAdd(a);
  for (r = 0; r < e; r++) {
    var p = o.redSqr(), w = d.redSqr(), A = w.redSqr(), P = p.redAdd(p).redIAdd(p).redIAdd(i.redMul(l)), N = o.redMul(w), L = P.redSqr().redISub(N.redAdd(N)), $ = N.redISub(L), B = P.redMul($);
    B = B.redIAdd(B).redISub(A);
    var H = d.redMul(u);
    r + 1 < e && (l = l.redMul(A)), o = L, u = H, d = B;
  }
  return this.curve.jpoint(o, d.redMul(s), u);
};
Wn.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
Wn.prototype._zeroDbl = function() {
  var e, r, n;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
    a = a.redIAdd(a);
    var u = i.redAdd(i).redIAdd(i), l = u.redSqr().redISub(a).redISub(a), d = o.redIAdd(o);
    d = d.redIAdd(d), d = d.redIAdd(d), e = l, r = u.redMul(a.redISub(l)).redISub(d), n = this.y.redAdd(this.y);
  } else {
    var p = this.x.redSqr(), w = this.y.redSqr(), A = w.redSqr(), P = this.x.redAdd(w).redSqr().redISub(p).redISub(A);
    P = P.redIAdd(P);
    var N = p.redAdd(p).redIAdd(p), L = N.redSqr(), $ = A.redIAdd(A);
    $ = $.redIAdd($), $ = $.redIAdd($), e = L.redISub(P).redISub(P), r = N.redMul(P.redISub(e)).redISub($), n = this.y.redMul(this.z), n = n.redIAdd(n);
  }
  return this.curve.jpoint(e, r, n);
};
Wn.prototype._threeDbl = function() {
  var e, r, n;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), o = s.redSqr(), a = this.x.redAdd(s).redSqr().redISub(i).redISub(o);
    a = a.redIAdd(a);
    var u = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a), l = u.redSqr().redISub(a).redISub(a);
    e = l;
    var d = o.redIAdd(o);
    d = d.redIAdd(d), d = d.redIAdd(d), r = u.redMul(a.redISub(l)).redISub(d), n = this.y.redAdd(this.y);
  } else {
    var p = this.z.redSqr(), w = this.y.redSqr(), A = this.x.redMul(w), P = this.x.redSub(p).redMul(this.x.redAdd(p));
    P = P.redAdd(P).redIAdd(P);
    var N = A.redIAdd(A);
    N = N.redIAdd(N);
    var L = N.redAdd(N);
    e = P.redSqr().redISub(L), n = this.y.redAdd(this.z).redSqr().redISub(w).redISub(p);
    var $ = w.redSqr();
    $ = $.redIAdd($), $ = $.redIAdd($), $ = $.redIAdd($), r = P.redMul(N.redISub(e)).redISub($);
  }
  return this.curve.jpoint(e, r, n);
};
Wn.prototype._dbl = function() {
  var e = this.curve.a, r = this.x, n = this.y, i = this.z, s = i.redSqr().redSqr(), o = r.redSqr(), a = n.redSqr(), u = o.redAdd(o).redIAdd(o).redIAdd(e.redMul(s)), l = r.redAdd(r);
  l = l.redIAdd(l);
  var d = l.redMul(a), p = u.redSqr().redISub(d.redAdd(d)), w = d.redISub(p), A = a.redSqr();
  A = A.redIAdd(A), A = A.redIAdd(A), A = A.redIAdd(A);
  var P = u.redMul(w).redISub(A), N = n.redAdd(n).redMul(i);
  return this.curve.jpoint(p, P, N);
};
Wn.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr(), i = r.redSqr(), s = e.redAdd(e).redIAdd(e), o = s.redSqr(), a = this.x.redAdd(r).redSqr().redISub(e).redISub(i);
  a = a.redIAdd(a), a = a.redAdd(a).redIAdd(a), a = a.redISub(o);
  var u = a.redSqr(), l = i.redIAdd(i);
  l = l.redIAdd(l), l = l.redIAdd(l), l = l.redIAdd(l);
  var d = s.redIAdd(a).redSqr().redISub(o).redISub(u).redISub(l), p = r.redMul(d);
  p = p.redIAdd(p), p = p.redIAdd(p);
  var w = this.x.redMul(u).redISub(p);
  w = w.redIAdd(w), w = w.redIAdd(w);
  var A = this.y.redMul(d.redMul(l.redISub(d)).redISub(a.redMul(u)));
  A = A.redIAdd(A), A = A.redIAdd(A), A = A.redIAdd(A);
  var P = this.z.redAdd(a).redSqr().redISub(n).redISub(u);
  return this.curve.jpoint(w, A, P);
};
Wn.prototype.mul = function(e, r) {
  return e = new rn(e, r), this.curve._wnafMul(this, e);
};
Wn.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var r = this.z.redSqr(), n = e.z.redSqr();
  if (this.x.redMul(n).redISub(e.x.redMul(r)).cmpn(0) !== 0)
    return !1;
  var i = r.redMul(this.z), s = n.redMul(e.z);
  return this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0) === 0;
};
Wn.prototype.eqXToP = function(e) {
  var r = this.z.redSqr(), n = e.toRed(this.curve.red).redMul(r);
  if (this.x.cmp(n) === 0)
    return !0;
  for (var i = e.clone(), s = this.curve.redN.redMul(r); ; ) {
    if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)
      return !1;
    if (n.redIAdd(s), this.x.cmp(n) === 0)
      return !0;
  }
};
Wn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
Wn.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var Qc = Ho, A8 = z0, Y0 = G0, aq = Fi;
function ju(t) {
  Y0.call(this, "mont", t), this.a = new Qc(t.a, 16).toRed(this.red), this.b = new Qc(t.b, 16).toRed(this.red), this.i4 = new Qc(4).toRed(this.red).redInvm(), this.two = new Qc(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
A8(ju, Y0);
var cq = ju;
ju.prototype.validate = function(e) {
  var r = e.normalize().x, n = r.redSqr(), i = n.redMul(r).redAdd(n.redMul(this.a)).redAdd(r), s = i.redSqrt();
  return s.redSqr().cmp(i) === 0;
};
function Ln(t, e, r) {
  Y0.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new Qc(e, 16), this.z = new Qc(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
A8(Ln, Y0.BasePoint);
ju.prototype.decodePoint = function(e, r) {
  return this.point(aq.toArray(e, r), 1);
};
ju.prototype.point = function(e, r) {
  return new Ln(this, e, r);
};
ju.prototype.pointFromJSON = function(e) {
  return Ln.fromJSON(this, e);
};
Ln.prototype.precompute = function() {
};
Ln.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Ln.fromJSON = function(e, r) {
  return new Ln(e, r[0], r[1] || e.one);
};
Ln.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Ln.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
Ln.prototype.dbl = function() {
  var e = this.x.redAdd(this.z), r = e.redSqr(), n = this.x.redSub(this.z), i = n.redSqr(), s = r.redSub(i), o = r.redMul(i), a = s.redMul(i.redAdd(this.curve.a24.redMul(s)));
  return this.curve.point(o, a);
};
Ln.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
Ln.prototype.diffAdd = function(e, r) {
  var n = this.x.redAdd(this.z), i = this.x.redSub(this.z), s = e.x.redAdd(e.z), o = e.x.redSub(e.z), a = o.redMul(n), u = s.redMul(i), l = r.z.redMul(a.redAdd(u).redSqr()), d = r.x.redMul(a.redISub(u).redSqr());
  return this.curve.point(l, d);
};
Ln.prototype.mul = function(e) {
  for (var r = e.clone(), n = this, i = this.curve.point(null, null), s = this, o = []; r.cmpn(0) !== 0; r.iushrn(1))
    o.push(r.andln(1));
  for (var a = o.length - 1; a >= 0; a--)
    o[a] === 0 ? (n = n.diffAdd(i, s), i = i.dbl()) : (i = n.diffAdd(i, s), n = n.dbl());
  return i;
};
Ln.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Ln.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Ln.prototype.eq = function(e) {
  return this.getX().cmp(e.getX()) === 0;
};
Ln.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Ln.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var uq = Fi, Po = Ho, P8 = z0, J0 = G0, fq = uq.assert;
function io(t) {
  this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, J0.call(this, "edwards", t), this.a = new Po(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new Po(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new Po(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), fq(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
}
P8(io, J0);
var lq = io;
io.prototype._mulA = function(e) {
  return this.mOneA ? e.redNeg() : this.a.redMul(e);
};
io.prototype._mulC = function(e) {
  return this.oneC ? e : this.c.redMul(e);
};
io.prototype.jpoint = function(e, r, n, i) {
  return this.point(e, r, n, i);
};
io.prototype.pointFromX = function(e, r) {
  e = new Po(e, 16), e.red || (e = e.toRed(this.red));
  var n = e.redSqr(), i = this.c2.redSub(this.a.redMul(n)), s = this.one.redSub(this.c2.redMul(this.d).redMul(n)), o = i.redMul(s.redInvm()), a = o.redSqrt();
  if (a.redSqr().redSub(o).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var u = a.fromRed().isOdd();
  return (r && !u || !r && u) && (a = a.redNeg()), this.point(e, a);
};
io.prototype.pointFromY = function(e, r) {
  e = new Po(e, 16), e.red || (e = e.toRed(this.red));
  var n = e.redSqr(), i = n.redSub(this.c2), s = n.redMul(this.d).redMul(this.c2).redSub(this.a), o = i.redMul(s.redInvm());
  if (o.cmp(this.zero) === 0) {
    if (r)
      throw new Error("invalid point");
    return this.point(this.zero, e);
  }
  var a = o.redSqrt();
  if (a.redSqr().redSub(o).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return a.fromRed().isOdd() !== r && (a = a.redNeg()), this.point(a, e);
};
io.prototype.validate = function(e) {
  if (e.isInfinity())
    return !0;
  e.normalize();
  var r = e.x.redSqr(), n = e.y.redSqr(), i = r.redMul(this.a).redAdd(n), s = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(n)));
  return i.cmp(s) === 0;
};
function Hr(t, e, r, n, i) {
  J0.BasePoint.call(this, t, "projective"), e === null && r === null && n === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new Po(e, 16), this.y = new Po(r, 16), this.z = n ? new Po(n, 16) : this.curve.one, this.t = i && new Po(i, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
P8(Hr, J0.BasePoint);
io.prototype.pointFromJSON = function(e) {
  return Hr.fromJSON(this, e);
};
io.prototype.point = function(e, r, n, i) {
  return new Hr(this, e, r, n, i);
};
Hr.fromJSON = function(e, r) {
  return new Hr(e, r[0], r[1], r[2]);
};
Hr.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Hr.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Hr.prototype._extDbl = function() {
  var e = this.x.redSqr(), r = this.y.redSqr(), n = this.z.redSqr();
  n = n.redIAdd(n);
  var i = this.curve._mulA(e), s = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r), o = i.redAdd(r), a = o.redSub(n), u = i.redSub(r), l = s.redMul(a), d = o.redMul(u), p = s.redMul(u), w = a.redMul(o);
  return this.curve.point(l, d, w, p);
};
Hr.prototype._projDbl = function() {
  var e = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), n = this.y.redSqr(), i, s, o, a, u, l;
  if (this.curve.twisted) {
    a = this.curve._mulA(r);
    var d = a.redAdd(n);
    this.zOne ? (i = e.redSub(r).redSub(n).redMul(d.redSub(this.curve.two)), s = d.redMul(a.redSub(n)), o = d.redSqr().redSub(d).redSub(d)) : (u = this.z.redSqr(), l = d.redSub(u).redISub(u), i = e.redSub(r).redISub(n).redMul(l), s = d.redMul(a.redSub(n)), o = d.redMul(l));
  } else
    a = r.redAdd(n), u = this.curve._mulC(this.z).redSqr(), l = a.redSub(u).redSub(u), i = this.curve._mulC(e.redISub(a)).redMul(l), s = this.curve._mulC(a).redMul(r.redISub(n)), o = a.redMul(l);
  return this.curve.point(i, s, o);
};
Hr.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Hr.prototype._extAdd = function(e) {
  var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), n = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), i = this.t.redMul(this.curve.dd).redMul(e.t), s = this.z.redMul(e.z.redAdd(e.z)), o = n.redSub(r), a = s.redSub(i), u = s.redAdd(i), l = n.redAdd(r), d = o.redMul(a), p = u.redMul(l), w = o.redMul(l), A = a.redMul(u);
  return this.curve.point(d, p, A, w);
};
Hr.prototype._projAdd = function(e) {
  var r = this.z.redMul(e.z), n = r.redSqr(), i = this.x.redMul(e.x), s = this.y.redMul(e.y), o = this.curve.d.redMul(i).redMul(s), a = n.redSub(o), u = n.redAdd(o), l = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(i).redISub(s), d = r.redMul(a).redMul(l), p, w;
  return this.curve.twisted ? (p = r.redMul(u).redMul(s.redSub(this.curve._mulA(i))), w = a.redMul(u)) : (p = r.redMul(u).redMul(s.redSub(i)), w = this.curve._mulC(a).redMul(u)), this.curve.point(d, p, w);
};
Hr.prototype.add = function(e) {
  return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
};
Hr.prototype.mul = function(e) {
  return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
};
Hr.prototype.mulAdd = function(e, r, n) {
  return this.curve._wnafMulAdd(1, [this, r], [e, n], 2, !1);
};
Hr.prototype.jmulAdd = function(e, r, n) {
  return this.curve._wnafMulAdd(1, [this, r], [e, n], 2, !0);
};
Hr.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var e = this.z.redInvm();
  return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this;
};
Hr.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Hr.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
Hr.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
Hr.prototype.eq = function(e) {
  return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
};
Hr.prototype.eqXToP = function(e) {
  var r = e.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(r) === 0)
    return !0;
  for (var n = e.clone(), i = this.curve.redN.redMul(this.z); ; ) {
    if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0)
      return !1;
    if (r.redIAdd(i), this.x.cmp(r) === 0)
      return !0;
  }
};
Hr.prototype.toP = Hr.prototype.normalize;
Hr.prototype.mixedAdd = Hr.prototype.add;
(function(t) {
  var e = t;
  e.base = G0, e.short = oq, e.mont = cq, e.edwards = lq;
})(eb);
var X0 = {}, cm, Dx;
function hq() {
  return Dx || (Dx = 1, cm = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), cm;
}
(function(t) {
  var e = t, r = Vl, n = eb, i = Fi, s = i.assert;
  function o(l) {
    l.type === "short" ? this.curve = new n.short(l) : l.type === "edwards" ? this.curve = new n.edwards(l) : this.curve = new n.mont(l), this.g = this.curve.g, this.n = this.curve.n, this.hash = l.hash, s(this.g.validate(), "Invalid curve"), s(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  e.PresetCurve = o;
  function a(l, d) {
    Object.defineProperty(e, l, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var p = new o(d);
        return Object.defineProperty(e, l, {
          configurable: !0,
          enumerable: !0,
          value: p
        }), p;
      }
    });
  }
  a("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: r.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), a("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: r.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), a("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: r.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), a("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: r.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), a("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: r.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), a("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: r.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), a("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: r.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var u;
  try {
    u = hq();
  } catch {
    u = void 0;
  }
  a("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: r.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      u
    ]
  });
})(X0);
var dq = Vl, ac = Zv, M8 = wc;
function xa(t) {
  if (!(this instanceof xa))
    return new xa(t);
  this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var e = ac.toArray(t.entropy, t.entropyEnc || "hex"), r = ac.toArray(t.nonce, t.nonceEnc || "hex"), n = ac.toArray(t.pers, t.persEnc || "hex");
  M8(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(e, r, n);
}
var pq = xa;
xa.prototype._init = function(e, r, n) {
  var i = e.concat(r).concat(n);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var s = 0; s < this.V.length; s++)
    this.K[s] = 0, this.V[s] = 1;
  this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656;
};
xa.prototype._hmac = function() {
  return new dq.hmac(this.hash, this.K);
};
xa.prototype._update = function(e) {
  var r = this._hmac().update(this.V).update([0]);
  e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
xa.prototype.reseed = function(e, r, n, i) {
  typeof r != "string" && (i = n, n = r, r = null), e = ac.toArray(e, r), n = ac.toArray(n, i), M8(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(n || [])), this._reseed = 1;
};
xa.prototype.generate = function(e, r, n, i) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof r != "string" && (i = n, n = r, r = null), n && (n = ac.toArray(n, i || "hex"), this._update(n));
  for (var s = []; s.length < e; )
    this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
  var o = s.slice(0, e);
  return this._update(n), this._reseed++, ac.encode(o, r);
};
var gq = Ho, mq = Fi, P1 = mq.assert;
function Qn(t, e) {
  this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var vq = Qn;
Qn.fromPublic = function(e, r, n) {
  return r instanceof Qn ? r : new Qn(e, {
    pub: r,
    pubEnc: n
  });
};
Qn.fromPrivate = function(e, r, n) {
  return r instanceof Qn ? r : new Qn(e, {
    priv: r,
    privEnc: n
  });
};
Qn.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
Qn.prototype.getPublic = function(e, r) {
  return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
};
Qn.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
Qn.prototype._importPrivate = function(e, r) {
  this.priv = new gq(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
Qn.prototype._importPublic = function(e, r) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? P1(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && P1(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, r);
};
Qn.prototype.derive = function(e) {
  return e.validate() || P1(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
Qn.prototype.sign = function(e, r, n) {
  return this.ec.sign(e, this, r, n);
};
Qn.prototype.verify = function(e, r, n) {
  return this.ec.verify(e, r, this, void 0, n);
};
Qn.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var a0 = Ho, rb = Fi, bq = rb.assert;
function Z0(t, e) {
  if (t instanceof Z0)
    return t;
  this._importDER(t, e) || (bq(t.r && t.s, "Signature without r or s"), this.r = new a0(t.r, 16), this.s = new a0(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
}
var yq = Z0;
function wq() {
  this.place = 0;
}
function um(t, e) {
  var r = t[e.place++];
  if (!(r & 128))
    return r;
  var n = r & 15;
  if (n === 0 || n > 4 || t[e.place] === 0)
    return !1;
  for (var i = 0, s = 0, o = e.place; s < n; s++, o++)
    i <<= 8, i |= t[o], i >>>= 0;
  return i <= 127 ? !1 : (e.place = o, i);
}
function Ox(t) {
  for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r; )
    e++;
  return e === 0 ? t : t.slice(e);
}
Z0.prototype._importDER = function(e, r) {
  e = rb.toArray(e, r);
  var n = new wq();
  if (e[n.place++] !== 48)
    return !1;
  var i = um(e, n);
  if (i === !1 || i + n.place !== e.length || e[n.place++] !== 2)
    return !1;
  var s = um(e, n);
  if (s === !1 || e[n.place] & 128)
    return !1;
  var o = e.slice(n.place, s + n.place);
  if (n.place += s, e[n.place++] !== 2)
    return !1;
  var a = um(e, n);
  if (a === !1 || e.length !== a + n.place || e[n.place] & 128)
    return !1;
  var u = e.slice(n.place, a + n.place);
  if (o[0] === 0)
    if (o[1] & 128)
      o = o.slice(1);
    else
      return !1;
  if (u[0] === 0)
    if (u[1] & 128)
      u = u.slice(1);
    else
      return !1;
  return this.r = new a0(o), this.s = new a0(u), this.recoveryParam = null, !0;
};
function fm(t, e) {
  if (e < 128) {
    t.push(e);
    return;
  }
  var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
  for (t.push(r | 128); --r; )
    t.push(e >>> (r << 3) & 255);
  t.push(e);
}
Z0.prototype.toDER = function(e) {
  var r = this.r.toArray(), n = this.s.toArray();
  for (r[0] & 128 && (r = [0].concat(r)), n[0] & 128 && (n = [0].concat(n)), r = Ox(r), n = Ox(n); !n[0] && !(n[1] & 128); )
    n = n.slice(1);
  var i = [2];
  fm(i, r.length), i = i.concat(r), i.push(2), fm(i, n.length);
  var s = i.concat(n), o = [48];
  return fm(o, s.length), o = o.concat(s), rb.encode(o, e);
};
var Mo = Ho, I8 = pq, xq = Fi, lm = X0, _q = S8, C8 = xq.assert, nb = vq, Q0 = yq;
function ts(t) {
  if (!(this instanceof ts))
    return new ts(t);
  typeof t == "string" && (C8(
    Object.prototype.hasOwnProperty.call(lm, t),
    "Unknown curve " + t
  ), t = lm[t]), t instanceof lm.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
}
var Eq = ts;
ts.prototype.keyPair = function(e) {
  return new nb(this, e);
};
ts.prototype.keyFromPrivate = function(e, r) {
  return nb.fromPrivate(this, e, r);
};
ts.prototype.keyFromPublic = function(e, r) {
  return nb.fromPublic(this, e, r);
};
ts.prototype.genKeyPair = function(e) {
  e || (e = {});
  for (var r = new I8({
    hash: this.hash,
    pers: e.pers,
    persEnc: e.persEnc || "utf8",
    entropy: e.entropy || _q(this.hash.hmacStrength),
    entropyEnc: e.entropy && e.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), n = this.n.byteLength(), i = this.n.sub(new Mo(2)); ; ) {
    var s = new Mo(r.generate(n));
    if (!(s.cmp(i) > 0))
      return s.iaddn(1), this.keyFromPrivate(s);
  }
};
ts.prototype._truncateToN = function(e, r, n) {
  var i;
  if (Mo.isBN(e) || typeof e == "number")
    e = new Mo(e, 16), i = e.byteLength();
  else if (typeof e == "object")
    i = e.length, e = new Mo(e, 16);
  else {
    var s = e.toString();
    i = s.length + 1 >>> 1, e = new Mo(s, 16);
  }
  typeof n != "number" && (n = i * 8);
  var o = n - this.n.bitLength();
  return o > 0 && (e = e.ushrn(o)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
};
ts.prototype.sign = function(e, r, n, i) {
  typeof n == "object" && (i = n, n = null), i || (i = {}), r = this.keyFromPrivate(r, n), e = this._truncateToN(e, !1, i.msgBitLength);
  for (var s = this.n.byteLength(), o = r.getPrivate().toArray("be", s), a = e.toArray("be", s), u = new I8({
    hash: this.hash,
    entropy: o,
    nonce: a,
    pers: i.pers,
    persEnc: i.persEnc || "utf8"
  }), l = this.n.sub(new Mo(1)), d = 0; ; d++) {
    var p = i.k ? i.k(d) : new Mo(u.generate(this.n.byteLength()));
    if (p = this._truncateToN(p, !0), !(p.cmpn(1) <= 0 || p.cmp(l) >= 0)) {
      var w = this.g.mul(p);
      if (!w.isInfinity()) {
        var A = w.getX(), P = A.umod(this.n);
        if (P.cmpn(0) !== 0) {
          var N = p.invm(this.n).mul(P.mul(r.getPrivate()).iadd(e));
          if (N = N.umod(this.n), N.cmpn(0) !== 0) {
            var L = (w.getY().isOdd() ? 1 : 0) | (A.cmp(P) !== 0 ? 2 : 0);
            return i.canonical && N.cmp(this.nh) > 0 && (N = this.n.sub(N), L ^= 1), new Q0({ r: P, s: N, recoveryParam: L });
          }
        }
      }
    }
  }
};
ts.prototype.verify = function(e, r, n, i, s) {
  s || (s = {}), e = this._truncateToN(e, !1, s.msgBitLength), n = this.keyFromPublic(n, i), r = new Q0(r, "hex");
  var o = r.r, a = r.s;
  if (o.cmpn(1) < 0 || o.cmp(this.n) >= 0 || a.cmpn(1) < 0 || a.cmp(this.n) >= 0)
    return !1;
  var u = a.invm(this.n), l = u.mul(e).umod(this.n), d = u.mul(o).umod(this.n), p;
  return this.curve._maxwellTrick ? (p = this.g.jmulAdd(l, n.getPublic(), d), p.isInfinity() ? !1 : p.eqXToP(o)) : (p = this.g.mulAdd(l, n.getPublic(), d), p.isInfinity() ? !1 : p.getX().umod(this.n).cmp(o) === 0);
};
ts.prototype.recoverPubKey = function(t, e, r, n) {
  C8((3 & r) === r, "The recovery param is more than two bits"), e = new Q0(e, n);
  var i = this.n, s = new Mo(t), o = e.r, a = e.s, u = r & 1, l = r >> 1;
  if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && l)
    throw new Error("Unable to find sencond key candinate");
  l ? o = this.curve.pointFromX(o.add(this.curve.n), u) : o = this.curve.pointFromX(o, u);
  var d = e.r.invm(i), p = i.sub(s).mul(d).umod(i), w = a.mul(d).umod(i);
  return this.g.mulAdd(p, o, w);
};
ts.prototype.getKeyRecoveryParam = function(t, e, r, n) {
  if (e = new Q0(e, n), e.recoveryParam !== null)
    return e.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var s;
    try {
      s = this.recoverPubKey(t, e, i);
    } catch {
      continue;
    }
    if (s.eq(r))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var Xl = Fi, T8 = Xl.assert, Nx = Xl.parseBytes, Uu = Xl.cachedProperty;
function Nn(t, e) {
  this.eddsa = t, this._secret = Nx(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = Nx(e.pub);
}
Nn.fromPublic = function(e, r) {
  return r instanceof Nn ? r : new Nn(e, { pub: r });
};
Nn.fromSecret = function(e, r) {
  return r instanceof Nn ? r : new Nn(e, { secret: r });
};
Nn.prototype.secret = function() {
  return this._secret;
};
Uu(Nn, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
Uu(Nn, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
Uu(Nn, "privBytes", function() {
  var e = this.eddsa, r = this.hash(), n = e.encodingLength - 1, i = r.slice(0, e.encodingLength);
  return i[0] &= 248, i[n] &= 127, i[n] |= 64, i;
});
Uu(Nn, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
Uu(Nn, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
Uu(Nn, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
Nn.prototype.sign = function(e) {
  return T8(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
};
Nn.prototype.verify = function(e, r) {
  return this.eddsa.verify(e, r, this);
};
Nn.prototype.getSecret = function(e) {
  return T8(this._secret, "KeyPair is public only"), Xl.encode(this.secret(), e);
};
Nn.prototype.getPublic = function(e) {
  return Xl.encode(this.pubBytes(), e);
};
var Sq = Nn, Aq = Ho, ep = Fi, Lx = ep.assert, tp = ep.cachedProperty, Pq = ep.parseBytes;
function _c(t, e) {
  this.eddsa = t, typeof e != "object" && (e = Pq(e)), Array.isArray(e) && (Lx(e.length === t.encodingLength * 2, "Signature has invalid size"), e = {
    R: e.slice(0, t.encodingLength),
    S: e.slice(t.encodingLength)
  }), Lx(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof Aq && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
}
tp(_c, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
tp(_c, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
tp(_c, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
tp(_c, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
_c.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
_c.prototype.toHex = function() {
  return ep.encode(this.toBytes(), "hex").toUpperCase();
};
var Mq = _c, Iq = Vl, Cq = X0, Au = Fi, Tq = Au.assert, R8 = Au.parseBytes, D8 = Sq, kx = Mq;
function _i(t) {
  if (Tq(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof _i))
    return new _i(t);
  t = Cq[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = Iq.sha512;
}
var Rq = _i;
_i.prototype.sign = function(e, r) {
  e = R8(e);
  var n = this.keyFromSecret(r), i = this.hashInt(n.messagePrefix(), e), s = this.g.mul(i), o = this.encodePoint(s), a = this.hashInt(o, n.pubBytes(), e).mul(n.priv()), u = i.add(a).umod(this.curve.n);
  return this.makeSignature({ R: s, S: u, Rencoded: o });
};
_i.prototype.verify = function(e, r, n) {
  if (e = R8(e), r = this.makeSignature(r), r.S().gte(r.eddsa.curve.n) || r.S().isNeg())
    return !1;
  var i = this.keyFromPublic(n), s = this.hashInt(r.Rencoded(), i.pubBytes(), e), o = this.g.mul(r.S()), a = r.R().add(i.pub().mul(s));
  return a.eq(o);
};
_i.prototype.hashInt = function() {
  for (var e = this.hash(), r = 0; r < arguments.length; r++)
    e.update(arguments[r]);
  return Au.intFromLE(e.digest()).umod(this.curve.n);
};
_i.prototype.keyFromPublic = function(e) {
  return D8.fromPublic(this, e);
};
_i.prototype.keyFromSecret = function(e) {
  return D8.fromSecret(this, e);
};
_i.prototype.makeSignature = function(e) {
  return e instanceof kx ? e : new kx(this, e);
};
_i.prototype.encodePoint = function(e) {
  var r = e.getY().toArray("le", this.encodingLength);
  return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r;
};
_i.prototype.decodePoint = function(e) {
  e = Au.parseBytes(e);
  var r = e.length - 1, n = e.slice(0, r).concat(e[r] & -129), i = (e[r] & 128) !== 0, s = Au.intFromLE(n);
  return this.curve.pointFromY(s, i);
};
_i.prototype.encodeInt = function(e) {
  return e.toArray("le", this.encodingLength);
};
_i.prototype.decodeInt = function(e) {
  return Au.intFromLE(e);
};
_i.prototype.isPoint = function(e) {
  return e instanceof this.pointClass;
};
(function(t) {
  var e = t;
  e.version = rq.version, e.utils = Fi, e.rand = S8, e.curve = eb, e.curves = X0, e.ec = Eq, e.eddsa = Rq;
})(E8);
const Dq = { waku: { publish: "waku_publish", batchPublish: "waku_batchPublish", subscribe: "waku_subscribe", batchSubscribe: "waku_batchSubscribe", subscription: "waku_subscription", unsubscribe: "waku_unsubscribe", batchUnsubscribe: "waku_batchUnsubscribe", batchFetchMessages: "waku_batchFetchMessages" }, irn: { publish: "irn_publish", batchPublish: "irn_batchPublish", subscribe: "irn_subscribe", batchSubscribe: "irn_batchSubscribe", subscription: "irn_subscription", unsubscribe: "irn_unsubscribe", batchUnsubscribe: "irn_batchUnsubscribe", batchFetchMessages: "irn_batchFetchMessages" }, iridium: { publish: "iridium_publish", batchPublish: "iridium_batchPublish", subscribe: "iridium_subscribe", batchSubscribe: "iridium_batchSubscribe", subscription: "iridium_subscription", unsubscribe: "iridium_unsubscribe", batchUnsubscribe: "iridium_batchUnsubscribe", batchFetchMessages: "iridium_batchFetchMessages" } }, Oq = ":";
function hu(t) {
  const [e, r] = t.split(Oq);
  return { namespace: e, reference: r };
}
function O8(t, e) {
  return t.includes(":") ? [t] : e.chains || [];
}
var Nq = Object.defineProperty, $x = Object.getOwnPropertySymbols, Lq = Object.prototype.hasOwnProperty, kq = Object.prototype.propertyIsEnumerable, Bx = (t, e, r) => e in t ? Nq(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Fx = (t, e) => {
  for (var r in e || (e = {})) Lq.call(e, r) && Bx(t, r, e[r]);
  if ($x) for (var r of $x(e)) kq.call(e, r) && Bx(t, r, e[r]);
  return t;
};
const $q = "ReactNative", Di = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, Bq = "js";
function c0() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function qu() {
  return !Kl() && !!Fv() && navigator.product === $q;
}
function Zl() {
  return !c0() && !!Fv() && !!Kl();
}
function Ql() {
  return qu() ? Di.reactNative : c0() ? Di.node : Zl() ? Di.browser : Di.unknown;
}
function Fq() {
  var t;
  try {
    return qu() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (t = global.Application) == null ? void 0 : t.applicationId : void 0;
  } catch {
    return;
  }
}
function jq(t, e) {
  let r = xl.parse(t);
  return r = Fx(Fx({}, r), e), t = xl.stringify(r), t;
}
function N8() {
  return W4() || { name: "", description: "", url: "", icons: [""] };
}
function Uq() {
  if (Ql() === Di.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: r, Version: n } = global.Platform;
    return [r, n].join("-");
  }
  const t = QB();
  if (t === null) return "unknown";
  const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
  return t.type === "browser" ? [e, t.name, t.version].join("-") : [e, t.version].join("-");
}
function qq() {
  var t;
  const e = Ql();
  return e === Di.browser ? [e, ((t = z4()) == null ? void 0 : t.host) || "unknown"].join(":") : e;
}
function L8(t, e, r) {
  const n = Uq(), i = qq();
  return [[t, e].join("-"), [Bq, r].join("-"), n, i].join("/");
}
function zq({ protocol: t, version: e, relayUrl: r, sdkVersion: n, auth: i, projectId: s, useOnCloseEvent: o, bundleId: a }) {
  const u = r.split("?"), l = L8(t, e, n), d = { auth: i, ua: l, projectId: s, useOnCloseEvent: o, origin: a || void 0 }, p = jq(u[1] || "", d);
  return u[0] + "?" + p;
}
function nc(t, e) {
  return t.filter((r) => e.includes(r)).length === t.length;
}
function k8(t) {
  return Object.fromEntries(t.entries());
}
function $8(t) {
  return new Map(Object.entries(t));
}
function Ja(t = mt.FIVE_MINUTES, e) {
  const r = mt.toMiliseconds(t || mt.FIVE_MINUTES);
  let n, i, s;
  return { resolve: (o) => {
    s && n && (clearTimeout(s), n(o));
  }, reject: (o) => {
    s && i && (clearTimeout(s), i(o));
  }, done: () => new Promise((o, a) => {
    s = setTimeout(() => {
      a(new Error(e));
    }, r), n = o, i = a;
  }) };
}
function du(t, e, r) {
  return new Promise(async (n, i) => {
    const s = setTimeout(() => i(new Error(r)), e);
    try {
      const o = await t;
      n(o);
    } catch (o) {
      i(o);
    }
    clearTimeout(s);
  });
}
function B8(t, e) {
  if (typeof e == "string" && e.startsWith(`${t}:`)) return e;
  if (t.toLowerCase() === "topic") {
    if (typeof e != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (t.toLowerCase() === "id") {
    if (typeof e != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${t}`);
}
function Wq(t) {
  return B8("topic", t);
}
function Hq(t) {
  return B8("id", t);
}
function F8(t) {
  const [e, r] = t.split(":"), n = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof r == "string") n.topic = r;
  else if (e === "id" && Number.isInteger(Number(r))) n.id = Number(r);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${r}`);
  return n;
}
function En(t, e) {
  return mt.fromMiliseconds(Date.now() + mt.toMiliseconds(t));
}
function fa(t) {
  return Date.now() >= mt.toMiliseconds(t);
}
function br(t, e) {
  return `${t}${e ? `:${e}` : ""}`;
}
function Id(t = [], e = []) {
  return [.../* @__PURE__ */ new Set([...t, ...e])];
}
async function Kq({ id: t, topic: e, wcDeepLink: r }) {
  var n;
  try {
    if (!r) return;
    const i = typeof r == "string" ? JSON.parse(r) : r, s = i == null ? void 0 : i.href;
    if (typeof s != "string") return;
    const o = Vq(s, t, e), a = Ql();
    if (a === Di.browser) {
      if (!((n = Kl()) != null && n.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      o.startsWith("https://") || o.startsWith("http://") ? window.open(o, "_blank", "noreferrer noopener") : window.open(o, Yq() ? "_blank" : "_self", "noreferrer noopener");
    } else a === Di.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(o);
  } catch (i) {
    console.error(i);
  }
}
function Vq(t, e, r) {
  const n = `requestId=${e}&sessionTopic=${r}`;
  t.endsWith("/") && (t = t.slice(0, -1));
  let i = `${t}`;
  if (t.startsWith("https://t.me")) {
    const s = t.includes("?") ? "&startapp=" : "?startapp=";
    i = `${i}${s}${Jq(n, !0)}`;
  } else i = `${i}/wc?${n}`;
  return i;
}
async function Gq(t, e) {
  let r = "";
  try {
    if (Zl() && (r = localStorage.getItem(e), r)) return r;
    r = await t.getItem(e);
  } catch (n) {
    console.error(n);
  }
  return r;
}
function jx(t, e) {
  if (!t.includes(e)) return null;
  const r = t.split(/([&,?,=])/), n = r.indexOf(e);
  return r[n + 2];
}
function Ux() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t) => {
    const e = Math.random() * 16 | 0;
    return (t === "x" ? e : e & 3 | 8).toString(16);
  });
}
function ib() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function Yq() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function Jq(t, e = !1) {
  const r = Buffer.from(t).toString("base64");
  return e ? r.replace(/[=]/g, "") : r;
}
function j8(t) {
  return Buffer.from(t, "base64").toString("utf-8");
}
const Xq = "https://rpc.walletconnect.org/v1";
async function Zq(t, e, r, n, i, s) {
  switch (r.t) {
    case "eip191":
      return Qq(t, e, r.s);
    case "eip1271":
      return await ez(t, e, r.s, n, i, s);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${r.t}`);
  }
}
function Qq(t, e, r) {
  return IU(Y4(e), r).toLowerCase() === t.toLowerCase();
}
async function ez(t, e, r, n, i, s) {
  const o = hu(n);
  if (!o.namespace || !o.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${n}`);
  try {
    const a = "0x1626ba7e", u = "0000000000000000000000000000000000000000000000000000000000000040", l = "0000000000000000000000000000000000000000000000000000000000000041", d = r.substring(2), p = Y4(e).substring(2), w = a + p + u + l + d, A = await fetch(`${s || Xq}/?chainId=${n}&projectId=${i}`, { method: "POST", body: JSON.stringify({ id: tz(), jsonrpc: "2.0", method: "eth_call", params: [{ to: t, data: w }, "latest"] }) }), { result: P } = await A.json();
    return P ? P.slice(0, a.length).toLowerCase() === a.toLowerCase() : !1;
  } catch (a) {
    return console.error("isValidEip1271Signature: ", a), !1;
  }
}
function tz() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
var rz = Object.defineProperty, nz = Object.defineProperties, iz = Object.getOwnPropertyDescriptors, qx = Object.getOwnPropertySymbols, sz = Object.prototype.hasOwnProperty, oz = Object.prototype.propertyIsEnumerable, zx = (t, e, r) => e in t ? rz(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, az = (t, e) => {
  for (var r in e || (e = {})) sz.call(e, r) && zx(t, r, e[r]);
  if (qx) for (var r of qx(e)) oz.call(e, r) && zx(t, r, e[r]);
  return t;
}, cz = (t, e) => nz(t, iz(e));
const uz = "did:pkh:", sb = (t) => t == null ? void 0 : t.split(":"), fz = (t) => {
  const e = t && sb(t);
  if (e) return t.includes(uz) ? e[3] : e[1];
}, M1 = (t) => {
  const e = t && sb(t);
  if (e) return e[2] + ":" + e[3];
}, u0 = (t) => {
  const e = t && sb(t);
  if (e) return e.pop();
};
async function Wx(t) {
  const { cacao: e, projectId: r } = t, { s: n, p: i } = e, s = U8(i, i.iss), o = u0(i.iss);
  return await Zq(o, s, n, M1(i.iss), r);
}
const U8 = (t, e) => {
  const r = `${t.domain} wants you to sign in with your Ethereum account:`, n = u0(e);
  if (!t.aud && !t.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let i = t.statement || void 0;
  const s = `URI: ${t.aud || t.uri}`, o = `Version: ${t.version}`, a = `Chain ID: ${fz(e)}`, u = `Nonce: ${t.nonce}`, l = `Issued At: ${t.iat}`, d = t.exp ? `Expiration Time: ${t.exp}` : void 0, p = t.nbf ? `Not Before: ${t.nbf}` : void 0, w = t.requestId ? `Request ID: ${t.requestId}` : void 0, A = t.resources ? `Resources:${t.resources.map((N) => `
- ${N}`).join("")}` : void 0, P = Cd(t.resources);
  if (P) {
    const N = _l(P);
    i = yz(i, N);
  }
  return [r, n, "", i, "", s, o, a, u, l, d, p, w, A].filter((N) => N != null).join(`
`);
};
function lz(t) {
  return Buffer.from(JSON.stringify(t)).toString("base64");
}
function hz(t) {
  return JSON.parse(Buffer.from(t, "base64").toString("utf-8"));
}
function dc(t) {
  if (!t) throw new Error("No recap provided, value is undefined");
  if (!t.att) throw new Error("No `att` property found");
  const e = Object.keys(t.att);
  if (!(e != null && e.length)) throw new Error("No resources found in `att` property");
  e.forEach((r) => {
    const n = t.att[r];
    if (Array.isArray(n)) throw new Error(`Resource must be an object: ${r}`);
    if (typeof n != "object") throw new Error(`Resource must be an object: ${r}`);
    if (!Object.keys(n).length) throw new Error(`Resource object is empty: ${r}`);
    Object.keys(n).forEach((i) => {
      const s = n[i];
      if (!Array.isArray(s)) throw new Error(`Ability limits ${i} must be an array of objects, found: ${s}`);
      if (!s.length) throw new Error(`Value of ${i} is empty array, must be an array with objects`);
      s.forEach((o) => {
        if (typeof o != "object") throw new Error(`Ability limits (${i}) must be an array of objects, found: ${o}`);
      });
    });
  });
}
function dz(t, e, r, n = {}) {
  return r == null || r.sort((i, s) => i.localeCompare(s)), { att: { [t]: pz(e, r, n) } };
}
function pz(t, e, r = {}) {
  e = e == null ? void 0 : e.sort((i, s) => i.localeCompare(s));
  const n = e.map((i) => ({ [`${t}/${i}`]: [r] }));
  return Object.assign({}, ...n);
}
function q8(t) {
  return dc(t), `urn:recap:${lz(t).replace(/=/g, "")}`;
}
function _l(t) {
  const e = hz(t.replace("urn:recap:", ""));
  return dc(e), e;
}
function gz(t, e, r) {
  const n = dz(t, e, r);
  return q8(n);
}
function mz(t) {
  return t && t.includes("urn:recap:");
}
function vz(t, e) {
  const r = _l(t), n = _l(e), i = bz(r, n);
  return q8(i);
}
function bz(t, e) {
  dc(t), dc(e);
  const r = Object.keys(t.att).concat(Object.keys(e.att)).sort((i, s) => i.localeCompare(s)), n = { att: {} };
  return r.forEach((i) => {
    var s, o;
    Object.keys(((s = t.att) == null ? void 0 : s[i]) || {}).concat(Object.keys(((o = e.att) == null ? void 0 : o[i]) || {})).sort((a, u) => a.localeCompare(u)).forEach((a) => {
      var u, l;
      n.att[i] = cz(az({}, n.att[i]), { [a]: ((u = t.att[i]) == null ? void 0 : u[a]) || ((l = e.att[i]) == null ? void 0 : l[a]) });
    });
  }), n;
}
function yz(t = "", e) {
  dc(e);
  const r = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (t.includes(r)) return t;
  const n = [];
  let i = 0;
  Object.keys(e.att).forEach((a) => {
    const u = Object.keys(e.att[a]).map((p) => ({ ability: p.split("/")[0], action: p.split("/")[1] }));
    u.sort((p, w) => p.action.localeCompare(w.action));
    const l = {};
    u.forEach((p) => {
      l[p.ability] || (l[p.ability] = []), l[p.ability].push(p.action);
    });
    const d = Object.keys(l).map((p) => (i++, `(${i}) '${p}': '${l[p].join("', '")}' for '${a}'.`));
    n.push(d.join(", ").replace(".,", "."));
  });
  const s = n.join(" "), o = `${r}${s}`;
  return `${t ? t + " " : ""}${o}`;
}
function Hx(t) {
  var e;
  const r = _l(t);
  dc(r);
  const n = (e = r.att) == null ? void 0 : e.eip155;
  return n ? Object.keys(n).map((i) => i.split("/")[1]) : [];
}
function Kx(t) {
  const e = _l(t);
  dc(e);
  const r = [];
  return Object.values(e.att).forEach((n) => {
    Object.values(n).forEach((i) => {
      var s;
      (s = i == null ? void 0 : i[0]) != null && s.chains && r.push(i[0].chains);
    });
  }), [...new Set(r.flat())];
}
function Cd(t) {
  if (!t) return;
  const e = t == null ? void 0 : t[t.length - 1];
  return mz(e) ? e : void 0;
}
const z8 = "base10", ai = "base16", pa = "base64pad", Af = "base64url", eh = "utf8", W8 = 0, Ro = 1, th = 2, wz = 0, Vx = 1, qf = 12, ob = 32;
function xz() {
  const t = Jv.generateKeyPair();
  return { privateKey: On(t.secretKey, ai), publicKey: On(t.publicKey, ai) };
}
function I1() {
  const t = Ca.randomBytes(ob);
  return On(t, ai);
}
function _z(t, e) {
  const r = Jv.sharedKey(Rn(t, ai), Rn(e, ai), !0), n = new UU(Yl.SHA256, r).expand(ob);
  return On(n, ai);
}
function Td(t) {
  const e = Yl.hash(Rn(t, ai));
  return On(e, ai);
}
function Eo(t) {
  const e = Yl.hash(Rn(t, eh));
  return On(e, ai);
}
function H8(t) {
  return Rn(`${t}`, z8);
}
function pc(t) {
  return Number(On(t, z8));
}
function Ez(t) {
  const e = H8(typeof t.type < "u" ? t.type : W8);
  if (pc(e) === Ro && typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const r = typeof t.senderPublicKey < "u" ? Rn(t.senderPublicKey, ai) : void 0, n = typeof t.iv < "u" ? Rn(t.iv, ai) : Ca.randomBytes(qf), i = new Gv.ChaCha20Poly1305(Rn(t.symKey, ai)).seal(n, Rn(t.message, eh));
  return K8({ type: e, sealed: i, iv: n, senderPublicKey: r, encoding: t.encoding });
}
function Sz(t, e) {
  const r = H8(th), n = Ca.randomBytes(qf), i = Rn(t, eh);
  return K8({ type: r, sealed: i, iv: n, encoding: e });
}
function Az(t) {
  const e = new Gv.ChaCha20Poly1305(Rn(t.symKey, ai)), { sealed: r, iv: n } = El({ encoded: t.encoded, encoding: t == null ? void 0 : t.encoding }), i = e.open(n, r);
  if (i === null) throw new Error("Failed to decrypt");
  return On(i, eh);
}
function Pz(t, e) {
  const { sealed: r } = El({ encoded: t, encoding: e });
  return On(r, eh);
}
function K8(t) {
  const { encoding: e = pa } = t;
  if (pc(t.type) === th) return On(Sd([t.type, t.sealed]), e);
  if (pc(t.type) === Ro) {
    if (typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return On(Sd([t.type, t.senderPublicKey, t.iv, t.sealed]), e);
  }
  return On(Sd([t.type, t.iv, t.sealed]), e);
}
function El(t) {
  const { encoded: e, encoding: r = pa } = t, n = Rn(e, r), i = n.slice(wz, Vx), s = Vx;
  if (pc(i) === Ro) {
    const l = s + ob, d = l + qf, p = n.slice(s, l), w = n.slice(l, d), A = n.slice(d);
    return { type: i, sealed: A, iv: w, senderPublicKey: p };
  }
  if (pc(i) === th) {
    const l = n.slice(s), d = Ca.randomBytes(qf);
    return { type: i, sealed: l, iv: d };
  }
  const o = s + qf, a = n.slice(s, o), u = n.slice(o);
  return { type: i, sealed: u, iv: a };
}
function Mz(t, e) {
  const r = El({ encoded: t, encoding: e == null ? void 0 : e.encoding });
  return V8({ type: pc(r.type), senderPublicKey: typeof r.senderPublicKey < "u" ? On(r.senderPublicKey, ai) : void 0, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey });
}
function V8(t) {
  const e = (t == null ? void 0 : t.type) || W8;
  if (e === Ro) {
    if (typeof (t == null ? void 0 : t.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (t == null ? void 0 : t.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: t == null ? void 0 : t.senderPublicKey, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey };
}
function Gx(t) {
  return t.type === Ro && typeof t.senderPublicKey == "string" && typeof t.receiverPublicKey == "string";
}
function Yx(t) {
  return t.type === th;
}
function Iz(t) {
  return new E8.ec("p256").keyFromPublic({ x: Buffer.from(t.x, "base64").toString("hex"), y: Buffer.from(t.y, "base64").toString("hex") }, "hex");
}
function Cz(t) {
  let e = t.replace(/-/g, "+").replace(/_/g, "/");
  const r = e.length % 4;
  return r > 0 && (e += "=".repeat(4 - r)), e;
}
function Tz(t) {
  return Buffer.from(Cz(t), "base64");
}
function Rz(t, e) {
  const [r, n, i] = t.split("."), s = Tz(i);
  if (s.length !== 64) throw new Error("Invalid signature length");
  const o = s.slice(0, 32).toString("hex"), a = s.slice(32, 64).toString("hex"), u = `${r}.${n}`, l = new Yl.SHA256().update(Buffer.from(u)).digest(), d = Iz(e), p = Buffer.from(l).toString("hex");
  if (!d.verify(p, { r: o, s: a })) throw new Error("Invalid signature");
  return v1(t).payload;
}
const Dz = "irn";
function C1(t) {
  return (t == null ? void 0 : t.relay) || { protocol: Dz };
}
function Bf(t) {
  const e = Dq[t];
  if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${t}`);
  return e;
}
var Oz = Object.defineProperty, Nz = Object.defineProperties, Lz = Object.getOwnPropertyDescriptors, Jx = Object.getOwnPropertySymbols, kz = Object.prototype.hasOwnProperty, $z = Object.prototype.propertyIsEnumerable, Xx = (t, e, r) => e in t ? Oz(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Zx = (t, e) => {
  for (var r in e || (e = {})) kz.call(e, r) && Xx(t, r, e[r]);
  if (Jx) for (var r of Jx(e)) $z.call(e, r) && Xx(t, r, e[r]);
  return t;
}, Bz = (t, e) => Nz(t, Lz(e));
function Fz(t, e = "-") {
  const r = {}, n = "relay" + e;
  return Object.keys(t).forEach((i) => {
    if (i.startsWith(n)) {
      const s = i.replace(n, ""), o = t[i];
      r[s] = o;
    }
  }), r;
}
function Qx(t) {
  if (!t.includes("wc:")) {
    const u = j8(t);
    u != null && u.includes("wc:") && (t = u);
  }
  t = t.includes("wc://") ? t.replace("wc://", "") : t, t = t.includes("wc:") ? t.replace("wc:", "") : t;
  const e = t.indexOf(":"), r = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0, n = t.substring(0, e), i = t.substring(e + 1, r).split("@"), s = typeof r < "u" ? t.substring(r) : "", o = xl.parse(s), a = typeof o.methods == "string" ? o.methods.split(",") : void 0;
  return { protocol: n, topic: jz(i[0]), version: parseInt(i[1], 10), symKey: o.symKey, relay: Fz(o), methods: a, expiryTimestamp: o.expiryTimestamp ? parseInt(o.expiryTimestamp, 10) : void 0 };
}
function jz(t) {
  return t.startsWith("//") ? t.substring(2) : t;
}
function Uz(t, e = "-") {
  const r = "relay", n = {};
  return Object.keys(t).forEach((i) => {
    const s = r + e + i;
    t[i] && (n[s] = t[i]);
  }), n;
}
function e3(t) {
  return `${t.protocol}:${t.topic}@${t.version}?` + xl.stringify(Zx(Bz(Zx({ symKey: t.symKey }, Uz(t.relay)), { expiryTimestamp: t.expiryTimestamp }), t.methods ? { methods: t.methods.join(",") } : {}));
}
function fd(t, e, r) {
  return `${t}?wc_ev=${r}&topic=${e}`;
}
function zu(t) {
  const e = [];
  return t.forEach((r) => {
    const [n, i] = r.split(":");
    e.push(`${n}:${i}`);
  }), e;
}
function qz(t) {
  const e = [];
  return Object.values(t).forEach((r) => {
    e.push(...zu(r.accounts));
  }), e;
}
function zz(t, e) {
  const r = [];
  return Object.values(t).forEach((n) => {
    zu(n.accounts).includes(e) && r.push(...n.methods);
  }), r;
}
function Wz(t, e) {
  const r = [];
  return Object.values(t).forEach((n) => {
    zu(n.accounts).includes(e) && r.push(...n.events);
  }), r;
}
function ab(t) {
  return t.includes(":");
}
function Ff(t) {
  return ab(t) ? t.split(":")[0] : t;
}
function Hz(t) {
  const e = {};
  return t == null || t.forEach((r) => {
    const [n, i] = r.split(":");
    e[n] || (e[n] = { accounts: [], chains: [], events: [] }), e[n].accounts.push(r), e[n].chains.push(`${n}:${i}`);
  }), e;
}
function t3(t, e) {
  e = e.map((n) => n.replace("did:pkh:", ""));
  const r = Hz(e);
  for (const [n, i] of Object.entries(r)) i.methods ? i.methods = Id(i.methods, t) : i.methods = t, i.events = ["chainChanged", "accountsChanged"];
  return r;
}
const Kz = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, Vz = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function ft(t, e) {
  const { message: r, code: n } = Vz[t];
  return { message: e ? `${r} ${e}` : r, code: n };
}
function Or(t, e) {
  const { message: r, code: n } = Kz[t];
  return { message: e ? `${r} ${e}` : r, code: n };
}
function gc(t, e) {
  return !!Array.isArray(t);
}
function Sl(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;
}
function mi(t) {
  return typeof t > "u";
}
function dn(t, e) {
  return e && mi(t) ? !0 : typeof t == "string" && !!t.trim().length;
}
function cb(t, e) {
  return typeof t == "number" && !isNaN(t);
}
function Gz(t, e) {
  const { requiredNamespaces: r } = e, n = Object.keys(t.namespaces), i = Object.keys(r);
  let s = !0;
  return nc(i, n) ? (n.forEach((o) => {
    const { accounts: a, methods: u, events: l } = t.namespaces[o], d = zu(a), p = r[o];
    (!nc(O8(o, p), d) || !nc(p.methods, u) || !nc(p.events, l)) && (s = !1);
  }), s) : !1;
}
function f0(t) {
  return dn(t, !1) && t.includes(":") ? t.split(":").length === 2 : !1;
}
function Yz(t) {
  if (dn(t, !1) && t.includes(":")) {
    const e = t.split(":");
    if (e.length === 3) {
      const r = e[0] + ":" + e[1];
      return !!e[2] && f0(r);
    }
  }
  return !1;
}
function Jz(t) {
  function e(r) {
    try {
      return typeof new URL(r) < "u";
    } catch {
      return !1;
    }
  }
  try {
    if (dn(t, !1)) {
      if (e(t)) return !0;
      const r = j8(t);
      return e(r);
    }
  } catch {
  }
  return !1;
}
function Xz(t) {
  var e;
  return (e = t == null ? void 0 : t.proposer) == null ? void 0 : e.publicKey;
}
function Zz(t) {
  return t == null ? void 0 : t.topic;
}
function Qz(t, e) {
  let r = null;
  return dn(t == null ? void 0 : t.publicKey, !1) || (r = ft("MISSING_OR_INVALID", `${e} controller public key should be a string`)), r;
}
function r3(t) {
  let e = !0;
  return gc(t) ? t.length && (e = t.every((r) => dn(r, !1))) : e = !1, e;
}
function eW(t, e, r) {
  let n = null;
  return gc(e) && e.length ? e.forEach((i) => {
    n || f0(i) || (n = Or("UNSUPPORTED_CHAINS", `${r}, chain ${i} should be a string and conform to "namespace:chainId" format`));
  }) : f0(t) || (n = Or("UNSUPPORTED_CHAINS", `${r}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), n;
}
function tW(t, e, r) {
  let n = null;
  return Object.entries(t).forEach(([i, s]) => {
    if (n) return;
    const o = eW(i, O8(i, s), `${e} ${r}`);
    o && (n = o);
  }), n;
}
function rW(t, e) {
  let r = null;
  return gc(t) ? t.forEach((n) => {
    r || Yz(n) || (r = Or("UNSUPPORTED_ACCOUNTS", `${e}, account ${n} should be a string and conform to "namespace:chainId:address" format`));
  }) : r = Or("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), r;
}
function nW(t, e) {
  let r = null;
  return Object.values(t).forEach((n) => {
    if (r) return;
    const i = rW(n == null ? void 0 : n.accounts, `${e} namespace`);
    i && (r = i);
  }), r;
}
function iW(t, e) {
  let r = null;
  return r3(t == null ? void 0 : t.methods) ? r3(t == null ? void 0 : t.events) || (r = Or("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : r = Or("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), r;
}
function G8(t, e) {
  let r = null;
  return Object.values(t).forEach((n) => {
    if (r) return;
    const i = iW(n, `${e}, namespace`);
    i && (r = i);
  }), r;
}
function sW(t, e, r) {
  let n = null;
  if (t && Sl(t)) {
    const i = G8(t, e);
    i && (n = i);
    const s = tW(t, e, r);
    s && (n = s);
  } else n = ft("MISSING_OR_INVALID", `${e}, ${r} should be an object with data`);
  return n;
}
function hm(t, e) {
  let r = null;
  if (t && Sl(t)) {
    const n = G8(t, e);
    n && (r = n);
    const i = nW(t, e);
    i && (r = i);
  } else r = ft("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return r;
}
function Y8(t) {
  return dn(t.protocol, !0);
}
function oW(t, e) {
  let r = !1;
  return t ? t && gc(t) && t.length && t.forEach((n) => {
    r = Y8(n);
  }) : r = !0, r;
}
function aW(t) {
  return typeof t == "number";
}
function gi(t) {
  return typeof t < "u" && typeof t !== null;
}
function cW(t) {
  return !(!t || typeof t != "object" || !t.code || !cb(t.code) || !t.message || !dn(t.message, !1));
}
function uW(t) {
  return !(mi(t) || !dn(t.method, !1));
}
function fW(t) {
  return !(mi(t) || mi(t.result) && mi(t.error) || !cb(t.id) || !dn(t.jsonrpc, !1));
}
function lW(t) {
  return !(mi(t) || !dn(t.name, !1));
}
function n3(t, e) {
  return !(!f0(e) || !qz(t).includes(e));
}
function hW(t, e, r) {
  return dn(r, !1) ? zz(t, e).includes(r) : !1;
}
function dW(t, e, r) {
  return dn(r, !1) ? Wz(t, e).includes(r) : !1;
}
function i3(t, e, r) {
  let n = null;
  const i = pW(t), s = gW(e), o = Object.keys(i), a = Object.keys(s), u = s3(Object.keys(t)), l = s3(Object.keys(e)), d = u.filter((p) => !l.includes(p));
  return d.length && (n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces keys don't satisfy requiredNamespaces.
      Required: ${d.toString()}
      Received: ${Object.keys(e).toString()}`)), nc(o, a) || (n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces chains don't satisfy required namespaces.
      Required: ${o.toString()}
      Approved: ${a.toString()}`)), Object.keys(e).forEach((p) => {
    if (!p.includes(":") || n) return;
    const w = zu(e[p].accounts);
    w.includes(p) || (n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces accounts don't satisfy namespace accounts for ${p}
        Required: ${p}
        Approved: ${w.toString()}`));
  }), o.forEach((p) => {
    n || (nc(i[p].methods, s[p].methods) ? nc(i[p].events, s[p].events) || (n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces events don't satisfy namespace events for ${p}`)) : n = ft("NON_CONFORMING_NAMESPACES", `${r} namespaces methods don't satisfy namespace methods for ${p}`));
  }), n;
}
function pW(t) {
  const e = {};
  return Object.keys(t).forEach((r) => {
    var n;
    r.includes(":") ? e[r] = t[r] : (n = t[r].chains) == null || n.forEach((i) => {
      e[i] = { methods: t[r].methods, events: t[r].events };
    });
  }), e;
}
function s3(t) {
  return [...new Set(t.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function gW(t) {
  const e = {};
  return Object.keys(t).forEach((r) => {
    if (r.includes(":")) e[r] = t[r];
    else {
      const n = zu(t[r].accounts);
      n == null || n.forEach((i) => {
        e[i] = { accounts: t[r].accounts.filter((s) => s.includes(`${i}:`)), methods: t[r].methods, events: t[r].events };
      });
    }
  }), e;
}
function mW(t, e) {
  return cb(t) && t <= e.max && t >= e.min;
}
function o3() {
  const t = Ql();
  return new Promise((e) => {
    switch (t) {
      case Di.browser:
        e(vW());
        break;
      case Di.reactNative:
        e(bW());
        break;
      case Di.node:
        e(yW());
        break;
      default:
        e(!0);
    }
  });
}
function vW() {
  return Zl() && (navigator == null ? void 0 : navigator.onLine);
}
async function bW() {
  if (qu() && typeof global < "u" && global != null && global.NetInfo) {
    const t = await (global == null ? void 0 : global.NetInfo.fetch());
    return t == null ? void 0 : t.isConnected;
  }
  return !0;
}
function yW() {
  return !0;
}
function wW(t) {
  switch (Ql()) {
    case Di.browser:
      xW(t);
      break;
    case Di.reactNative:
      _W(t);
      break;
  }
}
function xW(t) {
  !qu() && Zl() && (window.addEventListener("online", () => t(!0)), window.addEventListener("offline", () => t(!1)));
}
function _W(t) {
  qu() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener((e) => t(e == null ? void 0 : e.isConnected)));
}
const dm = {};
class Pf {
  static get(e) {
    return dm[e];
  }
  static set(e, r) {
    dm[e] = r;
  }
  static delete(e) {
    delete dm[e];
  }
}
const EW = "PARSE_ERROR", SW = "INVALID_REQUEST", AW = "METHOD_NOT_FOUND", PW = "INVALID_PARAMS", J8 = "INTERNAL_ERROR", ub = "SERVER_ERROR", MW = [-32700, -32600, -32601, -32602, -32603], zf = {
  [EW]: { code: -32700, message: "Parse error" },
  [SW]: { code: -32600, message: "Invalid Request" },
  [AW]: { code: -32601, message: "Method not found" },
  [PW]: { code: -32602, message: "Invalid params" },
  [J8]: { code: -32603, message: "Internal error" },
  [ub]: { code: -32e3, message: "Server error" }
}, X8 = ub;
function IW(t) {
  return MW.includes(t);
}
function a3(t) {
  return Object.keys(zf).includes(t) ? zf[t] : zf[X8];
}
function CW(t) {
  const e = Object.values(zf).find((r) => r.code === t);
  return e || zf[X8];
}
function Z8(t, e, r) {
  return t.message.includes("getaddrinfo ENOTFOUND") || t.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${r} RPC url at ${e}`) : t;
}
var Q8 = {}, bo = {}, c3;
function TW() {
  if (c3) return bo;
  c3 = 1, Object.defineProperty(bo, "__esModule", { value: !0 }), bo.isBrowserCryptoAvailable = bo.getSubtleCrypto = bo.getBrowerCrypto = void 0;
  function t() {
    return (gn == null ? void 0 : gn.crypto) || (gn == null ? void 0 : gn.msCrypto) || {};
  }
  bo.getBrowerCrypto = t;
  function e() {
    const n = t();
    return n.subtle || n.webkitSubtle;
  }
  bo.getSubtleCrypto = e;
  function r() {
    return !!t() && !!e();
  }
  return bo.isBrowserCryptoAvailable = r, bo;
}
var yo = {}, u3;
function RW() {
  if (u3) return yo;
  u3 = 1, Object.defineProperty(yo, "__esModule", { value: !0 }), yo.isBrowser = yo.isNode = yo.isReactNative = void 0;
  function t() {
    return typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative";
  }
  yo.isReactNative = t;
  function e() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
  }
  yo.isNode = e;
  function r() {
    return !t() && !e();
  }
  return yo.isBrowser = r, yo;
}
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  const e = jl;
  e.__exportStar(TW(), t), e.__exportStar(RW(), t);
})(Q8);
function la(t = 3) {
  const e = Date.now() * Math.pow(10, t), r = Math.floor(Math.random() * Math.pow(10, t));
  return e + r;
}
function ic(t = 6) {
  return BigInt(la(t));
}
function ga(t, e, r) {
  return {
    id: r || la(),
    jsonrpc: "2.0",
    method: t,
    params: e
  };
}
function rp(t, e) {
  return {
    id: t,
    jsonrpc: "2.0",
    result: e
  };
}
function np(t, e, r) {
  return {
    id: t,
    jsonrpc: "2.0",
    error: DW(e)
  };
}
function DW(t, e) {
  return typeof t > "u" ? a3(J8) : (typeof t == "string" && (t = Object.assign(Object.assign({}, a3(ub)), { message: t })), IW(t.code) && (t = CW(t.code)), t);
}
let OW = class {
}, NW = class extends OW {
  constructor() {
    super();
  }
}, LW = class extends NW {
  constructor(e) {
    super();
  }
};
const kW = "^https?:", $W = "^wss?:";
function BW(t) {
  const e = t.match(new RegExp(/^\w+:/, "gi"));
  if (!(!e || !e.length))
    return e[0];
}
function eE(t, e) {
  const r = BW(t);
  return typeof r > "u" ? !1 : new RegExp(e).test(r);
}
function f3(t) {
  return eE(t, kW);
}
function l3(t) {
  return eE(t, $W);
}
function FW(t) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(t);
}
function tE(t) {
  return typeof t == "object" && "id" in t && "jsonrpc" in t && t.jsonrpc === "2.0";
}
function fb(t) {
  return tE(t) && "method" in t;
}
function ip(t) {
  return tE(t) && (js(t) || Qi(t));
}
function js(t) {
  return "result" in t;
}
function Qi(t) {
  return "error" in t;
}
let cs = class extends LW {
  constructor(e) {
    super(e), this.events = new ns.EventEmitter(), this.hasRegisteredEventListeners = !1, this.connection = this.setConnection(e), this.connection.connected && this.registerEventListeners();
  }
  async connect(e = this.connection) {
    await this.open(e);
  }
  async disconnect() {
    await this.close();
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async request(e, r) {
    return this.requestStrict(ga(e.method, e.params || [], e.id || ic().toString()), r);
  }
  async requestStrict(e, r) {
    return new Promise(async (n, i) => {
      if (!this.connection.connected) try {
        await this.open();
      } catch (s) {
        i(s);
      }
      this.events.on(`${e.id}`, (s) => {
        Qi(s) ? i(s.error) : n(s.result);
      });
      try {
        await this.connection.send(e, r);
      } catch (s) {
        i(s);
      }
    });
  }
  setConnection(e = this.connection) {
    return e;
  }
  onPayload(e) {
    this.events.emit("payload", e), ip(e) ? this.events.emit(`${e.id}`, e) : this.events.emit("message", { type: e.method, data: e.params });
  }
  onClose(e) {
    e && e.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${e.code} ${e.reason ? `(${e.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(e = this.connection) {
    this.connection === e && this.connection.connected || (this.connection.connected && this.close(), typeof e == "string" && (await this.connection.open(e), e = this.connection), this.connection = this.setConnection(e), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (e) => this.onPayload(e)), this.connection.on("close", (e) => this.onClose(e)), this.connection.on("error", (e) => this.events.emit("error", e)), this.connection.on("register_error", (e) => this.onClose()), this.hasRegisteredEventListeners = !0);
  }
};
const jW = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require("ws"), UW = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u", h3 = (t) => t.split("?")[0], d3 = 10, qW = jW();
let zW = class {
  constructor(e) {
    if (this.url = e, this.events = new ns.EventEmitter(), this.registering = !1, !l3(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    this.url = e;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    return new Promise((e, r) => {
      if (typeof this.socket > "u") {
        r(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n) => {
        this.onClose(n), e();
      }, this.socket.close();
    });
  }
  async send(e) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(Bo(e));
    } catch (r) {
      this.onError(e.id, r);
    }
  }
  register(e = this.url) {
    if (!l3(e)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e}`);
    if (this.registering) {
      const r = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= r || this.events.listenerCount("open") >= r) && this.events.setMaxListeners(r + 1), new Promise((n, i) => {
        this.events.once("register_error", (s) => {
          this.resetMaxListeners(), i(s);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return i(new Error("WebSocket connection is missing or invalid"));
          n(this.socket);
        });
      });
    }
    return this.url = e, this.registering = !0, new Promise((r, n) => {
      const i = new URLSearchParams(e).get("origin"), s = Q8.isReactNative() ? { headers: { origin: i } } : { rejectUnauthorized: !FW(e) }, o = new qW(e, [], s);
      UW() ? o.onerror = (a) => {
        const u = a;
        n(this.emitError(u.error));
      } : o.on("error", (a) => {
        n(this.emitError(a));
      }), o.onopen = () => {
        this.onOpen(o), r(o);
      };
    });
  }
  onOpen(e) {
    e.onmessage = (r) => this.onPayload(r), e.onclose = (r) => this.onClose(r), this.socket = e, this.registering = !1, this.events.emit("open");
  }
  onClose(e) {
    this.socket = void 0, this.registering = !1, this.events.emit("close", e);
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const r = typeof e.data == "string" ? lc(e.data) : e.data;
    this.events.emit("payload", r);
  }
  onError(e, r) {
    const n = this.parseError(r), i = n.message || n.toString(), s = np(e, i);
    this.events.emit("payload", s);
  }
  parseError(e, r = this.url) {
    return Z8(e, h3(r), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > d3 && this.events.setMaxListeners(d3);
  }
  emitError(e) {
    const r = this.parseError(new Error((e == null ? void 0 : e.message) || `WebSocket connection failed for host: ${h3(this.url)}`));
    return this.events.emit("register_error", r), r;
  }
};
var l0 = { exports: {} };
l0.exports;
(function(t, e) {
  var r = 200, n = "__lodash_hash_undefined__", i = 1, s = 2, o = 9007199254740991, a = "[object Arguments]", u = "[object Array]", l = "[object AsyncFunction]", d = "[object Boolean]", p = "[object Date]", w = "[object Error]", A = "[object Function]", P = "[object GeneratorFunction]", N = "[object Map]", L = "[object Number]", $ = "[object Null]", B = "[object Object]", H = "[object Promise]", W = "[object Proxy]", V = "[object RegExp]", te = "[object Set]", R = "[object String]", K = "[object Symbol]", ge = "[object Undefined]", Ee = "[object WeakMap]", Y = "[object ArrayBuffer]", S = "[object DataView]", m = "[object Float32Array]", f = "[object Float64Array]", g = "[object Int8Array]", b = "[object Int16Array]", x = "[object Int32Array]", _ = "[object Uint8Array]", E = "[object Uint8ClampedArray]", v = "[object Uint16Array]", M = "[object Uint32Array]", I = /[\\^$.*+?()[\]{}|]/g, F = /^\[object .+?Constructor\]$/, ce = /^(?:0|[1-9]\d*)$/, D = {};
  D[m] = D[f] = D[g] = D[b] = D[x] = D[_] = D[E] = D[v] = D[M] = !0, D[a] = D[u] = D[Y] = D[d] = D[S] = D[p] = D[w] = D[A] = D[N] = D[L] = D[B] = D[V] = D[te] = D[R] = D[Ee] = !1;
  var oe = typeof gn == "object" && gn && gn.Object === Object && gn, Z = typeof self == "object" && self && self.Object === Object && self, J = oe || Z || Function("return this")(), Q = e && !e.nodeType && e, T = Q && !0 && t && !t.nodeType && t, X = T && T.exports === Q, re = X && oe.process, pe = function() {
    try {
      return re && re.binding && re.binding("util");
    } catch {
    }
  }(), ie = pe && pe.isTypedArray;
  function ue(ae, ye) {
    for (var Ge = -1, Pt = ae == null ? 0 : ae.length, jr = 0, nr = []; ++Ge < Pt; ) {
      var Kr = ae[Ge];
      ye(Kr, Ge, ae) && (nr[jr++] = Kr);
    }
    return nr;
  }
  function ve(ae, ye) {
    for (var Ge = -1, Pt = ye.length, jr = ae.length; ++Ge < Pt; )
      ae[jr + Ge] = ye[Ge];
    return ae;
  }
  function Pe(ae, ye) {
    for (var Ge = -1, Pt = ae == null ? 0 : ae.length; ++Ge < Pt; )
      if (ye(ae[Ge], Ge, ae))
        return !0;
    return !1;
  }
  function De(ae, ye) {
    for (var Ge = -1, Pt = Array(ae); ++Ge < ae; )
      Pt[Ge] = ye(Ge);
    return Pt;
  }
  function Ce(ae) {
    return function(ye) {
      return ae(ye);
    };
  }
  function $e(ae, ye) {
    return ae.has(ye);
  }
  function Me(ae, ye) {
    return ae == null ? void 0 : ae[ye];
  }
  function Ne(ae) {
    var ye = -1, Ge = Array(ae.size);
    return ae.forEach(function(Pt, jr) {
      Ge[++ye] = [jr, Pt];
    }), Ge;
  }
  function Ke(ae, ye) {
    return function(Ge) {
      return ae(ye(Ge));
    };
  }
  function Le(ae) {
    var ye = -1, Ge = Array(ae.size);
    return ae.forEach(function(Pt) {
      Ge[++ye] = Pt;
    }), Ge;
  }
  var qe = Array.prototype, ze = Function.prototype, _e = Object.prototype, Ze = J["__core-js_shared__"], at = ze.toString, ke = _e.hasOwnProperty, Qe = function() {
    var ae = /[^.]+$/.exec(Ze && Ze.keys && Ze.keys.IE_PROTO || "");
    return ae ? "Symbol(src)_1." + ae : "";
  }(), tt = _e.toString, Ye = RegExp(
    "^" + at.call(ke).replace(I, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), dt = X ? J.Buffer : void 0, lt = J.Symbol, ct = J.Uint8Array, qt = _e.propertyIsEnumerable, Jt = qe.splice, Et = lt ? lt.toStringTag : void 0, er = Object.getOwnPropertySymbols, Xt = dt ? dt.isBuffer : void 0, Dt = Ke(Object.keys, Object), kt = yr(J, "DataView"), Ct = yr(J, "Map"), gt = yr(J, "Promise"), Rt = yr(J, "Set"), Nt = yr(J, "WeakMap"), vt = yr(Object, "create"), $t = oo(kt), Ft = oo(Ct), rt = oo(gt), Bt = oo(Rt), k = oo(Nt), U = lt ? lt.prototype : void 0, z = U ? U.valueOf : void 0;
  function C(ae) {
    var ye = -1, Ge = ae == null ? 0 : ae.length;
    for (this.clear(); ++ye < Ge; ) {
      var Pt = ae[ye];
      this.set(Pt[0], Pt[1]);
    }
  }
  function G() {
    this.__data__ = vt ? vt(null) : {}, this.size = 0;
  }
  function j(ae) {
    var ye = this.has(ae) && delete this.__data__[ae];
    return this.size -= ye ? 1 : 0, ye;
  }
  function se(ae) {
    var ye = this.__data__;
    if (vt) {
      var Ge = ye[ae];
      return Ge === n ? void 0 : Ge;
    }
    return ke.call(ye, ae) ? ye[ae] : void 0;
  }
  function de(ae) {
    var ye = this.__data__;
    return vt ? ye[ae] !== void 0 : ke.call(ye, ae);
  }
  function xe(ae, ye) {
    var Ge = this.__data__;
    return this.size += this.has(ae) ? 0 : 1, Ge[ae] = vt && ye === void 0 ? n : ye, this;
  }
  C.prototype.clear = G, C.prototype.delete = j, C.prototype.get = se, C.prototype.has = de, C.prototype.set = xe;
  function Te(ae) {
    var ye = -1, Ge = ae == null ? 0 : ae.length;
    for (this.clear(); ++ye < Ge; ) {
      var Pt = ae[ye];
      this.set(Pt[0], Pt[1]);
    }
  }
  function Re() {
    this.__data__ = [], this.size = 0;
  }
  function nt(ae) {
    var ye = this.__data__, Ge = Je(ye, ae);
    if (Ge < 0)
      return !1;
    var Pt = ye.length - 1;
    return Ge == Pt ? ye.pop() : Jt.call(ye, Ge, 1), --this.size, !0;
  }
  function je(ae) {
    var ye = this.__data__, Ge = Je(ye, ae);
    return Ge < 0 ? void 0 : ye[Ge][1];
  }
  function pt(ae) {
    return Je(this.__data__, ae) > -1;
  }
  function it(ae, ye) {
    var Ge = this.__data__, Pt = Je(Ge, ae);
    return Pt < 0 ? (++this.size, Ge.push([ae, ye])) : Ge[Pt][1] = ye, this;
  }
  Te.prototype.clear = Re, Te.prototype.delete = nt, Te.prototype.get = je, Te.prototype.has = pt, Te.prototype.set = it;
  function et(ae) {
    var ye = -1, Ge = ae == null ? 0 : ae.length;
    for (this.clear(); ++ye < Ge; ) {
      var Pt = ae[ye];
      this.set(Pt[0], Pt[1]);
    }
  }
  function St() {
    this.size = 0, this.__data__ = {
      hash: new C(),
      map: new (Ct || Te)(),
      string: new C()
    };
  }
  function Tt(ae) {
    var ye = mr(this, ae).delete(ae);
    return this.size -= ye ? 1 : 0, ye;
  }
  function At(ae) {
    return mr(this, ae).get(ae);
  }
  function _t(ae) {
    return mr(this, ae).has(ae);
  }
  function ht(ae, ye) {
    var Ge = mr(this, ae), Pt = Ge.size;
    return Ge.set(ae, ye), this.size += Ge.size == Pt ? 0 : 1, this;
  }
  et.prototype.clear = St, et.prototype.delete = Tt, et.prototype.get = At, et.prototype.has = _t, et.prototype.set = ht;
  function xt(ae) {
    var ye = -1, Ge = ae == null ? 0 : ae.length;
    for (this.__data__ = new et(); ++ye < Ge; )
      this.add(ae[ye]);
  }
  function st(ae) {
    return this.__data__.set(ae, n), this;
  }
  function bt(ae) {
    return this.__data__.has(ae);
  }
  xt.prototype.add = xt.prototype.push = st, xt.prototype.has = bt;
  function ut(ae) {
    var ye = this.__data__ = new Te(ae);
    this.size = ye.size;
  }
  function ot() {
    this.__data__ = new Te(), this.size = 0;
  }
  function Se(ae) {
    var ye = this.__data__, Ge = ye.delete(ae);
    return this.size = ye.size, Ge;
  }
  function Ae(ae) {
    return this.__data__.get(ae);
  }
  function Ve(ae) {
    return this.__data__.has(ae);
  }
  function Fe(ae, ye) {
    var Ge = this.__data__;
    if (Ge instanceof Te) {
      var Pt = Ge.__data__;
      if (!Ct || Pt.length < r - 1)
        return Pt.push([ae, ye]), this.size = ++Ge.size, this;
      Ge = this.__data__ = new et(Pt);
    }
    return Ge.set(ae, ye), this.size = Ge.size, this;
  }
  ut.prototype.clear = ot, ut.prototype.delete = Se, ut.prototype.get = Ae, ut.prototype.has = Ve, ut.prototype.set = Fe;
  function Ue(ae, ye) {
    var Ge = Mc(ae), Pt = !Ge && dh(ae), jr = !Ge && !Pt && Xu(ae), nr = !Ge && !Pt && !jr && mh(ae), Kr = Ge || Pt || jr || nr, vn = Kr ? De(ae.length, String) : [], _r = vn.length;
    for (var Ur in ae)
      ke.call(ae, Ur) && !(Kr && // Safari 9 has enumerable `arguments.length` in strict mode.
      (Ur == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      jr && (Ur == "offset" || Ur == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      nr && (Ur == "buffer" || Ur == "byteLength" || Ur == "byteOffset") || // Skip index properties.
      nn(Ur, _r))) && vn.push(Ur);
    return vn;
  }
  function Je(ae, ye) {
    for (var Ge = ae.length; Ge--; )
      if (hh(ae[Ge][0], ye))
        return Ge;
    return -1;
  }
  function Lt(ae, ye, Ge) {
    var Pt = ye(ae);
    return Mc(ae) ? Pt : ve(Pt, Ge(ae));
  }
  function zt(ae) {
    return ae == null ? ae === void 0 ? ge : $ : Et && Et in Object(ae) ? $r(ae) : Rp(ae);
  }
  function Zt(ae) {
    return Na(ae) && zt(ae) == a;
  }
  function Wt(ae, ye, Ge, Pt, jr) {
    return ae === ye ? !0 : ae == null || ye == null || !Na(ae) && !Na(ye) ? ae !== ae && ye !== ye : he(ae, ye, Ge, Pt, Wt, jr);
  }
  function he(ae, ye, Ge, Pt, jr, nr) {
    var Kr = Mc(ae), vn = Mc(ye), _r = Kr ? u : Ir(ae), Ur = vn ? u : Ir(ye);
    _r = _r == a ? B : _r, Ur = Ur == a ? B : Ur;
    var an = _r == B, ui = Ur == B, bn = _r == Ur;
    if (bn && Xu(ae)) {
      if (!Xu(ye))
        return !1;
      Kr = !0, an = !1;
    }
    if (bn && !an)
      return nr || (nr = new ut()), Kr || mh(ae) ? Qt(ae, ye, Ge, Pt, jr, nr) : gr(ae, ye, _r, Ge, Pt, jr, nr);
    if (!(Ge & i)) {
      var Vr = an && ke.call(ae, "__wrapped__"), ei = ui && ke.call(ye, "__wrapped__");
      if (Vr || ei) {
        var fs = Vr ? ae.value() : ae, ji = ei ? ye.value() : ye;
        return nr || (nr = new ut()), jr(fs, ji, Ge, Pt, nr);
      }
    }
    return bn ? (nr || (nr = new ut()), lr(ae, ye, Ge, Pt, jr, nr)) : !1;
  }
  function rr(ae) {
    if (!gh(ae) || on(ae))
      return !1;
    var ye = Ic(ae) ? Ye : F;
    return ye.test(oo(ae));
  }
  function dr(ae) {
    return Na(ae) && ph(ae.length) && !!D[zt(ae)];
  }
  function pr(ae) {
    if (!lh(ae))
      return Dt(ae);
    var ye = [];
    for (var Ge in Object(ae))
      ke.call(ae, Ge) && Ge != "constructor" && ye.push(Ge);
    return ye;
  }
  function Qt(ae, ye, Ge, Pt, jr, nr) {
    var Kr = Ge & i, vn = ae.length, _r = ye.length;
    if (vn != _r && !(Kr && _r > vn))
      return !1;
    var Ur = nr.get(ae);
    if (Ur && nr.get(ye))
      return Ur == ye;
    var an = -1, ui = !0, bn = Ge & s ? new xt() : void 0;
    for (nr.set(ae, ye), nr.set(ye, ae); ++an < vn; ) {
      var Vr = ae[an], ei = ye[an];
      if (Pt)
        var fs = Kr ? Pt(ei, Vr, an, ye, ae, nr) : Pt(Vr, ei, an, ae, ye, nr);
      if (fs !== void 0) {
        if (fs)
          continue;
        ui = !1;
        break;
      }
      if (bn) {
        if (!Pe(ye, function(ji, Is) {
          if (!$e(bn, Is) && (Vr === ji || jr(Vr, ji, Ge, Pt, nr)))
            return bn.push(Is);
        })) {
          ui = !1;
          break;
        }
      } else if (!(Vr === ei || jr(Vr, ei, Ge, Pt, nr))) {
        ui = !1;
        break;
      }
    }
    return nr.delete(ae), nr.delete(ye), ui;
  }
  function gr(ae, ye, Ge, Pt, jr, nr, Kr) {
    switch (Ge) {
      case S:
        if (ae.byteLength != ye.byteLength || ae.byteOffset != ye.byteOffset)
          return !1;
        ae = ae.buffer, ye = ye.buffer;
      case Y:
        return !(ae.byteLength != ye.byteLength || !nr(new ct(ae), new ct(ye)));
      case d:
      case p:
      case L:
        return hh(+ae, +ye);
      case w:
        return ae.name == ye.name && ae.message == ye.message;
      case V:
      case R:
        return ae == ye + "";
      case N:
        var vn = Ne;
      case te:
        var _r = Pt & i;
        if (vn || (vn = Le), ae.size != ye.size && !_r)
          return !1;
        var Ur = Kr.get(ae);
        if (Ur)
          return Ur == ye;
        Pt |= s, Kr.set(ae, ye);
        var an = Qt(vn(ae), vn(ye), Pt, jr, nr, Kr);
        return Kr.delete(ae), an;
      case K:
        if (z)
          return z.call(ae) == z.call(ye);
    }
    return !1;
  }
  function lr(ae, ye, Ge, Pt, jr, nr) {
    var Kr = Ge & i, vn = Rr(ae), _r = vn.length, Ur = Rr(ye), an = Ur.length;
    if (_r != an && !Kr)
      return !1;
    for (var ui = _r; ui--; ) {
      var bn = vn[ui];
      if (!(Kr ? bn in ye : ke.call(ye, bn)))
        return !1;
    }
    var Vr = nr.get(ae);
    if (Vr && nr.get(ye))
      return Vr == ye;
    var ei = !0;
    nr.set(ae, ye), nr.set(ye, ae);
    for (var fs = Kr; ++ui < _r; ) {
      bn = vn[ui];
      var ji = ae[bn], Is = ye[bn];
      if (Pt)
        var Zu = Kr ? Pt(Is, ji, bn, ye, ae, nr) : Pt(ji, Is, bn, ae, ye, nr);
      if (!(Zu === void 0 ? ji === Is || jr(ji, Is, Ge, Pt, nr) : Zu)) {
        ei = !1;
        break;
      }
      fs || (fs = bn == "constructor");
    }
    if (ei && !fs) {
      var La = ae.constructor, Pn = ye.constructor;
      La != Pn && "constructor" in ae && "constructor" in ye && !(typeof La == "function" && La instanceof La && typeof Pn == "function" && Pn instanceof Pn) && (ei = !1);
    }
    return nr.delete(ae), nr.delete(ye), ei;
  }
  function Rr(ae) {
    return Lt(ae, Np, Br);
  }
  function mr(ae, ye) {
    var Ge = ae.__data__;
    return sn(ye) ? Ge[typeof ye == "string" ? "string" : "hash"] : Ge.map;
  }
  function yr(ae, ye) {
    var Ge = Me(ae, ye);
    return rr(Ge) ? Ge : void 0;
  }
  function $r(ae) {
    var ye = ke.call(ae, Et), Ge = ae[Et];
    try {
      ae[Et] = void 0;
      var Pt = !0;
    } catch {
    }
    var jr = tt.call(ae);
    return Pt && (ye ? ae[Et] = Ge : delete ae[Et]), jr;
  }
  var Br = er ? function(ae) {
    return ae == null ? [] : (ae = Object(ae), ue(er(ae), function(ye) {
      return qt.call(ae, ye);
    }));
  } : Fr, Ir = zt;
  (kt && Ir(new kt(new ArrayBuffer(1))) != S || Ct && Ir(new Ct()) != N || gt && Ir(gt.resolve()) != H || Rt && Ir(new Rt()) != te || Nt && Ir(new Nt()) != Ee) && (Ir = function(ae) {
    var ye = zt(ae), Ge = ye == B ? ae.constructor : void 0, Pt = Ge ? oo(Ge) : "";
    if (Pt)
      switch (Pt) {
        case $t:
          return S;
        case Ft:
          return N;
        case rt:
          return H;
        case Bt:
          return te;
        case k:
          return Ee;
      }
    return ye;
  });
  function nn(ae, ye) {
    return ye = ye ?? o, !!ye && (typeof ae == "number" || ce.test(ae)) && ae > -1 && ae % 1 == 0 && ae < ye;
  }
  function sn(ae) {
    var ye = typeof ae;
    return ye == "string" || ye == "number" || ye == "symbol" || ye == "boolean" ? ae !== "__proto__" : ae === null;
  }
  function on(ae) {
    return !!Qe && Qe in ae;
  }
  function lh(ae) {
    var ye = ae && ae.constructor, Ge = typeof ye == "function" && ye.prototype || _e;
    return ae === Ge;
  }
  function Rp(ae) {
    return tt.call(ae);
  }
  function oo(ae) {
    if (ae != null) {
      try {
        return at.call(ae);
      } catch {
      }
      try {
        return ae + "";
      } catch {
      }
    }
    return "";
  }
  function hh(ae, ye) {
    return ae === ye || ae !== ae && ye !== ye;
  }
  var dh = Zt(/* @__PURE__ */ function() {
    return arguments;
  }()) ? Zt : function(ae) {
    return Na(ae) && ke.call(ae, "callee") && !qt.call(ae, "callee");
  }, Mc = Array.isArray;
  function Dp(ae) {
    return ae != null && ph(ae.length) && !Ic(ae);
  }
  var Xu = Xt || Dr;
  function Op(ae, ye) {
    return Wt(ae, ye);
  }
  function Ic(ae) {
    if (!gh(ae))
      return !1;
    var ye = zt(ae);
    return ye == A || ye == P || ye == l || ye == W;
  }
  function ph(ae) {
    return typeof ae == "number" && ae > -1 && ae % 1 == 0 && ae <= o;
  }
  function gh(ae) {
    var ye = typeof ae;
    return ae != null && (ye == "object" || ye == "function");
  }
  function Na(ae) {
    return ae != null && typeof ae == "object";
  }
  var mh = ie ? Ce(ie) : dr;
  function Np(ae) {
    return Dp(ae) ? Ue(ae) : pr(ae);
  }
  function Fr() {
    return [];
  }
  function Dr() {
    return !1;
  }
  t.exports = Op;
})(l0, l0.exports);
var WW = l0.exports;
const HW = /* @__PURE__ */ rs(WW), rE = "wc", nE = 2, iE = "core", eo = `${rE}@2:${iE}:`, KW = { logger: "error" }, VW = { database: ":memory:" }, GW = "crypto", p3 = "client_ed25519_seed", YW = mt.ONE_DAY, JW = "keychain", XW = "0.3", ZW = "messages", QW = "0.3", eH = mt.SIX_HOURS, tH = "publisher", sE = "irn", rH = "error", oE = "wss://relay.walletconnect.org", nH = "relayer", si = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", publish: "relayer_publish" }, iH = "_subscription", Gi = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" }, sH = 0.1, T1 = "2.17.2", zr = { link_mode: "link_mode", relay: "relay" }, oH = "0.3", aH = "WALLETCONNECT_CLIENT_ID", g3 = "WALLETCONNECT_LINK_MODE_APPS", Us = { created: "subscription_created", deleted: "subscription_deleted", sync: "subscription_sync", resubscribed: "subscription_resubscribed" }, cH = "subscription", uH = "0.3", fH = mt.FIVE_SECONDS * 1e3, lH = "pairing", hH = "0.3", Mf = { wc_pairingDelete: { req: { ttl: mt.ONE_DAY, prompt: !1, tag: 1e3 }, res: { ttl: mt.ONE_DAY, prompt: !1, tag: 1001 } }, wc_pairingPing: { req: { ttl: mt.THIRTY_SECONDS, prompt: !1, tag: 1002 }, res: { ttl: mt.THIRTY_SECONDS, prompt: !1, tag: 1003 } }, unregistered_method: { req: { ttl: mt.ONE_DAY, prompt: !1, tag: 0 }, res: { ttl: mt.ONE_DAY, prompt: !1, tag: 0 } } }, Qa = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" }, ms = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" }, dH = "history", pH = "0.3", gH = "expirer", Xi = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" }, mH = "0.3", vH = "verify-api", bH = "https://verify.walletconnect.com", aE = "https://verify.walletconnect.org", Wf = aE, yH = `${Wf}/v3`, wH = [bH, aE], xH = "echo", _H = "https://echo.walletconnect.com", Fs = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal" }, _o = { no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_listener_not_found: "proposal_listener_not_found" }, vs = { session_approve_started: "session_approve_started", session_namespaces_validation_success: "session_namespaces_validation_success", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" }, Va = { no_internet_connection: "no_internet_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" }, Ga = { authenticated_session_approve_started: "authenticated_session_approve_started", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve" }, If = { no_internet_connection: "no_internet_connection", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" }, EH = 0.1, SH = "event-client", AH = 86400, PH = "https://pulse.walletconnect.org/batch";
function MH(t, e) {
  if (t.length >= 255) throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++) r[n] = 255;
  for (var i = 0; i < t.length; i++) {
    var s = t.charAt(i), o = s.charCodeAt(0);
    if (r[o] !== 255) throw new TypeError(s + " is ambiguous");
    r[o] = i;
  }
  var a = t.length, u = t.charAt(0), l = Math.log(a) / Math.log(256), d = Math.log(256) / Math.log(a);
  function p(P) {
    if (P instanceof Uint8Array || (ArrayBuffer.isView(P) ? P = new Uint8Array(P.buffer, P.byteOffset, P.byteLength) : Array.isArray(P) && (P = Uint8Array.from(P))), !(P instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (P.length === 0) return "";
    for (var N = 0, L = 0, $ = 0, B = P.length; $ !== B && P[$] === 0; ) $++, N++;
    for (var H = (B - $) * d + 1 >>> 0, W = new Uint8Array(H); $ !== B; ) {
      for (var V = P[$], te = 0, R = H - 1; (V !== 0 || te < L) && R !== -1; R--, te++) V += 256 * W[R] >>> 0, W[R] = V % a >>> 0, V = V / a >>> 0;
      if (V !== 0) throw new Error("Non-zero carry");
      L = te, $++;
    }
    for (var K = H - L; K !== H && W[K] === 0; ) K++;
    for (var ge = u.repeat(N); K < H; ++K) ge += t.charAt(W[K]);
    return ge;
  }
  function w(P) {
    if (typeof P != "string") throw new TypeError("Expected String");
    if (P.length === 0) return new Uint8Array();
    var N = 0;
    if (P[N] !== " ") {
      for (var L = 0, $ = 0; P[N] === u; ) L++, N++;
      for (var B = (P.length - N) * l + 1 >>> 0, H = new Uint8Array(B); P[N]; ) {
        var W = r[P.charCodeAt(N)];
        if (W === 255) return;
        for (var V = 0, te = B - 1; (W !== 0 || V < $) && te !== -1; te--, V++) W += a * H[te] >>> 0, H[te] = W % 256 >>> 0, W = W / 256 >>> 0;
        if (W !== 0) throw new Error("Non-zero carry");
        $ = V, N++;
      }
      if (P[N] !== " ") {
        for (var R = B - $; R !== B && H[R] === 0; ) R++;
        for (var K = new Uint8Array(L + (B - R)), ge = L; R !== B; ) K[ge++] = H[R++];
        return K;
      }
    }
  }
  function A(P) {
    var N = w(P);
    if (N) return N;
    throw new Error(`Non-${e} character`);
  }
  return { encode: p, decodeUnsafe: w, decode: A };
}
var IH = MH, CH = IH;
const cE = (t) => {
  if (t instanceof Uint8Array && t.constructor.name === "Uint8Array") return t;
  if (t instanceof ArrayBuffer) return new Uint8Array(t);
  if (ArrayBuffer.isView(t)) return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  throw new Error("Unknown type, must be binary type");
}, TH = (t) => new TextEncoder().encode(t), RH = (t) => new TextDecoder().decode(t);
class DH {
  constructor(e, r, n) {
    this.name = e, this.prefix = r, this.baseEncode = n;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class OH {
  constructor(e, r, n) {
    if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return uE(this, e);
  }
}
class NH {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return uE(this, e);
  }
  decode(e) {
    const r = e[0], n = this.decoders[r];
    if (n) return n.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const uE = (t, e) => new NH({ ...t.decoders || { [t.prefix]: t }, ...e.decoders || { [e.prefix]: e } });
class LH {
  constructor(e, r, n, i) {
    this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = i, this.encoder = new DH(e, r, n), this.decoder = new OH(e, r, i);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const sp = ({ name: t, prefix: e, encode: r, decode: n }) => new LH(t, e, r, n), rh = ({ prefix: t, name: e, alphabet: r }) => {
  const { encode: n, decode: i } = CH(r, e);
  return sp({ prefix: t, name: e, encode: n, decode: (s) => cE(i(s)) });
}, kH = (t, e, r, n) => {
  const i = {};
  for (let d = 0; d < e.length; ++d) i[e[d]] = d;
  let s = t.length;
  for (; t[s - 1] === "="; ) --s;
  const o = new Uint8Array(s * r / 8 | 0);
  let a = 0, u = 0, l = 0;
  for (let d = 0; d < s; ++d) {
    const p = i[t[d]];
    if (p === void 0) throw new SyntaxError(`Non-${n} character`);
    u = u << r | p, a += r, a >= 8 && (a -= 8, o[l++] = 255 & u >> a);
  }
  if (a >= r || 255 & u << 8 - a) throw new SyntaxError("Unexpected end of data");
  return o;
}, $H = (t, e, r) => {
  const n = e[e.length - 1] === "=", i = (1 << r) - 1;
  let s = "", o = 0, a = 0;
  for (let u = 0; u < t.length; ++u) for (a = a << 8 | t[u], o += 8; o > r; ) o -= r, s += e[i & a >> o];
  if (o && (s += e[i & a << r - o]), n) for (; s.length * r & 7; ) s += "=";
  return s;
}, Hn = ({ name: t, prefix: e, bitsPerChar: r, alphabet: n }) => sp({ prefix: e, name: t, encode(i) {
  return $H(i, n, r);
}, decode(i) {
  return kH(i, n, r, t);
} }), BH = sp({ prefix: "\0", name: "identity", encode: (t) => RH(t), decode: (t) => TH(t) });
var FH = Object.freeze({ __proto__: null, identity: BH });
const jH = Hn({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var UH = Object.freeze({ __proto__: null, base2: jH });
const qH = Hn({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var zH = Object.freeze({ __proto__: null, base8: qH });
const WH = rh({ prefix: "9", name: "base10", alphabet: "0123456789" });
var HH = Object.freeze({ __proto__: null, base10: WH });
const KH = Hn({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), VH = Hn({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var GH = Object.freeze({ __proto__: null, base16: KH, base16upper: VH });
const YH = Hn({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), JH = Hn({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), XH = Hn({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), ZH = Hn({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), QH = Hn({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), eK = Hn({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), tK = Hn({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), rK = Hn({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), nK = Hn({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var iK = Object.freeze({ __proto__: null, base32: YH, base32upper: JH, base32pad: XH, base32padupper: ZH, base32hex: QH, base32hexupper: eK, base32hexpad: tK, base32hexpadupper: rK, base32z: nK });
const sK = rh({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), oK = rh({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var aK = Object.freeze({ __proto__: null, base36: sK, base36upper: oK });
const cK = rh({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), uK = rh({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var fK = Object.freeze({ __proto__: null, base58btc: cK, base58flickr: uK });
const lK = Hn({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), hK = Hn({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), dK = Hn({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), pK = Hn({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var gK = Object.freeze({ __proto__: null, base64: lK, base64pad: hK, base64url: dK, base64urlpad: pK });
const fE = Array.from(""), mK = fE.reduce((t, e, r) => (t[r] = e, t), []), vK = fE.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
function bK(t) {
  return t.reduce((e, r) => (e += mK[r], e), "");
}
function yK(t) {
  const e = [];
  for (const r of t) {
    const n = vK[r.codePointAt(0)];
    if (n === void 0) throw new Error(`Non-base256emoji character: ${r}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
const wK = sp({ prefix: "", name: "base256emoji", encode: bK, decode: yK });
var xK = Object.freeze({ __proto__: null, base256emoji: wK }), _K = lE, m3 = 128, EK = 127, SK = ~EK, AK = Math.pow(2, 31);
function lE(t, e, r) {
  e = e || [], r = r || 0;
  for (var n = r; t >= AK; ) e[r++] = t & 255 | m3, t /= 128;
  for (; t & SK; ) e[r++] = t & 255 | m3, t >>>= 7;
  return e[r] = t | 0, lE.bytes = r - n + 1, e;
}
var PK = R1, MK = 128, v3 = 127;
function R1(t, n) {
  var r = 0, n = n || 0, i = 0, s = n, o, a = t.length;
  do {
    if (s >= a) throw R1.bytes = 0, new RangeError("Could not decode varint");
    o = t[s++], r += i < 28 ? (o & v3) << i : (o & v3) * Math.pow(2, i), i += 7;
  } while (o >= MK);
  return R1.bytes = s - n, r;
}
var IK = Math.pow(2, 7), CK = Math.pow(2, 14), TK = Math.pow(2, 21), RK = Math.pow(2, 28), DK = Math.pow(2, 35), OK = Math.pow(2, 42), NK = Math.pow(2, 49), LK = Math.pow(2, 56), kK = Math.pow(2, 63), $K = function(t) {
  return t < IK ? 1 : t < CK ? 2 : t < TK ? 3 : t < RK ? 4 : t < DK ? 5 : t < OK ? 6 : t < NK ? 7 : t < LK ? 8 : t < kK ? 9 : 10;
}, BK = { encode: _K, decode: PK, encodingLength: $K }, hE = BK;
const b3 = (t, e, r = 0) => (hE.encode(t, e, r), e), y3 = (t) => hE.encodingLength(t), D1 = (t, e) => {
  const r = e.byteLength, n = y3(t), i = n + y3(r), s = new Uint8Array(i + r);
  return b3(t, s, 0), b3(r, s, n), s.set(e, i), new FK(t, r, e, s);
};
class FK {
  constructor(e, r, n, i) {
    this.code = e, this.size = r, this.digest = n, this.bytes = i;
  }
}
const dE = ({ name: t, code: e, encode: r }) => new jK(t, e, r);
class jK {
  constructor(e, r, n) {
    this.name = e, this.code = r, this.encode = n;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const r = this.encode(e);
      return r instanceof Uint8Array ? D1(this.code, r) : r.then((n) => D1(this.code, n));
    } else throw Error("Unknown type, must be binary type");
  }
}
const pE = (t) => async (e) => new Uint8Array(await crypto.subtle.digest(t, e)), UK = dE({ name: "sha2-256", code: 18, encode: pE("SHA-256") }), qK = dE({ name: "sha2-512", code: 19, encode: pE("SHA-512") });
var zK = Object.freeze({ __proto__: null, sha256: UK, sha512: qK });
const gE = 0, WK = "identity", mE = cE, HK = (t) => D1(gE, mE(t)), KK = { code: gE, name: WK, encode: mE, digest: HK };
var VK = Object.freeze({ __proto__: null, identity: KK });
new TextEncoder(), new TextDecoder();
const w3 = { ...FH, ...UH, ...zH, ...HH, ...GH, ...iK, ...aK, ...fK, ...gK, ...xK };
({ ...zK, ...VK });
function GK(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(t) : new Uint8Array(t);
}
function vE(t, e, r, n) {
  return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: r }, decoder: { decode: n } };
}
const x3 = vE("utf8", "u", (t) => "u" + new TextDecoder("utf8").decode(t), (t) => new TextEncoder().encode(t.substring(1))), pm = vE("ascii", "a", (t) => {
  let e = "a";
  for (let r = 0; r < t.length; r++) e += String.fromCharCode(t[r]);
  return e;
}, (t) => {
  t = t.substring(1);
  const e = GK(t.length);
  for (let r = 0; r < t.length; r++) e[r] = t.charCodeAt(r);
  return e;
}), YK = { utf8: x3, "utf-8": x3, hex: w3.base16, latin1: pm, ascii: pm, binary: pm, ...w3 };
function JK(t, e = "utf8") {
  const r = YK[e];
  if (!r) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t, "utf8") : r.decoder.decode(`${r.prefix}${t}`);
}
let XK = class {
  constructor(e, r) {
    this.core = e, this.logger = r, this.keychain = /* @__PURE__ */ new Map(), this.name = JW, this.version = XW, this.initialized = !1, this.storagePrefix = eo, this.init = async () => {
      if (!this.initialized) {
        const n = await this.getKeyChain();
        typeof n < "u" && (this.keychain = n), this.initialized = !0;
      }
    }, this.has = (n) => (this.isInitialized(), this.keychain.has(n)), this.set = async (n, i) => {
      this.isInitialized(), this.keychain.set(n, i), await this.persist();
    }, this.get = (n) => {
      this.isInitialized();
      const i = this.keychain.get(n);
      if (typeof i > "u") {
        const { message: s } = ft("NO_MATCHING_KEY", `${this.name}: ${n}`);
        throw new Error(s);
      }
      return i;
    }, this.del = async (n) => {
      this.isInitialized(), this.keychain.delete(n), await this.persist();
    }, this.core = e, this.logger = ci(r, this.name);
  }
  get context() {
    return Si(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, k8(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? $8(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}, ZK = class {
  constructor(e, r, n) {
    this.core = e, this.logger = r, this.name = GW, this.randomSessionIdentifier = I1(), this.initialized = !1, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = !0);
    }, this.hasKeys = (i) => (this.isInitialized(), this.keychain.has(i)), this.getClientId = async () => {
      this.isInitialized();
      const i = await this.getClientSeed(), s = ox(i);
      return q4(s.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const i = xz();
      return this.setPrivateKey(i.publicKey, i.privateKey);
    }, this.signJWT = async (i) => {
      this.isInitialized();
      const s = await this.getClientSeed(), o = ox(s), a = this.randomSessionIdentifier;
      return await WB(a, i, YW, o);
    }, this.generateSharedKey = (i, s, o) => {
      this.isInitialized();
      const a = this.getPrivateKey(i), u = _z(a, s);
      return this.setSymKey(u, o);
    }, this.setSymKey = async (i, s) => {
      this.isInitialized();
      const o = s || Td(i);
      return await this.keychain.set(o, i), o;
    }, this.deleteKeyPair = async (i) => {
      this.isInitialized(), await this.keychain.del(i);
    }, this.deleteSymKey = async (i) => {
      this.isInitialized(), await this.keychain.del(i);
    }, this.encode = async (i, s, o) => {
      this.isInitialized();
      const a = V8(o), u = Bo(s);
      if (Yx(a)) return Sz(u, o == null ? void 0 : o.encoding);
      if (Gx(a)) {
        const w = a.senderPublicKey, A = a.receiverPublicKey;
        i = await this.generateSharedKey(w, A);
      }
      const l = this.getSymKey(i), { type: d, senderPublicKey: p } = a;
      return Ez({ type: d, symKey: l, message: u, senderPublicKey: p, encoding: o == null ? void 0 : o.encoding });
    }, this.decode = async (i, s, o) => {
      this.isInitialized();
      const a = Mz(s, o);
      if (Yx(a)) {
        const u = Pz(s, o == null ? void 0 : o.encoding);
        return lc(u);
      }
      if (Gx(a)) {
        const u = a.receiverPublicKey, l = a.senderPublicKey;
        i = await this.generateSharedKey(u, l);
      }
      try {
        const u = this.getSymKey(i), l = Az({ symKey: u, encoded: s, encoding: o == null ? void 0 : o.encoding });
        return lc(l);
      } catch (u) {
        this.logger.error(`Failed to decode message from topic: '${i}', clientId: '${await this.getClientId()}'`), this.logger.error(u);
      }
    }, this.getPayloadType = (i, s = pa) => {
      const o = El({ encoded: i, encoding: s });
      return pc(o.type);
    }, this.getPayloadSenderPublicKey = (i, s = pa) => {
      const o = El({ encoded: i, encoding: s });
      return o.senderPublicKey ? On(o.senderPublicKey, ai) : void 0;
    }, this.core = e, this.logger = ci(r, this.name), this.keychain = n || new XK(this.core, this.logger);
  }
  get context() {
    return Si(this.logger);
  }
  async setPrivateKey(e, r) {
    return await this.keychain.set(e, r), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(p3);
    } catch {
      e = I1(), await this.keychain.set(p3, e);
    }
    return JK(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
class QK extends Jk {
  constructor(e, r) {
    super(e, r), this.logger = e, this.core = r, this.messages = /* @__PURE__ */ new Map(), this.name = ZW, this.version = QW, this.initialized = !1, this.storagePrefix = eo, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const n = await this.getRelayerMessages();
          typeof n < "u" && (this.messages = n), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (n) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(n);
        } finally {
          this.initialized = !0;
        }
      }
    }, this.set = async (n, i) => {
      this.isInitialized();
      const s = Eo(i);
      let o = this.messages.get(n);
      return typeof o > "u" && (o = {}), typeof o[s] < "u" || (o[s] = i, this.messages.set(n, o), await this.persist()), s;
    }, this.get = (n) => {
      this.isInitialized();
      let i = this.messages.get(n);
      return typeof i > "u" && (i = {}), i;
    }, this.has = (n, i) => {
      this.isInitialized();
      const s = this.get(n), o = Eo(i);
      return typeof s[o] < "u";
    }, this.del = async (n) => {
      this.isInitialized(), this.messages.delete(n), await this.persist();
    }, this.logger = ci(e, this.name), this.core = r;
  }
  get context() {
    return Si(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, k8(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? $8(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class eV extends Xk {
  constructor(e, r) {
    super(e, r), this.relayer = e, this.logger = r, this.events = new ns.EventEmitter(), this.name = tH, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = mt.toMiliseconds(mt.ONE_MINUTE), this.failedPublishTimeout = mt.toMiliseconds(mt.ONE_SECOND), this.needsTransportRestart = !1, this.publish = async (n, i, s) => {
      var o;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: n, message: i, opts: s } });
      const a = (s == null ? void 0 : s.ttl) || eH, u = C1(s), l = (s == null ? void 0 : s.prompt) || !1, d = (s == null ? void 0 : s.tag) || 0, p = (s == null ? void 0 : s.id) || ic().toString(), w = { topic: n, message: i, opts: { ttl: a, relay: u, prompt: l, tag: d, id: p, attestation: s == null ? void 0 : s.attestation } }, A = `Failed to publish payload, please try again. id:${p} tag:${d}`, P = Date.now();
      let N, L = 1;
      try {
        for (; N === void 0; ) {
          if (Date.now() - P > this.publishTimeout) throw new Error(A);
          this.logger.trace({ id: p, attempts: L }, `publisher.publish - attempt ${L}`), N = await await du(this.rpcPublish(n, i, a, u, l, d, p, s == null ? void 0 : s.attestation).catch(($) => this.logger.warn($)), this.publishTimeout, A), L++, N || await new Promise(($) => setTimeout($, this.failedPublishTimeout));
        }
        this.relayer.events.emit(si.publish, w), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { id: p, topic: n, message: i, opts: s } });
      } catch ($) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error($), (o = s == null ? void 0 : s.internal) != null && o.throwOnFailedPublish) throw $;
        this.queue.set(p, w);
      }
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.relayer = e, this.logger = ci(r, this.name), this.registerEventListeners();
  }
  get context() {
    return Si(this.logger);
  }
  rpcPublish(e, r, n, i, s, o, a, u) {
    var l, d, p, w;
    const A = { method: Bf(i.protocol).publish, params: { topic: e, message: r, ttl: n, prompt: s, tag: o, attestation: u }, id: a };
    return mi((l = A.params) == null ? void 0 : l.prompt) && ((d = A.params) == null || delete d.prompt), mi((p = A.params) == null ? void 0 : p.tag) && ((w = A.params) == null || delete w.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: A }), this.relayer.request(A);
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e) => {
      const { topic: r, message: n, opts: i } = e;
      await this.publish(r, n, i);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(Ou.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = !1, this.relayer.events.emit(si.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(si.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
}
class tV {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e, r) => {
      const n = this.get(e);
      this.exists(e, r) || this.map.set(e, [...n, r]);
    }, this.get = (e) => this.map.get(e) || [], this.exists = (e, r) => this.get(e).includes(r), this.delete = (e, r) => {
      if (typeof r > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const n = this.get(e);
      if (!this.exists(e, r)) return;
      const i = n.filter((s) => s !== r);
      if (!i.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, i);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
}
var rV = Object.defineProperty, nV = Object.defineProperties, iV = Object.getOwnPropertyDescriptors, _3 = Object.getOwnPropertySymbols, sV = Object.prototype.hasOwnProperty, oV = Object.prototype.propertyIsEnumerable, E3 = (t, e, r) => e in t ? rV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Cf = (t, e) => {
  for (var r in e || (e = {})) sV.call(e, r) && E3(t, r, e[r]);
  if (_3) for (var r of _3(e)) oV.call(e, r) && E3(t, r, e[r]);
  return t;
}, gm = (t, e) => nV(t, iV(e));
class aV extends e$ {
  constructor(e, r) {
    super(e, r), this.relayer = e, this.logger = r, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new tV(), this.events = new ns.EventEmitter(), this.name = cH, this.version = uH, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = !1, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = eo, this.subscribeTimeout = mt.toMiliseconds(mt.ONE_MINUTE), this.restartInProgress = !1, this.batchSubscribeTopicsLimit = 500, this.pendingBatchMessages = [], this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = !0;
    }, this.subscribe = async (n, i) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: i } });
      try {
        const s = C1(i), o = { topic: n, relay: s, transportType: i == null ? void 0 : i.transportType };
        this.pending.set(n, o);
        const a = await this.rpcSubscribe(n, s, i);
        return typeof a == "string" && (this.onSubscribe(a, o), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: n, opts: i } })), a;
      } catch (s) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(s), s;
      }
    }, this.unsubscribe = async (n, i) => {
      await this.restartToComplete(), this.isInitialized(), typeof (i == null ? void 0 : i.id) < "u" ? await this.unsubscribeById(n, i.id, i) : await this.unsubscribeByTopic(n, i);
    }, this.isSubscribed = async (n) => {
      if (this.topics.includes(n)) return !0;
      const i = `${this.pendingSubscriptionWatchLabel}_${n}`;
      return await new Promise((s, o) => {
        const a = new mt.Watch();
        a.start(i);
        const u = setInterval(() => {
          !this.pending.has(n) && this.topics.includes(n) && (clearInterval(u), a.stop(i), s(!0)), a.elapsed(i) >= fH && (clearInterval(u), a.stop(i), o(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => !1);
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.start = async () => {
      await this.onConnect();
    }, this.stop = async () => {
      await this.onDisconnect();
    }, this.restart = async () => {
      this.restartInProgress = !0, await this.restore(), await this.reset(), this.restartInProgress = !1;
    }, this.relayer = e, this.logger = ci(r, this.name), this.clientId = "";
  }
  get context() {
    return Si(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e, r) {
    let n = !1;
    try {
      n = this.getSubscription(e).topic === r;
    } catch {
    }
    return n;
  }
  onEnable() {
    this.cached = [], this.initialized = !0;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, r) {
    const n = this.topicMap.get(e);
    await Promise.all(n.map(async (i) => await this.unsubscribeById(e, i, r)));
  }
  async unsubscribeById(e, r, n) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: r, opts: n } });
    try {
      const i = C1(n);
      await this.rpcUnsubscribe(e, r, i);
      const s = Or("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, r, s), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: r, opts: n } });
    } catch (i) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i), i;
    }
  }
  async rpcSubscribe(e, r, n) {
    var i;
    (n == null ? void 0 : n.transportType) === zr.relay && await this.restartToComplete();
    const s = { method: Bf(r.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s });
    const o = (i = n == null ? void 0 : n.internal) == null ? void 0 : i.throwOnFailedPublish;
    try {
      const a = Eo(e + this.clientId);
      if ((n == null ? void 0 : n.transportType) === zr.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(s).catch((l) => this.logger.warn(l));
      }, mt.toMiliseconds(mt.ONE_SECOND)), a;
      const u = await du(this.relayer.request(s).catch((l) => this.logger.warn(l)), this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!u && o) throw new Error(`Subscribing to ${e} failed, please try again`);
      return u ? a : null;
    } catch (a) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(si.connection_stalled), o) throw a;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const r = e[0].relay, n = { method: Bf(r.protocol).batchSubscribe, params: { topics: e.map((i) => i.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    try {
      return await await du(this.relayer.request(n).catch((i) => this.logger.warn(i)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(si.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const r = e[0].relay, n = { method: Bf(r.protocol).batchFetchMessages, params: { topics: e.map((s) => s.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n });
    let i;
    try {
      i = await await du(this.relayer.request(n).catch((s) => this.logger.warn(s)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(si.connection_stalled);
    }
    return i;
  }
  rpcUnsubscribe(e, r, n) {
    const i = { method: Bf(n.protocol).unsubscribe, params: { topic: e, id: r } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i }), this.relayer.request(i);
  }
  onSubscribe(e, r) {
    this.setSubscription(e, gm(Cf({}, r), { id: e })), this.pending.delete(r.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((r) => {
      this.setSubscription(r.id, Cf({}, r)), this.pending.delete(r.topic);
    });
  }
  async onUnsubscribe(e, r, n) {
    this.events.removeAllListeners(r), this.hasSubscription(r, e) && this.deleteSubscription(r, n), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, r) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: r }), this.addSubscription(e, r);
  }
  addSubscription(e, r) {
    this.subscriptions.set(e, Cf({}, r)), this.topicMap.set(r.topic, e), this.events.emit(Us.created, r);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const r = this.subscriptions.get(e);
    if (!r) {
      const { message: n } = ft("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return r;
  }
  deleteSubscription(e, r) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: r });
    const n = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(n.topic, e), this.events.emit(Us.deleted, gm(Cf({}, n), { reason: r }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(Us.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let r = 0; r < e; r++) {
        const n = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchFetchMessages(n), await this.batchSubscribe(n);
      }
    }
    this.events.emit(Us.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: r } = ft("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    if (!e.length) return;
    const r = await this.rpcBatchSubscribe(e);
    gc(r) && this.onBatchSubscribe(r.map((n, i) => gm(Cf({}, e[i]), { id: n })));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const r = await this.rpcBatchFetchMessages(e);
    r && r.messages && (this.pendingBatchMessages = this.pendingBatchMessages.concat(r.messages));
  }
  async onConnect() {
    await this.restart(), this.onEnable();
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || !this.relayer.connected) return;
    const e = [];
    this.pending.forEach((r) => {
      e.push(r);
    }), await this.batchSubscribe(e), this.pendingBatchMessages.length && (await this.relayer.handleBatchMessageEvents(this.pendingBatchMessages), this.pendingBatchMessages = []);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(Ou.pulse, async () => {
      await this.checkPending();
    }), this.events.on(Us.created, async (e) => {
      const r = Us.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), await this.persist();
    }), this.events.on(Us.deleted, async (e) => {
      const r = Us.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete() {
    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen(), this.restartInProgress && await new Promise((e) => {
      const r = setInterval(() => {
        this.restartInProgress || (clearInterval(r), e());
      }, this.pollingInterval);
    });
  }
}
var cV = Object.defineProperty, S3 = Object.getOwnPropertySymbols, uV = Object.prototype.hasOwnProperty, fV = Object.prototype.propertyIsEnumerable, A3 = (t, e, r) => e in t ? cV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, P3 = (t, e) => {
  for (var r in e || (e = {})) uV.call(e, r) && A3(t, r, e[r]);
  if (S3) for (var r of S3(e)) fV.call(e, r) && A3(t, r, e[r]);
  return t;
};
class lV extends Zk {
  constructor(e) {
    super(e), this.protocol = "wc", this.version = 2, this.events = new ns.EventEmitter(), this.name = nH, this.transportExplicitlyClosed = !1, this.initialized = !1, this.connectionAttemptInProgress = !1, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "stalled", "interrupted"], this.hasExperiencedNetworkDisruption = !1, this.requestsInFlight = /* @__PURE__ */ new Map(), this.heartBeatTimeout = mt.toMiliseconds(mt.THIRTY_SECONDS + mt.ONE_SECOND), this.request = async (r) => {
      var n, i;
      this.logger.debug("Publishing Request Payload");
      const s = r.id || ic().toString();
      await this.toEstablishConnection();
      try {
        const o = this.provider.request(r);
        this.requestsInFlight.set(s, { promise: o, request: r }), this.logger.trace({ id: s, method: r.method, topic: (n = r.params) == null ? void 0 : n.topic }, "relayer.request - attempt to publish...");
        const a = await new Promise(async (u, l) => {
          const d = () => {
            l(new Error(`relayer.request - publish interrupted, id: ${s}`));
          };
          this.provider.on(Gi.disconnect, d);
          const p = await o;
          this.provider.off(Gi.disconnect, d), u(p);
        });
        return this.logger.trace({ id: s, method: r.method, topic: (i = r.params) == null ? void 0 : i.topic }, "relayer.request - published"), a;
      } catch (o) {
        throw this.logger.debug(`Failed to Publish Request: ${s}`), o;
      } finally {
        this.requestsInFlight.delete(s);
      }
    }, this.resetPingTimeout = () => {
      if (c0()) try {
        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
          var r, n, i;
          (i = (n = (r = this.provider) == null ? void 0 : r.connection) == null ? void 0 : n.socket) == null || i.terminate();
        }, this.heartBeatTimeout);
      } catch (r) {
        this.logger.warn(r);
      }
    }, this.onPayloadHandler = (r) => {
      this.onProviderPayload(r), this.resetPingTimeout();
    }, this.onConnectHandler = () => {
      this.logger.trace("relayer connected"), this.startPingTimeout(), this.events.emit(si.connect);
    }, this.onDisconnectHandler = () => {
      this.logger.trace("relayer disconnected"), this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (r) => {
      this.logger.error(r), this.events.emit(si.error, r), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(Gi.payload, this.onPayloadHandler), this.provider.on(Gi.connect, this.onConnectHandler), this.provider.on(Gi.disconnect, this.onDisconnectHandler), this.provider.on(Gi.error, this.onProviderErrorHandler);
    }, this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? ci(e.logger, this.name) : ql($0({ level: e.logger || rH })), this.messages = new QK(this.logger, e.core), this.subscriber = new aV(this, this.logger), this.publisher = new eV(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || oE, this.projectId = e.projectId, this.bundleId = Fq(), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = !0, this.subscriber.cached.length > 0) try {
      await this.transportOpen();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  get context() {
    return Si(this.logger);
  }
  get connected() {
    var e, r, n;
    return ((n = (r = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : r.socket) == null ? void 0 : n.readyState) === 1;
  }
  get connecting() {
    var e, r, n;
    return ((n = (r = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : r.socket) == null ? void 0 : n.readyState) === 0;
  }
  async publish(e, r, n) {
    this.isInitialized(), await this.publisher.publish(e, r, n), await this.recordMessageEvent({ topic: e, message: r, publishedAt: Date.now(), transportType: zr.relay });
  }
  async subscribe(e, r) {
    var n, i, s;
    this.isInitialized(), (r == null ? void 0 : r.transportType) === "relay" && await this.toEstablishConnection();
    const o = typeof ((n = r == null ? void 0 : r.internal) == null ? void 0 : n.throwOnFailedPublish) > "u" ? !0 : (i = r == null ? void 0 : r.internal) == null ? void 0 : i.throwOnFailedPublish;
    let a = ((s = this.subscriber.topicMap.get(e)) == null ? void 0 : s[0]) || "", u;
    const l = (d) => {
      d.topic === e && (this.subscriber.off(Us.created, l), u());
    };
    return await Promise.all([new Promise((d) => {
      u = d, this.subscriber.on(Us.created, l);
    }), new Promise(async (d, p) => {
      a = await this.subscriber.subscribe(e, P3({ internal: { throwOnFailedPublish: o } }, r)).catch((w) => {
        o && p(w);
      }) || a, d();
    })]), a;
  }
  async unsubscribe(e, r) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, r);
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async transportDisconnect() {
    if (!this.hasExperiencedNetworkDisruption && this.connected && this.requestsInFlight.size > 0) try {
      await Promise.all(Array.from(this.requestsInFlight.values()).map((e) => e.promise));
    } catch (e) {
      this.logger.warn(e);
    }
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await du(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = !0, await this.transportDisconnect();
  }
  async transportOpen(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), await this.createProvider(), this.connectionAttemptInProgress = !0, this.transportExplicitlyClosed = !1;
    try {
      await new Promise(async (r, n) => {
        const i = () => {
          this.provider.off(Gi.disconnect, i), n(new Error("Connection interrupted while trying to subscribe"));
        };
        this.provider.on(Gi.disconnect, i), await du(this.provider.connect(), mt.toMiliseconds(mt.ONE_MINUTE), `Socket stalled when trying to connect to ${this.relayUrl}`).catch((s) => {
          n(s);
        }).finally(() => {
          clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;
        }), this.subscriber.start().catch((s) => {
          this.logger.error(s), this.onDisconnectHandler();
        }), this.hasExperiencedNetworkDisruption = !1, r();
      });
    } catch (r) {
      this.logger.error(r);
      const n = r;
      if (this.hasExperiencedNetworkDisruption = !0, !this.isConnectionStalled(n.message)) throw r;
    } finally {
      this.connectionAttemptInProgress = !1;
    }
  }
  async restartTransport(e) {
    this.connectionAttemptInProgress || (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await o3()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const r = e.sort((n, i) => n.publishedAt - i.publishedAt);
    this.logger.trace(`Batch of ${r.length} message events sorted`);
    for (const n of r) try {
      await this.onMessageEvent(n);
    } catch (i) {
      this.logger.warn(i);
    }
    this.logger.trace(`Batch of ${r.length} message events processed`);
  }
  async onLinkMessageEvent(e, r) {
    const { topic: n } = e;
    if (!r.sessionExists) {
      const i = En(mt.FIVE_MINUTES), s = { topic: n, expiry: i, relay: { protocol: "irn" }, active: !1 };
      await this.core.pairing.pairings.set(n, s);
    }
    this.events.emit(si.message, e), await this.recordMessageEvent(e);
  }
  startPingTimeout() {
    var e, r, n, i, s;
    if (c0()) try {
      (r = (e = this.provider) == null ? void 0 : e.connection) != null && r.socket && ((s = (i = (n = this.provider) == null ? void 0 : n.connection) == null ? void 0 : i.socket) == null || s.once("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o) {
      this.logger.warn(o);
    }
  }
  isConnectionStalled(e) {
    return this.staleConnectionErrors.some((r) => e.includes(r));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new cs(new zW(zq({ sdkVersion: T1, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: !0, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e) {
    const { topic: r, message: n } = e;
    await this.messages.set(r, n);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: r, message: n } = e;
    if (!n || n.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${n}`), !0;
    if (!await this.subscriber.isSubscribed(r)) return this.logger.debug(`Ignoring message for non-subscribed topic ${r}`), !0;
    const i = this.messages.has(r, n);
    return i && this.logger.debug(`Ignoring duplicate message: ${n}`), i;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), fb(e)) {
      if (!e.method.endsWith(iH)) return;
      const r = e.params, { topic: n, message: i, publishedAt: s, attestation: o } = r.data, a = { topic: n, message: i, publishedAt: s, transportType: zr.relay, attestation: o };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(P3({ type: "event", event: r.id }, a)), this.events.emit(r.id, a), await this.acknowledgePayload(e), await this.onMessageEvent(a);
    } else ip(e) && this.events.emit(si.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (this.events.emit(si.message, e), await this.recordMessageEvent(e));
  }
  async acknowledgePayload(e) {
    const r = rp(e.id, !0);
    await this.provider.connection.send(r);
  }
  unregisterProviderListeners() {
    this.provider.off(Gi.payload, this.onPayloadHandler), this.provider.off(Gi.connect, this.onConnectHandler), this.provider.off(Gi.disconnect, this.onDisconnectHandler), this.provider.off(Gi.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await o3();
    wW(async (r) => {
      e !== r && (e = r, r ? await this.restartTransport().catch((n) => this.logger.error(n)) : (this.hasExperiencedNetworkDisruption = !0, await this.transportDisconnect(), this.transportExplicitlyClosed = !1));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), this.requestsInFlight.clear(), clearTimeout(this.pingTimeout), this.events.emit(si.disconnect), this.connectionAttemptInProgress = !1, !this.transportExplicitlyClosed && (this.reconnectTimeout || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e));
    }, mt.toMiliseconds(sH))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (this.connectionAttemptInProgress && await new Promise((e) => {
      const r = setInterval(() => {
        this.connected && (clearInterval(r), e());
      }, this.connectionStatusPollingInterval);
    }), await this.transportOpen());
  }
}
var hV = Object.defineProperty, M3 = Object.getOwnPropertySymbols, dV = Object.prototype.hasOwnProperty, pV = Object.prototype.propertyIsEnumerable, I3 = (t, e, r) => e in t ? hV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, C3 = (t, e) => {
  for (var r in e || (e = {})) dV.call(e, r) && I3(t, r, e[r]);
  if (M3) for (var r of M3(e)) pV.call(e, r) && I3(t, r, e[r]);
  return t;
};
class Ec extends Qk {
  constructor(e, r, n, i = eo, s = void 0) {
    super(e, r, n, i), this.core = e, this.logger = r, this.name = n, this.map = /* @__PURE__ */ new Map(), this.version = oH, this.cached = [], this.initialized = !1, this.storagePrefix = eo, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o) => {
        this.getKey && o !== null && !mi(o) ? this.map.set(this.getKey(o), o) : Xz(o) ? this.map.set(o.id, o) : Zz(o) && this.map.set(o.topic, o);
      }), this.cached = [], this.initialized = !0);
    }, this.set = async (o, a) => {
      this.isInitialized(), this.map.has(o) ? await this.update(o, a) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o, value: a }), this.map.set(o, a), await this.persist());
    }, this.get = (o) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o }), this.getData(o)), this.getAll = (o) => (this.isInitialized(), o ? this.values.filter((a) => Object.keys(o).every((u) => HW(a[u], o[u]))) : this.values), this.update = async (o, a) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o, update: a });
      const u = C3(C3({}, this.getData(o)), a);
      this.map.set(o, u), await this.persist();
    }, this.delete = async (o, a) => {
      this.isInitialized(), this.map.has(o) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o, reason: a }), this.map.delete(o), this.addToRecentlyDeleted(o), await this.persist());
    }, this.logger = ci(r, this.name), this.storagePrefix = i, this.getKey = s;
  }
  get context() {
    return Si(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const r = this.map.get(e);
    if (!r) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: i } = ft("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(i), new Error(i);
      }
      const { message: n } = ft("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(n), new Error(n);
    }
    return r;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: r } = ft("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class gV {
  constructor(e, r) {
    this.core = e, this.logger = r, this.name = lH, this.version = hH, this.events = new kv(), this.initialized = !1, this.storagePrefix = eo, this.ignoredPayloadTypes = [Ro], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = !0, this.logger.trace("Initialized"));
    }, this.register = ({ methods: n }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...n])];
    }, this.create = async (n) => {
      this.isInitialized();
      const i = I1(), s = await this.core.crypto.setSymKey(i), o = En(mt.FIVE_MINUTES), a = { protocol: sE }, u = { topic: s, expiry: o, relay: a, active: !1, methods: n == null ? void 0 : n.methods }, l = e3({ protocol: this.core.protocol, version: this.core.version, topic: s, symKey: i, relay: a, expiryTimestamp: o, methods: n == null ? void 0 : n.methods });
      return this.events.emit(Qa.create, u), this.core.expirer.set(s, o), await this.pairings.set(s, u), await this.core.relayer.subscribe(s, { transportType: n == null ? void 0 : n.transportType }), { topic: s, uri: l };
    }, this.pair = async (n) => {
      this.isInitialized();
      const i = this.core.eventClient.createEvent({ properties: { topic: n == null ? void 0 : n.uri, trace: [Fs.pairing_started] } });
      this.isValidPair(n, i);
      const { topic: s, symKey: o, relay: a, expiryTimestamp: u, methods: l } = Qx(n.uri);
      i.props.properties.topic = s, i.addTrace(Fs.pairing_uri_validation_success), i.addTrace(Fs.pairing_uri_not_expired);
      let d;
      if (this.pairings.keys.includes(s)) {
        if (d = this.pairings.get(s), i.addTrace(Fs.existing_pairing), d.active) throw i.setError(_o.active_pairing_already_exists), new Error(`Pairing already exists: ${s}. Please try again with a new connection URI.`);
        i.addTrace(Fs.pairing_not_expired);
      }
      const p = u || En(mt.FIVE_MINUTES), w = { topic: s, relay: a, expiry: p, active: !1, methods: l };
      this.core.expirer.set(s, p), await this.pairings.set(s, w), i.addTrace(Fs.store_new_pairing), n.activatePairing && await this.activate({ topic: s }), this.events.emit(Qa.create, w), i.addTrace(Fs.emit_inactive_pairing), this.core.crypto.keychain.has(s) || await this.core.crypto.setSymKey(o, s), i.addTrace(Fs.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        i.setError(_o.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(s, { relay: a });
      } catch (A) {
        throw i.setError(_o.subscribe_pairing_topic_failure), A;
      }
      return i.addTrace(Fs.subscribe_pairing_topic_success), w;
    }, this.activate = async ({ topic: n }) => {
      this.isInitialized();
      const i = En(mt.THIRTY_DAYS);
      this.core.expirer.set(n, i), await this.pairings.update(n, { active: !0, expiry: i });
    }, this.ping = async (n) => {
      this.isInitialized(), await this.isValidPing(n);
      const { topic: i } = n;
      if (this.pairings.keys.includes(i)) {
        const s = await this.sendRequest(i, "wc_pairingPing", {}), { done: o, resolve: a, reject: u } = Ja();
        this.events.once(br("pairing_ping", s), ({ error: l }) => {
          l ? u(l) : a();
        }), await o();
      }
    }, this.updateExpiry = async ({ topic: n, expiry: i }) => {
      this.isInitialized(), await this.pairings.update(n, { expiry: i });
    }, this.updateMetadata = async ({ topic: n, metadata: i }) => {
      this.isInitialized(), await this.pairings.update(n, { peerMetadata: i });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (n) => {
      this.isInitialized(), await this.isValidDisconnect(n);
      const { topic: i } = n;
      this.pairings.keys.includes(i) && (await this.sendRequest(i, "wc_pairingDelete", Or("USER_DISCONNECTED")), await this.deletePairing(i));
    }, this.formatUriFromPairing = (n) => {
      this.isInitialized();
      const { topic: i, relay: s, expiry: o, methods: a } = n, u = this.core.crypto.keychain.get(i);
      return e3({ protocol: this.core.protocol, version: this.core.version, topic: i, symKey: u, relay: s, expiryTimestamp: o, methods: a });
    }, this.sendRequest = async (n, i, s) => {
      const o = ga(i, s), a = await this.core.crypto.encode(n, o), u = Mf[i].req;
      return this.core.history.set(n, o), this.core.relayer.publish(n, a, u), o.id;
    }, this.sendResult = async (n, i, s) => {
      const o = rp(n, s), a = await this.core.crypto.encode(i, o), u = await this.core.history.get(i, n), l = Mf[u.request.method].res;
      await this.core.relayer.publish(i, a, l), await this.core.history.resolve(o);
    }, this.sendError = async (n, i, s) => {
      const o = np(n, s), a = await this.core.crypto.encode(i, o), u = await this.core.history.get(i, n), l = Mf[u.request.method] ? Mf[u.request.method].res : Mf.unregistered_method.res;
      await this.core.relayer.publish(i, a, l), await this.core.history.resolve(o);
    }, this.deletePairing = async (n, i) => {
      await this.core.relayer.unsubscribe(n), await Promise.all([this.pairings.delete(n, Or("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(n), i ? Promise.resolve() : this.core.expirer.del(n)]);
    }, this.cleanup = async () => {
      const n = this.pairings.getAll().filter((i) => fa(i.expiry));
      await Promise.all(n.map((i) => this.deletePairing(i.topic)));
    }, this.onRelayEventRequest = (n) => {
      const { topic: i, payload: s } = n;
      switch (s.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i, s);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i, s);
        default:
          return this.onUnknownRpcMethodRequest(i, s);
      }
    }, this.onRelayEventResponse = async (n) => {
      const { topic: i, payload: s } = n, o = (await this.core.history.get(i, s.id)).request.method;
      switch (o) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i, s);
        default:
          return this.onUnknownRpcMethodResponse(o);
      }
    }, this.onPairingPingRequest = async (n, i) => {
      const { id: s } = i;
      try {
        this.isValidPing({ topic: n }), await this.sendResult(s, n, !0), this.events.emit(Qa.ping, { id: s, topic: n });
      } catch (o) {
        await this.sendError(s, n, o), this.logger.error(o);
      }
    }, this.onPairingPingResponse = (n, i) => {
      const { id: s } = i;
      setTimeout(() => {
        js(i) ? this.events.emit(br("pairing_ping", s), {}) : Qi(i) && this.events.emit(br("pairing_ping", s), { error: i.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (n, i) => {
      const { id: s } = i;
      try {
        this.isValidDisconnect({ topic: n }), await this.deletePairing(n), this.events.emit(Qa.delete, { id: s, topic: n });
      } catch (o) {
        await this.sendError(s, n, o), this.logger.error(o);
      }
    }, this.onUnknownRpcMethodRequest = async (n, i) => {
      const { id: s, method: o } = i;
      try {
        if (this.registeredMethods.includes(o)) return;
        const a = Or("WC_METHOD_UNSUPPORTED", o);
        await this.sendError(s, n, a), this.logger.error(a);
      } catch (a) {
        await this.sendError(s, n, a), this.logger.error(a);
      }
    }, this.onUnknownRpcMethodResponse = (n) => {
      this.registeredMethods.includes(n) || this.logger.error(Or("WC_METHOD_UNSUPPORTED", n));
    }, this.isValidPair = (n, i) => {
      var s;
      if (!gi(n)) {
        const { message: a } = ft("MISSING_OR_INVALID", `pair() params: ${n}`);
        throw i.setError(_o.malformed_pairing_uri), new Error(a);
      }
      if (!Jz(n.uri)) {
        const { message: a } = ft("MISSING_OR_INVALID", `pair() uri: ${n.uri}`);
        throw i.setError(_o.malformed_pairing_uri), new Error(a);
      }
      const o = Qx(n == null ? void 0 : n.uri);
      if (!((s = o == null ? void 0 : o.relay) != null && s.protocol)) {
        const { message: a } = ft("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw i.setError(_o.malformed_pairing_uri), new Error(a);
      }
      if (!(o != null && o.symKey)) {
        const { message: a } = ft("MISSING_OR_INVALID", "pair() uri#symKey");
        throw i.setError(_o.malformed_pairing_uri), new Error(a);
      }
      if (o != null && o.expiryTimestamp && mt.toMiliseconds(o == null ? void 0 : o.expiryTimestamp) < Date.now()) {
        i.setError(_o.pairing_expired);
        const { message: a } = ft("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a);
      }
    }, this.isValidPing = async (n) => {
      if (!gi(n)) {
        const { message: s } = ft("MISSING_OR_INVALID", `ping() params: ${n}`);
        throw new Error(s);
      }
      const { topic: i } = n;
      await this.isValidPairingTopic(i);
    }, this.isValidDisconnect = async (n) => {
      if (!gi(n)) {
        const { message: s } = ft("MISSING_OR_INVALID", `disconnect() params: ${n}`);
        throw new Error(s);
      }
      const { topic: i } = n;
      await this.isValidPairingTopic(i);
    }, this.isValidPairingTopic = async (n) => {
      if (!dn(n, !1)) {
        const { message: i } = ft("MISSING_OR_INVALID", `pairing topic should be a string: ${n}`);
        throw new Error(i);
      }
      if (!this.pairings.keys.includes(n)) {
        const { message: i } = ft("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n}`);
        throw new Error(i);
      }
      if (fa(this.pairings.get(n).expiry)) {
        await this.deletePairing(n);
        const { message: i } = ft("EXPIRED", `pairing topic: ${n}`);
        throw new Error(i);
      }
    }, this.core = e, this.logger = ci(r, this.name), this.pairings = new Ec(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return Si(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(si.message, async (e) => {
      const { topic: r, message: n, transportType: i } = e;
      if (!this.pairings.keys.includes(r) || i === zr.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(n))) return;
      const s = await this.core.crypto.decode(r, n);
      try {
        fb(s) ? (this.core.history.set(r, s), this.onRelayEventRequest({ topic: r, payload: s })) : ip(s) && (await this.core.history.resolve(s), await this.onRelayEventResponse({ topic: r, payload: s }), this.core.history.delete(r, s.id));
      } catch (o) {
        this.logger.error(o);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(Xi.expired, async (e) => {
      const { topic: r } = F8(e.target);
      r && this.pairings.keys.includes(r) && (await this.deletePairing(r, !0), this.events.emit(Qa.expire, { topic: r }));
    });
  }
}
class mV extends Yk {
  constructor(e, r) {
    super(e, r), this.core = e, this.logger = r, this.records = /* @__PURE__ */ new Map(), this.events = new ns.EventEmitter(), this.name = dH, this.version = pH, this.cached = [], this.initialized = !1, this.storagePrefix = eo, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.records.set(n.id, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.set = (n, i, s) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: n, request: i, chainId: s }), this.records.has(i.id)) return;
      const o = { id: i.id, topic: n, request: { method: i.method, params: i.params || null }, chainId: s, expiry: En(mt.THIRTY_DAYS) };
      this.records.set(o.id, o), this.persist(), this.events.emit(ms.created, o);
    }, this.resolve = async (n) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: n }), !this.records.has(n.id)) return;
      const i = await this.getRecord(n.id);
      typeof i.response > "u" && (i.response = Qi(n) ? { error: n.error } : { result: n.result }, this.records.set(i.id, i), this.persist(), this.events.emit(ms.updated, i));
    }, this.get = async (n, i) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: n, id: i }), await this.getRecord(i)), this.delete = (n, i) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i }), this.values.forEach((s) => {
        if (s.topic === n) {
          if (typeof i < "u" && s.id !== i) return;
          this.records.delete(s.id), this.events.emit(ms.deleted, s);
        }
      }), this.persist();
    }, this.exists = async (n, i) => (this.isInitialized(), this.records.has(i) ? (await this.getRecord(i)).topic === n : !1), this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.logger = ci(r, this.name);
  }
  get context() {
    return Si(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((r) => {
      if (typeof r.response < "u") return;
      const n = { topic: r.topic, request: ga(r.request.method, r.request.params, r.id), chainId: r.chainId };
      return e.push(n);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const r = this.records.get(e);
    if (!r) {
      const { message: n } = ft("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(n);
    }
    return r;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(ms.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: r } = ft("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(ms.created, (e) => {
      const r = ms.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e });
    }), this.events.on(ms.updated, (e) => {
      const r = ms.updated;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e });
    }), this.events.on(ms.deleted, (e) => {
      const r = ms.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, record: e });
    }), this.core.heartbeat.on(Ou.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = !1;
      this.records.forEach((r) => {
        mt.toMiliseconds(r.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${r.id}`), this.records.delete(r.id), this.events.emit(ms.deleted, r, !1), e = !0);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class vV extends t$ {
  constructor(e, r) {
    super(e, r), this.core = e, this.logger = r, this.expirations = /* @__PURE__ */ new Map(), this.events = new ns.EventEmitter(), this.name = gH, this.version = mH, this.cached = [], this.initialized = !1, this.storagePrefix = eo, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n) => this.expirations.set(n.target, n)), this.cached = [], this.registerEventListeners(), this.initialized = !0);
    }, this.has = (n) => {
      try {
        const i = this.formatTarget(n);
        return typeof this.getExpiration(i) < "u";
      } catch {
        return !1;
      }
    }, this.set = (n, i) => {
      this.isInitialized();
      const s = this.formatTarget(n), o = { target: s, expiry: i };
      this.expirations.set(s, o), this.checkExpiry(s, o), this.events.emit(Xi.created, { target: s, expiration: o });
    }, this.get = (n) => {
      this.isInitialized();
      const i = this.formatTarget(n);
      return this.getExpiration(i);
    }, this.del = (n) => {
      if (this.isInitialized(), this.has(n)) {
        const i = this.formatTarget(n), s = this.getExpiration(i);
        this.expirations.delete(i), this.events.emit(Xi.deleted, { target: i, expiration: s });
      }
    }, this.on = (n, i) => {
      this.events.on(n, i);
    }, this.once = (n, i) => {
      this.events.once(n, i);
    }, this.off = (n, i) => {
      this.events.off(n, i);
    }, this.removeListener = (n, i) => {
      this.events.removeListener(n, i);
    }, this.logger = ci(r, this.name);
  }
  get context() {
    return Si(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return Wq(e);
    if (typeof e == "number") return Hq(e);
    const { message: r } = ft("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(r);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(Xi.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: r } = ft("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(r), new Error(r);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const r = this.expirations.get(e);
    if (!r) {
      const { message: n } = ft("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(n), new Error(n);
    }
    return r;
  }
  checkExpiry(e, r) {
    const { expiry: n } = r;
    mt.toMiliseconds(n) - Date.now() <= 0 && this.expire(e, r);
  }
  expire(e, r) {
    this.expirations.delete(e), this.events.emit(Xi.expired, { target: e, expiration: r });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, r) => this.checkExpiry(r, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(Ou.pulse, () => this.checkExpirations()), this.events.on(Xi.created, (e) => {
      const r = Xi.created;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    }), this.events.on(Xi.expired, (e) => {
      const r = Xi.expired;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    }), this.events.on(Xi.deleted, (e) => {
      const r = Xi.deleted;
      this.logger.info(`Emitting ${r}`), this.logger.debug({ type: "event", event: r, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
}
class bV extends r$ {
  constructor(e, r, n) {
    super(e, r, n), this.core = e, this.logger = r, this.store = n, this.name = vH, this.verifyUrlV3 = yH, this.storagePrefix = eo, this.version = nE, this.init = async () => {
      var i;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && mt.toMiliseconds((i = this.publicKey) == null ? void 0 : i.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }, this.register = async (i) => {
      if (!Zl() || this.isDevEnv) return;
      const s = window.location.origin, { id: o, decryptedId: a } = i, u = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${s}&id=${o}&decryptedId=${a}`;
      try {
        const l = Kl(), d = this.startAbortTimer(mt.ONE_SECOND * 5), p = await new Promise((w, A) => {
          const P = () => {
            window.removeEventListener("message", L), l.body.removeChild(N), A("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", P);
          const N = l.createElement("iframe");
          N.src = u, N.style.display = "none", N.addEventListener("error", P, { signal: this.abortController.signal });
          const L = ($) => {
            if ($.data && typeof $.data == "string") try {
              const B = JSON.parse($.data);
              if (B.type === "verify_attestation") {
                if (v1(B.attestation).payload.id !== o) return;
                clearInterval(d), l.body.removeChild(N), this.abortController.signal.removeEventListener("abort", P), window.removeEventListener("message", L), w(B.attestation === null ? "" : B.attestation);
              }
            } catch (B) {
              this.logger.warn(B);
            }
          };
          l.body.appendChild(N), window.addEventListener("message", L, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", p), p;
      } catch (l) {
        this.logger.warn(l);
      }
      return "";
    }, this.resolve = async (i) => {
      if (this.isDevEnv) return "";
      const { attestationId: s, hash: o, encryptedId: a } = i;
      if (s === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (s) {
        if (v1(s).payload.id !== a) return;
        const l = await this.isValidJwtAttestation(s);
        if (l) {
          if (!l.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return l;
        }
      }
      if (!o) return;
      const u = this.getVerifyUrl(i == null ? void 0 : i.verifyUrl);
      return this.fetchAttestation(o, u);
    }, this.fetchAttestation = async (i, s) => {
      this.logger.debug(`resolving attestation: ${i} from url: ${s}`);
      const o = this.startAbortTimer(mt.ONE_SECOND * 5), a = await fetch(`${s}/attestation/${i}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o), a.status === 200 ? await a.json() : void 0;
    }, this.getVerifyUrl = (i) => {
      let s = i || Wf;
      return wH.includes(s) || (this.logger.info(`verify url: ${s}, not included in trusted list, assigning default: ${Wf}`), s = Wf), s;
    }, this.fetchPublicKey = async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const i = this.startAbortTimer(mt.FIVE_SECONDS), s = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(i), await s.json();
      } catch (i) {
        this.logger.warn(i);
      }
    }, this.persistPublicKey = async (i) => {
      this.logger.debug("persisting public key to local storage", i), await this.store.setItem(this.storeKey, i), this.publicKey = i;
    }, this.removePublicKey = async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }, this.isValidJwtAttestation = async (i) => {
      const s = await this.getPublicKey();
      try {
        if (s) return this.validateAttestation(i, s);
      } catch (a) {
        this.logger.error(a), this.logger.warn("error validating attestation");
      }
      const o = await this.fetchAndPersistPublicKey();
      try {
        if (o) return this.validateAttestation(i, o);
      } catch (a) {
        this.logger.error(a), this.logger.warn("error validating attestation");
      }
    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (s) => {
        const o = await this.fetchPublicKey();
        o && (await this.persistPublicKey(o), s(o));
      });
      const i = await this.fetchPromise;
      return this.fetchPromise = void 0, i;
    }, this.validateAttestation = (i, s) => {
      const o = Rz(i, s.publicKey), a = { hasExpired: mt.toMiliseconds(o.exp) < Date.now(), payload: o };
      if (a.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a.payload.origin, isScam: a.payload.isScam, isVerified: a.payload.isVerified };
    }, this.logger = ci(r, this.name), this.abortController = new AbortController(), this.isDevEnv = ib(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return Si(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), mt.toMiliseconds(e));
  }
}
class yV extends n$ {
  constructor(e, r) {
    super(e, r), this.projectId = e, this.logger = r, this.context = xH, this.registerDeviceToken = async (n) => {
      const { clientId: i, token: s, notificationType: o, enableEncrypted: a = !1 } = n, u = `${_H}/${this.projectId}/clients`;
      await fetch(u, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i, type: o, token: s, always_raw: a }) });
    }, this.logger = ci(r, this.context);
  }
}
var wV = Object.defineProperty, T3 = Object.getOwnPropertySymbols, xV = Object.prototype.hasOwnProperty, _V = Object.prototype.propertyIsEnumerable, R3 = (t, e, r) => e in t ? wV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Tf = (t, e) => {
  for (var r in e || (e = {})) xV.call(e, r) && R3(t, r, e[r]);
  if (T3) for (var r of T3(e)) _V.call(e, r) && R3(t, r, e[r]);
  return t;
};
class EV extends i$ {
  constructor(e, r, n = !0) {
    super(e, r, n), this.core = e, this.logger = r, this.context = SH, this.storagePrefix = eo, this.storageVersion = EH, this.events = /* @__PURE__ */ new Map(), this.shouldPersist = !1, this.init = async () => {
      if (!ib()) try {
        const i = { eventId: Ux(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: L8(this.core.relayer.protocol, this.core.relayer.version, T1) } } };
        await this.sendEvent([i]);
      } catch (i) {
        this.logger.warn(i);
      }
    }, this.createEvent = (i) => {
      const { event: s = "ERROR", type: o = "", properties: { topic: a, trace: u } } = i, l = Ux(), d = this.core.projectId || "", p = Date.now(), w = Tf({ eventId: l, timestamp: p, props: { event: s, type: o, properties: { topic: a, trace: u } }, bundleId: d, domain: this.getAppDomain() }, this.setMethods(l));
      return this.telemetryEnabled && (this.events.set(l, w), this.shouldPersist = !0), w;
    }, this.getEvent = (i) => {
      const { eventId: s, topic: o } = i;
      if (s) return this.events.get(s);
      const a = Array.from(this.events.values()).find((u) => u.props.properties.topic === o);
      if (a) return Tf(Tf({}, a), this.setMethods(a.eventId));
    }, this.deleteEvent = (i) => {
      const { eventId: s } = i;
      this.events.delete(s), this.shouldPersist = !0;
    }, this.setEventListeners = () => {
      this.core.heartbeat.on(Ou.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((i) => {
          mt.fromMiliseconds(Date.now()) - mt.fromMiliseconds(i.timestamp) > AH && (this.events.delete(i.eventId), this.shouldPersist = !0);
        });
      });
    }, this.setMethods = (i) => ({ addTrace: (s) => this.addTrace(i, s), setError: (s) => this.setError(i, s) }), this.addTrace = (i, s) => {
      const o = this.events.get(i);
      o && (o.props.properties.trace.push(s), this.events.set(i, o), this.shouldPersist = !0);
    }, this.setError = (i, s) => {
      const o = this.events.get(i);
      o && (o.props.type = s, o.timestamp = Date.now(), this.events.set(i, o), this.shouldPersist = !0);
    }, this.persist = async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = !1;
    }, this.restore = async () => {
      try {
        const i = await this.core.storage.getItem(this.storageKey) || [];
        if (!i.length) return;
        i.forEach((s) => {
          this.events.set(s.eventId, Tf(Tf({}, s), this.setMethods(s.eventId)));
        });
      } catch (i) {
        this.logger.warn(i);
      }
    }, this.submit = async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const i = [];
      for (const [s, o] of this.events) o.props.type && i.push(o);
      if (i.length !== 0) try {
        if ((await this.sendEvent(i)).ok) for (const s of i) this.events.delete(s.eventId), this.shouldPersist = !0;
      } catch (s) {
        this.logger.warn(s);
      }
    }, this.sendEvent = async (i) => {
      const s = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${PH}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${T1}${s}`, { method: "POST", body: JSON.stringify(i) });
    }, this.getAppDomain = () => N8().url, this.logger = ci(r, this.context), this.telemetryEnabled = n, n ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
}
var SV = Object.defineProperty, D3 = Object.getOwnPropertySymbols, AV = Object.prototype.hasOwnProperty, PV = Object.prototype.propertyIsEnumerable, O3 = (t, e, r) => e in t ? SV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, N3 = (t, e) => {
  for (var r in e || (e = {})) AV.call(e, r) && O3(t, r, e[r]);
  if (D3) for (var r of D3(e)) PV.call(e, r) && O3(t, r, e[r]);
  return t;
};
class lb extends Gk {
  constructor(e) {
    var r;
    super(e), this.protocol = rE, this.version = nE, this.name = iE, this.events = new ns.EventEmitter(), this.initialized = !1, this.on = (o, a) => this.events.on(o, a), this.once = (o, a) => this.events.once(o, a), this.off = (o, a) => this.events.off(o, a), this.removeListener = (o, a) => this.events.removeListener(o, a), this.dispatchEnvelope = ({ topic: o, message: a, sessionExists: u }) => {
      if (!o || !a) return;
      const l = { topic: o, message: a, publishedAt: Date.now(), transportType: zr.link_mode };
      this.relayer.onLinkMessageEvent(l, { sessionExists: u });
    }, this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || oE, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const n = $0({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : KW.logger }), { logger: i, chunkLoggerController: s } = Vk({ opts: n, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = s, (r = this.logChunkController) != null && r.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var o, a;
      (o = this.logChunkController) != null && o.downloadLogsBlobInBrowser && ((a = this.logChunkController) == null || a.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = ci(i, this.name), this.heartbeat = new UL(), this.crypto = new ZK(this, this.logger, e == null ? void 0 : e.keychain), this.history = new mV(this, this.logger), this.expirer = new vV(this, this.logger), this.storage = e != null && e.storage ? e.storage : new yk(N3(N3({}, VW), e == null ? void 0 : e.storageOptions)), this.relayer = new lV({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new gV(this, this.logger), this.verify = new bV(this, this.logger, this.storage), this.echoClient = new yV(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new EV(this, this.logger, e == null ? void 0 : e.telemetryEnabled);
  }
  static async init(e) {
    const r = new lb(e);
    await r.initialize();
    const n = await r.crypto.getClientId();
    return await r.storage.setItem(aH, n), r;
  }
  get context() {
    return Si(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(g3, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.eventClient.init(), this.linkModeSupportedApps = await this.storage.getItem(g3) || [], this.initialized = !0, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
}
const MV = lb, bE = "wc", yE = 2, wE = "client", hb = `${bE}@${yE}:${wE}:`, mm = { name: wE, logger: "error" }, L3 = "WALLETCONNECT_DEEPLINK_CHOICE", IV = "proposal", xE = "Proposal expired", CV = "session", Kc = mt.SEVEN_DAYS, TV = "engine", In = { wc_sessionPropose: { req: { ttl: mt.FIVE_MINUTES, prompt: !0, tag: 1100 }, res: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1101 }, reject: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1120 }, autoReject: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1121 } }, wc_sessionSettle: { req: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1102 }, res: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: mt.ONE_DAY, prompt: !1, tag: 1104 }, res: { ttl: mt.ONE_DAY, prompt: !1, tag: 1105 } }, wc_sessionExtend: { req: { ttl: mt.ONE_DAY, prompt: !1, tag: 1106 }, res: { ttl: mt.ONE_DAY, prompt: !1, tag: 1107 } }, wc_sessionRequest: { req: { ttl: mt.FIVE_MINUTES, prompt: !0, tag: 1108 }, res: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1109 } }, wc_sessionEvent: { req: { ttl: mt.FIVE_MINUTES, prompt: !0, tag: 1110 }, res: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1111 } }, wc_sessionDelete: { req: { ttl: mt.ONE_DAY, prompt: !1, tag: 1112 }, res: { ttl: mt.ONE_DAY, prompt: !1, tag: 1113 } }, wc_sessionPing: { req: { ttl: mt.ONE_DAY, prompt: !1, tag: 1114 }, res: { ttl: mt.ONE_DAY, prompt: !1, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: mt.ONE_HOUR, prompt: !0, tag: 1116 }, res: { ttl: mt.ONE_HOUR, prompt: !1, tag: 1117 }, reject: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1118 }, autoReject: { ttl: mt.FIVE_MINUTES, prompt: !1, tag: 1119 } } }, vm = { min: mt.FIVE_MINUTES, max: mt.SEVEN_DAYS }, ks = { idle: "IDLE", active: "ACTIVE" }, RV = "request", DV = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"], OV = "wc", NV = "auth", LV = "authKeys", kV = "pairingTopics", $V = "requests", op = `${OV}@${1.5}:${NV}:`, Rd = `${op}:PUB_KEY`;
var BV = Object.defineProperty, FV = Object.defineProperties, jV = Object.getOwnPropertyDescriptors, k3 = Object.getOwnPropertySymbols, UV = Object.prototype.hasOwnProperty, qV = Object.prototype.propertyIsEnumerable, $3 = (t, e, r) => e in t ? BV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, tn = (t, e) => {
  for (var r in e || (e = {})) UV.call(e, r) && $3(t, r, e[r]);
  if (k3) for (var r of k3(e)) qV.call(e, r) && $3(t, r, e[r]);
  return t;
}, bs = (t, e) => FV(t, jV(e));
class zV extends o$ {
  constructor(e) {
    super(e), this.name = TV, this.events = new kv(), this.initialized = !1, this.requestQueue = { state: ks.idle, queue: [] }, this.sessionRequestQueue = { state: ks.idle, queue: [] }, this.requestQueueDelay = mt.ONE_SECOND, this.expectedPairingMethodMap = /* @__PURE__ */ new Map(), this.recentlyDeletedMap = /* @__PURE__ */ new Map(), this.recentlyDeletedLimit = 200, this.relayMessageCache = [], this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(In) }), this.initialized = !0, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, mt.toMiliseconds(this.requestQueueDelay)));
    }, this.connect = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const n = bs(tn({}, r), { requiredNamespaces: r.requiredNamespaces || {}, optionalNamespaces: r.optionalNamespaces || {} });
      await this.isValidConnect(n);
      const { pairingTopic: i, requiredNamespaces: s, optionalNamespaces: o, sessionProperties: a, relays: u } = n;
      let l = i, d, p = !1;
      try {
        l && (p = this.client.core.pairing.pairings.get(l).active);
      } catch (W) {
        throw this.client.logger.error(`connect() -> pairing.get(${l}) failed`), W;
      }
      if (!l || !p) {
        const { topic: W, uri: V } = await this.client.core.pairing.create();
        l = W, d = V;
      }
      if (!l) {
        const { message: W } = ft("NO_MATCHING_KEY", `connect() pairing topic: ${l}`);
        throw new Error(W);
      }
      const w = await this.client.core.crypto.generateKeyPair(), A = In.wc_sessionPropose.req.ttl || mt.FIVE_MINUTES, P = En(A), N = tn({ requiredNamespaces: s, optionalNamespaces: o, relays: u ?? [{ protocol: sE }], proposer: { publicKey: w, metadata: this.client.metadata }, expiryTimestamp: P, pairingTopic: l }, a && { sessionProperties: a }), { reject: L, resolve: $, done: B } = Ja(A, xE);
      this.events.once(br("session_connect"), async ({ error: W, session: V }) => {
        if (W) L(W);
        else if (V) {
          V.self.publicKey = w;
          const te = bs(tn({}, V), { pairingTopic: N.pairingTopic, requiredNamespaces: N.requiredNamespaces, optionalNamespaces: N.optionalNamespaces, transportType: zr.relay });
          await this.client.session.set(V.topic, te), await this.setExpiry(V.topic, V.expiry), l && await this.client.core.pairing.updateMetadata({ topic: l, metadata: V.peer.metadata }), this.cleanupDuplicatePairings(te), $(te);
        }
      });
      const H = await this.sendRequest({ topic: l, method: "wc_sessionPropose", params: N, throwOnFailedPublish: !0 });
      return await this.setProposal(H, tn({ id: H }, N)), { uri: d, approval: B };
    }, this.pair = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(r);
      } catch (n) {
        throw this.client.logger.error("pair() failed"), n;
      }
    }, this.approve = async (r) => {
      var n, i, s;
      const o = this.client.core.eventClient.createEvent({ properties: { topic: (n = r == null ? void 0 : r.id) == null ? void 0 : n.toString(), trace: [vs.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (K) {
        throw o.setError(Va.no_internet_connection), K;
      }
      try {
        await this.isValidProposalId(r == null ? void 0 : r.id);
      } catch (K) {
        throw this.client.logger.error(`approve() -> proposal.get(${r == null ? void 0 : r.id}) failed`), o.setError(Va.proposal_not_found), K;
      }
      try {
        await this.isValidApprove(r);
      } catch (K) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), o.setError(Va.session_approve_namespace_validation_failure), K;
      }
      const { id: a, relayProtocol: u, namespaces: l, sessionProperties: d, sessionConfig: p } = r, w = this.client.proposal.get(a);
      this.client.core.eventClient.deleteEvent({ eventId: o.eventId });
      const { pairingTopic: A, proposer: P, requiredNamespaces: N, optionalNamespaces: L } = w;
      let $ = (i = this.client.core.eventClient) == null ? void 0 : i.getEvent({ topic: A });
      $ || ($ = (s = this.client.core.eventClient) == null ? void 0 : s.createEvent({ type: vs.session_approve_started, properties: { topic: A, trace: [vs.session_approve_started, vs.session_namespaces_validation_success] } }));
      const B = await this.client.core.crypto.generateKeyPair(), H = P.publicKey, W = await this.client.core.crypto.generateSharedKey(B, H), V = tn(tn({ relay: { protocol: u ?? "irn" }, namespaces: l, controller: { publicKey: B, metadata: this.client.metadata }, expiry: En(Kc) }, d && { sessionProperties: d }), p && { sessionConfig: p }), te = zr.relay;
      $.addTrace(vs.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(W, { transportType: te });
      } catch (K) {
        throw $.setError(Va.subscribe_session_topic_failure), K;
      }
      $.addTrace(vs.subscribe_session_topic_success);
      const R = bs(tn({}, V), { topic: W, requiredNamespaces: N, optionalNamespaces: L, pairingTopic: A, acknowledged: !1, self: V.controller, peer: { publicKey: P.publicKey, metadata: P.metadata }, controller: B, transportType: zr.relay });
      await this.client.session.set(W, R), $.addTrace(vs.store_session);
      try {
        $.addTrace(vs.publishing_session_settle), await this.sendRequest({ topic: W, method: "wc_sessionSettle", params: V, throwOnFailedPublish: !0 }).catch((K) => {
          throw $ == null || $.setError(Va.session_settle_publish_failure), K;
        }), $.addTrace(vs.session_settle_publish_success), $.addTrace(vs.publishing_session_approve), await this.sendResult({ id: a, topic: A, result: { relay: { protocol: u ?? "irn" }, responderPublicKey: B }, throwOnFailedPublish: !0 }).catch((K) => {
          throw $ == null || $.setError(Va.session_approve_publish_failure), K;
        }), $.addTrace(vs.session_approve_publish_success);
      } catch (K) {
        throw this.client.logger.error(K), this.client.session.delete(W, Or("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(W), K;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: $.eventId }), await this.client.core.pairing.updateMetadata({ topic: A, metadata: P.metadata }), await this.client.proposal.delete(a, Or("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: A }), await this.setExpiry(W, En(Kc)), { topic: W, acknowledged: () => Promise.resolve(this.client.session.get(W)) };
    }, this.reject = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(r);
      } catch (o) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), o;
      }
      const { id: n, reason: i } = r;
      let s;
      try {
        s = this.client.proposal.get(n).pairingTopic;
      } catch (o) {
        throw this.client.logger.error(`reject() -> proposal.get(${n}) failed`), o;
      }
      s && (await this.sendError({ id: n, topic: s, error: i, rpcOpts: In.wc_sessionPropose.reject }), await this.client.proposal.delete(n, Or("USER_DISCONNECTED")));
    }, this.update = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(r);
      } catch (p) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), p;
      }
      const { topic: n, namespaces: i } = r, { done: s, resolve: o, reject: a } = Ja(), u = la(), l = ic().toString(), d = this.client.session.get(n).namespaces;
      return this.events.once(br("session_update", u), ({ error: p }) => {
        p ? a(p) : o();
      }), await this.client.session.update(n, { namespaces: i }), await this.sendRequest({ topic: n, method: "wc_sessionUpdate", params: { namespaces: i }, throwOnFailedPublish: !0, clientRpcId: u, relayRpcId: l }).catch((p) => {
        this.client.logger.error(p), this.client.session.update(n, { namespaces: d }), a(p);
      }), { acknowledged: s };
    }, this.extend = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(r);
      } catch (u) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), u;
      }
      const { topic: n } = r, i = la(), { done: s, resolve: o, reject: a } = Ja();
      return this.events.once(br("session_extend", i), ({ error: u }) => {
        u ? a(u) : o();
      }), await this.setExpiry(n, En(Kc)), this.sendRequest({ topic: n, method: "wc_sessionExtend", params: {}, clientRpcId: i, throwOnFailedPublish: !0 }).catch((u) => {
        a(u);
      }), { acknowledged: s };
    }, this.request = async (r) => {
      this.isInitialized();
      try {
        await this.isValidRequest(r);
      } catch (P) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), P;
      }
      const { chainId: n, request: i, topic: s, expiry: o = In.wc_sessionRequest.req.ttl } = r, a = this.client.session.get(s);
      (a == null ? void 0 : a.transportType) === zr.relay && await this.confirmOnlineStateOrThrow();
      const u = la(), l = ic().toString(), { done: d, resolve: p, reject: w } = Ja(o, "Request expired. Please try again.");
      this.events.once(br("session_request", u), ({ error: P, result: N }) => {
        P ? w(P) : p(N);
      });
      const A = this.getAppLinkIfEnabled(a.peer.metadata, a.transportType);
      return A ? (await this.sendRequest({ clientRpcId: u, relayRpcId: l, topic: s, method: "wc_sessionRequest", params: { request: bs(tn({}, i), { expiryTimestamp: En(o) }), chainId: n }, expiry: o, throwOnFailedPublish: !0, appLink: A }).catch((P) => w(P)), this.client.events.emit("session_request_sent", { topic: s, request: i, chainId: n, id: u }), await d()) : await Promise.all([new Promise(async (P) => {
        await this.sendRequest({ clientRpcId: u, relayRpcId: l, topic: s, method: "wc_sessionRequest", params: { request: bs(tn({}, i), { expiryTimestamp: En(o) }), chainId: n }, expiry: o, throwOnFailedPublish: !0 }).catch((N) => w(N)), this.client.events.emit("session_request_sent", { topic: s, request: i, chainId: n, id: u }), P();
      }), new Promise(async (P) => {
        var N;
        if (!((N = a.sessionConfig) != null && N.disableDeepLink)) {
          const L = await Gq(this.client.core.storage, L3);
          await Kq({ id: u, topic: s, wcDeepLink: L });
        }
        P();
      }), d()]).then((P) => P[2]);
    }, this.respond = async (r) => {
      this.isInitialized(), await this.isValidRespond(r);
      const { topic: n, response: i } = r, { id: s } = i, o = this.client.session.get(n);
      o.transportType === zr.relay && await this.confirmOnlineStateOrThrow();
      const a = this.getAppLinkIfEnabled(o.peer.metadata, o.transportType);
      js(i) ? await this.sendResult({ id: s, topic: n, result: i.result, throwOnFailedPublish: !0, appLink: a }) : Qi(i) && await this.sendError({ id: s, topic: n, error: i.error, appLink: a }), this.cleanupAfterResponse(r);
    }, this.ping = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(r);
      } catch (i) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), i;
      }
      const { topic: n } = r;
      if (this.client.session.keys.includes(n)) {
        const i = la(), s = ic().toString(), { done: o, resolve: a, reject: u } = Ja();
        this.events.once(br("session_ping", i), ({ error: l }) => {
          l ? u(l) : a();
        }), await Promise.all([this.sendRequest({ topic: n, method: "wc_sessionPing", params: {}, throwOnFailedPublish: !0, clientRpcId: i, relayRpcId: s }), o()]);
      } else this.client.core.pairing.pairings.keys.includes(n) && await this.client.core.pairing.ping({ topic: n });
    }, this.emit = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(r);
      const { topic: n, event: i, chainId: s } = r, o = ic().toString();
      await this.sendRequest({ topic: n, method: "wc_sessionEvent", params: { event: i, chainId: s }, throwOnFailedPublish: !0, relayRpcId: o });
    }, this.disconnect = async (r) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(r);
      const { topic: n } = r;
      if (this.client.session.keys.includes(n)) await this.sendRequest({ topic: n, method: "wc_sessionDelete", params: Or("USER_DISCONNECTED"), throwOnFailedPublish: !0 }), await this.deleteSession({ topic: n, emitEvent: !1 });
      else if (this.client.core.pairing.pairings.keys.includes(n)) await this.client.core.pairing.disconnect({ topic: n });
      else {
        const { message: i } = ft("MISMATCHED_TOPIC", `Session or pairing topic not found: ${n}`);
        throw new Error(i);
      }
    }, this.find = (r) => (this.isInitialized(), this.client.session.getAll().filter((n) => Gz(n, r))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (r, n) => {
      var i;
      this.isInitialized(), this.isValidAuthenticate(r);
      const s = n && this.client.core.linkModeSupportedApps.includes(n) && ((i = this.client.metadata.redirect) == null ? void 0 : i.linkMode), o = s ? zr.link_mode : zr.relay;
      o === zr.relay && await this.confirmOnlineStateOrThrow();
      const { chains: a, statement: u = "", uri: l, domain: d, nonce: p, type: w, exp: A, nbf: P, methods: N = [], expiry: L } = r, $ = [...r.resources || []], { topic: B, uri: H } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: o });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: B, uri: H } });
      const W = await this.client.core.crypto.generateKeyPair(), V = Td(W);
      if (await Promise.all([this.client.auth.authKeys.set(Rd, { responseTopic: V, publicKey: W }), this.client.auth.pairingTopics.set(V, { topic: V, pairingTopic: B })]), await this.client.core.relayer.subscribe(V, { transportType: o }), this.client.logger.info(`sending request to new pairing topic: ${B}`), N.length > 0) {
        const { namespace: _ } = hu(a[0]);
        let E = gz(_, "request", N);
        Cd($) && (E = vz(E, $.pop())), $.push(E);
      }
      const te = L && L > In.wc_sessionAuthenticate.req.ttl ? L : In.wc_sessionAuthenticate.req.ttl, R = { authPayload: { type: w ?? "caip122", chains: a, statement: u, aud: l, domain: d, version: "1", nonce: p, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: A, nbf: P, resources: $ }, requester: { publicKey: W, metadata: this.client.metadata }, expiryTimestamp: En(te) }, K = { eip155: { chains: a, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...N])], events: ["chainChanged", "accountsChanged"] } }, ge = { requiredNamespaces: {}, optionalNamespaces: K, relays: [{ protocol: "irn" }], pairingTopic: B, proposer: { publicKey: W, metadata: this.client.metadata }, expiryTimestamp: En(In.wc_sessionPropose.req.ttl) }, { done: Ee, resolve: Y, reject: S } = Ja(te, "Request expired"), m = async ({ error: _, session: E }) => {
        if (this.events.off(br("session_request", g), f), _) S(_);
        else if (E) {
          E.self.publicKey = W, await this.client.session.set(E.topic, E), await this.setExpiry(E.topic, E.expiry), B && await this.client.core.pairing.updateMetadata({ topic: B, metadata: E.peer.metadata });
          const v = this.client.session.get(E.topic);
          await this.deleteProposal(b), Y({ session: v });
        }
      }, f = async (_) => {
        var E, v, M;
        if (await this.deletePendingAuthRequest(g, { message: "fulfilled", code: 0 }), _.error) {
          const J = Or("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return _.error.code === J.code ? void 0 : (this.events.off(br("session_connect"), m), S(_.error.message));
        }
        await this.deleteProposal(b), this.events.off(br("session_connect"), m);
        const { cacaos: I, responder: F } = _.result, ce = [], D = [];
        for (const J of I) {
          await Wx({ cacao: J, projectId: this.client.core.projectId }) || (this.client.logger.error(J, "Signature verification failed"), S(Or("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: Q } = J, T = Cd(Q.resources), X = [M1(Q.iss)], re = u0(Q.iss);
          if (T) {
            const pe = Hx(T), ie = Kx(T);
            ce.push(...pe), X.push(...ie);
          }
          for (const pe of X) D.push(`${pe}:${re}`);
        }
        const oe = await this.client.core.crypto.generateSharedKey(W, F.publicKey);
        let Z;
        ce.length > 0 && (Z = { topic: oe, acknowledged: !0, self: { publicKey: W, metadata: this.client.metadata }, peer: F, controller: F.publicKey, expiry: En(Kc), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: B, namespaces: t3([...new Set(ce)], [...new Set(D)]), transportType: o }, await this.client.core.relayer.subscribe(oe, { transportType: o }), await this.client.session.set(oe, Z), B && await this.client.core.pairing.updateMetadata({ topic: B, metadata: F.metadata }), Z = this.client.session.get(oe)), (E = this.client.metadata.redirect) != null && E.linkMode && (v = F.metadata.redirect) != null && v.linkMode && (M = F.metadata.redirect) != null && M.universal && n && (this.client.core.addLinkModeSupportedApp(F.metadata.redirect.universal), this.client.session.update(oe, { transportType: zr.link_mode })), Y({ auths: I, session: Z });
      }, g = la(), b = la();
      this.events.once(br("session_connect"), m), this.events.once(br("session_request", g), f);
      let x;
      try {
        if (s) {
          const _ = ga("wc_sessionAuthenticate", R, g);
          this.client.core.history.set(B, _);
          const E = await this.client.core.crypto.encode("", _, { type: th, encoding: Af });
          x = fd(n, B, E);
        } else await Promise.all([this.sendRequest({ topic: B, method: "wc_sessionAuthenticate", params: R, expiry: r.expiry, throwOnFailedPublish: !0, clientRpcId: g }), this.sendRequest({ topic: B, method: "wc_sessionPropose", params: ge, expiry: In.wc_sessionPropose.req.ttl, throwOnFailedPublish: !0, clientRpcId: b })]);
      } catch (_) {
        throw this.events.off(br("session_connect"), m), this.events.off(br("session_request", g), f), _;
      }
      return await this.setProposal(b, tn({ id: b }, ge)), await this.setAuthRequest(g, { request: bs(tn({}, R), { verifyContext: {} }), pairingTopic: B, transportType: o }), { uri: x ?? H, response: Ee };
    }, this.approveSessionAuthenticate = async (r) => {
      const { id: n, auths: i } = r, s = this.client.core.eventClient.createEvent({ properties: { topic: n.toString(), trace: [Ga.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (L) {
        throw s.setError(If.no_internet_connection), L;
      }
      const o = this.getPendingAuthRequest(n);
      if (!o) throw s.setError(If.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${n}`);
      const a = o.transportType || zr.relay;
      a === zr.relay && await this.confirmOnlineStateOrThrow();
      const u = o.requester.publicKey, l = await this.client.core.crypto.generateKeyPair(), d = Td(u), p = { type: Ro, receiverPublicKey: u, senderPublicKey: l }, w = [], A = [];
      for (const L of i) {
        if (!await Wx({ cacao: L, projectId: this.client.core.projectId })) {
          s.setError(If.invalid_cacao);
          const V = Or("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: n, topic: d, error: V, encodeOpts: p }), new Error(V.message);
        }
        s.addTrace(Ga.cacaos_verified);
        const { p: $ } = L, B = Cd($.resources), H = [M1($.iss)], W = u0($.iss);
        if (B) {
          const V = Hx(B), te = Kx(B);
          w.push(...V), H.push(...te);
        }
        for (const V of H) A.push(`${V}:${W}`);
      }
      const P = await this.client.core.crypto.generateSharedKey(l, u);
      s.addTrace(Ga.create_authenticated_session_topic);
      let N;
      if ((w == null ? void 0 : w.length) > 0) {
        N = { topic: P, acknowledged: !0, self: { publicKey: l, metadata: this.client.metadata }, peer: { publicKey: u, metadata: o.requester.metadata }, controller: u, expiry: En(Kc), authentication: i, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: o.pairingTopic, namespaces: t3([...new Set(w)], [...new Set(A)]), transportType: a }, s.addTrace(Ga.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(P, { transportType: a });
        } catch (L) {
          throw s.setError(If.subscribe_authenticated_session_topic_failure), L;
        }
        s.addTrace(Ga.subscribe_authenticated_session_topic_success), await this.client.session.set(P, N), s.addTrace(Ga.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: o.pairingTopic, metadata: o.requester.metadata });
      }
      s.addTrace(Ga.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: d, id: n, result: { cacaos: i, responder: { publicKey: l, metadata: this.client.metadata } }, encodeOpts: p, throwOnFailedPublish: !0, appLink: this.getAppLinkIfEnabled(o.requester.metadata, a) });
      } catch (L) {
        throw s.setError(If.authenticated_session_approve_publish_failure), L;
      }
      return await this.client.auth.requests.delete(n, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: o.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: s.eventId }), { session: N };
    }, this.rejectSessionAuthenticate = async (r) => {
      this.isInitialized();
      const { id: n, reason: i } = r, s = this.getPendingAuthRequest(n);
      if (!s) throw new Error(`Could not find pending auth request with id ${n}`);
      s.transportType === zr.relay && await this.confirmOnlineStateOrThrow();
      const o = s.requester.publicKey, a = await this.client.core.crypto.generateKeyPair(), u = Td(o), l = { type: Ro, receiverPublicKey: o, senderPublicKey: a };
      await this.sendError({ id: n, topic: u, error: i, encodeOpts: l, rpcOpts: In.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(s.requester.metadata, s.transportType) }), await this.client.auth.requests.delete(n, { message: "rejected", code: 0 }), await this.client.proposal.delete(n, Or("USER_DISCONNECTED"));
    }, this.formatAuthMessage = (r) => {
      this.isInitialized();
      const { request: n, iss: i } = r;
      return U8(n, i);
    }, this.processRelayMessageCache = () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const r = this.relayMessageCache.shift();
          r && await this.onRelayMessage(r);
        } catch (r) {
          this.client.logger.error(r);
        }
      }, 50);
    }, this.cleanupDuplicatePairings = async (r) => {
      if (r.pairingTopic) try {
        const n = this.client.core.pairing.pairings.get(r.pairingTopic), i = this.client.core.pairing.pairings.getAll().filter((s) => {
          var o, a;
          return ((o = s.peerMetadata) == null ? void 0 : o.url) && ((a = s.peerMetadata) == null ? void 0 : a.url) === r.peer.metadata.url && s.topic && s.topic !== n.topic;
        });
        if (i.length === 0) return;
        this.client.logger.info(`Cleaning up ${i.length} duplicate pairing(s)`), await Promise.all(i.map((s) => this.client.core.pairing.disconnect({ topic: s.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (n) {
        this.client.logger.error(n);
      }
    }, this.deleteSession = async (r) => {
      var n;
      const { topic: i, expirerHasDeleted: s = !1, emitEvent: o = !0, id: a = 0 } = r, { self: u } = this.client.session.get(i);
      await this.client.core.relayer.unsubscribe(i), await this.client.session.delete(i, Or("USER_DISCONNECTED")), this.addToRecentlyDeleted(i, "session"), this.client.core.crypto.keychain.has(u.publicKey) && await this.client.core.crypto.deleteKeyPair(u.publicKey), this.client.core.crypto.keychain.has(i) && await this.client.core.crypto.deleteSymKey(i), s || this.client.core.expirer.del(i), this.client.core.storage.removeItem(L3).catch((l) => this.client.logger.warn(l)), this.getPendingSessionRequests().forEach((l) => {
        l.topic === i && this.deletePendingSessionRequest(l.id, Or("USER_DISCONNECTED"));
      }), i === ((n = this.sessionRequestQueue.queue[0]) == null ? void 0 : n.topic) && (this.sessionRequestQueue.state = ks.idle), o && this.client.events.emit("session_delete", { id: a, topic: i });
    }, this.deleteProposal = async (r, n) => {
      if (n) try {
        const i = this.client.proposal.get(r), s = this.client.core.eventClient.getEvent({ topic: i.pairingTopic });
        s == null || s.setError(Va.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(r, Or("USER_DISCONNECTED")), n ? Promise.resolve() : this.client.core.expirer.del(r)]), this.addToRecentlyDeleted(r, "proposal");
    }, this.deletePendingSessionRequest = async (r, n, i = !1) => {
      await Promise.all([this.client.pendingRequest.delete(r, n), i ? Promise.resolve() : this.client.core.expirer.del(r)]), this.addToRecentlyDeleted(r, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((s) => s.id !== r), i && (this.sessionRequestQueue.state = ks.idle, this.client.events.emit("session_request_expire", { id: r }));
    }, this.deletePendingAuthRequest = async (r, n, i = !1) => {
      await Promise.all([this.client.auth.requests.delete(r, n), i ? Promise.resolve() : this.client.core.expirer.del(r)]);
    }, this.setExpiry = async (r, n) => {
      this.client.session.keys.includes(r) && (this.client.core.expirer.set(r, n), await this.client.session.update(r, { expiry: n }));
    }, this.setProposal = async (r, n) => {
      this.client.core.expirer.set(r, En(In.wc_sessionPropose.req.ttl)), await this.client.proposal.set(r, n);
    }, this.setAuthRequest = async (r, n) => {
      const { request: i, pairingTopic: s, transportType: o = zr.relay } = n;
      this.client.core.expirer.set(r, i.expiryTimestamp), await this.client.auth.requests.set(r, { authPayload: i.authPayload, requester: i.requester, expiryTimestamp: i.expiryTimestamp, id: r, pairingTopic: s, verifyContext: i.verifyContext, transportType: o });
    }, this.setPendingSessionRequest = async (r) => {
      const { id: n, topic: i, params: s, verifyContext: o } = r, a = s.request.expiryTimestamp || En(In.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(n, a), await this.client.pendingRequest.set(n, { id: n, topic: i, params: s, verifyContext: o });
    }, this.sendRequest = async (r) => {
      const { topic: n, method: i, params: s, expiry: o, relayRpcId: a, clientRpcId: u, throwOnFailedPublish: l, appLink: d } = r, p = ga(i, s, u);
      let w;
      const A = !!d;
      try {
        const L = A ? Af : pa;
        w = await this.client.core.crypto.encode(n, p, { encoding: L });
      } catch (L) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${n} failed`), L;
      }
      let P;
      if (DV.includes(i)) {
        const L = Eo(JSON.stringify(p)), $ = Eo(w);
        P = await this.client.core.verify.register({ id: $, decryptedId: L });
      }
      const N = In[i].req;
      if (N.attestation = P, o && (N.ttl = o), a && (N.id = a), this.client.core.history.set(n, p), A) {
        const L = fd(d, n, w);
        await global.Linking.openURL(L, this.client.name);
      } else {
        const L = In[i].req;
        o && (L.ttl = o), a && (L.id = a), l ? (L.internal = bs(tn({}, L.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(n, w, L)) : this.client.core.relayer.publish(n, w, L).catch(($) => this.client.logger.error($));
      }
      return p.id;
    }, this.sendResult = async (r) => {
      const { id: n, topic: i, result: s, throwOnFailedPublish: o, encodeOpts: a, appLink: u } = r, l = rp(n, s);
      let d;
      const p = u && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const A = p ? Af : pa;
        d = await this.client.core.crypto.encode(i, l, bs(tn({}, a || {}), { encoding: A }));
      } catch (A) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${i} failed`), A;
      }
      let w;
      try {
        w = await this.client.core.history.get(i, n);
      } catch (A) {
        throw this.client.logger.error(`sendResult() -> history.get(${i}, ${n}) failed`), A;
      }
      if (p) {
        const A = fd(u, i, d);
        await global.Linking.openURL(A, this.client.name);
      } else {
        const A = In[w.request.method].res;
        o ? (A.internal = bs(tn({}, A.internal), { throwOnFailedPublish: !0 }), await this.client.core.relayer.publish(i, d, A)) : this.client.core.relayer.publish(i, d, A).catch((P) => this.client.logger.error(P));
      }
      await this.client.core.history.resolve(l);
    }, this.sendError = async (r) => {
      const { id: n, topic: i, error: s, encodeOpts: o, rpcOpts: a, appLink: u } = r, l = np(n, s);
      let d;
      const p = u && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const A = p ? Af : pa;
        d = await this.client.core.crypto.encode(i, l, bs(tn({}, o || {}), { encoding: A }));
      } catch (A) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${i} failed`), A;
      }
      let w;
      try {
        w = await this.client.core.history.get(i, n);
      } catch (A) {
        throw this.client.logger.error(`sendError() -> history.get(${i}, ${n}) failed`), A;
      }
      if (p) {
        const A = fd(u, i, d);
        await global.Linking.openURL(A, this.client.name);
      } else {
        const A = a || In[w.request.method].res;
        this.client.core.relayer.publish(i, d, A);
      }
      await this.client.core.history.resolve(l);
    }, this.cleanup = async () => {
      const r = [], n = [];
      this.client.session.getAll().forEach((i) => {
        let s = !1;
        fa(i.expiry) && (s = !0), this.client.core.crypto.keychain.has(i.topic) || (s = !0), s && r.push(i.topic);
      }), this.client.proposal.getAll().forEach((i) => {
        fa(i.expiryTimestamp) && n.push(i.id);
      }), await Promise.all([...r.map((i) => this.deleteSession({ topic: i })), ...n.map((i) => this.deleteProposal(i))]);
    }, this.onRelayEventRequest = async (r) => {
      this.requestQueue.queue.push(r), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === ks.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = ks.active;
        const r = this.requestQueue.queue.shift();
        if (r) try {
          await this.processRequest(r);
        } catch (n) {
          this.client.logger.warn(n);
        }
      }
      this.requestQueue.state = ks.idle;
    }, this.processRequest = async (r) => {
      const { topic: n, payload: i, attestation: s, transportType: o, encryptedId: a } = r, u = i.method;
      if (!this.shouldIgnorePairingRequest({ topic: n, requestMethod: u })) switch (u) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: n, payload: i, attestation: s, encryptedId: a });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(n, i);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(n, i);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(n, i);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(n, i);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(n, i);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: n, payload: i, attestation: s, encryptedId: a, transportType: o });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(n, i);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: n, payload: i, attestation: s, encryptedId: a, transportType: o });
        default:
          return this.client.logger.info(`Unsupported request method ${u}`);
      }
    }, this.onRelayEventResponse = async (r) => {
      const { topic: n, payload: i, transportType: s } = r, o = (await this.client.core.history.get(n, i.id)).request.method;
      switch (o) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(n, i, s);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(n, i);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(n, i);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(n, i);
        case "wc_sessionPing":
          return this.onSessionPingResponse(n, i);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(n, i);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(n, i);
        default:
          return this.client.logger.info(`Unsupported response method ${o}`);
      }
    }, this.onRelayEventUnknownPayload = (r) => {
      const { topic: n } = r, { message: i } = ft("MISSING_OR_INVALID", `Decoded payload on topic ${n} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(i);
    }, this.shouldIgnorePairingRequest = (r) => {
      const { topic: n, requestMethod: i } = r, s = this.expectedPairingMethodMap.get(n);
      return !s || s.includes(i) ? !1 : !!(s.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }, this.onSessionProposeRequest = async (r) => {
      const { topic: n, payload: i, attestation: s, encryptedId: o } = r, { params: a, id: u } = i;
      try {
        const l = this.client.core.eventClient.getEvent({ topic: n });
        this.isValidConnect(tn({}, i.params));
        const d = a.expiryTimestamp || En(In.wc_sessionPropose.req.ttl), p = tn({ id: u, pairingTopic: n, expiryTimestamp: d }, a);
        await this.setProposal(u, p);
        const w = await this.getVerifyContext({ attestationId: s, hash: Eo(JSON.stringify(i)), encryptedId: o, metadata: p.proposer.metadata });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l == null || l.setError(_o.proposal_listener_not_found)), l == null || l.addTrace(Fs.emit_session_proposal), this.client.events.emit("session_proposal", { id: u, params: p, verifyContext: w });
      } catch (l) {
        await this.sendError({ id: u, topic: n, error: l, rpcOpts: In.wc_sessionPropose.autoReject }), this.client.logger.error(l);
      }
    }, this.onSessionProposeResponse = async (r, n, i) => {
      const { id: s } = n;
      if (js(n)) {
        const { result: o } = n;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: o });
        const a = this.client.proposal.get(s);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: a });
        const u = a.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: u });
        const l = o.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l });
        const d = await this.client.core.crypto.generateSharedKey(u, l);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: d });
        const p = await this.client.core.relayer.subscribe(d, { transportType: i });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p }), await this.client.core.pairing.activate({ topic: r });
      } else if (Qi(n)) {
        await this.client.proposal.delete(s, Or("USER_DISCONNECTED"));
        const o = br("session_connect");
        if (this.events.listenerCount(o) === 0) throw new Error(`emitting ${o} without any listeners, 954`);
        this.events.emit(br("session_connect"), { error: n.error });
      }
    }, this.onSessionSettleRequest = async (r, n) => {
      const { id: i, params: s } = n;
      try {
        this.isValidSessionSettleRequest(s);
        const { relay: o, controller: a, expiry: u, namespaces: l, sessionProperties: d, sessionConfig: p } = n.params, w = bs(tn(tn({ topic: r, relay: o, expiry: u, namespaces: l, acknowledged: !0, pairingTopic: "", requiredNamespaces: {}, optionalNamespaces: {}, controller: a.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: a.publicKey, metadata: a.metadata } }, d && { sessionProperties: d }), p && { sessionConfig: p }), { transportType: zr.relay }), A = br("session_connect");
        if (this.events.listenerCount(A) === 0) throw new Error(`emitting ${A} without any listeners 997`);
        this.events.emit(br("session_connect"), { session: w }), await this.sendResult({ id: n.id, topic: r, result: !0, throwOnFailedPublish: !0 });
      } catch (o) {
        await this.sendError({ id: i, topic: r, error: o }), this.client.logger.error(o);
      }
    }, this.onSessionSettleResponse = async (r, n) => {
      const { id: i } = n;
      js(n) ? (await this.client.session.update(r, { acknowledged: !0 }), this.events.emit(br("session_approve", i), {})) : Qi(n) && (await this.client.session.delete(r, Or("USER_DISCONNECTED")), this.events.emit(br("session_approve", i), { error: n.error }));
    }, this.onSessionUpdateRequest = async (r, n) => {
      const { params: i, id: s } = n;
      try {
        const o = `${r}_session_update`, a = Pf.get(o);
        if (a && this.isRequestOutOfSync(a, s)) {
          this.client.logger.info(`Discarding out of sync request - ${s}`), this.sendError({ id: s, topic: r, error: Or("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(tn({ topic: r }, i));
        try {
          Pf.set(o, s), await this.client.session.update(r, { namespaces: i.namespaces }), await this.sendResult({ id: s, topic: r, result: !0, throwOnFailedPublish: !0 });
        } catch (u) {
          throw Pf.delete(o), u;
        }
        this.client.events.emit("session_update", { id: s, topic: r, params: i });
      } catch (o) {
        await this.sendError({ id: s, topic: r, error: o }), this.client.logger.error(o);
      }
    }, this.isRequestOutOfSync = (r, n) => parseInt(n.toString().slice(0, -3)) <= parseInt(r.toString().slice(0, -3)), this.onSessionUpdateResponse = (r, n) => {
      const { id: i } = n, s = br("session_update", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      js(n) ? this.events.emit(br("session_update", i), {}) : Qi(n) && this.events.emit(br("session_update", i), { error: n.error });
    }, this.onSessionExtendRequest = async (r, n) => {
      const { id: i } = n;
      try {
        this.isValidExtend({ topic: r }), await this.setExpiry(r, En(Kc)), await this.sendResult({ id: i, topic: r, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_extend", { id: i, topic: r });
      } catch (s) {
        await this.sendError({ id: i, topic: r, error: s }), this.client.logger.error(s);
      }
    }, this.onSessionExtendResponse = (r, n) => {
      const { id: i } = n, s = br("session_extend", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      js(n) ? this.events.emit(br("session_extend", i), {}) : Qi(n) && this.events.emit(br("session_extend", i), { error: n.error });
    }, this.onSessionPingRequest = async (r, n) => {
      const { id: i } = n;
      try {
        this.isValidPing({ topic: r }), await this.sendResult({ id: i, topic: r, result: !0, throwOnFailedPublish: !0 }), this.client.events.emit("session_ping", { id: i, topic: r });
      } catch (s) {
        await this.sendError({ id: i, topic: r, error: s }), this.client.logger.error(s);
      }
    }, this.onSessionPingResponse = (r, n) => {
      const { id: i } = n, s = br("session_ping", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      setTimeout(() => {
        js(n) ? this.events.emit(br("session_ping", i), {}) : Qi(n) && this.events.emit(br("session_ping", i), { error: n.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (r, n) => {
      const { id: i } = n;
      try {
        this.isValidDisconnect({ topic: r, reason: n.params }), Promise.all([new Promise((s) => {
          this.client.core.relayer.once(si.publish, async () => {
            s(await this.deleteSession({ topic: r, id: i }));
          });
        }), this.sendResult({ id: i, topic: r, result: !0, throwOnFailedPublish: !0 }), this.cleanupPendingSentRequestsForTopic({ topic: r, error: Or("USER_DISCONNECTED") })]).catch((s) => this.client.logger.error(s));
      } catch (s) {
        this.client.logger.error(s);
      }
    }, this.onSessionRequest = async (r) => {
      var n, i, s;
      const { topic: o, payload: a, attestation: u, encryptedId: l, transportType: d } = r, { id: p, params: w } = a;
      try {
        await this.isValidRequest(tn({ topic: o }, w));
        const A = this.client.session.get(o), P = await this.getVerifyContext({ attestationId: u, hash: Eo(JSON.stringify(ga("wc_sessionRequest", w, p))), encryptedId: l, metadata: A.peer.metadata, transportType: d }), N = { id: p, topic: o, params: w, verifyContext: P };
        await this.setPendingSessionRequest(N), d === zr.link_mode && (n = A.peer.metadata.redirect) != null && n.universal && this.client.core.addLinkModeSupportedApp((i = A.peer.metadata.redirect) == null ? void 0 : i.universal), (s = this.client.signConfig) != null && s.disableRequestQueue ? this.emitSessionRequest(N) : (this.addSessionRequestToSessionRequestQueue(N), this.processSessionRequestQueue());
      } catch (A) {
        await this.sendError({ id: p, topic: o, error: A }), this.client.logger.error(A);
      }
    }, this.onSessionRequestResponse = (r, n) => {
      const { id: i } = n, s = br("session_request", i);
      if (this.events.listenerCount(s) === 0) throw new Error(`emitting ${s} without any listeners`);
      js(n) ? this.events.emit(br("session_request", i), { result: n.result }) : Qi(n) && this.events.emit(br("session_request", i), { error: n.error });
    }, this.onSessionEventRequest = async (r, n) => {
      const { id: i, params: s } = n;
      try {
        const o = `${r}_session_event_${s.event.name}`, a = Pf.get(o);
        if (a && this.isRequestOutOfSync(a, i)) {
          this.client.logger.info(`Discarding out of sync request - ${i}`);
          return;
        }
        this.isValidEmit(tn({ topic: r }, s)), this.client.events.emit("session_event", { id: i, topic: r, params: s }), Pf.set(o, i);
      } catch (o) {
        await this.sendError({ id: i, topic: r, error: o }), this.client.logger.error(o);
      }
    }, this.onSessionAuthenticateResponse = (r, n) => {
      const { id: i } = n;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: r, payload: n }), js(n) ? this.events.emit(br("session_request", i), { result: n.result }) : Qi(n) && this.events.emit(br("session_request", i), { error: n.error });
    }, this.onSessionAuthenticateRequest = async (r) => {
      var n;
      const { topic: i, payload: s, attestation: o, encryptedId: a, transportType: u } = r;
      try {
        const { requester: l, authPayload: d, expiryTimestamp: p } = s.params, w = await this.getVerifyContext({ attestationId: o, hash: Eo(JSON.stringify(s)), encryptedId: a, metadata: l.metadata, transportType: u }), A = { requester: l, pairingTopic: i, id: s.id, authPayload: d, verifyContext: w, expiryTimestamp: p };
        await this.setAuthRequest(s.id, { request: A, pairingTopic: i, transportType: u }), u === zr.link_mode && (n = l.metadata.redirect) != null && n.universal && this.client.core.addLinkModeSupportedApp(l.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: i, params: s.params, id: s.id, verifyContext: w });
      } catch (l) {
        this.client.logger.error(l);
        const d = s.params.requester.publicKey, p = await this.client.core.crypto.generateKeyPair(), w = this.getAppLinkIfEnabled(s.params.requester.metadata, u), A = { type: Ro, receiverPublicKey: d, senderPublicKey: p };
        await this.sendError({ id: s.id, topic: i, error: l, encodeOpts: A, rpcOpts: In.wc_sessionAuthenticate.autoReject, appLink: w });
      }
    }, this.addSessionRequestToSessionRequestQueue = (r) => {
      this.sessionRequestQueue.queue.push(r);
    }, this.cleanupAfterResponse = (r) => {
      this.deletePendingSessionRequest(r.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = ks.idle, this.processSessionRequestQueue();
      }, mt.toMiliseconds(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: r, error: n }) => {
      const i = this.client.core.history.pending;
      i.length > 0 && i.filter((s) => s.topic === r && s.request.method === "wc_sessionRequest").forEach((s) => {
        const o = s.request.id, a = br("session_request", o);
        if (this.events.listenerCount(a) === 0) throw new Error(`emitting ${a} without any listeners`);
        this.events.emit(br("session_request", s.request.id), { error: n });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === ks.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const r = this.sessionRequestQueue.queue[0];
      if (!r) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = ks.active, this.emitSessionRequest(r);
      } catch (n) {
        this.client.logger.error(n);
      }
    }, this.emitSessionRequest = (r) => {
      this.client.events.emit("session_request", r);
    }, this.onPairingCreated = (r) => {
      if (r.methods && this.expectedPairingMethodMap.set(r.topic, r.methods), r.active) return;
      const n = this.client.proposal.getAll().find((i) => i.pairingTopic === r.topic);
      n && this.onSessionProposeRequest({ topic: r.topic, payload: ga("wc_sessionPropose", { requiredNamespaces: n.requiredNamespaces, optionalNamespaces: n.optionalNamespaces, relays: n.relays, proposer: n.proposer, sessionProperties: n.sessionProperties }, n.id) });
    }, this.isValidConnect = async (r) => {
      if (!gi(r)) {
        const { message: u } = ft("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(r)}`);
        throw new Error(u);
      }
      const { pairingTopic: n, requiredNamespaces: i, optionalNamespaces: s, sessionProperties: o, relays: a } = r;
      if (mi(n) || await this.isValidPairingTopic(n), !oW(a)) {
        const { message: u } = ft("MISSING_OR_INVALID", `connect() relays: ${a}`);
        throw new Error(u);
      }
      !mi(i) && Sl(i) !== 0 && this.validateNamespaces(i, "requiredNamespaces"), !mi(s) && Sl(s) !== 0 && this.validateNamespaces(s, "optionalNamespaces"), mi(o) || this.validateSessionProps(o, "sessionProperties");
    }, this.validateNamespaces = (r, n) => {
      const i = sW(r, "connect()", n);
      if (i) throw new Error(i.message);
    }, this.isValidApprove = async (r) => {
      if (!gi(r)) throw new Error(ft("MISSING_OR_INVALID", `approve() params: ${r}`).message);
      const { id: n, namespaces: i, relayProtocol: s, sessionProperties: o } = r;
      this.checkRecentlyDeleted(n), await this.isValidProposalId(n);
      const a = this.client.proposal.get(n), u = hm(i, "approve()");
      if (u) throw new Error(u.message);
      const l = i3(a.requiredNamespaces, i, "approve()");
      if (l) throw new Error(l.message);
      if (!dn(s, !0)) {
        const { message: d } = ft("MISSING_OR_INVALID", `approve() relayProtocol: ${s}`);
        throw new Error(d);
      }
      mi(o) || this.validateSessionProps(o, "sessionProperties");
    }, this.isValidReject = async (r) => {
      if (!gi(r)) {
        const { message: s } = ft("MISSING_OR_INVALID", `reject() params: ${r}`);
        throw new Error(s);
      }
      const { id: n, reason: i } = r;
      if (this.checkRecentlyDeleted(n), await this.isValidProposalId(n), !cW(i)) {
        const { message: s } = ft("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(i)}`);
        throw new Error(s);
      }
    }, this.isValidSessionSettleRequest = (r) => {
      if (!gi(r)) {
        const { message: l } = ft("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${r}`);
        throw new Error(l);
      }
      const { relay: n, controller: i, namespaces: s, expiry: o } = r;
      if (!Y8(n)) {
        const { message: l } = ft("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l);
      }
      const a = Qz(i, "onSessionSettleRequest()");
      if (a) throw new Error(a.message);
      const u = hm(s, "onSessionSettleRequest()");
      if (u) throw new Error(u.message);
      if (fa(o)) {
        const { message: l } = ft("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l);
      }
    }, this.isValidUpdate = async (r) => {
      if (!gi(r)) {
        const { message: u } = ft("MISSING_OR_INVALID", `update() params: ${r}`);
        throw new Error(u);
      }
      const { topic: n, namespaces: i } = r;
      this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
      const s = this.client.session.get(n), o = hm(i, "update()");
      if (o) throw new Error(o.message);
      const a = i3(s.requiredNamespaces, i, "update()");
      if (a) throw new Error(a.message);
    }, this.isValidExtend = async (r) => {
      if (!gi(r)) {
        const { message: i } = ft("MISSING_OR_INVALID", `extend() params: ${r}`);
        throw new Error(i);
      }
      const { topic: n } = r;
      this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
    }, this.isValidRequest = async (r) => {
      if (!gi(r)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() params: ${r}`);
        throw new Error(u);
      }
      const { topic: n, request: i, chainId: s, expiry: o } = r;
      this.checkRecentlyDeleted(n), await this.isValidSessionTopic(n);
      const { namespaces: a } = this.client.session.get(n);
      if (!n3(a, s)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() chainId: ${s}`);
        throw new Error(u);
      }
      if (!uW(i)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() ${JSON.stringify(i)}`);
        throw new Error(u);
      }
      if (!hW(a, s, i.method)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() method: ${i.method}`);
        throw new Error(u);
      }
      if (o && !mW(o, vm)) {
        const { message: u } = ft("MISSING_OR_INVALID", `request() expiry: ${o}. Expiry must be a number (in seconds) between ${vm.min} and ${vm.max}`);
        throw new Error(u);
      }
    }, this.isValidRespond = async (r) => {
      var n;
      if (!gi(r)) {
        const { message: o } = ft("MISSING_OR_INVALID", `respond() params: ${r}`);
        throw new Error(o);
      }
      const { topic: i, response: s } = r;
      try {
        await this.isValidSessionTopic(i);
      } catch (o) {
        throw (n = r == null ? void 0 : r.response) != null && n.id && this.cleanupAfterResponse(r), o;
      }
      if (!fW(s)) {
        const { message: o } = ft("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(s)}`);
        throw new Error(o);
      }
    }, this.isValidPing = async (r) => {
      if (!gi(r)) {
        const { message: i } = ft("MISSING_OR_INVALID", `ping() params: ${r}`);
        throw new Error(i);
      }
      const { topic: n } = r;
      await this.isValidSessionOrPairingTopic(n);
    }, this.isValidEmit = async (r) => {
      if (!gi(r)) {
        const { message: a } = ft("MISSING_OR_INVALID", `emit() params: ${r}`);
        throw new Error(a);
      }
      const { topic: n, event: i, chainId: s } = r;
      await this.isValidSessionTopic(n);
      const { namespaces: o } = this.client.session.get(n);
      if (!n3(o, s)) {
        const { message: a } = ft("MISSING_OR_INVALID", `emit() chainId: ${s}`);
        throw new Error(a);
      }
      if (!lW(i)) {
        const { message: a } = ft("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
        throw new Error(a);
      }
      if (!dW(o, s, i.name)) {
        const { message: a } = ft("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(i)}`);
        throw new Error(a);
      }
    }, this.isValidDisconnect = async (r) => {
      if (!gi(r)) {
        const { message: i } = ft("MISSING_OR_INVALID", `disconnect() params: ${r}`);
        throw new Error(i);
      }
      const { topic: n } = r;
      await this.isValidSessionOrPairingTopic(n);
    }, this.isValidAuthenticate = (r) => {
      const { chains: n, uri: i, domain: s, nonce: o } = r;
      if (!Array.isArray(n) || n.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!dn(i, !1)) throw new Error("uri is required parameter");
      if (!dn(s, !1)) throw new Error("domain is required parameter");
      if (!dn(o, !1)) throw new Error("nonce is required parameter");
      if ([...new Set(n.map((u) => hu(u).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: a } = hu(n[0]);
      if (a !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }, this.getVerifyContext = async (r) => {
      const { attestationId: n, hash: i, encryptedId: s, metadata: o, transportType: a } = r, u = { verified: { verifyUrl: o.verifyUrl || Wf, validation: "UNKNOWN", origin: o.url || "" } };
      try {
        if (a === zr.link_mode) {
          const d = this.getAppLinkIfEnabled(o, a);
          return u.verified.validation = d && new URL(d).origin === new URL(o.url).origin ? "VALID" : "INVALID", u;
        }
        const l = await this.client.core.verify.resolve({ attestationId: n, hash: i, encryptedId: s, verifyUrl: o.verifyUrl });
        l && (u.verified.origin = l.origin, u.verified.isScam = l.isScam, u.verified.validation = l.origin === new URL(o.url).origin ? "VALID" : "INVALID");
      } catch (l) {
        this.client.logger.warn(l);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(u)}`), u;
    }, this.validateSessionProps = (r, n) => {
      Object.values(r).forEach((i) => {
        if (!dn(i, !1)) {
          const { message: s } = ft("MISSING_OR_INVALID", `${n} must be in Record<string, string> format. Received: ${JSON.stringify(i)}`);
          throw new Error(s);
        }
      });
    }, this.getPendingAuthRequest = (r) => {
      const n = this.client.auth.requests.get(r);
      return typeof n == "object" ? n : void 0;
    }, this.addToRecentlyDeleted = (r, n) => {
      if (this.recentlyDeletedMap.set(r, n), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let i = 0;
        const s = this.recentlyDeletedLimit / 2;
        for (const o of this.recentlyDeletedMap.keys()) {
          if (i++ >= s) break;
          this.recentlyDeletedMap.delete(o);
        }
      }
    }, this.checkRecentlyDeleted = (r) => {
      const n = this.recentlyDeletedMap.get(r);
      if (n) {
        const { message: i } = ft("MISSING_OR_INVALID", `Record was recently deleted - ${n}: ${r}`);
        throw new Error(i);
      }
    }, this.isLinkModeEnabled = (r, n) => {
      var i, s, o, a, u, l, d, p, w;
      return !r || n !== zr.link_mode ? !1 : ((s = (i = this.client.metadata) == null ? void 0 : i.redirect) == null ? void 0 : s.linkMode) === !0 && ((a = (o = this.client.metadata) == null ? void 0 : o.redirect) == null ? void 0 : a.universal) !== void 0 && ((l = (u = this.client.metadata) == null ? void 0 : u.redirect) == null ? void 0 : l.universal) !== "" && ((d = r == null ? void 0 : r.redirect) == null ? void 0 : d.universal) !== void 0 && ((p = r == null ? void 0 : r.redirect) == null ? void 0 : p.universal) !== "" && ((w = r == null ? void 0 : r.redirect) == null ? void 0 : w.linkMode) === !0 && this.client.core.linkModeSupportedApps.includes(r.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }, this.getAppLinkIfEnabled = (r, n) => {
      var i;
      return this.isLinkModeEnabled(r, n) ? (i = r == null ? void 0 : r.redirect) == null ? void 0 : i.universal : void 0;
    }, this.handleLinkModeMessage = ({ url: r }) => {
      if (!r || !r.includes("wc_ev") || !r.includes("topic")) return;
      const n = jx(r, "topic") || "", i = decodeURIComponent(jx(r, "wc_ev") || ""), s = this.client.session.keys.includes(n);
      s && this.client.session.update(n, { transportType: zr.link_mode }), this.client.core.dispatchEnvelope({ topic: n, message: i, sessionExists: s });
    }, this.registerLinkModeListeners = async () => {
      var r;
      if (ib() || qu() && (r = this.client.metadata.redirect) != null && r.linkMode) {
        const n = global == null ? void 0 : global.Linking;
        if (typeof n < "u") {
          n.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const i = await n.getInitialURL();
          i && setTimeout(() => {
            this.handleLinkModeMessage({ url: i });
          }, 50);
        }
      }
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ft("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(si.message, (e) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(e) : this.onRelayMessage(e);
    });
  }
  async onRelayMessage(e) {
    const { topic: r, message: n, attestation: i, transportType: s } = e, { publicKey: o } = this.client.auth.authKeys.keys.includes(Rd) ? this.client.auth.authKeys.get(Rd) : { publicKey: void 0 }, a = await this.client.core.crypto.decode(r, n, { receiverPublicKey: o, encoding: s === zr.link_mode ? Af : pa });
    try {
      fb(a) ? (this.client.core.history.set(r, a), this.onRelayEventRequest({ topic: r, payload: a, attestation: i, transportType: s, encryptedId: Eo(n) })) : ip(a) ? (await this.client.core.history.resolve(a), await this.onRelayEventResponse({ topic: r, payload: a, transportType: s }), this.client.core.history.delete(r, a.id)) : this.onRelayEventUnknownPayload({ topic: r, payload: a, transportType: s });
    } catch (u) {
      this.client.logger.error(u);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(Xi.expired, async (e) => {
      const { topic: r, id: n } = F8(e.target);
      if (n && this.client.pendingRequest.keys.includes(n)) return await this.deletePendingSessionRequest(n, ft("EXPIRED"), !0);
      if (n && this.client.auth.requests.keys.includes(n)) return await this.deletePendingAuthRequest(n, ft("EXPIRED"), !0);
      r ? this.client.session.keys.includes(r) && (await this.deleteSession({ topic: r, expirerHasDeleted: !0 }), this.client.events.emit("session_expire", { topic: r })) : n && (await this.deleteProposal(n, !0), this.client.events.emit("proposal_expire", { id: n }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(Qa.create, (e) => this.onPairingCreated(e)), this.client.core.pairing.events.on(Qa.delete, (e) => {
      this.addToRecentlyDeleted(e.topic, "pairing");
    });
  }
  isValidPairingTopic(e) {
    if (!dn(e, !1)) {
      const { message: r } = ft("MISSING_OR_INVALID", `pairing topic should be a string: ${e}`);
      throw new Error(r);
    }
    if (!this.client.core.pairing.pairings.keys.includes(e)) {
      const { message: r } = ft("NO_MATCHING_KEY", `pairing topic doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (fa(this.client.core.pairing.pairings.get(e).expiry)) {
      const { message: r } = ft("EXPIRED", `pairing topic: ${e}`);
      throw new Error(r);
    }
  }
  async isValidSessionTopic(e) {
    if (!dn(e, !1)) {
      const { message: r } = ft("MISSING_OR_INVALID", `session topic should be a string: ${e}`);
      throw new Error(r);
    }
    if (this.checkRecentlyDeleted(e), !this.client.session.keys.includes(e)) {
      const { message: r } = ft("NO_MATCHING_KEY", `session topic doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (fa(this.client.session.get(e).expiry)) {
      await this.deleteSession({ topic: e });
      const { message: r } = ft("EXPIRED", `session topic: ${e}`);
      throw new Error(r);
    }
    if (!this.client.core.crypto.keychain.has(e)) {
      const { message: r } = ft("MISSING_OR_INVALID", `session topic does not exist in keychain: ${e}`);
      throw await this.deleteSession({ topic: e }), new Error(r);
    }
  }
  async isValidSessionOrPairingTopic(e) {
    if (this.checkRecentlyDeleted(e), this.client.session.keys.includes(e)) await this.isValidSessionTopic(e);
    else if (this.client.core.pairing.pairings.keys.includes(e)) this.isValidPairingTopic(e);
    else if (dn(e, !1)) {
      const { message: r } = ft("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${e}`);
      throw new Error(r);
    } else {
      const { message: r } = ft("MISSING_OR_INVALID", `session or pairing topic should be a string: ${e}`);
      throw new Error(r);
    }
  }
  async isValidProposalId(e) {
    if (!aW(e)) {
      const { message: r } = ft("MISSING_OR_INVALID", `proposal id should be a number: ${e}`);
      throw new Error(r);
    }
    if (!this.client.proposal.keys.includes(e)) {
      const { message: r } = ft("NO_MATCHING_KEY", `proposal id doesn't exist: ${e}`);
      throw new Error(r);
    }
    if (fa(this.client.proposal.get(e).expiryTimestamp)) {
      await this.deleteProposal(e);
      const { message: r } = ft("EXPIRED", `proposal id: ${e}`);
      throw new Error(r);
    }
  }
}
class WV extends Ec {
  constructor(e, r) {
    super(e, r, IV, hb), this.core = e, this.logger = r;
  }
}
let HV = class extends Ec {
  constructor(e, r) {
    super(e, r, CV, hb), this.core = e, this.logger = r;
  }
};
class KV extends Ec {
  constructor(e, r) {
    super(e, r, RV, hb, (n) => n.id), this.core = e, this.logger = r;
  }
}
class VV extends Ec {
  constructor(e, r) {
    super(e, r, LV, op, () => Rd), this.core = e, this.logger = r;
  }
}
class GV extends Ec {
  constructor(e, r) {
    super(e, r, kV, op), this.core = e, this.logger = r;
  }
}
class YV extends Ec {
  constructor(e, r) {
    super(e, r, $V, op, (n) => n.id), this.core = e, this.logger = r;
  }
}
class JV {
  constructor(e, r) {
    this.core = e, this.logger = r, this.authKeys = new VV(this.core, this.logger), this.pairingTopics = new GV(this.core, this.logger), this.requests = new YV(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
}
class db extends s$ {
  constructor(e) {
    super(e), this.protocol = bE, this.version = yE, this.name = mm.name, this.events = new ns.EventEmitter(), this.on = (n, i) => this.events.on(n, i), this.once = (n, i) => this.events.once(n, i), this.off = (n, i) => this.events.off(n, i), this.removeListener = (n, i) => this.events.removeListener(n, i), this.removeAllListeners = (n) => this.events.removeAllListeners(n), this.connect = async (n) => {
      try {
        return await this.engine.connect(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.pair = async (n) => {
      try {
        return await this.engine.pair(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.approve = async (n) => {
      try {
        return await this.engine.approve(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.reject = async (n) => {
      try {
        return await this.engine.reject(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.update = async (n) => {
      try {
        return await this.engine.update(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.extend = async (n) => {
      try {
        return await this.engine.extend(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.request = async (n) => {
      try {
        return await this.engine.request(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.respond = async (n) => {
      try {
        return await this.engine.respond(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.ping = async (n) => {
      try {
        return await this.engine.ping(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.emit = async (n) => {
      try {
        return await this.engine.emit(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.disconnect = async (n) => {
      try {
        return await this.engine.disconnect(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.find = (n) => {
      try {
        return this.engine.find(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (n) {
        throw this.logger.error(n.message), n;
      }
    }, this.authenticate = async (n, i) => {
      try {
        return await this.engine.authenticate(n, i);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.formatAuthMessage = (n) => {
      try {
        return this.engine.formatAuthMessage(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.approveSessionAuthenticate = async (n) => {
      try {
        return await this.engine.approveSessionAuthenticate(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.rejectSessionAuthenticate = async (n) => {
      try {
        return await this.engine.rejectSessionAuthenticate(n);
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.name = (e == null ? void 0 : e.name) || mm.name, this.metadata = (e == null ? void 0 : e.metadata) || N8(), this.signConfig = e == null ? void 0 : e.signConfig;
    const r = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : ql($0({ level: (e == null ? void 0 : e.logger) || mm.logger }));
    this.core = (e == null ? void 0 : e.core) || new MV(e), this.logger = ci(r, this.name), this.session = new HV(this.core, this.logger), this.proposal = new WV(this.core, this.logger), this.pendingRequest = new KV(this.core, this.logger), this.engine = new zV(this), this.auth = new JV(this.core, this.logger);
  }
  static async init(e) {
    const r = new db(e);
    return await r.initialize(), r;
  }
  get context() {
    return Si(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), this.engine.processRelayMessageCache();
    } catch (e) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(e.message), e;
    }
  }
}
var h0 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
h0.exports;
(function(t, e) {
  (function() {
    var r, n = "4.17.21", i = 200, s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", o = "Expected a function", a = "Invalid `variable` option passed into `_.template`", u = "__lodash_hash_undefined__", l = 500, d = "__lodash_placeholder__", p = 1, w = 2, A = 4, P = 1, N = 2, L = 1, $ = 2, B = 4, H = 8, W = 16, V = 32, te = 64, R = 128, K = 256, ge = 512, Ee = 30, Y = "...", S = 800, m = 16, f = 1, g = 2, b = 3, x = 1 / 0, _ = 9007199254740991, E = 17976931348623157e292, v = NaN, M = 4294967295, I = M - 1, F = M >>> 1, ce = [
      ["ary", R],
      ["bind", L],
      ["bindKey", $],
      ["curry", H],
      ["curryRight", W],
      ["flip", ge],
      ["partial", V],
      ["partialRight", te],
      ["rearg", K]
    ], D = "[object Arguments]", oe = "[object Array]", Z = "[object AsyncFunction]", J = "[object Boolean]", Q = "[object Date]", T = "[object DOMException]", X = "[object Error]", re = "[object Function]", pe = "[object GeneratorFunction]", ie = "[object Map]", ue = "[object Number]", ve = "[object Null]", Pe = "[object Object]", De = "[object Promise]", Ce = "[object Proxy]", $e = "[object RegExp]", Me = "[object Set]", Ne = "[object String]", Ke = "[object Symbol]", Le = "[object Undefined]", qe = "[object WeakMap]", ze = "[object WeakSet]", _e = "[object ArrayBuffer]", Ze = "[object DataView]", at = "[object Float32Array]", ke = "[object Float64Array]", Qe = "[object Int8Array]", tt = "[object Int16Array]", Ye = "[object Int32Array]", dt = "[object Uint8Array]", lt = "[object Uint8ClampedArray]", ct = "[object Uint16Array]", qt = "[object Uint32Array]", Jt = /\b__p \+= '';/g, Et = /\b(__p \+=) '' \+/g, er = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Xt = /&(?:amp|lt|gt|quot|#39);/g, Dt = /[&<>"']/g, kt = RegExp(Xt.source), Ct = RegExp(Dt.source), gt = /<%-([\s\S]+?)%>/g, Rt = /<%([\s\S]+?)%>/g, Nt = /<%=([\s\S]+?)%>/g, vt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, $t = /^\w*$/, Ft = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, rt = /[\\^$.*+?()[\]{}|]/g, Bt = RegExp(rt.source), k = /^\s+/, U = /\s/, z = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, C = /\{\n\/\* \[wrapped with (.+)\] \*/, G = /,? & /, j = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, se = /[()=,{}\[\]\/\s]/, de = /\\(\\)?/g, xe = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Te = /\w*$/, Re = /^[-+]0x[0-9a-f]+$/i, nt = /^0b[01]+$/i, je = /^\[object .+?Constructor\]$/, pt = /^0o[0-7]+$/i, it = /^(?:0|[1-9]\d*)$/, et = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, St = /($^)/, Tt = /['\n\r\u2028\u2029\\]/g, At = "\\ud800-\\udfff", _t = "\\u0300-\\u036f", ht = "\\ufe20-\\ufe2f", xt = "\\u20d0-\\u20ff", st = _t + ht + xt, bt = "\\u2700-\\u27bf", ut = "a-z\\xdf-\\xf6\\xf8-\\xff", ot = "\\xac\\xb1\\xd7\\xf7", Se = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Ae = "\\u2000-\\u206f", Ve = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Fe = "A-Z\\xc0-\\xd6\\xd8-\\xde", Ue = "\\ufe0e\\ufe0f", Je = ot + Se + Ae + Ve, Lt = "[']", zt = "[" + At + "]", Zt = "[" + Je + "]", Wt = "[" + st + "]", he = "\\d+", rr = "[" + bt + "]", dr = "[" + ut + "]", pr = "[^" + At + Je + he + bt + ut + Fe + "]", Qt = "\\ud83c[\\udffb-\\udfff]", gr = "(?:" + Wt + "|" + Qt + ")", lr = "[^" + At + "]", Rr = "(?:\\ud83c[\\udde6-\\uddff]){2}", mr = "[\\ud800-\\udbff][\\udc00-\\udfff]", yr = "[" + Fe + "]", $r = "\\u200d", Br = "(?:" + dr + "|" + pr + ")", Ir = "(?:" + yr + "|" + pr + ")", nn = "(?:" + Lt + "(?:d|ll|m|re|s|t|ve))?", sn = "(?:" + Lt + "(?:D|LL|M|RE|S|T|VE))?", on = gr + "?", lh = "[" + Ue + "]?", Rp = "(?:" + $r + "(?:" + [lr, Rr, mr].join("|") + ")" + lh + on + ")*", oo = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", hh = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", dh = lh + on + Rp, Mc = "(?:" + [rr, Rr, mr].join("|") + ")" + dh, Dp = "(?:" + [lr + Wt + "?", Wt, Rr, mr, zt].join("|") + ")", Xu = RegExp(Lt, "g"), Op = RegExp(Wt, "g"), Ic = RegExp(Qt + "(?=" + Qt + ")|" + Dp + dh, "g"), ph = RegExp([
      yr + "?" + dr + "+" + nn + "(?=" + [Zt, yr, "$"].join("|") + ")",
      Ir + "+" + sn + "(?=" + [Zt, yr + Br, "$"].join("|") + ")",
      yr + "?" + Br + "+" + nn,
      yr + "+" + sn,
      hh,
      oo,
      he,
      Mc
    ].join("|"), "g"), gh = RegExp("[" + $r + At + st + Ue + "]"), Na = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, mh = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], Np = -1, Fr = {};
    Fr[at] = Fr[ke] = Fr[Qe] = Fr[tt] = Fr[Ye] = Fr[dt] = Fr[lt] = Fr[ct] = Fr[qt] = !0, Fr[D] = Fr[oe] = Fr[_e] = Fr[J] = Fr[Ze] = Fr[Q] = Fr[X] = Fr[re] = Fr[ie] = Fr[ue] = Fr[Pe] = Fr[$e] = Fr[Me] = Fr[Ne] = Fr[qe] = !1;
    var Dr = {};
    Dr[D] = Dr[oe] = Dr[_e] = Dr[Ze] = Dr[J] = Dr[Q] = Dr[at] = Dr[ke] = Dr[Qe] = Dr[tt] = Dr[Ye] = Dr[ie] = Dr[ue] = Dr[Pe] = Dr[$e] = Dr[Me] = Dr[Ne] = Dr[Ke] = Dr[dt] = Dr[lt] = Dr[ct] = Dr[qt] = !0, Dr[X] = Dr[re] = Dr[qe] = !1;
    var ae = {
      // Latin-1 Supplement block.
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "a",
      : "C",
      : "c",
      : "D",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "N",
      : "n",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "o",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "Y",
      : "y",
      : "y",
      : "Ae",
      : "ae",
      : "Th",
      : "th",
      : "ss",
      // Latin Extended-A block.
      : "A",
      : "A",
      : "A",
      : "a",
      : "a",
      : "a",
      : "C",
      : "C",
      : "C",
      : "C",
      : "c",
      : "c",
      : "c",
      : "c",
      : "D",
      : "D",
      : "d",
      : "d",
      : "E",
      : "E",
      : "E",
      : "E",
      : "E",
      : "e",
      : "e",
      : "e",
      : "e",
      : "e",
      : "G",
      : "G",
      : "G",
      : "G",
      : "g",
      : "g",
      : "g",
      : "g",
      : "H",
      : "H",
      : "h",
      : "h",
      : "I",
      : "I",
      : "I",
      : "I",
      : "I",
      : "i",
      : "i",
      : "i",
      : "i",
      : "i",
      : "J",
      : "j",
      : "K",
      : "k",
      : "k",
      : "L",
      : "L",
      : "L",
      : "L",
      : "L",
      : "l",
      : "l",
      : "l",
      : "l",
      : "l",
      : "N",
      : "N",
      : "N",
      : "N",
      : "n",
      : "n",
      : "n",
      : "n",
      : "O",
      : "O",
      : "O",
      : "o",
      : "o",
      : "o",
      : "R",
      : "R",
      : "R",
      : "r",
      : "r",
      : "r",
      : "S",
      : "S",
      : "S",
      : "S",
      : "s",
      : "s",
      : "s",
      : "s",
      : "T",
      : "T",
      : "T",
      : "t",
      : "t",
      : "t",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "U",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "u",
      : "W",
      : "w",
      : "Y",
      : "y",
      : "Y",
      : "Z",
      : "Z",
      : "Z",
      : "z",
      : "z",
      : "z",
      : "IJ",
      : "ij",
      : "Oe",
      : "oe",
      : "'n",
      : "s"
    }, ye = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, Ge = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, Pt = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, jr = parseFloat, nr = parseInt, Kr = typeof gn == "object" && gn && gn.Object === Object && gn, vn = typeof self == "object" && self && self.Object === Object && self, _r = Kr || vn || Function("return this")(), Ur = e && !e.nodeType && e, an = Ur && !0 && t && !t.nodeType && t, ui = an && an.exports === Ur, bn = ui && Kr.process, Vr = function() {
      try {
        var be = an && an.require && an.require("util").types;
        return be || bn && bn.binding && bn.binding("util");
      } catch {
      }
    }(), ei = Vr && Vr.isArrayBuffer, fs = Vr && Vr.isDate, ji = Vr && Vr.isMap, Is = Vr && Vr.isRegExp, Zu = Vr && Vr.isSet, La = Vr && Vr.isTypedArray;
    function Pn(be, Be, Ie) {
      switch (Ie.length) {
        case 0:
          return be.call(Be);
        case 1:
          return be.call(Be, Ie[0]);
        case 2:
          return be.call(Be, Ie[0], Ie[1]);
        case 3:
          return be.call(Be, Ie[0], Ie[1], Ie[2]);
      }
      return be.apply(Be, Ie);
    }
    function rA(be, Be, Ie, It) {
      for (var tr = -1, Pr = be == null ? 0 : be.length; ++tr < Pr; ) {
        var xn = be[tr];
        Be(It, xn, Ie(xn), be);
      }
      return It;
    }
    function Ui(be, Be) {
      for (var Ie = -1, It = be == null ? 0 : be.length; ++Ie < It && Be(be[Ie], Ie, be) !== !1; )
        ;
      return be;
    }
    function nA(be, Be) {
      for (var Ie = be == null ? 0 : be.length; Ie-- && Be(be[Ie], Ie, be) !== !1; )
        ;
      return be;
    }
    function my(be, Be) {
      for (var Ie = -1, It = be == null ? 0 : be.length; ++Ie < It; )
        if (!Be(be[Ie], Ie, be))
          return !1;
      return !0;
    }
    function Ko(be, Be) {
      for (var Ie = -1, It = be == null ? 0 : be.length, tr = 0, Pr = []; ++Ie < It; ) {
        var xn = be[Ie];
        Be(xn, Ie, be) && (Pr[tr++] = xn);
      }
      return Pr;
    }
    function vh(be, Be) {
      var Ie = be == null ? 0 : be.length;
      return !!Ie && Cc(be, Be, 0) > -1;
    }
    function Lp(be, Be, Ie) {
      for (var It = -1, tr = be == null ? 0 : be.length; ++It < tr; )
        if (Ie(Be, be[It]))
          return !0;
      return !1;
    }
    function Xr(be, Be) {
      for (var Ie = -1, It = be == null ? 0 : be.length, tr = Array(It); ++Ie < It; )
        tr[Ie] = Be(be[Ie], Ie, be);
      return tr;
    }
    function Vo(be, Be) {
      for (var Ie = -1, It = Be.length, tr = be.length; ++Ie < It; )
        be[tr + Ie] = Be[Ie];
      return be;
    }
    function kp(be, Be, Ie, It) {
      var tr = -1, Pr = be == null ? 0 : be.length;
      for (It && Pr && (Ie = be[++tr]); ++tr < Pr; )
        Ie = Be(Ie, be[tr], tr, be);
      return Ie;
    }
    function iA(be, Be, Ie, It) {
      var tr = be == null ? 0 : be.length;
      for (It && tr && (Ie = be[--tr]); tr--; )
        Ie = Be(Ie, be[tr], tr, be);
      return Ie;
    }
    function $p(be, Be) {
      for (var Ie = -1, It = be == null ? 0 : be.length; ++Ie < It; )
        if (Be(be[Ie], Ie, be))
          return !0;
      return !1;
    }
    var sA = Bp("length");
    function oA(be) {
      return be.split("");
    }
    function aA(be) {
      return be.match(j) || [];
    }
    function vy(be, Be, Ie) {
      var It;
      return Ie(be, function(tr, Pr, xn) {
        if (Be(tr, Pr, xn))
          return It = Pr, !1;
      }), It;
    }
    function bh(be, Be, Ie, It) {
      for (var tr = be.length, Pr = Ie + (It ? 1 : -1); It ? Pr-- : ++Pr < tr; )
        if (Be(be[Pr], Pr, be))
          return Pr;
      return -1;
    }
    function Cc(be, Be, Ie) {
      return Be === Be ? yA(be, Be, Ie) : bh(be, by, Ie);
    }
    function cA(be, Be, Ie, It) {
      for (var tr = Ie - 1, Pr = be.length; ++tr < Pr; )
        if (It(be[tr], Be))
          return tr;
      return -1;
    }
    function by(be) {
      return be !== be;
    }
    function yy(be, Be) {
      var Ie = be == null ? 0 : be.length;
      return Ie ? jp(be, Be) / Ie : v;
    }
    function Bp(be) {
      return function(Be) {
        return Be == null ? r : Be[be];
      };
    }
    function Fp(be) {
      return function(Be) {
        return be == null ? r : be[Be];
      };
    }
    function wy(be, Be, Ie, It, tr) {
      return tr(be, function(Pr, xn, qr) {
        Ie = It ? (It = !1, Pr) : Be(Ie, Pr, xn, qr);
      }), Ie;
    }
    function uA(be, Be) {
      var Ie = be.length;
      for (be.sort(Be); Ie--; )
        be[Ie] = be[Ie].value;
      return be;
    }
    function jp(be, Be) {
      for (var Ie, It = -1, tr = be.length; ++It < tr; ) {
        var Pr = Be(be[It]);
        Pr !== r && (Ie = Ie === r ? Pr : Ie + Pr);
      }
      return Ie;
    }
    function Up(be, Be) {
      for (var Ie = -1, It = Array(be); ++Ie < be; )
        It[Ie] = Be(Ie);
      return It;
    }
    function fA(be, Be) {
      return Xr(Be, function(Ie) {
        return [Ie, be[Ie]];
      });
    }
    function xy(be) {
      return be && be.slice(0, Ay(be) + 1).replace(k, "");
    }
    function Ai(be) {
      return function(Be) {
        return be(Be);
      };
    }
    function qp(be, Be) {
      return Xr(Be, function(Ie) {
        return be[Ie];
      });
    }
    function Qu(be, Be) {
      return be.has(Be);
    }
    function _y(be, Be) {
      for (var Ie = -1, It = be.length; ++Ie < It && Cc(Be, be[Ie], 0) > -1; )
        ;
      return Ie;
    }
    function Ey(be, Be) {
      for (var Ie = be.length; Ie-- && Cc(Be, be[Ie], 0) > -1; )
        ;
      return Ie;
    }
    function lA(be, Be) {
      for (var Ie = be.length, It = 0; Ie--; )
        be[Ie] === Be && ++It;
      return It;
    }
    var hA = Fp(ae), dA = Fp(ye);
    function pA(be) {
      return "\\" + Pt[be];
    }
    function gA(be, Be) {
      return be == null ? r : be[Be];
    }
    function Tc(be) {
      return gh.test(be);
    }
    function mA(be) {
      return Na.test(be);
    }
    function vA(be) {
      for (var Be, Ie = []; !(Be = be.next()).done; )
        Ie.push(Be.value);
      return Ie;
    }
    function zp(be) {
      var Be = -1, Ie = Array(be.size);
      return be.forEach(function(It, tr) {
        Ie[++Be] = [tr, It];
      }), Ie;
    }
    function Sy(be, Be) {
      return function(Ie) {
        return be(Be(Ie));
      };
    }
    function Go(be, Be) {
      for (var Ie = -1, It = be.length, tr = 0, Pr = []; ++Ie < It; ) {
        var xn = be[Ie];
        (xn === Be || xn === d) && (be[Ie] = d, Pr[tr++] = Ie);
      }
      return Pr;
    }
    function yh(be) {
      var Be = -1, Ie = Array(be.size);
      return be.forEach(function(It) {
        Ie[++Be] = It;
      }), Ie;
    }
    function bA(be) {
      var Be = -1, Ie = Array(be.size);
      return be.forEach(function(It) {
        Ie[++Be] = [It, It];
      }), Ie;
    }
    function yA(be, Be, Ie) {
      for (var It = Ie - 1, tr = be.length; ++It < tr; )
        if (be[It] === Be)
          return It;
      return -1;
    }
    function wA(be, Be, Ie) {
      for (var It = Ie + 1; It--; )
        if (be[It] === Be)
          return It;
      return It;
    }
    function Rc(be) {
      return Tc(be) ? _A(be) : sA(be);
    }
    function ls(be) {
      return Tc(be) ? EA(be) : oA(be);
    }
    function Ay(be) {
      for (var Be = be.length; Be-- && U.test(be.charAt(Be)); )
        ;
      return Be;
    }
    var xA = Fp(Ge);
    function _A(be) {
      for (var Be = Ic.lastIndex = 0; Ic.test(be); )
        ++Be;
      return Be;
    }
    function EA(be) {
      return be.match(Ic) || [];
    }
    function SA(be) {
      return be.match(ph) || [];
    }
    var AA = function be(Be) {
      Be = Be == null ? _r : Dc.defaults(_r.Object(), Be, Dc.pick(_r, mh));
      var Ie = Be.Array, It = Be.Date, tr = Be.Error, Pr = Be.Function, xn = Be.Math, qr = Be.Object, Wp = Be.RegExp, PA = Be.String, qi = Be.TypeError, wh = Ie.prototype, MA = Pr.prototype, Oc = qr.prototype, xh = Be["__core-js_shared__"], _h = MA.toString, Tr = Oc.hasOwnProperty, IA = 0, Py = function() {
        var c = /[^.]+$/.exec(xh && xh.keys && xh.keys.IE_PROTO || "");
        return c ? "Symbol(src)_1." + c : "";
      }(), Eh = Oc.toString, CA = _h.call(qr), TA = _r._, RA = Wp(
        "^" + _h.call(Tr).replace(rt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Sh = ui ? Be.Buffer : r, Yo = Be.Symbol, Ah = Be.Uint8Array, My = Sh ? Sh.allocUnsafe : r, Ph = Sy(qr.getPrototypeOf, qr), Iy = qr.create, Cy = Oc.propertyIsEnumerable, Mh = wh.splice, Ty = Yo ? Yo.isConcatSpreadable : r, ef = Yo ? Yo.iterator : r, ka = Yo ? Yo.toStringTag : r, Ih = function() {
        try {
          var c = Ua(qr, "defineProperty");
          return c({}, "", {}), c;
        } catch {
        }
      }(), DA = Be.clearTimeout !== _r.clearTimeout && Be.clearTimeout, OA = It && It.now !== _r.Date.now && It.now, NA = Be.setTimeout !== _r.setTimeout && Be.setTimeout, Ch = xn.ceil, Th = xn.floor, Hp = qr.getOwnPropertySymbols, LA = Sh ? Sh.isBuffer : r, Ry = Be.isFinite, kA = wh.join, $A = Sy(qr.keys, qr), _n = xn.max, Kn = xn.min, BA = It.now, FA = Be.parseInt, Dy = xn.random, jA = wh.reverse, Kp = Ua(Be, "DataView"), tf = Ua(Be, "Map"), Vp = Ua(Be, "Promise"), Nc = Ua(Be, "Set"), rf = Ua(Be, "WeakMap"), nf = Ua(qr, "create"), Rh = rf && new rf(), Lc = {}, UA = qa(Kp), qA = qa(tf), zA = qa(Vp), WA = qa(Nc), HA = qa(rf), Dh = Yo ? Yo.prototype : r, sf = Dh ? Dh.valueOf : r, Oy = Dh ? Dh.toString : r;
      function ee(c) {
        if (en(c) && !ir(c) && !(c instanceof wr)) {
          if (c instanceof zi)
            return c;
          if (Tr.call(c, "__wrapped__"))
            return Nw(c);
        }
        return new zi(c);
      }
      var kc = /* @__PURE__ */ function() {
        function c() {
        }
        return function(h) {
          if (!Zr(h))
            return {};
          if (Iy)
            return Iy(h);
          c.prototype = h;
          var y = new c();
          return c.prototype = r, y;
        };
      }();
      function Oh() {
      }
      function zi(c, h) {
        this.__wrapped__ = c, this.__actions__ = [], this.__chain__ = !!h, this.__index__ = 0, this.__values__ = r;
      }
      ee.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: gt,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: Rt,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: Nt,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: ee
        }
      }, ee.prototype = Oh.prototype, ee.prototype.constructor = ee, zi.prototype = kc(Oh.prototype), zi.prototype.constructor = zi;
      function wr(c) {
        this.__wrapped__ = c, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = M, this.__views__ = [];
      }
      function KA() {
        var c = new wr(this.__wrapped__);
        return c.__actions__ = fi(this.__actions__), c.__dir__ = this.__dir__, c.__filtered__ = this.__filtered__, c.__iteratees__ = fi(this.__iteratees__), c.__takeCount__ = this.__takeCount__, c.__views__ = fi(this.__views__), c;
      }
      function VA() {
        if (this.__filtered__) {
          var c = new wr(this);
          c.__dir__ = -1, c.__filtered__ = !0;
        } else
          c = this.clone(), c.__dir__ *= -1;
        return c;
      }
      function GA() {
        var c = this.__wrapped__.value(), h = this.__dir__, y = ir(c), O = h < 0, q = y ? c.length : 0, ne = oM(0, q, this.__views__), le = ne.start, me = ne.end, we = me - le, We = O ? me : le - 1, He = this.__iteratees__, Xe = He.length, wt = 0, Ot = Kn(we, this.__takeCount__);
        if (!y || !O && q == we && Ot == we)
          return nw(c, this.__actions__);
        var Ht = [];
        e:
          for (; we-- && wt < Ot; ) {
            We += h;
            for (var fr = -1, Kt = c[We]; ++fr < Xe; ) {
              var vr = He[fr], Er = vr.iteratee, Ii = vr.type, ni = Er(Kt);
              if (Ii == g)
                Kt = ni;
              else if (!ni) {
                if (Ii == f)
                  continue e;
                break e;
              }
            }
            Ht[wt++] = Kt;
          }
        return Ht;
      }
      wr.prototype = kc(Oh.prototype), wr.prototype.constructor = wr;
      function $a(c) {
        var h = -1, y = c == null ? 0 : c.length;
        for (this.clear(); ++h < y; ) {
          var O = c[h];
          this.set(O[0], O[1]);
        }
      }
      function YA() {
        this.__data__ = nf ? nf(null) : {}, this.size = 0;
      }
      function JA(c) {
        var h = this.has(c) && delete this.__data__[c];
        return this.size -= h ? 1 : 0, h;
      }
      function XA(c) {
        var h = this.__data__;
        if (nf) {
          var y = h[c];
          return y === u ? r : y;
        }
        return Tr.call(h, c) ? h[c] : r;
      }
      function ZA(c) {
        var h = this.__data__;
        return nf ? h[c] !== r : Tr.call(h, c);
      }
      function QA(c, h) {
        var y = this.__data__;
        return this.size += this.has(c) ? 0 : 1, y[c] = nf && h === r ? u : h, this;
      }
      $a.prototype.clear = YA, $a.prototype.delete = JA, $a.prototype.get = XA, $a.prototype.has = ZA, $a.prototype.set = QA;
      function ao(c) {
        var h = -1, y = c == null ? 0 : c.length;
        for (this.clear(); ++h < y; ) {
          var O = c[h];
          this.set(O[0], O[1]);
        }
      }
      function eP() {
        this.__data__ = [], this.size = 0;
      }
      function tP(c) {
        var h = this.__data__, y = Nh(h, c);
        if (y < 0)
          return !1;
        var O = h.length - 1;
        return y == O ? h.pop() : Mh.call(h, y, 1), --this.size, !0;
      }
      function rP(c) {
        var h = this.__data__, y = Nh(h, c);
        return y < 0 ? r : h[y][1];
      }
      function nP(c) {
        return Nh(this.__data__, c) > -1;
      }
      function iP(c, h) {
        var y = this.__data__, O = Nh(y, c);
        return O < 0 ? (++this.size, y.push([c, h])) : y[O][1] = h, this;
      }
      ao.prototype.clear = eP, ao.prototype.delete = tP, ao.prototype.get = rP, ao.prototype.has = nP, ao.prototype.set = iP;
      function co(c) {
        var h = -1, y = c == null ? 0 : c.length;
        for (this.clear(); ++h < y; ) {
          var O = c[h];
          this.set(O[0], O[1]);
        }
      }
      function sP() {
        this.size = 0, this.__data__ = {
          hash: new $a(),
          map: new (tf || ao)(),
          string: new $a()
        };
      }
      function oP(c) {
        var h = Kh(this, c).delete(c);
        return this.size -= h ? 1 : 0, h;
      }
      function aP(c) {
        return Kh(this, c).get(c);
      }
      function cP(c) {
        return Kh(this, c).has(c);
      }
      function uP(c, h) {
        var y = Kh(this, c), O = y.size;
        return y.set(c, h), this.size += y.size == O ? 0 : 1, this;
      }
      co.prototype.clear = sP, co.prototype.delete = oP, co.prototype.get = aP, co.prototype.has = cP, co.prototype.set = uP;
      function Ba(c) {
        var h = -1, y = c == null ? 0 : c.length;
        for (this.__data__ = new co(); ++h < y; )
          this.add(c[h]);
      }
      function fP(c) {
        return this.__data__.set(c, u), this;
      }
      function lP(c) {
        return this.__data__.has(c);
      }
      Ba.prototype.add = Ba.prototype.push = fP, Ba.prototype.has = lP;
      function hs(c) {
        var h = this.__data__ = new ao(c);
        this.size = h.size;
      }
      function hP() {
        this.__data__ = new ao(), this.size = 0;
      }
      function dP(c) {
        var h = this.__data__, y = h.delete(c);
        return this.size = h.size, y;
      }
      function pP(c) {
        return this.__data__.get(c);
      }
      function gP(c) {
        return this.__data__.has(c);
      }
      function mP(c, h) {
        var y = this.__data__;
        if (y instanceof ao) {
          var O = y.__data__;
          if (!tf || O.length < i - 1)
            return O.push([c, h]), this.size = ++y.size, this;
          y = this.__data__ = new co(O);
        }
        return y.set(c, h), this.size = y.size, this;
      }
      hs.prototype.clear = hP, hs.prototype.delete = dP, hs.prototype.get = pP, hs.prototype.has = gP, hs.prototype.set = mP;
      function Ny(c, h) {
        var y = ir(c), O = !y && za(c), q = !y && !O && ea(c), ne = !y && !O && !q && jc(c), le = y || O || q || ne, me = le ? Up(c.length, PA) : [], we = me.length;
        for (var We in c)
          (h || Tr.call(c, We)) && !(le && // Safari 9 has enumerable `arguments.length` in strict mode.
          (We == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          q && (We == "offset" || We == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          ne && (We == "buffer" || We == "byteLength" || We == "byteOffset") || // Skip index properties.
          ho(We, we))) && me.push(We);
        return me;
      }
      function Ly(c) {
        var h = c.length;
        return h ? c[ig(0, h - 1)] : r;
      }
      function vP(c, h) {
        return Vh(fi(c), Fa(h, 0, c.length));
      }
      function bP(c) {
        return Vh(fi(c));
      }
      function Gp(c, h, y) {
        (y !== r && !ds(c[h], y) || y === r && !(h in c)) && uo(c, h, y);
      }
      function of(c, h, y) {
        var O = c[h];
        (!(Tr.call(c, h) && ds(O, y)) || y === r && !(h in c)) && uo(c, h, y);
      }
      function Nh(c, h) {
        for (var y = c.length; y--; )
          if (ds(c[y][0], h))
            return y;
        return -1;
      }
      function yP(c, h, y, O) {
        return Jo(c, function(q, ne, le) {
          h(O, q, y(q), le);
        }), O;
      }
      function ky(c, h) {
        return c && Ts(h, Mn(h), c);
      }
      function wP(c, h) {
        return c && Ts(h, hi(h), c);
      }
      function uo(c, h, y) {
        h == "__proto__" && Ih ? Ih(c, h, {
          configurable: !0,
          enumerable: !0,
          value: y,
          writable: !0
        }) : c[h] = y;
      }
      function Yp(c, h) {
        for (var y = -1, O = h.length, q = Ie(O), ne = c == null; ++y < O; )
          q[y] = ne ? r : Cg(c, h[y]);
        return q;
      }
      function Fa(c, h, y) {
        return c === c && (y !== r && (c = c <= y ? c : y), h !== r && (c = c >= h ? c : h)), c;
      }
      function Wi(c, h, y, O, q, ne) {
        var le, me = h & p, we = h & w, We = h & A;
        if (y && (le = q ? y(c, O, q, ne) : y(c)), le !== r)
          return le;
        if (!Zr(c))
          return c;
        var He = ir(c);
        if (He) {
          if (le = cM(c), !me)
            return fi(c, le);
        } else {
          var Xe = Vn(c), wt = Xe == re || Xe == pe;
          if (ea(c))
            return ow(c, me);
          if (Xe == Pe || Xe == D || wt && !q) {
            if (le = we || wt ? {} : Aw(c), !me)
              return we ? XP(c, wP(le, c)) : JP(c, ky(le, c));
          } else {
            if (!Dr[Xe])
              return q ? c : {};
            le = uM(c, Xe, me);
          }
        }
        ne || (ne = new hs());
        var Ot = ne.get(c);
        if (Ot)
          return Ot;
        ne.set(c, le), e2(c) ? c.forEach(function(Kt) {
          le.add(Wi(Kt, h, y, Kt, c, ne));
        }) : Zw(c) && c.forEach(function(Kt, vr) {
          le.set(vr, Wi(Kt, h, y, vr, c, ne));
        });
        var Ht = We ? we ? gg : pg : we ? hi : Mn, fr = He ? r : Ht(c);
        return Ui(fr || c, function(Kt, vr) {
          fr && (vr = Kt, Kt = c[vr]), of(le, vr, Wi(Kt, h, y, vr, c, ne));
        }), le;
      }
      function xP(c) {
        var h = Mn(c);
        return function(y) {
          return $y(y, c, h);
        };
      }
      function $y(c, h, y) {
        var O = y.length;
        if (c == null)
          return !O;
        for (c = qr(c); O--; ) {
          var q = y[O], ne = h[q], le = c[q];
          if (le === r && !(q in c) || !ne(le))
            return !1;
        }
        return !0;
      }
      function By(c, h, y) {
        if (typeof c != "function")
          throw new qi(o);
        return df(function() {
          c.apply(r, y);
        }, h);
      }
      function af(c, h, y, O) {
        var q = -1, ne = vh, le = !0, me = c.length, we = [], We = h.length;
        if (!me)
          return we;
        y && (h = Xr(h, Ai(y))), O ? (ne = Lp, le = !1) : h.length >= i && (ne = Qu, le = !1, h = new Ba(h));
        e:
          for (; ++q < me; ) {
            var He = c[q], Xe = y == null ? He : y(He);
            if (He = O || He !== 0 ? He : 0, le && Xe === Xe) {
              for (var wt = We; wt--; )
                if (h[wt] === Xe)
                  continue e;
              we.push(He);
            } else ne(h, Xe, O) || we.push(He);
          }
        return we;
      }
      var Jo = lw(Cs), Fy = lw(Xp, !0);
      function _P(c, h) {
        var y = !0;
        return Jo(c, function(O, q, ne) {
          return y = !!h(O, q, ne), y;
        }), y;
      }
      function Lh(c, h, y) {
        for (var O = -1, q = c.length; ++O < q; ) {
          var ne = c[O], le = h(ne);
          if (le != null && (me === r ? le === le && !Mi(le) : y(le, me)))
            var me = le, we = ne;
        }
        return we;
      }
      function EP(c, h, y, O) {
        var q = c.length;
        for (y = cr(y), y < 0 && (y = -y > q ? 0 : q + y), O = O === r || O > q ? q : cr(O), O < 0 && (O += q), O = y > O ? 0 : r2(O); y < O; )
          c[y++] = h;
        return c;
      }
      function jy(c, h) {
        var y = [];
        return Jo(c, function(O, q, ne) {
          h(O, q, ne) && y.push(O);
        }), y;
      }
      function Bn(c, h, y, O, q) {
        var ne = -1, le = c.length;
        for (y || (y = lM), q || (q = []); ++ne < le; ) {
          var me = c[ne];
          h > 0 && y(me) ? h > 1 ? Bn(me, h - 1, y, O, q) : Vo(q, me) : O || (q[q.length] = me);
        }
        return q;
      }
      var Jp = hw(), Uy = hw(!0);
      function Cs(c, h) {
        return c && Jp(c, h, Mn);
      }
      function Xp(c, h) {
        return c && Uy(c, h, Mn);
      }
      function kh(c, h) {
        return Ko(h, function(y) {
          return po(c[y]);
        });
      }
      function ja(c, h) {
        h = Zo(h, c);
        for (var y = 0, O = h.length; c != null && y < O; )
          c = c[Rs(h[y++])];
        return y && y == O ? c : r;
      }
      function qy(c, h, y) {
        var O = h(c);
        return ir(c) ? O : Vo(O, y(c));
      }
      function ti(c) {
        return c == null ? c === r ? Le : ve : ka && ka in qr(c) ? sM(c) : bM(c);
      }
      function Zp(c, h) {
        return c > h;
      }
      function SP(c, h) {
        return c != null && Tr.call(c, h);
      }
      function AP(c, h) {
        return c != null && h in qr(c);
      }
      function PP(c, h, y) {
        return c >= Kn(h, y) && c < _n(h, y);
      }
      function Qp(c, h, y) {
        for (var O = y ? Lp : vh, q = c[0].length, ne = c.length, le = ne, me = Ie(ne), we = 1 / 0, We = []; le--; ) {
          var He = c[le];
          le && h && (He = Xr(He, Ai(h))), we = Kn(He.length, we), me[le] = !y && (h || q >= 120 && He.length >= 120) ? new Ba(le && He) : r;
        }
        He = c[0];
        var Xe = -1, wt = me[0];
        e:
          for (; ++Xe < q && We.length < we; ) {
            var Ot = He[Xe], Ht = h ? h(Ot) : Ot;
            if (Ot = y || Ot !== 0 ? Ot : 0, !(wt ? Qu(wt, Ht) : O(We, Ht, y))) {
              for (le = ne; --le; ) {
                var fr = me[le];
                if (!(fr ? Qu(fr, Ht) : O(c[le], Ht, y)))
                  continue e;
              }
              wt && wt.push(Ht), We.push(Ot);
            }
          }
        return We;
      }
      function MP(c, h, y, O) {
        return Cs(c, function(q, ne, le) {
          h(O, y(q), ne, le);
        }), O;
      }
      function cf(c, h, y) {
        h = Zo(h, c), c = Cw(c, h);
        var O = c == null ? c : c[Rs(Ki(h))];
        return O == null ? r : Pn(O, c, y);
      }
      function zy(c) {
        return en(c) && ti(c) == D;
      }
      function IP(c) {
        return en(c) && ti(c) == _e;
      }
      function CP(c) {
        return en(c) && ti(c) == Q;
      }
      function uf(c, h, y, O, q) {
        return c === h ? !0 : c == null || h == null || !en(c) && !en(h) ? c !== c && h !== h : TP(c, h, y, O, uf, q);
      }
      function TP(c, h, y, O, q, ne) {
        var le = ir(c), me = ir(h), we = le ? oe : Vn(c), We = me ? oe : Vn(h);
        we = we == D ? Pe : we, We = We == D ? Pe : We;
        var He = we == Pe, Xe = We == Pe, wt = we == We;
        if (wt && ea(c)) {
          if (!ea(h))
            return !1;
          le = !0, He = !1;
        }
        if (wt && !He)
          return ne || (ne = new hs()), le || jc(c) ? _w(c, h, y, O, q, ne) : nM(c, h, we, y, O, q, ne);
        if (!(y & P)) {
          var Ot = He && Tr.call(c, "__wrapped__"), Ht = Xe && Tr.call(h, "__wrapped__");
          if (Ot || Ht) {
            var fr = Ot ? c.value() : c, Kt = Ht ? h.value() : h;
            return ne || (ne = new hs()), q(fr, Kt, y, O, ne);
          }
        }
        return wt ? (ne || (ne = new hs()), iM(c, h, y, O, q, ne)) : !1;
      }
      function RP(c) {
        return en(c) && Vn(c) == ie;
      }
      function eg(c, h, y, O) {
        var q = y.length, ne = q, le = !O;
        if (c == null)
          return !ne;
        for (c = qr(c); q--; ) {
          var me = y[q];
          if (le && me[2] ? me[1] !== c[me[0]] : !(me[0] in c))
            return !1;
        }
        for (; ++q < ne; ) {
          me = y[q];
          var we = me[0], We = c[we], He = me[1];
          if (le && me[2]) {
            if (We === r && !(we in c))
              return !1;
          } else {
            var Xe = new hs();
            if (O)
              var wt = O(We, He, we, c, h, Xe);
            if (!(wt === r ? uf(He, We, P | N, O, Xe) : wt))
              return !1;
          }
        }
        return !0;
      }
      function Wy(c) {
        if (!Zr(c) || dM(c))
          return !1;
        var h = po(c) ? RA : je;
        return h.test(qa(c));
      }
      function DP(c) {
        return en(c) && ti(c) == $e;
      }
      function OP(c) {
        return en(c) && Vn(c) == Me;
      }
      function NP(c) {
        return en(c) && Qh(c.length) && !!Fr[ti(c)];
      }
      function Hy(c) {
        return typeof c == "function" ? c : c == null ? di : typeof c == "object" ? ir(c) ? Gy(c[0], c[1]) : Vy(c) : d2(c);
      }
      function tg(c) {
        if (!hf(c))
          return $A(c);
        var h = [];
        for (var y in qr(c))
          Tr.call(c, y) && y != "constructor" && h.push(y);
        return h;
      }
      function LP(c) {
        if (!Zr(c))
          return vM(c);
        var h = hf(c), y = [];
        for (var O in c)
          O == "constructor" && (h || !Tr.call(c, O)) || y.push(O);
        return y;
      }
      function rg(c, h) {
        return c < h;
      }
      function Ky(c, h) {
        var y = -1, O = li(c) ? Ie(c.length) : [];
        return Jo(c, function(q, ne, le) {
          O[++y] = h(q, ne, le);
        }), O;
      }
      function Vy(c) {
        var h = vg(c);
        return h.length == 1 && h[0][2] ? Mw(h[0][0], h[0][1]) : function(y) {
          return y === c || eg(y, c, h);
        };
      }
      function Gy(c, h) {
        return yg(c) && Pw(h) ? Mw(Rs(c), h) : function(y) {
          var O = Cg(y, c);
          return O === r && O === h ? Tg(y, c) : uf(h, O, P | N);
        };
      }
      function $h(c, h, y, O, q) {
        c !== h && Jp(h, function(ne, le) {
          if (q || (q = new hs()), Zr(ne))
            kP(c, h, le, y, $h, O, q);
          else {
            var me = O ? O(xg(c, le), ne, le + "", c, h, q) : r;
            me === r && (me = ne), Gp(c, le, me);
          }
        }, hi);
      }
      function kP(c, h, y, O, q, ne, le) {
        var me = xg(c, y), we = xg(h, y), We = le.get(we);
        if (We) {
          Gp(c, y, We);
          return;
        }
        var He = ne ? ne(me, we, y + "", c, h, le) : r, Xe = He === r;
        if (Xe) {
          var wt = ir(we), Ot = !wt && ea(we), Ht = !wt && !Ot && jc(we);
          He = we, wt || Ot || Ht ? ir(me) ? He = me : cn(me) ? He = fi(me) : Ot ? (Xe = !1, He = ow(we, !0)) : Ht ? (Xe = !1, He = aw(we, !0)) : He = [] : pf(we) || za(we) ? (He = me, za(me) ? He = n2(me) : (!Zr(me) || po(me)) && (He = Aw(we))) : Xe = !1;
        }
        Xe && (le.set(we, He), q(He, we, O, ne, le), le.delete(we)), Gp(c, y, He);
      }
      function Yy(c, h) {
        var y = c.length;
        if (y)
          return h += h < 0 ? y : 0, ho(h, y) ? c[h] : r;
      }
      function Jy(c, h, y) {
        h.length ? h = Xr(h, function(ne) {
          return ir(ne) ? function(le) {
            return ja(le, ne.length === 1 ? ne[0] : ne);
          } : ne;
        }) : h = [di];
        var O = -1;
        h = Xr(h, Ai(Ut()));
        var q = Ky(c, function(ne, le, me) {
          var we = Xr(h, function(We) {
            return We(ne);
          });
          return { criteria: we, index: ++O, value: ne };
        });
        return uA(q, function(ne, le) {
          return YP(ne, le, y);
        });
      }
      function $P(c, h) {
        return Xy(c, h, function(y, O) {
          return Tg(c, O);
        });
      }
      function Xy(c, h, y) {
        for (var O = -1, q = h.length, ne = {}; ++O < q; ) {
          var le = h[O], me = ja(c, le);
          y(me, le) && ff(ne, Zo(le, c), me);
        }
        return ne;
      }
      function BP(c) {
        return function(h) {
          return ja(h, c);
        };
      }
      function ng(c, h, y, O) {
        var q = O ? cA : Cc, ne = -1, le = h.length, me = c;
        for (c === h && (h = fi(h)), y && (me = Xr(c, Ai(y))); ++ne < le; )
          for (var we = 0, We = h[ne], He = y ? y(We) : We; (we = q(me, He, we, O)) > -1; )
            me !== c && Mh.call(me, we, 1), Mh.call(c, we, 1);
        return c;
      }
      function Zy(c, h) {
        for (var y = c ? h.length : 0, O = y - 1; y--; ) {
          var q = h[y];
          if (y == O || q !== ne) {
            var ne = q;
            ho(q) ? Mh.call(c, q, 1) : ag(c, q);
          }
        }
        return c;
      }
      function ig(c, h) {
        return c + Th(Dy() * (h - c + 1));
      }
      function FP(c, h, y, O) {
        for (var q = -1, ne = _n(Ch((h - c) / (y || 1)), 0), le = Ie(ne); ne--; )
          le[O ? ne : ++q] = c, c += y;
        return le;
      }
      function sg(c, h) {
        var y = "";
        if (!c || h < 1 || h > _)
          return y;
        do
          h % 2 && (y += c), h = Th(h / 2), h && (c += c);
        while (h);
        return y;
      }
      function hr(c, h) {
        return _g(Iw(c, h, di), c + "");
      }
      function jP(c) {
        return Ly(Uc(c));
      }
      function UP(c, h) {
        var y = Uc(c);
        return Vh(y, Fa(h, 0, y.length));
      }
      function ff(c, h, y, O) {
        if (!Zr(c))
          return c;
        h = Zo(h, c);
        for (var q = -1, ne = h.length, le = ne - 1, me = c; me != null && ++q < ne; ) {
          var we = Rs(h[q]), We = y;
          if (we === "__proto__" || we === "constructor" || we === "prototype")
            return c;
          if (q != le) {
            var He = me[we];
            We = O ? O(He, we, me) : r, We === r && (We = Zr(He) ? He : ho(h[q + 1]) ? [] : {});
          }
          of(me, we, We), me = me[we];
        }
        return c;
      }
      var Qy = Rh ? function(c, h) {
        return Rh.set(c, h), c;
      } : di, qP = Ih ? function(c, h) {
        return Ih(c, "toString", {
          configurable: !0,
          enumerable: !1,
          value: Dg(h),
          writable: !0
        });
      } : di;
      function zP(c) {
        return Vh(Uc(c));
      }
      function Hi(c, h, y) {
        var O = -1, q = c.length;
        h < 0 && (h = -h > q ? 0 : q + h), y = y > q ? q : y, y < 0 && (y += q), q = h > y ? 0 : y - h >>> 0, h >>>= 0;
        for (var ne = Ie(q); ++O < q; )
          ne[O] = c[O + h];
        return ne;
      }
      function WP(c, h) {
        var y;
        return Jo(c, function(O, q, ne) {
          return y = h(O, q, ne), !y;
        }), !!y;
      }
      function Bh(c, h, y) {
        var O = 0, q = c == null ? O : c.length;
        if (typeof h == "number" && h === h && q <= F) {
          for (; O < q; ) {
            var ne = O + q >>> 1, le = c[ne];
            le !== null && !Mi(le) && (y ? le <= h : le < h) ? O = ne + 1 : q = ne;
          }
          return q;
        }
        return og(c, h, di, y);
      }
      function og(c, h, y, O) {
        var q = 0, ne = c == null ? 0 : c.length;
        if (ne === 0)
          return 0;
        h = y(h);
        for (var le = h !== h, me = h === null, we = Mi(h), We = h === r; q < ne; ) {
          var He = Th((q + ne) / 2), Xe = y(c[He]), wt = Xe !== r, Ot = Xe === null, Ht = Xe === Xe, fr = Mi(Xe);
          if (le)
            var Kt = O || Ht;
          else We ? Kt = Ht && (O || wt) : me ? Kt = Ht && wt && (O || !Ot) : we ? Kt = Ht && wt && !Ot && (O || !fr) : Ot || fr ? Kt = !1 : Kt = O ? Xe <= h : Xe < h;
          Kt ? q = He + 1 : ne = He;
        }
        return Kn(ne, I);
      }
      function ew(c, h) {
        for (var y = -1, O = c.length, q = 0, ne = []; ++y < O; ) {
          var le = c[y], me = h ? h(le) : le;
          if (!y || !ds(me, we)) {
            var we = me;
            ne[q++] = le === 0 ? 0 : le;
          }
        }
        return ne;
      }
      function tw(c) {
        return typeof c == "number" ? c : Mi(c) ? v : +c;
      }
      function Pi(c) {
        if (typeof c == "string")
          return c;
        if (ir(c))
          return Xr(c, Pi) + "";
        if (Mi(c))
          return Oy ? Oy.call(c) : "";
        var h = c + "";
        return h == "0" && 1 / c == -x ? "-0" : h;
      }
      function Xo(c, h, y) {
        var O = -1, q = vh, ne = c.length, le = !0, me = [], we = me;
        if (y)
          le = !1, q = Lp;
        else if (ne >= i) {
          var We = h ? null : tM(c);
          if (We)
            return yh(We);
          le = !1, q = Qu, we = new Ba();
        } else
          we = h ? [] : me;
        e:
          for (; ++O < ne; ) {
            var He = c[O], Xe = h ? h(He) : He;
            if (He = y || He !== 0 ? He : 0, le && Xe === Xe) {
              for (var wt = we.length; wt--; )
                if (we[wt] === Xe)
                  continue e;
              h && we.push(Xe), me.push(He);
            } else q(we, Xe, y) || (we !== me && we.push(Xe), me.push(He));
          }
        return me;
      }
      function ag(c, h) {
        return h = Zo(h, c), c = Cw(c, h), c == null || delete c[Rs(Ki(h))];
      }
      function rw(c, h, y, O) {
        return ff(c, h, y(ja(c, h)), O);
      }
      function Fh(c, h, y, O) {
        for (var q = c.length, ne = O ? q : -1; (O ? ne-- : ++ne < q) && h(c[ne], ne, c); )
          ;
        return y ? Hi(c, O ? 0 : ne, O ? ne + 1 : q) : Hi(c, O ? ne + 1 : 0, O ? q : ne);
      }
      function nw(c, h) {
        var y = c;
        return y instanceof wr && (y = y.value()), kp(h, function(O, q) {
          return q.func.apply(q.thisArg, Vo([O], q.args));
        }, y);
      }
      function cg(c, h, y) {
        var O = c.length;
        if (O < 2)
          return O ? Xo(c[0]) : [];
        for (var q = -1, ne = Ie(O); ++q < O; )
          for (var le = c[q], me = -1; ++me < O; )
            me != q && (ne[q] = af(ne[q] || le, c[me], h, y));
        return Xo(Bn(ne, 1), h, y);
      }
      function iw(c, h, y) {
        for (var O = -1, q = c.length, ne = h.length, le = {}; ++O < q; ) {
          var me = O < ne ? h[O] : r;
          y(le, c[O], me);
        }
        return le;
      }
      function ug(c) {
        return cn(c) ? c : [];
      }
      function fg(c) {
        return typeof c == "function" ? c : di;
      }
      function Zo(c, h) {
        return ir(c) ? c : yg(c, h) ? [c] : Ow(Cr(c));
      }
      var HP = hr;
      function Qo(c, h, y) {
        var O = c.length;
        return y = y === r ? O : y, !h && y >= O ? c : Hi(c, h, y);
      }
      var sw = DA || function(c) {
        return _r.clearTimeout(c);
      };
      function ow(c, h) {
        if (h)
          return c.slice();
        var y = c.length, O = My ? My(y) : new c.constructor(y);
        return c.copy(O), O;
      }
      function lg(c) {
        var h = new c.constructor(c.byteLength);
        return new Ah(h).set(new Ah(c)), h;
      }
      function KP(c, h) {
        var y = h ? lg(c.buffer) : c.buffer;
        return new c.constructor(y, c.byteOffset, c.byteLength);
      }
      function VP(c) {
        var h = new c.constructor(c.source, Te.exec(c));
        return h.lastIndex = c.lastIndex, h;
      }
      function GP(c) {
        return sf ? qr(sf.call(c)) : {};
      }
      function aw(c, h) {
        var y = h ? lg(c.buffer) : c.buffer;
        return new c.constructor(y, c.byteOffset, c.length);
      }
      function cw(c, h) {
        if (c !== h) {
          var y = c !== r, O = c === null, q = c === c, ne = Mi(c), le = h !== r, me = h === null, we = h === h, We = Mi(h);
          if (!me && !We && !ne && c > h || ne && le && we && !me && !We || O && le && we || !y && we || !q)
            return 1;
          if (!O && !ne && !We && c < h || We && y && q && !O && !ne || me && y && q || !le && q || !we)
            return -1;
        }
        return 0;
      }
      function YP(c, h, y) {
        for (var O = -1, q = c.criteria, ne = h.criteria, le = q.length, me = y.length; ++O < le; ) {
          var we = cw(q[O], ne[O]);
          if (we) {
            if (O >= me)
              return we;
            var We = y[O];
            return we * (We == "desc" ? -1 : 1);
          }
        }
        return c.index - h.index;
      }
      function uw(c, h, y, O) {
        for (var q = -1, ne = c.length, le = y.length, me = -1, we = h.length, We = _n(ne - le, 0), He = Ie(we + We), Xe = !O; ++me < we; )
          He[me] = h[me];
        for (; ++q < le; )
          (Xe || q < ne) && (He[y[q]] = c[q]);
        for (; We--; )
          He[me++] = c[q++];
        return He;
      }
      function fw(c, h, y, O) {
        for (var q = -1, ne = c.length, le = -1, me = y.length, we = -1, We = h.length, He = _n(ne - me, 0), Xe = Ie(He + We), wt = !O; ++q < He; )
          Xe[q] = c[q];
        for (var Ot = q; ++we < We; )
          Xe[Ot + we] = h[we];
        for (; ++le < me; )
          (wt || q < ne) && (Xe[Ot + y[le]] = c[q++]);
        return Xe;
      }
      function fi(c, h) {
        var y = -1, O = c.length;
        for (h || (h = Ie(O)); ++y < O; )
          h[y] = c[y];
        return h;
      }
      function Ts(c, h, y, O) {
        var q = !y;
        y || (y = {});
        for (var ne = -1, le = h.length; ++ne < le; ) {
          var me = h[ne], we = O ? O(y[me], c[me], me, y, c) : r;
          we === r && (we = c[me]), q ? uo(y, me, we) : of(y, me, we);
        }
        return y;
      }
      function JP(c, h) {
        return Ts(c, bg(c), h);
      }
      function XP(c, h) {
        return Ts(c, Ew(c), h);
      }
      function jh(c, h) {
        return function(y, O) {
          var q = ir(y) ? rA : yP, ne = h ? h() : {};
          return q(y, c, Ut(O, 2), ne);
        };
      }
      function $c(c) {
        return hr(function(h, y) {
          var O = -1, q = y.length, ne = q > 1 ? y[q - 1] : r, le = q > 2 ? y[2] : r;
          for (ne = c.length > 3 && typeof ne == "function" ? (q--, ne) : r, le && ri(y[0], y[1], le) && (ne = q < 3 ? r : ne, q = 1), h = qr(h); ++O < q; ) {
            var me = y[O];
            me && c(h, me, O, ne);
          }
          return h;
        });
      }
      function lw(c, h) {
        return function(y, O) {
          if (y == null)
            return y;
          if (!li(y))
            return c(y, O);
          for (var q = y.length, ne = h ? q : -1, le = qr(y); (h ? ne-- : ++ne < q) && O(le[ne], ne, le) !== !1; )
            ;
          return y;
        };
      }
      function hw(c) {
        return function(h, y, O) {
          for (var q = -1, ne = qr(h), le = O(h), me = le.length; me--; ) {
            var we = le[c ? me : ++q];
            if (y(ne[we], we, ne) === !1)
              break;
          }
          return h;
        };
      }
      function ZP(c, h, y) {
        var O = h & L, q = lf(c);
        function ne() {
          var le = this && this !== _r && this instanceof ne ? q : c;
          return le.apply(O ? y : this, arguments);
        }
        return ne;
      }
      function dw(c) {
        return function(h) {
          h = Cr(h);
          var y = Tc(h) ? ls(h) : r, O = y ? y[0] : h.charAt(0), q = y ? Qo(y, 1).join("") : h.slice(1);
          return O[c]() + q;
        };
      }
      function Bc(c) {
        return function(h) {
          return kp(l2(f2(h).replace(Xu, "")), c, "");
        };
      }
      function lf(c) {
        return function() {
          var h = arguments;
          switch (h.length) {
            case 0:
              return new c();
            case 1:
              return new c(h[0]);
            case 2:
              return new c(h[0], h[1]);
            case 3:
              return new c(h[0], h[1], h[2]);
            case 4:
              return new c(h[0], h[1], h[2], h[3]);
            case 5:
              return new c(h[0], h[1], h[2], h[3], h[4]);
            case 6:
              return new c(h[0], h[1], h[2], h[3], h[4], h[5]);
            case 7:
              return new c(h[0], h[1], h[2], h[3], h[4], h[5], h[6]);
          }
          var y = kc(c.prototype), O = c.apply(y, h);
          return Zr(O) ? O : y;
        };
      }
      function QP(c, h, y) {
        var O = lf(c);
        function q() {
          for (var ne = arguments.length, le = Ie(ne), me = ne, we = Fc(q); me--; )
            le[me] = arguments[me];
          var We = ne < 3 && le[0] !== we && le[ne - 1] !== we ? [] : Go(le, we);
          if (ne -= We.length, ne < y)
            return bw(
              c,
              h,
              Uh,
              q.placeholder,
              r,
              le,
              We,
              r,
              r,
              y - ne
            );
          var He = this && this !== _r && this instanceof q ? O : c;
          return Pn(He, this, le);
        }
        return q;
      }
      function pw(c) {
        return function(h, y, O) {
          var q = qr(h);
          if (!li(h)) {
            var ne = Ut(y, 3);
            h = Mn(h), y = function(me) {
              return ne(q[me], me, q);
            };
          }
          var le = c(h, y, O);
          return le > -1 ? q[ne ? h[le] : le] : r;
        };
      }
      function gw(c) {
        return lo(function(h) {
          var y = h.length, O = y, q = zi.prototype.thru;
          for (c && h.reverse(); O--; ) {
            var ne = h[O];
            if (typeof ne != "function")
              throw new qi(o);
            if (q && !le && Hh(ne) == "wrapper")
              var le = new zi([], !0);
          }
          for (O = le ? O : y; ++O < y; ) {
            ne = h[O];
            var me = Hh(ne), we = me == "wrapper" ? mg(ne) : r;
            we && wg(we[0]) && we[1] == (R | H | V | K) && !we[4].length && we[9] == 1 ? le = le[Hh(we[0])].apply(le, we[3]) : le = ne.length == 1 && wg(ne) ? le[me]() : le.thru(ne);
          }
          return function() {
            var We = arguments, He = We[0];
            if (le && We.length == 1 && ir(He))
              return le.plant(He).value();
            for (var Xe = 0, wt = y ? h[Xe].apply(this, We) : He; ++Xe < y; )
              wt = h[Xe].call(this, wt);
            return wt;
          };
        });
      }
      function Uh(c, h, y, O, q, ne, le, me, we, We) {
        var He = h & R, Xe = h & L, wt = h & $, Ot = h & (H | W), Ht = h & ge, fr = wt ? r : lf(c);
        function Kt() {
          for (var vr = arguments.length, Er = Ie(vr), Ii = vr; Ii--; )
            Er[Ii] = arguments[Ii];
          if (Ot)
            var ni = Fc(Kt), Ci = lA(Er, ni);
          if (O && (Er = uw(Er, O, q, Ot)), ne && (Er = fw(Er, ne, le, Ot)), vr -= Ci, Ot && vr < We) {
            var un = Go(Er, ni);
            return bw(
              c,
              h,
              Uh,
              Kt.placeholder,
              y,
              Er,
              un,
              me,
              we,
              We - vr
            );
          }
          var ps = Xe ? y : this, mo = wt ? ps[c] : c;
          return vr = Er.length, me ? Er = yM(Er, me) : Ht && vr > 1 && Er.reverse(), He && we < vr && (Er.length = we), this && this !== _r && this instanceof Kt && (mo = fr || lf(mo)), mo.apply(ps, Er);
        }
        return Kt;
      }
      function mw(c, h) {
        return function(y, O) {
          return MP(y, c, h(O), {});
        };
      }
      function qh(c, h) {
        return function(y, O) {
          var q;
          if (y === r && O === r)
            return h;
          if (y !== r && (q = y), O !== r) {
            if (q === r)
              return O;
            typeof y == "string" || typeof O == "string" ? (y = Pi(y), O = Pi(O)) : (y = tw(y), O = tw(O)), q = c(y, O);
          }
          return q;
        };
      }
      function hg(c) {
        return lo(function(h) {
          return h = Xr(h, Ai(Ut())), hr(function(y) {
            var O = this;
            return c(h, function(q) {
              return Pn(q, O, y);
            });
          });
        });
      }
      function zh(c, h) {
        h = h === r ? " " : Pi(h);
        var y = h.length;
        if (y < 2)
          return y ? sg(h, c) : h;
        var O = sg(h, Ch(c / Rc(h)));
        return Tc(h) ? Qo(ls(O), 0, c).join("") : O.slice(0, c);
      }
      function eM(c, h, y, O) {
        var q = h & L, ne = lf(c);
        function le() {
          for (var me = -1, we = arguments.length, We = -1, He = O.length, Xe = Ie(He + we), wt = this && this !== _r && this instanceof le ? ne : c; ++We < He; )
            Xe[We] = O[We];
          for (; we--; )
            Xe[We++] = arguments[++me];
          return Pn(wt, q ? y : this, Xe);
        }
        return le;
      }
      function vw(c) {
        return function(h, y, O) {
          return O && typeof O != "number" && ri(h, y, O) && (y = O = r), h = go(h), y === r ? (y = h, h = 0) : y = go(y), O = O === r ? h < y ? 1 : -1 : go(O), FP(h, y, O, c);
        };
      }
      function Wh(c) {
        return function(h, y) {
          return typeof h == "string" && typeof y == "string" || (h = Vi(h), y = Vi(y)), c(h, y);
        };
      }
      function bw(c, h, y, O, q, ne, le, me, we, We) {
        var He = h & H, Xe = He ? le : r, wt = He ? r : le, Ot = He ? ne : r, Ht = He ? r : ne;
        h |= He ? V : te, h &= ~(He ? te : V), h & B || (h &= ~(L | $));
        var fr = [
          c,
          h,
          q,
          Ot,
          Xe,
          Ht,
          wt,
          me,
          we,
          We
        ], Kt = y.apply(r, fr);
        return wg(c) && Tw(Kt, fr), Kt.placeholder = O, Rw(Kt, c, h);
      }
      function dg(c) {
        var h = xn[c];
        return function(y, O) {
          if (y = Vi(y), O = O == null ? 0 : Kn(cr(O), 292), O && Ry(y)) {
            var q = (Cr(y) + "e").split("e"), ne = h(q[0] + "e" + (+q[1] + O));
            return q = (Cr(ne) + "e").split("e"), +(q[0] + "e" + (+q[1] - O));
          }
          return h(y);
        };
      }
      var tM = Nc && 1 / yh(new Nc([, -0]))[1] == x ? function(c) {
        return new Nc(c);
      } : Lg;
      function yw(c) {
        return function(h) {
          var y = Vn(h);
          return y == ie ? zp(h) : y == Me ? bA(h) : fA(h, c(h));
        };
      }
      function fo(c, h, y, O, q, ne, le, me) {
        var we = h & $;
        if (!we && typeof c != "function")
          throw new qi(o);
        var We = O ? O.length : 0;
        if (We || (h &= ~(V | te), O = q = r), le = le === r ? le : _n(cr(le), 0), me = me === r ? me : cr(me), We -= q ? q.length : 0, h & te) {
          var He = O, Xe = q;
          O = q = r;
        }
        var wt = we ? r : mg(c), Ot = [
          c,
          h,
          y,
          O,
          q,
          He,
          Xe,
          ne,
          le,
          me
        ];
        if (wt && mM(Ot, wt), c = Ot[0], h = Ot[1], y = Ot[2], O = Ot[3], q = Ot[4], me = Ot[9] = Ot[9] === r ? we ? 0 : c.length : _n(Ot[9] - We, 0), !me && h & (H | W) && (h &= ~(H | W)), !h || h == L)
          var Ht = ZP(c, h, y);
        else h == H || h == W ? Ht = QP(c, h, me) : (h == V || h == (L | V)) && !q.length ? Ht = eM(c, h, y, O) : Ht = Uh.apply(r, Ot);
        var fr = wt ? Qy : Tw;
        return Rw(fr(Ht, Ot), c, h);
      }
      function ww(c, h, y, O) {
        return c === r || ds(c, Oc[y]) && !Tr.call(O, y) ? h : c;
      }
      function xw(c, h, y, O, q, ne) {
        return Zr(c) && Zr(h) && (ne.set(h, c), $h(c, h, r, xw, ne), ne.delete(h)), c;
      }
      function rM(c) {
        return pf(c) ? r : c;
      }
      function _w(c, h, y, O, q, ne) {
        var le = y & P, me = c.length, we = h.length;
        if (me != we && !(le && we > me))
          return !1;
        var We = ne.get(c), He = ne.get(h);
        if (We && He)
          return We == h && He == c;
        var Xe = -1, wt = !0, Ot = y & N ? new Ba() : r;
        for (ne.set(c, h), ne.set(h, c); ++Xe < me; ) {
          var Ht = c[Xe], fr = h[Xe];
          if (O)
            var Kt = le ? O(fr, Ht, Xe, h, c, ne) : O(Ht, fr, Xe, c, h, ne);
          if (Kt !== r) {
            if (Kt)
              continue;
            wt = !1;
            break;
          }
          if (Ot) {
            if (!$p(h, function(vr, Er) {
              if (!Qu(Ot, Er) && (Ht === vr || q(Ht, vr, y, O, ne)))
                return Ot.push(Er);
            })) {
              wt = !1;
              break;
            }
          } else if (!(Ht === fr || q(Ht, fr, y, O, ne))) {
            wt = !1;
            break;
          }
        }
        return ne.delete(c), ne.delete(h), wt;
      }
      function nM(c, h, y, O, q, ne, le) {
        switch (y) {
          case Ze:
            if (c.byteLength != h.byteLength || c.byteOffset != h.byteOffset)
              return !1;
            c = c.buffer, h = h.buffer;
          case _e:
            return !(c.byteLength != h.byteLength || !ne(new Ah(c), new Ah(h)));
          case J:
          case Q:
          case ue:
            return ds(+c, +h);
          case X:
            return c.name == h.name && c.message == h.message;
          case $e:
          case Ne:
            return c == h + "";
          case ie:
            var me = zp;
          case Me:
            var we = O & P;
            if (me || (me = yh), c.size != h.size && !we)
              return !1;
            var We = le.get(c);
            if (We)
              return We == h;
            O |= N, le.set(c, h);
            var He = _w(me(c), me(h), O, q, ne, le);
            return le.delete(c), He;
          case Ke:
            if (sf)
              return sf.call(c) == sf.call(h);
        }
        return !1;
      }
      function iM(c, h, y, O, q, ne) {
        var le = y & P, me = pg(c), we = me.length, We = pg(h), He = We.length;
        if (we != He && !le)
          return !1;
        for (var Xe = we; Xe--; ) {
          var wt = me[Xe];
          if (!(le ? wt in h : Tr.call(h, wt)))
            return !1;
        }
        var Ot = ne.get(c), Ht = ne.get(h);
        if (Ot && Ht)
          return Ot == h && Ht == c;
        var fr = !0;
        ne.set(c, h), ne.set(h, c);
        for (var Kt = le; ++Xe < we; ) {
          wt = me[Xe];
          var vr = c[wt], Er = h[wt];
          if (O)
            var Ii = le ? O(Er, vr, wt, h, c, ne) : O(vr, Er, wt, c, h, ne);
          if (!(Ii === r ? vr === Er || q(vr, Er, y, O, ne) : Ii)) {
            fr = !1;
            break;
          }
          Kt || (Kt = wt == "constructor");
        }
        if (fr && !Kt) {
          var ni = c.constructor, Ci = h.constructor;
          ni != Ci && "constructor" in c && "constructor" in h && !(typeof ni == "function" && ni instanceof ni && typeof Ci == "function" && Ci instanceof Ci) && (fr = !1);
        }
        return ne.delete(c), ne.delete(h), fr;
      }
      function lo(c) {
        return _g(Iw(c, r, $w), c + "");
      }
      function pg(c) {
        return qy(c, Mn, bg);
      }
      function gg(c) {
        return qy(c, hi, Ew);
      }
      var mg = Rh ? function(c) {
        return Rh.get(c);
      } : Lg;
      function Hh(c) {
        for (var h = c.name + "", y = Lc[h], O = Tr.call(Lc, h) ? y.length : 0; O--; ) {
          var q = y[O], ne = q.func;
          if (ne == null || ne == c)
            return q.name;
        }
        return h;
      }
      function Fc(c) {
        var h = Tr.call(ee, "placeholder") ? ee : c;
        return h.placeholder;
      }
      function Ut() {
        var c = ee.iteratee || Og;
        return c = c === Og ? Hy : c, arguments.length ? c(arguments[0], arguments[1]) : c;
      }
      function Kh(c, h) {
        var y = c.__data__;
        return hM(h) ? y[typeof h == "string" ? "string" : "hash"] : y.map;
      }
      function vg(c) {
        for (var h = Mn(c), y = h.length; y--; ) {
          var O = h[y], q = c[O];
          h[y] = [O, q, Pw(q)];
        }
        return h;
      }
      function Ua(c, h) {
        var y = gA(c, h);
        return Wy(y) ? y : r;
      }
      function sM(c) {
        var h = Tr.call(c, ka), y = c[ka];
        try {
          c[ka] = r;
          var O = !0;
        } catch {
        }
        var q = Eh.call(c);
        return O && (h ? c[ka] = y : delete c[ka]), q;
      }
      var bg = Hp ? function(c) {
        return c == null ? [] : (c = qr(c), Ko(Hp(c), function(h) {
          return Cy.call(c, h);
        }));
      } : kg, Ew = Hp ? function(c) {
        for (var h = []; c; )
          Vo(h, bg(c)), c = Ph(c);
        return h;
      } : kg, Vn = ti;
      (Kp && Vn(new Kp(new ArrayBuffer(1))) != Ze || tf && Vn(new tf()) != ie || Vp && Vn(Vp.resolve()) != De || Nc && Vn(new Nc()) != Me || rf && Vn(new rf()) != qe) && (Vn = function(c) {
        var h = ti(c), y = h == Pe ? c.constructor : r, O = y ? qa(y) : "";
        if (O)
          switch (O) {
            case UA:
              return Ze;
            case qA:
              return ie;
            case zA:
              return De;
            case WA:
              return Me;
            case HA:
              return qe;
          }
        return h;
      });
      function oM(c, h, y) {
        for (var O = -1, q = y.length; ++O < q; ) {
          var ne = y[O], le = ne.size;
          switch (ne.type) {
            case "drop":
              c += le;
              break;
            case "dropRight":
              h -= le;
              break;
            case "take":
              h = Kn(h, c + le);
              break;
            case "takeRight":
              c = _n(c, h - le);
              break;
          }
        }
        return { start: c, end: h };
      }
      function aM(c) {
        var h = c.match(C);
        return h ? h[1].split(G) : [];
      }
      function Sw(c, h, y) {
        h = Zo(h, c);
        for (var O = -1, q = h.length, ne = !1; ++O < q; ) {
          var le = Rs(h[O]);
          if (!(ne = c != null && y(c, le)))
            break;
          c = c[le];
        }
        return ne || ++O != q ? ne : (q = c == null ? 0 : c.length, !!q && Qh(q) && ho(le, q) && (ir(c) || za(c)));
      }
      function cM(c) {
        var h = c.length, y = new c.constructor(h);
        return h && typeof c[0] == "string" && Tr.call(c, "index") && (y.index = c.index, y.input = c.input), y;
      }
      function Aw(c) {
        return typeof c.constructor == "function" && !hf(c) ? kc(Ph(c)) : {};
      }
      function uM(c, h, y) {
        var O = c.constructor;
        switch (h) {
          case _e:
            return lg(c);
          case J:
          case Q:
            return new O(+c);
          case Ze:
            return KP(c, y);
          case at:
          case ke:
          case Qe:
          case tt:
          case Ye:
          case dt:
          case lt:
          case ct:
          case qt:
            return aw(c, y);
          case ie:
            return new O();
          case ue:
          case Ne:
            return new O(c);
          case $e:
            return VP(c);
          case Me:
            return new O();
          case Ke:
            return GP(c);
        }
      }
      function fM(c, h) {
        var y = h.length;
        if (!y)
          return c;
        var O = y - 1;
        return h[O] = (y > 1 ? "& " : "") + h[O], h = h.join(y > 2 ? ", " : " "), c.replace(z, `{
/* [wrapped with ` + h + `] */
`);
      }
      function lM(c) {
        return ir(c) || za(c) || !!(Ty && c && c[Ty]);
      }
      function ho(c, h) {
        var y = typeof c;
        return h = h ?? _, !!h && (y == "number" || y != "symbol" && it.test(c)) && c > -1 && c % 1 == 0 && c < h;
      }
      function ri(c, h, y) {
        if (!Zr(y))
          return !1;
        var O = typeof h;
        return (O == "number" ? li(y) && ho(h, y.length) : O == "string" && h in y) ? ds(y[h], c) : !1;
      }
      function yg(c, h) {
        if (ir(c))
          return !1;
        var y = typeof c;
        return y == "number" || y == "symbol" || y == "boolean" || c == null || Mi(c) ? !0 : $t.test(c) || !vt.test(c) || h != null && c in qr(h);
      }
      function hM(c) {
        var h = typeof c;
        return h == "string" || h == "number" || h == "symbol" || h == "boolean" ? c !== "__proto__" : c === null;
      }
      function wg(c) {
        var h = Hh(c), y = ee[h];
        if (typeof y != "function" || !(h in wr.prototype))
          return !1;
        if (c === y)
          return !0;
        var O = mg(y);
        return !!O && c === O[0];
      }
      function dM(c) {
        return !!Py && Py in c;
      }
      var pM = xh ? po : $g;
      function hf(c) {
        var h = c && c.constructor, y = typeof h == "function" && h.prototype || Oc;
        return c === y;
      }
      function Pw(c) {
        return c === c && !Zr(c);
      }
      function Mw(c, h) {
        return function(y) {
          return y == null ? !1 : y[c] === h && (h !== r || c in qr(y));
        };
      }
      function gM(c) {
        var h = Xh(c, function(O) {
          return y.size === l && y.clear(), O;
        }), y = h.cache;
        return h;
      }
      function mM(c, h) {
        var y = c[1], O = h[1], q = y | O, ne = q < (L | $ | R), le = O == R && y == H || O == R && y == K && c[7].length <= h[8] || O == (R | K) && h[7].length <= h[8] && y == H;
        if (!(ne || le))
          return c;
        O & L && (c[2] = h[2], q |= y & L ? 0 : B);
        var me = h[3];
        if (me) {
          var we = c[3];
          c[3] = we ? uw(we, me, h[4]) : me, c[4] = we ? Go(c[3], d) : h[4];
        }
        return me = h[5], me && (we = c[5], c[5] = we ? fw(we, me, h[6]) : me, c[6] = we ? Go(c[5], d) : h[6]), me = h[7], me && (c[7] = me), O & R && (c[8] = c[8] == null ? h[8] : Kn(c[8], h[8])), c[9] == null && (c[9] = h[9]), c[0] = h[0], c[1] = q, c;
      }
      function vM(c) {
        var h = [];
        if (c != null)
          for (var y in qr(c))
            h.push(y);
        return h;
      }
      function bM(c) {
        return Eh.call(c);
      }
      function Iw(c, h, y) {
        return h = _n(h === r ? c.length - 1 : h, 0), function() {
          for (var O = arguments, q = -1, ne = _n(O.length - h, 0), le = Ie(ne); ++q < ne; )
            le[q] = O[h + q];
          q = -1;
          for (var me = Ie(h + 1); ++q < h; )
            me[q] = O[q];
          return me[h] = y(le), Pn(c, this, me);
        };
      }
      function Cw(c, h) {
        return h.length < 2 ? c : ja(c, Hi(h, 0, -1));
      }
      function yM(c, h) {
        for (var y = c.length, O = Kn(h.length, y), q = fi(c); O--; ) {
          var ne = h[O];
          c[O] = ho(ne, y) ? q[ne] : r;
        }
        return c;
      }
      function xg(c, h) {
        if (!(h === "constructor" && typeof c[h] == "function") && h != "__proto__")
          return c[h];
      }
      var Tw = Dw(Qy), df = NA || function(c, h) {
        return _r.setTimeout(c, h);
      }, _g = Dw(qP);
      function Rw(c, h, y) {
        var O = h + "";
        return _g(c, fM(O, wM(aM(O), y)));
      }
      function Dw(c) {
        var h = 0, y = 0;
        return function() {
          var O = BA(), q = m - (O - y);
          if (y = O, q > 0) {
            if (++h >= S)
              return arguments[0];
          } else
            h = 0;
          return c.apply(r, arguments);
        };
      }
      function Vh(c, h) {
        var y = -1, O = c.length, q = O - 1;
        for (h = h === r ? O : h; ++y < h; ) {
          var ne = ig(y, q), le = c[ne];
          c[ne] = c[y], c[y] = le;
        }
        return c.length = h, c;
      }
      var Ow = gM(function(c) {
        var h = [];
        return c.charCodeAt(0) === 46 && h.push(""), c.replace(Ft, function(y, O, q, ne) {
          h.push(q ? ne.replace(de, "$1") : O || y);
        }), h;
      });
      function Rs(c) {
        if (typeof c == "string" || Mi(c))
          return c;
        var h = c + "";
        return h == "0" && 1 / c == -x ? "-0" : h;
      }
      function qa(c) {
        if (c != null) {
          try {
            return _h.call(c);
          } catch {
          }
          try {
            return c + "";
          } catch {
          }
        }
        return "";
      }
      function wM(c, h) {
        return Ui(ce, function(y) {
          var O = "_." + y[0];
          h & y[1] && !vh(c, O) && c.push(O);
        }), c.sort();
      }
      function Nw(c) {
        if (c instanceof wr)
          return c.clone();
        var h = new zi(c.__wrapped__, c.__chain__);
        return h.__actions__ = fi(c.__actions__), h.__index__ = c.__index__, h.__values__ = c.__values__, h;
      }
      function xM(c, h, y) {
        (y ? ri(c, h, y) : h === r) ? h = 1 : h = _n(cr(h), 0);
        var O = c == null ? 0 : c.length;
        if (!O || h < 1)
          return [];
        for (var q = 0, ne = 0, le = Ie(Ch(O / h)); q < O; )
          le[ne++] = Hi(c, q, q += h);
        return le;
      }
      function _M(c) {
        for (var h = -1, y = c == null ? 0 : c.length, O = 0, q = []; ++h < y; ) {
          var ne = c[h];
          ne && (q[O++] = ne);
        }
        return q;
      }
      function EM() {
        var c = arguments.length;
        if (!c)
          return [];
        for (var h = Ie(c - 1), y = arguments[0], O = c; O--; )
          h[O - 1] = arguments[O];
        return Vo(ir(y) ? fi(y) : [y], Bn(h, 1));
      }
      var SM = hr(function(c, h) {
        return cn(c) ? af(c, Bn(h, 1, cn, !0)) : [];
      }), AM = hr(function(c, h) {
        var y = Ki(h);
        return cn(y) && (y = r), cn(c) ? af(c, Bn(h, 1, cn, !0), Ut(y, 2)) : [];
      }), PM = hr(function(c, h) {
        var y = Ki(h);
        return cn(y) && (y = r), cn(c) ? af(c, Bn(h, 1, cn, !0), r, y) : [];
      });
      function MM(c, h, y) {
        var O = c == null ? 0 : c.length;
        return O ? (h = y || h === r ? 1 : cr(h), Hi(c, h < 0 ? 0 : h, O)) : [];
      }
      function IM(c, h, y) {
        var O = c == null ? 0 : c.length;
        return O ? (h = y || h === r ? 1 : cr(h), h = O - h, Hi(c, 0, h < 0 ? 0 : h)) : [];
      }
      function CM(c, h) {
        return c && c.length ? Fh(c, Ut(h, 3), !0, !0) : [];
      }
      function TM(c, h) {
        return c && c.length ? Fh(c, Ut(h, 3), !0) : [];
      }
      function RM(c, h, y, O) {
        var q = c == null ? 0 : c.length;
        return q ? (y && typeof y != "number" && ri(c, h, y) && (y = 0, O = q), EP(c, h, y, O)) : [];
      }
      function Lw(c, h, y) {
        var O = c == null ? 0 : c.length;
        if (!O)
          return -1;
        var q = y == null ? 0 : cr(y);
        return q < 0 && (q = _n(O + q, 0)), bh(c, Ut(h, 3), q);
      }
      function kw(c, h, y) {
        var O = c == null ? 0 : c.length;
        if (!O)
          return -1;
        var q = O - 1;
        return y !== r && (q = cr(y), q = y < 0 ? _n(O + q, 0) : Kn(q, O - 1)), bh(c, Ut(h, 3), q, !0);
      }
      function $w(c) {
        var h = c == null ? 0 : c.length;
        return h ? Bn(c, 1) : [];
      }
      function DM(c) {
        var h = c == null ? 0 : c.length;
        return h ? Bn(c, x) : [];
      }
      function OM(c, h) {
        var y = c == null ? 0 : c.length;
        return y ? (h = h === r ? 1 : cr(h), Bn(c, h)) : [];
      }
      function NM(c) {
        for (var h = -1, y = c == null ? 0 : c.length, O = {}; ++h < y; ) {
          var q = c[h];
          O[q[0]] = q[1];
        }
        return O;
      }
      function Bw(c) {
        return c && c.length ? c[0] : r;
      }
      function LM(c, h, y) {
        var O = c == null ? 0 : c.length;
        if (!O)
          return -1;
        var q = y == null ? 0 : cr(y);
        return q < 0 && (q = _n(O + q, 0)), Cc(c, h, q);
      }
      function kM(c) {
        var h = c == null ? 0 : c.length;
        return h ? Hi(c, 0, -1) : [];
      }
      var $M = hr(function(c) {
        var h = Xr(c, ug);
        return h.length && h[0] === c[0] ? Qp(h) : [];
      }), BM = hr(function(c) {
        var h = Ki(c), y = Xr(c, ug);
        return h === Ki(y) ? h = r : y.pop(), y.length && y[0] === c[0] ? Qp(y, Ut(h, 2)) : [];
      }), FM = hr(function(c) {
        var h = Ki(c), y = Xr(c, ug);
        return h = typeof h == "function" ? h : r, h && y.pop(), y.length && y[0] === c[0] ? Qp(y, r, h) : [];
      });
      function jM(c, h) {
        return c == null ? "" : kA.call(c, h);
      }
      function Ki(c) {
        var h = c == null ? 0 : c.length;
        return h ? c[h - 1] : r;
      }
      function UM(c, h, y) {
        var O = c == null ? 0 : c.length;
        if (!O)
          return -1;
        var q = O;
        return y !== r && (q = cr(y), q = q < 0 ? _n(O + q, 0) : Kn(q, O - 1)), h === h ? wA(c, h, q) : bh(c, by, q, !0);
      }
      function qM(c, h) {
        return c && c.length ? Yy(c, cr(h)) : r;
      }
      var zM = hr(Fw);
      function Fw(c, h) {
        return c && c.length && h && h.length ? ng(c, h) : c;
      }
      function WM(c, h, y) {
        return c && c.length && h && h.length ? ng(c, h, Ut(y, 2)) : c;
      }
      function HM(c, h, y) {
        return c && c.length && h && h.length ? ng(c, h, r, y) : c;
      }
      var KM = lo(function(c, h) {
        var y = c == null ? 0 : c.length, O = Yp(c, h);
        return Zy(c, Xr(h, function(q) {
          return ho(q, y) ? +q : q;
        }).sort(cw)), O;
      });
      function VM(c, h) {
        var y = [];
        if (!(c && c.length))
          return y;
        var O = -1, q = [], ne = c.length;
        for (h = Ut(h, 3); ++O < ne; ) {
          var le = c[O];
          h(le, O, c) && (y.push(le), q.push(O));
        }
        return Zy(c, q), y;
      }
      function Eg(c) {
        return c == null ? c : jA.call(c);
      }
      function GM(c, h, y) {
        var O = c == null ? 0 : c.length;
        return O ? (y && typeof y != "number" && ri(c, h, y) ? (h = 0, y = O) : (h = h == null ? 0 : cr(h), y = y === r ? O : cr(y)), Hi(c, h, y)) : [];
      }
      function YM(c, h) {
        return Bh(c, h);
      }
      function JM(c, h, y) {
        return og(c, h, Ut(y, 2));
      }
      function XM(c, h) {
        var y = c == null ? 0 : c.length;
        if (y) {
          var O = Bh(c, h);
          if (O < y && ds(c[O], h))
            return O;
        }
        return -1;
      }
      function ZM(c, h) {
        return Bh(c, h, !0);
      }
      function QM(c, h, y) {
        return og(c, h, Ut(y, 2), !0);
      }
      function eI(c, h) {
        var y = c == null ? 0 : c.length;
        if (y) {
          var O = Bh(c, h, !0) - 1;
          if (ds(c[O], h))
            return O;
        }
        return -1;
      }
      function tI(c) {
        return c && c.length ? ew(c) : [];
      }
      function rI(c, h) {
        return c && c.length ? ew(c, Ut(h, 2)) : [];
      }
      function nI(c) {
        var h = c == null ? 0 : c.length;
        return h ? Hi(c, 1, h) : [];
      }
      function iI(c, h, y) {
        return c && c.length ? (h = y || h === r ? 1 : cr(h), Hi(c, 0, h < 0 ? 0 : h)) : [];
      }
      function sI(c, h, y) {
        var O = c == null ? 0 : c.length;
        return O ? (h = y || h === r ? 1 : cr(h), h = O - h, Hi(c, h < 0 ? 0 : h, O)) : [];
      }
      function oI(c, h) {
        return c && c.length ? Fh(c, Ut(h, 3), !1, !0) : [];
      }
      function aI(c, h) {
        return c && c.length ? Fh(c, Ut(h, 3)) : [];
      }
      var cI = hr(function(c) {
        return Xo(Bn(c, 1, cn, !0));
      }), uI = hr(function(c) {
        var h = Ki(c);
        return cn(h) && (h = r), Xo(Bn(c, 1, cn, !0), Ut(h, 2));
      }), fI = hr(function(c) {
        var h = Ki(c);
        return h = typeof h == "function" ? h : r, Xo(Bn(c, 1, cn, !0), r, h);
      });
      function lI(c) {
        return c && c.length ? Xo(c) : [];
      }
      function hI(c, h) {
        return c && c.length ? Xo(c, Ut(h, 2)) : [];
      }
      function dI(c, h) {
        return h = typeof h == "function" ? h : r, c && c.length ? Xo(c, r, h) : [];
      }
      function Sg(c) {
        if (!(c && c.length))
          return [];
        var h = 0;
        return c = Ko(c, function(y) {
          if (cn(y))
            return h = _n(y.length, h), !0;
        }), Up(h, function(y) {
          return Xr(c, Bp(y));
        });
      }
      function jw(c, h) {
        if (!(c && c.length))
          return [];
        var y = Sg(c);
        return h == null ? y : Xr(y, function(O) {
          return Pn(h, r, O);
        });
      }
      var pI = hr(function(c, h) {
        return cn(c) ? af(c, h) : [];
      }), gI = hr(function(c) {
        return cg(Ko(c, cn));
      }), mI = hr(function(c) {
        var h = Ki(c);
        return cn(h) && (h = r), cg(Ko(c, cn), Ut(h, 2));
      }), vI = hr(function(c) {
        var h = Ki(c);
        return h = typeof h == "function" ? h : r, cg(Ko(c, cn), r, h);
      }), bI = hr(Sg);
      function yI(c, h) {
        return iw(c || [], h || [], of);
      }
      function wI(c, h) {
        return iw(c || [], h || [], ff);
      }
      var xI = hr(function(c) {
        var h = c.length, y = h > 1 ? c[h - 1] : r;
        return y = typeof y == "function" ? (c.pop(), y) : r, jw(c, y);
      });
      function Uw(c) {
        var h = ee(c);
        return h.__chain__ = !0, h;
      }
      function _I(c, h) {
        return h(c), c;
      }
      function Gh(c, h) {
        return h(c);
      }
      var EI = lo(function(c) {
        var h = c.length, y = h ? c[0] : 0, O = this.__wrapped__, q = function(ne) {
          return Yp(ne, c);
        };
        return h > 1 || this.__actions__.length || !(O instanceof wr) || !ho(y) ? this.thru(q) : (O = O.slice(y, +y + (h ? 1 : 0)), O.__actions__.push({
          func: Gh,
          args: [q],
          thisArg: r
        }), new zi(O, this.__chain__).thru(function(ne) {
          return h && !ne.length && ne.push(r), ne;
        }));
      });
      function SI() {
        return Uw(this);
      }
      function AI() {
        return new zi(this.value(), this.__chain__);
      }
      function PI() {
        this.__values__ === r && (this.__values__ = t2(this.value()));
        var c = this.__index__ >= this.__values__.length, h = c ? r : this.__values__[this.__index__++];
        return { done: c, value: h };
      }
      function MI() {
        return this;
      }
      function II(c) {
        for (var h, y = this; y instanceof Oh; ) {
          var O = Nw(y);
          O.__index__ = 0, O.__values__ = r, h ? q.__wrapped__ = O : h = O;
          var q = O;
          y = y.__wrapped__;
        }
        return q.__wrapped__ = c, h;
      }
      function CI() {
        var c = this.__wrapped__;
        if (c instanceof wr) {
          var h = c;
          return this.__actions__.length && (h = new wr(this)), h = h.reverse(), h.__actions__.push({
            func: Gh,
            args: [Eg],
            thisArg: r
          }), new zi(h, this.__chain__);
        }
        return this.thru(Eg);
      }
      function TI() {
        return nw(this.__wrapped__, this.__actions__);
      }
      var RI = jh(function(c, h, y) {
        Tr.call(c, y) ? ++c[y] : uo(c, y, 1);
      });
      function DI(c, h, y) {
        var O = ir(c) ? my : _P;
        return y && ri(c, h, y) && (h = r), O(c, Ut(h, 3));
      }
      function OI(c, h) {
        var y = ir(c) ? Ko : jy;
        return y(c, Ut(h, 3));
      }
      var NI = pw(Lw), LI = pw(kw);
      function kI(c, h) {
        return Bn(Yh(c, h), 1);
      }
      function $I(c, h) {
        return Bn(Yh(c, h), x);
      }
      function BI(c, h, y) {
        return y = y === r ? 1 : cr(y), Bn(Yh(c, h), y);
      }
      function qw(c, h) {
        var y = ir(c) ? Ui : Jo;
        return y(c, Ut(h, 3));
      }
      function zw(c, h) {
        var y = ir(c) ? nA : Fy;
        return y(c, Ut(h, 3));
      }
      var FI = jh(function(c, h, y) {
        Tr.call(c, y) ? c[y].push(h) : uo(c, y, [h]);
      });
      function jI(c, h, y, O) {
        c = li(c) ? c : Uc(c), y = y && !O ? cr(y) : 0;
        var q = c.length;
        return y < 0 && (y = _n(q + y, 0)), ed(c) ? y <= q && c.indexOf(h, y) > -1 : !!q && Cc(c, h, y) > -1;
      }
      var UI = hr(function(c, h, y) {
        var O = -1, q = typeof h == "function", ne = li(c) ? Ie(c.length) : [];
        return Jo(c, function(le) {
          ne[++O] = q ? Pn(h, le, y) : cf(le, h, y);
        }), ne;
      }), qI = jh(function(c, h, y) {
        uo(c, y, h);
      });
      function Yh(c, h) {
        var y = ir(c) ? Xr : Ky;
        return y(c, Ut(h, 3));
      }
      function zI(c, h, y, O) {
        return c == null ? [] : (ir(h) || (h = h == null ? [] : [h]), y = O ? r : y, ir(y) || (y = y == null ? [] : [y]), Jy(c, h, y));
      }
      var WI = jh(function(c, h, y) {
        c[y ? 0 : 1].push(h);
      }, function() {
        return [[], []];
      });
      function HI(c, h, y) {
        var O = ir(c) ? kp : wy, q = arguments.length < 3;
        return O(c, Ut(h, 4), y, q, Jo);
      }
      function KI(c, h, y) {
        var O = ir(c) ? iA : wy, q = arguments.length < 3;
        return O(c, Ut(h, 4), y, q, Fy);
      }
      function VI(c, h) {
        var y = ir(c) ? Ko : jy;
        return y(c, Zh(Ut(h, 3)));
      }
      function GI(c) {
        var h = ir(c) ? Ly : jP;
        return h(c);
      }
      function YI(c, h, y) {
        (y ? ri(c, h, y) : h === r) ? h = 1 : h = cr(h);
        var O = ir(c) ? vP : UP;
        return O(c, h);
      }
      function JI(c) {
        var h = ir(c) ? bP : zP;
        return h(c);
      }
      function XI(c) {
        if (c == null)
          return 0;
        if (li(c))
          return ed(c) ? Rc(c) : c.length;
        var h = Vn(c);
        return h == ie || h == Me ? c.size : tg(c).length;
      }
      function ZI(c, h, y) {
        var O = ir(c) ? $p : WP;
        return y && ri(c, h, y) && (h = r), O(c, Ut(h, 3));
      }
      var QI = hr(function(c, h) {
        if (c == null)
          return [];
        var y = h.length;
        return y > 1 && ri(c, h[0], h[1]) ? h = [] : y > 2 && ri(h[0], h[1], h[2]) && (h = [h[0]]), Jy(c, Bn(h, 1), []);
      }), Jh = OA || function() {
        return _r.Date.now();
      };
      function eC(c, h) {
        if (typeof h != "function")
          throw new qi(o);
        return c = cr(c), function() {
          if (--c < 1)
            return h.apply(this, arguments);
        };
      }
      function Ww(c, h, y) {
        return h = y ? r : h, h = c && h == null ? c.length : h, fo(c, R, r, r, r, r, h);
      }
      function Hw(c, h) {
        var y;
        if (typeof h != "function")
          throw new qi(o);
        return c = cr(c), function() {
          return --c > 0 && (y = h.apply(this, arguments)), c <= 1 && (h = r), y;
        };
      }
      var Ag = hr(function(c, h, y) {
        var O = L;
        if (y.length) {
          var q = Go(y, Fc(Ag));
          O |= V;
        }
        return fo(c, O, h, y, q);
      }), Kw = hr(function(c, h, y) {
        var O = L | $;
        if (y.length) {
          var q = Go(y, Fc(Kw));
          O |= V;
        }
        return fo(h, O, c, y, q);
      });
      function Vw(c, h, y) {
        h = y ? r : h;
        var O = fo(c, H, r, r, r, r, r, h);
        return O.placeholder = Vw.placeholder, O;
      }
      function Gw(c, h, y) {
        h = y ? r : h;
        var O = fo(c, W, r, r, r, r, r, h);
        return O.placeholder = Gw.placeholder, O;
      }
      function Yw(c, h, y) {
        var O, q, ne, le, me, we, We = 0, He = !1, Xe = !1, wt = !0;
        if (typeof c != "function")
          throw new qi(o);
        h = Vi(h) || 0, Zr(y) && (He = !!y.leading, Xe = "maxWait" in y, ne = Xe ? _n(Vi(y.maxWait) || 0, h) : ne, wt = "trailing" in y ? !!y.trailing : wt);
        function Ot(un) {
          var ps = O, mo = q;
          return O = q = r, We = un, le = c.apply(mo, ps), le;
        }
        function Ht(un) {
          return We = un, me = df(vr, h), He ? Ot(un) : le;
        }
        function fr(un) {
          var ps = un - we, mo = un - We, p2 = h - ps;
          return Xe ? Kn(p2, ne - mo) : p2;
        }
        function Kt(un) {
          var ps = un - we, mo = un - We;
          return we === r || ps >= h || ps < 0 || Xe && mo >= ne;
        }
        function vr() {
          var un = Jh();
          if (Kt(un))
            return Er(un);
          me = df(vr, fr(un));
        }
        function Er(un) {
          return me = r, wt && O ? Ot(un) : (O = q = r, le);
        }
        function Ii() {
          me !== r && sw(me), We = 0, O = we = q = me = r;
        }
        function ni() {
          return me === r ? le : Er(Jh());
        }
        function Ci() {
          var un = Jh(), ps = Kt(un);
          if (O = arguments, q = this, we = un, ps) {
            if (me === r)
              return Ht(we);
            if (Xe)
              return sw(me), me = df(vr, h), Ot(we);
          }
          return me === r && (me = df(vr, h)), le;
        }
        return Ci.cancel = Ii, Ci.flush = ni, Ci;
      }
      var tC = hr(function(c, h) {
        return By(c, 1, h);
      }), rC = hr(function(c, h, y) {
        return By(c, Vi(h) || 0, y);
      });
      function nC(c) {
        return fo(c, ge);
      }
      function Xh(c, h) {
        if (typeof c != "function" || h != null && typeof h != "function")
          throw new qi(o);
        var y = function() {
          var O = arguments, q = h ? h.apply(this, O) : O[0], ne = y.cache;
          if (ne.has(q))
            return ne.get(q);
          var le = c.apply(this, O);
          return y.cache = ne.set(q, le) || ne, le;
        };
        return y.cache = new (Xh.Cache || co)(), y;
      }
      Xh.Cache = co;
      function Zh(c) {
        if (typeof c != "function")
          throw new qi(o);
        return function() {
          var h = arguments;
          switch (h.length) {
            case 0:
              return !c.call(this);
            case 1:
              return !c.call(this, h[0]);
            case 2:
              return !c.call(this, h[0], h[1]);
            case 3:
              return !c.call(this, h[0], h[1], h[2]);
          }
          return !c.apply(this, h);
        };
      }
      function iC(c) {
        return Hw(2, c);
      }
      var sC = HP(function(c, h) {
        h = h.length == 1 && ir(h[0]) ? Xr(h[0], Ai(Ut())) : Xr(Bn(h, 1), Ai(Ut()));
        var y = h.length;
        return hr(function(O) {
          for (var q = -1, ne = Kn(O.length, y); ++q < ne; )
            O[q] = h[q].call(this, O[q]);
          return Pn(c, this, O);
        });
      }), Pg = hr(function(c, h) {
        var y = Go(h, Fc(Pg));
        return fo(c, V, r, h, y);
      }), Jw = hr(function(c, h) {
        var y = Go(h, Fc(Jw));
        return fo(c, te, r, h, y);
      }), oC = lo(function(c, h) {
        return fo(c, K, r, r, r, h);
      });
      function aC(c, h) {
        if (typeof c != "function")
          throw new qi(o);
        return h = h === r ? h : cr(h), hr(c, h);
      }
      function cC(c, h) {
        if (typeof c != "function")
          throw new qi(o);
        return h = h == null ? 0 : _n(cr(h), 0), hr(function(y) {
          var O = y[h], q = Qo(y, 0, h);
          return O && Vo(q, O), Pn(c, this, q);
        });
      }
      function uC(c, h, y) {
        var O = !0, q = !0;
        if (typeof c != "function")
          throw new qi(o);
        return Zr(y) && (O = "leading" in y ? !!y.leading : O, q = "trailing" in y ? !!y.trailing : q), Yw(c, h, {
          leading: O,
          maxWait: h,
          trailing: q
        });
      }
      function fC(c) {
        return Ww(c, 1);
      }
      function lC(c, h) {
        return Pg(fg(h), c);
      }
      function hC() {
        if (!arguments.length)
          return [];
        var c = arguments[0];
        return ir(c) ? c : [c];
      }
      function dC(c) {
        return Wi(c, A);
      }
      function pC(c, h) {
        return h = typeof h == "function" ? h : r, Wi(c, A, h);
      }
      function gC(c) {
        return Wi(c, p | A);
      }
      function mC(c, h) {
        return h = typeof h == "function" ? h : r, Wi(c, p | A, h);
      }
      function vC(c, h) {
        return h == null || $y(c, h, Mn(h));
      }
      function ds(c, h) {
        return c === h || c !== c && h !== h;
      }
      var bC = Wh(Zp), yC = Wh(function(c, h) {
        return c >= h;
      }), za = zy(/* @__PURE__ */ function() {
        return arguments;
      }()) ? zy : function(c) {
        return en(c) && Tr.call(c, "callee") && !Cy.call(c, "callee");
      }, ir = Ie.isArray, wC = ei ? Ai(ei) : IP;
      function li(c) {
        return c != null && Qh(c.length) && !po(c);
      }
      function cn(c) {
        return en(c) && li(c);
      }
      function xC(c) {
        return c === !0 || c === !1 || en(c) && ti(c) == J;
      }
      var ea = LA || $g, _C = fs ? Ai(fs) : CP;
      function EC(c) {
        return en(c) && c.nodeType === 1 && !pf(c);
      }
      function SC(c) {
        if (c == null)
          return !0;
        if (li(c) && (ir(c) || typeof c == "string" || typeof c.splice == "function" || ea(c) || jc(c) || za(c)))
          return !c.length;
        var h = Vn(c);
        if (h == ie || h == Me)
          return !c.size;
        if (hf(c))
          return !tg(c).length;
        for (var y in c)
          if (Tr.call(c, y))
            return !1;
        return !0;
      }
      function AC(c, h) {
        return uf(c, h);
      }
      function PC(c, h, y) {
        y = typeof y == "function" ? y : r;
        var O = y ? y(c, h) : r;
        return O === r ? uf(c, h, r, y) : !!O;
      }
      function Mg(c) {
        if (!en(c))
          return !1;
        var h = ti(c);
        return h == X || h == T || typeof c.message == "string" && typeof c.name == "string" && !pf(c);
      }
      function MC(c) {
        return typeof c == "number" && Ry(c);
      }
      function po(c) {
        if (!Zr(c))
          return !1;
        var h = ti(c);
        return h == re || h == pe || h == Z || h == Ce;
      }
      function Xw(c) {
        return typeof c == "number" && c == cr(c);
      }
      function Qh(c) {
        return typeof c == "number" && c > -1 && c % 1 == 0 && c <= _;
      }
      function Zr(c) {
        var h = typeof c;
        return c != null && (h == "object" || h == "function");
      }
      function en(c) {
        return c != null && typeof c == "object";
      }
      var Zw = ji ? Ai(ji) : RP;
      function IC(c, h) {
        return c === h || eg(c, h, vg(h));
      }
      function CC(c, h, y) {
        return y = typeof y == "function" ? y : r, eg(c, h, vg(h), y);
      }
      function TC(c) {
        return Qw(c) && c != +c;
      }
      function RC(c) {
        if (pM(c))
          throw new tr(s);
        return Wy(c);
      }
      function DC(c) {
        return c === null;
      }
      function OC(c) {
        return c == null;
      }
      function Qw(c) {
        return typeof c == "number" || en(c) && ti(c) == ue;
      }
      function pf(c) {
        if (!en(c) || ti(c) != Pe)
          return !1;
        var h = Ph(c);
        if (h === null)
          return !0;
        var y = Tr.call(h, "constructor") && h.constructor;
        return typeof y == "function" && y instanceof y && _h.call(y) == CA;
      }
      var Ig = Is ? Ai(Is) : DP;
      function NC(c) {
        return Xw(c) && c >= -_ && c <= _;
      }
      var e2 = Zu ? Ai(Zu) : OP;
      function ed(c) {
        return typeof c == "string" || !ir(c) && en(c) && ti(c) == Ne;
      }
      function Mi(c) {
        return typeof c == "symbol" || en(c) && ti(c) == Ke;
      }
      var jc = La ? Ai(La) : NP;
      function LC(c) {
        return c === r;
      }
      function kC(c) {
        return en(c) && Vn(c) == qe;
      }
      function $C(c) {
        return en(c) && ti(c) == ze;
      }
      var BC = Wh(rg), FC = Wh(function(c, h) {
        return c <= h;
      });
      function t2(c) {
        if (!c)
          return [];
        if (li(c))
          return ed(c) ? ls(c) : fi(c);
        if (ef && c[ef])
          return vA(c[ef]());
        var h = Vn(c), y = h == ie ? zp : h == Me ? yh : Uc;
        return y(c);
      }
      function go(c) {
        if (!c)
          return c === 0 ? c : 0;
        if (c = Vi(c), c === x || c === -x) {
          var h = c < 0 ? -1 : 1;
          return h * E;
        }
        return c === c ? c : 0;
      }
      function cr(c) {
        var h = go(c), y = h % 1;
        return h === h ? y ? h - y : h : 0;
      }
      function r2(c) {
        return c ? Fa(cr(c), 0, M) : 0;
      }
      function Vi(c) {
        if (typeof c == "number")
          return c;
        if (Mi(c))
          return v;
        if (Zr(c)) {
          var h = typeof c.valueOf == "function" ? c.valueOf() : c;
          c = Zr(h) ? h + "" : h;
        }
        if (typeof c != "string")
          return c === 0 ? c : +c;
        c = xy(c);
        var y = nt.test(c);
        return y || pt.test(c) ? nr(c.slice(2), y ? 2 : 8) : Re.test(c) ? v : +c;
      }
      function n2(c) {
        return Ts(c, hi(c));
      }
      function jC(c) {
        return c ? Fa(cr(c), -_, _) : c === 0 ? c : 0;
      }
      function Cr(c) {
        return c == null ? "" : Pi(c);
      }
      var UC = $c(function(c, h) {
        if (hf(h) || li(h)) {
          Ts(h, Mn(h), c);
          return;
        }
        for (var y in h)
          Tr.call(h, y) && of(c, y, h[y]);
      }), i2 = $c(function(c, h) {
        Ts(h, hi(h), c);
      }), td = $c(function(c, h, y, O) {
        Ts(h, hi(h), c, O);
      }), qC = $c(function(c, h, y, O) {
        Ts(h, Mn(h), c, O);
      }), zC = lo(Yp);
      function WC(c, h) {
        var y = kc(c);
        return h == null ? y : ky(y, h);
      }
      var HC = hr(function(c, h) {
        c = qr(c);
        var y = -1, O = h.length, q = O > 2 ? h[2] : r;
        for (q && ri(h[0], h[1], q) && (O = 1); ++y < O; )
          for (var ne = h[y], le = hi(ne), me = -1, we = le.length; ++me < we; ) {
            var We = le[me], He = c[We];
            (He === r || ds(He, Oc[We]) && !Tr.call(c, We)) && (c[We] = ne[We]);
          }
        return c;
      }), KC = hr(function(c) {
        return c.push(r, xw), Pn(s2, r, c);
      });
      function VC(c, h) {
        return vy(c, Ut(h, 3), Cs);
      }
      function GC(c, h) {
        return vy(c, Ut(h, 3), Xp);
      }
      function YC(c, h) {
        return c == null ? c : Jp(c, Ut(h, 3), hi);
      }
      function JC(c, h) {
        return c == null ? c : Uy(c, Ut(h, 3), hi);
      }
      function XC(c, h) {
        return c && Cs(c, Ut(h, 3));
      }
      function ZC(c, h) {
        return c && Xp(c, Ut(h, 3));
      }
      function QC(c) {
        return c == null ? [] : kh(c, Mn(c));
      }
      function eT(c) {
        return c == null ? [] : kh(c, hi(c));
      }
      function Cg(c, h, y) {
        var O = c == null ? r : ja(c, h);
        return O === r ? y : O;
      }
      function tT(c, h) {
        return c != null && Sw(c, h, SP);
      }
      function Tg(c, h) {
        return c != null && Sw(c, h, AP);
      }
      var rT = mw(function(c, h, y) {
        h != null && typeof h.toString != "function" && (h = Eh.call(h)), c[h] = y;
      }, Dg(di)), nT = mw(function(c, h, y) {
        h != null && typeof h.toString != "function" && (h = Eh.call(h)), Tr.call(c, h) ? c[h].push(y) : c[h] = [y];
      }, Ut), iT = hr(cf);
      function Mn(c) {
        return li(c) ? Ny(c) : tg(c);
      }
      function hi(c) {
        return li(c) ? Ny(c, !0) : LP(c);
      }
      function sT(c, h) {
        var y = {};
        return h = Ut(h, 3), Cs(c, function(O, q, ne) {
          uo(y, h(O, q, ne), O);
        }), y;
      }
      function oT(c, h) {
        var y = {};
        return h = Ut(h, 3), Cs(c, function(O, q, ne) {
          uo(y, q, h(O, q, ne));
        }), y;
      }
      var aT = $c(function(c, h, y) {
        $h(c, h, y);
      }), s2 = $c(function(c, h, y, O) {
        $h(c, h, y, O);
      }), cT = lo(function(c, h) {
        var y = {};
        if (c == null)
          return y;
        var O = !1;
        h = Xr(h, function(ne) {
          return ne = Zo(ne, c), O || (O = ne.length > 1), ne;
        }), Ts(c, gg(c), y), O && (y = Wi(y, p | w | A, rM));
        for (var q = h.length; q--; )
          ag(y, h[q]);
        return y;
      });
      function uT(c, h) {
        return o2(c, Zh(Ut(h)));
      }
      var fT = lo(function(c, h) {
        return c == null ? {} : $P(c, h);
      });
      function o2(c, h) {
        if (c == null)
          return {};
        var y = Xr(gg(c), function(O) {
          return [O];
        });
        return h = Ut(h), Xy(c, y, function(O, q) {
          return h(O, q[0]);
        });
      }
      function lT(c, h, y) {
        h = Zo(h, c);
        var O = -1, q = h.length;
        for (q || (q = 1, c = r); ++O < q; ) {
          var ne = c == null ? r : c[Rs(h[O])];
          ne === r && (O = q, ne = y), c = po(ne) ? ne.call(c) : ne;
        }
        return c;
      }
      function hT(c, h, y) {
        return c == null ? c : ff(c, h, y);
      }
      function dT(c, h, y, O) {
        return O = typeof O == "function" ? O : r, c == null ? c : ff(c, h, y, O);
      }
      var a2 = yw(Mn), c2 = yw(hi);
      function pT(c, h, y) {
        var O = ir(c), q = O || ea(c) || jc(c);
        if (h = Ut(h, 4), y == null) {
          var ne = c && c.constructor;
          q ? y = O ? new ne() : [] : Zr(c) ? y = po(ne) ? kc(Ph(c)) : {} : y = {};
        }
        return (q ? Ui : Cs)(c, function(le, me, we) {
          return h(y, le, me, we);
        }), y;
      }
      function gT(c, h) {
        return c == null ? !0 : ag(c, h);
      }
      function mT(c, h, y) {
        return c == null ? c : rw(c, h, fg(y));
      }
      function vT(c, h, y, O) {
        return O = typeof O == "function" ? O : r, c == null ? c : rw(c, h, fg(y), O);
      }
      function Uc(c) {
        return c == null ? [] : qp(c, Mn(c));
      }
      function bT(c) {
        return c == null ? [] : qp(c, hi(c));
      }
      function yT(c, h, y) {
        return y === r && (y = h, h = r), y !== r && (y = Vi(y), y = y === y ? y : 0), h !== r && (h = Vi(h), h = h === h ? h : 0), Fa(Vi(c), h, y);
      }
      function wT(c, h, y) {
        return h = go(h), y === r ? (y = h, h = 0) : y = go(y), c = Vi(c), PP(c, h, y);
      }
      function xT(c, h, y) {
        if (y && typeof y != "boolean" && ri(c, h, y) && (h = y = r), y === r && (typeof h == "boolean" ? (y = h, h = r) : typeof c == "boolean" && (y = c, c = r)), c === r && h === r ? (c = 0, h = 1) : (c = go(c), h === r ? (h = c, c = 0) : h = go(h)), c > h) {
          var O = c;
          c = h, h = O;
        }
        if (y || c % 1 || h % 1) {
          var q = Dy();
          return Kn(c + q * (h - c + jr("1e-" + ((q + "").length - 1))), h);
        }
        return ig(c, h);
      }
      var _T = Bc(function(c, h, y) {
        return h = h.toLowerCase(), c + (y ? u2(h) : h);
      });
      function u2(c) {
        return Rg(Cr(c).toLowerCase());
      }
      function f2(c) {
        return c = Cr(c), c && c.replace(et, hA).replace(Op, "");
      }
      function ET(c, h, y) {
        c = Cr(c), h = Pi(h);
        var O = c.length;
        y = y === r ? O : Fa(cr(y), 0, O);
        var q = y;
        return y -= h.length, y >= 0 && c.slice(y, q) == h;
      }
      function ST(c) {
        return c = Cr(c), c && Ct.test(c) ? c.replace(Dt, dA) : c;
      }
      function AT(c) {
        return c = Cr(c), c && Bt.test(c) ? c.replace(rt, "\\$&") : c;
      }
      var PT = Bc(function(c, h, y) {
        return c + (y ? "-" : "") + h.toLowerCase();
      }), MT = Bc(function(c, h, y) {
        return c + (y ? " " : "") + h.toLowerCase();
      }), IT = dw("toLowerCase");
      function CT(c, h, y) {
        c = Cr(c), h = cr(h);
        var O = h ? Rc(c) : 0;
        if (!h || O >= h)
          return c;
        var q = (h - O) / 2;
        return zh(Th(q), y) + c + zh(Ch(q), y);
      }
      function TT(c, h, y) {
        c = Cr(c), h = cr(h);
        var O = h ? Rc(c) : 0;
        return h && O < h ? c + zh(h - O, y) : c;
      }
      function RT(c, h, y) {
        c = Cr(c), h = cr(h);
        var O = h ? Rc(c) : 0;
        return h && O < h ? zh(h - O, y) + c : c;
      }
      function DT(c, h, y) {
        return y || h == null ? h = 0 : h && (h = +h), FA(Cr(c).replace(k, ""), h || 0);
      }
      function OT(c, h, y) {
        return (y ? ri(c, h, y) : h === r) ? h = 1 : h = cr(h), sg(Cr(c), h);
      }
      function NT() {
        var c = arguments, h = Cr(c[0]);
        return c.length < 3 ? h : h.replace(c[1], c[2]);
      }
      var LT = Bc(function(c, h, y) {
        return c + (y ? "_" : "") + h.toLowerCase();
      });
      function kT(c, h, y) {
        return y && typeof y != "number" && ri(c, h, y) && (h = y = r), y = y === r ? M : y >>> 0, y ? (c = Cr(c), c && (typeof h == "string" || h != null && !Ig(h)) && (h = Pi(h), !h && Tc(c)) ? Qo(ls(c), 0, y) : c.split(h, y)) : [];
      }
      var $T = Bc(function(c, h, y) {
        return c + (y ? " " : "") + Rg(h);
      });
      function BT(c, h, y) {
        return c = Cr(c), y = y == null ? 0 : Fa(cr(y), 0, c.length), h = Pi(h), c.slice(y, y + h.length) == h;
      }
      function FT(c, h, y) {
        var O = ee.templateSettings;
        y && ri(c, h, y) && (h = r), c = Cr(c), h = td({}, h, O, ww);
        var q = td({}, h.imports, O.imports, ww), ne = Mn(q), le = qp(q, ne), me, we, We = 0, He = h.interpolate || St, Xe = "__p += '", wt = Wp(
          (h.escape || St).source + "|" + He.source + "|" + (He === Nt ? xe : St).source + "|" + (h.evaluate || St).source + "|$",
          "g"
        ), Ot = "//# sourceURL=" + (Tr.call(h, "sourceURL") ? (h.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Np + "]") + `
`;
        c.replace(wt, function(Kt, vr, Er, Ii, ni, Ci) {
          return Er || (Er = Ii), Xe += c.slice(We, Ci).replace(Tt, pA), vr && (me = !0, Xe += `' +
__e(` + vr + `) +
'`), ni && (we = !0, Xe += `';
` + ni + `;
__p += '`), Er && (Xe += `' +
((__t = (` + Er + `)) == null ? '' : __t) +
'`), We = Ci + Kt.length, Kt;
        }), Xe += `';
`;
        var Ht = Tr.call(h, "variable") && h.variable;
        if (!Ht)
          Xe = `with (obj) {
` + Xe + `
}
`;
        else if (se.test(Ht))
          throw new tr(a);
        Xe = (we ? Xe.replace(Jt, "") : Xe).replace(Et, "$1").replace(er, "$1;"), Xe = "function(" + (Ht || "obj") + `) {
` + (Ht ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (me ? ", __e = _.escape" : "") + (we ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Xe + `return __p
}`;
        var fr = h2(function() {
          return Pr(ne, Ot + "return " + Xe).apply(r, le);
        });
        if (fr.source = Xe, Mg(fr))
          throw fr;
        return fr;
      }
      function jT(c) {
        return Cr(c).toLowerCase();
      }
      function UT(c) {
        return Cr(c).toUpperCase();
      }
      function qT(c, h, y) {
        if (c = Cr(c), c && (y || h === r))
          return xy(c);
        if (!c || !(h = Pi(h)))
          return c;
        var O = ls(c), q = ls(h), ne = _y(O, q), le = Ey(O, q) + 1;
        return Qo(O, ne, le).join("");
      }
      function zT(c, h, y) {
        if (c = Cr(c), c && (y || h === r))
          return c.slice(0, Ay(c) + 1);
        if (!c || !(h = Pi(h)))
          return c;
        var O = ls(c), q = Ey(O, ls(h)) + 1;
        return Qo(O, 0, q).join("");
      }
      function WT(c, h, y) {
        if (c = Cr(c), c && (y || h === r))
          return c.replace(k, "");
        if (!c || !(h = Pi(h)))
          return c;
        var O = ls(c), q = _y(O, ls(h));
        return Qo(O, q).join("");
      }
      function HT(c, h) {
        var y = Ee, O = Y;
        if (Zr(h)) {
          var q = "separator" in h ? h.separator : q;
          y = "length" in h ? cr(h.length) : y, O = "omission" in h ? Pi(h.omission) : O;
        }
        c = Cr(c);
        var ne = c.length;
        if (Tc(c)) {
          var le = ls(c);
          ne = le.length;
        }
        if (y >= ne)
          return c;
        var me = y - Rc(O);
        if (me < 1)
          return O;
        var we = le ? Qo(le, 0, me).join("") : c.slice(0, me);
        if (q === r)
          return we + O;
        if (le && (me += we.length - me), Ig(q)) {
          if (c.slice(me).search(q)) {
            var We, He = we;
            for (q.global || (q = Wp(q.source, Cr(Te.exec(q)) + "g")), q.lastIndex = 0; We = q.exec(He); )
              var Xe = We.index;
            we = we.slice(0, Xe === r ? me : Xe);
          }
        } else if (c.indexOf(Pi(q), me) != me) {
          var wt = we.lastIndexOf(q);
          wt > -1 && (we = we.slice(0, wt));
        }
        return we + O;
      }
      function KT(c) {
        return c = Cr(c), c && kt.test(c) ? c.replace(Xt, xA) : c;
      }
      var VT = Bc(function(c, h, y) {
        return c + (y ? " " : "") + h.toUpperCase();
      }), Rg = dw("toUpperCase");
      function l2(c, h, y) {
        return c = Cr(c), h = y ? r : h, h === r ? mA(c) ? SA(c) : aA(c) : c.match(h) || [];
      }
      var h2 = hr(function(c, h) {
        try {
          return Pn(c, r, h);
        } catch (y) {
          return Mg(y) ? y : new tr(y);
        }
      }), GT = lo(function(c, h) {
        return Ui(h, function(y) {
          y = Rs(y), uo(c, y, Ag(c[y], c));
        }), c;
      });
      function YT(c) {
        var h = c == null ? 0 : c.length, y = Ut();
        return c = h ? Xr(c, function(O) {
          if (typeof O[1] != "function")
            throw new qi(o);
          return [y(O[0]), O[1]];
        }) : [], hr(function(O) {
          for (var q = -1; ++q < h; ) {
            var ne = c[q];
            if (Pn(ne[0], this, O))
              return Pn(ne[1], this, O);
          }
        });
      }
      function JT(c) {
        return xP(Wi(c, p));
      }
      function Dg(c) {
        return function() {
          return c;
        };
      }
      function XT(c, h) {
        return c == null || c !== c ? h : c;
      }
      var ZT = gw(), QT = gw(!0);
      function di(c) {
        return c;
      }
      function Og(c) {
        return Hy(typeof c == "function" ? c : Wi(c, p));
      }
      function eR(c) {
        return Vy(Wi(c, p));
      }
      function tR(c, h) {
        return Gy(c, Wi(h, p));
      }
      var rR = hr(function(c, h) {
        return function(y) {
          return cf(y, c, h);
        };
      }), nR = hr(function(c, h) {
        return function(y) {
          return cf(c, y, h);
        };
      });
      function Ng(c, h, y) {
        var O = Mn(h), q = kh(h, O);
        y == null && !(Zr(h) && (q.length || !O.length)) && (y = h, h = c, c = this, q = kh(h, Mn(h)));
        var ne = !(Zr(y) && "chain" in y) || !!y.chain, le = po(c);
        return Ui(q, function(me) {
          var we = h[me];
          c[me] = we, le && (c.prototype[me] = function() {
            var We = this.__chain__;
            if (ne || We) {
              var He = c(this.__wrapped__), Xe = He.__actions__ = fi(this.__actions__);
              return Xe.push({ func: we, args: arguments, thisArg: c }), He.__chain__ = We, He;
            }
            return we.apply(c, Vo([this.value()], arguments));
          });
        }), c;
      }
      function iR() {
        return _r._ === this && (_r._ = TA), this;
      }
      function Lg() {
      }
      function sR(c) {
        return c = cr(c), hr(function(h) {
          return Yy(h, c);
        });
      }
      var oR = hg(Xr), aR = hg(my), cR = hg($p);
      function d2(c) {
        return yg(c) ? Bp(Rs(c)) : BP(c);
      }
      function uR(c) {
        return function(h) {
          return c == null ? r : ja(c, h);
        };
      }
      var fR = vw(), lR = vw(!0);
      function kg() {
        return [];
      }
      function $g() {
        return !1;
      }
      function hR() {
        return {};
      }
      function dR() {
        return "";
      }
      function pR() {
        return !0;
      }
      function gR(c, h) {
        if (c = cr(c), c < 1 || c > _)
          return [];
        var y = M, O = Kn(c, M);
        h = Ut(h), c -= M;
        for (var q = Up(O, h); ++y < c; )
          h(y);
        return q;
      }
      function mR(c) {
        return ir(c) ? Xr(c, Rs) : Mi(c) ? [c] : fi(Ow(Cr(c)));
      }
      function vR(c) {
        var h = ++IA;
        return Cr(c) + h;
      }
      var bR = qh(function(c, h) {
        return c + h;
      }, 0), yR = dg("ceil"), wR = qh(function(c, h) {
        return c / h;
      }, 1), xR = dg("floor");
      function _R(c) {
        return c && c.length ? Lh(c, di, Zp) : r;
      }
      function ER(c, h) {
        return c && c.length ? Lh(c, Ut(h, 2), Zp) : r;
      }
      function SR(c) {
        return yy(c, di);
      }
      function AR(c, h) {
        return yy(c, Ut(h, 2));
      }
      function PR(c) {
        return c && c.length ? Lh(c, di, rg) : r;
      }
      function MR(c, h) {
        return c && c.length ? Lh(c, Ut(h, 2), rg) : r;
      }
      var IR = qh(function(c, h) {
        return c * h;
      }, 1), CR = dg("round"), TR = qh(function(c, h) {
        return c - h;
      }, 0);
      function RR(c) {
        return c && c.length ? jp(c, di) : 0;
      }
      function DR(c, h) {
        return c && c.length ? jp(c, Ut(h, 2)) : 0;
      }
      return ee.after = eC, ee.ary = Ww, ee.assign = UC, ee.assignIn = i2, ee.assignInWith = td, ee.assignWith = qC, ee.at = zC, ee.before = Hw, ee.bind = Ag, ee.bindAll = GT, ee.bindKey = Kw, ee.castArray = hC, ee.chain = Uw, ee.chunk = xM, ee.compact = _M, ee.concat = EM, ee.cond = YT, ee.conforms = JT, ee.constant = Dg, ee.countBy = RI, ee.create = WC, ee.curry = Vw, ee.curryRight = Gw, ee.debounce = Yw, ee.defaults = HC, ee.defaultsDeep = KC, ee.defer = tC, ee.delay = rC, ee.difference = SM, ee.differenceBy = AM, ee.differenceWith = PM, ee.drop = MM, ee.dropRight = IM, ee.dropRightWhile = CM, ee.dropWhile = TM, ee.fill = RM, ee.filter = OI, ee.flatMap = kI, ee.flatMapDeep = $I, ee.flatMapDepth = BI, ee.flatten = $w, ee.flattenDeep = DM, ee.flattenDepth = OM, ee.flip = nC, ee.flow = ZT, ee.flowRight = QT, ee.fromPairs = NM, ee.functions = QC, ee.functionsIn = eT, ee.groupBy = FI, ee.initial = kM, ee.intersection = $M, ee.intersectionBy = BM, ee.intersectionWith = FM, ee.invert = rT, ee.invertBy = nT, ee.invokeMap = UI, ee.iteratee = Og, ee.keyBy = qI, ee.keys = Mn, ee.keysIn = hi, ee.map = Yh, ee.mapKeys = sT, ee.mapValues = oT, ee.matches = eR, ee.matchesProperty = tR, ee.memoize = Xh, ee.merge = aT, ee.mergeWith = s2, ee.method = rR, ee.methodOf = nR, ee.mixin = Ng, ee.negate = Zh, ee.nthArg = sR, ee.omit = cT, ee.omitBy = uT, ee.once = iC, ee.orderBy = zI, ee.over = oR, ee.overArgs = sC, ee.overEvery = aR, ee.overSome = cR, ee.partial = Pg, ee.partialRight = Jw, ee.partition = WI, ee.pick = fT, ee.pickBy = o2, ee.property = d2, ee.propertyOf = uR, ee.pull = zM, ee.pullAll = Fw, ee.pullAllBy = WM, ee.pullAllWith = HM, ee.pullAt = KM, ee.range = fR, ee.rangeRight = lR, ee.rearg = oC, ee.reject = VI, ee.remove = VM, ee.rest = aC, ee.reverse = Eg, ee.sampleSize = YI, ee.set = hT, ee.setWith = dT, ee.shuffle = JI, ee.slice = GM, ee.sortBy = QI, ee.sortedUniq = tI, ee.sortedUniqBy = rI, ee.split = kT, ee.spread = cC, ee.tail = nI, ee.take = iI, ee.takeRight = sI, ee.takeRightWhile = oI, ee.takeWhile = aI, ee.tap = _I, ee.throttle = uC, ee.thru = Gh, ee.toArray = t2, ee.toPairs = a2, ee.toPairsIn = c2, ee.toPath = mR, ee.toPlainObject = n2, ee.transform = pT, ee.unary = fC, ee.union = cI, ee.unionBy = uI, ee.unionWith = fI, ee.uniq = lI, ee.uniqBy = hI, ee.uniqWith = dI, ee.unset = gT, ee.unzip = Sg, ee.unzipWith = jw, ee.update = mT, ee.updateWith = vT, ee.values = Uc, ee.valuesIn = bT, ee.without = pI, ee.words = l2, ee.wrap = lC, ee.xor = gI, ee.xorBy = mI, ee.xorWith = vI, ee.zip = bI, ee.zipObject = yI, ee.zipObjectDeep = wI, ee.zipWith = xI, ee.entries = a2, ee.entriesIn = c2, ee.extend = i2, ee.extendWith = td, Ng(ee, ee), ee.add = bR, ee.attempt = h2, ee.camelCase = _T, ee.capitalize = u2, ee.ceil = yR, ee.clamp = yT, ee.clone = dC, ee.cloneDeep = gC, ee.cloneDeepWith = mC, ee.cloneWith = pC, ee.conformsTo = vC, ee.deburr = f2, ee.defaultTo = XT, ee.divide = wR, ee.endsWith = ET, ee.eq = ds, ee.escape = ST, ee.escapeRegExp = AT, ee.every = DI, ee.find = NI, ee.findIndex = Lw, ee.findKey = VC, ee.findLast = LI, ee.findLastIndex = kw, ee.findLastKey = GC, ee.floor = xR, ee.forEach = qw, ee.forEachRight = zw, ee.forIn = YC, ee.forInRight = JC, ee.forOwn = XC, ee.forOwnRight = ZC, ee.get = Cg, ee.gt = bC, ee.gte = yC, ee.has = tT, ee.hasIn = Tg, ee.head = Bw, ee.identity = di, ee.includes = jI, ee.indexOf = LM, ee.inRange = wT, ee.invoke = iT, ee.isArguments = za, ee.isArray = ir, ee.isArrayBuffer = wC, ee.isArrayLike = li, ee.isArrayLikeObject = cn, ee.isBoolean = xC, ee.isBuffer = ea, ee.isDate = _C, ee.isElement = EC, ee.isEmpty = SC, ee.isEqual = AC, ee.isEqualWith = PC, ee.isError = Mg, ee.isFinite = MC, ee.isFunction = po, ee.isInteger = Xw, ee.isLength = Qh, ee.isMap = Zw, ee.isMatch = IC, ee.isMatchWith = CC, ee.isNaN = TC, ee.isNative = RC, ee.isNil = OC, ee.isNull = DC, ee.isNumber = Qw, ee.isObject = Zr, ee.isObjectLike = en, ee.isPlainObject = pf, ee.isRegExp = Ig, ee.isSafeInteger = NC, ee.isSet = e2, ee.isString = ed, ee.isSymbol = Mi, ee.isTypedArray = jc, ee.isUndefined = LC, ee.isWeakMap = kC, ee.isWeakSet = $C, ee.join = jM, ee.kebabCase = PT, ee.last = Ki, ee.lastIndexOf = UM, ee.lowerCase = MT, ee.lowerFirst = IT, ee.lt = BC, ee.lte = FC, ee.max = _R, ee.maxBy = ER, ee.mean = SR, ee.meanBy = AR, ee.min = PR, ee.minBy = MR, ee.stubArray = kg, ee.stubFalse = $g, ee.stubObject = hR, ee.stubString = dR, ee.stubTrue = pR, ee.multiply = IR, ee.nth = qM, ee.noConflict = iR, ee.noop = Lg, ee.now = Jh, ee.pad = CT, ee.padEnd = TT, ee.padStart = RT, ee.parseInt = DT, ee.random = xT, ee.reduce = HI, ee.reduceRight = KI, ee.repeat = OT, ee.replace = NT, ee.result = lT, ee.round = CR, ee.runInContext = be, ee.sample = GI, ee.size = XI, ee.snakeCase = LT, ee.some = ZI, ee.sortedIndex = YM, ee.sortedIndexBy = JM, ee.sortedIndexOf = XM, ee.sortedLastIndex = ZM, ee.sortedLastIndexBy = QM, ee.sortedLastIndexOf = eI, ee.startCase = $T, ee.startsWith = BT, ee.subtract = TR, ee.sum = RR, ee.sumBy = DR, ee.template = FT, ee.times = gR, ee.toFinite = go, ee.toInteger = cr, ee.toLength = r2, ee.toLower = jT, ee.toNumber = Vi, ee.toSafeInteger = jC, ee.toString = Cr, ee.toUpper = UT, ee.trim = qT, ee.trimEnd = zT, ee.trimStart = WT, ee.truncate = HT, ee.unescape = KT, ee.uniqueId = vR, ee.upperCase = VT, ee.upperFirst = Rg, ee.each = qw, ee.eachRight = zw, ee.first = Bw, Ng(ee, function() {
        var c = {};
        return Cs(ee, function(h, y) {
          Tr.call(ee.prototype, y) || (c[y] = h);
        }), c;
      }(), { chain: !1 }), ee.VERSION = n, Ui(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(c) {
        ee[c].placeholder = ee;
      }), Ui(["drop", "take"], function(c, h) {
        wr.prototype[c] = function(y) {
          y = y === r ? 1 : _n(cr(y), 0);
          var O = this.__filtered__ && !h ? new wr(this) : this.clone();
          return O.__filtered__ ? O.__takeCount__ = Kn(y, O.__takeCount__) : O.__views__.push({
            size: Kn(y, M),
            type: c + (O.__dir__ < 0 ? "Right" : "")
          }), O;
        }, wr.prototype[c + "Right"] = function(y) {
          return this.reverse()[c](y).reverse();
        };
      }), Ui(["filter", "map", "takeWhile"], function(c, h) {
        var y = h + 1, O = y == f || y == b;
        wr.prototype[c] = function(q) {
          var ne = this.clone();
          return ne.__iteratees__.push({
            iteratee: Ut(q, 3),
            type: y
          }), ne.__filtered__ = ne.__filtered__ || O, ne;
        };
      }), Ui(["head", "last"], function(c, h) {
        var y = "take" + (h ? "Right" : "");
        wr.prototype[c] = function() {
          return this[y](1).value()[0];
        };
      }), Ui(["initial", "tail"], function(c, h) {
        var y = "drop" + (h ? "" : "Right");
        wr.prototype[c] = function() {
          return this.__filtered__ ? new wr(this) : this[y](1);
        };
      }), wr.prototype.compact = function() {
        return this.filter(di);
      }, wr.prototype.find = function(c) {
        return this.filter(c).head();
      }, wr.prototype.findLast = function(c) {
        return this.reverse().find(c);
      }, wr.prototype.invokeMap = hr(function(c, h) {
        return typeof c == "function" ? new wr(this) : this.map(function(y) {
          return cf(y, c, h);
        });
      }), wr.prototype.reject = function(c) {
        return this.filter(Zh(Ut(c)));
      }, wr.prototype.slice = function(c, h) {
        c = cr(c);
        var y = this;
        return y.__filtered__ && (c > 0 || h < 0) ? new wr(y) : (c < 0 ? y = y.takeRight(-c) : c && (y = y.drop(c)), h !== r && (h = cr(h), y = h < 0 ? y.dropRight(-h) : y.take(h - c)), y);
      }, wr.prototype.takeRightWhile = function(c) {
        return this.reverse().takeWhile(c).reverse();
      }, wr.prototype.toArray = function() {
        return this.take(M);
      }, Cs(wr.prototype, function(c, h) {
        var y = /^(?:filter|find|map|reject)|While$/.test(h), O = /^(?:head|last)$/.test(h), q = ee[O ? "take" + (h == "last" ? "Right" : "") : h], ne = O || /^find/.test(h);
        q && (ee.prototype[h] = function() {
          var le = this.__wrapped__, me = O ? [1] : arguments, we = le instanceof wr, We = me[0], He = we || ir(le), Xe = function(vr) {
            var Er = q.apply(ee, Vo([vr], me));
            return O && wt ? Er[0] : Er;
          };
          He && y && typeof We == "function" && We.length != 1 && (we = He = !1);
          var wt = this.__chain__, Ot = !!this.__actions__.length, Ht = ne && !wt, fr = we && !Ot;
          if (!ne && He) {
            le = fr ? le : new wr(this);
            var Kt = c.apply(le, me);
            return Kt.__actions__.push({ func: Gh, args: [Xe], thisArg: r }), new zi(Kt, wt);
          }
          return Ht && fr ? c.apply(this, me) : (Kt = this.thru(Xe), Ht ? O ? Kt.value()[0] : Kt.value() : Kt);
        });
      }), Ui(["pop", "push", "shift", "sort", "splice", "unshift"], function(c) {
        var h = wh[c], y = /^(?:push|sort|unshift)$/.test(c) ? "tap" : "thru", O = /^(?:pop|shift)$/.test(c);
        ee.prototype[c] = function() {
          var q = arguments;
          if (O && !this.__chain__) {
            var ne = this.value();
            return h.apply(ir(ne) ? ne : [], q);
          }
          return this[y](function(le) {
            return h.apply(ir(le) ? le : [], q);
          });
        };
      }), Cs(wr.prototype, function(c, h) {
        var y = ee[h];
        if (y) {
          var O = y.name + "";
          Tr.call(Lc, O) || (Lc[O] = []), Lc[O].push({ name: h, func: y });
        }
      }), Lc[Uh(r, $).name] = [{
        name: "wrapper",
        func: r
      }], wr.prototype.clone = KA, wr.prototype.reverse = VA, wr.prototype.value = GA, ee.prototype.at = EI, ee.prototype.chain = SI, ee.prototype.commit = AI, ee.prototype.next = PI, ee.prototype.plant = II, ee.prototype.reverse = CI, ee.prototype.toJSON = ee.prototype.valueOf = ee.prototype.value = TI, ee.prototype.first = ee.prototype.head, ef && (ee.prototype[ef] = MI), ee;
    }, Dc = AA();
    an ? ((an.exports = Dc)._ = Dc, Ur._ = Dc) : _r._ = Dc;
  }).call(gn);
})(h0, h0.exports);
var XV = h0.exports, O1 = { exports: {} };
(function(t, e) {
  var r = typeof self < "u" ? self : gn, n = function() {
    function s() {
      this.fetch = !1, this.DOMException = r.DOMException;
    }
    return s.prototype = r, new s();
  }();
  (function(s) {
    (function(o) {
      var a = {
        searchParams: "URLSearchParams" in s,
        iterable: "Symbol" in s && "iterator" in Symbol,
        blob: "FileReader" in s && "Blob" in s && function() {
          try {
            return new Blob(), !0;
          } catch {
            return !1;
          }
        }(),
        formData: "FormData" in s,
        arrayBuffer: "ArrayBuffer" in s
      };
      function u(f) {
        return f && DataView.prototype.isPrototypeOf(f);
      }
      if (a.arrayBuffer)
        var l = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ], d = ArrayBuffer.isView || function(f) {
          return f && l.indexOf(Object.prototype.toString.call(f)) > -1;
        };
      function p(f) {
        if (typeof f != "string" && (f = String(f)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(f))
          throw new TypeError("Invalid character in header field name");
        return f.toLowerCase();
      }
      function w(f) {
        return typeof f != "string" && (f = String(f)), f;
      }
      function A(f) {
        var g = {
          next: function() {
            var b = f.shift();
            return { done: b === void 0, value: b };
          }
        };
        return a.iterable && (g[Symbol.iterator] = function() {
          return g;
        }), g;
      }
      function P(f) {
        this.map = {}, f instanceof P ? f.forEach(function(g, b) {
          this.append(b, g);
        }, this) : Array.isArray(f) ? f.forEach(function(g) {
          this.append(g[0], g[1]);
        }, this) : f && Object.getOwnPropertyNames(f).forEach(function(g) {
          this.append(g, f[g]);
        }, this);
      }
      P.prototype.append = function(f, g) {
        f = p(f), g = w(g);
        var b = this.map[f];
        this.map[f] = b ? b + ", " + g : g;
      }, P.prototype.delete = function(f) {
        delete this.map[p(f)];
      }, P.prototype.get = function(f) {
        return f = p(f), this.has(f) ? this.map[f] : null;
      }, P.prototype.has = function(f) {
        return this.map.hasOwnProperty(p(f));
      }, P.prototype.set = function(f, g) {
        this.map[p(f)] = w(g);
      }, P.prototype.forEach = function(f, g) {
        for (var b in this.map)
          this.map.hasOwnProperty(b) && f.call(g, this.map[b], b, this);
      }, P.prototype.keys = function() {
        var f = [];
        return this.forEach(function(g, b) {
          f.push(b);
        }), A(f);
      }, P.prototype.values = function() {
        var f = [];
        return this.forEach(function(g) {
          f.push(g);
        }), A(f);
      }, P.prototype.entries = function() {
        var f = [];
        return this.forEach(function(g, b) {
          f.push([b, g]);
        }), A(f);
      }, a.iterable && (P.prototype[Symbol.iterator] = P.prototype.entries);
      function N(f) {
        if (f.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        f.bodyUsed = !0;
      }
      function L(f) {
        return new Promise(function(g, b) {
          f.onload = function() {
            g(f.result);
          }, f.onerror = function() {
            b(f.error);
          };
        });
      }
      function $(f) {
        var g = new FileReader(), b = L(g);
        return g.readAsArrayBuffer(f), b;
      }
      function B(f) {
        var g = new FileReader(), b = L(g);
        return g.readAsText(f), b;
      }
      function H(f) {
        for (var g = new Uint8Array(f), b = new Array(g.length), x = 0; x < g.length; x++)
          b[x] = String.fromCharCode(g[x]);
        return b.join("");
      }
      function W(f) {
        if (f.slice)
          return f.slice(0);
        var g = new Uint8Array(f.byteLength);
        return g.set(new Uint8Array(f)), g.buffer;
      }
      function V() {
        return this.bodyUsed = !1, this._initBody = function(f) {
          this._bodyInit = f, f ? typeof f == "string" ? this._bodyText = f : a.blob && Blob.prototype.isPrototypeOf(f) ? this._bodyBlob = f : a.formData && FormData.prototype.isPrototypeOf(f) ? this._bodyFormData = f : a.searchParams && URLSearchParams.prototype.isPrototypeOf(f) ? this._bodyText = f.toString() : a.arrayBuffer && a.blob && u(f) ? (this._bodyArrayBuffer = W(f.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : a.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(f) || d(f)) ? this._bodyArrayBuffer = W(f) : this._bodyText = f = Object.prototype.toString.call(f) : this._bodyText = "", this.headers.get("content-type") || (typeof f == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : a.searchParams && URLSearchParams.prototype.isPrototypeOf(f) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, a.blob && (this.blob = function() {
          var f = N(this);
          if (f)
            return f;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? N(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then($);
        }), this.text = function() {
          var f = N(this);
          if (f)
            return f;
          if (this._bodyBlob)
            return B(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(H(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, a.formData && (this.formData = function() {
          return this.text().then(ge);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var te = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function R(f) {
        var g = f.toUpperCase();
        return te.indexOf(g) > -1 ? g : f;
      }
      function K(f, g) {
        g = g || {};
        var b = g.body;
        if (f instanceof K) {
          if (f.bodyUsed)
            throw new TypeError("Already read");
          this.url = f.url, this.credentials = f.credentials, g.headers || (this.headers = new P(f.headers)), this.method = f.method, this.mode = f.mode, this.signal = f.signal, !b && f._bodyInit != null && (b = f._bodyInit, f.bodyUsed = !0);
        } else
          this.url = String(f);
        if (this.credentials = g.credentials || this.credentials || "same-origin", (g.headers || !this.headers) && (this.headers = new P(g.headers)), this.method = R(g.method || this.method || "GET"), this.mode = g.mode || this.mode || null, this.signal = g.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && b)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(b);
      }
      K.prototype.clone = function() {
        return new K(this, { body: this._bodyInit });
      };
      function ge(f) {
        var g = new FormData();
        return f.trim().split("&").forEach(function(b) {
          if (b) {
            var x = b.split("="), _ = x.shift().replace(/\+/g, " "), E = x.join("=").replace(/\+/g, " ");
            g.append(decodeURIComponent(_), decodeURIComponent(E));
          }
        }), g;
      }
      function Ee(f) {
        var g = new P(), b = f.replace(/\r?\n[\t ]+/g, " ");
        return b.split(/\r?\n/).forEach(function(x) {
          var _ = x.split(":"), E = _.shift().trim();
          if (E) {
            var v = _.join(":").trim();
            g.append(E, v);
          }
        }), g;
      }
      V.call(K.prototype);
      function Y(f, g) {
        g || (g = {}), this.type = "default", this.status = g.status === void 0 ? 200 : g.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in g ? g.statusText : "OK", this.headers = new P(g.headers), this.url = g.url || "", this._initBody(f);
      }
      V.call(Y.prototype), Y.prototype.clone = function() {
        return new Y(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new P(this.headers),
          url: this.url
        });
      }, Y.error = function() {
        var f = new Y(null, { status: 0, statusText: "" });
        return f.type = "error", f;
      };
      var S = [301, 302, 303, 307, 308];
      Y.redirect = function(f, g) {
        if (S.indexOf(g) === -1)
          throw new RangeError("Invalid status code");
        return new Y(null, { status: g, headers: { location: f } });
      }, o.DOMException = s.DOMException;
      try {
        new o.DOMException();
      } catch {
        o.DOMException = function(g, b) {
          this.message = g, this.name = b;
          var x = Error(g);
          this.stack = x.stack;
        }, o.DOMException.prototype = Object.create(Error.prototype), o.DOMException.prototype.constructor = o.DOMException;
      }
      function m(f, g) {
        return new Promise(function(b, x) {
          var _ = new K(f, g);
          if (_.signal && _.signal.aborted)
            return x(new o.DOMException("Aborted", "AbortError"));
          var E = new XMLHttpRequest();
          function v() {
            E.abort();
          }
          E.onload = function() {
            var M = {
              status: E.status,
              statusText: E.statusText,
              headers: Ee(E.getAllResponseHeaders() || "")
            };
            M.url = "responseURL" in E ? E.responseURL : M.headers.get("X-Request-URL");
            var I = "response" in E ? E.response : E.responseText;
            b(new Y(I, M));
          }, E.onerror = function() {
            x(new TypeError("Network request failed"));
          }, E.ontimeout = function() {
            x(new TypeError("Network request failed"));
          }, E.onabort = function() {
            x(new o.DOMException("Aborted", "AbortError"));
          }, E.open(_.method, _.url, !0), _.credentials === "include" ? E.withCredentials = !0 : _.credentials === "omit" && (E.withCredentials = !1), "responseType" in E && a.blob && (E.responseType = "blob"), _.headers.forEach(function(M, I) {
            E.setRequestHeader(I, M);
          }), _.signal && (_.signal.addEventListener("abort", v), E.onreadystatechange = function() {
            E.readyState === 4 && _.signal.removeEventListener("abort", v);
          }), E.send(typeof _._bodyInit > "u" ? null : _._bodyInit);
        });
      }
      return m.polyfill = !0, s.fetch || (s.fetch = m, s.Headers = P, s.Request = K, s.Response = Y), o.Headers = P, o.Request = K, o.Response = Y, o.fetch = m, Object.defineProperty(o, "__esModule", { value: !0 }), o;
    })({});
  })(n), n.fetch.ponyfill = !0, delete n.fetch.polyfill;
  var i = n;
  e = i.fetch, e.default = i.fetch, e.fetch = i.fetch, e.Headers = i.Headers, e.Request = i.Request, e.Response = i.Response, t.exports = e;
})(O1, O1.exports);
var ZV = O1.exports;
const B3 = /* @__PURE__ */ rs(ZV);
var QV = Object.defineProperty, eG = Object.defineProperties, tG = Object.getOwnPropertyDescriptors, F3 = Object.getOwnPropertySymbols, rG = Object.prototype.hasOwnProperty, nG = Object.prototype.propertyIsEnumerable, j3 = (t, e, r) => e in t ? QV(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, U3 = (t, e) => {
  for (var r in e || (e = {})) rG.call(e, r) && j3(t, r, e[r]);
  if (F3) for (var r of F3(e)) nG.call(e, r) && j3(t, r, e[r]);
  return t;
}, q3 = (t, e) => eG(t, tG(e));
const iG = { Accept: "application/json", "Content-Type": "application/json" }, sG = "POST", z3 = { headers: iG, method: sG }, W3 = 10;
let As = class {
  constructor(e, r = !1) {
    if (this.url = e, this.disableProviderPing = r, this.events = new ns.EventEmitter(), this.isAvailable = !1, this.registering = !1, !f3(e)) throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
    this.url = e, this.disableProviderPing = r;
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  async open(e = this.url) {
    await this.register(e);
  }
  async close() {
    if (!this.isAvailable) throw new Error("Connection already closed");
    this.onClose();
  }
  async send(e) {
    this.isAvailable || await this.register();
    try {
      const r = Bo(e), n = await (await B3(this.url, q3(U3({}, z3), { body: r }))).json();
      this.onPayload({ data: n });
    } catch (r) {
      this.onError(e.id, r);
    }
  }
  async register(e = this.url) {
    if (!f3(e)) throw new Error(`Provided URL is not compatible with HTTP connection: ${e}`);
    if (this.registering) {
      const r = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= r || this.events.listenerCount("open") >= r) && this.events.setMaxListeners(r + 1), new Promise((n, i) => {
        this.events.once("register_error", (s) => {
          this.resetMaxListeners(), i(s);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.isAvailable > "u") return i(new Error("HTTP connection is missing or invalid"));
          n();
        });
      });
    }
    this.url = e, this.registering = !0;
    try {
      if (!this.disableProviderPing) {
        const r = Bo({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
        await B3(e, q3(U3({}, z3), { body: r }));
      }
      this.onOpen();
    } catch (r) {
      const n = this.parseError(r);
      throw this.events.emit("register_error", n), this.onClose(), n;
    }
  }
  onOpen() {
    this.isAvailable = !0, this.registering = !1, this.events.emit("open");
  }
  onClose() {
    this.isAvailable = !1, this.registering = !1, this.events.emit("close");
  }
  onPayload(e) {
    if (typeof e.data > "u") return;
    const r = typeof e.data == "string" ? lc(e.data) : e.data;
    this.events.emit("payload", r);
  }
  onError(e, r) {
    const n = this.parseError(r), i = n.message || n.toString(), s = np(e, i);
    this.events.emit("payload", s);
  }
  parseError(e, r = this.url) {
    return Z8(e, r, "HTTP");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > W3 && this.events.setMaxListeners(W3);
  }
};
const H3 = "error", oG = "wss://relay.walletconnect.org", aG = "wc", cG = "universal_provider", K3 = `${aG}@2:${cG}:`, _E = "https://rpc.walletconnect.org/v1/", Xc = "generic", uG = `${_E}bundler`, us = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
var fG = Object.defineProperty, lG = Object.defineProperties, hG = Object.getOwnPropertyDescriptors, V3 = Object.getOwnPropertySymbols, dG = Object.prototype.hasOwnProperty, pG = Object.prototype.propertyIsEnumerable, G3 = (t, e, r) => e in t ? fG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, ld = (t, e) => {
  for (var r in e || (e = {})) dG.call(e, r) && G3(t, r, e[r]);
  if (V3) for (var r of V3(e)) pG.call(e, r) && G3(t, r, e[r]);
  return t;
}, gG = (t, e) => lG(t, hG(e));
function Li(t, e, r) {
  var n;
  const i = hu(t);
  return ((n = e.rpcMap) == null ? void 0 : n[i.reference]) || `${_E}?chainId=${i.namespace}:${i.reference}&projectId=${r}`;
}
function Sc(t) {
  return t.includes(":") ? t.split(":")[1] : t;
}
function EE(t) {
  return t.map((e) => `${e.split(":")[0]}:${e.split(":")[1]}`);
}
function mG(t, e) {
  const r = Object.keys(e.namespaces).filter((i) => i.includes(t));
  if (!r.length) return [];
  const n = [];
  return r.forEach((i) => {
    const s = e.namespaces[i].accounts;
    n.push(...s);
  }), n;
}
function bm(t = {}, e = {}) {
  const r = Y3(t), n = Y3(e);
  return XV.merge(r, n);
}
function Y3(t) {
  var e, r, n, i;
  const s = {};
  if (!Sl(t)) return s;
  for (const [o, a] of Object.entries(t)) {
    const u = ab(o) ? [o] : a.chains, l = a.methods || [], d = a.events || [], p = a.rpcMap || {}, w = Ff(o);
    s[w] = gG(ld(ld({}, s[w]), a), { chains: Id(u, (e = s[w]) == null ? void 0 : e.chains), methods: Id(l, (r = s[w]) == null ? void 0 : r.methods), events: Id(d, (n = s[w]) == null ? void 0 : n.events), rpcMap: ld(ld({}, p), (i = s[w]) == null ? void 0 : i.rpcMap) });
  }
  return s;
}
function vG(t) {
  return t.includes(":") ? t.split(":")[2] : t;
}
function J3(t) {
  const e = {};
  for (const [r, n] of Object.entries(t)) {
    const i = n.methods || [], s = n.events || [], o = n.accounts || [], a = ab(r) ? [r] : n.chains ? n.chains : EE(n.accounts);
    e[r] = { chains: a, methods: i, events: s, accounts: o };
  }
  return e;
}
function ym(t) {
  return typeof t == "number" ? t : t.includes("0x") ? parseInt(t, 16) : (t = t.includes(":") ? t.split(":")[1] : t, isNaN(Number(t)) ? t : Number(t));
}
const SE = {}, Ar = (t) => SE[t], wm = (t, e) => {
  SE[t] = e;
};
class bG {
  constructor(e) {
    this.name = "polkadot", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(us.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = Sc(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Li(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cs(new As(n, Ar("disableProviderPing")));
  }
}
var yG = Object.defineProperty, wG = Object.defineProperties, xG = Object.getOwnPropertyDescriptors, X3 = Object.getOwnPropertySymbols, _G = Object.prototype.hasOwnProperty, EG = Object.prototype.propertyIsEnumerable, Z3 = (t, e, r) => e in t ? yG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Q3 = (t, e) => {
  for (var r in e || (e = {})) _G.call(e, r) && Z3(t, r, e[r]);
  if (X3) for (var r of X3(e)) EG.call(e, r) && Z3(t, r, e[r]);
  return t;
}, e6 = (t, e) => wG(t, xG(e));
class SG {
  constructor(e) {
    this.name = "eip155", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(e) {
    switch (e.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(e);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(e);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(e);
    }
    return this.namespace.methods.includes(e.request.method) ? await this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(parseInt(e), r), this.chainId = parseInt(e), this.events.emit(us.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  createHttpProvider(e, r) {
    const n = r || Li(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cs(new As(n, Ar("disableProviderPing")));
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = parseInt(Sc(r));
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const e = this.chainId, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  async handleSwitchChain(e) {
    var r, n;
    let i = e.request.params ? (r = e.request.params[0]) == null ? void 0 : r.chainId : "0x0";
    i = i.startsWith("0x") ? i : `0x${i}`;
    const s = parseInt(i, 16);
    if (this.isChainApproved(s)) this.setDefaultChain(`${s}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: e.topic, request: { method: e.request.method, params: [{ chainId: i }] }, chainId: (n = this.namespace.chains) == null ? void 0 : n[0] }), this.setDefaultChain(`${s}`);
    else throw new Error(`Failed to switch to chain 'eip155:${s}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(e) {
    return this.namespace.chains.includes(`${this.name}:${e}`);
  }
  async getCapabilities(e) {
    var r, n, i;
    const s = (n = (r = e.request) == null ? void 0 : r.params) == null ? void 0 : n[0];
    if (!s) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const o = this.client.session.get(e.topic), a = ((i = o == null ? void 0 : o.sessionProperties) == null ? void 0 : i.capabilities) || {};
    if (a != null && a[s]) return a == null ? void 0 : a[s];
    const u = await this.client.request(e);
    try {
      await this.client.session.update(e.topic, { sessionProperties: e6(Q3({}, o.sessionProperties || {}), { capabilities: e6(Q3({}, a || {}), { [s]: u }) }) });
    } catch (l) {
      console.warn("Failed to update session with capabilities", l);
    }
    return u;
  }
  async getCallStatus(e) {
    var r, n;
    const i = this.client.session.get(e.topic), s = (r = i.sessionProperties) == null ? void 0 : r.bundler_name;
    if (s) {
      const a = this.getBundlerUrl(e.chainId, s);
      try {
        return await this.getUserOperationReceipt(a, e);
      } catch (u) {
        console.warn("Failed to fetch call status from bundler", u, a);
      }
    }
    const o = (n = i.sessionProperties) == null ? void 0 : n.bundler_url;
    if (o) try {
      return await this.getUserOperationReceipt(o, e);
    } catch (a) {
      console.warn("Failed to fetch call status from custom bundler", a, o);
    }
    if (this.namespace.methods.includes(e.request.method)) return await this.client.request(e);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(e, r) {
    var n;
    const i = new URL(e), s = await fetch(i, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(ga("eth_getUserOperationReceipt", [(n = r.request.params) == null ? void 0 : n[0]])) });
    if (!s.ok) throw new Error(`Failed to fetch user operation receipt - ${s.status}`);
    return await s.json();
  }
  getBundlerUrl(e, r) {
    return `${uG}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${r}`;
  }
}
class AG {
  constructor(e) {
    this.name = "solana", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(us.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = Sc(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Li(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cs(new As(n, Ar("disableProviderPing")));
  }
}
let PG = class {
  constructor(e) {
    this.name = "cosmos", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(us.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = Sc(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Li(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cs(new As(n, Ar("disableProviderPing")));
  }
}, MG = class {
  constructor(e) {
    this.name = "algorand", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    if (!this.httpProviders[e]) {
      const n = r || Li(`${this.name}:${e}`, this.namespace, this.client.core.projectId);
      if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, n);
    }
    this.chainId = e, this.events.emit(us.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      e[r] = this.createHttpProvider(r, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Li(e, this.namespace, this.client.core.projectId);
    return typeof n > "u" ? void 0 : new cs(new As(n, Ar("disableProviderPing")));
  }
}, IG = class {
  constructor(e) {
    this.name = "cip34", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(us.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      const n = this.getCardanoRPCUrl(r), i = Sc(r);
      e[i] = this.createHttpProvider(i, n);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  getCardanoRPCUrl(e) {
    const r = this.namespace.rpcMap;
    if (r) return r[e];
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || this.getCardanoRPCUrl(e);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cs(new As(n, Ar("disableProviderPing")));
  }
}, CG = class {
  constructor(e) {
    this.name = "elrond", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(us.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = Sc(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Li(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cs(new As(n, Ar("disableProviderPing")));
  }
};
class TG {
  constructor(e) {
    this.name = "multiversx", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(us.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      const i = Sc(r);
      e[i] = this.createHttpProvider(i, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Li(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cs(new As(n, Ar("disableProviderPing")));
  }
}
let RG = class {
  constructor(e) {
    this.name = "near", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    if (this.chainId = e, !this.httpProviders[e]) {
      const n = r || Li(`${this.name}:${e}`, this.namespace);
      if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, n);
    }
    this.events.emit(us.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      var n;
      e[r] = this.createHttpProvider(r, (n = this.namespace.rpcMap) == null ? void 0 : n[r]);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Li(e, this.namespace);
    return typeof n > "u" ? void 0 : new cs(new As(n, Ar("disableProviderPing")));
  }
};
class DG {
  constructor(e) {
    this.name = "tezos", this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace = Object.assign(this.namespace, e);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider().request(e.request);
  }
  setDefaultChain(e, r) {
    if (this.chainId = e, !this.httpProviders[e]) {
      const n = r || Li(`${this.name}:${e}`, this.namespace);
      if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
      this.setHttpProvider(e, n);
    }
    this.events.emit(us.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const e = {};
    return this.namespace.chains.forEach((r) => {
      e[r] = this.createHttpProvider(r);
    }), e;
  }
  getHttpProvider() {
    const e = `${this.name}:${this.chainId}`, r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Li(e, this.namespace);
    return typeof n > "u" ? void 0 : new cs(new As(n));
  }
}
class OG {
  constructor(e) {
    this.name = Xc, this.namespace = e.namespace, this.events = Ar("events"), this.client = Ar("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(e) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(e.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(e.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(e.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(e.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(e) {
    return this.namespace.methods.includes(e.request.method) ? this.client.request(e) : this.getHttpProvider(e.chainId).request(e.request);
  }
  setDefaultChain(e, r) {
    this.httpProviders[e] || this.setHttpProvider(e, r), this.chainId = e, this.events.emit(us.DEFAULT_CHAIN_CHANGED, `${this.name}:${e}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const e = this.namespace.chains[0];
    if (!e) throw new Error("ChainId not found");
    return e.split(":")[1];
  }
  getAccounts() {
    const e = this.namespace.accounts;
    return e ? [...new Set(e.filter((r) => r.split(":")[1] === this.chainId.toString()).map((r) => r.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var e, r;
    const n = {};
    return (r = (e = this.namespace) == null ? void 0 : e.accounts) == null || r.forEach((i) => {
      const s = hu(i);
      n[`${s.namespace}:${s.reference}`] = this.createHttpProvider(i);
    }), n;
  }
  getHttpProvider(e) {
    const r = this.httpProviders[e];
    if (typeof r > "u") throw new Error(`JSON-RPC provider for ${e} not found`);
    return r;
  }
  setHttpProvider(e, r) {
    const n = this.createHttpProvider(e, r);
    n && (this.httpProviders[e] = n);
  }
  createHttpProvider(e, r) {
    const n = r || Li(e, this.namespace, this.client.core.projectId);
    if (!n) throw new Error(`No RPC url provided for chainId: ${e}`);
    return new cs(new As(n, Ar("disableProviderPing")));
  }
}
var NG = Object.defineProperty, LG = Object.defineProperties, kG = Object.getOwnPropertyDescriptors, t6 = Object.getOwnPropertySymbols, $G = Object.prototype.hasOwnProperty, BG = Object.prototype.propertyIsEnumerable, r6 = (t, e, r) => e in t ? NG(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, hd = (t, e) => {
  for (var r in e || (e = {})) $G.call(e, r) && r6(t, r, e[r]);
  if (t6) for (var r of t6(e)) BG.call(e, r) && r6(t, r, e[r]);
  return t;
}, xm = (t, e) => LG(t, kG(e));
let AE = class PE {
  constructor(e) {
    this.events = new kv(), this.rpcProviders = {}, this.shouldAbortPairingAttempt = !1, this.maxPairingAttempts = 10, this.disableProviderPing = !1, this.providerOpts = e, this.logger = typeof (e == null ? void 0 : e.logger) < "u" && typeof (e == null ? void 0 : e.logger) != "string" ? e.logger : ql($0({ level: (e == null ? void 0 : e.logger) || H3 })), this.disableProviderPing = (e == null ? void 0 : e.disableProviderPing) || !1;
  }
  static async init(e) {
    const r = new PE(e);
    return await r.initialize(), r;
  }
  async request(e, r, n) {
    const [i, s] = this.validateChain(r);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(i).request({ request: hd({}, e), chainId: `${i}:${s}`, topic: this.session.topic, expiry: n });
  }
  sendAsync(e, r, n, i) {
    const s = (/* @__PURE__ */ new Date()).getTime();
    this.request(e, n, i).then((o) => r(null, rp(s, o))).catch((o) => r(o, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var e;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (e = this.session) == null ? void 0 : e.topic, reason: Or("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(e) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(e), await this.cleanupPendingPairings(), !e.skipPairing) return await this.pair(e.pairingTopic);
  }
  async authenticate(e, r) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(e), await this.cleanupPendingPairings();
    const { uri: n, response: i } = await this.client.authenticate(e, r);
    n && (this.uri = n, this.events.emit("display_uri", n));
    const s = await i();
    if (this.session = s.session, this.session) {
      const o = J3(this.session.namespaces);
      this.namespaces = bm(this.namespaces, o), this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return s;
  }
  on(e, r) {
    this.events.on(e, r);
  }
  once(e, r) {
    this.events.once(e, r);
  }
  removeListener(e, r) {
    this.events.removeListener(e, r);
  }
  off(e, r) {
    this.events.off(e, r);
  }
  get isWalletConnect() {
    return !0;
  }
  async pair(e) {
    this.shouldAbortPairingAttempt = !1;
    let r = 0;
    do {
      if (this.shouldAbortPairingAttempt) throw new Error("Pairing aborted");
      if (r >= this.maxPairingAttempts) throw new Error("Max auto pairing attempts reached");
      const { uri: n, approval: i } = await this.client.connect({ pairingTopic: e, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties });
      n && (this.uri = n, this.events.emit("display_uri", n)), await i().then((s) => {
        this.session = s;
        const o = J3(s.namespaces);
        this.namespaces = bm(this.namespaces, o), this.persist("namespaces", this.namespaces);
      }).catch((s) => {
        if (s.message !== xE) throw s;
        r++;
      });
    } while (!this.session);
    return this.onConnect(), this.session;
  }
  setDefaultChain(e, r) {
    try {
      if (!this.session) return;
      const [n, i] = this.validateChain(e), s = this.getProvider(n);
      s.name === Xc ? s.setDefaultChain(`${n}:${i}`, r) : s.setDefaultChain(i, r);
    } catch (n) {
      if (!/Please call connect/.test(n.message)) throw n;
    }
  }
  async cleanupPendingPairings(e = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const r = this.client.pairing.getAll();
    if (gc(r)) {
      for (const n of r) e.deletePairings ? this.client.core.expirer.set(n.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(n.topic);
      this.logger.info(`Inactive pairings cleared: ${r.length}`);
    }
  }
  abortPairingAttempt() {
    this.shouldAbortPairingAttempt = !0;
  }
  async checkStorage() {
    if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
      const e = this.client.session.keys.length - 1;
      this.session = this.client.session.get(this.client.session.keys[e]), this.createProviders();
    }
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    this.client = this.providerOpts.client || await db.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || H3, relayUrl: this.providerOpts.relayUrl || oG, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const e = [...new Set(Object.keys(this.session.namespaces).map((r) => Ff(r)))];
    wm("client", this.client), wm("events", this.events), wm("disableProviderPing", this.disableProviderPing), e.forEach((r) => {
      if (!this.session) return;
      const n = mG(r, this.session), i = EE(n), s = bm(this.namespaces, this.optionalNamespaces), o = xm(hd({}, s[r]), { accounts: n, chains: i });
      switch (r) {
        case "eip155":
          this.rpcProviders[r] = new SG({ namespace: o });
          break;
        case "algorand":
          this.rpcProviders[r] = new MG({ namespace: o });
          break;
        case "solana":
          this.rpcProviders[r] = new AG({ namespace: o });
          break;
        case "cosmos":
          this.rpcProviders[r] = new PG({ namespace: o });
          break;
        case "polkadot":
          this.rpcProviders[r] = new bG({ namespace: o });
          break;
        case "cip34":
          this.rpcProviders[r] = new IG({ namespace: o });
          break;
        case "elrond":
          this.rpcProviders[r] = new CG({ namespace: o });
          break;
        case "multiversx":
          this.rpcProviders[r] = new TG({ namespace: o });
          break;
        case "near":
          this.rpcProviders[r] = new RG({ namespace: o });
          break;
        case "tezos":
          this.rpcProviders[r] = new DG({ namespace: o });
          break;
        default:
          this.rpcProviders[Xc] ? this.rpcProviders[Xc].updateNamespace(o) : this.rpcProviders[Xc] = new OG({ namespace: o });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (e) => {
      this.events.emit("session_ping", e);
    }), this.client.on("session_event", (e) => {
      const { params: r } = e, { event: n } = r;
      if (n.name === "accountsChanged") {
        const i = n.data;
        i && gc(i) && this.events.emit("accountsChanged", i.map(vG));
      } else if (n.name === "chainChanged") {
        const i = r.chainId, s = r.event.data, o = Ff(i), a = ym(i) !== ym(s) ? `${o}:${ym(s)}` : i;
        this.onChainChanged(a);
      } else this.events.emit(n.name, n.data);
      this.events.emit("session_event", e);
    }), this.client.on("session_update", ({ topic: e, params: r }) => {
      var n;
      const { namespaces: i } = r, s = (n = this.client) == null ? void 0 : n.session.get(e);
      this.session = xm(hd({}, s), { namespaces: i }), this.onSessionUpdate(), this.events.emit("session_update", { topic: e, params: r });
    }), this.client.on("session_delete", async (e) => {
      await this.cleanup(), this.events.emit("session_delete", e), this.events.emit("disconnect", xm(hd({}, Or("USER_DISCONNECTED")), { data: e.topic }));
    }), this.on(us.DEFAULT_CHAIN_CHANGED, (e) => {
      this.onChainChanged(e, !0);
    });
  }
  getProvider(e) {
    return this.rpcProviders[e] || this.rpcProviders[Xc];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((e) => {
      var r;
      this.getProvider(e).updateNamespace((r = this.session) == null ? void 0 : r.namespaces[e]);
    });
  }
  setNamespaces(e) {
    const { namespaces: r, optionalNamespaces: n, sessionProperties: i } = e;
    r && Object.keys(r).length && (this.namespaces = r), n && Object.keys(n).length && (this.optionalNamespaces = n), this.sessionProperties = i, this.persist("namespaces", r), this.persist("optionalNamespaces", n);
  }
  validateChain(e) {
    const [r, n] = (e == null ? void 0 : e.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [r, n];
    if (r && !Object.keys(this.namespaces || {}).map((o) => Ff(o)).includes(r)) throw new Error(`Namespace '${r}' is not configured. Please call connect() first with namespace config.`);
    if (r && n) return [r, n];
    const i = Ff(Object.keys(this.namespaces)[0]), s = this.rpcProviders[i].getDefaultChain();
    return [i, s];
  }
  async requestAccounts() {
    const [e] = this.validateChain();
    return await this.getProvider(e).requestAccounts();
  }
  onChainChanged(e, r = !1) {
    if (!this.namespaces) return;
    const [n, i] = this.validateChain(e);
    i && (r || this.getProvider(n).setDefaultChain(i), this.namespaces[n] ? this.namespaces[n].defaultChain = i : this.namespaces[`${n}:${i}`] ? this.namespaces[`${n}:${i}`].defaultChain = i : this.namespaces[`${n}:${i}`] = { defaultChain: i }, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", i));
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({ deletePairings: !0 });
  }
  persist(e, r) {
    this.client.core.storage.setItem(`${K3}/${e}`, r);
  }
  async getFromStore(e) {
    return await this.client.core.storage.getItem(`${K3}/${e}`);
  }
};
const FG = AE;
function jG() {
  return new Promise((t) => {
    const e = [];
    let r;
    window.addEventListener("eip6963:announceProvider", (n) => {
      const { detail: i } = n;
      r && clearTimeout(r), e.push(i), r = setTimeout(() => t(e), 200);
    }), r = setTimeout(() => t(e), 200), window.dispatchEvent(new Event("eip6963:requestProvider"));
  });
}
class to {
  constructor(e, r) {
    this.scope = e, this.module = r;
  }
  storeObject(e, r) {
    this.setItem(e, JSON.stringify(r));
  }
  loadObject(e) {
    const r = this.getItem(e);
    return r ? JSON.parse(r) : void 0;
  }
  setItem(e, r) {
    localStorage.setItem(this.scopedKey(e), r);
  }
  getItem(e) {
    return localStorage.getItem(this.scopedKey(e));
  }
  removeItem(e) {
    localStorage.removeItem(this.scopedKey(e));
  }
  clear() {
    const e = this.scopedKey(""), r = [];
    for (let n = 0; n < localStorage.length; n++) {
      const i = localStorage.key(n);
      typeof i == "string" && i.startsWith(e) && r.push(i);
    }
    r.forEach((n) => localStorage.removeItem(n));
  }
  scopedKey(e) {
    return `-${this.scope}${this.module ? `:${this.module}` : ""}:${e}`;
  }
  static clearAll() {
    new to("CBWSDK").clear(), new to("walletlink").clear();
  }
}
const fn = {
  rpc: {
    invalidInput: -32e3,
    resourceNotFound: -32001,
    resourceUnavailable: -32002,
    transactionRejected: -32003,
    methodNotSupported: -32004,
    limitExceeded: -32005,
    parse: -32700,
    invalidRequest: -32600,
    methodNotFound: -32601,
    invalidParams: -32602,
    internal: -32603
  },
  provider: {
    userRejectedRequest: 4001,
    unauthorized: 4100,
    unsupportedMethod: 4200,
    disconnected: 4900,
    chainDisconnected: 4901,
    unsupportedChain: 4902
  }
}, N1 = {
  "-32700": {
    standard: "JSON RPC 2.0",
    message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    standard: "JSON RPC 2.0",
    message: "The JSON sent is not a valid Request object."
  },
  "-32601": {
    standard: "JSON RPC 2.0",
    message: "The method does not exist / is not available."
  },
  "-32602": {
    standard: "JSON RPC 2.0",
    message: "Invalid method parameter(s)."
  },
  "-32603": {
    standard: "JSON RPC 2.0",
    message: "Internal JSON-RPC error."
  },
  "-32000": {
    standard: "EIP-1474",
    message: "Invalid input."
  },
  "-32001": {
    standard: "EIP-1474",
    message: "Resource not found."
  },
  "-32002": {
    standard: "EIP-1474",
    message: "Resource unavailable."
  },
  "-32003": {
    standard: "EIP-1474",
    message: "Transaction rejected."
  },
  "-32004": {
    standard: "EIP-1474",
    message: "Method not supported."
  },
  "-32005": {
    standard: "EIP-1474",
    message: "Request limit exceeded."
  },
  4001: {
    standard: "EIP-1193",
    message: "User rejected the request."
  },
  4100: {
    standard: "EIP-1193",
    message: "The requested account and/or method has not been authorized by the user."
  },
  4200: {
    standard: "EIP-1193",
    message: "The requested method is not supported by this Ethereum provider."
  },
  4900: {
    standard: "EIP-1193",
    message: "The provider is disconnected from all chains."
  },
  4901: {
    standard: "EIP-1193",
    message: "The provider is disconnected from the specified chain."
  },
  4902: {
    standard: "EIP-3085",
    message: "Unrecognized chain ID."
  }
}, ME = "Unspecified error message.", UG = "Unspecified server error.";
function pb(t, e = ME) {
  if (t && Number.isInteger(t)) {
    const r = t.toString();
    if (L1(N1, r))
      return N1[r].message;
    if (IE(t))
      return UG;
  }
  return e;
}
function qG(t) {
  if (!Number.isInteger(t))
    return !1;
  const e = t.toString();
  return !!(N1[e] || IE(t));
}
function zG(t, { shouldIncludeStack: e = !1 } = {}) {
  const r = {};
  if (t && typeof t == "object" && !Array.isArray(t) && L1(t, "code") && qG(t.code)) {
    const n = t;
    r.code = n.code, n.message && typeof n.message == "string" ? (r.message = n.message, L1(n, "data") && (r.data = n.data)) : (r.message = pb(r.code), r.data = { originalError: n6(t) });
  } else
    r.code = fn.rpc.internal, r.message = i6(t, "message") ? t.message : ME, r.data = { originalError: n6(t) };
  return e && (r.stack = i6(t, "stack") ? t.stack : void 0), r;
}
function IE(t) {
  return t >= -32099 && t <= -32e3;
}
function n6(t) {
  return t && typeof t == "object" && !Array.isArray(t) ? Object.assign({}, t) : t;
}
function L1(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
function i6(t, e) {
  return typeof t == "object" && t !== null && e in t && typeof t[e] == "string";
}
const Sr = {
  rpc: {
    parse: (t) => Yi(fn.rpc.parse, t),
    invalidRequest: (t) => Yi(fn.rpc.invalidRequest, t),
    invalidParams: (t) => Yi(fn.rpc.invalidParams, t),
    methodNotFound: (t) => Yi(fn.rpc.methodNotFound, t),
    internal: (t) => Yi(fn.rpc.internal, t),
    server: (t) => {
      if (!t || typeof t != "object" || Array.isArray(t))
        throw new Error("Ethereum RPC Server errors must provide single object argument.");
      const { code: e } = t;
      if (!Number.isInteger(e) || e > -32005 || e < -32099)
        throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
      return Yi(e, t);
    },
    invalidInput: (t) => Yi(fn.rpc.invalidInput, t),
    resourceNotFound: (t) => Yi(fn.rpc.resourceNotFound, t),
    resourceUnavailable: (t) => Yi(fn.rpc.resourceUnavailable, t),
    transactionRejected: (t) => Yi(fn.rpc.transactionRejected, t),
    methodNotSupported: (t) => Yi(fn.rpc.methodNotSupported, t),
    limitExceeded: (t) => Yi(fn.rpc.limitExceeded, t)
  },
  provider: {
    userRejectedRequest: (t) => Vc(fn.provider.userRejectedRequest, t),
    unauthorized: (t) => Vc(fn.provider.unauthorized, t),
    unsupportedMethod: (t) => Vc(fn.provider.unsupportedMethod, t),
    disconnected: (t) => Vc(fn.provider.disconnected, t),
    chainDisconnected: (t) => Vc(fn.provider.chainDisconnected, t),
    unsupportedChain: (t) => Vc(fn.provider.unsupportedChain, t),
    custom: (t) => {
      if (!t || typeof t != "object" || Array.isArray(t))
        throw new Error("Ethereum Provider custom errors must provide single object argument.");
      const { code: e, message: r, data: n } = t;
      if (!r || typeof r != "string")
        throw new Error('"message" must be a nonempty string');
      return new RE(e, r, n);
    }
  }
};
function Yi(t, e) {
  const [r, n] = CE(e);
  return new TE(t, r || pb(t), n);
}
function Vc(t, e) {
  const [r, n] = CE(e);
  return new RE(t, r || pb(t), n);
}
function CE(t) {
  if (t) {
    if (typeof t == "string")
      return [t];
    if (typeof t == "object" && !Array.isArray(t)) {
      const { message: e, data: r } = t;
      if (e && typeof e != "string")
        throw new Error("Must specify string message.");
      return [e || void 0, r];
    }
  }
  return [];
}
class TE extends Error {
  constructor(e, r, n) {
    if (!Number.isInteger(e))
      throw new Error('"code" must be an integer.');
    if (!r || typeof r != "string")
      throw new Error('"message" must be a nonempty string.');
    super(r), this.code = e, n !== void 0 && (this.data = n);
  }
}
class RE extends TE {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor(e, r, n) {
    if (!WG(e))
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    super(e, r, n);
  }
}
function WG(t) {
  return Number.isInteger(t) && t >= 1e3 && t <= 4999;
}
function gb() {
  return (t) => t;
}
const Al = gb(), HG = gb(), KG = gb();
function So(t) {
  return Math.floor(t);
}
const DE = /^[0-9]*$/, OE = /^[a-f0-9]*$/;
function ec(t) {
  return mb(crypto.getRandomValues(new Uint8Array(t)));
}
function mb(t) {
  return [...t].map((e) => e.toString(16).padStart(2, "0")).join("");
}
function Dd(t) {
  return new Uint8Array(t.match(/.{1,2}/g).map((e) => Number.parseInt(e, 16)));
}
function Hf(t, e = !1) {
  const r = t.toString("hex");
  return Al(e ? `0x${r}` : r);
}
function _m(t) {
  return Hf(k1(t), !0);
}
function $s(t) {
  return KG(t.toString(10));
}
function ma(t) {
  return Al(`0x${BigInt(t).toString(16)}`);
}
function NE(t) {
  return t.startsWith("0x") || t.startsWith("0X");
}
function vb(t) {
  return NE(t) ? t.slice(2) : t;
}
function LE(t) {
  return NE(t) ? `0x${t.slice(2)}` : `0x${t}`;
}
function ap(t) {
  if (typeof t != "string")
    return !1;
  const e = vb(t).toLowerCase();
  return OE.test(e);
}
function VG(t, e = !1) {
  if (typeof t == "string") {
    const r = vb(t).toLowerCase();
    if (OE.test(r))
      return Al(e ? `0x${r}` : r);
  }
  throw Sr.rpc.invalidParams(`"${String(t)}" is not a hexadecimal string`);
}
function bb(t, e = !1) {
  let r = VG(t, !1);
  return r.length % 2 === 1 && (r = Al(`0${r}`)), e ? Al(`0x${r}`) : r;
}
function ia(t) {
  if (typeof t == "string") {
    const e = vb(t).toLowerCase();
    if (ap(e) && e.length === 40)
      return HG(LE(e));
  }
  throw Sr.rpc.invalidParams(`Invalid Ethereum address: ${String(t)}`);
}
function k1(t) {
  if (Buffer.isBuffer(t))
    return t;
  if (typeof t == "string") {
    if (ap(t)) {
      const e = bb(t, !1);
      return Buffer.from(e, "hex");
    }
    return Buffer.from(t, "utf8");
  }
  throw Sr.rpc.invalidParams(`Not binary data: ${String(t)}`);
}
function Kf(t) {
  if (typeof t == "number" && Number.isInteger(t))
    return So(t);
  if (typeof t == "string") {
    if (DE.test(t))
      return So(Number(t));
    if (ap(t))
      return So(Number(BigInt(bb(t, !0))));
  }
  throw Sr.rpc.invalidParams(`Not an integer: ${String(t)}`);
}
function Rf(t) {
  if (t !== null && (typeof t == "bigint" || YG(t)))
    return BigInt(t.toString(10));
  if (typeof t == "number")
    return BigInt(Kf(t));
  if (typeof t == "string") {
    if (DE.test(t))
      return BigInt(t);
    if (ap(t))
      return BigInt(bb(t, !0));
  }
  throw Sr.rpc.invalidParams(`Not an integer: ${String(t)}`);
}
function GG(t) {
  if (typeof t == "string")
    return JSON.parse(t);
  if (typeof t == "object")
    return t;
  throw Sr.rpc.invalidParams(`Not a JSON string or an object: ${String(t)}`);
}
function YG(t) {
  if (t == null || typeof t.constructor != "function")
    return !1;
  const { constructor: e } = t;
  return typeof e.config == "function" && typeof e.EUCLID == "number";
}
async function JG() {
  return crypto.subtle.generateKey({
    name: "ECDH",
    namedCurve: "P-256"
  }, !0, ["deriveKey"]);
}
async function XG(t, e) {
  return crypto.subtle.deriveKey({
    name: "ECDH",
    public: e
  }, t, {
    name: "AES-GCM",
    length: 256
  }, !1, ["encrypt", "decrypt"]);
}
async function ZG(t, e) {
  const r = crypto.getRandomValues(new Uint8Array(12)), n = await crypto.subtle.encrypt({
    name: "AES-GCM",
    iv: r
  }, t, new TextEncoder().encode(e));
  return { iv: r, cipherText: n };
}
async function QG(t, { iv: e, cipherText: r }) {
  const n = await crypto.subtle.decrypt({
    name: "AES-GCM",
    iv: e
  }, t, r);
  return new TextDecoder().decode(n);
}
function kE(t) {
  switch (t) {
    case "public":
      return "spki";
    case "private":
      return "pkcs8";
  }
}
async function $E(t, e) {
  const r = kE(t), n = await crypto.subtle.exportKey(r, e);
  return mb(new Uint8Array(n));
}
async function BE(t, e) {
  const r = kE(t), n = Dd(e).buffer;
  return await crypto.subtle.importKey(r, new Uint8Array(n), {
    name: "ECDH",
    namedCurve: "P-256"
  }, !0, t === "private" ? ["deriveKey"] : []);
}
async function eY(t, e) {
  const r = JSON.stringify(t, (n, i) => {
    if (!(i instanceof Error))
      return i;
    const s = i;
    return Object.assign(Object.assign({}, s.code ? { code: s.code } : {}), { message: s.message });
  });
  return ZG(e, r);
}
async function tY(t, e) {
  return JSON.parse(await QG(e, t));
}
const Em = {
  storageKey: "ownPrivateKey",
  keyType: "private"
}, Sm = {
  storageKey: "ownPublicKey",
  keyType: "public"
}, Am = {
  storageKey: "peerPublicKey",
  keyType: "public"
};
class rY {
  constructor() {
    this.storage = new to("CBWSDK", "SCWKeyManager"), this.ownPrivateKey = null, this.ownPublicKey = null, this.peerPublicKey = null, this.sharedSecret = null;
  }
  async getOwnPublicKey() {
    return await this.loadKeysIfNeeded(), this.ownPublicKey;
  }
  // returns null if the shared secret is not yet derived
  async getSharedSecret() {
    return await this.loadKeysIfNeeded(), this.sharedSecret;
  }
  async setPeerPublicKey(e) {
    this.sharedSecret = null, this.peerPublicKey = e, await this.storeKey(Am, e), await this.loadKeysIfNeeded();
  }
  async clear() {
    this.ownPrivateKey = null, this.ownPublicKey = null, this.peerPublicKey = null, this.sharedSecret = null, this.storage.removeItem(Sm.storageKey), this.storage.removeItem(Em.storageKey), this.storage.removeItem(Am.storageKey);
  }
  async generateKeyPair() {
    const e = await JG();
    this.ownPrivateKey = e.privateKey, this.ownPublicKey = e.publicKey, await this.storeKey(Em, e.privateKey), await this.storeKey(Sm, e.publicKey);
  }
  async loadKeysIfNeeded() {
    if (this.ownPrivateKey === null && (this.ownPrivateKey = await this.loadKey(Em)), this.ownPublicKey === null && (this.ownPublicKey = await this.loadKey(Sm)), (this.ownPrivateKey === null || this.ownPublicKey === null) && await this.generateKeyPair(), this.peerPublicKey === null && (this.peerPublicKey = await this.loadKey(Am)), this.sharedSecret === null) {
      if (this.ownPrivateKey === null || this.peerPublicKey === null)
        return;
      this.sharedSecret = await XG(this.ownPrivateKey, this.peerPublicKey);
    }
  }
  // storage methods
  async loadKey(e) {
    const r = this.storage.getItem(e.storageKey);
    return r ? BE(e.keyType, r) : null;
  }
  async storeKey(e, r) {
    const n = await $E(e.keyType, r);
    this.storage.setItem(e.storageKey, n);
  }
}
const nh = "4.2.4", FE = "@coinbase/wallet-sdk";
async function jE(t, e) {
  const r = Object.assign(Object.assign({}, t), { jsonrpc: "2.0", id: crypto.randomUUID() }), n = await window.fetch(e, {
    method: "POST",
    body: JSON.stringify(r),
    mode: "cors",
    headers: {
      "Content-Type": "application/json",
      "X-Cbw-Sdk-Version": nh,
      "X-Cbw-Sdk-Platform": FE
    }
  }), { result: i, error: s } = await n.json();
  if (s)
    throw s;
  return i;
}
function nY() {
  return globalThis.coinbaseWalletExtension;
}
function iY() {
  var t, e;
  try {
    const r = globalThis;
    return (t = r.ethereum) !== null && t !== void 0 ? t : (e = r.top) === null || e === void 0 ? void 0 : e.ethereum;
  } catch {
    return;
  }
}
function sY({ metadata: t, preference: e }) {
  var r, n;
  const { appName: i, appLogoUrl: s, appChainIds: o } = t;
  if (e.options !== "smartWalletOnly") {
    const u = nY();
    if (u)
      return (r = u.setAppInfo) === null || r === void 0 || r.call(u, i, s, o, e), u;
  }
  const a = iY();
  if (a != null && a.isCoinbaseBrowser)
    return (n = a.setAppInfo) === null || n === void 0 || n.call(a, i, s, o, e), a;
}
function oY(t) {
  if (!t || typeof t != "object" || Array.isArray(t))
    throw Sr.rpc.invalidParams({
      message: "Expected a single, non-array, object argument.",
      data: t
    });
  const { method: e, params: r } = t;
  if (typeof e != "string" || e.length === 0)
    throw Sr.rpc.invalidParams({
      message: "'args.method' must be a non-empty string.",
      data: t
    });
  if (r !== void 0 && !Array.isArray(r) && (typeof r != "object" || r === null))
    throw Sr.rpc.invalidParams({
      message: "'args.params' must be an object or array if provided.",
      data: t
    });
  switch (e) {
    case "eth_sign":
    case "eth_signTypedData_v2":
    case "eth_subscribe":
    case "eth_unsubscribe":
      throw Sr.provider.unsupportedMethod();
  }
}
const s6 = "accounts", o6 = "activeChain", a6 = "availableChains", c6 = "walletCapabilities";
class aY {
  constructor(e) {
    var r, n, i;
    this.metadata = e.metadata, this.communicator = e.communicator, this.callback = e.callback, this.keyManager = new rY(), this.storage = new to("CBWSDK", "SCWStateManager"), this.accounts = (r = this.storage.loadObject(s6)) !== null && r !== void 0 ? r : [], this.chain = this.storage.loadObject(o6) || {
      id: (i = (n = e.metadata.appChainIds) === null || n === void 0 ? void 0 : n[0]) !== null && i !== void 0 ? i : 1
    }, this.handshake = this.handshake.bind(this), this.request = this.request.bind(this), this.createRequestMessage = this.createRequestMessage.bind(this), this.decryptResponseMessage = this.decryptResponseMessage.bind(this);
  }
  async handshake(e) {
    var r, n;
    const i = await this.createRequestMessage({
      handshake: {
        method: e.method,
        params: Object.assign({}, this.metadata, (r = e.params) !== null && r !== void 0 ? r : {})
      }
    }), s = await this.communicator.postRequestAndWaitForResponse(i);
    if ("failure" in s.content)
      throw s.content.failure;
    const o = await BE("public", s.sender);
    await this.keyManager.setPeerPublicKey(o);
    const u = (await this.decryptResponseMessage(s)).result;
    if ("error" in u)
      throw u.error;
    const l = u.value;
    this.accounts = l, this.storage.storeObject(s6, l), (n = this.callback) === null || n === void 0 || n.call(this, "accountsChanged", l);
  }
  async request(e) {
    var r;
    if (this.accounts.length === 0)
      throw Sr.provider.unauthorized();
    switch (e.method) {
      case "eth_requestAccounts":
        return (r = this.callback) === null || r === void 0 || r.call(this, "connect", { chainId: ma(this.chain.id) }), this.accounts;
      case "eth_accounts":
        return this.accounts;
      case "eth_coinbase":
        return this.accounts[0];
      case "net_version":
        return this.chain.id;
      case "eth_chainId":
        return ma(this.chain.id);
      case "wallet_getCapabilities":
        return this.storage.loadObject(c6);
      case "wallet_switchEthereumChain":
        return this.handleSwitchChainRequest(e);
      case "eth_ecRecover":
      case "personal_sign":
      case "personal_ecRecover":
      case "eth_signTransaction":
      case "eth_sendTransaction":
      case "eth_signTypedData_v1":
      case "eth_signTypedData_v3":
      case "eth_signTypedData_v4":
      case "eth_signTypedData":
      case "wallet_addEthereumChain":
      case "wallet_watchAsset":
      case "wallet_sendCalls":
      case "wallet_showCallsStatus":
      case "wallet_grantPermissions":
        return this.sendRequestToPopup(e);
      default:
        if (!this.chain.rpcUrl)
          throw Sr.rpc.internal("No RPC URL set for chain");
        return jE(e, this.chain.rpcUrl);
    }
  }
  async sendRequestToPopup(e) {
    var r, n;
    await ((n = (r = this.communicator).waitForPopupLoaded) === null || n === void 0 ? void 0 : n.call(r));
    const i = await this.sendEncryptedRequest(e), o = (await this.decryptResponseMessage(i)).result;
    if ("error" in o)
      throw o.error;
    return o.value;
  }
  async cleanup() {
    var e, r;
    this.storage.clear(), await this.keyManager.clear(), this.accounts = [], this.chain = {
      id: (r = (e = this.metadata.appChainIds) === null || e === void 0 ? void 0 : e[0]) !== null && r !== void 0 ? r : 1
    };
  }
  /**
   * @returns `null` if the request was successful.
   * https://eips.ethereum.org/EIPS/eip-3326#wallet_switchethereumchain
   */
  async handleSwitchChainRequest(e) {
    var r;
    const n = e.params;
    if (!n || !(!((r = n[0]) === null || r === void 0) && r.chainId))
      throw Sr.rpc.invalidParams();
    const i = Kf(n[0].chainId);
    if (this.updateChain(i))
      return null;
    const o = await this.sendRequestToPopup(e);
    return o === null && this.updateChain(i), o;
  }
  async sendEncryptedRequest(e) {
    const r = await this.keyManager.getSharedSecret();
    if (!r)
      throw Sr.provider.unauthorized("No valid session found, try requestAccounts before other methods");
    const n = await eY({
      action: e,
      chainId: this.chain.id
    }, r), i = await this.createRequestMessage({ encrypted: n });
    return this.communicator.postRequestAndWaitForResponse(i);
  }
  async createRequestMessage(e) {
    const r = await $E("public", await this.keyManager.getOwnPublicKey());
    return {
      id: crypto.randomUUID(),
      sender: r,
      content: e,
      timestamp: /* @__PURE__ */ new Date()
    };
  }
  async decryptResponseMessage(e) {
    var r, n;
    const i = e.content;
    if ("failure" in i)
      throw i.failure;
    const s = await this.keyManager.getSharedSecret();
    if (!s)
      throw Sr.provider.unauthorized("Invalid session");
    const o = await tY(i.encrypted, s), a = (r = o.data) === null || r === void 0 ? void 0 : r.chains;
    if (a) {
      const l = Object.entries(a).map(([d, p]) => ({
        id: Number(d),
        rpcUrl: p
      }));
      this.storage.storeObject(a6, l), this.updateChain(this.chain.id, l);
    }
    const u = (n = o.data) === null || n === void 0 ? void 0 : n.capabilities;
    return u && this.storage.storeObject(c6, u), o;
  }
  updateChain(e, r) {
    var n;
    const i = r ?? this.storage.loadObject(a6), s = i == null ? void 0 : i.find((o) => o.id === e);
    return s ? (s !== this.chain && (this.chain = s, this.storage.storeObject(o6, s), (n = this.callback) === null || n === void 0 || n.call(this, "chainChanged", ma(s.id))), !0) : !1;
  }
}
const cY = /* @__PURE__ */ bv(jD), { keccak_256: uY } = cY;
function UE(t) {
  return Buffer.allocUnsafe(t).fill(0);
}
function fY(t) {
  return t.toString(2).length;
}
function qE(t, e) {
  let r = t.toString(16);
  r.length % 2 !== 0 && (r = "0" + r);
  const n = r.match(/.{1,2}/g).map((i) => parseInt(i, 16));
  for (; n.length < e; )
    n.unshift(0);
  return Buffer.from(n);
}
function lY(t, e) {
  const r = t < 0n;
  let n;
  if (r) {
    const i = (1n << BigInt(e)) - 1n;
    n = (~t & i) + 1n;
  } else
    n = t;
  return n &= (1n << BigInt(e)) - 1n, n;
}
function zE(t, e, r) {
  const n = UE(e);
  return t = cp(t), r ? t.length < e ? (t.copy(n), n) : t.slice(0, e) : t.length < e ? (t.copy(n, e - t.length), n) : t.slice(-e);
}
function hY(t, e) {
  return zE(t, e, !0);
}
function cp(t) {
  if (!Buffer.isBuffer(t))
    if (Array.isArray(t))
      t = Buffer.from(t);
    else if (typeof t == "string")
      WE(t) ? t = Buffer.from(gY(HE(t)), "hex") : t = Buffer.from(t);
    else if (typeof t == "number")
      t = intToBuffer(t);
    else if (t == null)
      t = Buffer.allocUnsafe(0);
    else if (typeof t == "bigint")
      t = qE(t);
    else if (t.toArray)
      t = Buffer.from(t.toArray());
    else
      throw new Error("invalid type");
  return t;
}
function dY(t) {
  return t = cp(t), "0x" + t.toString("hex");
}
function pY(t, e) {
  if (t = cp(t), e || (e = 256), e !== 256)
    throw new Error("unsupported");
  return Buffer.from(uY(new Uint8Array(t)));
}
function gY(t) {
  return t.length % 2 ? "0" + t : t;
}
function WE(t) {
  return typeof t == "string" && t.match(/^0x[0-9A-Fa-f]*$/);
}
function HE(t) {
  return typeof t == "string" && t.startsWith("0x") ? t.slice(2) : t;
}
var KE = {
  zeros: UE,
  setLength: zE,
  setLengthRight: hY,
  isHexString: WE,
  stripHexPrefix: HE,
  toBuffer: cp,
  bufferToHex: dY,
  keccak: pY,
  bitLengthFromBigInt: fY,
  bufferBEFromBigInt: qE,
  twosFromBigInt: lY
};
const ii = KE;
function VE(t) {
  return t.startsWith("int[") ? "int256" + t.slice(3) : t === "int" ? "int256" : t.startsWith("uint[") ? "uint256" + t.slice(4) : t === "uint" ? "uint256" : t.startsWith("fixed[") ? "fixed128x128" + t.slice(5) : t === "fixed" ? "fixed128x128" : t.startsWith("ufixed[") ? "ufixed128x128" + t.slice(6) : t === "ufixed" ? "ufixed128x128" : t;
}
function pu(t) {
  return Number.parseInt(/^\D+(\d+)$/.exec(t)[1], 10);
}
function u6(t) {
  var e = /^\D+(\d+)x(\d+)$/.exec(t);
  return [Number.parseInt(e[1], 10), Number.parseInt(e[2], 10)];
}
function GE(t) {
  var e = t.match(/(.*)\[(.*?)\]$/);
  return e ? e[2] === "" ? "dynamic" : Number.parseInt(e[2], 10) : null;
}
function tc(t) {
  var e = typeof t;
  if (e === "string" || e === "number")
    return BigInt(t);
  if (e === "bigint")
    return t;
  throw new Error("Argument is not a number");
}
function qs(t, e) {
  var r, n, i, s;
  if (t === "address")
    return qs("uint160", tc(e));
  if (t === "bool")
    return qs("uint8", e ? 1 : 0);
  if (t === "string")
    return qs("bytes", new Buffer(e, "utf8"));
  if (vY(t)) {
    if (typeof e.length > "u")
      throw new Error("Not an array?");
    if (r = GE(t), r !== "dynamic" && r !== 0 && e.length > r)
      throw new Error("Elements exceed array size: " + r);
    i = [], t = t.slice(0, t.lastIndexOf("[")), typeof e == "string" && (e = JSON.parse(e));
    for (s in e)
      i.push(qs(t, e[s]));
    if (r === "dynamic") {
      var o = qs("uint256", e.length);
      i.unshift(o);
    }
    return Buffer.concat(i);
  } else {
    if (t === "bytes")
      return e = new Buffer(e), i = Buffer.concat([qs("uint256", e.length), e]), e.length % 32 !== 0 && (i = Buffer.concat([i, ii.zeros(32 - e.length % 32)])), i;
    if (t.startsWith("bytes")) {
      if (r = pu(t), r < 1 || r > 32)
        throw new Error("Invalid bytes<N> width: " + r);
      return ii.setLengthRight(e, 32);
    } else if (t.startsWith("uint")) {
      if (r = pu(t), r % 8 || r < 8 || r > 256)
        throw new Error("Invalid uint<N> width: " + r);
      n = tc(e);
      const a = ii.bitLengthFromBigInt(n);
      if (a > r)
        throw new Error("Supplied uint exceeds width: " + r + " vs " + a);
      if (n < 0)
        throw new Error("Supplied uint is negative");
      return ii.bufferBEFromBigInt(n, 32);
    } else if (t.startsWith("int")) {
      if (r = pu(t), r % 8 || r < 8 || r > 256)
        throw new Error("Invalid int<N> width: " + r);
      n = tc(e);
      const a = ii.bitLengthFromBigInt(n);
      if (a > r)
        throw new Error("Supplied int exceeds width: " + r + " vs " + a);
      const u = ii.twosFromBigInt(n, 256);
      return ii.bufferBEFromBigInt(u, 32);
    } else if (t.startsWith("ufixed")) {
      if (r = u6(t), n = tc(e), n < 0)
        throw new Error("Supplied ufixed is negative");
      return qs("uint256", n * BigInt(2) ** BigInt(r[1]));
    } else if (t.startsWith("fixed"))
      return r = u6(t), qs("int256", tc(e) * BigInt(2) ** BigInt(r[1]));
  }
  throw new Error("Unsupported or invalid type: " + t);
}
function mY(t) {
  return t === "string" || t === "bytes" || GE(t) === "dynamic";
}
function vY(t) {
  return t.lastIndexOf("]") === t.length - 1;
}
function bY(t, e) {
  var r = [], n = [], i = 32 * t.length;
  for (var s in t) {
    var o = VE(t[s]), a = e[s], u = qs(o, a);
    mY(o) ? (r.push(qs("uint256", i)), n.push(u), i += u.length) : r.push(u);
  }
  return Buffer.concat(r.concat(n));
}
function YE(t, e) {
  if (t.length !== e.length)
    throw new Error("Number of types are not matching the values");
  for (var r, n, i = [], s = 0; s < t.length; s++) {
    var o = VE(t[s]), a = e[s];
    if (o === "bytes")
      i.push(a);
    else if (o === "string")
      i.push(new Buffer(a, "utf8"));
    else if (o === "bool")
      i.push(new Buffer(a ? "01" : "00", "hex"));
    else if (o === "address")
      i.push(ii.setLength(a, 20));
    else if (o.startsWith("bytes")) {
      if (r = pu(o), r < 1 || r > 32)
        throw new Error("Invalid bytes<N> width: " + r);
      i.push(ii.setLengthRight(a, r));
    } else if (o.startsWith("uint")) {
      if (r = pu(o), r % 8 || r < 8 || r > 256)
        throw new Error("Invalid uint<N> width: " + r);
      n = tc(a);
      const u = ii.bitLengthFromBigInt(n);
      if (u > r)
        throw new Error("Supplied uint exceeds width: " + r + " vs " + u);
      i.push(ii.bufferBEFromBigInt(n, r / 8));
    } else if (o.startsWith("int")) {
      if (r = pu(o), r % 8 || r < 8 || r > 256)
        throw new Error("Invalid int<N> width: " + r);
      n = tc(a);
      const u = ii.bitLengthFromBigInt(n);
      if (u > r)
        throw new Error("Supplied int exceeds width: " + r + " vs " + u);
      const l = ii.twosFromBigInt(n, r);
      i.push(ii.bufferBEFromBigInt(l, r / 8));
    } else
      throw new Error("Unsupported or invalid type: " + o);
  }
  return Buffer.concat(i);
}
function yY(t, e) {
  return ii.keccak(YE(t, e));
}
var wY = {
  rawEncode: bY,
  solidityPack: YE,
  soliditySHA3: yY
};
const ys = KE, Vf = wY, JE = {
  type: "object",
  properties: {
    types: {
      type: "object",
      additionalProperties: {
        type: "array",
        items: {
          type: "object",
          properties: {
            name: { type: "string" },
            type: { type: "string" }
          },
          required: ["name", "type"]
        }
      }
    },
    primaryType: { type: "string" },
    domain: { type: "object" },
    message: { type: "object" }
  },
  required: ["types", "primaryType", "domain", "message"]
}, Pm = {
  /**
   * Encodes an object by encoding and concatenating each of its members
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of an object
   */
  encodeData(t, e, r, n = !0) {
    const i = ["bytes32"], s = [this.hashType(t, r)];
    if (n) {
      const o = (a, u, l) => {
        if (r[u] !== void 0)
          return ["bytes32", l == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : ys.keccak(this.encodeData(u, l, r, n))];
        if (l === void 0)
          throw new Error(`missing value for field ${a} of type ${u}`);
        if (u === "bytes")
          return ["bytes32", ys.keccak(l)];
        if (u === "string")
          return typeof l == "string" && (l = Buffer.from(l, "utf8")), ["bytes32", ys.keccak(l)];
        if (u.lastIndexOf("]") === u.length - 1) {
          const d = u.slice(0, u.lastIndexOf("[")), p = l.map((w) => o(a, d, w));
          return ["bytes32", ys.keccak(Vf.rawEncode(
            p.map(([w]) => w),
            p.map(([, w]) => w)
          ))];
        }
        return [u, l];
      };
      for (const a of r[t]) {
        const [u, l] = o(a.name, a.type, e[a.name]);
        i.push(u), s.push(l);
      }
    } else
      for (const o of r[t]) {
        let a = e[o.name];
        if (a !== void 0)
          if (o.type === "bytes")
            i.push("bytes32"), a = ys.keccak(a), s.push(a);
          else if (o.type === "string")
            i.push("bytes32"), typeof a == "string" && (a = Buffer.from(a, "utf8")), a = ys.keccak(a), s.push(a);
          else if (r[o.type] !== void 0)
            i.push("bytes32"), a = ys.keccak(this.encodeData(o.type, a, r, n)), s.push(a);
          else {
            if (o.type.lastIndexOf("]") === o.type.length - 1)
              throw new Error("Arrays currently unimplemented in encodeData");
            i.push(o.type), s.push(a);
          }
      }
    return Vf.rawEncode(i, s);
  },
  /**
   * Encodes the type of an object by encoding a comma delimited list of its members
   *
   * @param {string} primaryType - Root type to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of the type of an object
   */
  encodeType(t, e) {
    let r = "", n = this.findTypeDependencies(t, e).filter((i) => i !== t);
    n = [t].concat(n.sort());
    for (const i of n) {
      if (!e[i])
        throw new Error("No type definition specified: " + i);
      r += i + "(" + e[i].map(({ name: o, type: a }) => a + " " + o).join(",") + ")";
    }
    return r;
  },
  /**
   * Finds all types within a type definition object
   *
   * @param {string} primaryType - Root type
   * @param {Object} types - Type definitions
   * @param {Array} results - current set of accumulated types
   * @returns {Array} - Set of all types found in the type definition
   */
  findTypeDependencies(t, e, r = []) {
    if (t = t.match(/^\w*/)[0], r.includes(t) || e[t] === void 0)
      return r;
    r.push(t);
    for (const n of e[t])
      for (const i of this.findTypeDependencies(n.type, e, r))
        !r.includes(i) && r.push(i);
    return r;
  },
  /**
   * Hashes an object
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to hash
   * @param {Object} types - Type definitions
   * @returns {Buffer} - Hash of an object
   */
  hashStruct(t, e, r, n = !0) {
    return ys.keccak(this.encodeData(t, e, r, n));
  },
  /**
   * Hashes the type of an object
   *
   * @param {string} primaryType - Root type to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashType(t, e) {
    return ys.keccak(this.encodeType(t, e));
  },
  /**
   * Removes properties from a message object that are not defined per EIP-712
   *
   * @param {Object} data - typed message object
   * @returns {Object} - typed message object with only allowed fields
   */
  sanitizeData(t) {
    const e = {};
    for (const r in JE.properties)
      t[r] && (e[r] = t[r]);
    return e.types && (e.types = Object.assign({ EIP712Domain: [] }, e.types)), e;
  },
  /**
   * Returns the hash of a typed message as per EIP-712 for signing
   *
   * @param {Object} typedData - Types message data to sign
   * @returns {string} - sha3 hash for signing
   */
  hash(t, e = !0) {
    const r = this.sanitizeData(t), n = [Buffer.from("1901", "hex")];
    return n.push(this.hashStruct("EIP712Domain", r.domain, r.types, e)), r.primaryType !== "EIP712Domain" && n.push(this.hashStruct(r.primaryType, r.message, r.types, e)), ys.keccak(Buffer.concat(n));
  }
};
var xY = {
  TYPED_MESSAGE_SCHEMA: JE,
  TypedDataUtils: Pm,
  hashForSignTypedDataLegacy: function(t) {
    return _Y(t.data);
  },
  hashForSignTypedData_v3: function(t) {
    return Pm.hash(t.data, !1);
  },
  hashForSignTypedData_v4: function(t) {
    return Pm.hash(t.data);
  }
};
function _Y(t) {
  const e = new Error("Expect argument to be non-empty array");
  if (typeof t != "object" || !t.length) throw e;
  const r = t.map(function(s) {
    return s.type === "bytes" ? ys.toBuffer(s.value) : s.value;
  }), n = t.map(function(s) {
    return s.type;
  }), i = t.map(function(s) {
    if (!s.name) throw e;
    return s.type + " " + s.name;
  });
  return Vf.soliditySHA3(
    ["bytes32", "bytes32"],
    [
      Vf.soliditySHA3(new Array(t.length).fill("string"), i),
      Vf.soliditySHA3(n, r)
    ]
  );
}
const dd = /* @__PURE__ */ rs(xY), EY = "walletUsername", $1 = "Addresses", SY = "AppVersion";
function jn(t) {
  return t.errorMessage !== void 0;
}
class AY {
  // @param secret hex representation of 32-byte secret
  constructor(e) {
    this.secret = e;
  }
  /**
   *
   * @param plainText string to be encrypted
   * returns hex string representation of bytes in the order: initialization vector (iv),
   * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the
   * encrypted plainText.
   */
  async encrypt(e) {
    const r = this.secret;
    if (r.length !== 64)
      throw Error("secret must be 256 bits");
    const n = crypto.getRandomValues(new Uint8Array(12)), i = await crypto.subtle.importKey("raw", Dd(r), { name: "aes-gcm" }, !1, ["encrypt", "decrypt"]), s = new TextEncoder(), o = await window.crypto.subtle.encrypt({
      name: "AES-GCM",
      iv: n
    }, i, s.encode(e)), a = 16, u = o.slice(o.byteLength - a), l = o.slice(0, o.byteLength - a), d = new Uint8Array(u), p = new Uint8Array(l), w = new Uint8Array([...n, ...d, ...p]);
    return mb(w);
  }
  /**
   *
   * @param cipherText hex string representation of bytes in the order: initialization vector (iv),
   * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.
   */
  async decrypt(e) {
    const r = this.secret;
    if (r.length !== 64)
      throw Error("secret must be 256 bits");
    return new Promise((n, i) => {
      (async function() {
        const s = await crypto.subtle.importKey("raw", Dd(r), { name: "aes-gcm" }, !1, ["encrypt", "decrypt"]), o = Dd(e), a = o.slice(0, 12), u = o.slice(12, 28), l = o.slice(28), d = new Uint8Array([...l, ...u]), p = {
          name: "AES-GCM",
          iv: new Uint8Array(a)
        };
        try {
          const w = await window.crypto.subtle.decrypt(p, s, d), A = new TextDecoder();
          n(A.decode(w));
        } catch (w) {
          i(w);
        }
      })();
    });
  }
}
class PY {
  constructor(e, r, n) {
    this.linkAPIUrl = e, this.sessionId = r;
    const i = `${r}:${n}`;
    this.auth = `Basic ${btoa(i)}`;
  }
  // mark unseen events as seen
  async markUnseenEventsAsSeen(e) {
    return Promise.all(e.map((r) => fetch(`${this.linkAPIUrl}/events/${r.eventId}/seen`, {
      method: "POST",
      headers: {
        Authorization: this.auth
      }
    }))).catch((r) => console.error("Unabled to mark event as failed:", r));
  }
  async fetchUnseenEvents() {
    var e;
    const r = await fetch(`${this.linkAPIUrl}/events?unseen=true`, {
      headers: {
        Authorization: this.auth
      }
    });
    if (r.ok) {
      const { events: n, error: i } = await r.json();
      if (i)
        throw new Error(`Check unseen events failed: ${i}`);
      const s = (e = n == null ? void 0 : n.filter((o) => o.event === "Web3Response").map((o) => ({
        type: "Event",
        sessionId: this.sessionId,
        eventId: o.id,
        event: o.event,
        data: o.data
      }))) !== null && e !== void 0 ? e : [];
      return this.markUnseenEventsAsSeen(s), s;
    }
    throw new Error(`Check unseen events failed: ${r.status}`);
  }
}
var Io;
(function(t) {
  t[t.DISCONNECTED = 0] = "DISCONNECTED", t[t.CONNECTING = 1] = "CONNECTING", t[t.CONNECTED = 2] = "CONNECTED";
})(Io || (Io = {}));
class MY {
  setConnectionStateListener(e) {
    this.connectionStateListener = e;
  }
  setIncomingDataListener(e) {
    this.incomingDataListener = e;
  }
  /**
   * Constructor
   * @param url WebSocket server URL
   * @param [WebSocketClass] Custom WebSocket implementation
   */
  constructor(e, r = WebSocket) {
    this.WebSocketClass = r, this.webSocket = null, this.pendingData = [], this.url = e.replace(/^http/, "ws");
  }
  /**
   * Make a websocket connection
   * @returns a Promise that resolves when connected
   */
  async connect() {
    if (this.webSocket)
      throw new Error("webSocket object is not null");
    return new Promise((e, r) => {
      var n;
      let i;
      try {
        this.webSocket = i = new this.WebSocketClass(this.url);
      } catch (s) {
        r(s);
        return;
      }
      (n = this.connectionStateListener) === null || n === void 0 || n.call(this, Io.CONNECTING), i.onclose = (s) => {
        var o;
        this.clearWebSocket(), r(new Error(`websocket error ${s.code}: ${s.reason}`)), (o = this.connectionStateListener) === null || o === void 0 || o.call(this, Io.DISCONNECTED);
      }, i.onopen = (s) => {
        var o;
        e(), (o = this.connectionStateListener) === null || o === void 0 || o.call(this, Io.CONNECTED), this.pendingData.length > 0 && ([...this.pendingData].forEach((u) => this.sendData(u)), this.pendingData = []);
      }, i.onmessage = (s) => {
        var o, a;
        if (s.data === "h")
          (o = this.incomingDataListener) === null || o === void 0 || o.call(this, {
            type: "Heartbeat"
          });
        else
          try {
            const u = JSON.parse(s.data);
            (a = this.incomingDataListener) === null || a === void 0 || a.call(this, u);
          } catch {
          }
      };
    });
  }
  /**
   * Disconnect from server
   */
  disconnect() {
    var e;
    const { webSocket: r } = this;
    if (r) {
      this.clearWebSocket(), (e = this.connectionStateListener) === null || e === void 0 || e.call(this, Io.DISCONNECTED), this.connectionStateListener = void 0, this.incomingDataListener = void 0;
      try {
        r.close();
      } catch {
      }
    }
  }
  /**
   * Send data to server
   * @param data text to send
   */
  sendData(e) {
    const { webSocket: r } = this;
    if (!r) {
      this.pendingData.push(e), this.connect();
      return;
    }
    r.send(e);
  }
  clearWebSocket() {
    const { webSocket: e } = this;
    e && (this.webSocket = null, e.onclose = null, e.onerror = null, e.onmessage = null, e.onopen = null);
  }
}
const f6 = 1e4, IY = 6e4;
class CY {
  /**
   * Constructor
   * @param session Session
   * @param linkAPIUrl Coinbase Wallet link server URL
   * @param listener WalletLinkConnectionUpdateListener
   * @param [WebSocketClass] Custom WebSocket implementation
   */
  constructor({ session: e, linkAPIUrl: r, listener: n }) {
    this.destroyed = !1, this.lastHeartbeatResponse = 0, this.nextReqId = So(1), this._connected = !1, this._linked = !1, this.shouldFetchUnseenEventsOnConnect = !1, this.requestResolutions = /* @__PURE__ */ new Map(), this.handleSessionMetadataUpdated = (s) => {
      if (!s)
        return;
      (/* @__PURE__ */ new Map([
        ["__destroyed", this.handleDestroyed],
        ["EthereumAddress", this.handleAccountUpdated],
        ["WalletUsername", this.handleWalletUsernameUpdated],
        ["AppVersion", this.handleAppVersionUpdated],
        [
          "ChainId",
          // ChainId and JsonRpcUrl are always updated together
          (a) => s.JsonRpcUrl && this.handleChainUpdated(a, s.JsonRpcUrl)
        ]
      ])).forEach((a, u) => {
        const l = s[u];
        l !== void 0 && a(l);
      });
    }, this.handleDestroyed = (s) => {
      var o;
      s === "1" && ((o = this.listener) === null || o === void 0 || o.resetAndReload());
    }, this.handleAccountUpdated = async (s) => {
      var o;
      const a = await this.cipher.decrypt(s);
      (o = this.listener) === null || o === void 0 || o.accountUpdated(a);
    }, this.handleMetadataUpdated = async (s, o) => {
      var a;
      const u = await this.cipher.decrypt(o);
      (a = this.listener) === null || a === void 0 || a.metadataUpdated(s, u);
    }, this.handleWalletUsernameUpdated = async (s) => {
      this.handleMetadataUpdated(EY, s);
    }, this.handleAppVersionUpdated = async (s) => {
      this.handleMetadataUpdated(SY, s);
    }, this.handleChainUpdated = async (s, o) => {
      var a;
      const u = await this.cipher.decrypt(s), l = await this.cipher.decrypt(o);
      (a = this.listener) === null || a === void 0 || a.chainUpdated(u, l);
    }, this.session = e, this.cipher = new AY(e.secret), this.listener = n;
    const i = new MY(`${r}/rpc`, WebSocket);
    i.setConnectionStateListener(async (s) => {
      let o = !1;
      switch (s) {
        case Io.DISCONNECTED:
          if (!this.destroyed) {
            const a = async () => {
              await new Promise((u) => setTimeout(u, 5e3)), this.destroyed || i.connect().catch(() => {
                a();
              });
            };
            a();
          }
          break;
        case Io.CONNECTED:
          o = await this.handleConnected(), this.updateLastHeartbeat(), setInterval(() => {
            this.heartbeat();
          }, f6), this.shouldFetchUnseenEventsOnConnect && this.fetchUnseenEventsAPI();
          break;
        case Io.CONNECTING:
          break;
      }
      this.connected !== o && (this.connected = o);
    }), i.setIncomingDataListener((s) => {
      var o;
      switch (s.type) {
        case "Heartbeat":
          this.updateLastHeartbeat();
          return;
        case "IsLinkedOK":
        case "Linked": {
          const a = s.type === "IsLinkedOK" ? s.linked : void 0;
          this.linked = a || s.onlineGuests > 0;
          break;
        }
        case "GetSessionConfigOK":
        case "SessionConfigUpdated": {
          this.handleSessionMetadataUpdated(s.metadata);
          break;
        }
        case "Event": {
          this.handleIncomingEvent(s);
          break;
        }
      }
      s.id !== void 0 && ((o = this.requestResolutions.get(s.id)) === null || o === void 0 || o(s));
    }), this.ws = i, this.http = new PY(r, e.id, e.key);
  }
  /**
   * Make a connection to the server
   */
  connect() {
    if (this.destroyed)
      throw new Error("instance is destroyed");
    this.ws.connect();
  }
  /**
   * Terminate connection, and mark as destroyed. To reconnect, create a new
   * instance of WalletSDKConnection
   */
  async destroy() {
    this.destroyed || (await this.makeRequest({
      type: "SetSessionConfig",
      id: So(this.nextReqId++),
      sessionId: this.session.id,
      metadata: { __destroyed: "1" }
    }, { timeout: 1e3 }), this.destroyed = !0, this.ws.disconnect(), this.listener = void 0);
  }
  get connected() {
    return this._connected;
  }
  set connected(e) {
    this._connected = e;
  }
  get linked() {
    return this._linked;
  }
  set linked(e) {
    var r, n;
    this._linked = e, e && ((r = this.onceLinked) === null || r === void 0 || r.call(this)), (n = this.listener) === null || n === void 0 || n.linkedUpdated(e);
  }
  setOnceLinked(e) {
    return new Promise((r) => {
      this.linked ? e().then(r) : this.onceLinked = () => {
        e().then(r), this.onceLinked = void 0;
      };
    });
  }
  async handleIncomingEvent(e) {
    var r;
    if (e.type !== "Event" || e.event !== "Web3Response")
      return;
    const n = await this.cipher.decrypt(e.data), i = JSON.parse(n);
    if (i.type !== "WEB3_RESPONSE")
      return;
    const { id: s, response: o } = i;
    (r = this.listener) === null || r === void 0 || r.handleWeb3ResponseMessage(s, o);
  }
  async checkUnseenEvents() {
    if (!this.connected) {
      this.shouldFetchUnseenEventsOnConnect = !0;
      return;
    }
    await new Promise((e) => setTimeout(e, 250));
    try {
      await this.fetchUnseenEventsAPI();
    } catch (e) {
      console.error("Unable to check for unseen events", e);
    }
  }
  async fetchUnseenEventsAPI() {
    this.shouldFetchUnseenEventsOnConnect = !1, (await this.http.fetchUnseenEvents()).forEach((r) => this.handleIncomingEvent(r));
  }
  /**
   * Publish an event and emit event ID when successful
   * @param event event name
   * @param unencryptedData unencrypted event data
   * @param callWebhook whether the webhook should be invoked
   * @returns a Promise that emits event ID when successful
   */
  async publishEvent(e, r, n = !1) {
    const i = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, r), { origin: location.origin, location: location.href, relaySource: "coinbaseWalletExtension" in window && window.coinbaseWalletExtension ? "injected_sdk" : "sdk" }))), s = {
      type: "PublishEvent",
      id: So(this.nextReqId++),
      sessionId: this.session.id,
      event: e,
      data: i,
      callWebhook: n
    };
    return this.setOnceLinked(async () => {
      const o = await this.makeRequest(s);
      if (o.type === "Fail")
        throw new Error(o.error || "failed to publish event");
      return o.eventId;
    });
  }
  sendData(e) {
    this.ws.sendData(JSON.stringify(e));
  }
  updateLastHeartbeat() {
    this.lastHeartbeatResponse = Date.now();
  }
  heartbeat() {
    if (Date.now() - this.lastHeartbeatResponse > f6 * 2) {
      this.ws.disconnect();
      return;
    }
    try {
      this.ws.sendData("h");
    } catch {
    }
  }
  async makeRequest(e, r = { timeout: IY }) {
    const n = e.id;
    this.sendData(e);
    let i;
    return Promise.race([
      new Promise((s, o) => {
        i = window.setTimeout(() => {
          o(new Error(`request ${n} timed out`));
        }, r.timeout);
      }),
      new Promise((s) => {
        this.requestResolutions.set(n, (o) => {
          clearTimeout(i), s(o), this.requestResolutions.delete(n);
        });
      })
    ]);
  }
  async handleConnected() {
    return (await this.makeRequest({
      type: "HostSession",
      id: So(this.nextReqId++),
      sessionId: this.session.id,
      sessionKey: this.session.key
    })).type === "Fail" ? !1 : (this.sendData({
      type: "IsLinked",
      id: So(this.nextReqId++),
      sessionId: this.session.id
    }), this.sendData({
      type: "GetSessionConfig",
      id: So(this.nextReqId++),
      sessionId: this.session.id
    }), !0);
  }
}
class TY {
  constructor() {
    this._nextRequestId = 0, this.callbacks = /* @__PURE__ */ new Map();
  }
  makeRequestId() {
    this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
    const e = this._nextRequestId, r = LE(e.toString(16));
    return this.callbacks.get(r) && this.callbacks.delete(r), e;
  }
}
const l6 = "session:id", h6 = "session:secret", d6 = "session:linked";
class gu {
  constructor(e, r, n, i = !1) {
    this.storage = e, this.id = r, this.secret = n, this.key = xD(i4(`${r}, ${n} WalletLink`)), this._linked = !!i;
  }
  static create(e) {
    const r = ec(16), n = ec(32);
    return new gu(e, r, n).save();
  }
  static load(e) {
    const r = e.getItem(l6), n = e.getItem(d6), i = e.getItem(h6);
    return r && i ? new gu(e, r, i, n === "1") : null;
  }
  get linked() {
    return this._linked;
  }
  set linked(e) {
    this._linked = e, this.persistLinked();
  }
  save() {
    return this.storage.setItem(l6, this.id), this.storage.setItem(h6, this.secret), this.persistLinked(), this;
  }
  persistLinked() {
    this.storage.setItem(d6, this._linked ? "1" : "0");
  }
}
function RY() {
  try {
    return window.frameElement !== null;
  } catch {
    return !1;
  }
}
function DY() {
  try {
    return RY() && window.top ? window.top.location : window.location;
  } catch {
    return window.location;
  }
}
function OY() {
  var t;
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test((t = window == null ? void 0 : window.navigator) === null || t === void 0 ? void 0 : t.userAgent);
}
function XE() {
  var t, e;
  return (e = (t = window == null ? void 0 : window.matchMedia) === null || t === void 0 ? void 0 : t.call(window, "(prefers-color-scheme: dark)").matches) !== null && e !== void 0 ? e : !1;
}
const NY = '@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}';
function ZE() {
  const t = document.createElement("style");
  t.type = "text/css", t.appendChild(document.createTextNode(NY)), document.documentElement.appendChild(t);
}
function QE(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number") n += t;
  else if (typeof t == "object") if (Array.isArray(t)) for (e = 0; e < t.length; e++) t[e] && (r = QE(t[e])) && (n && (n += " "), n += r);
  else for (e in t) t[e] && (n && (n += " "), n += e);
  return n;
}
function Gf() {
  for (var t, e, r = 0, n = ""; r < arguments.length; ) (t = arguments[r++]) && (e = QE(t)) && (n && (n += " "), n += e);
  return n;
}
var up, Jr, eS, rc, p6, tS, B1, rS, yb, F1, j1, Pl = {}, nS = [], LY = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, wb = Array.isArray;
function va(t, e) {
  for (var r in e) t[r] = e[r];
  return t;
}
function xb(t) {
  t && t.parentNode && t.parentNode.removeChild(t);
}
function Nr(t, e, r) {
  var n, i, s, o = {};
  for (s in e) s == "key" ? n = e[s] : s == "ref" ? i = e[s] : o[s] = e[s];
  if (arguments.length > 2 && (o.children = arguments.length > 3 ? up.call(arguments, 2) : r), typeof t == "function" && t.defaultProps != null) for (s in t.defaultProps) o[s] === void 0 && (o[s] = t.defaultProps[s]);
  return Od(t, o, n, i, null);
}
function Od(t, e, r, n, i) {
  var s = { type: t, props: e, key: r, ref: n, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: i ?? ++eS, __i: -1, __u: 0 };
  return i == null && Jr.vnode != null && Jr.vnode(s), s;
}
function ih(t) {
  return t.children;
}
function Nd(t, e) {
  this.props = t, this.context = e;
}
function Pu(t, e) {
  if (e == null) return t.__ ? Pu(t.__, t.__i + 1) : null;
  for (var r; e < t.__k.length; e++) if ((r = t.__k[e]) != null && r.__e != null) return r.__e;
  return typeof t.type == "function" ? Pu(t) : null;
}
function iS(t) {
  var e, r;
  if ((t = t.__) != null && t.__c != null) {
    for (t.__e = t.__c.base = null, e = 0; e < t.__k.length; e++) if ((r = t.__k[e]) != null && r.__e != null) {
      t.__e = t.__c.base = r.__e;
      break;
    }
    return iS(t);
  }
}
function g6(t) {
  (!t.__d && (t.__d = !0) && rc.push(t) && !d0.__r++ || p6 !== Jr.debounceRendering) && ((p6 = Jr.debounceRendering) || tS)(d0);
}
function d0() {
  var t, e, r, n, i, s, o, a;
  for (rc.sort(B1); t = rc.shift(); ) t.__d && (e = rc.length, n = void 0, s = (i = (r = t).__v).__e, o = [], a = [], r.__P && ((n = va({}, i)).__v = i.__v + 1, Jr.vnode && Jr.vnode(n), _b(r.__P, n, i, r.__n, r.__P.namespaceURI, 32 & i.__u ? [s] : null, o, s ?? Pu(i), !!(32 & i.__u), a), n.__v = i.__v, n.__.__k[n.__i] = n, aS(o, n, a), n.__e != s && iS(n)), rc.length > e && rc.sort(B1));
  d0.__r = 0;
}
function sS(t, e, r, n, i, s, o, a, u, l, d) {
  var p, w, A, P, N, L, $ = n && n.__k || nS, B = e.length;
  for (u = kY(r, e, $, u), p = 0; p < B; p++) (A = r.__k[p]) != null && (w = A.__i === -1 ? Pl : $[A.__i] || Pl, A.__i = p, L = _b(t, A, w, i, s, o, a, u, l, d), P = A.__e, A.ref && w.ref != A.ref && (w.ref && Eb(w.ref, null, A), d.push(A.ref, A.__c || P, A)), N == null && P != null && (N = P), 4 & A.__u || w.__k === A.__k ? u = oS(A, u, t) : typeof A.type == "function" && L !== void 0 ? u = L : P && (u = P.nextSibling), A.__u &= -7);
  return r.__e = N, u;
}
function kY(t, e, r, n) {
  var i, s, o, a, u, l = e.length, d = r.length, p = d, w = 0;
  for (t.__k = [], i = 0; i < l; i++) (s = e[i]) != null && typeof s != "boolean" && typeof s != "function" ? (a = i + w, (s = t.__k[i] = typeof s == "string" || typeof s == "number" || typeof s == "bigint" || s.constructor == String ? Od(null, s, null, null, null) : wb(s) ? Od(ih, { children: s }, null, null, null) : s.constructor === void 0 && s.__b > 0 ? Od(s.type, s.props, s.key, s.ref ? s.ref : null, s.__v) : s).__ = t, s.__b = t.__b + 1, o = null, (u = s.__i = $Y(s, r, a, p)) !== -1 && (p--, (o = r[u]) && (o.__u |= 2)), o == null || o.__v === null ? (u == -1 && w--, typeof s.type != "function" && (s.__u |= 4)) : u !== a && (u == a - 1 ? w-- : u == a + 1 ? w++ : (u > a ? w-- : w++, s.__u |= 4))) : s = t.__k[i] = null;
  if (p) for (i = 0; i < d; i++) (o = r[i]) != null && !(2 & o.__u) && (o.__e == n && (n = Pu(o)), cS(o, o));
  return n;
}
function oS(t, e, r) {
  var n, i;
  if (typeof t.type == "function") {
    for (n = t.__k, i = 0; n && i < n.length; i++) n[i] && (n[i].__ = t, e = oS(n[i], e, r));
    return e;
  }
  t.__e != e && (e && t.type && !r.contains(e) && (e = Pu(t)), r.insertBefore(t.__e, e || null), e = t.__e);
  do
    e = e && e.nextSibling;
  while (e != null && e.nodeType === 8);
  return e;
}
function $Y(t, e, r, n) {
  var i = t.key, s = t.type, o = r - 1, a = r + 1, u = e[r];
  if (u === null || u && i == u.key && s === u.type && !(2 & u.__u)) return r;
  if ((typeof s != "function" || s === ih || i) && n > (u != null && !(2 & u.__u) ? 1 : 0)) for (; o >= 0 || a < e.length; ) {
    if (o >= 0) {
      if ((u = e[o]) && !(2 & u.__u) && i == u.key && s === u.type) return o;
      o--;
    }
    if (a < e.length) {
      if ((u = e[a]) && !(2 & u.__u) && i == u.key && s === u.type) return a;
      a++;
    }
  }
  return -1;
}
function m6(t, e, r) {
  e[0] === "-" ? t.setProperty(e, r ?? "") : t[e] = r == null ? "" : typeof r != "number" || LY.test(e) ? r : r + "px";
}
function pd(t, e, r, n, i) {
  var s;
  e: if (e === "style") if (typeof r == "string") t.style.cssText = r;
  else {
    if (typeof n == "string" && (t.style.cssText = n = ""), n) for (e in n) r && e in r || m6(t.style, e, "");
    if (r) for (e in r) n && r[e] === n[e] || m6(t.style, e, r[e]);
  }
  else if (e[0] === "o" && e[1] === "n") s = e !== (e = e.replace(rS, "$1")), e = e.toLowerCase() in t || e === "onFocusOut" || e === "onFocusIn" ? e.toLowerCase().slice(2) : e.slice(2), t.l || (t.l = {}), t.l[e + s] = r, r ? n ? r.u = n.u : (r.u = yb, t.addEventListener(e, s ? j1 : F1, s)) : t.removeEventListener(e, s ? j1 : F1, s);
  else {
    if (i == "http://www.w3.org/2000/svg") e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if (e != "width" && e != "height" && e != "href" && e != "list" && e != "form" && e != "tabIndex" && e != "download" && e != "rowSpan" && e != "colSpan" && e != "role" && e != "popover" && e in t) try {
      t[e] = r ?? "";
      break e;
    } catch {
    }
    typeof r == "function" || (r == null || r === !1 && e[4] !== "-" ? t.removeAttribute(e) : t.setAttribute(e, e == "popover" && r == 1 ? "" : r));
  }
}
function v6(t) {
  return function(e) {
    if (this.l) {
      var r = this.l[e.type + t];
      if (e.t == null) e.t = yb++;
      else if (e.t < r.u) return;
      return r(Jr.event ? Jr.event(e) : e);
    }
  };
}
function _b(t, e, r, n, i, s, o, a, u, l) {
  var d, p, w, A, P, N, L, $, B, H, W, V, te, R, K, ge, Ee, Y = e.type;
  if (e.constructor !== void 0) return null;
  128 & r.__u && (u = !!(32 & r.__u), s = [a = e.__e = r.__e]), (d = Jr.__b) && d(e);
  e: if (typeof Y == "function") try {
    if ($ = e.props, B = "prototype" in Y && Y.prototype.render, H = (d = Y.contextType) && n[d.__c], W = d ? H ? H.props.value : d.__ : n, r.__c ? L = (p = e.__c = r.__c).__ = p.__E : (B ? e.__c = p = new Y($, W) : (e.__c = p = new Nd($, W), p.constructor = Y, p.render = FY), H && H.sub(p), p.props = $, p.state || (p.state = {}), p.context = W, p.__n = n, w = p.__d = !0, p.__h = [], p._sb = []), B && p.__s == null && (p.__s = p.state), B && Y.getDerivedStateFromProps != null && (p.__s == p.state && (p.__s = va({}, p.__s)), va(p.__s, Y.getDerivedStateFromProps($, p.__s))), A = p.props, P = p.state, p.__v = e, w) B && Y.getDerivedStateFromProps == null && p.componentWillMount != null && p.componentWillMount(), B && p.componentDidMount != null && p.__h.push(p.componentDidMount);
    else {
      if (B && Y.getDerivedStateFromProps == null && $ !== A && p.componentWillReceiveProps != null && p.componentWillReceiveProps($, W), !p.__e && (p.shouldComponentUpdate != null && p.shouldComponentUpdate($, p.__s, W) === !1 || e.__v === r.__v)) {
        for (e.__v !== r.__v && (p.props = $, p.state = p.__s, p.__d = !1), e.__e = r.__e, e.__k = r.__k, e.__k.some(function(S) {
          S && (S.__ = e);
        }), V = 0; V < p._sb.length; V++) p.__h.push(p._sb[V]);
        p._sb = [], p.__h.length && o.push(p);
        break e;
      }
      p.componentWillUpdate != null && p.componentWillUpdate($, p.__s, W), B && p.componentDidUpdate != null && p.__h.push(function() {
        p.componentDidUpdate(A, P, N);
      });
    }
    if (p.context = W, p.props = $, p.__P = t, p.__e = !1, te = Jr.__r, R = 0, B) {
      for (p.state = p.__s, p.__d = !1, te && te(e), d = p.render(p.props, p.state, p.context), K = 0; K < p._sb.length; K++) p.__h.push(p._sb[K]);
      p._sb = [];
    } else do
      p.__d = !1, te && te(e), d = p.render(p.props, p.state, p.context), p.state = p.__s;
    while (p.__d && ++R < 25);
    p.state = p.__s, p.getChildContext != null && (n = va(va({}, n), p.getChildContext())), B && !w && p.getSnapshotBeforeUpdate != null && (N = p.getSnapshotBeforeUpdate(A, P)), a = sS(t, wb(ge = d != null && d.type === ih && d.key == null ? d.props.children : d) ? ge : [ge], e, r, n, i, s, o, a, u, l), p.base = e.__e, e.__u &= -161, p.__h.length && o.push(p), L && (p.__E = p.__ = null);
  } catch (S) {
    if (e.__v = null, u || s != null) if (S.then) {
      for (e.__u |= u ? 160 : 128; a && a.nodeType === 8 && a.nextSibling; ) a = a.nextSibling;
      s[s.indexOf(a)] = null, e.__e = a;
    } else for (Ee = s.length; Ee--; ) xb(s[Ee]);
    else e.__e = r.__e, e.__k = r.__k;
    Jr.__e(S, e, r);
  }
  else s == null && e.__v === r.__v ? (e.__k = r.__k, e.__e = r.__e) : a = e.__e = BY(r.__e, e, r, n, i, s, o, u, l);
  return (d = Jr.diffed) && d(e), 128 & e.__u ? void 0 : a;
}
function aS(t, e, r) {
  for (var n = 0; n < r.length; n++) Eb(r[n], r[++n], r[++n]);
  Jr.__c && Jr.__c(e, t), t.some(function(i) {
    try {
      t = i.__h, i.__h = [], t.some(function(s) {
        s.call(i);
      });
    } catch (s) {
      Jr.__e(s, i.__v);
    }
  });
}
function BY(t, e, r, n, i, s, o, a, u) {
  var l, d, p, w, A, P, N, L = r.props, $ = e.props, B = e.type;
  if (B === "svg" ? i = "http://www.w3.org/2000/svg" : B === "math" ? i = "http://www.w3.org/1998/Math/MathML" : i || (i = "http://www.w3.org/1999/xhtml"), s != null) {
    for (l = 0; l < s.length; l++) if ((A = s[l]) && "setAttribute" in A == !!B && (B ? A.localName === B : A.nodeType === 3)) {
      t = A, s[l] = null;
      break;
    }
  }
  if (t == null) {
    if (B === null) return document.createTextNode($);
    t = document.createElementNS(i, B, $.is && $), a && (Jr.__m && Jr.__m(e, s), a = !1), s = null;
  }
  if (B === null) L === $ || a && t.data === $ || (t.data = $);
  else {
    if (s = s && up.call(t.childNodes), L = r.props || Pl, !a && s != null) for (L = {}, l = 0; l < t.attributes.length; l++) L[(A = t.attributes[l]).name] = A.value;
    for (l in L) if (A = L[l], l != "children") {
      if (l == "dangerouslySetInnerHTML") p = A;
      else if (!(l in $)) {
        if (l == "value" && "defaultValue" in $ || l == "checked" && "defaultChecked" in $) continue;
        pd(t, l, null, A, i);
      }
    }
    for (l in $) A = $[l], l == "children" ? w = A : l == "dangerouslySetInnerHTML" ? d = A : l == "value" ? P = A : l == "checked" ? N = A : a && typeof A != "function" || L[l] === A || pd(t, l, A, L[l], i);
    if (d) a || p && (d.__html === p.__html || d.__html === t.innerHTML) || (t.innerHTML = d.__html), e.__k = [];
    else if (p && (t.innerHTML = ""), sS(t, wb(w) ? w : [w], e, r, n, B === "foreignObject" ? "http://www.w3.org/1999/xhtml" : i, s, o, s ? s[0] : r.__k && Pu(r, 0), a, u), s != null) for (l = s.length; l--; ) xb(s[l]);
    a || (l = "value", B === "progress" && P == null ? t.removeAttribute("value") : P !== void 0 && (P !== t[l] || B === "progress" && !P || B === "option" && P !== L[l]) && pd(t, l, P, L[l], i), l = "checked", N !== void 0 && N !== t[l] && pd(t, l, N, L[l], i));
  }
  return t;
}
function Eb(t, e, r) {
  try {
    if (typeof t == "function") {
      var n = typeof t.__u == "function";
      n && t.__u(), n && e == null || (t.__u = t(e));
    } else t.current = e;
  } catch (i) {
    Jr.__e(i, r);
  }
}
function cS(t, e, r) {
  var n, i;
  if (Jr.unmount && Jr.unmount(t), (n = t.ref) && (n.current && n.current !== t.__e || Eb(n, null, e)), (n = t.__c) != null) {
    if (n.componentWillUnmount) try {
      n.componentWillUnmount();
    } catch (s) {
      Jr.__e(s, e);
    }
    n.base = n.__P = null;
  }
  if (n = t.__k) for (i = 0; i < n.length; i++) n[i] && cS(n[i], e, r || typeof t.type != "function");
  r || xb(t.__e), t.__c = t.__ = t.__e = void 0;
}
function FY(t, e, r) {
  return this.constructor(t, r);
}
function U1(t, e, r) {
  var n, i, s, o;
  e === document && (e = document.documentElement), Jr.__ && Jr.__(t, e), i = (n = typeof r == "function") ? null : e.__k, s = [], o = [], _b(e, t = (!n && r || e).__k = Nr(ih, null, [t]), i || Pl, Pl, e.namespaceURI, !n && r ? [r] : i ? null : e.firstChild ? up.call(e.childNodes) : null, s, !n && r ? r : i ? i.__e : e.firstChild, n, o), aS(s, t, o);
}
up = nS.slice, Jr = { __e: function(t, e, r, n) {
  for (var i, s, o; e = e.__; ) if ((i = e.__c) && !i.__) try {
    if ((s = i.constructor) && s.getDerivedStateFromError != null && (i.setState(s.getDerivedStateFromError(t)), o = i.__d), i.componentDidCatch != null && (i.componentDidCatch(t, n || {}), o = i.__d), o) return i.__E = i;
  } catch (a) {
    t = a;
  }
  throw t;
} }, eS = 0, Nd.prototype.setState = function(t, e) {
  var r;
  r = this.__s != null && this.__s !== this.state ? this.__s : this.__s = va({}, this.state), typeof t == "function" && (t = t(va({}, r), this.props)), t && va(r, t), t != null && this.__v && (e && this._sb.push(e), g6(this));
}, Nd.prototype.forceUpdate = function(t) {
  this.__v && (this.__e = !0, t && this.__h.push(t), g6(this));
}, Nd.prototype.render = ih, rc = [], tS = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, B1 = function(t, e) {
  return t.__v.__b - e.__v.__b;
}, d0.__r = 0, rS = /(PointerCapture)$|Capture$/i, yb = 0, F1 = v6(!1), j1 = v6(!0);
var p0, pn, Mm, b6, q1 = 0, uS = [], yn = Jr, y6 = yn.__b, w6 = yn.__r, x6 = yn.diffed, _6 = yn.__c, E6 = yn.unmount, S6 = yn.__;
function fS(t, e) {
  yn.__h && yn.__h(pn, t, q1 || e), q1 = 0;
  var r = pn.__H || (pn.__H = { __: [], __h: [] });
  return t >= r.__.length && r.__.push({}), r.__[t];
}
function A6(t) {
  return q1 = 1, jY(lS, t);
}
function jY(t, e, r) {
  var n = fS(p0++, 2);
  if (n.t = t, !n.__c && (n.__ = [lS(void 0, e), function(a) {
    var u = n.__N ? n.__N[0] : n.__[0], l = n.t(u, a);
    u !== l && (n.__N = [l, n.__[1]], n.__c.setState({}));
  }], n.__c = pn, !pn.u)) {
    var i = function(a, u, l) {
      if (!n.__c.__H) return !0;
      var d = n.__c.__H.__.filter(function(w) {
        return !!w.__c;
      });
      if (d.every(function(w) {
        return !w.__N;
      })) return !s || s.call(this, a, u, l);
      var p = n.__c.props !== a;
      return d.forEach(function(w) {
        if (w.__N) {
          var A = w.__[0];
          w.__ = w.__N, w.__N = void 0, A !== w.__[0] && (p = !0);
        }
      }), s && s.call(this, a, u, l) || p;
    };
    pn.u = !0;
    var s = pn.shouldComponentUpdate, o = pn.componentWillUpdate;
    pn.componentWillUpdate = function(a, u, l) {
      if (this.__e) {
        var d = s;
        s = void 0, i(a, u, l), s = d;
      }
      o && o.call(this, a, u, l);
    }, pn.shouldComponentUpdate = i;
  }
  return n.__N || n.__;
}
function UY(t, e) {
  var r = fS(p0++, 3);
  !yn.__s && WY(r.__H, e) && (r.__ = t, r.i = e, pn.__H.__h.push(r));
}
function qY() {
  for (var t; t = uS.shift(); ) if (t.__P && t.__H) try {
    t.__H.__h.forEach(Ld), t.__H.__h.forEach(z1), t.__H.__h = [];
  } catch (e) {
    t.__H.__h = [], yn.__e(e, t.__v);
  }
}
yn.__b = function(t) {
  pn = null, y6 && y6(t);
}, yn.__ = function(t, e) {
  t && e.__k && e.__k.__m && (t.__m = e.__k.__m), S6 && S6(t, e);
}, yn.__r = function(t) {
  w6 && w6(t), p0 = 0;
  var e = (pn = t.__c).__H;
  e && (Mm === pn ? (e.__h = [], pn.__h = [], e.__.forEach(function(r) {
    r.__N && (r.__ = r.__N), r.i = r.__N = void 0;
  })) : (e.__h.forEach(Ld), e.__h.forEach(z1), e.__h = [], p0 = 0)), Mm = pn;
}, yn.diffed = function(t) {
  x6 && x6(t);
  var e = t.__c;
  e && e.__H && (e.__H.__h.length && (uS.push(e) !== 1 && b6 === yn.requestAnimationFrame || ((b6 = yn.requestAnimationFrame) || zY)(qY)), e.__H.__.forEach(function(r) {
    r.i && (r.__H = r.i), r.i = void 0;
  })), Mm = pn = null;
}, yn.__c = function(t, e) {
  e.some(function(r) {
    try {
      r.__h.forEach(Ld), r.__h = r.__h.filter(function(n) {
        return !n.__ || z1(n);
      });
    } catch (n) {
      e.some(function(i) {
        i.__h && (i.__h = []);
      }), e = [], yn.__e(n, r.__v);
    }
  }), _6 && _6(t, e);
}, yn.unmount = function(t) {
  E6 && E6(t);
  var e, r = t.__c;
  r && r.__H && (r.__H.__.forEach(function(n) {
    try {
      Ld(n);
    } catch (i) {
      e = i;
    }
  }), r.__H = void 0, e && yn.__e(e, r.__v));
};
var P6 = typeof requestAnimationFrame == "function";
function zY(t) {
  var e, r = function() {
    clearTimeout(n), P6 && cancelAnimationFrame(e), setTimeout(t);
  }, n = setTimeout(r, 100);
  P6 && (e = requestAnimationFrame(r));
}
function Ld(t) {
  var e = pn, r = t.__c;
  typeof r == "function" && (t.__c = void 0, r()), pn = e;
}
function z1(t) {
  var e = pn;
  t.__c = t.__(), pn = e;
}
function WY(t, e) {
  return !t || t.length !== e.length || e.some(function(r, n) {
    return r !== t[n];
  });
}
function lS(t, e) {
  return typeof e == "function" ? e(t) : e;
}
const HY = ".-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}", KY = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+", VY = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=";
class GY {
  constructor() {
    this.items = /* @__PURE__ */ new Map(), this.nextItemKey = 0, this.root = null, this.darkMode = XE();
  }
  attach(e) {
    this.root = document.createElement("div"), this.root.className = "-cbwsdk-snackbar-root", e.appendChild(this.root), this.render();
  }
  presentItem(e) {
    const r = this.nextItemKey++;
    return this.items.set(r, e), this.render(), () => {
      this.items.delete(r), this.render();
    };
  }
  clear() {
    this.items.clear(), this.render();
  }
  render() {
    this.root && U1(Nr(
      "div",
      null,
      Nr(hS, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([e, r]) => Nr(YY, Object.assign({}, r, { key: e }))))
    ), this.root);
  }
}
const hS = (t) => Nr(
  "div",
  { class: Gf("-cbwsdk-snackbar-container") },
  Nr("style", null, HY),
  Nr("div", { class: "-cbwsdk-snackbar" }, t.children)
), YY = ({ autoExpand: t, message: e, menuItems: r }) => {
  const [n, i] = A6(!0), [s, o] = A6(t ?? !1);
  UY(() => {
    const u = [
      window.setTimeout(() => {
        i(!1);
      }, 1),
      window.setTimeout(() => {
        o(!0);
      }, 1e4)
    ];
    return () => {
      u.forEach(window.clearTimeout);
    };
  });
  const a = () => {
    o(!s);
  };
  return Nr(
    "div",
    { class: Gf("-cbwsdk-snackbar-instance", n && "-cbwsdk-snackbar-instance-hidden", s && "-cbwsdk-snackbar-instance-expanded") },
    Nr(
      "div",
      { class: "-cbwsdk-snackbar-instance-header", onClick: a },
      Nr("img", { src: KY, class: "-cbwsdk-snackbar-instance-header-cblogo" }),
      " ",
      Nr("div", { class: "-cbwsdk-snackbar-instance-header-message" }, e),
      Nr(
        "div",
        { class: "-gear-container" },
        !s && Nr(
          "svg",
          { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
          Nr("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" })
        ),
        Nr("img", { src: VY, class: "-gear-icon", title: "Expand" })
      )
    ),
    r && r.length > 0 && Nr("div", { class: "-cbwsdk-snackbar-instance-menu" }, r.map((u, l) => Nr(
      "div",
      { class: Gf("-cbwsdk-snackbar-instance-menu-item", u.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"), onClick: u.onClick, key: l },
      Nr(
        "svg",
        { width: u.svgWidth, height: u.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
        Nr("path", { "fill-rule": u.defaultFillRule, "clip-rule": u.defaultClipRule, d: u.path, fill: "#AAAAAA" })
      ),
      Nr("span", { class: Gf("-cbwsdk-snackbar-instance-menu-item-info", u.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red") }, u.info)
    )))
  );
};
class JY {
  constructor() {
    this.attached = !1, this.snackbar = new GY();
  }
  attach() {
    if (this.attached)
      throw new Error("Coinbase Wallet SDK UI is already attached");
    const e = document.documentElement, r = document.createElement("div");
    r.className = "-cbwsdk-css-reset", e.appendChild(r), this.snackbar.attach(r), this.attached = !0, ZE();
  }
  showConnecting(e) {
    let r;
    return e.isUnlinkedErrorState ? r = {
      autoExpand: !0,
      message: "Connection lost",
      menuItems: [
        {
          isRed: !1,
          info: "Reset connection",
          svgWidth: "10",
          svgHeight: "11",
          path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
          defaultFillRule: "evenodd",
          defaultClipRule: "evenodd",
          onClick: e.onResetConnection
        }
      ]
    } : r = {
      message: "Confirm on phone",
      menuItems: [
        {
          isRed: !0,
          info: "Cancel transaction",
          svgWidth: "11",
          svgHeight: "11",
          path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
          defaultFillRule: "inherit",
          defaultClipRule: "inherit",
          onClick: e.onCancel
        },
        {
          isRed: !1,
          info: "Reset connection",
          svgWidth: "10",
          svgHeight: "11",
          path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
          defaultFillRule: "evenodd",
          defaultClipRule: "evenodd",
          onClick: e.onResetConnection
        }
      ]
    }, this.snackbar.presentItem(r);
  }
}
const XY = ".-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop{position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s;background-color:rgba(10,11,13,.5)}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box{display:block;position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);padding:20px;border-radius:8px;background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box p{display:block;font-weight:400;font-size:14px;line-height:20px;padding-bottom:12px;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box button{appearance:none;border:none;background:none;color:#0052ff;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark{background-color:#0a0b0d;color:#fff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark button{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light{background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light button{color:#0052ff}";
class ZY {
  constructor() {
    this.root = null, this.darkMode = XE();
  }
  attach() {
    const e = document.documentElement;
    this.root = document.createElement("div"), this.root.className = "-cbwsdk-css-reset", e.appendChild(this.root), ZE();
  }
  present(e) {
    this.render(e);
  }
  clear() {
    this.render(null);
  }
  render(e) {
    this.root && (U1(null, this.root), e && U1(Nr(QY, Object.assign({}, e, { onDismiss: () => {
      this.clear();
    }, darkMode: this.darkMode })), this.root));
  }
}
const QY = ({ title: t, buttonText: e, darkMode: r, onButtonClick: n, onDismiss: i }) => {
  const s = r ? "dark" : "light";
  return Nr(
    hS,
    { darkMode: r },
    Nr(
      "div",
      { class: "-cbwsdk-redirect-dialog" },
      Nr("style", null, XY),
      Nr("div", { class: "-cbwsdk-redirect-dialog-backdrop", onClick: i }),
      Nr(
        "div",
        { class: Gf("-cbwsdk-redirect-dialog-box", s) },
        Nr("p", null, t),
        Nr("button", { onClick: n }, e)
      )
    )
  );
}, eJ = "https://keys.coinbase.com/connect", M6 = "https://www.walletlink.org", tJ = "https://go.cb-w.com/walletlink";
class I6 {
  constructor() {
    this.attached = !1, this.redirectDialog = new ZY();
  }
  attach() {
    if (this.attached)
      throw new Error("Coinbase Wallet SDK UI is already attached");
    this.redirectDialog.attach(), this.attached = !0;
  }
  redirectToCoinbaseWallet(e) {
    const r = new URL(tJ);
    r.searchParams.append("redirect_url", DY().href), e && r.searchParams.append("wl_url", e);
    const n = document.createElement("a");
    n.target = "cbw-opener", n.href = r.href, n.rel = "noreferrer noopener", n.click();
  }
  openCoinbaseWalletDeeplink(e) {
    this.redirectDialog.present({
      title: "Redirecting to Coinbase Wallet...",
      buttonText: "Open",
      onButtonClick: () => {
        this.redirectToCoinbaseWallet(e);
      }
    }), setTimeout(() => {
      this.redirectToCoinbaseWallet(e);
    }, 99);
  }
  showConnecting(e) {
    return () => {
      this.redirectDialog.clear();
    };
  }
}
class Ao {
  constructor(e) {
    this.chainCallbackParams = { chainId: "", jsonRpcUrl: "" }, this.isMobileWeb = OY(), this.linkedUpdated = (s) => {
      this.isLinked = s;
      const o = this.storage.getItem($1);
      if (s && (this._session.linked = s), this.isUnlinkedErrorState = !1, o) {
        const a = o.split(" "), u = this.storage.getItem("IsStandaloneSigning") === "true";
        a[0] !== "" && !s && this._session.linked && !u && (this.isUnlinkedErrorState = !0);
      }
    }, this.metadataUpdated = (s, o) => {
      this.storage.setItem(s, o);
    }, this.chainUpdated = (s, o) => {
      this.chainCallbackParams.chainId === s && this.chainCallbackParams.jsonRpcUrl === o || (this.chainCallbackParams = {
        chainId: s,
        jsonRpcUrl: o
      }, this.chainCallback && this.chainCallback(o, Number.parseInt(s, 10)));
    }, this.accountUpdated = (s) => {
      this.accountsCallback && this.accountsCallback([s]), Ao.accountRequestCallbackIds.size > 0 && (Array.from(Ao.accountRequestCallbackIds.values()).forEach((o) => {
        this.invokeCallback(o, {
          method: "requestEthereumAccounts",
          result: [s]
        });
      }), Ao.accountRequestCallbackIds.clear());
    }, this.resetAndReload = this.resetAndReload.bind(this), this.linkAPIUrl = e.linkAPIUrl, this.storage = e.storage, this.metadata = e.metadata, this.accountsCallback = e.accountsCallback, this.chainCallback = e.chainCallback;
    const { session: r, ui: n, connection: i } = this.subscribe();
    this._session = r, this.connection = i, this.relayEventManager = new TY(), this.ui = n, this.ui.attach();
  }
  subscribe() {
    const e = gu.load(this.storage) || gu.create(this.storage), { linkAPIUrl: r } = this, n = new CY({
      session: e,
      linkAPIUrl: r,
      listener: this
    }), i = this.isMobileWeb ? new I6() : new JY();
    return n.connect(), { session: e, ui: i, connection: n };
  }
  resetAndReload() {
    this.connection.destroy().then(() => {
      const e = gu.load(this.storage);
      (e == null ? void 0 : e.id) === this._session.id && to.clearAll(), document.location.reload();
    }).catch((e) => {
    });
  }
  signEthereumTransaction(e) {
    return this.sendRequest({
      method: "signEthereumTransaction",
      params: {
        fromAddress: e.fromAddress,
        toAddress: e.toAddress,
        weiValue: $s(e.weiValue),
        data: Hf(e.data, !0),
        nonce: e.nonce,
        gasPriceInWei: e.gasPriceInWei ? $s(e.gasPriceInWei) : null,
        maxFeePerGas: e.gasPriceInWei ? $s(e.gasPriceInWei) : null,
        maxPriorityFeePerGas: e.gasPriceInWei ? $s(e.gasPriceInWei) : null,
        gasLimit: e.gasLimit ? $s(e.gasLimit) : null,
        chainId: e.chainId,
        shouldSubmit: !1
      }
    });
  }
  signAndSubmitEthereumTransaction(e) {
    return this.sendRequest({
      method: "signEthereumTransaction",
      params: {
        fromAddress: e.fromAddress,
        toAddress: e.toAddress,
        weiValue: $s(e.weiValue),
        data: Hf(e.data, !0),
        nonce: e.nonce,
        gasPriceInWei: e.gasPriceInWei ? $s(e.gasPriceInWei) : null,
        maxFeePerGas: e.maxFeePerGas ? $s(e.maxFeePerGas) : null,
        maxPriorityFeePerGas: e.maxPriorityFeePerGas ? $s(e.maxPriorityFeePerGas) : null,
        gasLimit: e.gasLimit ? $s(e.gasLimit) : null,
        chainId: e.chainId,
        shouldSubmit: !0
      }
    });
  }
  submitEthereumTransaction(e, r) {
    return this.sendRequest({
      method: "submitEthereumTransaction",
      params: {
        signedTransaction: Hf(e, !0),
        chainId: r
      }
    });
  }
  getWalletLinkSession() {
    return this._session;
  }
  sendRequest(e) {
    let r = null;
    const n = ec(8), i = (s) => {
      this.publishWeb3RequestCanceledEvent(n), this.handleErrorResponse(n, e.method, s), r == null || r();
    };
    return new Promise((s, o) => {
      r = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: i,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      }), this.relayEventManager.callbacks.set(n, (a) => {
        if (r == null || r(), jn(a))
          return o(new Error(a.errorMessage));
        s(a);
      }), this.publishWeb3RequestEvent(n, e);
    });
  }
  publishWeb3RequestEvent(e, r) {
    const n = { type: "WEB3_REQUEST", id: e, request: r };
    this.publishEvent("Web3Request", n, !0).then((i) => {
    }).catch((i) => {
      this.handleWeb3ResponseMessage(n.id, {
        method: r.method,
        errorMessage: i.message
      });
    }), this.isMobileWeb && this.openCoinbaseWalletDeeplink(r.method);
  }
  // copied from MobileRelay
  openCoinbaseWalletDeeplink(e) {
    if (this.ui instanceof I6)
      switch (e) {
        case "requestEthereumAccounts":
        case "switchEthereumChain":
          return;
        default:
          window.addEventListener("blur", () => {
            window.addEventListener("focus", () => {
              this.connection.checkUnseenEvents();
            }, { once: !0 });
          }, { once: !0 }), this.ui.openCoinbaseWalletDeeplink();
          break;
      }
  }
  publishWeb3RequestCanceledEvent(e) {
    const r = {
      type: "WEB3_REQUEST_CANCELED",
      id: e
    };
    this.publishEvent("Web3RequestCanceled", r, !1).then();
  }
  publishEvent(e, r, n) {
    return this.connection.publishEvent(e, r, n);
  }
  handleWeb3ResponseMessage(e, r) {
    if (r.method === "requestEthereumAccounts") {
      Ao.accountRequestCallbackIds.forEach((n) => this.invokeCallback(n, r)), Ao.accountRequestCallbackIds.clear();
      return;
    }
    this.invokeCallback(e, r);
  }
  handleErrorResponse(e, r, n) {
    var i;
    const s = (i = n == null ? void 0 : n.message) !== null && i !== void 0 ? i : "Unspecified error message.";
    this.handleWeb3ResponseMessage(e, {
      method: r,
      errorMessage: s
    });
  }
  invokeCallback(e, r) {
    const n = this.relayEventManager.callbacks.get(e);
    n && (n(r), this.relayEventManager.callbacks.delete(e));
  }
  requestEthereumAccounts() {
    const { appName: e, appLogoUrl: r } = this.metadata, n = {
      method: "requestEthereumAccounts",
      params: {
        appName: e,
        appLogoUrl: r
      }
    }, i = ec(8);
    return new Promise((s, o) => {
      this.relayEventManager.callbacks.set(i, (a) => {
        if (jn(a))
          return o(new Error(a.errorMessage));
        s(a);
      }), Ao.accountRequestCallbackIds.add(i), this.publishWeb3RequestEvent(i, n);
    });
  }
  watchAsset(e, r, n, i, s, o) {
    const a = {
      method: "watchAsset",
      params: {
        type: e,
        options: {
          address: r,
          symbol: n,
          decimals: i,
          image: s
        },
        chainId: o
      }
    };
    let u = null;
    const l = ec(8), d = (p) => {
      this.publishWeb3RequestCanceledEvent(l), this.handleErrorResponse(l, a.method, p), u == null || u();
    };
    return u = this.ui.showConnecting({
      isUnlinkedErrorState: this.isUnlinkedErrorState,
      onCancel: d,
      onResetConnection: this.resetAndReload
      // eslint-disable-line @typescript-eslint/unbound-method
    }), new Promise((p, w) => {
      this.relayEventManager.callbacks.set(l, (A) => {
        if (u == null || u(), jn(A))
          return w(new Error(A.errorMessage));
        p(A);
      }), this.publishWeb3RequestEvent(l, a);
    });
  }
  addEthereumChain(e, r, n, i, s, o) {
    const a = {
      method: "addEthereumChain",
      params: {
        chainId: e,
        rpcUrls: r,
        blockExplorerUrls: i,
        chainName: s,
        iconUrls: n,
        nativeCurrency: o
      }
    };
    let u = null;
    const l = ec(8), d = (p) => {
      this.publishWeb3RequestCanceledEvent(l), this.handleErrorResponse(l, a.method, p), u == null || u();
    };
    return u = this.ui.showConnecting({
      isUnlinkedErrorState: this.isUnlinkedErrorState,
      onCancel: d,
      onResetConnection: this.resetAndReload
      // eslint-disable-line @typescript-eslint/unbound-method
    }), new Promise((p, w) => {
      this.relayEventManager.callbacks.set(l, (A) => {
        if (u == null || u(), jn(A))
          return w(new Error(A.errorMessage));
        p(A);
      }), this.publishWeb3RequestEvent(l, a);
    });
  }
  switchEthereumChain(e, r) {
    const n = {
      method: "switchEthereumChain",
      params: Object.assign({ chainId: e }, { address: r })
    };
    let i = null;
    const s = ec(8), o = (a) => {
      this.publishWeb3RequestCanceledEvent(s), this.handleErrorResponse(s, n.method, a), i == null || i();
    };
    return i = this.ui.showConnecting({
      isUnlinkedErrorState: this.isUnlinkedErrorState,
      onCancel: o,
      onResetConnection: this.resetAndReload
      // eslint-disable-line @typescript-eslint/unbound-method
    }), new Promise((a, u) => {
      this.relayEventManager.callbacks.set(s, (l) => {
        if (i == null || i(), jn(l) && l.errorCode)
          return u(Sr.provider.custom({
            code: l.errorCode,
            message: "Unrecognized chain ID. Try adding the chain using addEthereumChain first."
          }));
        if (jn(l))
          return u(new Error(l.errorMessage));
        a(l);
      }), this.publishWeb3RequestEvent(s, n);
    });
  }
}
Ao.accountRequestCallbackIds = /* @__PURE__ */ new Set();
const C6 = "DefaultChainId", T6 = "DefaultJsonRpcUrl";
class dS {
  constructor(e) {
    this._relay = null, this._addresses = [], this.metadata = e.metadata, this._storage = new to("walletlink", M6), this.callback = e.callback || null;
    const r = this._storage.getItem($1);
    if (r) {
      const n = r.split(" ");
      n[0] !== "" && (this._addresses = n.map((i) => ia(i)));
    }
    this.initializeRelay();
  }
  getSession() {
    const e = this.initializeRelay(), { id: r, secret: n } = e.getWalletLinkSession();
    return { id: r, secret: n };
  }
  async handshake() {
    await this._eth_requestAccounts();
  }
  get selectedAddress() {
    return this._addresses[0] || void 0;
  }
  get jsonRpcUrl() {
    var e;
    return (e = this._storage.getItem(T6)) !== null && e !== void 0 ? e : void 0;
  }
  set jsonRpcUrl(e) {
    this._storage.setItem(T6, e);
  }
  updateProviderInfo(e, r) {
    var n;
    this.jsonRpcUrl = e;
    const i = this.getChainId();
    this._storage.setItem(C6, r.toString(10)), Kf(r) !== i && ((n = this.callback) === null || n === void 0 || n.call(this, "chainChanged", ma(r)));
  }
  async watchAsset(e) {
    const r = Array.isArray(e) ? e[0] : e;
    if (!r.type)
      throw Sr.rpc.invalidParams("Type is required");
    if ((r == null ? void 0 : r.type) !== "ERC20")
      throw Sr.rpc.invalidParams(`Asset of type '${r.type}' is not supported`);
    if (!(r != null && r.options))
      throw Sr.rpc.invalidParams("Options are required");
    if (!(r != null && r.options.address))
      throw Sr.rpc.invalidParams("Address is required");
    const n = this.getChainId(), { address: i, symbol: s, image: o, decimals: a } = r.options, l = await this.initializeRelay().watchAsset(r.type, i, s, a, o, n == null ? void 0 : n.toString());
    return jn(l) ? !1 : !!l.result;
  }
  async addEthereumChain(e) {
    var r, n;
    const i = e[0];
    if (((r = i.rpcUrls) === null || r === void 0 ? void 0 : r.length) === 0)
      throw Sr.rpc.invalidParams("please pass in at least 1 rpcUrl");
    if (!i.chainName || i.chainName.trim() === "")
      throw Sr.rpc.invalidParams("chainName is a required field");
    if (!i.nativeCurrency)
      throw Sr.rpc.invalidParams("nativeCurrency is a required field");
    const s = Number.parseInt(i.chainId, 16);
    if (s === this.getChainId())
      return !1;
    const o = this.initializeRelay(), { rpcUrls: a = [], blockExplorerUrls: u = [], chainName: l, iconUrls: d = [], nativeCurrency: p } = i, w = await o.addEthereumChain(s.toString(), a, d, u, l, p);
    if (jn(w))
      return !1;
    if (((n = w.result) === null || n === void 0 ? void 0 : n.isApproved) === !0)
      return this.updateProviderInfo(a[0], s), null;
    throw Sr.rpc.internal("unable to add ethereum chain");
  }
  async switchEthereumChain(e) {
    const r = e[0], n = Number.parseInt(r.chainId, 16), s = await this.initializeRelay().switchEthereumChain(n.toString(10), this.selectedAddress || void 0);
    if (jn(s))
      throw s;
    const o = s.result;
    return o.isApproved && o.rpcUrl.length > 0 && this.updateProviderInfo(o.rpcUrl, n), null;
  }
  async cleanup() {
    this.callback = null, this._relay && this._relay.resetAndReload(), this._storage.clear();
  }
  _setAddresses(e, r) {
    var n;
    if (!Array.isArray(e))
      throw new Error("addresses is not an array");
    const i = e.map((s) => ia(s));
    JSON.stringify(i) !== JSON.stringify(this._addresses) && (this._addresses = i, (n = this.callback) === null || n === void 0 || n.call(this, "accountsChanged", i), this._storage.setItem($1, i.join(" ")));
  }
  async request(e) {
    const r = e.params || [];
    switch (e.method) {
      case "eth_accounts":
        return [...this._addresses];
      case "eth_coinbase":
        return this.selectedAddress || null;
      case "net_version":
        return this.getChainId().toString(10);
      case "eth_chainId":
        return ma(this.getChainId());
      case "eth_requestAccounts":
        return this._eth_requestAccounts();
      case "eth_ecRecover":
      case "personal_ecRecover":
        return this.ecRecover(e);
      case "personal_sign":
        return this.personalSign(e);
      case "eth_signTransaction":
        return this._eth_signTransaction(r);
      case "eth_sendRawTransaction":
        return this._eth_sendRawTransaction(r);
      case "eth_sendTransaction":
        return this._eth_sendTransaction(r);
      case "eth_signTypedData_v1":
      case "eth_signTypedData_v3":
      case "eth_signTypedData_v4":
      case "eth_signTypedData":
        return this.signTypedData(e);
      case "wallet_addEthereumChain":
        return this.addEthereumChain(r);
      case "wallet_switchEthereumChain":
        return this.switchEthereumChain(r);
      case "wallet_watchAsset":
        return this.watchAsset(r);
      default:
        if (!this.jsonRpcUrl)
          throw Sr.rpc.internal("No RPC URL set for chain");
        return jE(e, this.jsonRpcUrl);
    }
  }
  _ensureKnownAddress(e) {
    const r = ia(e);
    if (!this._addresses.map((i) => ia(i)).includes(r))
      throw new Error("Unknown Ethereum address");
  }
  _prepareTransactionParams(e) {
    const r = e.from ? ia(e.from) : this.selectedAddress;
    if (!r)
      throw new Error("Ethereum address is unavailable");
    this._ensureKnownAddress(r);
    const n = e.to ? ia(e.to) : null, i = e.value != null ? Rf(e.value) : BigInt(0), s = e.data ? k1(e.data) : Buffer.alloc(0), o = e.nonce != null ? Kf(e.nonce) : null, a = e.gasPrice != null ? Rf(e.gasPrice) : null, u = e.maxFeePerGas != null ? Rf(e.maxFeePerGas) : null, l = e.maxPriorityFeePerGas != null ? Rf(e.maxPriorityFeePerGas) : null, d = e.gas != null ? Rf(e.gas) : null, p = e.chainId ? Kf(e.chainId) : this.getChainId();
    return {
      fromAddress: r,
      toAddress: n,
      weiValue: i,
      data: s,
      nonce: o,
      gasPriceInWei: a,
      maxFeePerGas: u,
      maxPriorityFeePerGas: l,
      gasLimit: d,
      chainId: p
    };
  }
  async ecRecover(e) {
    const { method: r, params: n } = e;
    if (!Array.isArray(n))
      throw Sr.rpc.invalidParams();
    const s = await this.initializeRelay().sendRequest({
      method: "ethereumAddressFromSignedMessage",
      params: {
        message: _m(n[0]),
        signature: _m(n[1]),
        addPrefix: r === "personal_ecRecover"
      }
    });
    if (jn(s))
      throw s;
    return s.result;
  }
  getChainId() {
    var e;
    return Number.parseInt((e = this._storage.getItem(C6)) !== null && e !== void 0 ? e : "1", 10);
  }
  async _eth_requestAccounts() {
    var e, r;
    if (this._addresses.length > 0)
      return (e = this.callback) === null || e === void 0 || e.call(this, "connect", { chainId: ma(this.getChainId()) }), this._addresses;
    const i = await this.initializeRelay().requestEthereumAccounts();
    if (jn(i))
      throw i;
    if (!i.result)
      throw new Error("accounts received is empty");
    return this._setAddresses(i.result), (r = this.callback) === null || r === void 0 || r.call(this, "connect", { chainId: ma(this.getChainId()) }), this._addresses;
  }
  async personalSign({ params: e }) {
    if (!Array.isArray(e))
      throw Sr.rpc.invalidParams();
    const r = e[1], n = e[0];
    this._ensureKnownAddress(r);
    const s = await this.initializeRelay().sendRequest({
      method: "signEthereumMessage",
      params: {
        address: ia(r),
        message: _m(n),
        addPrefix: !0,
        typedDataJson: null
      }
    });
    if (jn(s))
      throw s;
    return s.result;
  }
  async _eth_signTransaction(e) {
    const r = this._prepareTransactionParams(e[0] || {}), i = await this.initializeRelay().signEthereumTransaction(r);
    if (jn(i))
      throw i;
    return i.result;
  }
  async _eth_sendRawTransaction(e) {
    const r = k1(e[0]), i = await this.initializeRelay().submitEthereumTransaction(r, this.getChainId());
    if (jn(i))
      throw i;
    return i.result;
  }
  async _eth_sendTransaction(e) {
    const r = this._prepareTransactionParams(e[0] || {}), i = await this.initializeRelay().signAndSubmitEthereumTransaction(r);
    if (jn(i))
      throw i;
    return i.result;
  }
  async signTypedData(e) {
    const { method: r, params: n } = e;
    if (!Array.isArray(n))
      throw Sr.rpc.invalidParams();
    const i = (l) => {
      const d = {
        eth_signTypedData_v1: dd.hashForSignTypedDataLegacy,
        eth_signTypedData_v3: dd.hashForSignTypedData_v3,
        eth_signTypedData_v4: dd.hashForSignTypedData_v4,
        eth_signTypedData: dd.hashForSignTypedData_v4
      };
      return Hf(d[r]({
        data: GG(l)
      }), !0);
    }, s = n[r === "eth_signTypedData_v1" ? 1 : 0], o = n[r === "eth_signTypedData_v1" ? 0 : 1];
    this._ensureKnownAddress(s);
    const u = await this.initializeRelay().sendRequest({
      method: "signEthereumMessage",
      params: {
        address: ia(s),
        message: i(o),
        typedDataJson: JSON.stringify(o, null, 2),
        addPrefix: !1
      }
    });
    if (jn(u))
      throw u;
    return u.result;
  }
  initializeRelay() {
    return this._relay || (this._relay = new Ao({
      linkAPIUrl: M6,
      storage: this._storage,
      metadata: this.metadata,
      accountsCallback: this._setAddresses.bind(this),
      chainCallback: this.updateProviderInfo.bind(this)
    })), this._relay;
  }
}
const pS = "SignerType", gS = new to("CBWSDK", "SignerConfigurator");
function rJ() {
  return gS.getItem(pS);
}
function nJ(t) {
  gS.setItem(pS, t);
}
async function iJ(t) {
  const { communicator: e, metadata: r, handshakeRequest: n, callback: i } = t;
  oJ(e, r, i).catch(() => {
  });
  const s = {
    id: crypto.randomUUID(),
    event: "selectSignerType",
    data: Object.assign(Object.assign({}, t.preference), { handshakeRequest: n })
  }, { data: o } = await e.postRequestAndWaitForResponse(s);
  return o;
}
function sJ(t) {
  const { signerType: e, metadata: r, communicator: n, callback: i } = t;
  switch (e) {
    case "scw":
      return new aY({
        metadata: r,
        callback: i,
        communicator: n
      });
    case "walletlink":
      return new dS({
        metadata: r,
        callback: i
      });
  }
}
async function oJ(t, e, r) {
  await t.onMessage(({ event: i }) => i === "WalletLinkSessionRequest");
  const n = new dS({
    metadata: e,
    callback: r
  });
  t.postMessage({
    event: "WalletLinkUpdate",
    data: { session: n.getSession() }
  }), await n.handshake(), t.postMessage({
    event: "WalletLinkUpdate",
    data: { connected: !0 }
  });
}
const aJ = `Coinbase Wallet SDK requires the Cross-Origin-Opener-Policy header to not be set to 'same-origin'. This is to ensure that the SDK can communicate with the Coinbase Smart Wallet app.

Please see https://www.smartwallet.dev/guides/tips/popup-tips#cross-origin-opener-policy for more information.`, cJ = () => {
  let t;
  return {
    getCrossOriginOpenerPolicy: () => t === void 0 ? "undefined" : t,
    checkCrossOriginOpenerPolicy: async () => {
      if (typeof window > "u") {
        t = "non-browser-env";
        return;
      }
      try {
        const e = `${window.location.origin}${window.location.pathname}`, r = await fetch(e, {
          method: "HEAD"
        });
        if (!r.ok)
          throw new Error(`HTTP error! status: ${r.status}`);
        const n = r.headers.get("Cross-Origin-Opener-Policy");
        t = n ?? "null", t === "same-origin" && console.error(aJ);
      } catch (e) {
        console.error("Error checking Cross-Origin-Opener-Policy:", e.message), t = "error";
      }
    }
  };
}, { checkCrossOriginOpenerPolicy: uJ, getCrossOriginOpenerPolicy: fJ } = cJ(), R6 = 420, D6 = 540;
function lJ(t) {
  const e = (window.innerWidth - R6) / 2 + window.screenX, r = (window.innerHeight - D6) / 2 + window.screenY;
  dJ(t);
  const n = window.open(t, "Smart Wallet", `width=${R6}, height=${D6}, left=${e}, top=${r}`);
  if (n == null || n.focus(), !n)
    throw Sr.rpc.internal("Pop up window failed to open");
  return n;
}
function hJ(t) {
  t && !t.closed && t.close();
}
function dJ(t) {
  const e = {
    sdkName: FE,
    sdkVersion: nh,
    origin: window.location.origin,
    coop: fJ()
  };
  for (const [r, n] of Object.entries(e))
    t.searchParams.append(r, n.toString());
}
class pJ {
  constructor({ url: e = eJ, metadata: r, preference: n }) {
    this.popup = null, this.listeners = /* @__PURE__ */ new Map(), this.postMessage = async (i) => {
      (await this.waitForPopupLoaded()).postMessage(i, this.url.origin);
    }, this.postRequestAndWaitForResponse = async (i) => {
      const s = this.onMessage(({ requestId: o }) => o === i.id);
      return this.postMessage(i), await s;
    }, this.onMessage = async (i) => new Promise((s, o) => {
      const a = (u) => {
        if (u.origin !== this.url.origin)
          return;
        const l = u.data;
        i(l) && (s(l), window.removeEventListener("message", a), this.listeners.delete(a));
      };
      window.addEventListener("message", a), this.listeners.set(a, { reject: o });
    }), this.disconnect = () => {
      hJ(this.popup), this.popup = null, this.listeners.forEach(({ reject: i }, s) => {
        i(Sr.provider.userRejectedRequest("Request rejected")), window.removeEventListener("message", s);
      }), this.listeners.clear();
    }, this.waitForPopupLoaded = async () => this.popup && !this.popup.closed ? (this.popup.focus(), this.popup) : (this.popup = lJ(this.url), this.onMessage(({ event: i }) => i === "PopupUnload").then(this.disconnect).catch(() => {
    }), this.onMessage(({ event: i }) => i === "PopupLoaded").then((i) => {
      this.postMessage({
        requestId: i.id,
        data: {
          version: nh,
          metadata: this.metadata,
          preference: this.preference,
          location: window.location.toString()
        }
      });
    }).then(() => {
      if (!this.popup)
        throw Sr.rpc.internal();
      return this.popup;
    })), this.url = new URL(e), this.metadata = r, this.preference = n;
  }
}
function gJ(t) {
  const e = zG(mJ(t), {
    shouldIncludeStack: !0
  }), r = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
  return r.searchParams.set("version", nh), r.searchParams.set("code", e.code.toString()), r.searchParams.set("message", e.message), Object.assign(Object.assign({}, e), { docUrl: r.href });
}
function mJ(t) {
  var e;
  if (typeof t == "string")
    return {
      message: t,
      code: fn.rpc.internal
    };
  if (jn(t)) {
    const r = t.errorMessage, n = (e = t.errorCode) !== null && e !== void 0 ? e : r.match(/(denied|rejected)/i) ? fn.provider.userRejectedRequest : void 0;
    return Object.assign(Object.assign({}, t), {
      message: r,
      code: n,
      data: { method: t.method }
    });
  }
  return t;
}
var mS = { exports: {} };
(function(t) {
  var e = Object.prototype.hasOwnProperty, r = "~";
  function n() {
  }
  Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (r = !1));
  function i(u, l, d) {
    this.fn = u, this.context = l, this.once = d || !1;
  }
  function s(u, l, d, p, w) {
    if (typeof d != "function")
      throw new TypeError("The listener must be a function");
    var A = new i(d, p || u, w), P = r ? r + l : l;
    return u._events[P] ? u._events[P].fn ? u._events[P] = [u._events[P], A] : u._events[P].push(A) : (u._events[P] = A, u._eventsCount++), u;
  }
  function o(u, l) {
    --u._eventsCount === 0 ? u._events = new n() : delete u._events[l];
  }
  function a() {
    this._events = new n(), this._eventsCount = 0;
  }
  a.prototype.eventNames = function() {
    var l = [], d, p;
    if (this._eventsCount === 0) return l;
    for (p in d = this._events)
      e.call(d, p) && l.push(r ? p.slice(1) : p);
    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(d)) : l;
  }, a.prototype.listeners = function(l) {
    var d = r ? r + l : l, p = this._events[d];
    if (!p) return [];
    if (p.fn) return [p.fn];
    for (var w = 0, A = p.length, P = new Array(A); w < A; w++)
      P[w] = p[w].fn;
    return P;
  }, a.prototype.listenerCount = function(l) {
    var d = r ? r + l : l, p = this._events[d];
    return p ? p.fn ? 1 : p.length : 0;
  }, a.prototype.emit = function(l, d, p, w, A, P) {
    var N = r ? r + l : l;
    if (!this._events[N]) return !1;
    var L = this._events[N], $ = arguments.length, B, H;
    if (L.fn) {
      switch (L.once && this.removeListener(l, L.fn, void 0, !0), $) {
        case 1:
          return L.fn.call(L.context), !0;
        case 2:
          return L.fn.call(L.context, d), !0;
        case 3:
          return L.fn.call(L.context, d, p), !0;
        case 4:
          return L.fn.call(L.context, d, p, w), !0;
        case 5:
          return L.fn.call(L.context, d, p, w, A), !0;
        case 6:
          return L.fn.call(L.context, d, p, w, A, P), !0;
      }
      for (H = 1, B = new Array($ - 1); H < $; H++)
        B[H - 1] = arguments[H];
      L.fn.apply(L.context, B);
    } else {
      var W = L.length, V;
      for (H = 0; H < W; H++)
        switch (L[H].once && this.removeListener(l, L[H].fn, void 0, !0), $) {
          case 1:
            L[H].fn.call(L[H].context);
            break;
          case 2:
            L[H].fn.call(L[H].context, d);
            break;
          case 3:
            L[H].fn.call(L[H].context, d, p);
            break;
          case 4:
            L[H].fn.call(L[H].context, d, p, w);
            break;
          default:
            if (!B) for (V = 1, B = new Array($ - 1); V < $; V++)
              B[V - 1] = arguments[V];
            L[H].fn.apply(L[H].context, B);
        }
    }
    return !0;
  }, a.prototype.on = function(l, d, p) {
    return s(this, l, d, p, !1);
  }, a.prototype.once = function(l, d, p) {
    return s(this, l, d, p, !0);
  }, a.prototype.removeListener = function(l, d, p, w) {
    var A = r ? r + l : l;
    if (!this._events[A]) return this;
    if (!d)
      return o(this, A), this;
    var P = this._events[A];
    if (P.fn)
      P.fn === d && (!w || P.once) && (!p || P.context === p) && o(this, A);
    else {
      for (var N = 0, L = [], $ = P.length; N < $; N++)
        (P[N].fn !== d || w && !P[N].once || p && P[N].context !== p) && L.push(P[N]);
      L.length ? this._events[A] = L.length === 1 ? L[0] : L : o(this, A);
    }
    return this;
  }, a.prototype.removeAllListeners = function(l) {
    var d;
    return l ? (d = r ? r + l : l, this._events[d] && o(this, d)) : (this._events = new n(), this._eventsCount = 0), this;
  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, t.exports = a;
})(mS);
var vJ = mS.exports;
const bJ = /* @__PURE__ */ rs(vJ);
class yJ extends bJ {
}
var wJ = function(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
  return r;
};
class xJ extends yJ {
  constructor(e) {
    var { metadata: r } = e, n = e.preference, { keysUrl: i } = n, s = wJ(n, ["keysUrl"]);
    super(), this.signer = null, this.isCoinbaseWallet = !0, this.metadata = r, this.preference = s, this.communicator = new pJ({
      url: i,
      metadata: r,
      preference: s
    });
    const o = rJ();
    o && (this.signer = this.initSigner(o));
  }
  async request(e) {
    try {
      if (oY(e), !this.signer)
        switch (e.method) {
          case "eth_requestAccounts": {
            const r = await this.requestSignerSelection(e), n = this.initSigner(r);
            await n.handshake(e), this.signer = n, nJ(r);
            break;
          }
          case "net_version":
            return 1;
          case "eth_chainId":
            return ma(1);
          default:
            throw Sr.provider.unauthorized("Must call 'eth_requestAccounts' before other methods");
        }
      return this.signer.request(e);
    } catch (r) {
      const { code: n } = r;
      return n === fn.provider.unauthorized && this.disconnect(), Promise.reject(gJ(r));
    }
  }
  /** @deprecated Use `.request({ method: 'eth_requestAccounts' })` instead. */
  async enable() {
    return console.warn('.enable() has been deprecated. Please use .request({ method: "eth_requestAccounts" }) instead.'), await this.request({
      method: "eth_requestAccounts"
    });
  }
  async disconnect() {
    var e;
    await ((e = this.signer) === null || e === void 0 ? void 0 : e.cleanup()), this.signer = null, to.clearAll(), this.emit("disconnect", Sr.provider.disconnected("User initiated disconnection"));
  }
  requestSignerSelection(e) {
    return iJ({
      communicator: this.communicator,
      preference: this.preference,
      metadata: this.metadata,
      handshakeRequest: e,
      callback: this.emit.bind(this)
    });
  }
  initSigner(e) {
    return sJ({
      signerType: e,
      metadata: this.metadata,
      communicator: this.communicator,
      callback: this.emit.bind(this)
    });
  }
}
function _J(t) {
  if (t) {
    if (!["all", "smartWalletOnly", "eoaOnly"].includes(t.options))
      throw new Error(`Invalid options: ${t.options}`);
    if (t.attribution && t.attribution.auto !== void 0 && t.attribution.dataSuffix !== void 0)
      throw new Error("Attribution cannot contain both auto and dataSuffix properties");
  }
}
function EJ(t) {
  var e;
  const r = {
    metadata: t.metadata,
    preference: t.preference
  };
  return (e = sY(r)) !== null && e !== void 0 ? e : new xJ(r);
}
const SJ = {
  options: "all"
};
function AJ(t) {
  var e;
  new to("CBWSDK").setItem("VERSION", nh), uJ();
  const n = {
    metadata: {
      appName: t.appName || "Dapp",
      appLogoUrl: t.appLogoUrl || "",
      appChainIds: t.appChainIds || []
    },
    preference: Object.assign(SJ, (e = t.preference) !== null && e !== void 0 ? e : {})
  };
  _J(n.preference);
  let i = null;
  return {
    getProvider: () => (i || (i = EJ(n)), i)
  };
}
function vS(t, e) {
  return function() {
    return t.apply(e, arguments);
  };
}
const { toString: PJ } = Object.prototype, { getPrototypeOf: Sb } = Object, fp = /* @__PURE__ */ ((t) => (e) => {
  const r = PJ.call(e);
  return t[r] || (t[r] = r.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Ps = (t) => (t = t.toLowerCase(), (e) => fp(e) === t), lp = (t) => (e) => typeof e === t, { isArray: Wu } = Array, Ml = lp("undefined");
function MJ(t) {
  return t !== null && !Ml(t) && t.constructor !== null && !Ml(t.constructor) && Oi(t.constructor.isBuffer) && t.constructor.isBuffer(t);
}
const bS = Ps("ArrayBuffer");
function IJ(t) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && bS(t.buffer), e;
}
const CJ = lp("string"), Oi = lp("function"), yS = lp("number"), hp = (t) => t !== null && typeof t == "object", TJ = (t) => t === !0 || t === !1, kd = (t) => {
  if (fp(t) !== "object")
    return !1;
  const e = Sb(t);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
}, RJ = Ps("Date"), DJ = Ps("File"), OJ = Ps("Blob"), NJ = Ps("FileList"), LJ = (t) => hp(t) && Oi(t.pipe), kJ = (t) => {
  let e;
  return t && (typeof FormData == "function" && t instanceof FormData || Oi(t.append) && ((e = fp(t)) === "formdata" || // detect form-data instance
  e === "object" && Oi(t.toString) && t.toString() === "[object FormData]"));
}, $J = Ps("URLSearchParams"), [BJ, FJ, jJ, UJ] = ["ReadableStream", "Request", "Response", "Headers"].map(Ps), qJ = (t) => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function sh(t, e, { allOwnKeys: r = !1 } = {}) {
  if (t === null || typeof t > "u")
    return;
  let n, i;
  if (typeof t != "object" && (t = [t]), Wu(t))
    for (n = 0, i = t.length; n < i; n++)
      e.call(null, t[n], n, t);
  else {
    const s = r ? Object.getOwnPropertyNames(t) : Object.keys(t), o = s.length;
    let a;
    for (n = 0; n < o; n++)
      a = s[n], e.call(null, t[a], a, t);
  }
}
function wS(t, e) {
  e = e.toLowerCase();
  const r = Object.keys(t);
  let n = r.length, i;
  for (; n-- > 0; )
    if (i = r[n], e === i.toLowerCase())
      return i;
  return null;
}
const sc = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, xS = (t) => !Ml(t) && t !== sc;
function W1() {
  const { caseless: t } = xS(this) && this || {}, e = {}, r = (n, i) => {
    const s = t && wS(e, i) || i;
    kd(e[s]) && kd(n) ? e[s] = W1(e[s], n) : kd(n) ? e[s] = W1({}, n) : Wu(n) ? e[s] = n.slice() : e[s] = n;
  };
  for (let n = 0, i = arguments.length; n < i; n++)
    arguments[n] && sh(arguments[n], r);
  return e;
}
const zJ = (t, e, r, { allOwnKeys: n } = {}) => (sh(e, (i, s) => {
  r && Oi(i) ? t[s] = vS(i, r) : t[s] = i;
}, { allOwnKeys: n }), t), WJ = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), HJ = (t, e, r, n) => {
  t.prototype = Object.create(e.prototype, n), t.prototype.constructor = t, Object.defineProperty(t, "super", {
    value: e.prototype
  }), r && Object.assign(t.prototype, r);
}, KJ = (t, e, r, n) => {
  let i, s, o;
  const a = {};
  if (e = e || {}, t == null) return e;
  do {
    for (i = Object.getOwnPropertyNames(t), s = i.length; s-- > 0; )
      o = i[s], (!n || n(o, t, e)) && !a[o] && (e[o] = t[o], a[o] = !0);
    t = r !== !1 && Sb(t);
  } while (t && (!r || r(t, e)) && t !== Object.prototype);
  return e;
}, VJ = (t, e, r) => {
  t = String(t), (r === void 0 || r > t.length) && (r = t.length), r -= e.length;
  const n = t.indexOf(e, r);
  return n !== -1 && n === r;
}, GJ = (t) => {
  if (!t) return null;
  if (Wu(t)) return t;
  let e = t.length;
  if (!yS(e)) return null;
  const r = new Array(e);
  for (; e-- > 0; )
    r[e] = t[e];
  return r;
}, YJ = /* @__PURE__ */ ((t) => (e) => t && e instanceof t)(typeof Uint8Array < "u" && Sb(Uint8Array)), JJ = (t, e) => {
  const n = (t && t[Symbol.iterator]).call(t);
  let i;
  for (; (i = n.next()) && !i.done; ) {
    const s = i.value;
    e.call(t, s[0], s[1]);
  }
}, XJ = (t, e) => {
  let r;
  const n = [];
  for (; (r = t.exec(e)) !== null; )
    n.push(r);
  return n;
}, ZJ = Ps("HTMLFormElement"), QJ = (t) => t.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(r, n, i) {
    return n.toUpperCase() + i;
  }
), O6 = (({ hasOwnProperty: t }) => (e, r) => t.call(e, r))(Object.prototype), eX = Ps("RegExp"), _S = (t, e) => {
  const r = Object.getOwnPropertyDescriptors(t), n = {};
  sh(r, (i, s) => {
    let o;
    (o = e(i, s, t)) !== !1 && (n[s] = o || i);
  }), Object.defineProperties(t, n);
}, tX = (t) => {
  _S(t, (e, r) => {
    if (Oi(t) && ["arguments", "caller", "callee"].indexOf(r) !== -1)
      return !1;
    const n = t[r];
    if (Oi(n)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + r + "'");
      });
    }
  });
}, rX = (t, e) => {
  const r = {}, n = (i) => {
    i.forEach((s) => {
      r[s] = !0;
    });
  };
  return Wu(t) ? n(t) : n(String(t).split(e)), r;
}, nX = () => {
}, iX = (t, e) => t != null && Number.isFinite(t = +t) ? t : e, Im = "abcdefghijklmnopqrstuvwxyz", N6 = "0123456789", ES = {
  DIGIT: N6,
  ALPHA: Im,
  ALPHA_DIGIT: Im + Im.toUpperCase() + N6
}, sX = (t = 16, e = ES.ALPHA_DIGIT) => {
  let r = "";
  const { length: n } = e;
  for (; t--; )
    r += e[Math.random() * n | 0];
  return r;
};
function oX(t) {
  return !!(t && Oi(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator]);
}
const aX = (t) => {
  const e = new Array(10), r = (n, i) => {
    if (hp(n)) {
      if (e.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        e[i] = n;
        const s = Wu(n) ? [] : {};
        return sh(n, (o, a) => {
          const u = r(o, i + 1);
          !Ml(u) && (s[a] = u);
        }), e[i] = void 0, s;
      }
    }
    return n;
  };
  return r(t, 0);
}, cX = Ps("AsyncFunction"), uX = (t) => t && (hp(t) || Oi(t)) && Oi(t.then) && Oi(t.catch), SS = ((t, e) => t ? setImmediate : e ? ((r, n) => (sc.addEventListener("message", ({ source: i, data: s }) => {
  i === sc && s === r && n.length && n.shift()();
}, !1), (i) => {
  n.push(i), sc.postMessage(r, "*");
}))(`axios@${Math.random()}`, []) : (r) => setTimeout(r))(
  typeof setImmediate == "function",
  Oi(sc.postMessage)
), fX = typeof queueMicrotask < "u" ? queueMicrotask.bind(sc) : typeof process < "u" && process.nextTick || SS, Oe = {
  isArray: Wu,
  isArrayBuffer: bS,
  isBuffer: MJ,
  isFormData: kJ,
  isArrayBufferView: IJ,
  isString: CJ,
  isNumber: yS,
  isBoolean: TJ,
  isObject: hp,
  isPlainObject: kd,
  isReadableStream: BJ,
  isRequest: FJ,
  isResponse: jJ,
  isHeaders: UJ,
  isUndefined: Ml,
  isDate: RJ,
  isFile: DJ,
  isBlob: OJ,
  isRegExp: eX,
  isFunction: Oi,
  isStream: LJ,
  isURLSearchParams: $J,
  isTypedArray: YJ,
  isFileList: NJ,
  forEach: sh,
  merge: W1,
  extend: zJ,
  trim: qJ,
  stripBOM: WJ,
  inherits: HJ,
  toFlatObject: KJ,
  kindOf: fp,
  kindOfTest: Ps,
  endsWith: VJ,
  toArray: GJ,
  forEachEntry: JJ,
  matchAll: XJ,
  isHTMLForm: ZJ,
  hasOwnProperty: O6,
  hasOwnProp: O6,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: _S,
  freezeMethods: tX,
  toObjectSet: rX,
  toCamelCase: QJ,
  noop: nX,
  toFiniteNumber: iX,
  findKey: wS,
  global: sc,
  isContextDefined: xS,
  ALPHABET: ES,
  generateString: sX,
  isSpecCompliantForm: oX,
  toJSONObject: aX,
  isAsyncFn: cX,
  isThenable: uX,
  setImmediate: SS,
  asap: fX
};
function or(t, e, r, n, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), r && (this.config = r), n && (this.request = n), i && (this.response = i, this.status = i.status ? i.status : null);
}
Oe.inherits(or, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Oe.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const AS = or.prototype, PS = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((t) => {
  PS[t] = { value: t };
});
Object.defineProperties(or, PS);
Object.defineProperty(AS, "isAxiosError", { value: !0 });
or.from = (t, e, r, n, i, s) => {
  const o = Object.create(AS);
  return Oe.toFlatObject(t, o, function(u) {
    return u !== Error.prototype;
  }, (a) => a !== "isAxiosError"), or.call(o, t.message, e, r, n, i), o.cause = t, o.name = t.name, s && Object.assign(o, s), o;
};
const lX = null;
function H1(t) {
  return Oe.isPlainObject(t) || Oe.isArray(t);
}
function MS(t) {
  return Oe.endsWith(t, "[]") ? t.slice(0, -2) : t;
}
function L6(t, e, r) {
  return t ? t.concat(e).map(function(i, s) {
    return i = MS(i), !r && s ? "[" + i + "]" : i;
  }).join(r ? "." : "") : e;
}
function hX(t) {
  return Oe.isArray(t) && !t.some(H1);
}
const dX = Oe.toFlatObject(Oe, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function dp(t, e, r) {
  if (!Oe.isObject(t))
    throw new TypeError("target must be an object");
  e = e || new FormData(), r = Oe.toFlatObject(r, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(N, L) {
    return !Oe.isUndefined(L[N]);
  });
  const n = r.metaTokens, i = r.visitor || d, s = r.dots, o = r.indexes, u = (r.Blob || typeof Blob < "u" && Blob) && Oe.isSpecCompliantForm(e);
  if (!Oe.isFunction(i))
    throw new TypeError("visitor must be a function");
  function l(P) {
    if (P === null) return "";
    if (Oe.isDate(P))
      return P.toISOString();
    if (!u && Oe.isBlob(P))
      throw new or("Blob is not supported. Use a Buffer instead.");
    return Oe.isArrayBuffer(P) || Oe.isTypedArray(P) ? u && typeof Blob == "function" ? new Blob([P]) : Buffer.from(P) : P;
  }
  function d(P, N, L) {
    let $ = P;
    if (P && !L && typeof P == "object") {
      if (Oe.endsWith(N, "{}"))
        N = n ? N : N.slice(0, -2), P = JSON.stringify(P);
      else if (Oe.isArray(P) && hX(P) || (Oe.isFileList(P) || Oe.endsWith(N, "[]")) && ($ = Oe.toArray(P)))
        return N = MS(N), $.forEach(function(H, W) {
          !(Oe.isUndefined(H) || H === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? L6([N], W, s) : o === null ? N : N + "[]",
            l(H)
          );
        }), !1;
    }
    return H1(P) ? !0 : (e.append(L6(L, N, s), l(P)), !1);
  }
  const p = [], w = Object.assign(dX, {
    defaultVisitor: d,
    convertValue: l,
    isVisitable: H1
  });
  function A(P, N) {
    if (!Oe.isUndefined(P)) {
      if (p.indexOf(P) !== -1)
        throw Error("Circular reference detected in " + N.join("."));
      p.push(P), Oe.forEach(P, function($, B) {
        (!(Oe.isUndefined($) || $ === null) && i.call(
          e,
          $,
          Oe.isString(B) ? B.trim() : B,
          N,
          w
        )) === !0 && A($, N ? N.concat(B) : [B]);
      }), p.pop();
    }
  }
  if (!Oe.isObject(t))
    throw new TypeError("data must be an object");
  return A(t), e;
}
function k6(t) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(n) {
    return e[n];
  });
}
function Ab(t, e) {
  this._pairs = [], t && dp(t, this, e);
}
const IS = Ab.prototype;
IS.append = function(e, r) {
  this._pairs.push([e, r]);
};
IS.toString = function(e) {
  const r = e ? function(n) {
    return e.call(this, n, k6);
  } : k6;
  return this._pairs.map(function(i) {
    return r(i[0]) + "=" + r(i[1]);
  }, "").join("&");
};
function pX(t) {
  return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function CS(t, e, r) {
  if (!e)
    return t;
  const n = r && r.encode || pX;
  Oe.isFunction(r) && (r = {
    serialize: r
  });
  const i = r && r.serialize;
  let s;
  if (i ? s = i(e, r) : s = Oe.isURLSearchParams(e) ? e.toString() : new Ab(e, r).toString(n), s) {
    const o = t.indexOf("#");
    o !== -1 && (t = t.slice(0, o)), t += (t.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return t;
}
class $6 {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, r, n) {
    return this.handlers.push({
      fulfilled: e,
      rejected: r,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    Oe.forEach(this.handlers, function(n) {
      n !== null && e(n);
    });
  }
}
const TS = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, gX = typeof URLSearchParams < "u" ? URLSearchParams : Ab, mX = typeof FormData < "u" ? FormData : null, vX = typeof Blob < "u" ? Blob : null, bX = {
  isBrowser: !0,
  classes: {
    URLSearchParams: gX,
    FormData: mX,
    Blob: vX
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Pb = typeof window < "u" && typeof document < "u", K1 = typeof navigator == "object" && navigator || void 0, yX = Pb && (!K1 || ["ReactNative", "NativeScript", "NS"].indexOf(K1.product) < 0), wX = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", xX = Pb && window.location.href || "http://localhost", _X = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Pb,
  hasStandardBrowserEnv: yX,
  hasStandardBrowserWebWorkerEnv: wX,
  navigator: K1,
  origin: xX
}, Symbol.toStringTag, { value: "Module" })), Jn = {
  ..._X,
  ...bX
};
function EX(t, e) {
  return dp(t, new Jn.classes.URLSearchParams(), Object.assign({
    visitor: function(r, n, i, s) {
      return Jn.isNode && Oe.isBuffer(r) ? (this.append(n, r.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function SX(t) {
  return Oe.matchAll(/\w+|\[(\w*)]/g, t).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function AX(t) {
  const e = {}, r = Object.keys(t);
  let n;
  const i = r.length;
  let s;
  for (n = 0; n < i; n++)
    s = r[n], e[s] = t[s];
  return e;
}
function RS(t) {
  function e(r, n, i, s) {
    let o = r[s++];
    if (o === "__proto__") return !0;
    const a = Number.isFinite(+o), u = s >= r.length;
    return o = !o && Oe.isArray(i) ? i.length : o, u ? (Oe.hasOwnProp(i, o) ? i[o] = [i[o], n] : i[o] = n, !a) : ((!i[o] || !Oe.isObject(i[o])) && (i[o] = []), e(r, n, i[o], s) && Oe.isArray(i[o]) && (i[o] = AX(i[o])), !a);
  }
  if (Oe.isFormData(t) && Oe.isFunction(t.entries)) {
    const r = {};
    return Oe.forEachEntry(t, (n, i) => {
      e(SX(n), i, r, 0);
    }), r;
  }
  return null;
}
function PX(t, e, r) {
  if (Oe.isString(t))
    try {
      return (e || JSON.parse)(t), Oe.trim(t);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (r || JSON.stringify)(t);
}
const oh = {
  transitional: TS,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, r) {
    const n = r.getContentType() || "", i = n.indexOf("application/json") > -1, s = Oe.isObject(e);
    if (s && Oe.isHTMLForm(e) && (e = new FormData(e)), Oe.isFormData(e))
      return i ? JSON.stringify(RS(e)) : e;
    if (Oe.isArrayBuffer(e) || Oe.isBuffer(e) || Oe.isStream(e) || Oe.isFile(e) || Oe.isBlob(e) || Oe.isReadableStream(e))
      return e;
    if (Oe.isArrayBufferView(e))
      return e.buffer;
    if (Oe.isURLSearchParams(e))
      return r.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let a;
    if (s) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return EX(e, this.formSerializer).toString();
      if ((a = Oe.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
        const u = this.env && this.env.FormData;
        return dp(
          a ? { "files[]": e } : e,
          u && new u(),
          this.formSerializer
        );
      }
    }
    return s || i ? (r.setContentType("application/json", !1), PX(e)) : e;
  }],
  transformResponse: [function(e) {
    const r = this.transitional || oh.transitional, n = r && r.forcedJSONParsing, i = this.responseType === "json";
    if (Oe.isResponse(e) || Oe.isReadableStream(e))
      return e;
    if (e && Oe.isString(e) && (n && !this.responseType || i)) {
      const o = !(r && r.silentJSONParsing) && i;
      try {
        return JSON.parse(e);
      } catch (a) {
        if (o)
          throw a.name === "SyntaxError" ? or.from(a, or.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Jn.classes.FormData,
    Blob: Jn.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
Oe.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
  oh.headers[t] = {};
});
const MX = Oe.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), IX = (t) => {
  const e = {};
  let r, n, i;
  return t && t.split(`
`).forEach(function(o) {
    i = o.indexOf(":"), r = o.substring(0, i).trim().toLowerCase(), n = o.substring(i + 1).trim(), !(!r || e[r] && MX[r]) && (r === "set-cookie" ? e[r] ? e[r].push(n) : e[r] = [n] : e[r] = e[r] ? e[r] + ", " + n : n);
  }), e;
}, B6 = Symbol("internals");
function Df(t) {
  return t && String(t).trim().toLowerCase();
}
function $d(t) {
  return t === !1 || t == null ? t : Oe.isArray(t) ? t.map($d) : String(t);
}
function CX(t) {
  const e = /* @__PURE__ */ Object.create(null), r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = r.exec(t); )
    e[n[1]] = n[2];
  return e;
}
const TX = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
function Cm(t, e, r, n, i) {
  if (Oe.isFunction(n))
    return n.call(this, e, r);
  if (i && (e = r), !!Oe.isString(e)) {
    if (Oe.isString(n))
      return e.indexOf(n) !== -1;
    if (Oe.isRegExp(n))
      return n.test(e);
  }
}
function RX(t) {
  return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, r, n) => r.toUpperCase() + n);
}
function DX(t, e) {
  const r = Oe.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(t, n + r, {
      value: function(i, s, o) {
        return this[n].call(this, e, i, s, o);
      },
      configurable: !0
    });
  });
}
let yi = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, r, n) {
    const i = this;
    function s(a, u, l) {
      const d = Df(u);
      if (!d)
        throw new Error("header name must be a non-empty string");
      const p = Oe.findKey(i, d);
      (!p || i[p] === void 0 || l === !0 || l === void 0 && i[p] !== !1) && (i[p || u] = $d(a));
    }
    const o = (a, u) => Oe.forEach(a, (l, d) => s(l, d, u));
    if (Oe.isPlainObject(e) || e instanceof this.constructor)
      o(e, r);
    else if (Oe.isString(e) && (e = e.trim()) && !TX(e))
      o(IX(e), r);
    else if (Oe.isHeaders(e))
      for (const [a, u] of e.entries())
        s(u, a, n);
    else
      e != null && s(r, e, n);
    return this;
  }
  get(e, r) {
    if (e = Df(e), e) {
      const n = Oe.findKey(this, e);
      if (n) {
        const i = this[n];
        if (!r)
          return i;
        if (r === !0)
          return CX(i);
        if (Oe.isFunction(r))
          return r.call(this, i, n);
        if (Oe.isRegExp(r))
          return r.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, r) {
    if (e = Df(e), e) {
      const n = Oe.findKey(this, e);
      return !!(n && this[n] !== void 0 && (!r || Cm(this, this[n], n, r)));
    }
    return !1;
  }
  delete(e, r) {
    const n = this;
    let i = !1;
    function s(o) {
      if (o = Df(o), o) {
        const a = Oe.findKey(n, o);
        a && (!r || Cm(n, n[a], a, r)) && (delete n[a], i = !0);
      }
    }
    return Oe.isArray(e) ? e.forEach(s) : s(e), i;
  }
  clear(e) {
    const r = Object.keys(this);
    let n = r.length, i = !1;
    for (; n--; ) {
      const s = r[n];
      (!e || Cm(this, this[s], s, e, !0)) && (delete this[s], i = !0);
    }
    return i;
  }
  normalize(e) {
    const r = this, n = {};
    return Oe.forEach(this, (i, s) => {
      const o = Oe.findKey(n, s);
      if (o) {
        r[o] = $d(i), delete r[s];
        return;
      }
      const a = e ? RX(s) : String(s).trim();
      a !== s && delete r[s], r[a] = $d(i), n[a] = !0;
    }), this;
  }
  concat(...e) {
    return this.constructor.concat(this, ...e);
  }
  toJSON(e) {
    const r = /* @__PURE__ */ Object.create(null);
    return Oe.forEach(this, (n, i) => {
      n != null && n !== !1 && (r[i] = e && Oe.isArray(n) ? n.join(", ") : n);
    }), r;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([e, r]) => e + ": " + r).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e, ...r) {
    const n = new this(e);
    return r.forEach((i) => n.set(i)), n;
  }
  static accessor(e) {
    const n = (this[B6] = this[B6] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function s(o) {
      const a = Df(o);
      n[a] || (DX(i, o), n[a] = !0);
    }
    return Oe.isArray(e) ? e.forEach(s) : s(e), this;
  }
};
yi.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Oe.reduceDescriptors(yi.prototype, ({ value: t }, e) => {
  let r = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => t,
    set(n) {
      this[r] = n;
    }
  };
});
Oe.freezeMethods(yi);
function Tm(t, e) {
  const r = this || oh, n = e || r, i = yi.from(n.headers);
  let s = n.data;
  return Oe.forEach(t, function(a) {
    s = a.call(r, s, i.normalize(), e ? e.status : void 0);
  }), i.normalize(), s;
}
function DS(t) {
  return !!(t && t.__CANCEL__);
}
function Hu(t, e, r) {
  or.call(this, t ?? "canceled", or.ERR_CANCELED, e, r), this.name = "CanceledError";
}
Oe.inherits(Hu, or, {
  __CANCEL__: !0
});
function OS(t, e, r) {
  const n = r.config.validateStatus;
  !r.status || !n || n(r.status) ? t(r) : e(new or(
    "Request failed with status code " + r.status,
    [or.ERR_BAD_REQUEST, or.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4],
    r.config,
    r.request,
    r
  ));
}
function OX(t) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
  return e && e[1] || "";
}
function NX(t, e) {
  t = t || 10;
  const r = new Array(t), n = new Array(t);
  let i = 0, s = 0, o;
  return e = e !== void 0 ? e : 1e3, function(u) {
    const l = Date.now(), d = n[s];
    o || (o = l), r[i] = u, n[i] = l;
    let p = s, w = 0;
    for (; p !== i; )
      w += r[p++], p = p % t;
    if (i = (i + 1) % t, i === s && (s = (s + 1) % t), l - o < e)
      return;
    const A = d && l - d;
    return A ? Math.round(w * 1e3 / A) : void 0;
  };
}
function LX(t, e) {
  let r = 0, n = 1e3 / e, i, s;
  const o = (l, d = Date.now()) => {
    r = d, i = null, s && (clearTimeout(s), s = null), t.apply(null, l);
  };
  return [(...l) => {
    const d = Date.now(), p = d - r;
    p >= n ? o(l, d) : (i = l, s || (s = setTimeout(() => {
      s = null, o(i);
    }, n - p)));
  }, () => i && o(i)];
}
const g0 = (t, e, r = 3) => {
  let n = 0;
  const i = NX(50, 250);
  return LX((s) => {
    const o = s.loaded, a = s.lengthComputable ? s.total : void 0, u = o - n, l = i(u), d = o <= a;
    n = o;
    const p = {
      loaded: o,
      total: a,
      progress: a ? o / a : void 0,
      bytes: u,
      rate: l || void 0,
      estimated: l && a && d ? (a - o) / l : void 0,
      event: s,
      lengthComputable: a != null,
      [e ? "download" : "upload"]: !0
    };
    t(p);
  }, r);
}, F6 = (t, e) => {
  const r = t != null;
  return [(n) => e[0]({
    lengthComputable: r,
    total: t,
    loaded: n
  }), e[1]];
}, j6 = (t) => (...e) => Oe.asap(() => t(...e)), kX = Jn.hasStandardBrowserEnv ? /* @__PURE__ */ ((t, e) => (r) => (r = new URL(r, Jn.origin), t.protocol === r.protocol && t.host === r.host && (e || t.port === r.port)))(
  new URL(Jn.origin),
  Jn.navigator && /(msie|trident)/i.test(Jn.navigator.userAgent)
) : () => !0, $X = Jn.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(t, e, r, n, i, s) {
      const o = [t + "=" + encodeURIComponent(e)];
      Oe.isNumber(r) && o.push("expires=" + new Date(r).toGMTString()), Oe.isString(n) && o.push("path=" + n), Oe.isString(i) && o.push("domain=" + i), s === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(t) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(t) {
      this.write(t, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function BX(t) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
}
function FX(t, e) {
  return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t;
}
function NS(t, e) {
  return t && !BX(e) ? FX(t, e) : e;
}
const U6 = (t) => t instanceof yi ? { ...t } : t;
function mc(t, e) {
  e = e || {};
  const r = {};
  function n(l, d, p, w) {
    return Oe.isPlainObject(l) && Oe.isPlainObject(d) ? Oe.merge.call({ caseless: w }, l, d) : Oe.isPlainObject(d) ? Oe.merge({}, d) : Oe.isArray(d) ? d.slice() : d;
  }
  function i(l, d, p, w) {
    if (Oe.isUndefined(d)) {
      if (!Oe.isUndefined(l))
        return n(void 0, l, p, w);
    } else return n(l, d, p, w);
  }
  function s(l, d) {
    if (!Oe.isUndefined(d))
      return n(void 0, d);
  }
  function o(l, d) {
    if (Oe.isUndefined(d)) {
      if (!Oe.isUndefined(l))
        return n(void 0, l);
    } else return n(void 0, d);
  }
  function a(l, d, p) {
    if (p in e)
      return n(l, d);
    if (p in t)
      return n(void 0, l);
  }
  const u = {
    url: s,
    method: s,
    data: s,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (l, d, p) => i(U6(l), U6(d), p, !0)
  };
  return Oe.forEach(Object.keys(Object.assign({}, t, e)), function(d) {
    const p = u[d] || i, w = p(t[d], e[d], d);
    Oe.isUndefined(w) && p !== a || (r[d] = w);
  }), r;
}
const LS = (t) => {
  const e = mc({}, t);
  let { data: r, withXSRFToken: n, xsrfHeaderName: i, xsrfCookieName: s, headers: o, auth: a } = e;
  e.headers = o = yi.from(o), e.url = CS(NS(e.baseURL, e.url), t.params, t.paramsSerializer), a && o.set(
    "Authorization",
    "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))
  );
  let u;
  if (Oe.isFormData(r)) {
    if (Jn.hasStandardBrowserEnv || Jn.hasStandardBrowserWebWorkerEnv)
      o.setContentType(void 0);
    else if ((u = o.getContentType()) !== !1) {
      const [l, ...d] = u ? u.split(";").map((p) => p.trim()).filter(Boolean) : [];
      o.setContentType([l || "multipart/form-data", ...d].join("; "));
    }
  }
  if (Jn.hasStandardBrowserEnv && (n && Oe.isFunction(n) && (n = n(e)), n || n !== !1 && kX(e.url))) {
    const l = i && s && $X.read(s);
    l && o.set(i, l);
  }
  return e;
}, jX = typeof XMLHttpRequest < "u", UX = jX && function(t) {
  return new Promise(function(r, n) {
    const i = LS(t);
    let s = i.data;
    const o = yi.from(i.headers).normalize();
    let { responseType: a, onUploadProgress: u, onDownloadProgress: l } = i, d, p, w, A, P;
    function N() {
      A && A(), P && P(), i.cancelToken && i.cancelToken.unsubscribe(d), i.signal && i.signal.removeEventListener("abort", d);
    }
    let L = new XMLHttpRequest();
    L.open(i.method.toUpperCase(), i.url, !0), L.timeout = i.timeout;
    function $() {
      if (!L)
        return;
      const H = yi.from(
        "getAllResponseHeaders" in L && L.getAllResponseHeaders()
      ), V = {
        data: !a || a === "text" || a === "json" ? L.responseText : L.response,
        status: L.status,
        statusText: L.statusText,
        headers: H,
        config: t,
        request: L
      };
      OS(function(R) {
        r(R), N();
      }, function(R) {
        n(R), N();
      }, V), L = null;
    }
    "onloadend" in L ? L.onloadend = $ : L.onreadystatechange = function() {
      !L || L.readyState !== 4 || L.status === 0 && !(L.responseURL && L.responseURL.indexOf("file:") === 0) || setTimeout($);
    }, L.onabort = function() {
      L && (n(new or("Request aborted", or.ECONNABORTED, t, L)), L = null);
    }, L.onerror = function() {
      n(new or("Network Error", or.ERR_NETWORK, t, L)), L = null;
    }, L.ontimeout = function() {
      let W = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const V = i.transitional || TS;
      i.timeoutErrorMessage && (W = i.timeoutErrorMessage), n(new or(
        W,
        V.clarifyTimeoutError ? or.ETIMEDOUT : or.ECONNABORTED,
        t,
        L
      )), L = null;
    }, s === void 0 && o.setContentType(null), "setRequestHeader" in L && Oe.forEach(o.toJSON(), function(W, V) {
      L.setRequestHeader(V, W);
    }), Oe.isUndefined(i.withCredentials) || (L.withCredentials = !!i.withCredentials), a && a !== "json" && (L.responseType = i.responseType), l && ([w, P] = g0(l, !0), L.addEventListener("progress", w)), u && L.upload && ([p, A] = g0(u), L.upload.addEventListener("progress", p), L.upload.addEventListener("loadend", A)), (i.cancelToken || i.signal) && (d = (H) => {
      L && (n(!H || H.type ? new Hu(null, t, L) : H), L.abort(), L = null);
    }, i.cancelToken && i.cancelToken.subscribe(d), i.signal && (i.signal.aborted ? d() : i.signal.addEventListener("abort", d)));
    const B = OX(i.url);
    if (B && Jn.protocols.indexOf(B) === -1) {
      n(new or("Unsupported protocol " + B + ":", or.ERR_BAD_REQUEST, t));
      return;
    }
    L.send(s || null);
  });
}, qX = (t, e) => {
  const { length: r } = t = t ? t.filter(Boolean) : [];
  if (e || r) {
    let n = new AbortController(), i;
    const s = function(l) {
      if (!i) {
        i = !0, a();
        const d = l instanceof Error ? l : this.reason;
        n.abort(d instanceof or ? d : new Hu(d instanceof Error ? d.message : d));
      }
    };
    let o = e && setTimeout(() => {
      o = null, s(new or(`timeout ${e} of ms exceeded`, or.ETIMEDOUT));
    }, e);
    const a = () => {
      t && (o && clearTimeout(o), o = null, t.forEach((l) => {
        l.unsubscribe ? l.unsubscribe(s) : l.removeEventListener("abort", s);
      }), t = null);
    };
    t.forEach((l) => l.addEventListener("abort", s));
    const { signal: u } = n;
    return u.unsubscribe = () => Oe.asap(a), u;
  }
}, zX = function* (t, e) {
  let r = t.byteLength;
  if (r < e) {
    yield t;
    return;
  }
  let n = 0, i;
  for (; n < r; )
    i = n + e, yield t.slice(n, i), n = i;
}, WX = async function* (t, e) {
  for await (const r of HX(t))
    yield* zX(r, e);
}, HX = async function* (t) {
  if (t[Symbol.asyncIterator]) {
    yield* t;
    return;
  }
  const e = t.getReader();
  try {
    for (; ; ) {
      const { done: r, value: n } = await e.read();
      if (r)
        break;
      yield n;
    }
  } finally {
    await e.cancel();
  }
}, q6 = (t, e, r, n) => {
  const i = WX(t, e);
  let s = 0, o, a = (u) => {
    o || (o = !0, n && n(u));
  };
  return new ReadableStream({
    async pull(u) {
      try {
        const { done: l, value: d } = await i.next();
        if (l) {
          a(), u.close();
          return;
        }
        let p = d.byteLength;
        if (r) {
          let w = s += p;
          r(w);
        }
        u.enqueue(new Uint8Array(d));
      } catch (l) {
        throw a(l), l;
      }
    },
    cancel(u) {
      return a(u), i.return();
    }
  }, {
    highWaterMark: 2
  });
}, pp = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", kS = pp && typeof ReadableStream == "function", KX = pp && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((t) => (e) => t.encode(e))(new TextEncoder()) : async (t) => new Uint8Array(await new Response(t).arrayBuffer())), $S = (t, ...e) => {
  try {
    return !!t(...e);
  } catch {
    return !1;
  }
}, VX = kS && $S(() => {
  let t = !1;
  const e = new Request(Jn.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return t = !0, "half";
    }
  }).headers.has("Content-Type");
  return t && !e;
}), z6 = 64 * 1024, V1 = kS && $S(() => Oe.isReadableStream(new Response("").body)), m0 = {
  stream: V1 && ((t) => t.body)
};
pp && ((t) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !m0[e] && (m0[e] = Oe.isFunction(t[e]) ? (r) => r[e]() : (r, n) => {
      throw new or(`Response type '${e}' is not supported`, or.ERR_NOT_SUPPORT, n);
    });
  });
})(new Response());
const GX = async (t) => {
  if (t == null)
    return 0;
  if (Oe.isBlob(t))
    return t.size;
  if (Oe.isSpecCompliantForm(t))
    return (await new Request(Jn.origin, {
      method: "POST",
      body: t
    }).arrayBuffer()).byteLength;
  if (Oe.isArrayBufferView(t) || Oe.isArrayBuffer(t))
    return t.byteLength;
  if (Oe.isURLSearchParams(t) && (t = t + ""), Oe.isString(t))
    return (await KX(t)).byteLength;
}, YX = async (t, e) => {
  const r = Oe.toFiniteNumber(t.getContentLength());
  return r ?? GX(e);
}, JX = pp && (async (t) => {
  let {
    url: e,
    method: r,
    data: n,
    signal: i,
    cancelToken: s,
    timeout: o,
    onDownloadProgress: a,
    onUploadProgress: u,
    responseType: l,
    headers: d,
    withCredentials: p = "same-origin",
    fetchOptions: w
  } = LS(t);
  l = l ? (l + "").toLowerCase() : "text";
  let A = qX([i, s && s.toAbortSignal()], o), P;
  const N = A && A.unsubscribe && (() => {
    A.unsubscribe();
  });
  let L;
  try {
    if (u && VX && r !== "get" && r !== "head" && (L = await YX(d, n)) !== 0) {
      let V = new Request(e, {
        method: "POST",
        body: n,
        duplex: "half"
      }), te;
      if (Oe.isFormData(n) && (te = V.headers.get("content-type")) && d.setContentType(te), V.body) {
        const [R, K] = F6(
          L,
          g0(j6(u))
        );
        n = q6(V.body, z6, R, K);
      }
    }
    Oe.isString(p) || (p = p ? "include" : "omit");
    const $ = "credentials" in Request.prototype;
    P = new Request(e, {
      ...w,
      signal: A,
      method: r.toUpperCase(),
      headers: d.normalize().toJSON(),
      body: n,
      duplex: "half",
      credentials: $ ? p : void 0
    });
    let B = await fetch(P);
    const H = V1 && (l === "stream" || l === "response");
    if (V1 && (a || H && N)) {
      const V = {};
      ["status", "statusText", "headers"].forEach((ge) => {
        V[ge] = B[ge];
      });
      const te = Oe.toFiniteNumber(B.headers.get("content-length")), [R, K] = a && F6(
        te,
        g0(j6(a), !0)
      ) || [];
      B = new Response(
        q6(B.body, z6, R, () => {
          K && K(), N && N();
        }),
        V
      );
    }
    l = l || "text";
    let W = await m0[Oe.findKey(m0, l) || "text"](B, t);
    return !H && N && N(), await new Promise((V, te) => {
      OS(V, te, {
        data: W,
        headers: yi.from(B.headers),
        status: B.status,
        statusText: B.statusText,
        config: t,
        request: P
      });
    });
  } catch ($) {
    throw N && N(), $ && $.name === "TypeError" && /fetch/i.test($.message) ? Object.assign(
      new or("Network Error", or.ERR_NETWORK, t, P),
      {
        cause: $.cause || $
      }
    ) : or.from($, $ && $.code, t, P);
  }
}), G1 = {
  http: lX,
  xhr: UX,
  fetch: JX
};
Oe.forEach(G1, (t, e) => {
  if (t) {
    try {
      Object.defineProperty(t, "name", { value: e });
    } catch {
    }
    Object.defineProperty(t, "adapterName", { value: e });
  }
});
const W6 = (t) => `- ${t}`, XX = (t) => Oe.isFunction(t) || t === null || t === !1, BS = {
  getAdapter: (t) => {
    t = Oe.isArray(t) ? t : [t];
    const { length: e } = t;
    let r, n;
    const i = {};
    for (let s = 0; s < e; s++) {
      r = t[s];
      let o;
      if (n = r, !XX(r) && (n = G1[(o = String(r)).toLowerCase()], n === void 0))
        throw new or(`Unknown adapter '${o}'`);
      if (n)
        break;
      i[o || "#" + s] = n;
    }
    if (!n) {
      const s = Object.entries(i).map(
        ([a, u]) => `adapter ${a} ` + (u === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = e ? s.length > 1 ? `since :
` + s.map(W6).join(`
`) : " " + W6(s[0]) : "as no adapter specified";
      throw new or(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return n;
  },
  adapters: G1
};
function Rm(t) {
  if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)
    throw new Hu(null, t);
}
function H6(t) {
  return Rm(t), t.headers = yi.from(t.headers), t.data = Tm.call(
    t,
    t.transformRequest
  ), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), BS.getAdapter(t.adapter || oh.adapter)(t).then(function(n) {
    return Rm(t), n.data = Tm.call(
      t,
      t.transformResponse,
      n
    ), n.headers = yi.from(n.headers), n;
  }, function(n) {
    return DS(n) || (Rm(t), n && n.response && (n.response.data = Tm.call(
      t,
      t.transformResponse,
      n.response
    ), n.response.headers = yi.from(n.response.headers))), Promise.reject(n);
  });
}
const FS = "1.7.8", gp = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
  gp[t] = function(n) {
    return typeof n === t || "a" + (e < 1 ? "n " : " ") + t;
  };
});
const K6 = {};
gp.transitional = function(e, r, n) {
  function i(s, o) {
    return "[Axios v" + FS + "] Transitional option '" + s + "'" + o + (n ? ". " + n : "");
  }
  return (s, o, a) => {
    if (e === !1)
      throw new or(
        i(o, " has been removed" + (r ? " in " + r : "")),
        or.ERR_DEPRECATED
      );
    return r && !K6[o] && (K6[o] = !0, console.warn(
      i(
        o,
        " has been deprecated since v" + r + " and will be removed in the near future"
      )
    )), e ? e(s, o, a) : !0;
  };
};
gp.spelling = function(e) {
  return (r, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0);
};
function ZX(t, e, r) {
  if (typeof t != "object")
    throw new or("options must be an object", or.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(t);
  let i = n.length;
  for (; i-- > 0; ) {
    const s = n[i], o = e[s];
    if (o) {
      const a = t[s], u = a === void 0 || o(a, s, t);
      if (u !== !0)
        throw new or("option " + s + " must be " + u, or.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (r !== !0)
      throw new or("Unknown option " + s, or.ERR_BAD_OPTION);
  }
}
const Bd = {
  assertOptions: ZX,
  validators: gp
}, Bs = Bd.validators;
let cc = class {
  constructor(e) {
    this.defaults = e, this.interceptors = {
      request: new $6(),
      response: new $6()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, r) {
    try {
      return await this._request(e, r);
    } catch (n) {
      if (n instanceof Error) {
        let i = {};
        Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error();
        const s = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? s && !String(n.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + s) : n.stack = s;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(e, r) {
    typeof e == "string" ? (r = r || {}, r.url = e) : r = e || {}, r = mc(this.defaults, r);
    const { transitional: n, paramsSerializer: i, headers: s } = r;
    n !== void 0 && Bd.assertOptions(n, {
      silentJSONParsing: Bs.transitional(Bs.boolean),
      forcedJSONParsing: Bs.transitional(Bs.boolean),
      clarifyTimeoutError: Bs.transitional(Bs.boolean)
    }, !1), i != null && (Oe.isFunction(i) ? r.paramsSerializer = {
      serialize: i
    } : Bd.assertOptions(i, {
      encode: Bs.function,
      serialize: Bs.function
    }, !0)), Bd.assertOptions(r, {
      baseUrl: Bs.spelling("baseURL"),
      withXsrfToken: Bs.spelling("withXSRFToken")
    }, !0), r.method = (r.method || this.defaults.method || "get").toLowerCase();
    let o = s && Oe.merge(
      s.common,
      s[r.method]
    );
    s && Oe.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (P) => {
        delete s[P];
      }
    ), r.headers = yi.concat(o, s);
    const a = [];
    let u = !0;
    this.interceptors.request.forEach(function(N) {
      typeof N.runWhen == "function" && N.runWhen(r) === !1 || (u = u && N.synchronous, a.unshift(N.fulfilled, N.rejected));
    });
    const l = [];
    this.interceptors.response.forEach(function(N) {
      l.push(N.fulfilled, N.rejected);
    });
    let d, p = 0, w;
    if (!u) {
      const P = [H6.bind(this), void 0];
      for (P.unshift.apply(P, a), P.push.apply(P, l), w = P.length, d = Promise.resolve(r); p < w; )
        d = d.then(P[p++], P[p++]);
      return d;
    }
    w = a.length;
    let A = r;
    for (p = 0; p < w; ) {
      const P = a[p++], N = a[p++];
      try {
        A = P(A);
      } catch (L) {
        N.call(this, L);
        break;
      }
    }
    try {
      d = H6.call(this, A);
    } catch (P) {
      return Promise.reject(P);
    }
    for (p = 0, w = l.length; p < w; )
      d = d.then(l[p++], l[p++]);
    return d;
  }
  getUri(e) {
    e = mc(this.defaults, e);
    const r = NS(e.baseURL, e.url);
    return CS(r, e.params, e.paramsSerializer);
  }
};
Oe.forEach(["delete", "get", "head", "options"], function(e) {
  cc.prototype[e] = function(r, n) {
    return this.request(mc(n || {}, {
      method: e,
      url: r,
      data: (n || {}).data
    }));
  };
});
Oe.forEach(["post", "put", "patch"], function(e) {
  function r(n) {
    return function(s, o, a) {
      return this.request(mc(a || {}, {
        method: e,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: o
      }));
    };
  }
  cc.prototype[e] = r(), cc.prototype[e + "Form"] = r(!0);
});
let QX = class jS {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let r;
    this.promise = new Promise(function(s) {
      r = s;
    });
    const n = this;
    this.promise.then((i) => {
      if (!n._listeners) return;
      let s = n._listeners.length;
      for (; s-- > 0; )
        n._listeners[s](i);
      n._listeners = null;
    }), this.promise.then = (i) => {
      let s;
      const o = new Promise((a) => {
        n.subscribe(a), s = a;
      }).then(i);
      return o.cancel = function() {
        n.unsubscribe(s);
      }, o;
    }, e(function(s, o, a) {
      n.reason || (n.reason = new Hu(s, o, a), r(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const r = this._listeners.indexOf(e);
    r !== -1 && this._listeners.splice(r, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), r = (n) => {
      e.abort(n);
    };
    return this.subscribe(r), e.signal.unsubscribe = () => this.unsubscribe(r), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new jS(function(i) {
        e = i;
      }),
      cancel: e
    };
  }
};
function eZ(t) {
  return function(r) {
    return t.apply(null, r);
  };
}
function tZ(t) {
  return Oe.isObject(t) && t.isAxiosError === !0;
}
const Y1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Y1).forEach(([t, e]) => {
  Y1[e] = t;
});
function US(t) {
  const e = new cc(t), r = vS(cc.prototype.request, e);
  return Oe.extend(r, cc.prototype, e, { allOwnKeys: !0 }), Oe.extend(r, e, null, { allOwnKeys: !0 }), r.create = function(i) {
    return US(mc(t, i));
  }, r;
}
const mn = US(oh);
mn.Axios = cc;
mn.CanceledError = Hu;
mn.CancelToken = QX;
mn.isCancel = DS;
mn.VERSION = FS;
mn.toFormData = dp;
mn.AxiosError = or;
mn.Cancel = mn.CanceledError;
mn.all = function(e) {
  return Promise.all(e);
};
mn.spread = eZ;
mn.isAxiosError = tZ;
mn.mergeConfig = mc;
mn.AxiosHeaders = yi;
mn.formToJSON = (t) => RS(Oe.isHTMLForm(t) ? new FormData(t) : t);
mn.getAdapter = BS.getAdapter;
mn.HttpStatusCode = Y1;
mn.default = mn;
const {
  Axios: eoe,
  AxiosError: rZ,
  CanceledError: toe,
  isCancel: roe,
  CancelToken: noe,
  VERSION: ioe,
  all: soe,
  Cancel: ooe,
  isAxiosError: aoe,
  spread: coe,
  toFormData: uoe,
  AxiosHeaders: foe,
  HttpStatusCode: loe,
  formToJSON: hoe,
  getAdapter: doe,
  mergeConfig: poe
} = mn, qS = mn.create({
  timeout: 6e4,
  headers: {
    "Content-Type": "application/json",
    token: localStorage.getItem("auth")
  }
});
function nZ(t) {
  var e, r, n;
  if (((e = t.data) == null ? void 0 : e.success) !== !0) {
    const i = new rZ(
      (r = t.data) == null ? void 0 : r.errorMessage,
      (n = t.data) == null ? void 0 : n.errorCode,
      t.config,
      t.request,
      t
    );
    return Promise.reject(i);
  } else
    return t;
}
qS.interceptors.response.use(
  nZ
);
class iZ {
  constructor(e) {
    Ds(this, "_apiBase", "");
    this.request = e;
  }
  setApiBase(e) {
    this._apiBase = e || "";
  }
  async getNonce(e) {
    const { data: r } = await this.request.post(`${this._apiBase}/api/v2/user/nonce`, e);
    return r.data;
  }
  async getEmailCode(e) {
    const { data: r } = await this.request.post(`${this._apiBase}/api/v2/user/get_code`, e);
    return r.data;
  }
  async emailLogin(e) {
    return (await this.request.post(`${this._apiBase}/api/v2/user/login`, e)).data;
  }
  async walletLogin(e) {
    return (await this.request.post(`${this._apiBase}/api/v2/user/login`, e)).data;
  }
  async tonLogin(e) {
    return (await this.request.post(`${this._apiBase}/api/v2/user/login`, e)).data;
  }
  async bindEmail(e) {
    return (await this.request.post("/api/v2/user/account/bind", e)).data;
  }
  async bindTonWallet(e) {
    return (await this.request.post("/api/v2/user/account/bind", e)).data;
  }
  async bindEvmWallet(e) {
    return (await this.request.post("/api/v2/user/account/bind", e)).data;
  }
}
const qo = new iZ(qS), sZ = {
  projectId: "7a4434fefbcc9af474fb5c995e47d286",
  metadata: {
    name: "codatta",
    description: "codatta",
    url: "https://codatta.io/",
    icons: ["https://avatars.githubusercontent.com/u/171659315"]
  }
}, oZ = AJ({
  appName: "codatta",
  appLogoUrl: "https://avatars.githubusercontent.com/u/171659315"
}), zS = Ma({
  saveLastUsedWallet: () => {
  },
  lastUsedWallet: null,
  wallets: [],
  initialized: !1,
  featuredWallets: []
});
function mp() {
  return Tn(zS);
}
function goe(t) {
  const { apiBaseUrl: e } = t, [r, n] = Gt([]), [i, s] = Gt([]), [o, a] = Gt(null), [u, l] = Gt(!1), d = (A) => {
    console.log("saveLastUsedWallet", A);
  };
  function p(A) {
    const P = A.filter(($) => $.featured || $.installed), N = A.filter(($) => !$.featured && !$.installed), L = [...P, ...N];
    n(L), s(P);
  }
  async function w() {
    const A = [], P = /* @__PURE__ */ new Map();
    UR.forEach((L) => {
      const $ = new vl(L);
      L.name === "Coinbase Wallet" && $.EIP6963Detected({
        info: { name: "Coinbase Wallet", uuid: "coinbase", icon: L.image, rdns: "coinbase" },
        provider: oZ.getProvider()
      }), P.set($.key, $), A.push($);
    }), (await jG()).forEach((L) => {
      const $ = P.get(L.info.name);
      if ($)
        $.EIP6963Detected(L);
      else {
        const B = new vl(L);
        P.set(B.key, B), A.push(B);
      }
    });
    try {
      const L = JSON.parse(localStorage.getItem("xn-last-used-info") || "{}"), $ = P.get(L.key);
      if ($) {
        if ($.lastUsed = !0, L.provider === "UniversalProvider") {
          const B = await AE.init(sZ);
          B.session && $.setUniversalProvider(B);
        }
        a($);
      }
    } catch (L) {
      console.log(L);
    }
    p(A), l(!0);
  }
  return Dn(() => {
    w(), qo.setApiBase(e);
  }, []), /* @__PURE__ */ fe.jsx(
    zS.Provider,
    {
      value: {
        saveLastUsedWallet: d,
        wallets: r,
        initialized: u,
        lastUsedWallet: o,
        featuredWallets: i
      },
      children: t.children
    }
  );
}
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const aZ = (t) => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), WS = (...t) => t.filter((e, r, n) => !!e && e.trim() !== "" && n.indexOf(e) === r).join(" ").trim();
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var cZ = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const uZ = gv(
  ({
    color: t = "currentColor",
    size: e = 24,
    strokeWidth: r = 2,
    absoluteStrokeWidth: n,
    className: i = "",
    children: s,
    iconNode: o,
    ...a
  }, u) => qd(
    "svg",
    {
      ref: u,
      ...cZ,
      width: e,
      height: e,
      stroke: t,
      strokeWidth: n ? Number(r) * 24 / Number(e) : r,
      className: WS("lucide", i),
      ...a
    },
    [
      ...o.map(([l, d]) => qd(l, d)),
      ...Array.isArray(s) ? s : [s]
    ]
  )
);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ms = (t, e) => {
  const r = gv(
    ({ className: n, ...i }, s) => qd(uZ, {
      ref: s,
      iconNode: e,
      className: WS(`lucide-${aZ(t)}`, n),
      ...i
    })
  );
  return r.displayName = `${t}`, r;
};
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const fZ = Ms("ArrowLeft", [
  ["path", { d: "m12 19-7-7 7-7", key: "1l729n" }],
  ["path", { d: "M19 12H5", key: "x3x0zl" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const HS = Ms("ArrowRight", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const lZ = Ms("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const hZ = Ms("CircleCheckBig", [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const dZ = Ms("Download", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }],
  ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const pZ = Ms("Globe", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" }],
  ["path", { d: "M2 12h20", key: "9i4pu4" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const KS = Ms("Laptop", [
  [
    "path",
    {
      d: "M20 16V7a2 2 0 0 0-2-2H6a2 2 0 0 0-2 2v9m16 0H4m16 0 1.28 2.55a1 1 0 0 1-.9 1.45H3.62a1 1 0 0 1-.9-1.45L4 16",
      key: "tarvll"
    }
  ]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const gZ = Ms("Link2", [
  ["path", { d: "M9 17H7A5 5 0 0 1 7 7h2", key: "8i5ue5" }],
  ["path", { d: "M15 7h2a5 5 0 1 1 0 10h-2", key: "1b9ql8" }],
  ["line", { x1: "8", x2: "16", y1: "12", y2: "12", key: "1jonct" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const _a = Ms("LoaderCircle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const VS = Ms("Mail", [
  ["rect", { width: "20", height: "16", x: "2", y: "4", rx: "2", key: "18n3k1" }],
  ["path", { d: "m22 7-8.97 5.7a1.94 1.94 0 0 1-2.06 0L2 7", key: "1ocrg3" }]
]);
/**
 * @license lucide-react v0.460.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const GS = Ms("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
]), V6 = /* @__PURE__ */ new Set();
function vp(t, e, r) {
  t || V6.has(e) || (console.warn(e), V6.add(e));
}
function mZ(t) {
  if (typeof Proxy > "u")
    return t;
  const e = /* @__PURE__ */ new Map(), r = (...n) => (process.env.NODE_ENV !== "production" && vp(!1, "motion() is deprecated. Use motion.create() instead."), t(...n));
  return new Proxy(r, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (n, i) => i === "create" ? t : (e.has(i) || e.set(i, t(i)), e.get(i))
  });
}
function bp(t) {
  return t !== null && typeof t == "object" && typeof t.start == "function";
}
const J1 = (t) => Array.isArray(t);
function YS(t, e) {
  if (!Array.isArray(e))
    return !1;
  const r = e.length;
  if (r !== t.length)
    return !1;
  for (let n = 0; n < r; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function Il(t) {
  return typeof t == "string" || Array.isArray(t);
}
function G6(t) {
  const e = [{}, {}];
  return t == null || t.values.forEach((r, n) => {
    e[0][n] = r.get(), e[1][n] = r.getVelocity();
  }), e;
}
function Mb(t, e, r, n) {
  if (typeof e == "function") {
    const [i, s] = G6(n);
    e = e(r !== void 0 ? r : t.custom, i, s);
  }
  if (typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function") {
    const [i, s] = G6(n);
    e = e(r !== void 0 ? r : t.custom, i, s);
  }
  return e;
}
function yp(t, e, r) {
  const n = t.getProps();
  return Mb(n, e, r !== void 0 ? r : n.custom, t);
}
const Ib = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], Cb = ["initial", ...Ib], ah = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], Ac = new Set(ah), Vs = (t) => t * 1e3, Do = (t) => t / 1e3, vZ = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, bZ = (t) => ({
  type: "spring",
  stiffness: 550,
  damping: t === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), yZ = {
  type: "keyframes",
  duration: 0.8
}, wZ = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, xZ = (t, { keyframes: e }) => e.length > 2 ? yZ : Ac.has(t) ? t.startsWith("scale") ? bZ(e[1]) : vZ : wZ;
function Tb(t, e) {
  return t ? t[e] || t.default || t : void 0;
}
const _Z = {
  useManualTiming: !1
}, EZ = (t) => t !== null;
function wp(t, { repeat: e, repeatType: r = "loop" }, n) {
  const i = t.filter(EZ), s = e && r !== "loop" && e % 2 === 1 ? 0 : i.length - 1;
  return !s || n === void 0 ? i[s] : n;
}
const Un = (t) => t;
function SZ(t) {
  let e = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), n = !1, i = !1;
  const s = /* @__PURE__ */ new WeakSet();
  let o = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function a(l) {
    s.has(l) && (u.schedule(l), t()), l(o);
  }
  const u = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (l, d = !1, p = !1) => {
      const A = p && n ? e : r;
      return d && s.add(l), A.has(l) || A.add(l), l;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (l) => {
      r.delete(l), s.delete(l);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (l) => {
      if (o = l, n) {
        i = !0;
        return;
      }
      n = !0, [e, r] = [r, e], r.clear(), e.forEach(a), n = !1, i && (i = !1, u.process(l));
    }
  };
  return u;
}
const gd = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
], AZ = 40;
function JS(t, e) {
  let r = !1, n = !0;
  const i = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, s = () => r = !0, o = gd.reduce(($, B) => ($[B] = SZ(s), $), {}), { read: a, resolveKeyframes: u, update: l, preRender: d, render: p, postRender: w } = o, A = () => {
    const $ = performance.now();
    r = !1, i.delta = n ? 1e3 / 60 : Math.max(Math.min($ - i.timestamp, AZ), 1), i.timestamp = $, i.isProcessing = !0, a.process(i), u.process(i), l.process(i), d.process(i), p.process(i), w.process(i), i.isProcessing = !1, r && e && (n = !1, t(A));
  }, P = () => {
    r = !0, n = !0, i.isProcessing || t(A);
  };
  return { schedule: gd.reduce(($, B) => {
    const H = o[B];
    return $[B] = (W, V = !1, te = !1) => (r || P(), H.schedule(W, V, te)), $;
  }, {}), cancel: ($) => {
    for (let B = 0; B < gd.length; B++)
      o[gd[B]].cancel($);
  }, state: i, steps: o };
}
const { schedule: Lr, cancel: Ea, state: Fn, steps: Dm } = JS(typeof requestAnimationFrame < "u" ? requestAnimationFrame : Un, !0), XS = (t, e, r) => (((1 - 3 * r + 3 * e) * t + (3 * r - 6 * e)) * t + 3 * e) * t, PZ = 1e-7, MZ = 12;
function IZ(t, e, r, n, i) {
  let s, o, a = 0;
  do
    o = e + (r - e) / 2, s = XS(o, n, i) - t, s > 0 ? r = o : e = o;
  while (Math.abs(s) > PZ && ++a < MZ);
  return o;
}
function ch(t, e, r, n) {
  if (t === e && r === n)
    return Un;
  const i = (s) => IZ(s, 0, 1, t, r);
  return (s) => s === 0 || s === 1 ? s : XS(i(s), e, n);
}
const ZS = (t) => (e) => e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, QS = (t) => (e) => 1 - t(1 - e), e7 = /* @__PURE__ */ ch(0.33, 1.53, 0.69, 0.99), Rb = /* @__PURE__ */ QS(e7), t7 = /* @__PURE__ */ ZS(Rb), r7 = (t) => (t *= 2) < 1 ? 0.5 * Rb(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))), Db = (t) => 1 - Math.sin(Math.acos(t)), n7 = QS(Db), i7 = ZS(Db), s7 = (t) => /^0[^.\s]+$/u.test(t);
function CZ(t) {
  return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || s7(t) : !0;
}
let Ku = Un, zo = Un;
process.env.NODE_ENV !== "production" && (Ku = (t, e) => {
  !t && typeof console < "u" && console.warn(e);
}, zo = (t, e) => {
  if (!t)
    throw new Error(e);
});
const o7 = (t) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t), a7 = (t) => (e) => typeof e == "string" && e.startsWith(t), c7 = /* @__PURE__ */ a7("--"), TZ = /* @__PURE__ */ a7("var(--"), Ob = (t) => TZ(t) ? RZ.test(t.split("/*")[0].trim()) : !1, RZ = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, DZ = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function OZ(t) {
  const e = DZ.exec(t);
  if (!e)
    return [,];
  const [, r, n, i] = e;
  return [`--${r ?? n}`, i];
}
const NZ = 4;
function u7(t, e, r = 1) {
  zo(r <= NZ, `Max CSS variable fallback depth detected in property "${t}". This may indicate a circular fallback dependency.`);
  const [n, i] = OZ(t);
  if (!n)
    return;
  const s = window.getComputedStyle(e).getPropertyValue(n);
  if (s) {
    const o = s.trim();
    return o7(o) ? parseFloat(o) : o;
  }
  return Ob(i) ? u7(i, e, r + 1) : i;
}
const Sa = (t, e, r) => r > e ? e : r < t ? t : r, Vu = {
  test: (t) => typeof t == "number",
  parse: parseFloat,
  transform: (t) => t
}, Cl = {
  ...Vu,
  transform: (t) => Sa(0, 1, t)
}, md = {
  ...Vu,
  default: 1
}, uh = (t) => ({
  test: (e) => typeof e == "string" && e.endsWith(t) && e.split(" ").length === 1,
  parse: parseFloat,
  transform: (e) => `${e}${t}`
}), ca = /* @__PURE__ */ uh("deg"), Gs = /* @__PURE__ */ uh("%"), Vt = /* @__PURE__ */ uh("px"), LZ = /* @__PURE__ */ uh("vh"), kZ = /* @__PURE__ */ uh("vw"), Y6 = {
  ...Gs,
  parse: (t) => Gs.parse(t) / 100,
  transform: (t) => Gs.transform(t * 100)
}, $Z = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]), J6 = (t) => t === Vu || t === Vt, X6 = (t, e) => parseFloat(t.split(", ")[e]), Z6 = (t, e) => (r, { transform: n }) => {
  if (n === "none" || !n)
    return 0;
  const i = n.match(/^matrix3d\((.+)\)$/u);
  if (i)
    return X6(i[1], e);
  {
    const s = n.match(/^matrix\((.+)\)$/u);
    return s ? X6(s[1], t) : 0;
  }
}, BZ = /* @__PURE__ */ new Set(["x", "y", "z"]), FZ = ah.filter((t) => !BZ.has(t));
function jZ(t) {
  const e = [];
  return FZ.forEach((r) => {
    const n = t.getValue(r);
    n !== void 0 && (e.push([r, n.get()]), n.set(r.startsWith("scale") ? 1 : 0));
  }), e;
}
const Mu = {
  // Dimensions
  width: ({ x: t }, { paddingLeft: e = "0", paddingRight: r = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(r),
  height: ({ y: t }, { paddingTop: e = "0", paddingBottom: r = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(r),
  top: (t, { top: e }) => parseFloat(e),
  left: (t, { left: e }) => parseFloat(e),
  bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min),
  right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min),
  // Transform
  x: Z6(4, 13),
  y: Z6(5, 14)
};
Mu.translateX = Mu.x;
Mu.translateY = Mu.y;
const f7 = (t) => (e) => e.test(t), UZ = {
  test: (t) => t === "auto",
  parse: (t) => t
}, l7 = [Vu, Vt, Gs, ca, kZ, LZ, UZ], Q6 = (t) => l7.find(f7(t)), uc = /* @__PURE__ */ new Set();
let X1 = !1, Z1 = !1;
function h7() {
  if (Z1) {
    const t = Array.from(uc).filter((n) => n.needsMeasurement), e = new Set(t.map((n) => n.element)), r = /* @__PURE__ */ new Map();
    e.forEach((n) => {
      const i = jZ(n);
      i.length && (r.set(n, i), n.render());
    }), t.forEach((n) => n.measureInitialState()), e.forEach((n) => {
      n.render();
      const i = r.get(n);
      i && i.forEach(([s, o]) => {
        var a;
        (a = n.getValue(s)) === null || a === void 0 || a.set(o);
      });
    }), t.forEach((n) => n.measureEndState()), t.forEach((n) => {
      n.suspendedScrollY !== void 0 && window.scrollTo(0, n.suspendedScrollY);
    });
  }
  Z1 = !1, X1 = !1, uc.forEach((t) => t.complete()), uc.clear();
}
function d7() {
  uc.forEach((t) => {
    t.readKeyframes(), t.needsMeasurement && (Z1 = !0);
  });
}
function qZ() {
  d7(), h7();
}
class Nb {
  constructor(e, r, n, i, s, o = !1) {
    this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = r, this.name = n, this.motionValue = i, this.element = s, this.isAsync = o;
  }
  scheduleResolve() {
    this.isScheduled = !0, this.isAsync ? (uc.add(this), X1 || (X1 = !0, Lr.read(d7), Lr.resolveKeyframes(h7))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, name: r, element: n, motionValue: i } = this;
    for (let s = 0; s < e.length; s++)
      if (e[s] === null)
        if (s === 0) {
          const o = i == null ? void 0 : i.get(), a = e[e.length - 1];
          if (o !== void 0)
            e[0] = o;
          else if (n && r) {
            const u = n.readValue(r, a);
            u != null && (e[0] = u);
          }
          e[0] === void 0 && (e[0] = a), i && o === void 0 && i.set(e[0]);
        } else
          e[s] = e[s - 1];
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), uc.delete(this);
  }
  cancel() {
    this.isComplete || (this.isScheduled = !1, uc.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const Yf = (t) => Math.round(t * 1e5) / 1e5, Lb = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function zZ(t) {
  return t == null;
}
const WZ = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, kb = (t, e) => (r) => !!(typeof r == "string" && WZ.test(r) && r.startsWith(t) || e && !zZ(r) && Object.prototype.hasOwnProperty.call(r, e)), p7 = (t, e, r) => (n) => {
  if (typeof n != "string")
    return n;
  const [i, s, o, a] = n.match(Lb);
  return {
    [t]: parseFloat(i),
    [e]: parseFloat(s),
    [r]: parseFloat(o),
    alpha: a !== void 0 ? parseFloat(a) : 1
  };
}, HZ = (t) => Sa(0, 255, t), Om = {
  ...Vu,
  transform: (t) => Math.round(HZ(t))
}, oc = {
  test: /* @__PURE__ */ kb("rgb", "red"),
  parse: /* @__PURE__ */ p7("red", "green", "blue"),
  transform: ({ red: t, green: e, blue: r, alpha: n = 1 }) => "rgba(" + Om.transform(t) + ", " + Om.transform(e) + ", " + Om.transform(r) + ", " + Yf(Cl.transform(n)) + ")"
};
function KZ(t) {
  let e = "", r = "", n = "", i = "";
  return t.length > 5 ? (e = t.substring(1, 3), r = t.substring(3, 5), n = t.substring(5, 7), i = t.substring(7, 9)) : (e = t.substring(1, 2), r = t.substring(2, 3), n = t.substring(3, 4), i = t.substring(4, 5), e += e, r += r, n += n, i += i), {
    red: parseInt(e, 16),
    green: parseInt(r, 16),
    blue: parseInt(n, 16),
    alpha: i ? parseInt(i, 16) / 255 : 1
  };
}
const Q1 = {
  test: /* @__PURE__ */ kb("#"),
  parse: KZ,
  transform: oc.transform
}, eu = {
  test: /* @__PURE__ */ kb("hsl", "hue"),
  parse: /* @__PURE__ */ p7("hue", "saturation", "lightness"),
  transform: ({ hue: t, saturation: e, lightness: r, alpha: n = 1 }) => "hsla(" + Math.round(t) + ", " + Gs.transform(Yf(e)) + ", " + Gs.transform(Yf(r)) + ", " + Yf(Cl.transform(n)) + ")"
}, Yn = {
  test: (t) => oc.test(t) || Q1.test(t) || eu.test(t),
  parse: (t) => oc.test(t) ? oc.parse(t) : eu.test(t) ? eu.parse(t) : Q1.parse(t),
  transform: (t) => typeof t == "string" ? t : t.hasOwnProperty("red") ? oc.transform(t) : eu.transform(t)
}, VZ = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function GZ(t) {
  var e, r;
  return isNaN(t) && typeof t == "string" && (((e = t.match(Lb)) === null || e === void 0 ? void 0 : e.length) || 0) + (((r = t.match(VZ)) === null || r === void 0 ? void 0 : r.length) || 0) > 0;
}
const g7 = "number", m7 = "color", YZ = "var", JZ = "var(", e_ = "${}", XZ = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function Tl(t) {
  const e = t.toString(), r = [], n = {
    color: [],
    number: [],
    var: []
  }, i = [];
  let s = 0;
  const a = e.replace(XZ, (u) => (Yn.test(u) ? (n.color.push(s), i.push(m7), r.push(Yn.parse(u))) : u.startsWith(JZ) ? (n.var.push(s), i.push(YZ), r.push(u)) : (n.number.push(s), i.push(g7), r.push(parseFloat(u))), ++s, e_)).split(e_);
  return { values: r, split: a, indexes: n, types: i };
}
function v7(t) {
  return Tl(t).values;
}
function b7(t) {
  const { split: e, types: r } = Tl(t), n = e.length;
  return (i) => {
    let s = "";
    for (let o = 0; o < n; o++)
      if (s += e[o], i[o] !== void 0) {
        const a = r[o];
        a === g7 ? s += Yf(i[o]) : a === m7 ? s += Yn.transform(i[o]) : s += i[o];
      }
    return s;
  };
}
const ZZ = (t) => typeof t == "number" ? 0 : t;
function QZ(t) {
  const e = v7(t);
  return b7(t)(e.map(ZZ));
}
const Aa = {
  test: GZ,
  parse: v7,
  createTransformer: b7,
  getAnimatableNone: QZ
}, eQ = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function tQ(t) {
  const [e, r] = t.slice(0, -1).split("(");
  if (e === "drop-shadow")
    return t;
  const [n] = r.match(Lb) || [];
  if (!n)
    return t;
  const i = r.replace(n, "");
  let s = eQ.has(e) ? 1 : 0;
  return n !== r && (s *= 100), e + "(" + s + i + ")";
}
const rQ = /\b([a-z-]*)\(.*?\)/gu, ev = {
  ...Aa,
  getAnimatableNone: (t) => {
    const e = t.match(rQ);
    return e ? e.map(tQ).join(" ") : t;
  }
}, nQ = {
  // Border props
  borderWidth: Vt,
  borderTopWidth: Vt,
  borderRightWidth: Vt,
  borderBottomWidth: Vt,
  borderLeftWidth: Vt,
  borderRadius: Vt,
  radius: Vt,
  borderTopLeftRadius: Vt,
  borderTopRightRadius: Vt,
  borderBottomRightRadius: Vt,
  borderBottomLeftRadius: Vt,
  // Positioning props
  width: Vt,
  maxWidth: Vt,
  height: Vt,
  maxHeight: Vt,
  top: Vt,
  right: Vt,
  bottom: Vt,
  left: Vt,
  // Spacing props
  padding: Vt,
  paddingTop: Vt,
  paddingRight: Vt,
  paddingBottom: Vt,
  paddingLeft: Vt,
  margin: Vt,
  marginTop: Vt,
  marginRight: Vt,
  marginBottom: Vt,
  marginLeft: Vt,
  // Misc
  backgroundPositionX: Vt,
  backgroundPositionY: Vt
}, iQ = {
  rotate: ca,
  rotateX: ca,
  rotateY: ca,
  rotateZ: ca,
  scale: md,
  scaleX: md,
  scaleY: md,
  scaleZ: md,
  skew: ca,
  skewX: ca,
  skewY: ca,
  distance: Vt,
  translateX: Vt,
  translateY: Vt,
  translateZ: Vt,
  x: Vt,
  y: Vt,
  z: Vt,
  perspective: Vt,
  transformPerspective: Vt,
  opacity: Cl,
  originX: Y6,
  originY: Y6,
  originZ: Vt
}, t_ = {
  ...Vu,
  transform: Math.round
}, $b = {
  ...nQ,
  ...iQ,
  zIndex: t_,
  size: Vt,
  // SVG
  fillOpacity: Cl,
  strokeOpacity: Cl,
  numOctaves: t_
}, sQ = {
  ...$b,
  // Color props
  color: Yn,
  backgroundColor: Yn,
  outlineColor: Yn,
  fill: Yn,
  stroke: Yn,
  // Border props
  borderColor: Yn,
  borderTopColor: Yn,
  borderRightColor: Yn,
  borderBottomColor: Yn,
  borderLeftColor: Yn,
  filter: ev,
  WebkitFilter: ev
}, Bb = (t) => sQ[t];
function y7(t, e) {
  let r = Bb(t);
  return r !== ev && (r = Aa), r.getAnimatableNone ? r.getAnimatableNone(e) : void 0;
}
const oQ = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function aQ(t, e, r) {
  let n = 0, i;
  for (; n < t.length && !i; ) {
    const s = t[n];
    typeof s == "string" && !oQ.has(s) && Tl(s).values.length && (i = t[n]), n++;
  }
  if (i && r)
    for (const s of e)
      t[s] = y7(r, i);
}
class w7 extends Nb {
  constructor(e, r, n, i, s) {
    super(e, r, n, i, s, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: r, name: n } = this;
    if (!r || !r.current)
      return;
    super.readKeyframes();
    for (let u = 0; u < e.length; u++) {
      let l = e[u];
      if (typeof l == "string" && (l = l.trim(), Ob(l))) {
        const d = u7(l, r.current);
        d !== void 0 && (e[u] = d), u === e.length - 1 && (this.finalKeyframe = l);
      }
    }
    if (this.resolveNoneKeyframes(), !$Z.has(n) || e.length !== 2)
      return;
    const [i, s] = e, o = Q6(i), a = Q6(s);
    if (o !== a)
      if (J6(o) && J6(a))
        for (let u = 0; u < e.length; u++) {
          const l = e[u];
          typeof l == "string" && (e[u] = parseFloat(l));
        }
      else
        this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: r } = this, n = [];
    for (let i = 0; i < e.length; i++)
      CZ(e[i]) && n.push(i);
    n.length && aQ(e, n, r);
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: r, name: n } = this;
    if (!e || !e.current)
      return;
    n === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Mu[n](e.measureViewportBox(), window.getComputedStyle(e.current)), r[0] = this.measuredOrigin;
    const i = r[r.length - 1];
    i !== void 0 && e.getValue(n, i).jump(i, !1);
  }
  measureEndState() {
    var e;
    const { element: r, name: n, unresolvedKeyframes: i } = this;
    if (!r || !r.current)
      return;
    const s = r.getValue(n);
    s && s.jump(this.measuredOrigin, !1);
    const o = i.length - 1, a = i[o];
    i[o] = Mu[n](r.measureViewportBox(), window.getComputedStyle(r.current)), a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a), !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach(([u, l]) => {
      r.getValue(u).set(l);
    }), this.resolveNoneKeyframes();
  }
}
function Fb(t) {
  return typeof t == "function";
}
let Fd;
function cQ() {
  Fd = void 0;
}
const Ys = {
  now: () => (Fd === void 0 && Ys.set(Fn.isProcessing || _Z.useManualTiming ? Fn.timestamp : performance.now()), Fd),
  set: (t) => {
    Fd = t, queueMicrotask(cQ);
  }
}, r_ = (t, e) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && // It's animatable if we have a string
(Aa.test(t) || t === "0") && // And it contains numbers and/or colors
!t.startsWith("url("));
function uQ(t) {
  const e = t[0];
  if (t.length === 1)
    return !0;
  for (let r = 0; r < t.length; r++)
    if (t[r] !== e)
      return !0;
}
function fQ(t, e, r, n) {
  const i = t[0];
  if (i === null)
    return !1;
  if (e === "display" || e === "visibility")
    return !0;
  const s = t[t.length - 1], o = r_(i, e), a = r_(s, e);
  return Ku(o === a, `You are trying to animate ${e} from "${i}" to "${s}". ${i} is not an animatable value - to enable this animation set ${i} to a value animatable to ${s} via the \`style\` property.`), !o || !a ? !1 : uQ(t) || (r === "spring" || Fb(r)) && n;
}
const lQ = 40;
class x7 {
  constructor({ autoplay: e = !0, delay: r = 0, type: n = "keyframes", repeat: i = 0, repeatDelay: s = 0, repeatType: o = "loop", ...a }) {
    this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = Ys.now(), this.options = {
      autoplay: e,
      delay: r,
      type: n,
      repeat: i,
      repeatDelay: s,
      repeatType: o,
      ...a
    }, this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    return this.resolvedAt ? this.resolvedAt - this.createdAt > lQ ? this.resolvedAt : this.createdAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && qZ(), this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(e, r) {
    this.resolvedAt = Ys.now(), this.hasAttemptedResolve = !0;
    const { name: n, type: i, velocity: s, delay: o, onComplete: a, onUpdate: u, isGenerator: l } = this.options;
    if (!l && !fQ(e, n, i, s))
      if (o)
        this.options.duration = 0;
      else {
        u == null || u(wp(e, this.options, r)), a == null || a(), this.resolveFinishedPromise();
        return;
      }
    const d = this.initPlayback(e, r);
    d !== !1 && (this._resolved = {
      keyframes: e,
      finalKeyframe: r,
      ...d
    }, this.onPostResolved());
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(e, r) {
    return this.currentFinishedPromise.then(e, r);
  }
  flatten() {
    this.options.type = "keyframes", this.options.ease = "linear";
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((e) => {
      this.resolveFinishedPromise = e;
    });
  }
}
function _7(t, e) {
  return e ? t * (1e3 / e) : 0;
}
const hQ = 5;
function E7(t, e, r) {
  const n = Math.max(e - hQ, 0);
  return _7(r - t(n), e - n);
}
const Nm = 1e-3, dQ = 0.01, n_ = 10, pQ = 0.05, gQ = 1;
function mQ({ duration: t = 800, bounce: e = 0.25, velocity: r = 0, mass: n = 1 }) {
  let i, s;
  Ku(t <= Vs(n_), "Spring duration must be 10 seconds or less");
  let o = 1 - e;
  o = Sa(pQ, gQ, o), t = Sa(dQ, n_, Do(t)), o < 1 ? (i = (l) => {
    const d = l * o, p = d * t, w = d - r, A = tv(l, o), P = Math.exp(-p);
    return Nm - w / A * P;
  }, s = (l) => {
    const p = l * o * t, w = p * r + r, A = Math.pow(o, 2) * Math.pow(l, 2) * t, P = Math.exp(-p), N = tv(Math.pow(l, 2), o);
    return (-i(l) + Nm > 0 ? -1 : 1) * ((w - A) * P) / N;
  }) : (i = (l) => {
    const d = Math.exp(-l * t), p = (l - r) * t + 1;
    return -Nm + d * p;
  }, s = (l) => {
    const d = Math.exp(-l * t), p = (r - l) * (t * t);
    return d * p;
  });
  const a = 5 / t, u = bQ(i, s, a);
  if (t = Vs(t), isNaN(u))
    return {
      stiffness: 100,
      damping: 10,
      duration: t
    };
  {
    const l = Math.pow(u, 2) * n;
    return {
      stiffness: l,
      damping: o * 2 * Math.sqrt(n * l),
      duration: t
    };
  }
}
const vQ = 12;
function bQ(t, e, r) {
  let n = r;
  for (let i = 1; i < vQ; i++)
    n = n - t(n) / e(n);
  return n;
}
function tv(t, e) {
  return t * Math.sqrt(1 - e * e);
}
const yQ = ["duration", "bounce"], wQ = ["stiffness", "damping", "mass"];
function i_(t, e) {
  return e.some((r) => t[r] !== void 0);
}
function xQ(t) {
  let e = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...t
  };
  if (!i_(t, wQ) && i_(t, yQ)) {
    const r = mQ(t);
    e = {
      ...e,
      ...r,
      mass: 1
    }, e.isResolvedFromDuration = !0;
  }
  return e;
}
function S7({ keyframes: t, restDelta: e, restSpeed: r, ...n }) {
  const i = t[0], s = t[t.length - 1], o = { done: !1, value: i }, { stiffness: a, damping: u, mass: l, duration: d, velocity: p, isResolvedFromDuration: w } = xQ({
    ...n,
    velocity: -Do(n.velocity || 0)
  }), A = p || 0, P = u / (2 * Math.sqrt(a * l)), N = s - i, L = Do(Math.sqrt(a / l)), $ = Math.abs(N) < 5;
  r || (r = $ ? 0.01 : 2), e || (e = $ ? 5e-3 : 0.5);
  let B;
  if (P < 1) {
    const H = tv(L, P);
    B = (W) => {
      const V = Math.exp(-P * L * W);
      return s - V * ((A + P * L * N) / H * Math.sin(H * W) + N * Math.cos(H * W));
    };
  } else if (P === 1)
    B = (H) => s - Math.exp(-L * H) * (N + (A + L * N) * H);
  else {
    const H = L * Math.sqrt(P * P - 1);
    B = (W) => {
      const V = Math.exp(-P * L * W), te = Math.min(H * W, 300);
      return s - V * ((A + P * L * N) * Math.sinh(te) + H * N * Math.cosh(te)) / H;
    };
  }
  return {
    calculatedDuration: w && d || null,
    next: (H) => {
      const W = B(H);
      if (w)
        o.done = H >= d;
      else {
        let V = 0;
        P < 1 && (V = H === 0 ? Vs(A) : E7(B, H, W));
        const te = Math.abs(V) <= r, R = Math.abs(s - W) <= e;
        o.done = te && R;
      }
      return o.value = o.done ? s : W, o;
    }
  };
}
function s_({ keyframes: t, velocity: e = 0, power: r = 0.8, timeConstant: n = 325, bounceDamping: i = 10, bounceStiffness: s = 500, modifyTarget: o, min: a, max: u, restDelta: l = 0.5, restSpeed: d }) {
  const p = t[0], w = {
    done: !1,
    value: p
  }, A = (K) => a !== void 0 && K < a || u !== void 0 && K > u, P = (K) => a === void 0 ? u : u === void 0 || Math.abs(a - K) < Math.abs(u - K) ? a : u;
  let N = r * e;
  const L = p + N, $ = o === void 0 ? L : o(L);
  $ !== L && (N = $ - p);
  const B = (K) => -N * Math.exp(-K / n), H = (K) => $ + B(K), W = (K) => {
    const ge = B(K), Ee = H(K);
    w.done = Math.abs(ge) <= l, w.value = w.done ? $ : Ee;
  };
  let V, te;
  const R = (K) => {
    A(w.value) && (V = K, te = S7({
      keyframes: [w.value, P(w.value)],
      velocity: E7(H, K, w.value),
      // TODO: This should be passing * 1000
      damping: i,
      stiffness: s,
      restDelta: l,
      restSpeed: d
    }));
  };
  return R(0), {
    calculatedDuration: null,
    next: (K) => {
      let ge = !1;
      return !te && V === void 0 && (ge = !0, W(K), R(K)), V !== void 0 && K >= V ? te.next(K - V) : (!ge && W(K), w);
    }
  };
}
const _Q = /* @__PURE__ */ ch(0.42, 0, 1, 1), EQ = /* @__PURE__ */ ch(0, 0, 0.58, 1), A7 = /* @__PURE__ */ ch(0.42, 0, 0.58, 1), SQ = (t) => Array.isArray(t) && typeof t[0] != "number", jb = (t) => Array.isArray(t) && typeof t[0] == "number", o_ = {
  linear: Un,
  easeIn: _Q,
  easeInOut: A7,
  easeOut: EQ,
  circIn: Db,
  circInOut: i7,
  circOut: n7,
  backIn: Rb,
  backInOut: t7,
  backOut: e7,
  anticipate: r7
}, a_ = (t) => {
  if (jb(t)) {
    zo(t.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [e, r, n, i] = t;
    return ch(e, r, n, i);
  } else if (typeof t == "string")
    return zo(o_[t] !== void 0, `Invalid easing type '${t}'`), o_[t];
  return t;
}, AQ = (t, e) => (r) => e(t(r)), Oo = (...t) => t.reduce(AQ), Iu = (t, e, r) => {
  const n = e - t;
  return n === 0 ? 1 : (r - t) / n;
}, Qr = (t, e, r) => t + (e - t) * r;
function Lm(t, e, r) {
  return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? t + (e - t) * 6 * r : r < 1 / 2 ? e : r < 2 / 3 ? t + (e - t) * (2 / 3 - r) * 6 : t;
}
function PQ({ hue: t, saturation: e, lightness: r, alpha: n }) {
  t /= 360, e /= 100, r /= 100;
  let i = 0, s = 0, o = 0;
  if (!e)
    i = s = o = r;
  else {
    const a = r < 0.5 ? r * (1 + e) : r + e - r * e, u = 2 * r - a;
    i = Lm(u, a, t + 1 / 3), s = Lm(u, a, t), o = Lm(u, a, t - 1 / 3);
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(s * 255),
    blue: Math.round(o * 255),
    alpha: n
  };
}
function v0(t, e) {
  return (r) => r > 0 ? e : t;
}
const km = (t, e, r) => {
  const n = t * t, i = r * (e * e - n) + n;
  return i < 0 ? 0 : Math.sqrt(i);
}, MQ = [Q1, oc, eu], IQ = (t) => MQ.find((e) => e.test(t));
function c_(t) {
  const e = IQ(t);
  if (Ku(!!e, `'${t}' is not an animatable color. Use the equivalent color code instead.`), !e)
    return !1;
  let r = e.parse(t);
  return e === eu && (r = PQ(r)), r;
}
const u_ = (t, e) => {
  const r = c_(t), n = c_(e);
  if (!r || !n)
    return v0(t, e);
  const i = { ...r };
  return (s) => (i.red = km(r.red, n.red, s), i.green = km(r.green, n.green, s), i.blue = km(r.blue, n.blue, s), i.alpha = Qr(r.alpha, n.alpha, s), oc.transform(i));
}, rv = /* @__PURE__ */ new Set(["none", "hidden"]);
function CQ(t, e) {
  return rv.has(t) ? (r) => r <= 0 ? t : e : (r) => r >= 1 ? e : t;
}
function TQ(t, e) {
  return (r) => Qr(t, e, r);
}
function Ub(t) {
  return typeof t == "number" ? TQ : typeof t == "string" ? Ob(t) ? v0 : Yn.test(t) ? u_ : OQ : Array.isArray(t) ? P7 : typeof t == "object" ? Yn.test(t) ? u_ : RQ : v0;
}
function P7(t, e) {
  const r = [...t], n = r.length, i = t.map((s, o) => Ub(s)(s, e[o]));
  return (s) => {
    for (let o = 0; o < n; o++)
      r[o] = i[o](s);
    return r;
  };
}
function RQ(t, e) {
  const r = { ...t, ...e }, n = {};
  for (const i in r)
    t[i] !== void 0 && e[i] !== void 0 && (n[i] = Ub(t[i])(t[i], e[i]));
  return (i) => {
    for (const s in n)
      r[s] = n[s](i);
    return r;
  };
}
function DQ(t, e) {
  var r;
  const n = [], i = { color: 0, var: 0, number: 0 };
  for (let s = 0; s < e.values.length; s++) {
    const o = e.types[s], a = t.indexes[o][i[o]], u = (r = t.values[a]) !== null && r !== void 0 ? r : 0;
    n[s] = u, i[o]++;
  }
  return n;
}
const OQ = (t, e) => {
  const r = Aa.createTransformer(e), n = Tl(t), i = Tl(e);
  return n.indexes.var.length === i.indexes.var.length && n.indexes.color.length === i.indexes.color.length && n.indexes.number.length >= i.indexes.number.length ? rv.has(t) && !i.values.length || rv.has(e) && !n.values.length ? CQ(t, e) : Oo(P7(DQ(n, i), i.values), r) : (Ku(!0, `Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), v0(t, e));
};
function M7(t, e, r) {
  return typeof t == "number" && typeof e == "number" && typeof r == "number" ? Qr(t, e, r) : Ub(t)(t, e);
}
function NQ(t, e, r) {
  const n = [], i = r || M7, s = t.length - 1;
  for (let o = 0; o < s; o++) {
    let a = i(t[o], t[o + 1]);
    if (e) {
      const u = Array.isArray(e) ? e[o] || Un : e;
      a = Oo(u, a);
    }
    n.push(a);
  }
  return n;
}
function LQ(t, e, { clamp: r = !0, ease: n, mixer: i } = {}) {
  const s = t.length;
  if (zo(s === e.length, "Both input and output ranges must be the same length"), s === 1)
    return () => e[0];
  if (s === 2 && t[0] === t[1])
    return () => e[1];
  t[0] > t[s - 1] && (t = [...t].reverse(), e = [...e].reverse());
  const o = NQ(e, n, i), a = o.length, u = (l) => {
    let d = 0;
    if (a > 1)
      for (; d < t.length - 2 && !(l < t[d + 1]); d++)
        ;
    const p = Iu(t[d], t[d + 1], l);
    return o[d](p);
  };
  return r ? (l) => u(Sa(t[0], t[s - 1], l)) : u;
}
function kQ(t, e) {
  const r = t[t.length - 1];
  for (let n = 1; n <= e; n++) {
    const i = Iu(0, e, n);
    t.push(Qr(r, 1, i));
  }
}
function $Q(t) {
  const e = [0];
  return kQ(e, t.length - 1), e;
}
function BQ(t, e) {
  return t.map((r) => r * e);
}
function FQ(t, e) {
  return t.map(() => e || A7).splice(0, t.length - 1);
}
function b0({ duration: t = 300, keyframes: e, times: r, ease: n = "easeInOut" }) {
  const i = SQ(n) ? n.map(a_) : a_(n), s = {
    done: !1,
    value: e[0]
  }, o = BQ(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    r && r.length === e.length ? r : $Q(e),
    t
  ), a = LQ(o, e, {
    ease: Array.isArray(i) ? i : FQ(e, i)
  });
  return {
    calculatedDuration: t,
    next: (u) => (s.value = a(u), s.done = u >= t, s)
  };
}
const f_ = 2e4;
function jQ(t) {
  let e = 0;
  const r = 50;
  let n = t.next(e);
  for (; !n.done && e < f_; )
    e += r, n = t.next(e);
  return e >= f_ ? 1 / 0 : e;
}
const UQ = (t) => {
  const e = ({ timestamp: r }) => t(r);
  return {
    start: () => Lr.update(e, !0),
    stop: () => Ea(e),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => Fn.isProcessing ? Fn.timestamp : Ys.now()
  };
}, qQ = {
  decay: s_,
  inertia: s_,
  tween: b0,
  keyframes: b0,
  spring: S7
}, zQ = (t) => t / 100;
class qb extends x7 {
  constructor(e) {
    super(e), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
      if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
        return;
      this.teardown();
      const { onStop: u } = this.options;
      u && u();
    };
    const { name: r, motionValue: n, element: i, keyframes: s } = this.options, o = (i == null ? void 0 : i.KeyframeResolver) || Nb, a = (u, l) => this.onKeyframesResolved(u, l);
    this.resolver = new o(s, a, r, n, i), this.resolver.scheduleResolve();
  }
  flatten() {
    super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
  }
  initPlayback(e) {
    const { type: r = "keyframes", repeat: n = 0, repeatDelay: i = 0, repeatType: s, velocity: o = 0 } = this.options, a = Fb(r) ? r : qQ[r] || b0;
    let u, l;
    a !== b0 && typeof e[0] != "number" && (process.env.NODE_ENV !== "production" && zo(e.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${e}`), u = Oo(zQ, M7(e[0], e[1])), e = [0, 100]);
    const d = a({ ...this.options, keyframes: e });
    s === "mirror" && (l = a({
      ...this.options,
      keyframes: [...e].reverse(),
      velocity: -o
    })), d.calculatedDuration === null && (d.calculatedDuration = jQ(d));
    const { calculatedDuration: p } = d, w = p + i, A = w * (n + 1) - i;
    return {
      generator: d,
      mirroredGenerator: l,
      mapPercentToKeyframes: u,
      calculatedDuration: p,
      resolvedDuration: w,
      totalDuration: A
    };
  }
  onPostResolved() {
    const { autoplay: e = !0 } = this.options;
    this.play(), this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState;
  }
  tick(e, r = !1) {
    const { resolved: n } = this;
    if (!n) {
      const { keyframes: K } = this.options;
      return { done: !0, value: K[K.length - 1] };
    }
    const { finalKeyframe: i, generator: s, mirroredGenerator: o, mapPercentToKeyframes: a, keyframes: u, calculatedDuration: l, totalDuration: d, resolvedDuration: p } = n;
    if (this.startTime === null)
      return s.next(0);
    const { delay: w, repeat: A, repeatType: P, repeatDelay: N, onUpdate: L } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - d / this.speed, this.startTime)), r ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed;
    const $ = this.currentTime - w * (this.speed >= 0 ? 1 : -1), B = this.speed >= 0 ? $ < 0 : $ > d;
    this.currentTime = Math.max($, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = d);
    let H = this.currentTime, W = s;
    if (A) {
      const K = Math.min(this.currentTime, d) / p;
      let ge = Math.floor(K), Ee = K % 1;
      !Ee && K >= 1 && (Ee = 1), Ee === 1 && ge--, ge = Math.min(ge, A + 1), !!(ge % 2) && (P === "reverse" ? (Ee = 1 - Ee, N && (Ee -= N / p)) : P === "mirror" && (W = o)), H = Sa(0, 1, Ee) * p;
    }
    const V = B ? { done: !1, value: u[0] } : W.next(H);
    a && (V.value = a(V.value));
    let { done: te } = V;
    !B && l !== null && (te = this.speed >= 0 ? this.currentTime >= d : this.currentTime <= 0);
    const R = this.holdTime === null && (this.state === "finished" || this.state === "running" && te);
    return R && i !== void 0 && (V.value = wp(u, this.options, i)), L && L(V.value), R && this.finish(), V;
  }
  get duration() {
    const { resolved: e } = this;
    return e ? Do(e.calculatedDuration) : 0;
  }
  get time() {
    return Do(this.currentTime);
  }
  set time(e) {
    e = Vs(e), this.currentTime = e, this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(e) {
    const r = this.playbackSpeed !== e;
    this.playbackSpeed = e, r && (this.time = Do(this.currentTime));
  }
  play() {
    if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver: e = UQ, onPlay: r, startTime: n } = this.options;
    this.driver || (this.driver = e((s) => this.tick(s))), r && r();
    const i = this.driver.now();
    this.holdTime !== null ? this.startTime = i - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = i) : this.startTime = n ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    var e;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused", this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0;
  }
  complete() {
    this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.teardown(), this.state = "finished";
    const { onComplete: e } = this.options;
    e && e();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(e) {
    return this.startTime = 0, this.tick(e, !0);
  }
}
const WQ = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]), HQ = 10, KQ = (t, e) => {
  let r = "";
  const n = Math.max(Math.round(e / HQ), 2);
  for (let i = 0; i < n; i++)
    r += t(Iu(0, n - 1, i)) + ", ";
  return `linear(${r.substring(0, r.length - 2)})`;
};
function zb(t) {
  let e;
  return () => (e === void 0 && (e = t()), e);
}
const VQ = {
  linearEasing: void 0
};
function GQ(t, e) {
  const r = zb(t);
  return () => {
    var n;
    return (n = VQ[e]) !== null && n !== void 0 ? n : r();
  };
}
const y0 = /* @__PURE__ */ GQ(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing");
function I7(t) {
  return !!(typeof t == "function" && y0() || !t || typeof t == "string" && (t in nv || y0()) || jb(t) || Array.isArray(t) && t.every(I7));
}
const jf = ([t, e, r, n]) => `cubic-bezier(${t}, ${e}, ${r}, ${n})`, nv = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ jf([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ jf([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ jf([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ jf([0.33, 1.53, 0.69, 0.99])
};
function C7(t, e) {
  if (t)
    return typeof t == "function" && y0() ? KQ(t, e) : jb(t) ? jf(t) : Array.isArray(t) ? t.map((r) => C7(r, e) || nv.easeOut) : nv[t];
}
function YQ(t, e, r, { delay: n = 0, duration: i = 300, repeat: s = 0, repeatType: o = "loop", ease: a = "easeInOut", times: u } = {}) {
  const l = { [e]: r };
  u && (l.offset = u);
  const d = C7(a, i);
  return Array.isArray(d) && (l.easing = d), t.animate(l, {
    delay: n,
    duration: i,
    easing: Array.isArray(d) ? "linear" : d,
    fill: "both",
    iterations: s + 1,
    direction: o === "reverse" ? "alternate" : "normal"
  });
}
function l_(t, e) {
  t.timeline = e, t.onfinish = null;
}
const JQ = /* @__PURE__ */ zb(() => Object.hasOwnProperty.call(Element.prototype, "animate")), w0 = 10, XQ = 2e4;
function ZQ(t) {
  return Fb(t.type) || t.type === "spring" || !I7(t.ease);
}
function QQ(t, e) {
  const r = new qb({
    ...e,
    keyframes: t,
    repeat: 0,
    delay: 0,
    isGenerator: !0
  });
  let n = { done: !1, value: t[0] };
  const i = [];
  let s = 0;
  for (; !n.done && s < XQ; )
    n = r.sample(s), i.push(n.value), s += w0;
  return {
    times: void 0,
    keyframes: i,
    duration: s - w0,
    ease: "linear"
  };
}
const T7 = {
  anticipate: r7,
  backInOut: t7,
  circInOut: i7
};
function eee(t) {
  return t in T7;
}
class h_ extends x7 {
  constructor(e) {
    super(e);
    const { name: r, motionValue: n, element: i, keyframes: s } = this.options;
    this.resolver = new w7(s, (o, a) => this.onKeyframesResolved(o, a), r, n, i), this.resolver.scheduleResolve();
  }
  initPlayback(e, r) {
    var n;
    let { duration: i = 300, times: s, ease: o, type: a, motionValue: u, name: l, startTime: d } = this.options;
    if (!(!((n = u.owner) === null || n === void 0) && n.current))
      return !1;
    if (typeof o == "string" && y0() && eee(o) && (o = T7[o]), ZQ(this.options)) {
      const { onComplete: w, onUpdate: A, motionValue: P, element: N, ...L } = this.options, $ = QQ(e, L);
      e = $.keyframes, e.length === 1 && (e[1] = e[0]), i = $.duration, s = $.times, o = $.ease, a = "keyframes";
    }
    const p = YQ(u.owner.current, l, e, { ...this.options, duration: i, times: s, ease: o });
    return p.startTime = d ?? this.calcStartTime(), this.pendingTimeline ? (l_(p, this.pendingTimeline), this.pendingTimeline = void 0) : p.onfinish = () => {
      const { onComplete: w } = this.options;
      u.set(wp(e, this.options, r)), w && w(), this.cancel(), this.resolveFinishedPromise();
    }, {
      animation: p,
      duration: i,
      times: s,
      type: a,
      ease: o,
      keyframes: e
    };
  }
  get duration() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { duration: r } = e;
    return Do(r);
  }
  get time() {
    const { resolved: e } = this;
    if (!e)
      return 0;
    const { animation: r } = e;
    return Do(r.currentTime || 0);
  }
  set time(e) {
    const { resolved: r } = this;
    if (!r)
      return;
    const { animation: n } = r;
    n.currentTime = Vs(e);
  }
  get speed() {
    const { resolved: e } = this;
    if (!e)
      return 1;
    const { animation: r } = e;
    return r.playbackRate;
  }
  set speed(e) {
    const { resolved: r } = this;
    if (!r)
      return;
    const { animation: n } = r;
    n.playbackRate = e;
  }
  get state() {
    const { resolved: e } = this;
    if (!e)
      return "idle";
    const { animation: r } = e;
    return r.playState;
  }
  get startTime() {
    const { resolved: e } = this;
    if (!e)
      return null;
    const { animation: r } = e;
    return r.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(e) {
    if (!this._resolved)
      this.pendingTimeline = e;
    else {
      const { resolved: r } = this;
      if (!r)
        return Un;
      const { animation: n } = r;
      l_(n, e);
    }
    return Un;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: r } = e;
    r.playState === "finished" && this.updateFinishedPromise(), r.play();
  }
  pause() {
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: r } = e;
    r.pause();
  }
  stop() {
    if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved: e } = this;
    if (!e)
      return;
    const { animation: r, keyframes: n, duration: i, type: s, ease: o, times: a } = e;
    if (r.playState === "idle" || r.playState === "finished")
      return;
    if (this.time) {
      const { motionValue: l, onUpdate: d, onComplete: p, element: w, ...A } = this.options, P = new qb({
        ...A,
        keyframes: n,
        duration: i,
        type: s,
        ease: o,
        times: a,
        isGenerator: !0
      }), N = Vs(this.time);
      l.setWithVelocity(P.sample(N - w0).value, P.sample(N).value, w0);
    }
    const { onStop: u } = this.options;
    u && u(), this.cancel();
  }
  complete() {
    const { resolved: e } = this;
    e && e.animation.finish();
  }
  cancel() {
    const { resolved: e } = this;
    e && e.animation.cancel();
  }
  static supports(e) {
    const { motionValue: r, name: n, repeatDelay: i, repeatType: s, damping: o, type: a } = e;
    return JQ() && n && WQ.has(n) && r && r.owner && r.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !r.owner.getProps().onUpdate && !i && s !== "mirror" && o !== 0 && a !== "inertia";
  }
}
const tee = zb(() => window.ScrollTimeline !== void 0);
class ree {
  constructor(e) {
    this.stop = () => this.runAll("stop"), this.animations = e.filter(Boolean);
  }
  then(e, r) {
    return Promise.all(this.animations).then(e).catch(r);
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(e) {
    return this.animations[0][e];
  }
  setAll(e, r) {
    for (let n = 0; n < this.animations.length; n++)
      this.animations[n][e] = r;
  }
  attachTimeline(e, r) {
    const n = this.animations.map((i) => tee() && i.attachTimeline ? i.attachTimeline(e) : r(i));
    return () => {
      n.forEach((i, s) => {
        i && i(), this.animations[s].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(e) {
    this.setAll("time", e);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(e) {
    this.setAll("speed", e);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let e = 0;
    for (let r = 0; r < this.animations.length; r++)
      e = Math.max(e, this.animations[r].duration);
    return e;
  }
  runAll(e) {
    this.animations.forEach((r) => r[e]());
  }
  flatten() {
    this.runAll("flatten");
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
function nee({ when: t, delay: e, delayChildren: r, staggerChildren: n, staggerDirection: i, repeat: s, repeatType: o, repeatDelay: a, from: u, elapsed: l, ...d }) {
  return !!Object.keys(d).length;
}
const Wb = (t, e, r, n = {}, i, s) => (o) => {
  const a = Tb(n, t) || {}, u = a.delay || n.delay || 0;
  let { elapsed: l = 0 } = n;
  l = l - Vs(u);
  let d = {
    keyframes: Array.isArray(r) ? r : [null, r],
    ease: "easeOut",
    velocity: e.getVelocity(),
    ...a,
    delay: -l,
    onUpdate: (w) => {
      e.set(w), a.onUpdate && a.onUpdate(w);
    },
    onComplete: () => {
      o(), a.onComplete && a.onComplete();
    },
    name: t,
    motionValue: e,
    element: s ? void 0 : i
  };
  nee(a) || (d = {
    ...d,
    ...xZ(t, d)
  }), d.duration && (d.duration = Vs(d.duration)), d.repeatDelay && (d.repeatDelay = Vs(d.repeatDelay)), d.from !== void 0 && (d.keyframes[0] = d.from);
  let p = !1;
  if ((d.type === !1 || d.duration === 0 && !d.repeatDelay) && (d.duration = 0, d.delay === 0 && (p = !0)), p && !s && e.get() !== void 0) {
    const w = wp(d.keyframes, a);
    if (w !== void 0)
      return Lr.update(() => {
        d.onUpdate(w), d.onComplete();
      }), new ree([]);
  }
  return !s && h_.supports(d) ? new h_(d) : new qb(d);
}, iee = (t) => !!(t && typeof t == "object" && t.mix && t.toValue), see = (t) => J1(t) ? t[t.length - 1] || 0 : t;
function Hb(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function Kb(t, e) {
  const r = t.indexOf(e);
  r > -1 && t.splice(r, 1);
}
class Vb {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return Hb(this.subscriptions, e), () => Kb(this.subscriptions, e);
  }
  notify(e, r, n) {
    const i = this.subscriptions.length;
    if (i)
      if (i === 1)
        this.subscriptions[0](e, r, n);
      else
        for (let s = 0; s < i; s++) {
          const o = this.subscriptions[s];
          o && o(e, r, n);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const d_ = 30, oee = (t) => !isNaN(parseFloat(t));
class aee {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(e, r = {}) {
    this.version = "11.11.17", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (n, i = !0) => {
      const s = Ys.now();
      this.updatedAt !== s && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(n), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), i && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.hasAnimated = !1, this.setCurrent(e), this.owner = r.owner;
  }
  setCurrent(e) {
    this.current = e, this.updatedAt = Ys.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = oee(this.current));
  }
  setPrevFrameValue(e = this.current) {
    this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(e) {
    return process.env.NODE_ENV !== "production" && vp(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", e);
  }
  on(e, r) {
    this.events[e] || (this.events[e] = new Vb());
    const n = this.events[e].add(r);
    return e === "change" ? () => {
      n(), Lr.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : n;
  }
  clearListeners() {
    for (const e in this.events)
      this.events[e].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(e, r) {
    this.passiveEffect = e, this.stopPassiveEffect = r;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(e, r = !0) {
    !r || !this.passiveEffect ? this.updateAndNotify(e, r) : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, r, n) {
    this.set(r), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - n;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(e, r = !0) {
    this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, r && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const e = Ys.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > d_)
      return 0;
    const r = Math.min(this.updatedAt - this.prevUpdatedAt, d_);
    return _7(parseFloat(this.current) - parseFloat(this.prevFrameValue), r);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(e) {
    return this.stop(), new Promise((r) => {
      this.hasAnimated = !0, this.animation = e(r), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Rl(t, e) {
  return new aee(t, e);
}
function cee(t, e, r) {
  t.hasValue(e) ? t.getValue(e).set(r) : t.addValue(e, Rl(r));
}
function uee(t, e) {
  const r = yp(t, e);
  let { transitionEnd: n = {}, transition: i = {}, ...s } = r || {};
  s = { ...s, ...n };
  for (const o in s) {
    const a = see(s[o]);
    cee(t, o, a);
  }
}
const Gb = (t) => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), fee = "framerAppearId", R7 = "data-" + Gb(fee);
function D7(t) {
  return t.props[R7];
}
const Xn = (t) => !!(t && t.getVelocity);
function lee(t) {
  return !!(Xn(t) && t.add);
}
function iv(t, e) {
  const r = t.getValue("willChange");
  if (lee(r))
    return r.add(e);
}
function hee({ protectedKeys: t, needsAnimating: e }, r) {
  const n = t.hasOwnProperty(r) && e[r] !== !0;
  return e[r] = !1, n;
}
function O7(t, e, { delay: r = 0, transitionOverride: n, type: i } = {}) {
  var s;
  let { transition: o = t.getDefaultTransition(), transitionEnd: a, ...u } = e;
  n && (o = n);
  const l = [], d = i && t.animationState && t.animationState.getState()[i];
  for (const p in u) {
    const w = t.getValue(p, (s = t.latestValues[p]) !== null && s !== void 0 ? s : null), A = u[p];
    if (A === void 0 || d && hee(d, p))
      continue;
    const P = {
      delay: r,
      ...Tb(o || {}, p)
    };
    let N = !1;
    if (window.MotionHandoffAnimation) {
      const $ = D7(t);
      if ($) {
        const B = window.MotionHandoffAnimation($, p, Lr);
        B !== null && (P.startTime = B, N = !0);
      }
    }
    iv(t, p), w.start(Wb(p, w, A, t.shouldReduceMotion && Ac.has(p) ? { type: !1 } : P, t, N));
    const L = w.animation;
    L && l.push(L);
  }
  return a && Promise.all(l).then(() => {
    Lr.update(() => {
      a && uee(t, a);
    });
  }), l;
}
function sv(t, e, r = {}) {
  var n;
  const i = yp(t, e, r.type === "exit" ? (n = t.presenceContext) === null || n === void 0 ? void 0 : n.custom : void 0);
  let { transition: s = t.getDefaultTransition() || {} } = i || {};
  r.transitionOverride && (s = r.transitionOverride);
  const o = i ? () => Promise.all(O7(t, i, r)) : () => Promise.resolve(), a = t.variantChildren && t.variantChildren.size ? (l = 0) => {
    const { delayChildren: d = 0, staggerChildren: p, staggerDirection: w } = s;
    return dee(t, e, d + l, p, w, r);
  } : () => Promise.resolve(), { when: u } = s;
  if (u) {
    const [l, d] = u === "beforeChildren" ? [o, a] : [a, o];
    return l().then(() => d());
  } else
    return Promise.all([o(), a(r.delay)]);
}
function dee(t, e, r = 0, n = 0, i = 1, s) {
  const o = [], a = (t.variantChildren.size - 1) * n, u = i === 1 ? (l = 0) => l * n : (l = 0) => a - l * n;
  return Array.from(t.variantChildren).sort(pee).forEach((l, d) => {
    l.notify("AnimationStart", e), o.push(sv(l, e, {
      ...s,
      delay: r + u(d)
    }).then(() => l.notify("AnimationComplete", e)));
  }), Promise.all(o);
}
function pee(t, e) {
  return t.sortNodePosition(e);
}
function gee(t, e, r = {}) {
  t.notify("AnimationStart", e);
  let n;
  if (Array.isArray(e)) {
    const i = e.map((s) => sv(t, s, r));
    n = Promise.all(i);
  } else if (typeof e == "string")
    n = sv(t, e, r);
  else {
    const i = typeof e == "function" ? yp(t, e, r.custom) : e;
    n = Promise.all(O7(t, i, r));
  }
  return n.then(() => {
    t.notify("AnimationComplete", e);
  });
}
const mee = Cb.length;
function N7(t) {
  if (!t)
    return;
  if (!t.isControllingVariants) {
    const r = t.parent ? N7(t.parent) || {} : {};
    return t.props.initial !== void 0 && (r.initial = t.props.initial), r;
  }
  const e = {};
  for (let r = 0; r < mee; r++) {
    const n = Cb[r], i = t.props[n];
    (Il(i) || i === !1) && (e[n] = i);
  }
  return e;
}
const vee = [...Ib].reverse(), bee = Ib.length;
function yee(t) {
  return (e) => Promise.all(e.map(({ animation: r, options: n }) => gee(t, r, n)));
}
function wee(t) {
  let e = yee(t), r = p_(), n = !0;
  const i = (u) => (l, d) => {
    var p;
    const w = yp(t, d, u === "exit" ? (p = t.presenceContext) === null || p === void 0 ? void 0 : p.custom : void 0);
    if (w) {
      const { transition: A, transitionEnd: P, ...N } = w;
      l = { ...l, ...N, ...P };
    }
    return l;
  };
  function s(u) {
    e = u(t);
  }
  function o(u) {
    const { props: l } = t, d = N7(t.parent) || {}, p = [], w = /* @__PURE__ */ new Set();
    let A = {}, P = 1 / 0;
    for (let L = 0; L < bee; L++) {
      const $ = vee[L], B = r[$], H = l[$] !== void 0 ? l[$] : d[$], W = Il(H), V = $ === u ? B.isActive : null;
      V === !1 && (P = L);
      let te = H === d[$] && H !== l[$] && W;
      if (te && n && t.manuallyAnimateOnMount && (te = !1), B.protectedKeys = { ...A }, // If it isn't active and hasn't *just* been set as inactive
      !B.isActive && V === null || // If we didn't and don't have any defined prop for this animation type
      !H && !B.prevProp || // Or if the prop doesn't define an animation
      bp(H) || typeof H == "boolean")
        continue;
      const R = xee(B.prevProp, H);
      let K = R || // If we're making this variant active, we want to always make it active
      $ === u && B.isActive && !te && W || // If we removed a higher-priority variant (i is in reverse order)
      L > P && W, ge = !1;
      const Ee = Array.isArray(H) ? H : [H];
      let Y = Ee.reduce(i($), {});
      V === !1 && (Y = {});
      const { prevResolvedValues: S = {} } = B, m = {
        ...S,
        ...Y
      }, f = (x) => {
        K = !0, w.has(x) && (ge = !0, w.delete(x)), B.needsAnimating[x] = !0;
        const _ = t.getValue(x);
        _ && (_.liveStyle = !1);
      };
      for (const x in m) {
        const _ = Y[x], E = S[x];
        if (A.hasOwnProperty(x))
          continue;
        let v = !1;
        J1(_) && J1(E) ? v = !YS(_, E) : v = _ !== E, v ? _ != null ? f(x) : w.add(x) : _ !== void 0 && w.has(x) ? f(x) : B.protectedKeys[x] = !0;
      }
      B.prevProp = H, B.prevResolvedValues = Y, B.isActive && (A = { ...A, ...Y }), n && t.blockInitialAnimation && (K = !1), K && (!(te && R) || ge) && p.push(...Ee.map((x) => ({
        animation: x,
        options: { type: $ }
      })));
    }
    if (w.size) {
      const L = {};
      w.forEach(($) => {
        const B = t.getBaseTarget($), H = t.getValue($);
        H && (H.liveStyle = !0), L[$] = B ?? null;
      }), p.push({ animation: L });
    }
    let N = !!p.length;
    return n && (l.initial === !1 || l.initial === l.animate) && !t.manuallyAnimateOnMount && (N = !1), n = !1, N ? e(p) : Promise.resolve();
  }
  function a(u, l) {
    var d;
    if (r[u].isActive === l)
      return Promise.resolve();
    (d = t.variantChildren) === null || d === void 0 || d.forEach((w) => {
      var A;
      return (A = w.animationState) === null || A === void 0 ? void 0 : A.setActive(u, l);
    }), r[u].isActive = l;
    const p = o(u);
    for (const w in r)
      r[w].protectedKeys = {};
    return p;
  }
  return {
    animateChanges: o,
    setActive: a,
    setAnimateFunction: s,
    getState: () => r,
    reset: () => {
      r = p_(), n = !0;
    }
  };
}
function xee(t, e) {
  return typeof e == "string" ? e !== t : Array.isArray(e) ? !YS(e, t) : !1;
}
function Ya(t = !1) {
  return {
    isActive: t,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function p_() {
  return {
    animate: Ya(!0),
    whileInView: Ya(),
    whileHover: Ya(),
    whileTap: Ya(),
    whileDrag: Ya(),
    whileFocus: Ya(),
    exit: Ya()
  };
}
class Oa {
  constructor(e) {
    this.isMounted = !1, this.node = e;
  }
  update() {
  }
}
class _ee extends Oa {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(e) {
    super(e), e.animationState || (e.animationState = wee(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    bp(e) && (this.unmountControls = e.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(), { animate: r } = this.node.prevProps || {};
    e !== r && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var e;
    this.node.animationState.reset(), (e = this.unmountControls) === null || e === void 0 || e.call(this);
  }
}
let Eee = 0;
class See extends Oa {
  constructor() {
    super(...arguments), this.id = Eee++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: e, onExitComplete: r } = this.node.presenceContext, { isPresent: n } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === n)
      return;
    const i = this.node.animationState.setActive("exit", !e);
    r && !e && i.then(() => r(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {
  }
}
const Aee = {
  animation: {
    Feature: _ee
  },
  exit: {
    Feature: See
  }
}, L7 = (t) => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1;
function xp(t, e = "page") {
  return {
    point: {
      x: t[`${e}X`],
      y: t[`${e}Y`]
    }
  };
}
const Pee = (t) => (e) => L7(e) && t(e, xp(e));
function Co(t, e, r, n = { passive: !0 }) {
  return t.addEventListener(e, r, n), () => t.removeEventListener(e, r);
}
function No(t, e, r, n) {
  return Co(t, e, Pee(r), n);
}
const g_ = (t, e) => Math.abs(t - e);
function Mee(t, e) {
  const r = g_(t.x, e.x), n = g_(t.y, e.y);
  return Math.sqrt(r ** 2 + n ** 2);
}
class k7 {
  constructor(e, r, { transformPagePoint: n, contextWindow: i, dragSnapToOrigin: s = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const p = Bm(this.lastMoveEventInfo, this.history), w = this.startEvent !== null, A = Mee(p.offset, { x: 0, y: 0 }) >= 3;
      if (!w && !A)
        return;
      const { point: P } = p, { timestamp: N } = Fn;
      this.history.push({ ...P, timestamp: N });
      const { onStart: L, onMove: $ } = this.handlers;
      w || (L && L(this.lastMoveEvent, p), this.startEvent = this.lastMoveEvent), $ && $(this.lastMoveEvent, p);
    }, this.handlePointerMove = (p, w) => {
      this.lastMoveEvent = p, this.lastMoveEventInfo = $m(w, this.transformPagePoint), Lr.update(this.updatePoint, !0);
    }, this.handlePointerUp = (p, w) => {
      this.end();
      const { onEnd: A, onSessionEnd: P, resumeAnimation: N } = this.handlers;
      if (this.dragSnapToOrigin && N && N(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const L = Bm(p.type === "pointercancel" ? this.lastMoveEventInfo : $m(w, this.transformPagePoint), this.history);
      this.startEvent && A && A(p, L), P && P(p, L);
    }, !L7(e))
      return;
    this.dragSnapToOrigin = s, this.handlers = r, this.transformPagePoint = n, this.contextWindow = i || window;
    const o = xp(e), a = $m(o, this.transformPagePoint), { point: u } = a, { timestamp: l } = Fn;
    this.history = [{ ...u, timestamp: l }];
    const { onSessionStart: d } = r;
    d && d(e, Bm(a, this.history)), this.removeListeners = Oo(No(this.contextWindow, "pointermove", this.handlePointerMove), No(this.contextWindow, "pointerup", this.handlePointerUp), No(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), Ea(this.updatePoint);
  }
}
function $m(t, e) {
  return e ? { point: e(t.point) } : t;
}
function m_(t, e) {
  return { x: t.x - e.x, y: t.y - e.y };
}
function Bm({ point: t }, e) {
  return {
    point: t,
    delta: m_(t, $7(e)),
    offset: m_(t, Iee(e)),
    velocity: Cee(e, 0.1)
  };
}
function Iee(t) {
  return t[0];
}
function $7(t) {
  return t[t.length - 1];
}
function Cee(t, e) {
  if (t.length < 2)
    return { x: 0, y: 0 };
  let r = t.length - 1, n = null;
  const i = $7(t);
  for (; r >= 0 && (n = t[r], !(i.timestamp - n.timestamp > Vs(e))); )
    r--;
  if (!n)
    return { x: 0, y: 0 };
  const s = Do(i.timestamp - n.timestamp);
  if (s === 0)
    return { x: 0, y: 0 };
  const o = {
    x: (i.x - n.x) / s,
    y: (i.y - n.y) / s
  };
  return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o;
}
function B7(t) {
  let e = null;
  return () => {
    const r = () => {
      e = null;
    };
    return e === null ? (e = t, r) : !1;
  };
}
const v_ = B7("dragHorizontal"), b_ = B7("dragVertical");
function F7(t) {
  let e = !1;
  if (t === "y")
    e = b_();
  else if (t === "x")
    e = v_();
  else {
    const r = v_(), n = b_();
    r && n ? e = () => {
      r(), n();
    } : (r && r(), n && n());
  }
  return e;
}
function j7() {
  const t = F7(!0);
  return t ? (t(), !1) : !0;
}
function tu(t) {
  return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current");
}
const U7 = 1e-4, Tee = 1 - U7, Ree = 1 + U7, q7 = 0.01, Dee = 0 - q7, Oee = 0 + q7;
function ki(t) {
  return t.max - t.min;
}
function Nee(t, e, r) {
  return Math.abs(t - e) <= r;
}
function y_(t, e, r, n = 0.5) {
  t.origin = n, t.originPoint = Qr(e.min, e.max, t.origin), t.scale = ki(r) / ki(e), t.translate = Qr(r.min, r.max, t.origin) - t.originPoint, (t.scale >= Tee && t.scale <= Ree || isNaN(t.scale)) && (t.scale = 1), (t.translate >= Dee && t.translate <= Oee || isNaN(t.translate)) && (t.translate = 0);
}
function Jf(t, e, r, n) {
  y_(t.x, e.x, r.x, n ? n.originX : void 0), y_(t.y, e.y, r.y, n ? n.originY : void 0);
}
function w_(t, e, r) {
  t.min = r.min + e.min, t.max = t.min + ki(e);
}
function Lee(t, e, r) {
  w_(t.x, e.x, r.x), w_(t.y, e.y, r.y);
}
function x_(t, e, r) {
  t.min = e.min - r.min, t.max = t.min + ki(e);
}
function Xf(t, e, r) {
  x_(t.x, e.x, r.x), x_(t.y, e.y, r.y);
}
function kee(t, { min: e, max: r }, n) {
  return e !== void 0 && t < e ? t = n ? Qr(e, t, n.min) : Math.max(t, e) : r !== void 0 && t > r && (t = n ? Qr(r, t, n.max) : Math.min(t, r)), t;
}
function __(t, e, r) {
  return {
    min: e !== void 0 ? t.min + e : void 0,
    max: r !== void 0 ? t.max + r - (t.max - t.min) : void 0
  };
}
function $ee(t, { top: e, left: r, bottom: n, right: i }) {
  return {
    x: __(t.x, r, i),
    y: __(t.y, e, n)
  };
}
function E_(t, e) {
  let r = e.min - t.min, n = e.max - t.max;
  return e.max - e.min < t.max - t.min && ([r, n] = [n, r]), { min: r, max: n };
}
function Bee(t, e) {
  return {
    x: E_(t.x, e.x),
    y: E_(t.y, e.y)
  };
}
function Fee(t, e) {
  let r = 0.5;
  const n = ki(t), i = ki(e);
  return i > n ? r = Iu(e.min, e.max - n, t.min) : n > i && (r = Iu(t.min, t.max - i, e.min)), Sa(0, 1, r);
}
function jee(t, e) {
  const r = {};
  return e.min !== void 0 && (r.min = e.min - t.min), e.max !== void 0 && (r.max = e.max - t.min), r;
}
const ov = 0.35;
function Uee(t = ov) {
  return t === !1 ? t = 0 : t === !0 && (t = ov), {
    x: S_(t, "left", "right"),
    y: S_(t, "top", "bottom")
  };
}
function S_(t, e, r) {
  return {
    min: A_(t, e),
    max: A_(t, r)
  };
}
function A_(t, e) {
  return typeof t == "number" ? t : t[e] || 0;
}
const P_ = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), ru = () => ({
  x: P_(),
  y: P_()
}), M_ = () => ({ min: 0, max: 0 }), ln = () => ({
  x: M_(),
  y: M_()
});
function Zi(t) {
  return [t("x"), t("y")];
}
function z7({ top: t, left: e, right: r, bottom: n }) {
  return {
    x: { min: e, max: r },
    y: { min: t, max: n }
  };
}
function qee({ x: t, y: e }) {
  return { top: e.min, right: t.max, bottom: e.max, left: t.min };
}
function zee(t, e) {
  if (!e)
    return t;
  const r = e({ x: t.left, y: t.top }), n = e({ x: t.right, y: t.bottom });
  return {
    top: r.y,
    left: r.x,
    bottom: n.y,
    right: n.x
  };
}
function Fm(t) {
  return t === void 0 || t === 1;
}
function av({ scale: t, scaleX: e, scaleY: r }) {
  return !Fm(t) || !Fm(e) || !Fm(r);
}
function Xa(t) {
  return av(t) || W7(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY;
}
function W7(t) {
  return I_(t.x) || I_(t.y);
}
function I_(t) {
  return t && t !== "0%";
}
function x0(t, e, r) {
  const n = t - r, i = e * n;
  return r + i;
}
function C_(t, e, r, n, i) {
  return i !== void 0 && (t = x0(t, i, n)), x0(t, r, n) + e;
}
function cv(t, e = 0, r = 1, n, i) {
  t.min = C_(t.min, e, r, n, i), t.max = C_(t.max, e, r, n, i);
}
function H7(t, { x: e, y: r }) {
  cv(t.x, e.translate, e.scale, e.originPoint), cv(t.y, r.translate, r.scale, r.originPoint);
}
const T_ = 0.999999999999, R_ = 1.0000000000001;
function Wee(t, e, r, n = !1) {
  const i = r.length;
  if (!i)
    return;
  e.x = e.y = 1;
  let s, o;
  for (let a = 0; a < i; a++) {
    s = r[a], o = s.projectionDelta;
    const { visualElement: u } = s.options;
    u && u.props.style && u.props.style.display === "contents" || (n && s.options.layoutScroll && s.scroll && s !== s.root && iu(t, {
      x: -s.scroll.offset.x,
      y: -s.scroll.offset.y
    }), o && (e.x *= o.x.scale, e.y *= o.y.scale, H7(t, o)), n && Xa(s.latestValues) && iu(t, s.latestValues));
  }
  e.x < R_ && e.x > T_ && (e.x = 1), e.y < R_ && e.y > T_ && (e.y = 1);
}
function nu(t, e) {
  t.min = t.min + e, t.max = t.max + e;
}
function D_(t, e, r, n, i = 0.5) {
  const s = Qr(t.min, t.max, i);
  cv(t, e, r, s, n);
}
function iu(t, e) {
  D_(t.x, e.x, e.scaleX, e.scale, e.originX), D_(t.y, e.y, e.scaleY, e.scale, e.originY);
}
function K7(t, e) {
  return z7(zee(t.getBoundingClientRect(), e));
}
function Hee(t, e, r) {
  const n = K7(t, r), { scroll: i } = e;
  return i && (nu(n.x, i.offset.x), nu(n.y, i.offset.y)), n;
}
const V7 = ({ current: t }) => t ? t.ownerDocument.defaultView : null, Kee = /* @__PURE__ */ new WeakMap();
class Vee {
  constructor(e) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = ln(), this.visualElement = e;
  }
  start(e, { snapToCursor: r = !1 } = {}) {
    const { presenceContext: n } = this.visualElement;
    if (n && n.isPresent === !1)
      return;
    const i = (d) => {
      const { dragSnapToOrigin: p } = this.getProps();
      p ? this.pauseAnimation() : this.stopAnimation(), r && this.snapToCursor(xp(d, "page").point);
    }, s = (d, p) => {
      const { drag: w, dragPropagation: A, onDragStart: P } = this.getProps();
      if (w && !A && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = F7(w), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Zi((L) => {
        let $ = this.getAxisMotionValue(L).get() || 0;
        if (Gs.test($)) {
          const { projection: B } = this.visualElement;
          if (B && B.layout) {
            const H = B.layout.layoutBox[L];
            H && ($ = ki(H) * (parseFloat($) / 100));
          }
        }
        this.originPoint[L] = $;
      }), P && Lr.postRender(() => P(d, p)), iv(this.visualElement, "transform");
      const { animationState: N } = this.visualElement;
      N && N.setActive("whileDrag", !0);
    }, o = (d, p) => {
      const { dragPropagation: w, dragDirectionLock: A, onDirectionLock: P, onDrag: N } = this.getProps();
      if (!w && !this.openGlobalLock)
        return;
      const { offset: L } = p;
      if (A && this.currentDirection === null) {
        this.currentDirection = Gee(L), this.currentDirection !== null && P && P(this.currentDirection);
        return;
      }
      this.updateAxis("x", p.point, L), this.updateAxis("y", p.point, L), this.visualElement.render(), N && N(d, p);
    }, a = (d, p) => this.stop(d, p), u = () => Zi((d) => {
      var p;
      return this.getAnimationState(d) === "paused" && ((p = this.getAxisMotionValue(d).animation) === null || p === void 0 ? void 0 : p.play());
    }), { dragSnapToOrigin: l } = this.getProps();
    this.panSession = new k7(e, {
      onSessionStart: i,
      onStart: s,
      onMove: o,
      onSessionEnd: a,
      resumeAnimation: u
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: l,
      contextWindow: V7(this.visualElement)
    });
  }
  stop(e, r) {
    const n = this.isDragging;
    if (this.cancel(), !n)
      return;
    const { velocity: i } = r;
    this.startAnimation(i);
    const { onDragEnd: s } = this.getProps();
    s && Lr.postRender(() => s(e, r));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: r } = this.visualElement;
    e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: n } = this.getProps();
    !n && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), r && r.setActive("whileDrag", !1);
  }
  updateAxis(e, r, n) {
    const { drag: i } = this.getProps();
    if (!n || !vd(e, i, this.currentDirection))
      return;
    const s = this.getAxisMotionValue(e);
    let o = this.originPoint[e] + n[e];
    this.constraints && this.constraints[e] && (o = kee(o, this.constraints[e], this.elastic[e])), s.set(o);
  }
  resolveConstraints() {
    var e;
    const { dragConstraints: r, dragElastic: n } = this.getProps(), i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout, s = this.constraints;
    r && tu(r) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : r && i ? this.constraints = $ee(i.layoutBox, r) : this.constraints = !1, this.elastic = Uee(n), s !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && Zi((o) => {
      this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = jee(i.layoutBox[o], this.constraints[o]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: r } = this.getProps();
    if (!e || !tu(e))
      return !1;
    const n = e.current;
    zo(n !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection: i } = this.visualElement;
    if (!i || !i.layout)
      return !1;
    const s = Hee(n, i.root, this.visualElement.getTransformPagePoint());
    let o = Bee(i.layout.layoutBox, s);
    if (r) {
      const a = r(qee(o));
      this.hasMutatedConstraints = !!a, a && (o = z7(a));
    }
    return o;
  }
  startAnimation(e) {
    const { drag: r, dragMomentum: n, dragElastic: i, dragTransition: s, dragSnapToOrigin: o, onDragTransitionEnd: a } = this.getProps(), u = this.constraints || {}, l = Zi((d) => {
      if (!vd(d, r, this.currentDirection))
        return;
      let p = u && u[d] || {};
      o && (p = { min: 0, max: 0 });
      const w = i ? 200 : 1e6, A = i ? 40 : 1e7, P = {
        type: "inertia",
        velocity: n ? e[d] : 0,
        bounceStiffness: w,
        bounceDamping: A,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...s,
        ...p
      };
      return this.startAxisValueAnimation(d, P);
    });
    return Promise.all(l).then(a);
  }
  startAxisValueAnimation(e, r) {
    const n = this.getAxisMotionValue(e);
    return iv(this.visualElement, e), n.start(Wb(e, n, 0, r, this.visualElement, !1));
  }
  stopAnimation() {
    Zi((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    Zi((e) => {
      var r;
      return (r = this.getAxisMotionValue(e).animation) === null || r === void 0 ? void 0 : r.pause();
    });
  }
  getAnimationState(e) {
    var r;
    return (r = this.getAxisMotionValue(e).animation) === null || r === void 0 ? void 0 : r.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(e) {
    const r = `_drag${e.toUpperCase()}`, n = this.visualElement.getProps(), i = n[r];
    return i || this.visualElement.getValue(e, (n.initial ? n.initial[e] : void 0) || 0);
  }
  snapToCursor(e) {
    Zi((r) => {
      const { drag: n } = this.getProps();
      if (!vd(r, n, this.currentDirection))
        return;
      const { projection: i } = this.visualElement, s = this.getAxisMotionValue(r);
      if (i && i.layout) {
        const { min: o, max: a } = i.layout.layoutBox[r];
        s.set(e[r] - Qr(o, a, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: e, dragConstraints: r } = this.getProps(), { projection: n } = this.visualElement;
    if (!tu(r) || !n || !this.constraints)
      return;
    this.stopAnimation();
    const i = { x: 0, y: 0 };
    Zi((o) => {
      const a = this.getAxisMotionValue(o);
      if (a && this.constraints !== !1) {
        const u = a.get();
        i[o] = Fee({ min: u, max: u }, this.constraints[o]);
      }
    });
    const { transformTemplate: s } = this.visualElement.getProps();
    this.visualElement.current.style.transform = s ? s({}, "") : "none", n.root && n.root.updateScroll(), n.updateLayout(), this.resolveConstraints(), Zi((o) => {
      if (!vd(o, e, null))
        return;
      const a = this.getAxisMotionValue(o), { min: u, max: l } = this.constraints[o];
      a.set(Qr(u, l, i[o]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    Kee.set(this.visualElement, this);
    const e = this.visualElement.current, r = No(e, "pointerdown", (u) => {
      const { drag: l, dragListener: d = !0 } = this.getProps();
      l && d && this.start(u);
    }), n = () => {
      const { dragConstraints: u } = this.getProps();
      tu(u) && u.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: i } = this.visualElement, s = i.addEventListener("measure", n);
    i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), Lr.read(n);
    const o = Co(window, "resize", () => this.scalePositionWithinConstraints()), a = i.addEventListener("didUpdate", ({ delta: u, hasLayoutChanged: l }) => {
      this.isDragging && l && (Zi((d) => {
        const p = this.getAxisMotionValue(d);
        p && (this.originPoint[d] += u[d].translate, p.set(p.get() + u[d].translate));
      }), this.visualElement.render());
    });
    return () => {
      o(), r(), s(), a && a();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(), { drag: r = !1, dragDirectionLock: n = !1, dragPropagation: i = !1, dragConstraints: s = !1, dragElastic: o = ov, dragMomentum: a = !0 } = e;
    return {
      ...e,
      drag: r,
      dragDirectionLock: n,
      dragPropagation: i,
      dragConstraints: s,
      dragElastic: o,
      dragMomentum: a
    };
  }
}
function vd(t, e, r) {
  return (e === !0 || e === t) && (r === null || r === t);
}
function Gee(t, e = 10) {
  let r = null;
  return Math.abs(t.y) > e ? r = "y" : Math.abs(t.x) > e && (r = "x"), r;
}
class Yee extends Oa {
  constructor(e) {
    super(e), this.removeGroupControls = Un, this.removeListeners = Un, this.controls = new Vee(e);
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Un;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const O_ = (t) => (e, r) => {
  t && Lr.postRender(() => t(e, r));
};
class Jee extends Oa {
  constructor() {
    super(...arguments), this.removePointerDownListener = Un;
  }
  onPointerDown(e) {
    this.session = new k7(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: V7(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: e, onPanStart: r, onPan: n, onPanEnd: i } = this.node.getProps();
    return {
      onSessionStart: O_(e),
      onStart: O_(r),
      onMove: n,
      onEnd: (s, o) => {
        delete this.session, i && Lr.postRender(() => i(s, o));
      }
    };
  }
  mount() {
    this.removePointerDownListener = No(this.node.current, "pointerdown", (e) => this.onPointerDown(e));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const _p = Ma(null);
function Xee() {
  const t = Tn(_p);
  if (t === null)
    return [!0, null];
  const { isPresent: e, onExitComplete: r, register: n } = t, i = mv();
  Dn(() => n(i), []);
  const s = vv(() => r && r(i), [i, r]);
  return !e && r ? [!1, s] : [!0];
}
const Yb = Ma({}), G7 = Ma({}), jd = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function N_(t, e) {
  return e.max === e.min ? 0 : t / (e.max - e.min) * 100;
}
const Of = {
  correct: (t, e) => {
    if (!e.target)
      return t;
    if (typeof t == "string")
      if (Vt.test(t))
        t = parseFloat(t);
      else
        return t;
    const r = N_(t, e.target.x), n = N_(t, e.target.y);
    return `${r}% ${n}%`;
  }
}, Zee = {
  correct: (t, { treeScale: e, projectionDelta: r }) => {
    const n = t, i = Aa.parse(t);
    if (i.length > 5)
      return n;
    const s = Aa.createTransformer(t), o = typeof i[0] != "number" ? 1 : 0, a = r.x.scale * e.x, u = r.y.scale * e.y;
    i[0 + o] /= a, i[1 + o] /= u;
    const l = Qr(a, u, 0.5);
    return typeof i[2 + o] == "number" && (i[2 + o] /= l), typeof i[3 + o] == "number" && (i[3 + o] /= l), s(i);
  }
}, _0 = {};
function Qee(t) {
  Object.assign(_0, t);
}
const { schedule: Jb } = JS(queueMicrotask, !1);
class ete extends LR {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: e, layoutGroup: r, switchLayoutGroup: n, layoutId: i } = this.props, { projection: s } = e;
    Qee(tte), s && (r.group && r.group.add(s), n && n.register && i && n.register(s), s.root.didUpdate(), s.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), s.setOptions({
      ...s.options,
      onExitComplete: () => this.safeToRemove()
    })), jd.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(e) {
    const { layoutDependency: r, visualElement: n, drag: i, isPresent: s } = this.props, o = n.projection;
    return o && (o.isPresent = s, i || e.layoutDependency !== r || r === void 0 ? o.willUpdate() : this.safeToRemove(), e.isPresent !== s && (s ? o.promote() : o.relegate() || Lr.postRender(() => {
      const a = o.getStack();
      (!a || !a.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e && (e.root.didUpdate(), Jb.postRender(() => {
      !e.currentAnimation && e.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: e, layoutGroup: r, switchLayoutGroup: n } = this.props, { projection: i } = e;
    i && (i.scheduleCheckAfterUnmount(), r && r.group && r.group.remove(i), n && n.deregister && n.deregister(i));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function Y7(t) {
  const [e, r] = Xee(), n = Tn(Yb);
  return fe.jsx(ete, { ...t, layoutGroup: n, switchLayoutGroup: Tn(G7), isPresent: e, safeToRemove: r });
}
const tte = {
  borderRadius: {
    ...Of,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: Of,
  borderTopRightRadius: Of,
  borderBottomLeftRadius: Of,
  borderBottomRightRadius: Of,
  boxShadow: Zee
}, J7 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], rte = J7.length, L_ = (t) => typeof t == "string" ? parseFloat(t) : t, k_ = (t) => typeof t == "number" || Vt.test(t);
function nte(t, e, r, n, i, s) {
  i ? (t.opacity = Qr(
    0,
    // TODO Reinstate this if only child
    r.opacity !== void 0 ? r.opacity : 1,
    ite(n)
  ), t.opacityExit = Qr(e.opacity !== void 0 ? e.opacity : 1, 0, ste(n))) : s && (t.opacity = Qr(e.opacity !== void 0 ? e.opacity : 1, r.opacity !== void 0 ? r.opacity : 1, n));
  for (let o = 0; o < rte; o++) {
    const a = `border${J7[o]}Radius`;
    let u = $_(e, a), l = $_(r, a);
    if (u === void 0 && l === void 0)
      continue;
    u || (u = 0), l || (l = 0), u === 0 || l === 0 || k_(u) === k_(l) ? (t[a] = Math.max(Qr(L_(u), L_(l), n), 0), (Gs.test(l) || Gs.test(u)) && (t[a] += "%")) : t[a] = l;
  }
  (e.rotate || r.rotate) && (t.rotate = Qr(e.rotate || 0, r.rotate || 0, n));
}
function $_(t, e) {
  return t[e] !== void 0 ? t[e] : t.borderRadius;
}
const ite = /* @__PURE__ */ X7(0, 0.5, n7), ste = /* @__PURE__ */ X7(0.5, 0.95, Un);
function X7(t, e, r) {
  return (n) => n < t ? 0 : n > e ? 1 : r(Iu(t, e, n));
}
function B_(t, e) {
  t.min = e.min, t.max = e.max;
}
function Ji(t, e) {
  B_(t.x, e.x), B_(t.y, e.y);
}
function F_(t, e) {
  t.translate = e.translate, t.scale = e.scale, t.originPoint = e.originPoint, t.origin = e.origin;
}
function j_(t, e, r, n, i) {
  return t -= e, t = x0(t, 1 / r, n), i !== void 0 && (t = x0(t, 1 / i, n)), t;
}
function ote(t, e = 0, r = 1, n = 0.5, i, s = t, o = t) {
  if (Gs.test(e) && (e = parseFloat(e), e = Qr(o.min, o.max, e / 100) - o.min), typeof e != "number")
    return;
  let a = Qr(s.min, s.max, n);
  t === s && (a -= e), t.min = j_(t.min, e, r, a, i), t.max = j_(t.max, e, r, a, i);
}
function U_(t, e, [r, n, i], s, o) {
  ote(t, e[r], e[n], e[i], e.scale, s, o);
}
const ate = ["x", "scaleX", "originX"], cte = ["y", "scaleY", "originY"];
function q_(t, e, r, n) {
  U_(t.x, e, ate, r ? r.x : void 0, n ? n.x : void 0), U_(t.y, e, cte, r ? r.y : void 0, n ? n.y : void 0);
}
function z_(t) {
  return t.translate === 0 && t.scale === 1;
}
function Z7(t) {
  return z_(t.x) && z_(t.y);
}
function W_(t, e) {
  return t.min === e.min && t.max === e.max;
}
function ute(t, e) {
  return W_(t.x, e.x) && W_(t.y, e.y);
}
function H_(t, e) {
  return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max);
}
function Q7(t, e) {
  return H_(t.x, e.x) && H_(t.y, e.y);
}
function K_(t) {
  return ki(t.x) / ki(t.y);
}
function V_(t, e) {
  return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint;
}
class fte {
  constructor() {
    this.members = [];
  }
  add(e) {
    Hb(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (Kb(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
      const r = this.members[this.members.length - 1];
      r && this.promote(r);
    }
  }
  relegate(e) {
    const r = this.members.findIndex((i) => e === i);
    if (r === 0)
      return !1;
    let n;
    for (let i = r; i >= 0; i--) {
      const s = this.members[i];
      if (s.isPresent !== !1) {
        n = s;
        break;
      }
    }
    return n ? (this.promote(n), !0) : !1;
  }
  promote(e, r) {
    const n = this.lead;
    if (e !== n && (this.prevLead = n, this.lead = e, e.show(), n)) {
      n.instance && n.scheduleRender(), e.scheduleRender(), e.resumeFrom = n, r && (e.resumeFrom.preserveOpacity = !0), n.snapshot && (e.snapshot = n.snapshot, e.snapshot.latestValues = n.animationValues || n.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: i } = e.options;
      i === !1 && n.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: r, resumingFrom: n } = e;
      r.onExitComplete && r.onExitComplete(), n && n.options.onExitComplete && n.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function lte(t, e, r) {
  let n = "";
  const i = t.x.translate / e.x, s = t.y.translate / e.y, o = (r == null ? void 0 : r.z) || 0;
  if ((i || s || o) && (n = `translate3d(${i}px, ${s}px, ${o}px) `), (e.x !== 1 || e.y !== 1) && (n += `scale(${1 / e.x}, ${1 / e.y}) `), r) {
    const { transformPerspective: l, rotate: d, rotateX: p, rotateY: w, skewX: A, skewY: P } = r;
    l && (n = `perspective(${l}px) ${n}`), d && (n += `rotate(${d}deg) `), p && (n += `rotateX(${p}deg) `), w && (n += `rotateY(${w}deg) `), A && (n += `skewX(${A}deg) `), P && (n += `skewY(${P}deg) `);
  }
  const a = t.x.scale * e.x, u = t.y.scale * e.y;
  return (a !== 1 || u !== 1) && (n += `scale(${a}, ${u})`), n || "none";
}
const hte = (t, e) => t.depth - e.depth;
class dte {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(e) {
    Hb(this.children, e), this.isDirty = !0;
  }
  remove(e) {
    Kb(this.children, e), this.isDirty = !0;
  }
  forEach(e) {
    this.isDirty && this.children.sort(hte), this.isDirty = !1, this.children.forEach(e);
  }
}
function Ud(t) {
  const e = Xn(t) ? t.get() : t;
  return iee(e) ? e.toValue() : e;
}
function pte(t, e) {
  const r = Ys.now(), n = ({ timestamp: i }) => {
    const s = i - r;
    s >= e && (Ea(n), t(s - e));
  };
  return Lr.read(n, !0), () => Ea(n);
}
function gte(t) {
  return t instanceof SVGElement && t.tagName !== "svg";
}
function mte(t, e, r) {
  const n = Xn(t) ? t : Rl(t);
  return n.start(Wb("", n, e, r)), n.animation;
}
const Za = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
}, Uf = typeof window < "u" && window.MotionDebug !== void 0, jm = ["", "X", "Y", "Z"], vte = { visibility: "hidden" }, G_ = 1e3;
let bte = 0;
function Um(t, e, r, n) {
  const { latestValues: i } = e;
  i[t] && (r[t] = i[t], e.setStaticValue(t, 0), n && (n[t] = 0));
}
function e9(t) {
  if (t.hasCheckedOptimisedAppear = !0, t.root === t)
    return;
  const { visualElement: e } = t.options;
  if (!e)
    return;
  const r = D7(e);
  if (window.MotionHasOptimisedAnimation(r, "transform")) {
    const { layout: i, layoutId: s } = t.options;
    window.MotionCancelOptimisedAnimation(r, "transform", Lr, !(i || s));
  }
  const { parent: n } = t;
  n && !n.hasCheckedOptimisedAppear && e9(n);
}
function t9({ attachResizeListener: t, defaultParent: e, measureScroll: r, checkIsScrollRoot: n, resetTransform: i }) {
  return class {
    constructor(o = {}, a = e == null ? void 0 : e()) {
      this.id = bte++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, Uf && (Za.totalNodes = Za.resolvedTargetDeltas = Za.recalculatedProjection = 0), this.nodes.forEach(xte), this.nodes.forEach(Pte), this.nodes.forEach(Mte), this.nodes.forEach(_te), Uf && window.MotionDebug.record(Za);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = o, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
      for (let u = 0; u < this.path.length; u++)
        this.path[u].shouldResetTransform = !0;
      this.root === this && (this.nodes = new dte());
    }
    addEventListener(o, a) {
      return this.eventHandlers.has(o) || this.eventHandlers.set(o, new Vb()), this.eventHandlers.get(o).add(a);
    }
    notifyListeners(o, ...a) {
      const u = this.eventHandlers.get(o);
      u && u.notify(...a);
    }
    hasListeners(o) {
      return this.eventHandlers.has(o);
    }
    /**
     * Lifecycles
     */
    mount(o, a = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = gte(o), this.instance = o;
      const { layoutId: u, layout: l, visualElement: d } = this.options;
      if (d && !d.current && d.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (l || u) && (this.isLayoutDirty = !0), t) {
        let p;
        const w = () => this.root.updateBlockedByResize = !1;
        t(o, () => {
          this.root.updateBlockedByResize = !0, p && p(), p = pte(w, 250), jd.hasAnimatedSinceResize && (jd.hasAnimatedSinceResize = !1, this.nodes.forEach(J_));
        });
      }
      u && this.root.registerSharedNode(u, this), this.options.animate !== !1 && d && (u || l) && this.addEventListener("didUpdate", ({ delta: p, hasLayoutChanged: w, hasRelativeTargetChanged: A, layout: P }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const N = this.options.transition || d.getDefaultTransition() || Dte, { onLayoutAnimationStart: L, onLayoutAnimationComplete: $ } = d.getProps(), B = !this.targetLayout || !Q7(this.targetLayout, P) || A, H = !w && A;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || H || w && (B || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(p, H);
          const W = {
            ...Tb(N, "layout"),
            onPlay: L,
            onComplete: $
          };
          (d.shouldReduceMotion || this.options.layoutRoot) && (W.delay = 0, W.type = !1), this.startAnimation(W);
        } else
          w || J_(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = P;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const o = this.getStack();
      o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, Ea(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(Ite), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: o } = this.options;
      return o && o.getProps().transformTemplate;
    }
    willUpdate(o = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && e9(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let d = 0; d < this.path.length; d++) {
        const p = this.path[d];
        p.shouldResetTransform = !0, p.updateScroll("snapshot"), p.options.layoutRoot && p.willUpdate(!1);
      }
      const { layoutId: a, layout: u } = this.options;
      if (a === void 0 && !u)
        return;
      const l = this.getTransformTemplate();
      this.prevTransformTemplateValue = l ? l(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Y_);
        return;
      }
      this.isUpdating || this.nodes.forEach(Ste), this.isUpdating = !1, this.nodes.forEach(Ate), this.nodes.forEach(yte), this.nodes.forEach(wte), this.clearAllSnapshots();
      const a = Ys.now();
      Fn.delta = Sa(0, 1e3 / 60, a - Fn.timestamp), Fn.timestamp = a, Fn.isProcessing = !0, Dm.update.process(Fn), Dm.preRender.process(Fn), Dm.render.process(Fn), Fn.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, Jb.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(Ete), this.sharedNodes.forEach(Cte);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Lr.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      Lr.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let u = 0; u < this.path.length; u++)
          this.path[u].updateScroll();
      const o = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = ln(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0);
    }
    updateScroll(o = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a) {
        const u = n(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: o,
          isRoot: u,
          offset: r(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : u
        };
      }
    }
    resetTransform() {
      if (!i)
        return;
      const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !Z7(this.projectionDelta), u = this.getTransformTemplate(), l = u ? u(this.latestValues, "") : void 0, d = l !== this.prevTransformTemplateValue;
      o && (a || Xa(this.latestValues) || d) && (i(this.instance, l), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(o = !0) {
      const a = this.measurePageBox();
      let u = this.removeElementScroll(a);
      return o && (u = this.removeTransform(u)), Ote(u), {
        animationId: this.root.animationId,
        measuredBox: a,
        layoutBox: u,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var o;
      const { visualElement: a } = this.options;
      if (!a)
        return ln();
      const u = a.measureViewportBox();
      if (!(((o = this.scroll) === null || o === void 0 ? void 0 : o.wasRoot) || this.path.some(Nte))) {
        const { scroll: d } = this.root;
        d && (nu(u.x, d.offset.x), nu(u.y, d.offset.y));
      }
      return u;
    }
    removeElementScroll(o) {
      var a;
      const u = ln();
      if (Ji(u, o), !((a = this.scroll) === null || a === void 0) && a.wasRoot)
        return u;
      for (let l = 0; l < this.path.length; l++) {
        const d = this.path[l], { scroll: p, options: w } = d;
        d !== this.root && p && w.layoutScroll && (p.wasRoot && Ji(u, o), nu(u.x, p.offset.x), nu(u.y, p.offset.y));
      }
      return u;
    }
    applyTransform(o, a = !1) {
      const u = ln();
      Ji(u, o);
      for (let l = 0; l < this.path.length; l++) {
        const d = this.path[l];
        !a && d.options.layoutScroll && d.scroll && d !== d.root && iu(u, {
          x: -d.scroll.offset.x,
          y: -d.scroll.offset.y
        }), Xa(d.latestValues) && iu(u, d.latestValues);
      }
      return Xa(this.latestValues) && iu(u, this.latestValues), u;
    }
    removeTransform(o) {
      const a = ln();
      Ji(a, o);
      for (let u = 0; u < this.path.length; u++) {
        const l = this.path[u];
        if (!l.instance || !Xa(l.latestValues))
          continue;
        av(l.latestValues) && l.updateSnapshot();
        const d = ln(), p = l.measurePageBox();
        Ji(d, p), q_(a, l.latestValues, l.snapshot ? l.snapshot.layoutBox : void 0, d);
      }
      return Xa(this.latestValues) && q_(a, this.latestValues), a;
    }
    setTargetDelta(o) {
      this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(o) {
      this.options = {
        ...this.options,
        ...o,
        crossfade: o.crossfade !== void 0 ? o.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Fn.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(o = !1) {
      var a;
      const u = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = u.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = u.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = u.isSharedProjectionDirty);
      const l = !!this.resumingFrom || this !== u;
      if (!(o || l && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: p, layoutId: w } = this.options;
      if (!(!this.layout || !(p || w))) {
        if (this.resolvedRelativeTargetAt = Fn.timestamp, !this.targetDelta && !this.relativeTarget) {
          const A = this.getClosestProjectingParent();
          A && A.layout && this.animationProgress !== 1 ? (this.relativeParent = A, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ln(), this.relativeTargetOrigin = ln(), Xf(this.relativeTargetOrigin, this.layout.layoutBox, A.layout.layoutBox), Ji(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = ln(), this.targetWithTransforms = ln()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), Lee(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Ji(this.target, this.layout.layoutBox), H7(this.target, this.targetDelta)) : Ji(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const A = this.getClosestProjectingParent();
            A && !!A.resumingFrom == !!this.resumingFrom && !A.options.layoutScroll && A.target && this.animationProgress !== 1 ? (this.relativeParent = A, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ln(), this.relativeTargetOrigin = ln(), Xf(this.relativeTargetOrigin, this.target, A.target), Ji(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          Uf && Za.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || av(this.parent.latestValues) || W7(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var o;
      const a = this.getLead(), u = !!this.resumingFrom || this !== a;
      let l = !0;
      if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (l = !1), u && (this.isSharedProjectionDirty || this.isTransformDirty) && (l = !1), this.resolvedRelativeTargetAt === Fn.timestamp && (l = !1), l)
        return;
      const { layout: d, layoutId: p } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(d || p))
        return;
      Ji(this.layoutCorrected, this.layout.layoutBox);
      const w = this.treeScale.x, A = this.treeScale.y;
      Wee(this.layoutCorrected, this.treeScale, this.path, u), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = ln());
      const { target: P } = a;
      if (!P) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (F_(this.prevProjectionDelta.x, this.projectionDelta.x), F_(this.prevProjectionDelta.y, this.projectionDelta.y)), Jf(this.projectionDelta, this.layoutCorrected, P, this.latestValues), (this.treeScale.x !== w || this.treeScale.y !== A || !V_(this.projectionDelta.x, this.prevProjectionDelta.x) || !V_(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", P)), Uf && Za.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(o = !0) {
      var a;
      if ((a = this.options.visualElement) === null || a === void 0 || a.scheduleRender(), o) {
        const u = this.getStack();
        u && u.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = ru(), this.projectionDelta = ru(), this.projectionDeltaWithTransform = ru();
    }
    setAnimationOrigin(o, a = !1) {
      const u = this.snapshot, l = u ? u.latestValues : {}, d = { ...this.latestValues }, p = ru();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
      const w = ln(), A = u ? u.source : void 0, P = this.layout ? this.layout.source : void 0, N = A !== P, L = this.getStack(), $ = !L || L.members.length <= 1, B = !!(N && !$ && this.options.crossfade === !0 && !this.path.some(Rte));
      this.animationProgress = 0;
      let H;
      this.mixTargetDelta = (W) => {
        const V = W / 1e3;
        X_(p.x, o.x, V), X_(p.y, o.y, V), this.setTargetDelta(p), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Xf(w, this.layout.layoutBox, this.relativeParent.layout.layoutBox), Tte(this.relativeTarget, this.relativeTargetOrigin, w, V), H && ute(this.relativeTarget, H) && (this.isProjectionDirty = !1), H || (H = ln()), Ji(H, this.relativeTarget)), N && (this.animationValues = d, nte(d, l, this.latestValues, V, B, $)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = V;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(o) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (Ea(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Lr.update(() => {
        jd.hasAnimatedSinceResize = !0, this.currentAnimation = mte(0, G_, {
          ...o,
          onUpdate: (a) => {
            this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a);
          },
          onComplete: () => {
            o.onComplete && o.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const o = this.getStack();
      o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(G_), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const o = this.getLead();
      let { targetWithTransforms: a, target: u, layout: l, latestValues: d } = o;
      if (!(!a || !u || !l)) {
        if (this !== o && this.layout && l && r9(this.options.animationType, this.layout.layoutBox, l.layoutBox)) {
          u = this.target || ln();
          const p = ki(this.layout.layoutBox.x);
          u.x.min = o.target.x.min, u.x.max = u.x.min + p;
          const w = ki(this.layout.layoutBox.y);
          u.y.min = o.target.y.min, u.y.max = u.y.min + w;
        }
        Ji(a, u), iu(a, d), Jf(this.projectionDeltaWithTransform, this.layoutCorrected, a, d);
      }
    }
    registerSharedNode(o, a) {
      this.sharedNodes.has(o) || this.sharedNodes.set(o, new fte()), this.sharedNodes.get(o).add(a);
      const l = a.options.initialPromotionConfig;
      a.promote({
        transition: l ? l.transition : void 0,
        preserveFollowOpacity: l && l.shouldPreserveFollowOpacity ? l.shouldPreserveFollowOpacity(a) : void 0
      });
    }
    isLead() {
      const o = this.getStack();
      return o ? o.lead === this : !0;
    }
    getLead() {
      var o;
      const { layoutId: a } = this.options;
      return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this;
    }
    getPrevLead() {
      var o;
      const { layoutId: a } = this.options;
      return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0;
    }
    getStack() {
      const { layoutId: o } = this.options;
      if (o)
        return this.root.sharedNodes.get(o);
    }
    promote({ needsReset: o, transition: a, preserveFollowOpacity: u } = {}) {
      const l = this.getStack();
      l && l.promote(this, u), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a });
    }
    relegate() {
      const o = this.getStack();
      return o ? o.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: o } = this.options;
      if (!o)
        return;
      let a = !1;
      const { latestValues: u } = o;
      if ((u.z || u.rotate || u.rotateX || u.rotateY || u.rotateZ || u.skewX || u.skewY) && (a = !0), !a)
        return;
      const l = {};
      u.z && Um("z", o, l, this.animationValues);
      for (let d = 0; d < jm.length; d++)
        Um(`rotate${jm[d]}`, o, l, this.animationValues), Um(`skew${jm[d]}`, o, l, this.animationValues);
      o.render();
      for (const d in l)
        o.setStaticValue(d, l[d]), this.animationValues && (this.animationValues[d] = l[d]);
      o.scheduleRender();
    }
    getProjectionStyles(o) {
      var a, u;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return vte;
      const l = {
        visibility: ""
      }, d = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, l.opacity = "", l.pointerEvents = Ud(o == null ? void 0 : o.pointerEvents) || "", l.transform = d ? d(this.latestValues, "") : "none", l;
      const p = this.getLead();
      if (!this.projectionDelta || !this.layout || !p.target) {
        const N = {};
        return this.options.layoutId && (N.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, N.pointerEvents = Ud(o == null ? void 0 : o.pointerEvents) || ""), this.hasProjected && !Xa(this.latestValues) && (N.transform = d ? d({}, "") : "none", this.hasProjected = !1), N;
      }
      const w = p.animationValues || p.latestValues;
      this.applyTransformsToTarget(), l.transform = lte(this.projectionDeltaWithTransform, this.treeScale, w), d && (l.transform = d(w, l.transform));
      const { x: A, y: P } = this.projectionDelta;
      l.transformOrigin = `${A.origin * 100}% ${P.origin * 100}% 0`, p.animationValues ? l.opacity = p === this ? (u = (a = w.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && u !== void 0 ? u : 1 : this.preserveOpacity ? this.latestValues.opacity : w.opacityExit : l.opacity = p === this ? w.opacity !== void 0 ? w.opacity : "" : w.opacityExit !== void 0 ? w.opacityExit : 0;
      for (const N in _0) {
        if (w[N] === void 0)
          continue;
        const { correct: L, applyTo: $ } = _0[N], B = l.transform === "none" ? w[N] : L(w[N], p);
        if ($) {
          const H = $.length;
          for (let W = 0; W < H; W++)
            l[$[W]] = B;
        } else
          l[N] = B;
      }
      return this.options.layoutId && (l.pointerEvents = p === this ? Ud(o == null ? void 0 : o.pointerEvents) || "" : "none"), l;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((o) => {
        var a;
        return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop();
      }), this.root.nodes.forEach(Y_), this.root.sharedNodes.clear();
    }
  };
}
function yte(t) {
  t.updateLayout();
}
function wte(t) {
  var e;
  const r = ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || t.snapshot;
  if (t.isLead() && t.layout && r && t.hasListeners("didUpdate")) {
    const { layoutBox: n, measuredBox: i } = t.layout, { animationType: s } = t.options, o = r.source !== t.layout.source;
    s === "size" ? Zi((p) => {
      const w = o ? r.measuredBox[p] : r.layoutBox[p], A = ki(w);
      w.min = n[p].min, w.max = w.min + A;
    }) : r9(s, r.layoutBox, n) && Zi((p) => {
      const w = o ? r.measuredBox[p] : r.layoutBox[p], A = ki(n[p]);
      w.max = w.min + A, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[p].max = t.relativeTarget[p].min + A);
    });
    const a = ru();
    Jf(a, n, r.layoutBox);
    const u = ru();
    o ? Jf(u, t.applyTransform(i, !0), r.measuredBox) : Jf(u, n, r.layoutBox);
    const l = !Z7(a);
    let d = !1;
    if (!t.resumeFrom) {
      const p = t.getClosestProjectingParent();
      if (p && !p.resumeFrom) {
        const { snapshot: w, layout: A } = p;
        if (w && A) {
          const P = ln();
          Xf(P, r.layoutBox, w.layoutBox);
          const N = ln();
          Xf(N, n, A.layoutBox), Q7(P, N) || (d = !0), p.options.layoutRoot && (t.relativeTarget = N, t.relativeTargetOrigin = P, t.relativeParent = p);
        }
      }
    }
    t.notifyListeners("didUpdate", {
      layout: n,
      snapshot: r,
      delta: u,
      layoutDelta: a,
      hasLayoutChanged: l,
      hasRelativeTargetChanged: d
    });
  } else if (t.isLead()) {
    const { onExitComplete: n } = t.options;
    n && n();
  }
  t.options.transition = void 0;
}
function xte(t) {
  Uf && Za.totalNodes++, t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty));
}
function _te(t) {
  t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1;
}
function Ete(t) {
  t.clearSnapshot();
}
function Y_(t) {
  t.clearMeasurements();
}
function Ste(t) {
  t.isLayoutDirty = !1;
}
function Ate(t) {
  const { visualElement: e } = t.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform();
}
function J_(t) {
  t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0;
}
function Pte(t) {
  t.resolveTargetDelta();
}
function Mte(t) {
  t.calcProjection();
}
function Ite(t) {
  t.resetSkewAndRotation();
}
function Cte(t) {
  t.removeLeadSnapshot();
}
function X_(t, e, r) {
  t.translate = Qr(e.translate, 0, r), t.scale = Qr(e.scale, 1, r), t.origin = e.origin, t.originPoint = e.originPoint;
}
function Z_(t, e, r, n) {
  t.min = Qr(e.min, r.min, n), t.max = Qr(e.max, r.max, n);
}
function Tte(t, e, r, n) {
  Z_(t.x, e.x, r.x, n), Z_(t.y, e.y, r.y, n);
}
function Rte(t) {
  return t.animationValues && t.animationValues.opacityExit !== void 0;
}
const Dte = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, Q_ = (t) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), e5 = Q_("applewebkit/") && !Q_("chrome/") ? Math.round : Un;
function t5(t) {
  t.min = e5(t.min), t.max = e5(t.max);
}
function Ote(t) {
  t5(t.x), t5(t.y);
}
function r9(t, e, r) {
  return t === "position" || t === "preserve-aspect" && !Nee(K_(e), K_(r), 0.2);
}
function Nte(t) {
  var e;
  return t !== t.root && ((e = t.scroll) === null || e === void 0 ? void 0 : e.wasRoot);
}
const Lte = t9({
  attachResizeListener: (t, e) => Co(t, "resize", e),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), qm = {
  current: void 0
}, n9 = t9({
  measureScroll: (t) => ({
    x: t.scrollLeft,
    y: t.scrollTop
  }),
  defaultParent: () => {
    if (!qm.current) {
      const t = new Lte({});
      t.mount(window), t.setOptions({ layoutScroll: !0 }), qm.current = t;
    }
    return qm.current;
  },
  resetTransform: (t, e) => {
    t.style.transform = e !== void 0 ? e : "none";
  },
  checkIsScrollRoot: (t) => window.getComputedStyle(t).position === "fixed"
}), kte = {
  pan: {
    Feature: Jee
  },
  drag: {
    Feature: Yee,
    ProjectionNode: n9,
    MeasureLayout: Y7
  }
};
function r5(t, e) {
  const r = e ? "pointerenter" : "pointerleave", n = e ? "onHoverStart" : "onHoverEnd", i = (s, o) => {
    if (s.pointerType === "touch" || j7())
      return;
    const a = t.getProps();
    t.animationState && a.whileHover && t.animationState.setActive("whileHover", e);
    const u = a[n];
    u && Lr.postRender(() => u(s, o));
  };
  return No(t.current, r, i, {
    passive: !t.getProps()[n]
  });
}
class $te extends Oa {
  mount() {
    this.unmount = Oo(r5(this.node, !0), r5(this.node, !1));
  }
  unmount() {
  }
}
class Bte extends Oa {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Oo(Co(this.node.current, "focus", () => this.onFocus()), Co(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const i9 = (t, e) => e ? t === e ? !0 : i9(t, e.parentElement) : !1;
function zm(t, e) {
  if (!e)
    return;
  const r = new PointerEvent("pointer" + t);
  e(r, xp(r));
}
class Fte extends Oa {
  constructor() {
    super(...arguments), this.removeStartListeners = Un, this.removeEndListeners = Un, this.removeAccessibleListeners = Un, this.startPointerPress = (e, r) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const n = this.node.getProps(), s = No(window, "pointerup", (a, u) => {
        if (!this.checkPressEnd())
          return;
        const { onTap: l, onTapCancel: d, globalTapTarget: p } = this.node.getProps(), w = !p && !i9(this.node.current, a.target) ? d : l;
        w && Lr.update(() => w(a, u));
      }, {
        passive: !(n.onTap || n.onPointerUp)
      }), o = No(window, "pointercancel", (a, u) => this.cancelPress(a, u), {
        passive: !(n.onTapCancel || n.onPointerCancel)
      });
      this.removeEndListeners = Oo(s, o), this.startPress(e, r);
    }, this.startAccessiblePress = () => {
      const e = (s) => {
        if (s.key !== "Enter" || this.isPressing)
          return;
        const o = (a) => {
          a.key !== "Enter" || !this.checkPressEnd() || zm("up", (u, l) => {
            const { onTap: d } = this.node.getProps();
            d && Lr.postRender(() => d(u, l));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = Co(this.node.current, "keyup", o), zm("down", (a, u) => {
          this.startPress(a, u);
        });
      }, r = Co(this.node.current, "keydown", e), n = () => {
        this.isPressing && zm("cancel", (s, o) => this.cancelPress(s, o));
      }, i = Co(this.node.current, "blur", n);
      this.removeAccessibleListeners = Oo(r, i);
    };
  }
  startPress(e, r) {
    this.isPressing = !0;
    const { onTapStart: n, whileTap: i } = this.node.getProps();
    i && this.node.animationState && this.node.animationState.setActive("whileTap", !0), n && Lr.postRender(() => n(e, r));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !j7();
  }
  cancelPress(e, r) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel: n } = this.node.getProps();
    n && Lr.postRender(() => n(e, r));
  }
  mount() {
    const e = this.node.getProps(), r = No(e.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, {
      passive: !(e.onTapStart || e.onPointerStart)
    }), n = Co(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = Oo(r, n);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const uv = /* @__PURE__ */ new WeakMap(), Wm = /* @__PURE__ */ new WeakMap(), jte = (t) => {
  const e = uv.get(t.target);
  e && e(t);
}, Ute = (t) => {
  t.forEach(jte);
};
function qte({ root: t, ...e }) {
  const r = t || document;
  Wm.has(r) || Wm.set(r, {});
  const n = Wm.get(r), i = JSON.stringify(e);
  return n[i] || (n[i] = new IntersectionObserver(Ute, { root: t, ...e })), n[i];
}
function zte(t, e, r) {
  const n = qte(e);
  return uv.set(t, r), n.observe(t), () => {
    uv.delete(t), n.unobserve(t);
  };
}
const Wte = {
  some: 0,
  all: 1
};
class Hte extends Oa {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(), { root: r, margin: n, amount: i = "some", once: s } = e, o = {
      root: r ? r.current : void 0,
      rootMargin: n,
      threshold: typeof i == "number" ? i : Wte[i]
    }, a = (u) => {
      const { isIntersecting: l } = u;
      if (this.isInView === l || (this.isInView = l, s && !l && this.hasEnteredView))
        return;
      l && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", l);
      const { onViewportEnter: d, onViewportLeave: p } = this.node.getProps(), w = l ? d : p;
      w && w(u);
    };
    return zte(this.node.current, o, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: e, prevProps: r } = this.node;
    ["amount", "margin", "root"].some(Kte(e, r)) && this.startObserver();
  }
  unmount() {
  }
}
function Kte({ viewport: t = {} }, { viewport: e = {} } = {}) {
  return (r) => t[r] !== e[r];
}
const Vte = {
  inView: {
    Feature: Hte
  },
  tap: {
    Feature: Fte
  },
  focus: {
    Feature: Bte
  },
  hover: {
    Feature: $te
  }
}, Gte = {
  layout: {
    ProjectionNode: n9,
    MeasureLayout: Y7
  }
}, Xb = Ma({
  transformPagePoint: (t) => t,
  isStatic: !1,
  reducedMotion: "never"
}), Ep = Ma({}), Zb = typeof window < "u", s9 = Zb ? kR : Dn, o9 = Ma({ strict: !1 });
function Yte(t, e, r, n, i) {
  var s, o;
  const { visualElement: a } = Tn(Ep), u = Tn(o9), l = Tn(_p), d = Tn(Xb).reducedMotion, p = oi();
  n = n || u.renderer, !p.current && n && (p.current = n(t, {
    visualState: e,
    parent: a,
    props: r,
    presenceContext: l,
    blockInitialAnimation: l ? l.initial === !1 : !1,
    reducedMotionConfig: d
  }));
  const w = p.current, A = Tn(G7);
  w && !w.projection && i && (w.type === "html" || w.type === "svg") && Jte(p.current, r, i, A);
  const P = oi(!1);
  w5(() => {
    w && P.current && w.update(r, l);
  });
  const N = r[R7], L = oi(!!N && !(!((s = window.MotionHandoffIsComplete) === null || s === void 0) && s.call(window, N)) && ((o = window.MotionHasOptimisedAnimation) === null || o === void 0 ? void 0 : o.call(window, N)));
  return s9(() => {
    w && (P.current = !0, window.MotionIsMounted = !0, w.updateFeatures(), Jb.render(w.render), L.current && w.animationState && w.animationState.animateChanges());
  }), Dn(() => {
    w && (!L.current && w.animationState && w.animationState.animateChanges(), L.current && (queueMicrotask(() => {
      var $;
      ($ = window.MotionHandoffMarkAsComplete) === null || $ === void 0 || $.call(window, N);
    }), L.current = !1));
  }), w;
}
function Jte(t, e, r, n) {
  const { layoutId: i, layout: s, drag: o, dragConstraints: a, layoutScroll: u, layoutRoot: l } = e;
  t.projection = new r(t.latestValues, e["data-framer-portal-id"] ? void 0 : a9(t.parent)), t.projection.setOptions({
    layoutId: i,
    layout: s,
    alwaysMeasureLayout: !!o || a && tu(a),
    visualElement: t,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof s == "string" ? s : "both",
    initialPromotionConfig: n,
    layoutScroll: u,
    layoutRoot: l
  });
}
function a9(t) {
  if (t)
    return t.options.allowProjection !== !1 ? t.projection : a9(t.parent);
}
function Xte(t, e, r) {
  return vv(
    (n) => {
      n && t.mount && t.mount(n), e && (n ? e.mount(n) : e.unmount()), r && (typeof r == "function" ? r(n) : tu(r) && (r.current = n));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [e]
  );
}
function Sp(t) {
  return bp(t.animate) || Cb.some((e) => Il(t[e]));
}
function c9(t) {
  return !!(Sp(t) || t.variants);
}
function Zte(t, e) {
  if (Sp(t)) {
    const { initial: r, animate: n } = t;
    return {
      initial: r === !1 || Il(r) ? r : void 0,
      animate: Il(n) ? n : void 0
    };
  }
  return t.inherit !== !1 ? e : {};
}
function Qte(t) {
  const { initial: e, animate: r } = Zte(t, Tn(Ep));
  return Ni(() => ({ initial: e, animate: r }), [n5(e), n5(r)]);
}
function n5(t) {
  return Array.isArray(t) ? t.join(" ") : t;
}
const i5 = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, Cu = {};
for (const t in i5)
  Cu[t] = {
    isEnabled: (e) => i5[t].some((r) => !!e[r])
  };
function ere(t) {
  for (const e in t)
    Cu[e] = {
      ...Cu[e],
      ...t[e]
    };
}
const tre = Symbol.for("motionComponentSymbol");
function rre({ preloadedFeatures: t, createVisualElement: e, useRender: r, useVisualState: n, Component: i }) {
  t && ere(t);
  function s(a, u) {
    let l;
    const d = {
      ...Tn(Xb),
      ...a,
      layoutId: nre(a)
    }, { isStatic: p } = d, w = Qte(a), A = n(a, p);
    if (!p && Zb) {
      ire(d, t);
      const P = sre(d);
      l = P.MeasureLayout, w.visualElement = Yte(i, A, d, e, P.ProjectionNode);
    }
    return fe.jsxs(Ep.Provider, { value: w, children: [l && w.visualElement ? fe.jsx(l, { visualElement: w.visualElement, ...d }) : null, r(i, a, Xte(A, w.visualElement, u), A, p, w.visualElement)] });
  }
  const o = gv(s);
  return o[tre] = i, o;
}
function nre({ layoutId: t }) {
  const e = Tn(Yb).id;
  return e && t !== void 0 ? e + "-" + t : t;
}
function ire(t, e) {
  const r = Tn(o9).strict;
  if (process.env.NODE_ENV !== "production" && e && r) {
    const n = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    t.ignoreStrict ? Ku(!1, n) : zo(!1, n);
  }
}
function sre(t) {
  const { drag: e, layout: r } = Cu;
  if (!e && !r)
    return {};
  const n = { ...e, ...r };
  return {
    MeasureLayout: e != null && e.isEnabled(t) || r != null && r.isEnabled(t) ? n.MeasureLayout : void 0,
    ProjectionNode: n.ProjectionNode
  };
}
const ore = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function Qb(t) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof t != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    t.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(ore.indexOf(t) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(t))
    )
  );
}
function u9(t, { style: e, vars: r }, n, i) {
  Object.assign(t.style, e, i && i.getProjectionStyles(n));
  for (const s in r)
    t.style.setProperty(s, r[s]);
}
const f9 = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function l9(t, e, r, n) {
  u9(t, e, void 0, n);
  for (const i in e.attrs)
    t.setAttribute(f9.has(i) ? i : Gb(i), e.attrs[i]);
}
function h9(t, { layout: e, layoutId: r }) {
  return Ac.has(t) || t.startsWith("origin") || (e || r !== void 0) && (!!_0[t] || t === "opacity");
}
function ey(t, e, r) {
  var n;
  const { style: i } = t, s = {};
  for (const o in i)
    (Xn(i[o]) || e.style && Xn(e.style[o]) || h9(o, t) || ((n = r == null ? void 0 : r.getValue(o)) === null || n === void 0 ? void 0 : n.liveStyle) !== void 0) && (s[o] = i[o]);
  return s;
}
function d9(t, e, r) {
  const n = ey(t, e, r);
  for (const i in t)
    if (Xn(t[i]) || Xn(e[i])) {
      const s = ah.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
      n[s] = t[i];
    }
  return n;
}
function ty(t) {
  const e = oi(null);
  return e.current === null && (e.current = t()), e.current;
}
function are({ scrapeMotionValuesFromProps: t, createRenderState: e, onMount: r }, n, i, s) {
  const o = {
    latestValues: cre(n, i, s, t),
    renderState: e()
  };
  return r && (o.mount = (a) => r(n, a, o)), o;
}
const p9 = (t) => (e, r) => {
  const n = Tn(Ep), i = Tn(_p), s = () => are(t, e, n, i);
  return r ? s() : ty(s);
};
function cre(t, e, r, n) {
  const i = {}, s = n(t, {});
  for (const w in s)
    i[w] = Ud(s[w]);
  let { initial: o, animate: a } = t;
  const u = Sp(t), l = c9(t);
  e && l && !u && t.inherit !== !1 && (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate));
  let d = r ? r.initial === !1 : !1;
  d = d || o === !1;
  const p = d ? a : o;
  if (p && typeof p != "boolean" && !bp(p)) {
    const w = Array.isArray(p) ? p : [p];
    for (let A = 0; A < w.length; A++) {
      const P = Mb(t, w[A]);
      if (P) {
        const { transitionEnd: N, transition: L, ...$ } = P;
        for (const B in $) {
          let H = $[B];
          if (Array.isArray(H)) {
            const W = d ? H.length - 1 : 0;
            H = H[W];
          }
          H !== null && (i[B] = H);
        }
        for (const B in N)
          i[B] = N[B];
      }
    }
  }
  return i;
}
const ry = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
}), g9 = () => ({
  ...ry(),
  attrs: {}
}), m9 = (t, e) => e && typeof t == "number" ? e.transform(t) : t, ure = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, fre = ah.length;
function lre(t, e, r) {
  let n = "", i = !0;
  for (let s = 0; s < fre; s++) {
    const o = ah[s], a = t[o];
    if (a === void 0)
      continue;
    let u = !0;
    if (typeof a == "number" ? u = a === (o.startsWith("scale") ? 1 : 0) : u = parseFloat(a) === 0, !u || r) {
      const l = m9(a, $b[o]);
      if (!u) {
        i = !1;
        const d = ure[o] || o;
        n += `${d}(${l}) `;
      }
      r && (e[o] = l);
    }
  }
  return n = n.trim(), r ? n = r(e, i ? "" : n) : i && (n = "none"), n;
}
function ny(t, e, r) {
  const { style: n, vars: i, transformOrigin: s } = t;
  let o = !1, a = !1;
  for (const u in e) {
    const l = e[u];
    if (Ac.has(u)) {
      o = !0;
      continue;
    } else if (c7(u)) {
      i[u] = l;
      continue;
    } else {
      const d = m9(l, $b[u]);
      u.startsWith("origin") ? (a = !0, s[u] = d) : n[u] = d;
    }
  }
  if (e.transform || (o || r ? n.transform = lre(e, t.transform, r) : n.transform && (n.transform = "none")), a) {
    const { originX: u = "50%", originY: l = "50%", originZ: d = 0 } = s;
    n.transformOrigin = `${u} ${l} ${d}`;
  }
}
function s5(t, e, r) {
  return typeof t == "string" ? t : Vt.transform(e + r * t);
}
function hre(t, e, r) {
  const n = s5(e, t.x, t.width), i = s5(r, t.y, t.height);
  return `${n} ${i}`;
}
const dre = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, pre = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function gre(t, e, r = 1, n = 0, i = !0) {
  t.pathLength = 1;
  const s = i ? dre : pre;
  t[s.offset] = Vt.transform(-n);
  const o = Vt.transform(e), a = Vt.transform(r);
  t[s.array] = `${o} ${a}`;
}
function iy(t, {
  attrX: e,
  attrY: r,
  attrScale: n,
  originX: i,
  originY: s,
  pathLength: o,
  pathSpacing: a = 1,
  pathOffset: u = 0,
  // This is object creation, which we try to avoid per-frame.
  ...l
}, d, p) {
  if (ny(t, l, p), d) {
    t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
    return;
  }
  t.attrs = t.style, t.style = {};
  const { attrs: w, style: A, dimensions: P } = t;
  w.transform && (P && (A.transform = w.transform), delete w.transform), P && (i !== void 0 || s !== void 0 || A.transform) && (A.transformOrigin = hre(P, i !== void 0 ? i : 0.5, s !== void 0 ? s : 0.5)), e !== void 0 && (w.x = e), r !== void 0 && (w.y = r), n !== void 0 && (w.scale = n), o !== void 0 && gre(w, o, a, u, !1);
}
const sy = (t) => typeof t == "string" && t.toLowerCase() === "svg", mre = {
  useVisualState: p9({
    scrapeMotionValuesFromProps: d9,
    createRenderState: g9,
    onMount: (t, e, { renderState: r, latestValues: n }) => {
      Lr.read(() => {
        try {
          r.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect();
        } catch {
          r.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      }), Lr.render(() => {
        iy(r, n, sy(e.tagName), t.transformTemplate), l9(e, r);
      });
    }
  })
}, vre = {
  useVisualState: p9({
    scrapeMotionValuesFromProps: ey,
    createRenderState: ry
  })
};
function v9(t, e, r) {
  for (const n in e)
    !Xn(e[n]) && !h9(n, r) && (t[n] = e[n]);
}
function bre({ transformTemplate: t }, e) {
  return Ni(() => {
    const r = ry();
    return ny(r, e, t), Object.assign({}, r.vars, r.style);
  }, [e]);
}
function yre(t, e) {
  const r = t.style || {}, n = {};
  return v9(n, r, t), Object.assign(n, bre(t, e)), n;
}
function wre(t, e) {
  const r = {}, n = yre(t, e);
  return t.drag && t.dragListener !== !1 && (r.draggable = !1, n.userSelect = n.WebkitUserSelect = n.WebkitTouchCallout = "none", n.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (r.tabIndex = 0), r.style = n, r;
}
const xre = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function E0(t) {
  return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || xre.has(t);
}
let b9 = (t) => !E0(t);
function _re(t) {
  t && (b9 = (e) => e.startsWith("on") ? !E0(e) : t(e));
}
try {
  _re(require("@emotion/is-prop-valid").default);
} catch {
}
function Ere(t, e, r) {
  const n = {};
  for (const i in t)
    i === "values" && typeof t.values == "object" || (b9(i) || r === !0 && E0(i) || !e && !E0(i) || // If trying to use native HTML drag events, forward drag listeners
    t.draggable && i.startsWith("onDrag")) && (n[i] = t[i]);
  return n;
}
function Sre(t, e, r, n) {
  const i = Ni(() => {
    const s = g9();
    return iy(s, e, sy(n), t.transformTemplate), {
      ...s.attrs,
      style: { ...s.style }
    };
  }, [e]);
  if (t.style) {
    const s = {};
    v9(s, t.style, t), i.style = { ...s, ...i.style };
  }
  return i;
}
function Are(t = !1) {
  return (r, n, i, { latestValues: s }, o) => {
    const u = (Qb(r) ? Sre : wre)(n, s, o, r), l = Ere(n, typeof r == "string", t), d = r !== x5 ? { ...l, ...u, ref: i } : {}, { children: p } = n, w = Ni(() => Xn(p) ? p.get() : p, [p]);
    return qd(r, {
      ...d,
      children: w
    });
  };
}
function Pre(t, e) {
  return function(n, { forwardMotionProps: i } = { forwardMotionProps: !1 }) {
    const o = {
      ...Qb(n) ? mre : vre,
      preloadedFeatures: t,
      useRender: Are(i),
      createVisualElement: e,
      Component: n
    };
    return rre(o);
  };
}
const fv = { current: null }, y9 = { current: !1 };
function Mre() {
  if (y9.current = !0, !!Zb)
    if (window.matchMedia) {
      const t = window.matchMedia("(prefers-reduced-motion)"), e = () => fv.current = t.matches;
      t.addListener(e), e();
    } else
      fv.current = !1;
}
function Ire(t, e, r) {
  for (const n in e) {
    const i = e[n], s = r[n];
    if (Xn(i))
      t.addValue(n, i), process.env.NODE_ENV === "development" && vp(i.version === "11.11.17", `Attempting to mix Motion versions ${i.version} with 11.11.17 may not work as expected.`);
    else if (Xn(s))
      t.addValue(n, Rl(i, { owner: t }));
    else if (s !== i)
      if (t.hasValue(n)) {
        const o = t.getValue(n);
        o.liveStyle === !0 ? o.jump(i) : o.hasAnimated || o.set(i);
      } else {
        const o = t.getStaticValue(n);
        t.addValue(n, Rl(o !== void 0 ? o : i, { owner: t }));
      }
  }
  for (const n in r)
    e[n] === void 0 && t.removeValue(n);
  return e;
}
const o5 = /* @__PURE__ */ new WeakMap(), Cre = [...l7, Yn, Aa], Tre = (t) => Cre.find(f7(t)), a5 = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class Rre {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(e, r, n) {
    return {};
  }
  constructor({ parent: e, props: r, presenceContext: n, reducedMotionConfig: i, blockInitialAnimation: s, visualState: o }, a = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = Nb, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const w = Ys.now();
      this.renderScheduledAt < w && (this.renderScheduledAt = w, Lr.render(this.render, !1, !0));
    };
    const { latestValues: u, renderState: l } = o;
    this.latestValues = u, this.baseTarget = { ...u }, this.initialValues = r.initial ? { ...u } : {}, this.renderState = l, this.parent = e, this.props = r, this.presenceContext = n, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = i, this.options = a, this.blockInitialAnimation = !!s, this.isControllingVariants = Sp(r), this.isVariantNode = c9(r), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(e && e.current);
    const { willChange: d, ...p } = this.scrapeMotionValuesFromProps(r, {}, this);
    for (const w in p) {
      const A = p[w];
      u[w] !== void 0 && Xn(A) && A.set(u[w], !1);
    }
  }
  mount(e) {
    this.current = e, o5.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((r, n) => this.bindToMotionValue(n, r)), y9.current || Mre(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : fv.current, process.env.NODE_ENV !== "production" && vp(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    o5.delete(this.current), this.projection && this.projection.unmount(), Ea(this.notifyUpdate), Ea(this.render), this.valueSubscriptions.forEach((e) => e()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const e in this.events)
      this.events[e].clear();
    for (const e in this.features) {
      const r = this.features[e];
      r && (r.unmount(), r.isMounted = !1);
    }
    this.current = null;
  }
  bindToMotionValue(e, r) {
    this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
    const n = Ac.has(e), i = r.on("change", (a) => {
      this.latestValues[e] = a, this.props.onUpdate && Lr.preRender(this.notifyUpdate), n && this.projection && (this.projection.isTransformDirty = !0);
    }), s = r.on("renderRequest", this.scheduleRender);
    let o;
    window.MotionCheckAppearSync && (o = window.MotionCheckAppearSync(this, e, r)), this.valueSubscriptions.set(e, () => {
      i(), s(), o && o(), r.owner && r.stop();
    });
  }
  sortNodePosition(e) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current);
  }
  updateFeatures() {
    let e = "animation";
    for (e in Cu) {
      const r = Cu[e];
      if (!r)
        continue;
      const { isEnabled: n, Feature: i } = r;
      if (!this.features[e] && i && n(this.props) && (this.features[e] = new i(this)), this.features[e]) {
        const s = this.features[e];
        s.isMounted ? s.update() : (s.mount(), s.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : ln();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, r) {
    this.latestValues[e] = r;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(e, r) {
    (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = r;
    for (let n = 0; n < a5.length; n++) {
      const i = a5[n];
      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
      const s = "on" + i, o = e[s];
      o && (this.propEventSubscriptions[i] = this.on(i, o));
    }
    this.prevMotionValues = Ire(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(e) {
    const r = this.getClosestVariantNode();
    if (r)
      return r.variantChildren && r.variantChildren.add(e), () => r.variantChildren.delete(e);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(e, r) {
    const n = this.values.get(e);
    r !== n && (n && this.removeValue(e), this.bindToMotionValue(e, r), this.values.set(e, r), this.latestValues[e] = r.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(e) {
    this.values.delete(e);
    const r = this.valueSubscriptions.get(e);
    r && (r(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, r) {
    if (this.props.values && this.props.values[e])
      return this.props.values[e];
    let n = this.values.get(e);
    return n === void 0 && r !== void 0 && (n = Rl(r === null ? void 0 : r, { owner: this }), this.addValue(e, n)), n;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(e, r) {
    var n;
    let i = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (n = this.getBaseTargetFromProps(this.props, e)) !== null && n !== void 0 ? n : this.readValueFromInstance(this.current, e, this.options);
    return i != null && (typeof i == "string" && (o7(i) || s7(i)) ? i = parseFloat(i) : !Tre(i) && Aa.test(r) && (i = y7(e, r)), this.setBaseTarget(e, Xn(i) ? i.get() : i)), Xn(i) ? i.get() : i;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(e, r) {
    this.baseTarget[e] = r;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(e) {
    var r;
    const { initial: n } = this.props;
    let i;
    if (typeof n == "string" || typeof n == "object") {
      const o = Mb(this.props, n, (r = this.presenceContext) === null || r === void 0 ? void 0 : r.custom);
      o && (i = o[e]);
    }
    if (n && i !== void 0)
      return i;
    const s = this.getBaseTargetFromProps(this.props, e);
    return s !== void 0 && !Xn(s) ? s : this.initialValues[e] !== void 0 && i === void 0 ? void 0 : this.baseTarget[e];
  }
  on(e, r) {
    return this.events[e] || (this.events[e] = new Vb()), this.events[e].add(r);
  }
  notify(e, ...r) {
    this.events[e] && this.events[e].notify(...r);
  }
}
class w9 extends Rre {
  constructor() {
    super(...arguments), this.KeyframeResolver = w7;
  }
  sortInstanceNodePosition(e, r) {
    return e.compareDocumentPosition(r) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, r) {
    return e.style ? e.style[r] : void 0;
  }
  removeValueFromRenderState(e, { vars: r, style: n }) {
    delete r[e], delete n[e];
  }
}
function Dre(t) {
  return window.getComputedStyle(t);
}
class Ore extends w9 {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = u9;
  }
  readValueFromInstance(e, r) {
    if (Ac.has(r)) {
      const n = Bb(r);
      return n && n.default || 0;
    } else {
      const n = Dre(e), i = (c7(r) ? n.getPropertyValue(r) : n[r]) || 0;
      return typeof i == "string" ? i.trim() : i;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: r }) {
    return K7(e, r);
  }
  build(e, r, n) {
    ny(e, r, n.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, r, n) {
    return ey(e, r, n);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    Xn(e) && (this.childSubscription = e.on("change", (r) => {
      this.current && (this.current.textContent = `${r}`);
    }));
  }
}
class Nre extends w9 {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = ln;
  }
  getBaseTargetFromProps(e, r) {
    return e[r];
  }
  readValueFromInstance(e, r) {
    if (Ac.has(r)) {
      const n = Bb(r);
      return n && n.default || 0;
    }
    return r = f9.has(r) ? r : Gb(r), e.getAttribute(r);
  }
  scrapeMotionValuesFromProps(e, r, n) {
    return d9(e, r, n);
  }
  build(e, r, n) {
    iy(e, r, this.isSVGTag, n.transformTemplate);
  }
  renderInstance(e, r, n, i) {
    l9(e, r, n, i);
  }
  mount(e) {
    this.isSVGTag = sy(e.tagName), super.mount(e);
  }
}
const Lre = (t, e) => Qb(t) ? new Nre(e) : new Ore(e, {
  allowProjection: t !== x5
}), kre = /* @__PURE__ */ Pre({
  ...Aee,
  ...Vte,
  ...kte,
  ...Gte
}, Lre), $re = /* @__PURE__ */ mZ(kre);
class Bre extends Yt.Component {
  getSnapshotBeforeUpdate(e) {
    const r = this.props.childRef.current;
    if (r && e.isPresent && !this.props.isPresent) {
      const n = this.props.sizeRef.current;
      n.height = r.offsetHeight || 0, n.width = r.offsetWidth || 0, n.top = r.offsetTop, n.left = r.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function Fre({ children: t, isPresent: e }) {
  const r = mv(), n = oi(null), i = oi({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  }), { nonce: s } = Tn(Xb);
  return w5(() => {
    const { width: o, height: a, top: u, left: l } = i.current;
    if (e || !n.current || !o || !a)
      return;
    n.current.dataset.motionPopId = r;
    const d = document.createElement("style");
    return s && (d.nonce = s), document.head.appendChild(d), d.sheet && d.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${o}px !important;
            height: ${a}px !important;
            top: ${u}px !important;
            left: ${l}px !important;
          }
        `), () => {
      document.head.removeChild(d);
    };
  }, [e]), fe.jsx(Bre, { isPresent: e, childRef: n, sizeRef: i, children: Yt.cloneElement(t, { ref: n }) });
}
const jre = ({ children: t, initial: e, isPresent: r, onExitComplete: n, custom: i, presenceAffectsLayout: s, mode: o }) => {
  const a = ty(Ure), u = mv(), l = vv((p) => {
    a.set(p, !0);
    for (const w of a.values())
      if (!w)
        return;
    n && n();
  }, [a, n]), d = Ni(
    () => ({
      id: u,
      initial: e,
      isPresent: r,
      custom: i,
      onExitComplete: l,
      register: (p) => (a.set(p, !1), () => a.delete(p))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    s ? [Math.random(), l] : [r, l]
  );
  return Ni(() => {
    a.forEach((p, w) => a.set(w, !1));
  }, [r]), Yt.useEffect(() => {
    !r && !a.size && n && n();
  }, [r]), o === "popLayout" && (t = fe.jsx(Fre, { isPresent: r, children: t })), fe.jsx(_p.Provider, { value: d, children: t });
};
function Ure() {
  return /* @__PURE__ */ new Map();
}
const bd = (t) => t.key || "";
function c5(t) {
  const e = [];
  return $R.forEach(t, (r) => {
    BR(r) && e.push(r);
  }), e;
}
const qre = ({ children: t, exitBeforeEnter: e, custom: r, initial: n = !0, onExitComplete: i, presenceAffectsLayout: s = !0, mode: o = "sync" }) => {
  zo(!e, "Replace exitBeforeEnter with mode='wait'");
  const a = Ni(() => c5(t), [t]), u = a.map(bd), l = oi(!0), d = oi(a), p = ty(() => /* @__PURE__ */ new Map()), [w, A] = Gt(a), [P, N] = Gt(a);
  s9(() => {
    l.current = !1, d.current = a;
    for (let B = 0; B < P.length; B++) {
      const H = bd(P[B]);
      u.includes(H) ? p.delete(H) : p.get(H) !== !0 && p.set(H, !1);
    }
  }, [P, u.length, u.join("-")]);
  const L = [];
  if (a !== w) {
    let B = [...a];
    for (let H = 0; H < P.length; H++) {
      const W = P[H], V = bd(W);
      u.includes(V) || (B.splice(H, 0, W), L.push(W));
    }
    o === "wait" && L.length && (B = L), N(c5(B)), A(a);
    return;
  }
  process.env.NODE_ENV !== "production" && o === "wait" && P.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
  const { forceRender: $ } = Tn(Yb);
  return fe.jsx(fe.Fragment, { children: P.map((B) => {
    const H = bd(B), W = a === P || u.includes(H), V = () => {
      if (p.has(H))
        p.set(H, !0);
      else
        return;
      let te = !0;
      p.forEach((R) => {
        R || (te = !1);
      }), te && ($ == null || $(), N(d.current), i && i());
    };
    return fe.jsx(jre, { isPresent: W, initial: !l.current || n ? void 0 : !1, custom: W ? void 0 : r, presenceAffectsLayout: s, mode: o, onExitComplete: W ? void 0 : V, children: B }, H);
  }) });
}, so = (t) => /* @__PURE__ */ fe.jsx(qre, { children: /* @__PURE__ */ fe.jsx(
  $re.div,
  {
    initial: { x: 0, opacity: 0 },
    animate: { x: 0, opacity: 1 },
    exit: { x: 30, opacity: 0 },
    transition: { duration: 0.3 },
    className: t.className,
    children: t.children
  }
) });
function oy(t) {
  const { icon: e, title: r, extra: n, onClick: i } = t;
  function s() {
    i && i();
  }
  return /* @__PURE__ */ fe.jsxs(
    "div",
    {
      className: "xc-rounded-lg xc-group xc-flex xc-cursor-pointer xc-items-center xc-gap-2 xc-border xc-border-white xc-border-opacity-15 xc-px-4 xc-py-2 xc-transition-all hover:xc-shadow-lg",
      onClick: s,
      children: [
        e,
        r,
        /* @__PURE__ */ fe.jsxs("div", { className: "xc-relative xc-ml-auto xc-h-6", children: [
          /* @__PURE__ */ fe.jsx("div", { className: "xc-relative xc-left-0 xc-opacity-100 xc-transition-all group-hover:xc-left-2 group-hover:xc-opacity-0", children: n }),
          /* @__PURE__ */ fe.jsx("div", { className: "xc-absolute xc-right-2 xc-top-0 xc-text-gray-400 xc-opacity-0 xc-transition-all group-hover:xc-right-0 group-hover:xc-opacity-100", children: /* @__PURE__ */ fe.jsx(lZ, {}) })
        ] })
      ]
    }
  );
}
function zre(t) {
  return t.lastUsed ? /* @__PURE__ */ fe.jsxs("div", { className: "xc-flex xc-items-center xc-gap-2 xc-rounded-full xc-py-1 xc-text-xs xc-text-gray-500", children: [
    /* @__PURE__ */ fe.jsx("div", { className: "xc-h-1 xc-w-1 xc-rounded-full xc-bg-[#009E8C]" }),
    "Last Used"
  ] }) : t.installed ? /* @__PURE__ */ fe.jsxs("div", { className: "xc-flex xc-items-center xc-gap-2 xc-rounded-full xc-py-1 xc-text-xs xc-text-gray-500", children: [
    /* @__PURE__ */ fe.jsx("div", { className: "xc-h-1 xc-w-1 xc-rounded-full xc-bg-[#2596FF]" }),
    "Installed"
  ] }) : null;
}
function x9(t) {
  var o, a;
  const { wallet: e, onClick: r } = t, n = /* @__PURE__ */ fe.jsx("img", { className: "xc-rounded-md xc-h-5 xc-w-5", src: (o = e.config) == null ? void 0 : o.image }), i = ((a = e.config) == null ? void 0 : a.name) || "", s = Ni(() => zre(e), [e]);
  return /* @__PURE__ */ fe.jsx(oy, { icon: n, title: i, extra: s, onClick: () => r(e) });
}
function _9(t) {
  var e, r, n = "";
  if (typeof t == "string" || typeof t == "number") n += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var i = t.length;
    for (e = 0; e < i; e++) t[e] && (r = _9(t[e])) && (n && (n += " "), n += r);
  } else for (r in t) t[r] && (n && (n += " "), n += r);
  return n;
}
function Wre() {
  for (var t, e, r = 0, n = "", i = arguments.length; r < i; r++) (t = arguments[r]) && (e = _9(t)) && (n && (n += " "), n += e);
  return n;
}
const Hre = Wre, ay = "-", Kre = (t) => {
  const e = Gre(t), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: n
  } = t;
  return {
    getClassGroupId: (o) => {
      const a = o.split(ay);
      return a[0] === "" && a.length !== 1 && a.shift(), E9(a, e) || Vre(o);
    },
    getConflictingClassGroupIds: (o, a) => {
      const u = r[o] || [];
      return a && n[o] ? [...u, ...n[o]] : u;
    }
  };
}, E9 = (t, e) => {
  var o;
  if (t.length === 0)
    return e.classGroupId;
  const r = t[0], n = e.nextPart.get(r), i = n ? E9(t.slice(1), n) : void 0;
  if (i)
    return i;
  if (e.validators.length === 0)
    return;
  const s = t.join(ay);
  return (o = e.validators.find(({
    validator: a
  }) => a(s))) == null ? void 0 : o.classGroupId;
}, u5 = /^\[(.+)\]$/, Vre = (t) => {
  if (u5.test(t)) {
    const e = u5.exec(t)[1], r = e == null ? void 0 : e.substring(0, e.indexOf(":"));
    if (r)
      return "arbitrary.." + r;
  }
}, Gre = (t) => {
  const {
    theme: e,
    prefix: r
  } = t, n = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return Jre(Object.entries(t.classGroups), r).forEach(([s, o]) => {
    lv(o, n, s, e);
  }), n;
}, lv = (t, e, r, n) => {
  t.forEach((i) => {
    if (typeof i == "string") {
      const s = i === "" ? e : f5(e, i);
      s.classGroupId = r;
      return;
    }
    if (typeof i == "function") {
      if (Yre(i)) {
        lv(i(n), e, r, n);
        return;
      }
      e.validators.push({
        validator: i,
        classGroupId: r
      });
      return;
    }
    Object.entries(i).forEach(([s, o]) => {
      lv(o, f5(e, s), r, n);
    });
  });
}, f5 = (t, e) => {
  let r = t;
  return e.split(ay).forEach((n) => {
    r.nextPart.has(n) || r.nextPart.set(n, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), r = r.nextPart.get(n);
  }), r;
}, Yre = (t) => t.isThemeGetter, Jre = (t, e) => e ? t.map(([r, n]) => {
  const i = n.map((s) => typeof s == "string" ? e + s : typeof s == "object" ? Object.fromEntries(Object.entries(s).map(([o, a]) => [e + o, a])) : s);
  return [r, i];
}) : t, Xre = (t) => {
  if (t < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, r = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map();
  const i = (s, o) => {
    r.set(s, o), e++, e > t && (e = 0, n = r, r = /* @__PURE__ */ new Map());
  };
  return {
    get(s) {
      let o = r.get(s);
      if (o !== void 0)
        return o;
      if ((o = n.get(s)) !== void 0)
        return i(s, o), o;
    },
    set(s, o) {
      r.has(s) ? r.set(s, o) : i(s, o);
    }
  };
}, S9 = "!", Zre = (t) => {
  const {
    separator: e,
    experimentalParseClassName: r
  } = t, n = e.length === 1, i = e[0], s = e.length, o = (a) => {
    const u = [];
    let l = 0, d = 0, p;
    for (let L = 0; L < a.length; L++) {
      let $ = a[L];
      if (l === 0) {
        if ($ === i && (n || a.slice(L, L + s) === e)) {
          u.push(a.slice(d, L)), d = L + s;
          continue;
        }
        if ($ === "/") {
          p = L;
          continue;
        }
      }
      $ === "[" ? l++ : $ === "]" && l--;
    }
    const w = u.length === 0 ? a : a.substring(d), A = w.startsWith(S9), P = A ? w.substring(1) : w, N = p && p > d ? p - d : void 0;
    return {
      modifiers: u,
      hasImportantModifier: A,
      baseClassName: P,
      maybePostfixModifierPosition: N
    };
  };
  return r ? (a) => r({
    className: a,
    parseClassName: o
  }) : o;
}, Qre = (t) => {
  if (t.length <= 1)
    return t;
  const e = [];
  let r = [];
  return t.forEach((n) => {
    n[0] === "[" ? (e.push(...r.sort(), n), r = []) : r.push(n);
  }), e.push(...r.sort()), e;
}, ene = (t) => ({
  cache: Xre(t.cacheSize),
  parseClassName: Zre(t),
  ...Kre(t)
}), tne = /\s+/, rne = (t, e) => {
  const {
    parseClassName: r,
    getClassGroupId: n,
    getConflictingClassGroupIds: i
  } = e, s = [], o = t.trim().split(tne);
  let a = "";
  for (let u = o.length - 1; u >= 0; u -= 1) {
    const l = o[u], {
      modifiers: d,
      hasImportantModifier: p,
      baseClassName: w,
      maybePostfixModifierPosition: A
    } = r(l);
    let P = !!A, N = n(P ? w.substring(0, A) : w);
    if (!N) {
      if (!P) {
        a = l + (a.length > 0 ? " " + a : a);
        continue;
      }
      if (N = n(w), !N) {
        a = l + (a.length > 0 ? " " + a : a);
        continue;
      }
      P = !1;
    }
    const L = Qre(d).join(":"), $ = p ? L + S9 : L, B = $ + N;
    if (s.includes(B))
      continue;
    s.push(B);
    const H = i(N, P);
    for (let W = 0; W < H.length; ++W) {
      const V = H[W];
      s.push($ + V);
    }
    a = l + (a.length > 0 ? " " + a : a);
  }
  return a;
};
function nne() {
  let t = 0, e, r, n = "";
  for (; t < arguments.length; )
    (e = arguments[t++]) && (r = A9(e)) && (n && (n += " "), n += r);
  return n;
}
const A9 = (t) => {
  if (typeof t == "string")
    return t;
  let e, r = "";
  for (let n = 0; n < t.length; n++)
    t[n] && (e = A9(t[n])) && (r && (r += " "), r += e);
  return r;
};
function ine(t, ...e) {
  let r, n, i, s = o;
  function o(u) {
    const l = e.reduce((d, p) => p(d), t());
    return r = ene(l), n = r.cache.get, i = r.cache.set, s = a, a(u);
  }
  function a(u) {
    const l = n(u);
    if (l)
      return l;
    const d = rne(u, r);
    return i(u, d), d;
  }
  return function() {
    return s(nne.apply(null, arguments));
  };
}
const Gr = (t) => {
  const e = (r) => r[t] || [];
  return e.isThemeGetter = !0, e;
}, P9 = /^\[(?:([a-z-]+):)?(.+)\]$/i, sne = /^\d+\/\d+$/, one = /* @__PURE__ */ new Set(["px", "full", "screen"]), ane = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, cne = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, une = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, fne = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, lne = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, wo = (t) => mu(t) || one.has(t) || sne.test(t), sa = (t) => Gu(t, "length", yne), mu = (t) => !!t && !Number.isNaN(Number(t)), Hm = (t) => Gu(t, "number", mu), Nf = (t) => !!t && Number.isInteger(Number(t)), hne = (t) => t.endsWith("%") && mu(t.slice(0, -1)), ur = (t) => P9.test(t), oa = (t) => ane.test(t), dne = /* @__PURE__ */ new Set(["length", "size", "percentage"]), pne = (t) => Gu(t, dne, M9), gne = (t) => Gu(t, "position", M9), mne = /* @__PURE__ */ new Set(["image", "url"]), vne = (t) => Gu(t, mne, xne), bne = (t) => Gu(t, "", wne), Lf = () => !0, Gu = (t, e, r) => {
  const n = P9.exec(t);
  return n ? n[1] ? typeof e == "string" ? n[1] === e : e.has(n[1]) : r(n[2]) : !1;
}, yne = (t) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  cne.test(t) && !une.test(t)
), M9 = () => !1, wne = (t) => fne.test(t), xne = (t) => lne.test(t), _ne = () => {
  const t = Gr("colors"), e = Gr("spacing"), r = Gr("blur"), n = Gr("brightness"), i = Gr("borderColor"), s = Gr("borderRadius"), o = Gr("borderSpacing"), a = Gr("borderWidth"), u = Gr("contrast"), l = Gr("grayscale"), d = Gr("hueRotate"), p = Gr("invert"), w = Gr("gap"), A = Gr("gradientColorStops"), P = Gr("gradientColorStopPositions"), N = Gr("inset"), L = Gr("margin"), $ = Gr("opacity"), B = Gr("padding"), H = Gr("saturate"), W = Gr("scale"), V = Gr("sepia"), te = Gr("skew"), R = Gr("space"), K = Gr("translate"), ge = () => ["auto", "contain", "none"], Ee = () => ["auto", "hidden", "clip", "visible", "scroll"], Y = () => ["auto", ur, e], S = () => [ur, e], m = () => ["", wo, sa], f = () => ["auto", mu, ur], g = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], b = () => ["solid", "dashed", "dotted", "double", "none"], x = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], _ = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], E = () => ["", "0", ur], v = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], M = () => [mu, ur];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Lf],
      spacing: [wo, sa],
      blur: ["none", "", oa, ur],
      brightness: M(),
      borderColor: [t],
      borderRadius: ["none", "", "full", oa, ur],
      borderSpacing: S(),
      borderWidth: m(),
      contrast: M(),
      grayscale: E(),
      hueRotate: M(),
      invert: E(),
      gap: S(),
      gradientColorStops: [t],
      gradientColorStopPositions: [hne, sa],
      inset: Y(),
      margin: Y(),
      opacity: M(),
      padding: S(),
      saturate: M(),
      scale: M(),
      sepia: E(),
      skew: M(),
      space: S(),
      translate: S()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", ur]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [oa]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": v()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": v()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...g(), ur]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: Ee()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": Ee()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": Ee()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: ge()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": ge()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": ge()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [N]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [N]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [N]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [N]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [N]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [N]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [N]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [N]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [N]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Nf, ur]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: Y()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", ur]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: E()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: E()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Nf, ur]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Lf]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Nf, ur]
        }, ur]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": f()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": f()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Lf]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Nf, ur]
        }, ur]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": f()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": f()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", ur]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", ur]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [w]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [w]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [w]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ..._()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ..._(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [..._(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [B]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [B]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [B]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [B]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [B]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [B]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [B]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [B]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [B]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [L]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [L]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [L]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [L]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [L]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [L]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [L]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [L]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [L]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [R]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [R]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", ur, e]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [ur, e, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [ur, e, "none", "full", "min", "max", "fit", "prose", {
          screen: [oa]
        }, oa]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [ur, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [ur, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [ur, e, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [ur, e, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", oa, sa]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Hm]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Lf]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", ur]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", mu, Hm]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", wo, ur]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", ur]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", ur]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [t]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [$]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [t]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [$]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...b(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", wo, sa]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", wo, ur]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [t]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: S()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ur]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", ur]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [$]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...g(), gne]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", pne]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, vne]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [t]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [P]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [P]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [P]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [A]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [A]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [A]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [s]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [s]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [s]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [s]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [s]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [s]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [s]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [s]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [s]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [s]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [s]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [s]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [s]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [s]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [s]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [a]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [a]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [a]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [a]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [a]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [a]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [a]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [a]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [a]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [$]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...b(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [a]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [a]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [$]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: b()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [i]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [i]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [i]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [i]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [i]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [i]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [i]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [i]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [i]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [i]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...b()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [wo, ur]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [wo, sa]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [t]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: m()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [t]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [$]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [wo, sa]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [t]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", oa, bne]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Lf]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [$]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...x(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": x()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [r]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [n]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [u]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", oa, ur]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [l]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [d]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [p]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [H]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [V]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [r]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [n]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [u]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [l]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [d]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [p]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [$]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [H]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [V]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [o]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [o]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [o]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", ur]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: M()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", ur]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: M()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", ur]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [W]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [W]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [W]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Nf, ur]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [K]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [K]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [te]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [te]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", ur]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", t]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ur]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [t]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": S()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": S()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": S()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": S()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": S()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": S()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": S()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": S()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": S()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": S()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": S()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": S()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": S()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": S()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": S()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": S()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": S()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": S()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", ur]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [t, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [wo, sa, Hm]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [t, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, Ene = /* @__PURE__ */ ine(_ne);
function Js(...t) {
  return Ene(Hre(t));
}
function I9(t) {
  const { className: e } = t;
  return /* @__PURE__ */ fe.jsxs("div", { className: Js("xc-flex xc-items-center xc-gap-2"), children: [
    /* @__PURE__ */ fe.jsx("hr", { className: Js("xc-flex-1 xc-border-gray-200", e) }),
    /* @__PURE__ */ fe.jsx("div", { className: "xc-shrink-0", children: t.children }),
    /* @__PURE__ */ fe.jsx("hr", { className: Js("xc-flex-1 xc-border-gray-200", e) })
  ] });
}
const Sne = "https://static.codatta.io/codatta-connect/wallet-icons.svg?v=2#ton";
function Ane(t) {
  const { onClick: e } = t;
  function r() {
    e && e();
  }
  return /* @__PURE__ */ fe.jsx(I9, { className: "xc-opacity-20", children: /* @__PURE__ */ fe.jsxs("div", { className: "xc-flex xc-items-center xc-gap-2 xc-cursor-pointer", onClick: r, children: [
    /* @__PURE__ */ fe.jsx("span", { className: "xc-text-sm", children: "View more wallets" }),
    /* @__PURE__ */ fe.jsx(HS, { size: 16 })
  ] }) });
}
function C9(t) {
  const [e, r] = Gt(""), { featuredWallets: n, initialized: i } = mp(), { onEmailConfirm: s, onSelectWallet: o, onSelectMoreWallets: a, onSelectTonConnect: u, config: l } = t, d = Ni(() => {
    const N = /[\u4e00-\u9fff]|[\u3400-\u4dbf]|[\u{20000}-\u{2a6df}]|[\u{2a700}-\u{2b73f}]|[\u{2b740}-\u{2b81f}]|[\u{2b820}-\u{2ceaf}]|[\uf900-\ufaff]|[\u3300-\u33ff]|[\ufe30-\ufe4f]/gu, L = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return !N.test(e) && L.test(e);
  }, [e]);
  function p(N) {
    o(N);
  }
  function w(N) {
    r(N.target.value);
  }
  async function A() {
    s(e);
  }
  function P(N) {
    N.key === "Enter" && d && A();
  }
  return /* @__PURE__ */ fe.jsx(so, { children: i && /* @__PURE__ */ fe.jsxs(fe.Fragment, { children: [
    t.header || /* @__PURE__ */ fe.jsx("div", { className: "xc-mb-6 xc-text-xl xc-font-bold", children: "Log in or sign up" }),
    l.showEmailSignIn && /* @__PURE__ */ fe.jsxs("div", { className: "xc-mb-4", children: [
      /* @__PURE__ */ fe.jsx("input", { className: "xc-w-full xc-bg-transparent xc-border-white xc-border xc-border-opacity-15 xc-h-10 xc-rounded-lg xc-px-3 xc-mb-3", placeholder: "Enter your email", type: "email", onChange: w, onKeyDown: P }),
      /* @__PURE__ */ fe.jsx("button", { disabled: !d, className: "xc-bg-[rgb(135,93,255)] xc-text-white xc-w-full xc-rounded-lg xc-py-2 disabled:xc-bg-opacity-10 disabled:xc-text-opacity-50 disabled:xc-bg-white xc-transition-all", onClick: A, children: "Continue" })
    ] }),
    l.showEmailSignIn && (l.showFeaturedWallets || l.showTonConnect) && /* @__PURE__ */ fe.jsx("div", { className: "xc-mb-4", children: /* @__PURE__ */ fe.jsxs(I9, { className: "xc-opacity-20", children: [
      " ",
      /* @__PURE__ */ fe.jsx("span", { className: "xc-text-sm xc-opacity-20", children: "OR" })
    ] }) }),
    /* @__PURE__ */ fe.jsxs("div", { children: [
      /* @__PURE__ */ fe.jsxs("div", { className: "xc-mb-4 xc-flex xc-max-h-[309px] xc-flex-col xc-gap-4 xc-overflow-scroll no-scrollbar", children: [
        l.showFeaturedWallets && n && n.map((N) => /* @__PURE__ */ fe.jsx(
          x9,
          {
            wallet: N,
            onClick: p
          },
          `feature-${N.key}`
        )),
        l.showTonConnect && /* @__PURE__ */ fe.jsx(
          oy,
          {
            icon: /* @__PURE__ */ fe.jsx("img", { className: "xc-h-5 xc-w-5", src: Sne }),
            title: "TON Connect",
            onClick: u
          }
        )
      ] }),
      l.showMoreWallets && /* @__PURE__ */ fe.jsx(Ane, { onClick: a })
    ] })
  ] }) });
}
function Pc(t) {
  const { title: e } = t;
  return /* @__PURE__ */ fe.jsxs("div", { className: "xc-flex xc-items-center xc-gap-2", children: [
    /* @__PURE__ */ fe.jsx(fZ, { onClick: t.onBack, size: 20, className: "xc-cursor-pointer" }),
    /* @__PURE__ */ fe.jsx("span", { children: e })
  ] });
}
var Pne = Object.defineProperty, Mne = Object.defineProperties, Ine = Object.getOwnPropertyDescriptors, S0 = Object.getOwnPropertySymbols, T9 = Object.prototype.hasOwnProperty, R9 = Object.prototype.propertyIsEnumerable, l5 = (t, e, r) => e in t ? Pne(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Cne = (t, e) => {
  for (var r in e || (e = {})) T9.call(e, r) && l5(t, r, e[r]);
  if (S0) for (var r of S0(e)) R9.call(e, r) && l5(t, r, e[r]);
  return t;
}, Tne = (t, e) => Mne(t, Ine(e)), Rne = (t, e) => {
  var r = {};
  for (var n in t) T9.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && S0) for (var n of S0(t)) e.indexOf(n) < 0 && R9.call(t, n) && (r[n] = t[n]);
  return r;
};
function Dne(t) {
  let e = setTimeout(t, 0), r = setTimeout(t, 10), n = setTimeout(t, 50);
  return [e, r, n];
}
function One(t) {
  let e = Yt.useRef();
  return Yt.useEffect(() => {
    e.current = t;
  }), e.current;
}
var Nne = 18, D9 = 40, Lne = `${D9}px`, kne = ["[data-lastpass-icon-root]", "com-1password-button", "[data-dashlanecreated]", '[style$="2147483647 !important;"]'].join(",");
function $ne({ containerRef: t, inputRef: e, pushPasswordManagerStrategy: r, isFocused: n }) {
  let [i, s] = Yt.useState(!1), [o, a] = Yt.useState(!1), [u, l] = Yt.useState(!1), d = Yt.useMemo(() => r === "none" ? !1 : (r === "increase-width" || r === "experimental-no-flickering") && i && o, [i, o, r]), p = Yt.useCallback(() => {
    let w = t.current, A = e.current;
    if (!w || !A || u || r === "none") return;
    let P = w, N = P.getBoundingClientRect().left + P.offsetWidth, L = P.getBoundingClientRect().top + P.offsetHeight / 2, $ = N - Nne, B = L;
    document.querySelectorAll(kne).length === 0 && document.elementFromPoint($, B) === w || (s(!0), l(!0));
  }, [t, e, u, r]);
  return Yt.useEffect(() => {
    let w = t.current;
    if (!w || r === "none") return;
    function A() {
      let N = window.innerWidth - w.getBoundingClientRect().right;
      a(N >= D9);
    }
    A();
    let P = setInterval(A, 1e3);
    return () => {
      clearInterval(P);
    };
  }, [t, r]), Yt.useEffect(() => {
    let w = n || document.activeElement === e.current;
    if (r === "none" || !w) return;
    let A = setTimeout(p, 0), P = setTimeout(p, 2e3), N = setTimeout(p, 5e3), L = setTimeout(() => {
      l(!0);
    }, 6e3);
    return () => {
      clearTimeout(A), clearTimeout(P), clearTimeout(N), clearTimeout(L);
    };
  }, [e, n, r, p]), { hasPWMBadge: i, willPushPWMBadge: d, PWM_BADGE_SPACE_WIDTH: Lne };
}
var O9 = Yt.createContext({}), N9 = Yt.forwardRef((t, e) => {
  var r = t, { value: n, onChange: i, maxLength: s, textAlign: o = "left", pattern: a, placeholder: u, inputMode: l = "numeric", onComplete: d, pushPasswordManagerStrategy: p = "increase-width", pasteTransformer: w, containerClassName: A, noScriptCSSFallback: P = Bne, render: N, children: L } = r, $ = Rne(r, ["value", "onChange", "maxLength", "textAlign", "pattern", "placeholder", "inputMode", "onComplete", "pushPasswordManagerStrategy", "pasteTransformer", "containerClassName", "noScriptCSSFallback", "render", "children"]), B, H, W, V, te;
  let [R, K] = Yt.useState(typeof $.defaultValue == "string" ? $.defaultValue : ""), ge = n ?? R, Ee = One(ge), Y = Yt.useCallback((ie) => {
    i == null || i(ie), K(ie);
  }, [i]), S = Yt.useMemo(() => a ? typeof a == "string" ? new RegExp(a) : a : null, [a]), m = Yt.useRef(null), f = Yt.useRef(null), g = Yt.useRef({ value: ge, onChange: Y, isIOS: typeof window < "u" && ((H = (B = window == null ? void 0 : window.CSS) == null ? void 0 : B.supports) == null ? void 0 : H.call(B, "-webkit-touch-callout", "none")) }), b = Yt.useRef({ prev: [(W = m.current) == null ? void 0 : W.selectionStart, (V = m.current) == null ? void 0 : V.selectionEnd, (te = m.current) == null ? void 0 : te.selectionDirection] });
  Yt.useImperativeHandle(e, () => m.current, []), Yt.useEffect(() => {
    let ie = m.current, ue = f.current;
    if (!ie || !ue) return;
    g.current.value !== ie.value && g.current.onChange(ie.value), b.current.prev = [ie.selectionStart, ie.selectionEnd, ie.selectionDirection];
    function ve() {
      if (document.activeElement !== ie) {
        I(null), ce(null);
        return;
      }
      let Ce = ie.selectionStart, $e = ie.selectionEnd, Me = ie.selectionDirection, Ne = ie.maxLength, Ke = ie.value, Le = b.current.prev, qe = -1, ze = -1, _e;
      if (Ke.length !== 0 && Ce !== null && $e !== null) {
        let Qe = Ce === $e, tt = Ce === Ke.length && Ke.length < Ne;
        if (Qe && !tt) {
          let Ye = Ce;
          if (Ye === 0) qe = 0, ze = 1, _e = "forward";
          else if (Ye === Ne) qe = Ye - 1, ze = Ye, _e = "backward";
          else if (Ne > 1 && Ke.length > 1) {
            let dt = 0;
            if (Le[0] !== null && Le[1] !== null) {
              _e = Ye < Le[1] ? "backward" : "forward";
              let lt = Le[0] === Le[1] && Le[0] < Ne;
              _e === "backward" && !lt && (dt = -1);
            }
            qe = dt + Ye, ze = dt + Ye + 1;
          }
        }
        qe !== -1 && ze !== -1 && qe !== ze && m.current.setSelectionRange(qe, ze, _e);
      }
      let Ze = qe !== -1 ? qe : Ce, at = ze !== -1 ? ze : $e, ke = _e ?? Me;
      I(Ze), ce(at), b.current.prev = [Ze, at, ke];
    }
    if (document.addEventListener("selectionchange", ve, { capture: !0 }), ve(), document.activeElement === ie && v(!0), !document.getElementById("input-otp-style")) {
      let Ce = document.createElement("style");
      if (Ce.id = "input-otp-style", document.head.appendChild(Ce), Ce.sheet) {
        let $e = "background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";
        kf(Ce.sheet, "[data-input-otp]::selection { background: transparent !important; color: transparent !important; }"), kf(Ce.sheet, `[data-input-otp]:autofill { ${$e} }`), kf(Ce.sheet, `[data-input-otp]:-webkit-autofill { ${$e} }`), kf(Ce.sheet, "@supports (-webkit-touch-callout: none) { [data-input-otp] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"), kf(Ce.sheet, "[data-input-otp] + * { pointer-events: all !important; }");
      }
    }
    let Pe = () => {
      ue && ue.style.setProperty("--root-height", `${ie.clientHeight}px`);
    };
    Pe();
    let De = new ResizeObserver(Pe);
    return De.observe(ie), () => {
      document.removeEventListener("selectionchange", ve, { capture: !0 }), De.disconnect();
    };
  }, []);
  let [x, _] = Yt.useState(!1), [E, v] = Yt.useState(!1), [M, I] = Yt.useState(null), [F, ce] = Yt.useState(null);
  Yt.useEffect(() => {
    Dne(() => {
      var ie, ue, ve, Pe;
      (ie = m.current) == null || ie.dispatchEvent(new Event("input"));
      let De = (ue = m.current) == null ? void 0 : ue.selectionStart, Ce = (ve = m.current) == null ? void 0 : ve.selectionEnd, $e = (Pe = m.current) == null ? void 0 : Pe.selectionDirection;
      De !== null && Ce !== null && (I(De), ce(Ce), b.current.prev = [De, Ce, $e]);
    });
  }, [ge, E]), Yt.useEffect(() => {
    Ee !== void 0 && ge !== Ee && Ee.length < s && ge.length === s && (d == null || d(ge));
  }, [s, d, Ee, ge]);
  let D = $ne({ containerRef: f, inputRef: m, pushPasswordManagerStrategy: p, isFocused: E }), oe = Yt.useCallback((ie) => {
    let ue = ie.currentTarget.value.slice(0, s);
    if (ue.length > 0 && S && !S.test(ue)) {
      ie.preventDefault();
      return;
    }
    typeof Ee == "string" && ue.length < Ee.length && document.dispatchEvent(new Event("selectionchange")), Y(ue);
  }, [s, Y, Ee, S]), Z = Yt.useCallback(() => {
    var ie;
    if (m.current) {
      let ue = Math.min(m.current.value.length, s - 1), ve = m.current.value.length;
      (ie = m.current) == null || ie.setSelectionRange(ue, ve), I(ue), ce(ve);
    }
    v(!0);
  }, [s]), J = Yt.useCallback((ie) => {
    var ue, ve;
    let Pe = m.current;
    if (!w && (!g.current.isIOS || !ie.clipboardData || !Pe)) return;
    let De = ie.clipboardData.getData("text/plain"), Ce = w ? w(De) : De;
    console.log({ _content: De, content: Ce }), ie.preventDefault();
    let $e = (ue = m.current) == null ? void 0 : ue.selectionStart, Me = (ve = m.current) == null ? void 0 : ve.selectionEnd, Ne = ($e !== Me ? ge.slice(0, $e) + Ce + ge.slice(Me) : ge.slice(0, $e) + Ce + ge.slice($e)).slice(0, s);
    if (Ne.length > 0 && S && !S.test(Ne)) return;
    Pe.value = Ne, Y(Ne);
    let Ke = Math.min(Ne.length, s - 1), Le = Ne.length;
    Pe.setSelectionRange(Ke, Le), I(Ke), ce(Le);
  }, [s, Y, S, ge]), Q = Yt.useMemo(() => ({ position: "relative", cursor: $.disabled ? "default" : "text", userSelect: "none", WebkitUserSelect: "none", pointerEvents: "none" }), [$.disabled]), T = Yt.useMemo(() => ({ position: "absolute", inset: 0, width: D.willPushPWMBadge ? `calc(100% + ${D.PWM_BADGE_SPACE_WIDTH})` : "100%", clipPath: D.willPushPWMBadge ? `inset(0 ${D.PWM_BADGE_SPACE_WIDTH} 0 0)` : void 0, height: "100%", display: "flex", textAlign: o, opacity: "1", color: "transparent", pointerEvents: "all", background: "transparent", caretColor: "transparent", border: "0 solid transparent", outline: "0 solid transparent", boxShadow: "none", lineHeight: "1", letterSpacing: "-.5em", fontSize: "var(--root-height)", fontFamily: "monospace", fontVariantNumeric: "tabular-nums" }), [D.PWM_BADGE_SPACE_WIDTH, D.willPushPWMBadge, o]), X = Yt.useMemo(() => Yt.createElement("input", Tne(Cne({ autoComplete: $.autoComplete || "one-time-code" }, $), { "data-input-otp": !0, "data-input-otp-placeholder-shown": ge.length === 0 || void 0, "data-input-otp-mss": M, "data-input-otp-mse": F, inputMode: l, pattern: S == null ? void 0 : S.source, "aria-placeholder": u, style: T, maxLength: s, value: ge, ref: m, onPaste: (ie) => {
    var ue;
    J(ie), (ue = $.onPaste) == null || ue.call($, ie);
  }, onChange: oe, onMouseOver: (ie) => {
    var ue;
    _(!0), (ue = $.onMouseOver) == null || ue.call($, ie);
  }, onMouseLeave: (ie) => {
    var ue;
    _(!1), (ue = $.onMouseLeave) == null || ue.call($, ie);
  }, onFocus: (ie) => {
    var ue;
    Z(), (ue = $.onFocus) == null || ue.call($, ie);
  }, onBlur: (ie) => {
    var ue;
    v(!1), (ue = $.onBlur) == null || ue.call($, ie);
  } })), [oe, Z, J, l, T, s, F, M, $, S == null ? void 0 : S.source, ge]), re = Yt.useMemo(() => ({ slots: Array.from({ length: s }).map((ie, ue) => {
    var ve;
    let Pe = E && M !== null && F !== null && (M === F && ue === M || ue >= M && ue < F), De = ge[ue] !== void 0 ? ge[ue] : null, Ce = ge[0] !== void 0 ? null : (ve = u == null ? void 0 : u[ue]) != null ? ve : null;
    return { char: De, placeholderChar: Ce, isActive: Pe, hasFakeCaret: Pe && De === null };
  }), isFocused: E, isHovering: !$.disabled && x }), [E, x, s, F, M, $.disabled, ge]), pe = Yt.useMemo(() => N ? N(re) : Yt.createElement(O9.Provider, { value: re }, L), [L, re, N]);
  return Yt.createElement(Yt.Fragment, null, P !== null && Yt.createElement("noscript", null, Yt.createElement("style", null, P)), Yt.createElement("div", { ref: f, "data-input-otp-container": !0, style: Q, className: A }, pe, Yt.createElement("div", { style: { position: "absolute", inset: 0, pointerEvents: "none" } }, X)));
});
N9.displayName = "Input";
function kf(t, e) {
  try {
    t.insertRule(e);
  } catch {
    console.error("input-otp could not insert CSS rule:", e);
  }
}
var Bne = `
[data-input-otp] {
  --nojs-bg: white !important;
  --nojs-fg: black !important;

  background-color: var(--nojs-bg) !important;
  color: var(--nojs-fg) !important;
  caret-color: var(--nojs-fg) !important;
  letter-spacing: .25em !important;
  text-align: center !important;
  border: 1px solid var(--nojs-fg) !important;
  border-radius: 4px !important;
  width: 100% !important;
}
@media (prefers-color-scheme: dark) {
  [data-input-otp] {
    --nojs-bg: black !important;
    --nojs-fg: white !important;
  }
}`;
const cy = Yt.forwardRef(({ className: t, containerClassName: e, ...r }, n) => /* @__PURE__ */ fe.jsx(
  N9,
  {
    ref: n,
    containerClassName: Js(
      "xc-flex xc-items-center xc-gap-2 xc-has-[:disabled]:opacity-50",
      e
    ),
    className: Js("disabled:xc-cursor-not-allowed", t),
    ...r
  }
));
cy.displayName = "InputOTP";
const uy = Yt.forwardRef(({ className: t, ...e }, r) => /* @__PURE__ */ fe.jsx("div", { ref: r, className: Js("xc-flex xc-items-center", t), ...e }));
uy.displayName = "InputOTPGroup";
const Ri = Yt.forwardRef(({ index: t, className: e, ...r }, n) => {
  const i = Yt.useContext(O9), { char: s, hasFakeCaret: o, isActive: a } = i.slots[t];
  return /* @__PURE__ */ fe.jsxs(
    "div",
    {
      ref: n,
      className: Js(
        "xc-relative xc-rounded-xl xc-text-2xl xc-flex xc-h-12 xc-w-12 xc-items-center xc-justify-center xc-border xc-border-white xc-border-opacity-20 xc-transition-all",
        a && "xc-z-10 xc-ring-2 xc-ring-ring xc-ring-[rgb(135,93,255)] xc-ring-offset-background",
        e
      ),
      ...r,
      children: [
        s,
        o && /* @__PURE__ */ fe.jsx("div", { className: "xc-pointer-events-none xc-absolute xc-inset-0 xc-flex xc-items-center xc-justify-center", children: /* @__PURE__ */ fe.jsx("div", { className: "xc-h-4 xc-w-px xc-animate-caret-blink xc-bg-foreground xc-duration-1000" }) })
      ]
    }
  );
});
Ri.displayName = "InputOTPSlot";
function L9(t) {
  const { spinning: e, children: r, className: n } = t;
  return /* @__PURE__ */ fe.jsxs("div", { className: "xc-inline-block xc-relative", children: [
    r,
    e && /* @__PURE__ */ fe.jsx("div", { className: Js("xc-absolute xc-top-0 xc-left-0 xc-w-full xc-h-full xc-bg-black xc-bg-opacity-10 xc-flex xc-items-center xc-justify-center", n), children: /* @__PURE__ */ fe.jsx(_a, { className: "xc-animate-spin" }) })
  ] });
}
const k9 = Ma({
  channel: "",
  device: "WEB",
  app: "",
  inviterCode: ""
});
function fy() {
  return Tn(k9);
}
function Fne(t) {
  const { config: e } = t, [r, n] = Gt(e.channel), [i, s] = Gt(e.device), [o, a] = Gt(e.app), [u, l] = Gt(e.inviterCode);
  return Dn(() => {
    n(e.channel), s(e.device), a(e.app), l(e.inviterCode);
  }, [e]), /* @__PURE__ */ fe.jsx(
    k9.Provider,
    {
      value: {
        channel: r,
        device: i,
        app: o,
        inviterCode: u
      },
      children: t.children
    }
  );
}
function jne(t) {
  const { email: e } = t, [r, n] = Gt(0), [i, s] = Gt(!1), [o, a] = Gt(!1), [u, l] = Gt(""), [d, p] = Gt(""), w = fy();
  async function A() {
    n(60);
    const L = setInterval(() => {
      n(($) => $ === 0 ? (clearInterval(L), 0) : $ - 1);
    }, 1e3);
  }
  async function P(L) {
    a(!0);
    try {
      l(""), await qo.getEmailCode({ account_type: "email", email: L }), A();
    } catch ($) {
      l($.message);
    }
    a(!1);
  }
  Dn(() => {
    e && P(e);
  }, [e]);
  async function N(L) {
    if (p(""), !(L.length < 6)) {
      s(!0);
      try {
        const $ = await qo.emailLogin({
          account_type: "email",
          connector: "codatta_email",
          account_enum: "C",
          email_code: L,
          email: e,
          inviter_code: w.inviterCode,
          source: {
            device: w.device,
            channel: w.channel,
            app: w.app
          }
        });
        t.onLogin($.data);
      } catch ($) {
        p($.message);
      }
      s(!1);
    }
  }
  return /* @__PURE__ */ fe.jsxs(so, { children: [
    /* @__PURE__ */ fe.jsx("div", { className: "xc-mb-12", children: /* @__PURE__ */ fe.jsx(Pc, { title: "Sign in with email", onBack: t.onBack }) }),
    /* @__PURE__ */ fe.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center xc-justify-center xc-mb-12", children: [
      /* @__PURE__ */ fe.jsx(VS, { className: "xc-mb-4", size: 60 }),
      /* @__PURE__ */ fe.jsx("div", { className: "xc-flex xc-flex-col xc-items-center xc-justify-center xc-mb-8 xc-h-16", children: u ? /* @__PURE__ */ fe.jsx("div", { className: "xc-text-[#ff0000] xc-text-center", children: /* @__PURE__ */ fe.jsx("p", { className: "xc-px-8", children: u }) }) : o ? /* @__PURE__ */ fe.jsx(_a, { className: "xc-animate-spin" }) : /* @__PURE__ */ fe.jsxs(fe.Fragment, { children: [
        /* @__PURE__ */ fe.jsx("p", { className: "xc-text-lg xc-mb-1", children: "Weve sent a verification code to" }),
        /* @__PURE__ */ fe.jsx("p", { className: "xc-font-bold xc-text-center", children: e })
      ] }) }),
      /* @__PURE__ */ fe.jsx("div", { className: "xc-mb-2 xc-h-12", children: /* @__PURE__ */ fe.jsx(L9, { spinning: i, className: "xc-rounded-xl", children: /* @__PURE__ */ fe.jsx(cy, { maxLength: 6, onChange: N, disabled: i, className: "disabled:xc-opacity-20", children: /* @__PURE__ */ fe.jsx(uy, { children: /* @__PURE__ */ fe.jsxs("div", { className: Js("xc-flex xc-gap-2", i ? "xc-opacity-20" : ""), children: [
        /* @__PURE__ */ fe.jsx(Ri, { index: 0 }),
        /* @__PURE__ */ fe.jsx(Ri, { index: 1 }),
        /* @__PURE__ */ fe.jsx(Ri, { index: 2 }),
        /* @__PURE__ */ fe.jsx(Ri, { index: 3 }),
        /* @__PURE__ */ fe.jsx(Ri, { index: 4 }),
        /* @__PURE__ */ fe.jsx(Ri, { index: 5 })
      ] }) }) }) }) }),
      d && /* @__PURE__ */ fe.jsx("div", { className: "xc-text-[#ff0000] xc-text-center", children: /* @__PURE__ */ fe.jsx("p", { children: d }) })
    ] }),
    /* @__PURE__ */ fe.jsxs("div", { className: "xc-text-center xc-text-sm xc-text-gray-400", children: [
      "Not get it? ",
      r ? `Recend in ${r}s` : /* @__PURE__ */ fe.jsx("button", { onClick: () => P(e), children: "Send again" })
    ] })
  ] });
}
var $9 = { exports: {} };
(function(t, e) {
  (function(r, n) {
    t.exports = n();
  })(gn, () => (() => {
    var r = { 873: (o, a) => {
      var u, l, d = function() {
        var p = function(f, g) {
          var b = f, x = $[g], _ = null, E = 0, v = null, M = [], I = {}, F = function(re, pe) {
            _ = function(ie) {
              for (var ue = new Array(ie), ve = 0; ve < ie; ve += 1) {
                ue[ve] = new Array(ie);
                for (var Pe = 0; Pe < ie; Pe += 1) ue[ve][Pe] = null;
              }
              return ue;
            }(E = 4 * b + 17), ce(0, 0), ce(E - 7, 0), ce(0, E - 7), oe(), D(), J(re, pe), b >= 7 && Z(re), v == null && (v = T(b, x, M)), Q(v, pe);
          }, ce = function(re, pe) {
            for (var ie = -1; ie <= 7; ie += 1) if (!(re + ie <= -1 || E <= re + ie)) for (var ue = -1; ue <= 7; ue += 1) pe + ue <= -1 || E <= pe + ue || (_[re + ie][pe + ue] = 0 <= ie && ie <= 6 && (ue == 0 || ue == 6) || 0 <= ue && ue <= 6 && (ie == 0 || ie == 6) || 2 <= ie && ie <= 4 && 2 <= ue && ue <= 4);
          }, D = function() {
            for (var re = 8; re < E - 8; re += 1) _[re][6] == null && (_[re][6] = re % 2 == 0);
            for (var pe = 8; pe < E - 8; pe += 1) _[6][pe] == null && (_[6][pe] = pe % 2 == 0);
          }, oe = function() {
            for (var re = B.getPatternPosition(b), pe = 0; pe < re.length; pe += 1) for (var ie = 0; ie < re.length; ie += 1) {
              var ue = re[pe], ve = re[ie];
              if (_[ue][ve] == null) for (var Pe = -2; Pe <= 2; Pe += 1) for (var De = -2; De <= 2; De += 1) _[ue + Pe][ve + De] = Pe == -2 || Pe == 2 || De == -2 || De == 2 || Pe == 0 && De == 0;
            }
          }, Z = function(re) {
            for (var pe = B.getBCHTypeNumber(b), ie = 0; ie < 18; ie += 1) {
              var ue = !re && (pe >> ie & 1) == 1;
              _[Math.floor(ie / 3)][ie % 3 + E - 8 - 3] = ue;
            }
            for (ie = 0; ie < 18; ie += 1) ue = !re && (pe >> ie & 1) == 1, _[ie % 3 + E - 8 - 3][Math.floor(ie / 3)] = ue;
          }, J = function(re, pe) {
            for (var ie = x << 3 | pe, ue = B.getBCHTypeInfo(ie), ve = 0; ve < 15; ve += 1) {
              var Pe = !re && (ue >> ve & 1) == 1;
              ve < 6 ? _[ve][8] = Pe : ve < 8 ? _[ve + 1][8] = Pe : _[E - 15 + ve][8] = Pe;
            }
            for (ve = 0; ve < 15; ve += 1) Pe = !re && (ue >> ve & 1) == 1, ve < 8 ? _[8][E - ve - 1] = Pe : ve < 9 ? _[8][15 - ve - 1 + 1] = Pe : _[8][15 - ve - 1] = Pe;
            _[E - 8][8] = !re;
          }, Q = function(re, pe) {
            for (var ie = -1, ue = E - 1, ve = 7, Pe = 0, De = B.getMaskFunction(pe), Ce = E - 1; Ce > 0; Ce -= 2) for (Ce == 6 && (Ce -= 1); ; ) {
              for (var $e = 0; $e < 2; $e += 1) if (_[ue][Ce - $e] == null) {
                var Me = !1;
                Pe < re.length && (Me = (re[Pe] >>> ve & 1) == 1), De(ue, Ce - $e) && (Me = !Me), _[ue][Ce - $e] = Me, (ve -= 1) == -1 && (Pe += 1, ve = 7);
              }
              if ((ue += ie) < 0 || E <= ue) {
                ue -= ie, ie = -ie;
                break;
              }
            }
          }, T = function(re, pe, ie) {
            for (var ue = V.getRSBlocks(re, pe), ve = te(), Pe = 0; Pe < ie.length; Pe += 1) {
              var De = ie[Pe];
              ve.put(De.getMode(), 4), ve.put(De.getLength(), B.getLengthInBits(De.getMode(), re)), De.write(ve);
            }
            var Ce = 0;
            for (Pe = 0; Pe < ue.length; Pe += 1) Ce += ue[Pe].dataCount;
            if (ve.getLengthInBits() > 8 * Ce) throw "code length overflow. (" + ve.getLengthInBits() + ">" + 8 * Ce + ")";
            for (ve.getLengthInBits() + 4 <= 8 * Ce && ve.put(0, 4); ve.getLengthInBits() % 8 != 0; ) ve.putBit(!1);
            for (; !(ve.getLengthInBits() >= 8 * Ce || (ve.put(236, 8), ve.getLengthInBits() >= 8 * Ce)); ) ve.put(17, 8);
            return function($e, Me) {
              for (var Ne = 0, Ke = 0, Le = 0, qe = new Array(Me.length), ze = new Array(Me.length), _e = 0; _e < Me.length; _e += 1) {
                var Ze = Me[_e].dataCount, at = Me[_e].totalCount - Ze;
                Ke = Math.max(Ke, Ze), Le = Math.max(Le, at), qe[_e] = new Array(Ze);
                for (var ke = 0; ke < qe[_e].length; ke += 1) qe[_e][ke] = 255 & $e.getBuffer()[ke + Ne];
                Ne += Ze;
                var Qe = B.getErrorCorrectPolynomial(at), tt = W(qe[_e], Qe.getLength() - 1).mod(Qe);
                for (ze[_e] = new Array(Qe.getLength() - 1), ke = 0; ke < ze[_e].length; ke += 1) {
                  var Ye = ke + tt.getLength() - ze[_e].length;
                  ze[_e][ke] = Ye >= 0 ? tt.getAt(Ye) : 0;
                }
              }
              var dt = 0;
              for (ke = 0; ke < Me.length; ke += 1) dt += Me[ke].totalCount;
              var lt = new Array(dt), ct = 0;
              for (ke = 0; ke < Ke; ke += 1) for (_e = 0; _e < Me.length; _e += 1) ke < qe[_e].length && (lt[ct] = qe[_e][ke], ct += 1);
              for (ke = 0; ke < Le; ke += 1) for (_e = 0; _e < Me.length; _e += 1) ke < ze[_e].length && (lt[ct] = ze[_e][ke], ct += 1);
              return lt;
            }(ve, ue);
          };
          I.addData = function(re, pe) {
            var ie = null;
            switch (pe = pe || "Byte") {
              case "Numeric":
                ie = R(re);
                break;
              case "Alphanumeric":
                ie = K(re);
                break;
              case "Byte":
                ie = ge(re);
                break;
              case "Kanji":
                ie = Ee(re);
                break;
              default:
                throw "mode:" + pe;
            }
            M.push(ie), v = null;
          }, I.isDark = function(re, pe) {
            if (re < 0 || E <= re || pe < 0 || E <= pe) throw re + "," + pe;
            return _[re][pe];
          }, I.getModuleCount = function() {
            return E;
          }, I.make = function() {
            if (b < 1) {
              for (var re = 1; re < 40; re++) {
                for (var pe = V.getRSBlocks(re, x), ie = te(), ue = 0; ue < M.length; ue++) {
                  var ve = M[ue];
                  ie.put(ve.getMode(), 4), ie.put(ve.getLength(), B.getLengthInBits(ve.getMode(), re)), ve.write(ie);
                }
                var Pe = 0;
                for (ue = 0; ue < pe.length; ue++) Pe += pe[ue].dataCount;
                if (ie.getLengthInBits() <= 8 * Pe) break;
              }
              b = re;
            }
            F(!1, function() {
              for (var De = 0, Ce = 0, $e = 0; $e < 8; $e += 1) {
                F(!0, $e);
                var Me = B.getLostPoint(I);
                ($e == 0 || De > Me) && (De = Me, Ce = $e);
              }
              return Ce;
            }());
          }, I.createTableTag = function(re, pe) {
            re = re || 2;
            var ie = "";
            ie += '<table style="', ie += " border-width: 0px; border-style: none;", ie += " border-collapse: collapse;", ie += " padding: 0px; margin: " + (pe = pe === void 0 ? 4 * re : pe) + "px;", ie += '">', ie += "<tbody>";
            for (var ue = 0; ue < I.getModuleCount(); ue += 1) {
              ie += "<tr>";
              for (var ve = 0; ve < I.getModuleCount(); ve += 1) ie += '<td style="', ie += " border-width: 0px; border-style: none;", ie += " border-collapse: collapse;", ie += " padding: 0px; margin: 0px;", ie += " width: " + re + "px;", ie += " height: " + re + "px;", ie += " background-color: ", ie += I.isDark(ue, ve) ? "#000000" : "#ffffff", ie += ";", ie += '"/>';
              ie += "</tr>";
            }
            return (ie += "</tbody>") + "</table>";
          }, I.createSvgTag = function(re, pe, ie, ue) {
            var ve = {};
            typeof arguments[0] == "object" && (re = (ve = arguments[0]).cellSize, pe = ve.margin, ie = ve.alt, ue = ve.title), re = re || 2, pe = pe === void 0 ? 4 * re : pe, (ie = typeof ie == "string" ? { text: ie } : ie || {}).text = ie.text || null, ie.id = ie.text ? ie.id || "qrcode-description" : null, (ue = typeof ue == "string" ? { text: ue } : ue || {}).text = ue.text || null, ue.id = ue.text ? ue.id || "qrcode-title" : null;
            var Pe, De, Ce, $e, Me = I.getModuleCount() * re + 2 * pe, Ne = "";
            for ($e = "l" + re + ",0 0," + re + " -" + re + ",0 0,-" + re + "z ", Ne += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"', Ne += ve.scalable ? "" : ' width="' + Me + 'px" height="' + Me + 'px"', Ne += ' viewBox="0 0 ' + Me + " " + Me + '" ', Ne += ' preserveAspectRatio="xMinYMin meet"', Ne += ue.text || ie.text ? ' role="img" aria-labelledby="' + X([ue.id, ie.id].join(" ").trim()) + '"' : "", Ne += ">", Ne += ue.text ? '<title id="' + X(ue.id) + '">' + X(ue.text) + "</title>" : "", Ne += ie.text ? '<description id="' + X(ie.id) + '">' + X(ie.text) + "</description>" : "", Ne += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>', Ne += '<path d="', De = 0; De < I.getModuleCount(); De += 1) for (Ce = De * re + pe, Pe = 0; Pe < I.getModuleCount(); Pe += 1) I.isDark(De, Pe) && (Ne += "M" + (Pe * re + pe) + "," + Ce + $e);
            return (Ne += '" stroke="transparent" fill="black"/>') + "</svg>";
          }, I.createDataURL = function(re, pe) {
            re = re || 2, pe = pe === void 0 ? 4 * re : pe;
            var ie = I.getModuleCount() * re + 2 * pe, ue = pe, ve = ie - pe;
            return m(ie, ie, function(Pe, De) {
              if (ue <= Pe && Pe < ve && ue <= De && De < ve) {
                var Ce = Math.floor((Pe - ue) / re), $e = Math.floor((De - ue) / re);
                return I.isDark($e, Ce) ? 0 : 1;
              }
              return 1;
            });
          }, I.createImgTag = function(re, pe, ie) {
            re = re || 2, pe = pe === void 0 ? 4 * re : pe;
            var ue = I.getModuleCount() * re + 2 * pe, ve = "";
            return ve += "<img", ve += ' src="', ve += I.createDataURL(re, pe), ve += '"', ve += ' width="', ve += ue, ve += '"', ve += ' height="', ve += ue, ve += '"', ie && (ve += ' alt="', ve += X(ie), ve += '"'), ve + "/>";
          };
          var X = function(re) {
            for (var pe = "", ie = 0; ie < re.length; ie += 1) {
              var ue = re.charAt(ie);
              switch (ue) {
                case "<":
                  pe += "&lt;";
                  break;
                case ">":
                  pe += "&gt;";
                  break;
                case "&":
                  pe += "&amp;";
                  break;
                case '"':
                  pe += "&quot;";
                  break;
                default:
                  pe += ue;
              }
            }
            return pe;
          };
          return I.createASCII = function(re, pe) {
            if ((re = re || 1) < 2) return function(qe) {
              qe = qe === void 0 ? 2 : qe;
              var ze, _e, Ze, at, ke, Qe = 1 * I.getModuleCount() + 2 * qe, tt = qe, Ye = Qe - qe, dt = { "": "", " ": "", " ": "", "  ": " " }, lt = { "": "", " ": "", " ": " ", "  ": " " }, ct = "";
              for (ze = 0; ze < Qe; ze += 2) {
                for (Ze = Math.floor((ze - tt) / 1), at = Math.floor((ze + 1 - tt) / 1), _e = 0; _e < Qe; _e += 1) ke = "", tt <= _e && _e < Ye && tt <= ze && ze < Ye && I.isDark(Ze, Math.floor((_e - tt) / 1)) && (ke = " "), tt <= _e && _e < Ye && tt <= ze + 1 && ze + 1 < Ye && I.isDark(at, Math.floor((_e - tt) / 1)) ? ke += " " : ke += "", ct += qe < 1 && ze + 1 >= Ye ? lt[ke] : dt[ke];
                ct += `
`;
              }
              return Qe % 2 && qe > 0 ? ct.substring(0, ct.length - Qe - 1) + Array(Qe + 1).join("") : ct.substring(0, ct.length - 1);
            }(pe);
            re -= 1, pe = pe === void 0 ? 2 * re : pe;
            var ie, ue, ve, Pe, De = I.getModuleCount() * re + 2 * pe, Ce = pe, $e = De - pe, Me = Array(re + 1).join(""), Ne = Array(re + 1).join("  "), Ke = "", Le = "";
            for (ie = 0; ie < De; ie += 1) {
              for (ve = Math.floor((ie - Ce) / re), Le = "", ue = 0; ue < De; ue += 1) Pe = 1, Ce <= ue && ue < $e && Ce <= ie && ie < $e && I.isDark(ve, Math.floor((ue - Ce) / re)) && (Pe = 0), Le += Pe ? Me : Ne;
              for (ve = 0; ve < re; ve += 1) Ke += Le + `
`;
            }
            return Ke.substring(0, Ke.length - 1);
          }, I.renderTo2dContext = function(re, pe) {
            pe = pe || 2;
            for (var ie = I.getModuleCount(), ue = 0; ue < ie; ue++) for (var ve = 0; ve < ie; ve++) re.fillStyle = I.isDark(ue, ve) ? "black" : "white", re.fillRect(ue * pe, ve * pe, pe, pe);
          }, I;
        };
        p.stringToBytes = (p.stringToBytesFuncs = { default: function(f) {
          for (var g = [], b = 0; b < f.length; b += 1) {
            var x = f.charCodeAt(b);
            g.push(255 & x);
          }
          return g;
        } }).default, p.createStringToBytes = function(f, g) {
          var b = function() {
            for (var _ = S(f), E = function() {
              var D = _.read();
              if (D == -1) throw "eof";
              return D;
            }, v = 0, M = {}; ; ) {
              var I = _.read();
              if (I == -1) break;
              var F = E(), ce = E() << 8 | E();
              M[String.fromCharCode(I << 8 | F)] = ce, v += 1;
            }
            if (v != g) throw v + " != " + g;
            return M;
          }(), x = 63;
          return function(_) {
            for (var E = [], v = 0; v < _.length; v += 1) {
              var M = _.charCodeAt(v);
              if (M < 128) E.push(M);
              else {
                var I = b[_.charAt(v)];
                typeof I == "number" ? (255 & I) == I ? E.push(I) : (E.push(I >>> 8), E.push(255 & I)) : E.push(x);
              }
            }
            return E;
          };
        };
        var w, A, P, N, L, $ = { L: 1, M: 0, Q: 3, H: 2 }, B = (w = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], A = 1335, P = 7973, L = function(f) {
          for (var g = 0; f != 0; ) g += 1, f >>>= 1;
          return g;
        }, (N = {}).getBCHTypeInfo = function(f) {
          for (var g = f << 10; L(g) - L(A) >= 0; ) g ^= A << L(g) - L(A);
          return 21522 ^ (f << 10 | g);
        }, N.getBCHTypeNumber = function(f) {
          for (var g = f << 12; L(g) - L(P) >= 0; ) g ^= P << L(g) - L(P);
          return f << 12 | g;
        }, N.getPatternPosition = function(f) {
          return w[f - 1];
        }, N.getMaskFunction = function(f) {
          switch (f) {
            case 0:
              return function(g, b) {
                return (g + b) % 2 == 0;
              };
            case 1:
              return function(g, b) {
                return g % 2 == 0;
              };
            case 2:
              return function(g, b) {
                return b % 3 == 0;
              };
            case 3:
              return function(g, b) {
                return (g + b) % 3 == 0;
              };
            case 4:
              return function(g, b) {
                return (Math.floor(g / 2) + Math.floor(b / 3)) % 2 == 0;
              };
            case 5:
              return function(g, b) {
                return g * b % 2 + g * b % 3 == 0;
              };
            case 6:
              return function(g, b) {
                return (g * b % 2 + g * b % 3) % 2 == 0;
              };
            case 7:
              return function(g, b) {
                return (g * b % 3 + (g + b) % 2) % 2 == 0;
              };
            default:
              throw "bad maskPattern:" + f;
          }
        }, N.getErrorCorrectPolynomial = function(f) {
          for (var g = W([1], 0), b = 0; b < f; b += 1) g = g.multiply(W([1, H.gexp(b)], 0));
          return g;
        }, N.getLengthInBits = function(f, g) {
          if (1 <= g && g < 10) switch (f) {
            case 1:
              return 10;
            case 2:
              return 9;
            case 4:
            case 8:
              return 8;
            default:
              throw "mode:" + f;
          }
          else if (g < 27) switch (f) {
            case 1:
              return 12;
            case 2:
              return 11;
            case 4:
              return 16;
            case 8:
              return 10;
            default:
              throw "mode:" + f;
          }
          else {
            if (!(g < 41)) throw "type:" + g;
            switch (f) {
              case 1:
                return 14;
              case 2:
                return 13;
              case 4:
                return 16;
              case 8:
                return 12;
              default:
                throw "mode:" + f;
            }
          }
        }, N.getLostPoint = function(f) {
          for (var g = f.getModuleCount(), b = 0, x = 0; x < g; x += 1) for (var _ = 0; _ < g; _ += 1) {
            for (var E = 0, v = f.isDark(x, _), M = -1; M <= 1; M += 1) if (!(x + M < 0 || g <= x + M)) for (var I = -1; I <= 1; I += 1) _ + I < 0 || g <= _ + I || M == 0 && I == 0 || v == f.isDark(x + M, _ + I) && (E += 1);
            E > 5 && (b += 3 + E - 5);
          }
          for (x = 0; x < g - 1; x += 1) for (_ = 0; _ < g - 1; _ += 1) {
            var F = 0;
            f.isDark(x, _) && (F += 1), f.isDark(x + 1, _) && (F += 1), f.isDark(x, _ + 1) && (F += 1), f.isDark(x + 1, _ + 1) && (F += 1), F != 0 && F != 4 || (b += 3);
          }
          for (x = 0; x < g; x += 1) for (_ = 0; _ < g - 6; _ += 1) f.isDark(x, _) && !f.isDark(x, _ + 1) && f.isDark(x, _ + 2) && f.isDark(x, _ + 3) && f.isDark(x, _ + 4) && !f.isDark(x, _ + 5) && f.isDark(x, _ + 6) && (b += 40);
          for (_ = 0; _ < g; _ += 1) for (x = 0; x < g - 6; x += 1) f.isDark(x, _) && !f.isDark(x + 1, _) && f.isDark(x + 2, _) && f.isDark(x + 3, _) && f.isDark(x + 4, _) && !f.isDark(x + 5, _) && f.isDark(x + 6, _) && (b += 40);
          var ce = 0;
          for (_ = 0; _ < g; _ += 1) for (x = 0; x < g; x += 1) f.isDark(x, _) && (ce += 1);
          return b + Math.abs(100 * ce / g / g - 50) / 5 * 10;
        }, N), H = function() {
          for (var f = new Array(256), g = new Array(256), b = 0; b < 8; b += 1) f[b] = 1 << b;
          for (b = 8; b < 256; b += 1) f[b] = f[b - 4] ^ f[b - 5] ^ f[b - 6] ^ f[b - 8];
          for (b = 0; b < 255; b += 1) g[f[b]] = b;
          return { glog: function(x) {
            if (x < 1) throw "glog(" + x + ")";
            return g[x];
          }, gexp: function(x) {
            for (; x < 0; ) x += 255;
            for (; x >= 256; ) x -= 255;
            return f[x];
          } };
        }();
        function W(f, g) {
          if (f.length === void 0) throw f.length + "/" + g;
          var b = function() {
            for (var _ = 0; _ < f.length && f[_] == 0; ) _ += 1;
            for (var E = new Array(f.length - _ + g), v = 0; v < f.length - _; v += 1) E[v] = f[v + _];
            return E;
          }(), x = { getAt: function(_) {
            return b[_];
          }, getLength: function() {
            return b.length;
          }, multiply: function(_) {
            for (var E = new Array(x.getLength() + _.getLength() - 1), v = 0; v < x.getLength(); v += 1) for (var M = 0; M < _.getLength(); M += 1) E[v + M] ^= H.gexp(H.glog(x.getAt(v)) + H.glog(_.getAt(M)));
            return W(E, 0);
          }, mod: function(_) {
            if (x.getLength() - _.getLength() < 0) return x;
            for (var E = H.glog(x.getAt(0)) - H.glog(_.getAt(0)), v = new Array(x.getLength()), M = 0; M < x.getLength(); M += 1) v[M] = x.getAt(M);
            for (M = 0; M < _.getLength(); M += 1) v[M] ^= H.gexp(H.glog(_.getAt(M)) + E);
            return W(v, 0).mod(_);
          } };
          return x;
        }
        var V = /* @__PURE__ */ function() {
          var f = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]], g = function(x, _) {
            var E = {};
            return E.totalCount = x, E.dataCount = _, E;
          }, b = { getRSBlocks: function(x, _) {
            var E = function(Z, J) {
              switch (J) {
                case $.L:
                  return f[4 * (Z - 1) + 0];
                case $.M:
                  return f[4 * (Z - 1) + 1];
                case $.Q:
                  return f[4 * (Z - 1) + 2];
                case $.H:
                  return f[4 * (Z - 1) + 3];
                default:
                  return;
              }
            }(x, _);
            if (E === void 0) throw "bad rs block @ typeNumber:" + x + "/errorCorrectionLevel:" + _;
            for (var v = E.length / 3, M = [], I = 0; I < v; I += 1) for (var F = E[3 * I + 0], ce = E[3 * I + 1], D = E[3 * I + 2], oe = 0; oe < F; oe += 1) M.push(g(ce, D));
            return M;
          } };
          return b;
        }(), te = function() {
          var f = [], g = 0, b = { getBuffer: function() {
            return f;
          }, getAt: function(x) {
            var _ = Math.floor(x / 8);
            return (f[_] >>> 7 - x % 8 & 1) == 1;
          }, put: function(x, _) {
            for (var E = 0; E < _; E += 1) b.putBit((x >>> _ - E - 1 & 1) == 1);
          }, getLengthInBits: function() {
            return g;
          }, putBit: function(x) {
            var _ = Math.floor(g / 8);
            f.length <= _ && f.push(0), x && (f[_] |= 128 >>> g % 8), g += 1;
          } };
          return b;
        }, R = function(f) {
          var g = f, b = { getMode: function() {
            return 1;
          }, getLength: function(E) {
            return g.length;
          }, write: function(E) {
            for (var v = g, M = 0; M + 2 < v.length; ) E.put(x(v.substring(M, M + 3)), 10), M += 3;
            M < v.length && (v.length - M == 1 ? E.put(x(v.substring(M, M + 1)), 4) : v.length - M == 2 && E.put(x(v.substring(M, M + 2)), 7));
          } }, x = function(E) {
            for (var v = 0, M = 0; M < E.length; M += 1) v = 10 * v + _(E.charAt(M));
            return v;
          }, _ = function(E) {
            if ("0" <= E && E <= "9") return E.charCodeAt(0) - 48;
            throw "illegal char :" + E;
          };
          return b;
        }, K = function(f) {
          var g = f, b = { getMode: function() {
            return 2;
          }, getLength: function(_) {
            return g.length;
          }, write: function(_) {
            for (var E = g, v = 0; v + 1 < E.length; ) _.put(45 * x(E.charAt(v)) + x(E.charAt(v + 1)), 11), v += 2;
            v < E.length && _.put(x(E.charAt(v)), 6);
          } }, x = function(_) {
            if ("0" <= _ && _ <= "9") return _.charCodeAt(0) - 48;
            if ("A" <= _ && _ <= "Z") return _.charCodeAt(0) - 65 + 10;
            switch (_) {
              case " ":
                return 36;
              case "$":
                return 37;
              case "%":
                return 38;
              case "*":
                return 39;
              case "+":
                return 40;
              case "-":
                return 41;
              case ".":
                return 42;
              case "/":
                return 43;
              case ":":
                return 44;
              default:
                throw "illegal char :" + _;
            }
          };
          return b;
        }, ge = function(f) {
          var g = p.stringToBytes(f);
          return { getMode: function() {
            return 4;
          }, getLength: function(b) {
            return g.length;
          }, write: function(b) {
            for (var x = 0; x < g.length; x += 1) b.put(g[x], 8);
          } };
        }, Ee = function(f) {
          var g = p.stringToBytesFuncs.SJIS;
          if (!g) throw "sjis not supported.";
          (function() {
            var _ = g("");
            if (_.length != 2 || (_[0] << 8 | _[1]) != 38726) throw "sjis not supported.";
          })();
          var b = g(f), x = { getMode: function() {
            return 8;
          }, getLength: function(_) {
            return ~~(b.length / 2);
          }, write: function(_) {
            for (var E = b, v = 0; v + 1 < E.length; ) {
              var M = (255 & E[v]) << 8 | 255 & E[v + 1];
              if (33088 <= M && M <= 40956) M -= 33088;
              else {
                if (!(57408 <= M && M <= 60351)) throw "illegal char at " + (v + 1) + "/" + M;
                M -= 49472;
              }
              M = 192 * (M >>> 8 & 255) + (255 & M), _.put(M, 13), v += 2;
            }
            if (v < E.length) throw "illegal char at " + (v + 1);
          } };
          return x;
        }, Y = function() {
          var f = [], g = { writeByte: function(b) {
            f.push(255 & b);
          }, writeShort: function(b) {
            g.writeByte(b), g.writeByte(b >>> 8);
          }, writeBytes: function(b, x, _) {
            x = x || 0, _ = _ || b.length;
            for (var E = 0; E < _; E += 1) g.writeByte(b[E + x]);
          }, writeString: function(b) {
            for (var x = 0; x < b.length; x += 1) g.writeByte(b.charCodeAt(x));
          }, toByteArray: function() {
            return f;
          }, toString: function() {
            var b = "";
            b += "[";
            for (var x = 0; x < f.length; x += 1) x > 0 && (b += ","), b += f[x];
            return b + "]";
          } };
          return g;
        }, S = function(f) {
          var g = f, b = 0, x = 0, _ = 0, E = { read: function() {
            for (; _ < 8; ) {
              if (b >= g.length) {
                if (_ == 0) return -1;
                throw "unexpected end of file./" + _;
              }
              var M = g.charAt(b);
              if (b += 1, M == "=") return _ = 0, -1;
              M.match(/^\s$/) || (x = x << 6 | v(M.charCodeAt(0)), _ += 6);
            }
            var I = x >>> _ - 8 & 255;
            return _ -= 8, I;
          } }, v = function(M) {
            if (65 <= M && M <= 90) return M - 65;
            if (97 <= M && M <= 122) return M - 97 + 26;
            if (48 <= M && M <= 57) return M - 48 + 52;
            if (M == 43) return 62;
            if (M == 47) return 63;
            throw "c:" + M;
          };
          return E;
        }, m = function(f, g, b) {
          for (var x = function(ce, D) {
            var oe = ce, Z = D, J = new Array(ce * D), Q = { setPixel: function(re, pe, ie) {
              J[pe * oe + re] = ie;
            }, write: function(re) {
              re.writeString("GIF87a"), re.writeShort(oe), re.writeShort(Z), re.writeByte(128), re.writeByte(0), re.writeByte(0), re.writeByte(0), re.writeByte(0), re.writeByte(0), re.writeByte(255), re.writeByte(255), re.writeByte(255), re.writeString(","), re.writeShort(0), re.writeShort(0), re.writeShort(oe), re.writeShort(Z), re.writeByte(0);
              var pe = T(2);
              re.writeByte(2);
              for (var ie = 0; pe.length - ie > 255; ) re.writeByte(255), re.writeBytes(pe, ie, 255), ie += 255;
              re.writeByte(pe.length - ie), re.writeBytes(pe, ie, pe.length - ie), re.writeByte(0), re.writeString(";");
            } }, T = function(re) {
              for (var pe = 1 << re, ie = 1 + (1 << re), ue = re + 1, ve = X(), Pe = 0; Pe < pe; Pe += 1) ve.add(String.fromCharCode(Pe));
              ve.add(String.fromCharCode(pe)), ve.add(String.fromCharCode(ie));
              var De, Ce, $e, Me = Y(), Ne = (De = Me, Ce = 0, $e = 0, { write: function(ze, _e) {
                if (ze >>> _e) throw "length over";
                for (; Ce + _e >= 8; ) De.writeByte(255 & (ze << Ce | $e)), _e -= 8 - Ce, ze >>>= 8 - Ce, $e = 0, Ce = 0;
                $e |= ze << Ce, Ce += _e;
              }, flush: function() {
                Ce > 0 && De.writeByte($e);
              } });
              Ne.write(pe, ue);
              var Ke = 0, Le = String.fromCharCode(J[Ke]);
              for (Ke += 1; Ke < J.length; ) {
                var qe = String.fromCharCode(J[Ke]);
                Ke += 1, ve.contains(Le + qe) ? Le += qe : (Ne.write(ve.indexOf(Le), ue), ve.size() < 4095 && (ve.size() == 1 << ue && (ue += 1), ve.add(Le + qe)), Le = qe);
              }
              return Ne.write(ve.indexOf(Le), ue), Ne.write(ie, ue), Ne.flush(), Me.toByteArray();
            }, X = function() {
              var re = {}, pe = 0, ie = { add: function(ue) {
                if (ie.contains(ue)) throw "dup key:" + ue;
                re[ue] = pe, pe += 1;
              }, size: function() {
                return pe;
              }, indexOf: function(ue) {
                return re[ue];
              }, contains: function(ue) {
                return re[ue] !== void 0;
              } };
              return ie;
            };
            return Q;
          }(f, g), _ = 0; _ < g; _ += 1) for (var E = 0; E < f; E += 1) x.setPixel(E, _, b(E, _));
          var v = Y();
          x.write(v);
          for (var M = function() {
            var ce = 0, D = 0, oe = 0, Z = "", J = {}, Q = function(X) {
              Z += String.fromCharCode(T(63 & X));
            }, T = function(X) {
              if (!(X < 0)) {
                if (X < 26) return 65 + X;
                if (X < 52) return X - 26 + 97;
                if (X < 62) return X - 52 + 48;
                if (X == 62) return 43;
                if (X == 63) return 47;
              }
              throw "n:" + X;
            };
            return J.writeByte = function(X) {
              for (ce = ce << 8 | 255 & X, D += 8, oe += 1; D >= 6; ) Q(ce >>> D - 6), D -= 6;
            }, J.flush = function() {
              if (D > 0 && (Q(ce << 6 - D), ce = 0, D = 0), oe % 3 != 0) for (var X = 3 - oe % 3, re = 0; re < X; re += 1) Z += "=";
            }, J.toString = function() {
              return Z;
            }, J;
          }(), I = v.toByteArray(), F = 0; F < I.length; F += 1) M.writeByte(I[F]);
          return M.flush(), "data:image/gif;base64," + M;
        };
        return p;
      }();
      d.stringToBytesFuncs["UTF-8"] = function(p) {
        return function(w) {
          for (var A = [], P = 0; P < w.length; P++) {
            var N = w.charCodeAt(P);
            N < 128 ? A.push(N) : N < 2048 ? A.push(192 | N >> 6, 128 | 63 & N) : N < 55296 || N >= 57344 ? A.push(224 | N >> 12, 128 | N >> 6 & 63, 128 | 63 & N) : (P++, N = 65536 + ((1023 & N) << 10 | 1023 & w.charCodeAt(P)), A.push(240 | N >> 18, 128 | N >> 12 & 63, 128 | N >> 6 & 63, 128 | 63 & N));
          }
          return A;
        }(p);
      }, (l = typeof (u = function() {
        return d;
      }) == "function" ? u.apply(a, []) : u) === void 0 || (o.exports = l);
    } }, n = {};
    function i(o) {
      var a = n[o];
      if (a !== void 0) return a.exports;
      var u = n[o] = { exports: {} };
      return r[o](u, u.exports, i), u.exports;
    }
    i.n = (o) => {
      var a = o && o.__esModule ? () => o.default : () => o;
      return i.d(a, { a }), a;
    }, i.d = (o, a) => {
      for (var u in a) i.o(a, u) && !i.o(o, u) && Object.defineProperty(o, u, { enumerable: !0, get: a[u] });
    }, i.o = (o, a) => Object.prototype.hasOwnProperty.call(o, a);
    var s = {};
    return (() => {
      i.d(s, { default: () => Y });
      const o = (S) => !!S && typeof S == "object" && !Array.isArray(S);
      function a(S, ...m) {
        if (!m.length) return S;
        const f = m.shift();
        return f !== void 0 && o(S) && o(f) ? (S = Object.assign({}, S), Object.keys(f).forEach((g) => {
          const b = S[g], x = f[g];
          Array.isArray(b) && Array.isArray(x) ? S[g] = x : o(b) && o(x) ? S[g] = a(Object.assign({}, b), x) : S[g] = x;
        }), a(S, ...m)) : S;
      }
      function u(S, m) {
        const f = document.createElement("a");
        f.download = m, f.href = S, document.body.appendChild(f), f.click(), document.body.removeChild(f);
      }
      const l = { L: 0.07, M: 0.15, Q: 0.25, H: 0.3 };
      class d {
        constructor({ svg: m, type: f, window: g }) {
          this._svg = m, this._type = f, this._window = g;
        }
        draw(m, f, g, b) {
          let x;
          switch (this._type) {
            case "dots":
              x = this._drawDot;
              break;
            case "classy":
              x = this._drawClassy;
              break;
            case "classy-rounded":
              x = this._drawClassyRounded;
              break;
            case "rounded":
              x = this._drawRounded;
              break;
            case "extra-rounded":
              x = this._drawExtraRounded;
              break;
            default:
              x = this._drawSquare;
          }
          x.call(this, { x: m, y: f, size: g, getNeighbor: b });
        }
        _rotateFigure({ x: m, y: f, size: g, rotation: b = 0, draw: x }) {
          var _;
          const E = m + g / 2, v = f + g / 2;
          x(), (_ = this._element) === null || _ === void 0 || _.setAttribute("transform", `rotate(${180 * b / Math.PI},${E},${v})`);
        }
        _basicDot(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "circle"), this._element.setAttribute("cx", String(g + f / 2)), this._element.setAttribute("cy", String(b + f / 2)), this._element.setAttribute("r", String(f / 2));
          } }));
        }
        _basicSquare(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect"), this._element.setAttribute("x", String(g)), this._element.setAttribute("y", String(b)), this._element.setAttribute("width", String(f)), this._element.setAttribute("height", String(f));
          } }));
        }
        _basicSideRounded(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${g} ${b}v ${f}h ` + f / 2 + `a ${f / 2} ${f / 2}, 0, 0, 0, 0 ${-f}`);
          } }));
        }
        _basicCornerRounded(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${g} ${b}v ${f}h ${f}v ` + -f / 2 + `a ${f / 2} ${f / 2}, 0, 0, 0, ${-f / 2} ${-f / 2}`);
          } }));
        }
        _basicCornerExtraRounded(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${g} ${b}v ${f}h ${f}a ${f} ${f}, 0, 0, 0, ${-f} ${-f}`);
          } }));
        }
        _basicCornersRounded(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("d", `M ${g} ${b}v ` + f / 2 + `a ${f / 2} ${f / 2}, 0, 0, 0, ${f / 2} ${f / 2}h ` + f / 2 + "v " + -f / 2 + `a ${f / 2} ${f / 2}, 0, 0, 0, ${-f / 2} ${-f / 2}`);
          } }));
        }
        _drawDot({ x: m, y: f, size: g }) {
          this._basicDot({ x: m, y: f, size: g, rotation: 0 });
        }
        _drawSquare({ x: m, y: f, size: g }) {
          this._basicSquare({ x: m, y: f, size: g, rotation: 0 });
        }
        _drawRounded({ x: m, y: f, size: g, getNeighbor: b }) {
          const x = b ? +b(-1, 0) : 0, _ = b ? +b(1, 0) : 0, E = b ? +b(0, -1) : 0, v = b ? +b(0, 1) : 0, M = x + _ + E + v;
          if (M !== 0) if (M > 2 || x && _ || E && v) this._basicSquare({ x: m, y: f, size: g, rotation: 0 });
          else {
            if (M === 2) {
              let I = 0;
              return x && E ? I = Math.PI / 2 : E && _ ? I = Math.PI : _ && v && (I = -Math.PI / 2), void this._basicCornerRounded({ x: m, y: f, size: g, rotation: I });
            }
            if (M === 1) {
              let I = 0;
              return E ? I = Math.PI / 2 : _ ? I = Math.PI : v && (I = -Math.PI / 2), void this._basicSideRounded({ x: m, y: f, size: g, rotation: I });
            }
          }
          else this._basicDot({ x: m, y: f, size: g, rotation: 0 });
        }
        _drawExtraRounded({ x: m, y: f, size: g, getNeighbor: b }) {
          const x = b ? +b(-1, 0) : 0, _ = b ? +b(1, 0) : 0, E = b ? +b(0, -1) : 0, v = b ? +b(0, 1) : 0, M = x + _ + E + v;
          if (M !== 0) if (M > 2 || x && _ || E && v) this._basicSquare({ x: m, y: f, size: g, rotation: 0 });
          else {
            if (M === 2) {
              let I = 0;
              return x && E ? I = Math.PI / 2 : E && _ ? I = Math.PI : _ && v && (I = -Math.PI / 2), void this._basicCornerExtraRounded({ x: m, y: f, size: g, rotation: I });
            }
            if (M === 1) {
              let I = 0;
              return E ? I = Math.PI / 2 : _ ? I = Math.PI : v && (I = -Math.PI / 2), void this._basicSideRounded({ x: m, y: f, size: g, rotation: I });
            }
          }
          else this._basicDot({ x: m, y: f, size: g, rotation: 0 });
        }
        _drawClassy({ x: m, y: f, size: g, getNeighbor: b }) {
          const x = b ? +b(-1, 0) : 0, _ = b ? +b(1, 0) : 0, E = b ? +b(0, -1) : 0, v = b ? +b(0, 1) : 0;
          x + _ + E + v !== 0 ? x || E ? _ || v ? this._basicSquare({ x: m, y: f, size: g, rotation: 0 }) : this._basicCornerRounded({ x: m, y: f, size: g, rotation: Math.PI / 2 }) : this._basicCornerRounded({ x: m, y: f, size: g, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: m, y: f, size: g, rotation: Math.PI / 2 });
        }
        _drawClassyRounded({ x: m, y: f, size: g, getNeighbor: b }) {
          const x = b ? +b(-1, 0) : 0, _ = b ? +b(1, 0) : 0, E = b ? +b(0, -1) : 0, v = b ? +b(0, 1) : 0;
          x + _ + E + v !== 0 ? x || E ? _ || v ? this._basicSquare({ x: m, y: f, size: g, rotation: 0 }) : this._basicCornerExtraRounded({ x: m, y: f, size: g, rotation: Math.PI / 2 }) : this._basicCornerExtraRounded({ x: m, y: f, size: g, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: m, y: f, size: g, rotation: Math.PI / 2 });
        }
      }
      class p {
        constructor({ svg: m, type: f, window: g }) {
          this._svg = m, this._type = f, this._window = g;
        }
        draw(m, f, g, b) {
          let x;
          switch (this._type) {
            case "square":
              x = this._drawSquare;
              break;
            case "extra-rounded":
              x = this._drawExtraRounded;
              break;
            default:
              x = this._drawDot;
          }
          x.call(this, { x: m, y: f, size: g, rotation: b });
        }
        _rotateFigure({ x: m, y: f, size: g, rotation: b = 0, draw: x }) {
          var _;
          const E = m + g / 2, v = f + g / 2;
          x(), (_ = this._element) === null || _ === void 0 || _.setAttribute("transform", `rotate(${180 * b / Math.PI},${E},${v})`);
        }
        _basicDot(m) {
          const { size: f, x: g, y: b } = m, x = f / 7;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${g + f / 2} ${b}a ${f / 2} ${f / 2} 0 1 0 0.1 0zm 0 ${x}a ${f / 2 - x} ${f / 2 - x} 0 1 1 -0.1 0Z`);
          } }));
        }
        _basicSquare(m) {
          const { size: f, x: g, y: b } = m, x = f / 7;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${g} ${b}v ${f}h ${f}v ` + -f + `zM ${g + x} ${b + x}h ` + (f - 2 * x) + "v " + (f - 2 * x) + "h " + (2 * x - f) + "z");
          } }));
        }
        _basicExtraRounded(m) {
          const { size: f, x: g, y: b } = m, x = f / 7;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "path"), this._element.setAttribute("clip-rule", "evenodd"), this._element.setAttribute("d", `M ${g} ${b + 2.5 * x}v ` + 2 * x + `a ${2.5 * x} ${2.5 * x}, 0, 0, 0, ${2.5 * x} ${2.5 * x}h ` + 2 * x + `a ${2.5 * x} ${2.5 * x}, 0, 0, 0, ${2.5 * x} ${2.5 * -x}v ` + -2 * x + `a ${2.5 * x} ${2.5 * x}, 0, 0, 0, ${2.5 * -x} ${2.5 * -x}h ` + -2 * x + `a ${2.5 * x} ${2.5 * x}, 0, 0, 0, ${2.5 * -x} ${2.5 * x}M ${g + 2.5 * x} ${b + x}h ` + 2 * x + `a ${1.5 * x} ${1.5 * x}, 0, 0, 1, ${1.5 * x} ${1.5 * x}v ` + 2 * x + `a ${1.5 * x} ${1.5 * x}, 0, 0, 1, ${1.5 * -x} ${1.5 * x}h ` + -2 * x + `a ${1.5 * x} ${1.5 * x}, 0, 0, 1, ${1.5 * -x} ${1.5 * -x}v ` + -2 * x + `a ${1.5 * x} ${1.5 * x}, 0, 0, 1, ${1.5 * x} ${1.5 * -x}`);
          } }));
        }
        _drawDot({ x: m, y: f, size: g, rotation: b }) {
          this._basicDot({ x: m, y: f, size: g, rotation: b });
        }
        _drawSquare({ x: m, y: f, size: g, rotation: b }) {
          this._basicSquare({ x: m, y: f, size: g, rotation: b });
        }
        _drawExtraRounded({ x: m, y: f, size: g, rotation: b }) {
          this._basicExtraRounded({ x: m, y: f, size: g, rotation: b });
        }
      }
      class w {
        constructor({ svg: m, type: f, window: g }) {
          this._svg = m, this._type = f, this._window = g;
        }
        draw(m, f, g, b) {
          let x;
          x = this._type === "square" ? this._drawSquare : this._drawDot, x.call(this, { x: m, y: f, size: g, rotation: b });
        }
        _rotateFigure({ x: m, y: f, size: g, rotation: b = 0, draw: x }) {
          var _;
          const E = m + g / 2, v = f + g / 2;
          x(), (_ = this._element) === null || _ === void 0 || _.setAttribute("transform", `rotate(${180 * b / Math.PI},${E},${v})`);
        }
        _basicDot(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "circle"), this._element.setAttribute("cx", String(g + f / 2)), this._element.setAttribute("cy", String(b + f / 2)), this._element.setAttribute("r", String(f / 2));
          } }));
        }
        _basicSquare(m) {
          const { size: f, x: g, y: b } = m;
          this._rotateFigure(Object.assign(Object.assign({}, m), { draw: () => {
            this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect"), this._element.setAttribute("x", String(g)), this._element.setAttribute("y", String(b)), this._element.setAttribute("width", String(f)), this._element.setAttribute("height", String(f));
          } }));
        }
        _drawDot({ x: m, y: f, size: g, rotation: b }) {
          this._basicDot({ x: m, y: f, size: g, rotation: b });
        }
        _drawSquare({ x: m, y: f, size: g, rotation: b }) {
          this._basicSquare({ x: m, y: f, size: g, rotation: b });
        }
      }
      const A = "circle", P = [[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]], N = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]];
      class L {
        constructor(m, f) {
          this._roundSize = (g) => this._options.dotsOptions.roundSize ? Math.floor(g) : g, this._window = f, this._element = this._window.document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._element.setAttribute("width", String(m.width)), this._element.setAttribute("height", String(m.height)), this._element.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), m.dotsOptions.roundSize || this._element.setAttribute("shape-rendering", "crispEdges"), this._element.setAttribute("viewBox", `0 0 ${m.width} ${m.height}`), this._defs = this._window.document.createElementNS("http://www.w3.org/2000/svg", "defs"), this._element.appendChild(this._defs), this._imageUri = m.image, this._instanceId = L.instanceCount++, this._options = m;
        }
        get width() {
          return this._options.width;
        }
        get height() {
          return this._options.height;
        }
        getElement() {
          return this._element;
        }
        async drawQR(m) {
          const f = m.getModuleCount(), g = Math.min(this._options.width, this._options.height) - 2 * this._options.margin, b = this._options.shape === A ? g / Math.sqrt(2) : g, x = this._roundSize(b / f);
          let _ = { hideXDots: 0, hideYDots: 0, width: 0, height: 0 };
          if (this._qr = m, this._options.image) {
            if (await this.loadImage(), !this._image) return;
            const { imageOptions: E, qrOptions: v } = this._options, M = E.imageSize * l[v.errorCorrectionLevel], I = Math.floor(M * f * f);
            _ = function({ originalHeight: F, originalWidth: ce, maxHiddenDots: D, maxHiddenAxisDots: oe, dotSize: Z }) {
              const J = { x: 0, y: 0 }, Q = { x: 0, y: 0 };
              if (F <= 0 || ce <= 0 || D <= 0 || Z <= 0) return { height: 0, width: 0, hideYDots: 0, hideXDots: 0 };
              const T = F / ce;
              return J.x = Math.floor(Math.sqrt(D / T)), J.x <= 0 && (J.x = 1), oe && oe < J.x && (J.x = oe), J.x % 2 == 0 && J.x--, Q.x = J.x * Z, J.y = 1 + 2 * Math.ceil((J.x * T - 1) / 2), Q.y = Math.round(Q.x * T), (J.y * J.x > D || oe && oe < J.y) && (oe && oe < J.y ? (J.y = oe, J.y % 2 == 0 && J.x--) : J.y -= 2, Q.y = J.y * Z, J.x = 1 + 2 * Math.ceil((J.y / T - 1) / 2), Q.x = Math.round(Q.y / T)), { height: Q.y, width: Q.x, hideYDots: J.y, hideXDots: J.x };
            }({ originalWidth: this._image.width, originalHeight: this._image.height, maxHiddenDots: I, maxHiddenAxisDots: f - 14, dotSize: x });
          }
          this.drawBackground(), this.drawDots((E, v) => {
            var M, I, F, ce, D, oe;
            return !(this._options.imageOptions.hideBackgroundDots && E >= (f - _.hideYDots) / 2 && E < (f + _.hideYDots) / 2 && v >= (f - _.hideXDots) / 2 && v < (f + _.hideXDots) / 2 || !((M = P[E]) === null || M === void 0) && M[v] || !((I = P[E - f + 7]) === null || I === void 0) && I[v] || !((F = P[E]) === null || F === void 0) && F[v - f + 7] || !((ce = N[E]) === null || ce === void 0) && ce[v] || !((D = N[E - f + 7]) === null || D === void 0) && D[v] || !((oe = N[E]) === null || oe === void 0) && oe[v - f + 7]);
          }), this.drawCorners(), this._options.image && await this.drawImage({ width: _.width, height: _.height, count: f, dotSize: x });
        }
        drawBackground() {
          var m, f, g;
          const b = this._element, x = this._options;
          if (b) {
            const _ = (m = x.backgroundOptions) === null || m === void 0 ? void 0 : m.gradient, E = (f = x.backgroundOptions) === null || f === void 0 ? void 0 : f.color;
            let v = x.height, M = x.width;
            if (_ || E) {
              const I = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
              this._backgroundClipPath = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._backgroundClipPath.setAttribute("id", `clip-path-background-color-${this._instanceId}`), this._defs.appendChild(this._backgroundClipPath), !((g = x.backgroundOptions) === null || g === void 0) && g.round && (v = M = Math.min(x.width, x.height), I.setAttribute("rx", String(v / 2 * x.backgroundOptions.round))), I.setAttribute("x", String(this._roundSize((x.width - M) / 2))), I.setAttribute("y", String(this._roundSize((x.height - v) / 2))), I.setAttribute("width", String(M)), I.setAttribute("height", String(v)), this._backgroundClipPath.appendChild(I), this._createColor({ options: _, color: E, additionalRotation: 0, x: 0, y: 0, height: x.height, width: x.width, name: `background-color-${this._instanceId}` });
            }
          }
        }
        drawDots(m) {
          var f, g;
          if (!this._qr) throw "QR code is not defined";
          const b = this._options, x = this._qr.getModuleCount();
          if (x > b.width || x > b.height) throw "The canvas is too small.";
          const _ = Math.min(b.width, b.height) - 2 * b.margin, E = b.shape === A ? _ / Math.sqrt(2) : _, v = this._roundSize(E / x), M = this._roundSize((b.width - x * v) / 2), I = this._roundSize((b.height - x * v) / 2), F = new d({ svg: this._element, type: b.dotsOptions.type, window: this._window });
          this._dotsClipPath = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._dotsClipPath.setAttribute("id", `clip-path-dot-color-${this._instanceId}`), this._defs.appendChild(this._dotsClipPath), this._createColor({ options: (f = b.dotsOptions) === null || f === void 0 ? void 0 : f.gradient, color: b.dotsOptions.color, additionalRotation: 0, x: 0, y: 0, height: b.height, width: b.width, name: `dot-color-${this._instanceId}` });
          for (let ce = 0; ce < x; ce++) for (let D = 0; D < x; D++) m && !m(ce, D) || !((g = this._qr) === null || g === void 0) && g.isDark(ce, D) && (F.draw(M + D * v, I + ce * v, v, (oe, Z) => !(D + oe < 0 || ce + Z < 0 || D + oe >= x || ce + Z >= x) && !(m && !m(ce + Z, D + oe)) && !!this._qr && this._qr.isDark(ce + Z, D + oe)), F._element && this._dotsClipPath && this._dotsClipPath.appendChild(F._element));
          if (b.shape === A) {
            const ce = this._roundSize((_ / v - x) / 2), D = x + 2 * ce, oe = M - ce * v, Z = I - ce * v, J = [], Q = this._roundSize(D / 2);
            for (let T = 0; T < D; T++) {
              J[T] = [];
              for (let X = 0; X < D; X++) T >= ce - 1 && T <= D - ce && X >= ce - 1 && X <= D - ce || Math.sqrt((T - Q) * (T - Q) + (X - Q) * (X - Q)) > Q ? J[T][X] = 0 : J[T][X] = this._qr.isDark(X - 2 * ce < 0 ? X : X >= x ? X - 2 * ce : X - ce, T - 2 * ce < 0 ? T : T >= x ? T - 2 * ce : T - ce) ? 1 : 0;
            }
            for (let T = 0; T < D; T++) for (let X = 0; X < D; X++) J[T][X] && (F.draw(oe + X * v, Z + T * v, v, (re, pe) => {
              var ie;
              return !!(!((ie = J[T + pe]) === null || ie === void 0) && ie[X + re]);
            }), F._element && this._dotsClipPath && this._dotsClipPath.appendChild(F._element));
          }
        }
        drawCorners() {
          if (!this._qr) throw "QR code is not defined";
          const m = this._element, f = this._options;
          if (!m) throw "Element code is not defined";
          const g = this._qr.getModuleCount(), b = Math.min(f.width, f.height) - 2 * f.margin, x = f.shape === A ? b / Math.sqrt(2) : b, _ = this._roundSize(x / g), E = 7 * _, v = 3 * _, M = this._roundSize((f.width - g * _) / 2), I = this._roundSize((f.height - g * _) / 2);
          [[0, 0, 0], [1, 0, Math.PI / 2], [0, 1, -Math.PI / 2]].forEach(([F, ce, D]) => {
            var oe, Z, J, Q, T, X, re, pe, ie, ue, ve, Pe;
            const De = M + F * _ * (g - 7), Ce = I + ce * _ * (g - 7);
            let $e = this._dotsClipPath, Me = this._dotsClipPath;
            if ((!((oe = f.cornersSquareOptions) === null || oe === void 0) && oe.gradient || !((Z = f.cornersSquareOptions) === null || Z === void 0) && Z.color) && ($e = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), $e.setAttribute("id", `clip-path-corners-square-color-${F}-${ce}-${this._instanceId}`), this._defs.appendChild($e), this._cornersSquareClipPath = this._cornersDotClipPath = Me = $e, this._createColor({ options: (J = f.cornersSquareOptions) === null || J === void 0 ? void 0 : J.gradient, color: (Q = f.cornersSquareOptions) === null || Q === void 0 ? void 0 : Q.color, additionalRotation: D, x: De, y: Ce, height: E, width: E, name: `corners-square-color-${F}-${ce}-${this._instanceId}` })), (T = f.cornersSquareOptions) === null || T === void 0 ? void 0 : T.type) {
              const Ne = new p({ svg: this._element, type: f.cornersSquareOptions.type, window: this._window });
              Ne.draw(De, Ce, E, D), Ne._element && $e && $e.appendChild(Ne._element);
            } else {
              const Ne = new d({ svg: this._element, type: f.dotsOptions.type, window: this._window });
              for (let Ke = 0; Ke < P.length; Ke++) for (let Le = 0; Le < P[Ke].length; Le++) !((X = P[Ke]) === null || X === void 0) && X[Le] && (Ne.draw(De + Le * _, Ce + Ke * _, _, (qe, ze) => {
                var _e;
                return !!(!((_e = P[Ke + ze]) === null || _e === void 0) && _e[Le + qe]);
              }), Ne._element && $e && $e.appendChild(Ne._element));
            }
            if ((!((re = f.cornersDotOptions) === null || re === void 0) && re.gradient || !((pe = f.cornersDotOptions) === null || pe === void 0) && pe.color) && (Me = this._window.document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), Me.setAttribute("id", `clip-path-corners-dot-color-${F}-${ce}-${this._instanceId}`), this._defs.appendChild(Me), this._cornersDotClipPath = Me, this._createColor({ options: (ie = f.cornersDotOptions) === null || ie === void 0 ? void 0 : ie.gradient, color: (ue = f.cornersDotOptions) === null || ue === void 0 ? void 0 : ue.color, additionalRotation: D, x: De + 2 * _, y: Ce + 2 * _, height: v, width: v, name: `corners-dot-color-${F}-${ce}-${this._instanceId}` })), (ve = f.cornersDotOptions) === null || ve === void 0 ? void 0 : ve.type) {
              const Ne = new w({ svg: this._element, type: f.cornersDotOptions.type, window: this._window });
              Ne.draw(De + 2 * _, Ce + 2 * _, v, D), Ne._element && Me && Me.appendChild(Ne._element);
            } else {
              const Ne = new d({ svg: this._element, type: f.dotsOptions.type, window: this._window });
              for (let Ke = 0; Ke < N.length; Ke++) for (let Le = 0; Le < N[Ke].length; Le++) !((Pe = N[Ke]) === null || Pe === void 0) && Pe[Le] && (Ne.draw(De + Le * _, Ce + Ke * _, _, (qe, ze) => {
                var _e;
                return !!(!((_e = N[Ke + ze]) === null || _e === void 0) && _e[Le + qe]);
              }), Ne._element && Me && Me.appendChild(Ne._element));
            }
          });
        }
        loadImage() {
          return new Promise((m, f) => {
            var g;
            const b = this._options;
            if (!b.image) return f("Image is not defined");
            if (!((g = b.nodeCanvas) === null || g === void 0) && g.loadImage) b.nodeCanvas.loadImage(b.image).then((x) => {
              var _, E;
              if (this._image = x, this._options.imageOptions.saveAsBlob) {
                const v = (_ = b.nodeCanvas) === null || _ === void 0 ? void 0 : _.createCanvas(this._image.width, this._image.height);
                (E = v == null ? void 0 : v.getContext("2d")) === null || E === void 0 || E.drawImage(x, 0, 0), this._imageUri = v == null ? void 0 : v.toDataURL();
              }
              m();
            }).catch(f);
            else {
              const x = new this._window.Image();
              typeof b.imageOptions.crossOrigin == "string" && (x.crossOrigin = b.imageOptions.crossOrigin), this._image = x, x.onload = async () => {
                this._options.imageOptions.saveAsBlob && (this._imageUri = await async function(_, E) {
                  return new Promise((v) => {
                    const M = new E.XMLHttpRequest();
                    M.onload = function() {
                      const I = new E.FileReader();
                      I.onloadend = function() {
                        v(I.result);
                      }, I.readAsDataURL(M.response);
                    }, M.open("GET", _), M.responseType = "blob", M.send();
                  });
                }(b.image || "", this._window)), m();
              }, x.src = b.image;
            }
          });
        }
        async drawImage({ width: m, height: f, count: g, dotSize: b }) {
          const x = this._options, _ = this._roundSize((x.width - g * b) / 2), E = this._roundSize((x.height - g * b) / 2), v = _ + this._roundSize(x.imageOptions.margin + (g * b - m) / 2), M = E + this._roundSize(x.imageOptions.margin + (g * b - f) / 2), I = m - 2 * x.imageOptions.margin, F = f - 2 * x.imageOptions.margin, ce = this._window.document.createElementNS("http://www.w3.org/2000/svg", "image");
          ce.setAttribute("href", this._imageUri || ""), ce.setAttribute("x", String(v)), ce.setAttribute("y", String(M)), ce.setAttribute("width", `${I}px`), ce.setAttribute("height", `${F}px`), this._element.appendChild(ce);
        }
        _createColor({ options: m, color: f, additionalRotation: g, x: b, y: x, height: _, width: E, name: v }) {
          const M = E > _ ? E : _, I = this._window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
          if (I.setAttribute("x", String(b)), I.setAttribute("y", String(x)), I.setAttribute("height", String(_)), I.setAttribute("width", String(E)), I.setAttribute("clip-path", `url('#clip-path-${v}')`), m) {
            let F;
            if (m.type === "radial") F = this._window.document.createElementNS("http://www.w3.org/2000/svg", "radialGradient"), F.setAttribute("id", v), F.setAttribute("gradientUnits", "userSpaceOnUse"), F.setAttribute("fx", String(b + E / 2)), F.setAttribute("fy", String(x + _ / 2)), F.setAttribute("cx", String(b + E / 2)), F.setAttribute("cy", String(x + _ / 2)), F.setAttribute("r", String(M / 2));
            else {
              const ce = ((m.rotation || 0) + g) % (2 * Math.PI), D = (ce + 2 * Math.PI) % (2 * Math.PI);
              let oe = b + E / 2, Z = x + _ / 2, J = b + E / 2, Q = x + _ / 2;
              D >= 0 && D <= 0.25 * Math.PI || D > 1.75 * Math.PI && D <= 2 * Math.PI ? (oe -= E / 2, Z -= _ / 2 * Math.tan(ce), J += E / 2, Q += _ / 2 * Math.tan(ce)) : D > 0.25 * Math.PI && D <= 0.75 * Math.PI ? (Z -= _ / 2, oe -= E / 2 / Math.tan(ce), Q += _ / 2, J += E / 2 / Math.tan(ce)) : D > 0.75 * Math.PI && D <= 1.25 * Math.PI ? (oe += E / 2, Z += _ / 2 * Math.tan(ce), J -= E / 2, Q -= _ / 2 * Math.tan(ce)) : D > 1.25 * Math.PI && D <= 1.75 * Math.PI && (Z += _ / 2, oe += E / 2 / Math.tan(ce), Q -= _ / 2, J -= E / 2 / Math.tan(ce)), F = this._window.document.createElementNS("http://www.w3.org/2000/svg", "linearGradient"), F.setAttribute("id", v), F.setAttribute("gradientUnits", "userSpaceOnUse"), F.setAttribute("x1", String(Math.round(oe))), F.setAttribute("y1", String(Math.round(Z))), F.setAttribute("x2", String(Math.round(J))), F.setAttribute("y2", String(Math.round(Q)));
            }
            m.colorStops.forEach(({ offset: ce, color: D }) => {
              const oe = this._window.document.createElementNS("http://www.w3.org/2000/svg", "stop");
              oe.setAttribute("offset", 100 * ce + "%"), oe.setAttribute("stop-color", D), F.appendChild(oe);
            }), I.setAttribute("fill", `url('#${v}')`), this._defs.appendChild(F);
          } else f && I.setAttribute("fill", f);
          this._element.appendChild(I);
        }
      }
      L.instanceCount = 0;
      const $ = L, B = "canvas", H = {};
      for (let S = 0; S <= 40; S++) H[S] = S;
      const W = { type: B, shape: "square", width: 300, height: 300, data: "", margin: 0, qrOptions: { typeNumber: H[0], mode: void 0, errorCorrectionLevel: "Q" }, imageOptions: { saveAsBlob: !0, hideBackgroundDots: !0, imageSize: 0.4, crossOrigin: void 0, margin: 0 }, dotsOptions: { type: "square", color: "#000", roundSize: !0 }, backgroundOptions: { round: 0, color: "#fff" } };
      function V(S) {
        const m = Object.assign({}, S);
        if (!m.colorStops || !m.colorStops.length) throw "Field 'colorStops' is required in gradient";
        return m.rotation ? m.rotation = Number(m.rotation) : m.rotation = 0, m.colorStops = m.colorStops.map((f) => Object.assign(Object.assign({}, f), { offset: Number(f.offset) })), m;
      }
      function te(S) {
        const m = Object.assign({}, S);
        return m.width = Number(m.width), m.height = Number(m.height), m.margin = Number(m.margin), m.imageOptions = Object.assign(Object.assign({}, m.imageOptions), { hideBackgroundDots: !!m.imageOptions.hideBackgroundDots, imageSize: Number(m.imageOptions.imageSize), margin: Number(m.imageOptions.margin) }), m.margin > Math.min(m.width, m.height) && (m.margin = Math.min(m.width, m.height)), m.dotsOptions = Object.assign({}, m.dotsOptions), m.dotsOptions.gradient && (m.dotsOptions.gradient = V(m.dotsOptions.gradient)), m.cornersSquareOptions && (m.cornersSquareOptions = Object.assign({}, m.cornersSquareOptions), m.cornersSquareOptions.gradient && (m.cornersSquareOptions.gradient = V(m.cornersSquareOptions.gradient))), m.cornersDotOptions && (m.cornersDotOptions = Object.assign({}, m.cornersDotOptions), m.cornersDotOptions.gradient && (m.cornersDotOptions.gradient = V(m.cornersDotOptions.gradient))), m.backgroundOptions && (m.backgroundOptions = Object.assign({}, m.backgroundOptions), m.backgroundOptions.gradient && (m.backgroundOptions.gradient = V(m.backgroundOptions.gradient))), m;
      }
      var R = i(873), K = i.n(R);
      function ge(S) {
        if (!S) throw new Error("Extension must be defined");
        S[0] === "." && (S = S.substring(1));
        const m = { bmp: "image/bmp", gif: "image/gif", ico: "image/vnd.microsoft.icon", jpeg: "image/jpeg", jpg: "image/jpeg", png: "image/png", svg: "image/svg+xml", tif: "image/tiff", tiff: "image/tiff", webp: "image/webp", pdf: "application/pdf" }[S.toLowerCase()];
        if (!m) throw new Error(`Extension "${S}" is not supported`);
        return m;
      }
      class Ee {
        constructor(m) {
          m != null && m.jsdom ? this._window = new m.jsdom("", { resources: "usable" }).window : this._window = window, this._options = m ? te(a(W, m)) : W, this.update();
        }
        static _clearContainer(m) {
          m && (m.innerHTML = "");
        }
        _setupSvg() {
          if (!this._qr) return;
          const m = new $(this._options, this._window);
          this._svg = m.getElement(), this._svgDrawingPromise = m.drawQR(this._qr).then(() => {
            var f;
            this._svg && ((f = this._extension) === null || f === void 0 || f.call(this, m.getElement(), this._options));
          });
        }
        _setupCanvas() {
          var m, f;
          this._qr && (!((m = this._options.nodeCanvas) === null || m === void 0) && m.createCanvas ? (this._nodeCanvas = this._options.nodeCanvas.createCanvas(this._options.width, this._options.height), this._nodeCanvas.width = this._options.width, this._nodeCanvas.height = this._options.height) : (this._domCanvas = document.createElement("canvas"), this._domCanvas.width = this._options.width, this._domCanvas.height = this._options.height), this._setupSvg(), this._canvasDrawingPromise = (f = this._svgDrawingPromise) === null || f === void 0 ? void 0 : f.then(() => {
            var g;
            if (!this._svg) return;
            const b = this._svg, x = new this._window.XMLSerializer().serializeToString(b), _ = btoa(x), E = `data:${ge("svg")};base64,${_}`;
            if (!((g = this._options.nodeCanvas) === null || g === void 0) && g.loadImage) return this._options.nodeCanvas.loadImage(E).then((v) => {
              var M, I;
              v.width = this._options.width, v.height = this._options.height, (I = (M = this._nodeCanvas) === null || M === void 0 ? void 0 : M.getContext("2d")) === null || I === void 0 || I.drawImage(v, 0, 0);
            });
            {
              const v = new this._window.Image();
              return new Promise((M) => {
                v.onload = () => {
                  var I, F;
                  (F = (I = this._domCanvas) === null || I === void 0 ? void 0 : I.getContext("2d")) === null || F === void 0 || F.drawImage(v, 0, 0), M();
                }, v.src = E;
              });
            }
          }));
        }
        async _getElement(m = "png") {
          if (!this._qr) throw "QR code is empty";
          return m.toLowerCase() === "svg" ? (this._svg && this._svgDrawingPromise || this._setupSvg(), await this._svgDrawingPromise, this._svg) : ((this._domCanvas || this._nodeCanvas) && this._canvasDrawingPromise || this._setupCanvas(), await this._canvasDrawingPromise, this._domCanvas || this._nodeCanvas);
        }
        update(m) {
          Ee._clearContainer(this._container), this._options = m ? te(a(this._options, m)) : this._options, this._options.data && (this._qr = K()(this._options.qrOptions.typeNumber, this._options.qrOptions.errorCorrectionLevel), this._qr.addData(this._options.data, this._options.qrOptions.mode || function(f) {
            switch (!0) {
              case /^[0-9]*$/.test(f):
                return "Numeric";
              case /^[0-9A-Z $%*+\-./:]*$/.test(f):
                return "Alphanumeric";
              default:
                return "Byte";
            }
          }(this._options.data)), this._qr.make(), this._options.type === B ? this._setupCanvas() : this._setupSvg(), this.append(this._container));
        }
        append(m) {
          if (m) {
            if (typeof m.appendChild != "function") throw "Container should be a single DOM node";
            this._options.type === B ? this._domCanvas && m.appendChild(this._domCanvas) : this._svg && m.appendChild(this._svg), this._container = m;
          }
        }
        applyExtension(m) {
          if (!m) throw "Extension function should be defined.";
          this._extension = m, this.update();
        }
        deleteExtension() {
          this._extension = void 0, this.update();
        }
        async getRawData(m = "png") {
          if (!this._qr) throw "QR code is empty";
          const f = await this._getElement(m), g = ge(m);
          if (!f) return null;
          if (m.toLowerCase() === "svg") {
            const b = `<?xml version="1.0" standalone="no"?>\r
${new this._window.XMLSerializer().serializeToString(f)}`;
            return typeof Blob > "u" || this._options.jsdom ? Buffer.from(b) : new Blob([b], { type: g });
          }
          return new Promise((b) => {
            const x = f;
            if ("toBuffer" in x) if (g === "image/png") b(x.toBuffer(g));
            else if (g === "image/jpeg") b(x.toBuffer(g));
            else {
              if (g !== "application/pdf") throw Error("Unsupported extension");
              b(x.toBuffer(g));
            }
            else "toBlob" in x && x.toBlob(b, g, 1);
          });
        }
        async download(m) {
          if (!this._qr) throw "QR code is empty";
          if (typeof Blob > "u") throw "Cannot download in Node.js, call getRawData instead.";
          let f = "png", g = "qr";
          typeof m == "string" ? (f = m, console.warn("Extension is deprecated as argument for 'download' method, please pass object { name: '...', extension: '...' } as argument")) : typeof m == "object" && m !== null && (m.name && (g = m.name), m.extension && (f = m.extension));
          const b = await this._getElement(f);
          if (b) if (f.toLowerCase() === "svg") {
            let x = new XMLSerializer().serializeToString(b);
            x = `<?xml version="1.0" standalone="no"?>\r
` + x, u(`data:${ge(f)};charset=utf-8,${encodeURIComponent(x)}`, `${g}.svg`);
          } else u(b.toDataURL(ge(f)), `${g}.${f}`);
        }
      }
      const Y = Ee;
    })(), s.default;
  })());
})($9);
var Une = $9.exports;
const B9 = /* @__PURE__ */ rs(Une);
class aa extends yt {
  constructor(e) {
    const { docsPath: r, field: n, metaMessages: i } = e;
    super(`Invalid Sign-In with Ethereum message field "${n}".`, {
      docsPath: r,
      metaMessages: i,
      name: "SiweInvalidMessageFieldError"
    });
  }
}
function h5(t) {
  if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(t) || /%[^0-9a-f]/i.test(t) || /%[0-9a-f](:?[^0-9a-f]|$)/i.test(t))
    return !1;
  const e = qne(t), r = e[1], n = e[2], i = e[3], s = e[4], o = e[5];
  if (!(r != null && r.length && i.length >= 0))
    return !1;
  if (n != null && n.length) {
    if (!(i.length === 0 || /^\//.test(i)))
      return !1;
  } else if (/^\/\//.test(i))
    return !1;
  if (!/^[a-z][a-z0-9\+\-\.]*$/.test(r.toLowerCase()))
    return !1;
  let a = "";
  return a += `${r}:`, n != null && n.length && (a += `//${n}`), a += i, s != null && s.length && (a += `?${s}`), o != null && o.length && (a += `#${o}`), a;
}
function qne(t) {
  return t.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
}
function F9(t) {
  const { chainId: e, domain: r, expirationTime: n, issuedAt: i = /* @__PURE__ */ new Date(), nonce: s, notBefore: o, requestId: a, resources: u, scheme: l, uri: d, version: p } = t;
  {
    if (e !== Math.floor(e))
      throw new aa({
        field: "chainId",
        metaMessages: [
          "- Chain ID must be a EIP-155 chain ID.",
          "- See https://eips.ethereum.org/EIPS/eip-155",
          "",
          `Provided value: ${e}`
        ]
      });
    if (!(zne.test(r) || Wne.test(r) || Hne.test(r)))
      throw new aa({
        field: "domain",
        metaMessages: [
          "- Domain must be an RFC 3986 authority.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${r}`
        ]
      });
    if (!Kne.test(s))
      throw new aa({
        field: "nonce",
        metaMessages: [
          "- Nonce must be at least 8 characters.",
          "- Nonce must be alphanumeric.",
          "",
          `Provided value: ${s}`
        ]
      });
    if (!h5(d))
      throw new aa({
        field: "uri",
        metaMessages: [
          "- URI must be a RFC 3986 URI referring to the resource that is the subject of the signing.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${d}`
        ]
      });
    if (p !== "1")
      throw new aa({
        field: "version",
        metaMessages: [
          "- Version must be '1'.",
          "",
          `Provided value: ${p}`
        ]
      });
    if (l && !Vne.test(l))
      throw new aa({
        field: "scheme",
        metaMessages: [
          "- Scheme must be an RFC 3986 URI scheme.",
          "- See https://www.rfc-editor.org/rfc/rfc3986#section-3.1",
          "",
          `Provided value: ${l}`
        ]
      });
    const $ = t.statement;
    if ($ != null && $.includes(`
`))
      throw new aa({
        field: "statement",
        metaMessages: [
          "- Statement must not include '\\n'.",
          "",
          `Provided value: ${$}`
        ]
      });
  }
  const w = Ev(t.address), A = l ? `${l}://${r}` : r, P = t.statement ? `${t.statement}
` : "", N = `${A} wants you to sign in with your Ethereum account:
${w}

${P}`;
  let L = `URI: ${d}
Version: ${p}
Chain ID: ${e}
Nonce: ${s}
Issued At: ${i.toISOString()}`;
  if (n && (L += `
Expiration Time: ${n.toISOString()}`), o && (L += `
Not Before: ${o.toISOString()}`), a && (L += `
Request ID: ${a}`), u) {
    let $ = `
Resources:`;
    for (const B of u) {
      if (!h5(B))
        throw new aa({
          field: "resources",
          metaMessages: [
            "- Every resource must be a RFC 3986 URI.",
            "- See https://www.rfc-editor.org/rfc/rfc3986",
            "",
            `Provided value: ${B}`
          ]
        });
      $ += `
- ${B}`;
    }
    L += $;
  }
  return `${N}
${L}`;
}
const zne = /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}(:[0-9]{1,5})?$/, Wne = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(:[0-9]{1,5})?$/, Hne = /^localhost(:[0-9]{1,5})?$/, Kne = /^[a-zA-Z0-9]{8,}$/, Vne = /^([a-zA-Z][a-zA-Z0-9+-.]*)$/, j9 = "7a4434fefbcc9af474fb5c995e47d286", Gne = {
  projectId: j9,
  metadata: {
    name: "codatta",
    description: "codatta",
    url: "https://codatta.io/",
    icons: ["https://avatars.githubusercontent.com/u/171659315"]
  }
}, Yne = {
  namespaces: {
    eip155: {
      methods: [
        "eth_sendTransaction",
        "eth_signTransaction",
        "eth_sign",
        "personal_sign",
        "eth_signTypedData"
      ],
      chains: ["eip155:1"],
      events: ["chainChanged", "accountsChanged", "disconnect"],
      rpcMap: {
        1: `https://rpc.walletconnect.com?chainId=eip155:1&projectId=${j9}`
      }
    }
  },
  skipPairing: !1
};
function Jne(t, e) {
  const r = window.location.host, n = window.location.href;
  return F9({
    address: t,
    chainId: 1,
    domain: r,
    nonce: e,
    uri: n,
    version: "1"
  });
}
function U9(t) {
  var ge, Ee, Y;
  const e = oi(null), { wallet: r, onGetExtension: n, onSignFinish: i } = t, [s, o] = Gt(""), [a, u] = Gt(!1), [l, d] = Gt(""), [p, w] = Gt("scan"), A = oi(), [P, N] = Gt((ge = r.config) == null ? void 0 : ge.image), [L, $] = Gt(!1), { saveLastUsedWallet: B } = mp();
  async function H(S) {
    var f, g, b, x;
    u(!0);
    const m = await FG.init(Gne);
    m.session && await m.disconnect();
    try {
      if (w("scan"), m.on("display_uri", (ce) => {
        console.log("display_uri", ce), o(ce), u(!1), w("scan");
      }), m.on("error", (ce) => {
        console.log(ce);
      }), m.on("session_update", (ce) => {
        console.log("session_update", ce);
      }), !await m.connect(Yne)) throw new Error("Walletconnect init failed");
      const E = new vl(m);
      N(((f = E.config) == null ? void 0 : f.image) || ((g = S.config) == null ? void 0 : g.image));
      const v = await E.getAddress(), M = await qo.getNonce({ account_type: "block_chain" });
      console.log("get nonce", M);
      const I = Jne(v, M);
      w("sign");
      const F = await E.signMessage(I, v);
      w("waiting"), await i(E, {
        message: I,
        nonce: M,
        signature: F,
        address: v,
        wallet_name: ((b = E.config) == null ? void 0 : b.name) || ((x = S.config) == null ? void 0 : x.name) || ""
      }), B(E);
    } catch (_) {
      console.log("err", _), d(_.details || _.message);
    }
  }
  function W() {
    A.current = new B9({
      width: 264,
      height: 264,
      margin: 0,
      type: "svg",
      // image: wallet.config?.image,
      qrOptions: {
        errorCorrectionLevel: "M"
      },
      dotsOptions: {
        color: "black",
        type: "rounded"
      },
      backgroundOptions: {
        color: "transparent"
      }
    }), A.current.append(e.current);
  }
  function V(S) {
    var m;
    console.log(A.current), (m = A.current) == null || m.update({
      data: S
    });
  }
  Dn(() => {
    s && V(s);
  }, [s]), Dn(() => {
    H(r);
  }, [r]), Dn(() => {
    W();
  }, []);
  function te() {
    d(""), V(""), H(r);
  }
  function R() {
    $(!0), navigator.clipboard.writeText(s), setTimeout(() => {
      $(!1);
    }, 2500);
  }
  function K() {
    var f;
    const S = (f = r.config) == null ? void 0 : f.desktop_link;
    if (!S) return;
    const m = `${S}?uri=${encodeURIComponent(s)}`;
    window.open(m, "_blank");
  }
  return /* @__PURE__ */ fe.jsxs("div", { children: [
    /* @__PURE__ */ fe.jsx("div", { className: "xc-text-center", children: /* @__PURE__ */ fe.jsxs("div", { className: "xc-relative xc-mx-auto xc-mb-6 xc-block xc-max-h-[272px] xc-max-w-[272px] xc-rounded-xl xc-bg-white xc-p-1", children: [
      /* @__PURE__ */ fe.jsx("div", { className: "xc-aspect-[1/1] xc-flex xc-h-full xc-w-full xc-justify-center", ref: e }),
      /* @__PURE__ */ fe.jsx("div", { className: "xc-absolute xc-left-0 xc-top-0 xc-flex xc-h-full xc-w-full xc-items-center xc-justify-center", children: a ? /* @__PURE__ */ fe.jsx(_a, { className: "xc-h-6 xc-w-6 xc-animate-spin xc-text-black", size: 20 }) : /* @__PURE__ */ fe.jsx("img", { className: "xc-h-10 xc-w-10", src: P }) })
    ] }) }),
    /* @__PURE__ */ fe.jsxs("div", { className: "xc-m-auto xc-mb-6 xc-flex xc-max-w-[400px] xc-flex-wrap xc-items-center xc-justify-between xc-gap-3", children: [
      /* @__PURE__ */ fe.jsx(
        "button",
        {
          disabled: !s,
          onClick: R,
          className: "xc-disabled:hover-text-white xc-flex xc-min-w-[160px] xc-flex-1 xc-shrink-0 xc-items-center xc-justify-center xc-gap-2 xc-rounded-full xc-border xc-py-2 xc-text-sm xc-transition-all xc-hover:bg-white xc-hover:text-black xc-disabled:cursor-not-allowed xc-disabled:opacity-40 xc-disabled:hover:bg-transparent",
          children: L ? /* @__PURE__ */ fe.jsxs(fe.Fragment, { children: [
            " ",
            /* @__PURE__ */ fe.jsx(hZ, {}),
            " Copied!"
          ] }) : /* @__PURE__ */ fe.jsxs(fe.Fragment, { children: [
            /* @__PURE__ */ fe.jsx(gZ, {}),
            "Copy QR URL"
          ] })
        }
      ),
      ((Ee = r.config) == null ? void 0 : Ee.getWallet) && /* @__PURE__ */ fe.jsxs(
        "button",
        {
          className: "xc-rounded-2 xc-flex xc-min-w-[160px] xc-flex-1 xc-shrink-0 xc-items-center xc-justify-center xc-gap-2 xc-rounded-full xc-border xc-py-2 xc-text-sm xc-transition-all xc-hover:bg-white xc-hover:text-black",
          onClick: n,
          children: [
            /* @__PURE__ */ fe.jsx(dZ, {}),
            "Get Extension"
          ]
        }
      ),
      ((Y = r.config) == null ? void 0 : Y.desktop_link) && /* @__PURE__ */ fe.jsxs(
        "button",
        {
          disabled: !s,
          className: "xc-rounded-2 xc-flex xc-min-w-[160px] xc-flex-1 xc-shrink-0 xc-items-center xc-justify-center xc-gap-2 xc-rounded-full xc-border xc-py-2 xc-text-sm xc-transition-all xc-hover:bg-white xc-hover:text-black",
          onClick: K,
          children: [
            /* @__PURE__ */ fe.jsx(KS, {}),
            "Desktop"
          ]
        }
      )
    ] }),
    /* @__PURE__ */ fe.jsx("div", { className: "xc-text-center", children: l ? /* @__PURE__ */ fe.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center", children: [
      /* @__PURE__ */ fe.jsx("p", { className: "xc-text-danger xc-mb-2 xc-text-center", children: l }),
      /* @__PURE__ */ fe.jsx("button", { className: "xc-rounded-full xc-bg-white xc-bg-opacity-10 xc-px-6 xc-py-1", onClick: te, children: "Retry" })
    ] }) : /* @__PURE__ */ fe.jsxs(fe.Fragment, { children: [
      p === "scan" && /* @__PURE__ */ fe.jsx("p", { children: "Scan this QR code from your mobile wallet or phone's camera to connect." }),
      p === "connect" && /* @__PURE__ */ fe.jsx("p", { children: "Click connect in your wallet app" }),
      p === "sign" && /* @__PURE__ */ fe.jsx("p", { children: "Click sign-in in your wallet to confirm you own this wallet." }),
      p === "waiting" && /* @__PURE__ */ fe.jsx("div", { className: "xc-text-center", children: /* @__PURE__ */ fe.jsx(_a, { className: "xc-inline-block xc-animate-spin" }) })
    ] }) })
  ] });
}
const Xne = "Accept connection request in the wallet", Zne = "Accept sign-in request in your wallet";
function Qne(t, e) {
  const r = window.location.host, n = window.location.href;
  return F9({
    address: t,
    chainId: 1,
    domain: r,
    nonce: e,
    uri: n,
    version: "1"
  });
}
function q9(t) {
  var p;
  const [e, r] = Gt(), { wallet: n, onSignFinish: i } = t, s = oi(), [o, a] = Gt("connect"), { saveLastUsedWallet: u } = mp();
  async function l(w) {
    var A;
    try {
      a("connect");
      const P = await n.connect();
      if (!P || P.length === 0)
        throw new Error("Wallet connect error");
      const N = Ev(P[0]), L = Qne(N, w);
      a("sign");
      const $ = await n.signMessage(L, N);
      if (!$ || $.length === 0)
        throw new Error("user sign error");
      a("waiting"), await i(n, { address: N, signature: $, message: L, nonce: w, wallet_name: ((A = n.config) == null ? void 0 : A.name) || "" }), u(n);
    } catch (P) {
      console.log(P.details), r(P.details || P.message);
    }
  }
  async function d() {
    try {
      r("");
      const w = await qo.getNonce({ account_type: "block_chain" });
      s.current = w, l(s.current);
    } catch (w) {
      console.log(w.details), r(w.message);
    }
  }
  return Dn(() => {
    d();
  }, []), /* @__PURE__ */ fe.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center xc-justify-center xc-gap-4", children: [
    /* @__PURE__ */ fe.jsx("img", { className: "xc-rounded-md xc-h-16 xc-w-16", src: (p = n.config) == null ? void 0 : p.image, alt: "" }),
    e && /* @__PURE__ */ fe.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center", children: [
      /* @__PURE__ */ fe.jsx("p", { className: "xc-text-danger xc-mb-2 xc-text-center", children: e }),
      /* @__PURE__ */ fe.jsx("div", { className: "xc-flex xc-gap-2", children: /* @__PURE__ */ fe.jsx("button", { className: "xc-rounded-full xc-bg-white xc-bg-opacity-10 xc-px-6 xc-py-1", onClick: d, children: "Retry" }) })
    ] }),
    !e && /* @__PURE__ */ fe.jsxs(fe.Fragment, { children: [
      o === "connect" && /* @__PURE__ */ fe.jsx("span", { className: "xc-text-center", children: Xne }),
      o === "sign" && /* @__PURE__ */ fe.jsx("span", { className: "xc-text-center", children: Zne }),
      o === "waiting" && /* @__PURE__ */ fe.jsx("span", { className: "xc-text-center", children: /* @__PURE__ */ fe.jsx(_a, { className: "xc-animate-spin" }) })
    ] })
  ] });
}
const Gc = "https://static.codatta.io/codatta-connect/wallet-icons.svg", eie = "https://itunes.apple.com/app/", tie = "https://play.google.com/store/apps/details?id=", rie = "https://chromewebstore.google.com/detail/", nie = "https://chromewebstore.google.com/detail/", iie = "https://addons.mozilla.org/en-US/firefox/addon/", sie = "https://microsoftedge.microsoft.com/addons/detail/";
function Yc(t) {
  const { icon: e, title: r, link: n } = t;
  return /* @__PURE__ */ fe.jsxs(
    "a",
    {
      href: n,
      target: "_blank",
      className: "xc-flex xc-w-full xc-cursor-pointer xc-items-center xc-gap-2 xc-rounded-full xc-border xc-border-white xc-border-opacity-15 xc-px-6 xc-py-3 xc-transition-all xc-hover:bg-white xc-hover:bg-opacity-5",
      children: [
        /* @__PURE__ */ fe.jsx("img", { className: "xc-rounded-1 xc-h-6 xc-w-6", src: e, alt: "" }),
        r,
        /* @__PURE__ */ fe.jsx(HS, { className: "xc-ml-auto xc-text-gray-400" })
      ]
    }
  );
}
function oie(t) {
  const e = {
    appStoreLink: "",
    playStoreLink: "",
    chromeStoreLink: "",
    braveStoreLink: "",
    firefoxStoreLink: "",
    edgeStoreLink: ""
  };
  return t != null && t.app_store_id && (e.appStoreLink = `${eie}${t.app_store_id}`), t != null && t.play_store_id && (e.playStoreLink = `${tie}${t.play_store_id}`), t != null && t.chrome_store_id && (e.chromeStoreLink = `${rie}${t.chrome_store_id}`), t != null && t.brave_store_id && (e.braveStoreLink = `${nie}${t.brave_store_id}`), t != null && t.firefox_addon_id && (e.firefoxStoreLink = `${iie}${t.firefox_addon_id}`), t != null && t.edge_addon_id && (e.edgeStoreLink = `${sie}${t.edge_addon_id}`), e;
}
function z9(t) {
  var i, s, o;
  const { wallet: e } = t, r = (i = e.config) == null ? void 0 : i.getWallet, n = oie(r);
  return /* @__PURE__ */ fe.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center", children: [
    /* @__PURE__ */ fe.jsx("img", { className: "xc-rounded-md xc-mb-2 xc-h-12 xc-w-12", src: (s = e.config) == null ? void 0 : s.image, alt: "" }),
    /* @__PURE__ */ fe.jsxs("p", { className: "xc-text-lg xc-font-bold", children: [
      "Install ",
      (o = e.config) == null ? void 0 : o.name,
      " to connect"
    ] }),
    /* @__PURE__ */ fe.jsx("p", { className: "xc-mb-6 xc-text-sm xc-text-gray-500", children: "Select from your preferred options below:" }),
    /* @__PURE__ */ fe.jsxs("div", { className: "xc-grid xc-w-full xc-grid-cols-1 xc-gap-3", children: [
      (r == null ? void 0 : r.chrome_store_id) && /* @__PURE__ */ fe.jsx(
        Yc,
        {
          link: n.chromeStoreLink,
          icon: `${Gc}#chrome`,
          title: "Google Play Store"
        }
      ),
      (r == null ? void 0 : r.app_store_id) && /* @__PURE__ */ fe.jsx(
        Yc,
        {
          link: n.appStoreLink,
          icon: `${Gc}#apple-dark`,
          title: "Apple App Store"
        }
      ),
      (r == null ? void 0 : r.play_store_id) && /* @__PURE__ */ fe.jsx(
        Yc,
        {
          link: n.playStoreLink,
          icon: `${Gc}#android`,
          title: "Google Play Store"
        }
      ),
      (r == null ? void 0 : r.edge_addon_id) && /* @__PURE__ */ fe.jsx(
        Yc,
        {
          link: n.edgeStoreLink,
          icon: `${Gc}#edge`,
          title: "Microsoft Edge"
        }
      ),
      (r == null ? void 0 : r.brave_store_id) && /* @__PURE__ */ fe.jsx(
        Yc,
        {
          link: n.braveStoreLink,
          icon: `${Gc}#brave`,
          title: "Brave extension"
        }
      ),
      (r == null ? void 0 : r.firefox_addon_id) && /* @__PURE__ */ fe.jsx(
        Yc,
        {
          link: n.firefoxStoreLink,
          icon: `${Gc}#firefox`,
          title: "Mozilla Firefox"
        }
      )
    ] })
  ] });
}
function aie(t) {
  const { wallet: e } = t, [r, n] = Gt(e.installed ? "connect" : "qr"), i = fy();
  async function s(o, a) {
    var l;
    const u = await qo.walletLogin({
      account_type: "block_chain",
      account_enum: "C",
      connector: "codatta_wallet",
      inviter_code: i.inviterCode,
      wallet_name: ((l = o.config) == null ? void 0 : l.name) || o.key,
      address: await o.getAddress(),
      chain: (await o.getChain()).toString(),
      nonce: a.nonce,
      signature: a.signature,
      message: a.message,
      source: {
        device: i.device,
        channel: i.channel,
        app: i.app
      }
    });
    await t.onLogin(u.data);
  }
  return /* @__PURE__ */ fe.jsxs(so, { children: [
    /* @__PURE__ */ fe.jsx("div", { className: "xc-mb-6", children: /* @__PURE__ */ fe.jsx(Pc, { title: "Connect wallet", onBack: t.onBack }) }),
    r === "qr" && /* @__PURE__ */ fe.jsx(
      U9,
      {
        wallet: e,
        onGetExtension: () => n("get-extension"),
        onSignFinish: s
      }
    ),
    r === "connect" && /* @__PURE__ */ fe.jsx(
      q9,
      {
        onShowQrCode: () => n("qr"),
        wallet: e,
        onSignFinish: s
      }
    ),
    r === "get-extension" && /* @__PURE__ */ fe.jsx(z9, { wallet: e })
  ] });
}
function cie(t) {
  const { wallet: e, onClick: r } = t, n = /* @__PURE__ */ fe.jsx("img", { className: "xc-rounded-md xc-h-5 xc-w-5", src: e.imageUrl }), i = e.name || "";
  return /* @__PURE__ */ fe.jsx(oy, { icon: n, title: i, onClick: () => r(e) });
}
function W9(t) {
  const { connector: e } = t, [r, n] = Gt(), [i, s] = Gt([]), o = Ni(() => r ? i.filter((d) => d.name.toLowerCase().includes(r.toLowerCase())) : i, [r, i]);
  function a(d) {
    n(d.target.value);
  }
  async function u() {
    const d = await e.getWallets();
    s(d), console.log(d);
  }
  Dn(() => {
    u();
  }, []);
  function l(d) {
    t.onSelect(d);
  }
  return /* @__PURE__ */ fe.jsxs(so, { children: [
    /* @__PURE__ */ fe.jsx("div", { className: "xc-mb-6", children: /* @__PURE__ */ fe.jsx(Pc, { title: "Select wallet", onBack: t.onBack }) }),
    /* @__PURE__ */ fe.jsxs("div", { className: "xc-mb-6 xc-flex xc-gap-3 xc-px-4 xc-py-2 xc-border xc-rounded-xl xc-w-full xc-overflow-hidden xc-items-center xc-border-opacity-15 xc-border-white focus-within:xc-border-opacity-40", children: [
      /* @__PURE__ */ fe.jsx(GS, { className: "xc-shrink-0 xc-opacity-50" }),
      /* @__PURE__ */ fe.jsx("input", { type: "text", className: "xc-flex-1 xc-bg-transparent xc-appearance-none xc-outline-none", placeholder: "Search wallet", onInput: a })
    ] }),
    /* @__PURE__ */ fe.jsx("div", { className: "xc-mb-4 xc-flex xc-h-[309px] xc-flex-col xc-gap-4 xc-overflow-scroll no-scrollbar", children: o == null ? void 0 : o.map((d) => /* @__PURE__ */ fe.jsx(cie, { wallet: d, onClick: l }, d.name)) })
  ] });
}
var H9 = { exports: {} };
(function(t) {
  (function(e, r) {
    t.exports ? t.exports = r() : (e.nacl || (e.nacl = {}), e.nacl.util = r());
  })(gn, function() {
    var e = {};
    function r(n) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(n))
        throw new TypeError("invalid encoding");
    }
    return e.decodeUTF8 = function(n) {
      if (typeof n != "string") throw new TypeError("expected string");
      var i, s = unescape(encodeURIComponent(n)), o = new Uint8Array(s.length);
      for (i = 0; i < s.length; i++) o[i] = s.charCodeAt(i);
      return o;
    }, e.encodeUTF8 = function(n) {
      var i, s = [];
      for (i = 0; i < n.length; i++) s.push(String.fromCharCode(n[i]));
      return decodeURIComponent(escape(s.join("")));
    }, typeof atob > "u" ? typeof Buffer.from < "u" ? (e.encodeBase64 = function(n) {
      return Buffer.from(n).toString("base64");
    }, e.decodeBase64 = function(n) {
      return r(n), new Uint8Array(Array.prototype.slice.call(Buffer.from(n, "base64"), 0));
    }) : (e.encodeBase64 = function(n) {
      return new Buffer(n).toString("base64");
    }, e.decodeBase64 = function(n) {
      return r(n), new Uint8Array(Array.prototype.slice.call(new Buffer(n, "base64"), 0));
    }) : (e.encodeBase64 = function(n) {
      var i, s = [], o = n.length;
      for (i = 0; i < o; i++) s.push(String.fromCharCode(n[i]));
      return btoa(s.join(""));
    }, e.decodeBase64 = function(n) {
      r(n);
      var i, s = atob(n), o = new Uint8Array(s.length);
      for (i = 0; i < s.length; i++) o[i] = s.charCodeAt(i);
      return o;
    }), e;
  });
})(H9);
var uie = H9.exports;
const Dl = /* @__PURE__ */ rs(uie);
var K9 = { exports: {} };
(function(t) {
  (function(e) {
    var r = function(k) {
      var U, z = new Float64Array(16);
      if (k) for (U = 0; U < k.length; U++) z[U] = k[U];
      return z;
    }, n = function() {
      throw new Error("no PRNG");
    }, i = new Uint8Array(16), s = new Uint8Array(32);
    s[0] = 9;
    var o = r(), a = r([1]), u = r([56129, 1]), l = r([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), d = r([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), p = r([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), w = r([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), A = r([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function P(k, U, z, C) {
      k[U] = z >> 24 & 255, k[U + 1] = z >> 16 & 255, k[U + 2] = z >> 8 & 255, k[U + 3] = z & 255, k[U + 4] = C >> 24 & 255, k[U + 5] = C >> 16 & 255, k[U + 6] = C >> 8 & 255, k[U + 7] = C & 255;
    }
    function N(k, U, z, C, G) {
      var j, se = 0;
      for (j = 0; j < G; j++) se |= k[U + j] ^ z[C + j];
      return (1 & se - 1 >>> 8) - 1;
    }
    function L(k, U, z, C) {
      return N(k, U, z, C, 16);
    }
    function $(k, U, z, C) {
      return N(k, U, z, C, 32);
    }
    function B(k, U, z, C) {
      for (var G = C[0] & 255 | (C[1] & 255) << 8 | (C[2] & 255) << 16 | (C[3] & 255) << 24, j = z[0] & 255 | (z[1] & 255) << 8 | (z[2] & 255) << 16 | (z[3] & 255) << 24, se = z[4] & 255 | (z[5] & 255) << 8 | (z[6] & 255) << 16 | (z[7] & 255) << 24, de = z[8] & 255 | (z[9] & 255) << 8 | (z[10] & 255) << 16 | (z[11] & 255) << 24, xe = z[12] & 255 | (z[13] & 255) << 8 | (z[14] & 255) << 16 | (z[15] & 255) << 24, Te = C[4] & 255 | (C[5] & 255) << 8 | (C[6] & 255) << 16 | (C[7] & 255) << 24, Re = U[0] & 255 | (U[1] & 255) << 8 | (U[2] & 255) << 16 | (U[3] & 255) << 24, nt = U[4] & 255 | (U[5] & 255) << 8 | (U[6] & 255) << 16 | (U[7] & 255) << 24, je = U[8] & 255 | (U[9] & 255) << 8 | (U[10] & 255) << 16 | (U[11] & 255) << 24, pt = U[12] & 255 | (U[13] & 255) << 8 | (U[14] & 255) << 16 | (U[15] & 255) << 24, it = C[8] & 255 | (C[9] & 255) << 8 | (C[10] & 255) << 16 | (C[11] & 255) << 24, et = z[16] & 255 | (z[17] & 255) << 8 | (z[18] & 255) << 16 | (z[19] & 255) << 24, St = z[20] & 255 | (z[21] & 255) << 8 | (z[22] & 255) << 16 | (z[23] & 255) << 24, Tt = z[24] & 255 | (z[25] & 255) << 8 | (z[26] & 255) << 16 | (z[27] & 255) << 24, At = z[28] & 255 | (z[29] & 255) << 8 | (z[30] & 255) << 16 | (z[31] & 255) << 24, _t = C[12] & 255 | (C[13] & 255) << 8 | (C[14] & 255) << 16 | (C[15] & 255) << 24, ht = G, xt = j, st = se, bt = de, ut = xe, ot = Te, Se = Re, Ae = nt, Ve = je, Fe = pt, Ue = it, Je = et, Lt = St, zt = Tt, Zt = At, Wt = _t, he, rr = 0; rr < 20; rr += 2)
        he = ht + Lt | 0, ut ^= he << 7 | he >>> 25, he = ut + ht | 0, Ve ^= he << 9 | he >>> 23, he = Ve + ut | 0, Lt ^= he << 13 | he >>> 19, he = Lt + Ve | 0, ht ^= he << 18 | he >>> 14, he = ot + xt | 0, Fe ^= he << 7 | he >>> 25, he = Fe + ot | 0, zt ^= he << 9 | he >>> 23, he = zt + Fe | 0, xt ^= he << 13 | he >>> 19, he = xt + zt | 0, ot ^= he << 18 | he >>> 14, he = Ue + Se | 0, Zt ^= he << 7 | he >>> 25, he = Zt + Ue | 0, st ^= he << 9 | he >>> 23, he = st + Zt | 0, Se ^= he << 13 | he >>> 19, he = Se + st | 0, Ue ^= he << 18 | he >>> 14, he = Wt + Je | 0, bt ^= he << 7 | he >>> 25, he = bt + Wt | 0, Ae ^= he << 9 | he >>> 23, he = Ae + bt | 0, Je ^= he << 13 | he >>> 19, he = Je + Ae | 0, Wt ^= he << 18 | he >>> 14, he = ht + bt | 0, xt ^= he << 7 | he >>> 25, he = xt + ht | 0, st ^= he << 9 | he >>> 23, he = st + xt | 0, bt ^= he << 13 | he >>> 19, he = bt + st | 0, ht ^= he << 18 | he >>> 14, he = ot + ut | 0, Se ^= he << 7 | he >>> 25, he = Se + ot | 0, Ae ^= he << 9 | he >>> 23, he = Ae + Se | 0, ut ^= he << 13 | he >>> 19, he = ut + Ae | 0, ot ^= he << 18 | he >>> 14, he = Ue + Fe | 0, Je ^= he << 7 | he >>> 25, he = Je + Ue | 0, Ve ^= he << 9 | he >>> 23, he = Ve + Je | 0, Fe ^= he << 13 | he >>> 19, he = Fe + Ve | 0, Ue ^= he << 18 | he >>> 14, he = Wt + Zt | 0, Lt ^= he << 7 | he >>> 25, he = Lt + Wt | 0, zt ^= he << 9 | he >>> 23, he = zt + Lt | 0, Zt ^= he << 13 | he >>> 19, he = Zt + zt | 0, Wt ^= he << 18 | he >>> 14;
      ht = ht + G | 0, xt = xt + j | 0, st = st + se | 0, bt = bt + de | 0, ut = ut + xe | 0, ot = ot + Te | 0, Se = Se + Re | 0, Ae = Ae + nt | 0, Ve = Ve + je | 0, Fe = Fe + pt | 0, Ue = Ue + it | 0, Je = Je + et | 0, Lt = Lt + St | 0, zt = zt + Tt | 0, Zt = Zt + At | 0, Wt = Wt + _t | 0, k[0] = ht >>> 0 & 255, k[1] = ht >>> 8 & 255, k[2] = ht >>> 16 & 255, k[3] = ht >>> 24 & 255, k[4] = xt >>> 0 & 255, k[5] = xt >>> 8 & 255, k[6] = xt >>> 16 & 255, k[7] = xt >>> 24 & 255, k[8] = st >>> 0 & 255, k[9] = st >>> 8 & 255, k[10] = st >>> 16 & 255, k[11] = st >>> 24 & 255, k[12] = bt >>> 0 & 255, k[13] = bt >>> 8 & 255, k[14] = bt >>> 16 & 255, k[15] = bt >>> 24 & 255, k[16] = ut >>> 0 & 255, k[17] = ut >>> 8 & 255, k[18] = ut >>> 16 & 255, k[19] = ut >>> 24 & 255, k[20] = ot >>> 0 & 255, k[21] = ot >>> 8 & 255, k[22] = ot >>> 16 & 255, k[23] = ot >>> 24 & 255, k[24] = Se >>> 0 & 255, k[25] = Se >>> 8 & 255, k[26] = Se >>> 16 & 255, k[27] = Se >>> 24 & 255, k[28] = Ae >>> 0 & 255, k[29] = Ae >>> 8 & 255, k[30] = Ae >>> 16 & 255, k[31] = Ae >>> 24 & 255, k[32] = Ve >>> 0 & 255, k[33] = Ve >>> 8 & 255, k[34] = Ve >>> 16 & 255, k[35] = Ve >>> 24 & 255, k[36] = Fe >>> 0 & 255, k[37] = Fe >>> 8 & 255, k[38] = Fe >>> 16 & 255, k[39] = Fe >>> 24 & 255, k[40] = Ue >>> 0 & 255, k[41] = Ue >>> 8 & 255, k[42] = Ue >>> 16 & 255, k[43] = Ue >>> 24 & 255, k[44] = Je >>> 0 & 255, k[45] = Je >>> 8 & 255, k[46] = Je >>> 16 & 255, k[47] = Je >>> 24 & 255, k[48] = Lt >>> 0 & 255, k[49] = Lt >>> 8 & 255, k[50] = Lt >>> 16 & 255, k[51] = Lt >>> 24 & 255, k[52] = zt >>> 0 & 255, k[53] = zt >>> 8 & 255, k[54] = zt >>> 16 & 255, k[55] = zt >>> 24 & 255, k[56] = Zt >>> 0 & 255, k[57] = Zt >>> 8 & 255, k[58] = Zt >>> 16 & 255, k[59] = Zt >>> 24 & 255, k[60] = Wt >>> 0 & 255, k[61] = Wt >>> 8 & 255, k[62] = Wt >>> 16 & 255, k[63] = Wt >>> 24 & 255;
    }
    function H(k, U, z, C) {
      for (var G = C[0] & 255 | (C[1] & 255) << 8 | (C[2] & 255) << 16 | (C[3] & 255) << 24, j = z[0] & 255 | (z[1] & 255) << 8 | (z[2] & 255) << 16 | (z[3] & 255) << 24, se = z[4] & 255 | (z[5] & 255) << 8 | (z[6] & 255) << 16 | (z[7] & 255) << 24, de = z[8] & 255 | (z[9] & 255) << 8 | (z[10] & 255) << 16 | (z[11] & 255) << 24, xe = z[12] & 255 | (z[13] & 255) << 8 | (z[14] & 255) << 16 | (z[15] & 255) << 24, Te = C[4] & 255 | (C[5] & 255) << 8 | (C[6] & 255) << 16 | (C[7] & 255) << 24, Re = U[0] & 255 | (U[1] & 255) << 8 | (U[2] & 255) << 16 | (U[3] & 255) << 24, nt = U[4] & 255 | (U[5] & 255) << 8 | (U[6] & 255) << 16 | (U[7] & 255) << 24, je = U[8] & 255 | (U[9] & 255) << 8 | (U[10] & 255) << 16 | (U[11] & 255) << 24, pt = U[12] & 255 | (U[13] & 255) << 8 | (U[14] & 255) << 16 | (U[15] & 255) << 24, it = C[8] & 255 | (C[9] & 255) << 8 | (C[10] & 255) << 16 | (C[11] & 255) << 24, et = z[16] & 255 | (z[17] & 255) << 8 | (z[18] & 255) << 16 | (z[19] & 255) << 24, St = z[20] & 255 | (z[21] & 255) << 8 | (z[22] & 255) << 16 | (z[23] & 255) << 24, Tt = z[24] & 255 | (z[25] & 255) << 8 | (z[26] & 255) << 16 | (z[27] & 255) << 24, At = z[28] & 255 | (z[29] & 255) << 8 | (z[30] & 255) << 16 | (z[31] & 255) << 24, _t = C[12] & 255 | (C[13] & 255) << 8 | (C[14] & 255) << 16 | (C[15] & 255) << 24, ht = G, xt = j, st = se, bt = de, ut = xe, ot = Te, Se = Re, Ae = nt, Ve = je, Fe = pt, Ue = it, Je = et, Lt = St, zt = Tt, Zt = At, Wt = _t, he, rr = 0; rr < 20; rr += 2)
        he = ht + Lt | 0, ut ^= he << 7 | he >>> 25, he = ut + ht | 0, Ve ^= he << 9 | he >>> 23, he = Ve + ut | 0, Lt ^= he << 13 | he >>> 19, he = Lt + Ve | 0, ht ^= he << 18 | he >>> 14, he = ot + xt | 0, Fe ^= he << 7 | he >>> 25, he = Fe + ot | 0, zt ^= he << 9 | he >>> 23, he = zt + Fe | 0, xt ^= he << 13 | he >>> 19, he = xt + zt | 0, ot ^= he << 18 | he >>> 14, he = Ue + Se | 0, Zt ^= he << 7 | he >>> 25, he = Zt + Ue | 0, st ^= he << 9 | he >>> 23, he = st + Zt | 0, Se ^= he << 13 | he >>> 19, he = Se + st | 0, Ue ^= he << 18 | he >>> 14, he = Wt + Je | 0, bt ^= he << 7 | he >>> 25, he = bt + Wt | 0, Ae ^= he << 9 | he >>> 23, he = Ae + bt | 0, Je ^= he << 13 | he >>> 19, he = Je + Ae | 0, Wt ^= he << 18 | he >>> 14, he = ht + bt | 0, xt ^= he << 7 | he >>> 25, he = xt + ht | 0, st ^= he << 9 | he >>> 23, he = st + xt | 0, bt ^= he << 13 | he >>> 19, he = bt + st | 0, ht ^= he << 18 | he >>> 14, he = ot + ut | 0, Se ^= he << 7 | he >>> 25, he = Se + ot | 0, Ae ^= he << 9 | he >>> 23, he = Ae + Se | 0, ut ^= he << 13 | he >>> 19, he = ut + Ae | 0, ot ^= he << 18 | he >>> 14, he = Ue + Fe | 0, Je ^= he << 7 | he >>> 25, he = Je + Ue | 0, Ve ^= he << 9 | he >>> 23, he = Ve + Je | 0, Fe ^= he << 13 | he >>> 19, he = Fe + Ve | 0, Ue ^= he << 18 | he >>> 14, he = Wt + Zt | 0, Lt ^= he << 7 | he >>> 25, he = Lt + Wt | 0, zt ^= he << 9 | he >>> 23, he = zt + Lt | 0, Zt ^= he << 13 | he >>> 19, he = Zt + zt | 0, Wt ^= he << 18 | he >>> 14;
      k[0] = ht >>> 0 & 255, k[1] = ht >>> 8 & 255, k[2] = ht >>> 16 & 255, k[3] = ht >>> 24 & 255, k[4] = ot >>> 0 & 255, k[5] = ot >>> 8 & 255, k[6] = ot >>> 16 & 255, k[7] = ot >>> 24 & 255, k[8] = Ue >>> 0 & 255, k[9] = Ue >>> 8 & 255, k[10] = Ue >>> 16 & 255, k[11] = Ue >>> 24 & 255, k[12] = Wt >>> 0 & 255, k[13] = Wt >>> 8 & 255, k[14] = Wt >>> 16 & 255, k[15] = Wt >>> 24 & 255, k[16] = Se >>> 0 & 255, k[17] = Se >>> 8 & 255, k[18] = Se >>> 16 & 255, k[19] = Se >>> 24 & 255, k[20] = Ae >>> 0 & 255, k[21] = Ae >>> 8 & 255, k[22] = Ae >>> 16 & 255, k[23] = Ae >>> 24 & 255, k[24] = Ve >>> 0 & 255, k[25] = Ve >>> 8 & 255, k[26] = Ve >>> 16 & 255, k[27] = Ve >>> 24 & 255, k[28] = Fe >>> 0 & 255, k[29] = Fe >>> 8 & 255, k[30] = Fe >>> 16 & 255, k[31] = Fe >>> 24 & 255;
    }
    function W(k, U, z, C) {
      B(k, U, z, C);
    }
    function V(k, U, z, C) {
      H(k, U, z, C);
    }
    var te = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function R(k, U, z, C, G, j, se) {
      var de = new Uint8Array(16), xe = new Uint8Array(64), Te, Re;
      for (Re = 0; Re < 16; Re++) de[Re] = 0;
      for (Re = 0; Re < 8; Re++) de[Re] = j[Re];
      for (; G >= 64; ) {
        for (W(xe, de, se, te), Re = 0; Re < 64; Re++) k[U + Re] = z[C + Re] ^ xe[Re];
        for (Te = 1, Re = 8; Re < 16; Re++)
          Te = Te + (de[Re] & 255) | 0, de[Re] = Te & 255, Te >>>= 8;
        G -= 64, U += 64, C += 64;
      }
      if (G > 0)
        for (W(xe, de, se, te), Re = 0; Re < G; Re++) k[U + Re] = z[C + Re] ^ xe[Re];
      return 0;
    }
    function K(k, U, z, C, G) {
      var j = new Uint8Array(16), se = new Uint8Array(64), de, xe;
      for (xe = 0; xe < 16; xe++) j[xe] = 0;
      for (xe = 0; xe < 8; xe++) j[xe] = C[xe];
      for (; z >= 64; ) {
        for (W(se, j, G, te), xe = 0; xe < 64; xe++) k[U + xe] = se[xe];
        for (de = 1, xe = 8; xe < 16; xe++)
          de = de + (j[xe] & 255) | 0, j[xe] = de & 255, de >>>= 8;
        z -= 64, U += 64;
      }
      if (z > 0)
        for (W(se, j, G, te), xe = 0; xe < z; xe++) k[U + xe] = se[xe];
      return 0;
    }
    function ge(k, U, z, C, G) {
      var j = new Uint8Array(32);
      V(j, C, G, te);
      for (var se = new Uint8Array(8), de = 0; de < 8; de++) se[de] = C[de + 16];
      return K(k, U, z, se, j);
    }
    function Ee(k, U, z, C, G, j, se) {
      var de = new Uint8Array(32);
      V(de, j, se, te);
      for (var xe = new Uint8Array(8), Te = 0; Te < 8; Te++) xe[Te] = j[Te + 16];
      return R(k, U, z, C, G, xe, de);
    }
    var Y = function(k) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var U, z, C, G, j, se, de, xe;
      U = k[0] & 255 | (k[1] & 255) << 8, this.r[0] = U & 8191, z = k[2] & 255 | (k[3] & 255) << 8, this.r[1] = (U >>> 13 | z << 3) & 8191, C = k[4] & 255 | (k[5] & 255) << 8, this.r[2] = (z >>> 10 | C << 6) & 7939, G = k[6] & 255 | (k[7] & 255) << 8, this.r[3] = (C >>> 7 | G << 9) & 8191, j = k[8] & 255 | (k[9] & 255) << 8, this.r[4] = (G >>> 4 | j << 12) & 255, this.r[5] = j >>> 1 & 8190, se = k[10] & 255 | (k[11] & 255) << 8, this.r[6] = (j >>> 14 | se << 2) & 8191, de = k[12] & 255 | (k[13] & 255) << 8, this.r[7] = (se >>> 11 | de << 5) & 8065, xe = k[14] & 255 | (k[15] & 255) << 8, this.r[8] = (de >>> 8 | xe << 8) & 8191, this.r[9] = xe >>> 5 & 127, this.pad[0] = k[16] & 255 | (k[17] & 255) << 8, this.pad[1] = k[18] & 255 | (k[19] & 255) << 8, this.pad[2] = k[20] & 255 | (k[21] & 255) << 8, this.pad[3] = k[22] & 255 | (k[23] & 255) << 8, this.pad[4] = k[24] & 255 | (k[25] & 255) << 8, this.pad[5] = k[26] & 255 | (k[27] & 255) << 8, this.pad[6] = k[28] & 255 | (k[29] & 255) << 8, this.pad[7] = k[30] & 255 | (k[31] & 255) << 8;
    };
    Y.prototype.blocks = function(k, U, z) {
      for (var C = this.fin ? 0 : 2048, G, j, se, de, xe, Te, Re, nt, je, pt, it, et, St, Tt, At, _t, ht, xt, st, bt = this.h[0], ut = this.h[1], ot = this.h[2], Se = this.h[3], Ae = this.h[4], Ve = this.h[5], Fe = this.h[6], Ue = this.h[7], Je = this.h[8], Lt = this.h[9], zt = this.r[0], Zt = this.r[1], Wt = this.r[2], he = this.r[3], rr = this.r[4], dr = this.r[5], pr = this.r[6], Qt = this.r[7], gr = this.r[8], lr = this.r[9]; z >= 16; )
        G = k[U + 0] & 255 | (k[U + 1] & 255) << 8, bt += G & 8191, j = k[U + 2] & 255 | (k[U + 3] & 255) << 8, ut += (G >>> 13 | j << 3) & 8191, se = k[U + 4] & 255 | (k[U + 5] & 255) << 8, ot += (j >>> 10 | se << 6) & 8191, de = k[U + 6] & 255 | (k[U + 7] & 255) << 8, Se += (se >>> 7 | de << 9) & 8191, xe = k[U + 8] & 255 | (k[U + 9] & 255) << 8, Ae += (de >>> 4 | xe << 12) & 8191, Ve += xe >>> 1 & 8191, Te = k[U + 10] & 255 | (k[U + 11] & 255) << 8, Fe += (xe >>> 14 | Te << 2) & 8191, Re = k[U + 12] & 255 | (k[U + 13] & 255) << 8, Ue += (Te >>> 11 | Re << 5) & 8191, nt = k[U + 14] & 255 | (k[U + 15] & 255) << 8, Je += (Re >>> 8 | nt << 8) & 8191, Lt += nt >>> 5 | C, je = 0, pt = je, pt += bt * zt, pt += ut * (5 * lr), pt += ot * (5 * gr), pt += Se * (5 * Qt), pt += Ae * (5 * pr), je = pt >>> 13, pt &= 8191, pt += Ve * (5 * dr), pt += Fe * (5 * rr), pt += Ue * (5 * he), pt += Je * (5 * Wt), pt += Lt * (5 * Zt), je += pt >>> 13, pt &= 8191, it = je, it += bt * Zt, it += ut * zt, it += ot * (5 * lr), it += Se * (5 * gr), it += Ae * (5 * Qt), je = it >>> 13, it &= 8191, it += Ve * (5 * pr), it += Fe * (5 * dr), it += Ue * (5 * rr), it += Je * (5 * he), it += Lt * (5 * Wt), je += it >>> 13, it &= 8191, et = je, et += bt * Wt, et += ut * Zt, et += ot * zt, et += Se * (5 * lr), et += Ae * (5 * gr), je = et >>> 13, et &= 8191, et += Ve * (5 * Qt), et += Fe * (5 * pr), et += Ue * (5 * dr), et += Je * (5 * rr), et += Lt * (5 * he), je += et >>> 13, et &= 8191, St = je, St += bt * he, St += ut * Wt, St += ot * Zt, St += Se * zt, St += Ae * (5 * lr), je = St >>> 13, St &= 8191, St += Ve * (5 * gr), St += Fe * (5 * Qt), St += Ue * (5 * pr), St += Je * (5 * dr), St += Lt * (5 * rr), je += St >>> 13, St &= 8191, Tt = je, Tt += bt * rr, Tt += ut * he, Tt += ot * Wt, Tt += Se * Zt, Tt += Ae * zt, je = Tt >>> 13, Tt &= 8191, Tt += Ve * (5 * lr), Tt += Fe * (5 * gr), Tt += Ue * (5 * Qt), Tt += Je * (5 * pr), Tt += Lt * (5 * dr), je += Tt >>> 13, Tt &= 8191, At = je, At += bt * dr, At += ut * rr, At += ot * he, At += Se * Wt, At += Ae * Zt, je = At >>> 13, At &= 8191, At += Ve * zt, At += Fe * (5 * lr), At += Ue * (5 * gr), At += Je * (5 * Qt), At += Lt * (5 * pr), je += At >>> 13, At &= 8191, _t = je, _t += bt * pr, _t += ut * dr, _t += ot * rr, _t += Se * he, _t += Ae * Wt, je = _t >>> 13, _t &= 8191, _t += Ve * Zt, _t += Fe * zt, _t += Ue * (5 * lr), _t += Je * (5 * gr), _t += Lt * (5 * Qt), je += _t >>> 13, _t &= 8191, ht = je, ht += bt * Qt, ht += ut * pr, ht += ot * dr, ht += Se * rr, ht += Ae * he, je = ht >>> 13, ht &= 8191, ht += Ve * Wt, ht += Fe * Zt, ht += Ue * zt, ht += Je * (5 * lr), ht += Lt * (5 * gr), je += ht >>> 13, ht &= 8191, xt = je, xt += bt * gr, xt += ut * Qt, xt += ot * pr, xt += Se * dr, xt += Ae * rr, je = xt >>> 13, xt &= 8191, xt += Ve * he, xt += Fe * Wt, xt += Ue * Zt, xt += Je * zt, xt += Lt * (5 * lr), je += xt >>> 13, xt &= 8191, st = je, st += bt * lr, st += ut * gr, st += ot * Qt, st += Se * pr, st += Ae * dr, je = st >>> 13, st &= 8191, st += Ve * rr, st += Fe * he, st += Ue * Wt, st += Je * Zt, st += Lt * zt, je += st >>> 13, st &= 8191, je = (je << 2) + je | 0, je = je + pt | 0, pt = je & 8191, je = je >>> 13, it += je, bt = pt, ut = it, ot = et, Se = St, Ae = Tt, Ve = At, Fe = _t, Ue = ht, Je = xt, Lt = st, U += 16, z -= 16;
      this.h[0] = bt, this.h[1] = ut, this.h[2] = ot, this.h[3] = Se, this.h[4] = Ae, this.h[5] = Ve, this.h[6] = Fe, this.h[7] = Ue, this.h[8] = Je, this.h[9] = Lt;
    }, Y.prototype.finish = function(k, U) {
      var z = new Uint16Array(10), C, G, j, se;
      if (this.leftover) {
        for (se = this.leftover, this.buffer[se++] = 1; se < 16; se++) this.buffer[se] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (C = this.h[1] >>> 13, this.h[1] &= 8191, se = 2; se < 10; se++)
        this.h[se] += C, C = this.h[se] >>> 13, this.h[se] &= 8191;
      for (this.h[0] += C * 5, C = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += C, C = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += C, z[0] = this.h[0] + 5, C = z[0] >>> 13, z[0] &= 8191, se = 1; se < 10; se++)
        z[se] = this.h[se] + C, C = z[se] >>> 13, z[se] &= 8191;
      for (z[9] -= 8192, G = (C ^ 1) - 1, se = 0; se < 10; se++) z[se] &= G;
      for (G = ~G, se = 0; se < 10; se++) this.h[se] = this.h[se] & G | z[se];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, j = this.h[0] + this.pad[0], this.h[0] = j & 65535, se = 1; se < 8; se++)
        j = (this.h[se] + this.pad[se] | 0) + (j >>> 16) | 0, this.h[se] = j & 65535;
      k[U + 0] = this.h[0] >>> 0 & 255, k[U + 1] = this.h[0] >>> 8 & 255, k[U + 2] = this.h[1] >>> 0 & 255, k[U + 3] = this.h[1] >>> 8 & 255, k[U + 4] = this.h[2] >>> 0 & 255, k[U + 5] = this.h[2] >>> 8 & 255, k[U + 6] = this.h[3] >>> 0 & 255, k[U + 7] = this.h[3] >>> 8 & 255, k[U + 8] = this.h[4] >>> 0 & 255, k[U + 9] = this.h[4] >>> 8 & 255, k[U + 10] = this.h[5] >>> 0 & 255, k[U + 11] = this.h[5] >>> 8 & 255, k[U + 12] = this.h[6] >>> 0 & 255, k[U + 13] = this.h[6] >>> 8 & 255, k[U + 14] = this.h[7] >>> 0 & 255, k[U + 15] = this.h[7] >>> 8 & 255;
    }, Y.prototype.update = function(k, U, z) {
      var C, G;
      if (this.leftover) {
        for (G = 16 - this.leftover, G > z && (G = z), C = 0; C < G; C++)
          this.buffer[this.leftover + C] = k[U + C];
        if (z -= G, U += G, this.leftover += G, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (z >= 16 && (G = z - z % 16, this.blocks(k, U, G), U += G, z -= G), z) {
        for (C = 0; C < z; C++)
          this.buffer[this.leftover + C] = k[U + C];
        this.leftover += z;
      }
    };
    function S(k, U, z, C, G, j) {
      var se = new Y(j);
      return se.update(z, C, G), se.finish(k, U), 0;
    }
    function m(k, U, z, C, G, j) {
      var se = new Uint8Array(16);
      return S(se, 0, z, C, G, j), L(k, U, se, 0);
    }
    function f(k, U, z, C, G) {
      var j;
      if (z < 32) return -1;
      for (Ee(k, 0, U, 0, z, C, G), S(k, 16, k, 32, z - 32, k), j = 0; j < 16; j++) k[j] = 0;
      return 0;
    }
    function g(k, U, z, C, G) {
      var j, se = new Uint8Array(32);
      if (z < 32 || (ge(se, 0, 32, C, G), m(U, 16, U, 32, z - 32, se) !== 0)) return -1;
      for (Ee(k, 0, U, 0, z, C, G), j = 0; j < 32; j++) k[j] = 0;
      return 0;
    }
    function b(k, U) {
      var z;
      for (z = 0; z < 16; z++) k[z] = U[z] | 0;
    }
    function x(k) {
      var U, z, C = 1;
      for (U = 0; U < 16; U++)
        z = k[U] + C + 65535, C = Math.floor(z / 65536), k[U] = z - C * 65536;
      k[0] += C - 1 + 37 * (C - 1);
    }
    function _(k, U, z) {
      for (var C, G = ~(z - 1), j = 0; j < 16; j++)
        C = G & (k[j] ^ U[j]), k[j] ^= C, U[j] ^= C;
    }
    function E(k, U) {
      var z, C, G, j = r(), se = r();
      for (z = 0; z < 16; z++) se[z] = U[z];
      for (x(se), x(se), x(se), C = 0; C < 2; C++) {
        for (j[0] = se[0] - 65517, z = 1; z < 15; z++)
          j[z] = se[z] - 65535 - (j[z - 1] >> 16 & 1), j[z - 1] &= 65535;
        j[15] = se[15] - 32767 - (j[14] >> 16 & 1), G = j[15] >> 16 & 1, j[14] &= 65535, _(se, j, 1 - G);
      }
      for (z = 0; z < 16; z++)
        k[2 * z] = se[z] & 255, k[2 * z + 1] = se[z] >> 8;
    }
    function v(k, U) {
      var z = new Uint8Array(32), C = new Uint8Array(32);
      return E(z, k), E(C, U), $(z, 0, C, 0);
    }
    function M(k) {
      var U = new Uint8Array(32);
      return E(U, k), U[0] & 1;
    }
    function I(k, U) {
      var z;
      for (z = 0; z < 16; z++) k[z] = U[2 * z] + (U[2 * z + 1] << 8);
      k[15] &= 32767;
    }
    function F(k, U, z) {
      for (var C = 0; C < 16; C++) k[C] = U[C] + z[C];
    }
    function ce(k, U, z) {
      for (var C = 0; C < 16; C++) k[C] = U[C] - z[C];
    }
    function D(k, U, z) {
      var C, G, j = 0, se = 0, de = 0, xe = 0, Te = 0, Re = 0, nt = 0, je = 0, pt = 0, it = 0, et = 0, St = 0, Tt = 0, At = 0, _t = 0, ht = 0, xt = 0, st = 0, bt = 0, ut = 0, ot = 0, Se = 0, Ae = 0, Ve = 0, Fe = 0, Ue = 0, Je = 0, Lt = 0, zt = 0, Zt = 0, Wt = 0, he = z[0], rr = z[1], dr = z[2], pr = z[3], Qt = z[4], gr = z[5], lr = z[6], Rr = z[7], mr = z[8], yr = z[9], $r = z[10], Br = z[11], Ir = z[12], nn = z[13], sn = z[14], on = z[15];
      C = U[0], j += C * he, se += C * rr, de += C * dr, xe += C * pr, Te += C * Qt, Re += C * gr, nt += C * lr, je += C * Rr, pt += C * mr, it += C * yr, et += C * $r, St += C * Br, Tt += C * Ir, At += C * nn, _t += C * sn, ht += C * on, C = U[1], se += C * he, de += C * rr, xe += C * dr, Te += C * pr, Re += C * Qt, nt += C * gr, je += C * lr, pt += C * Rr, it += C * mr, et += C * yr, St += C * $r, Tt += C * Br, At += C * Ir, _t += C * nn, ht += C * sn, xt += C * on, C = U[2], de += C * he, xe += C * rr, Te += C * dr, Re += C * pr, nt += C * Qt, je += C * gr, pt += C * lr, it += C * Rr, et += C * mr, St += C * yr, Tt += C * $r, At += C * Br, _t += C * Ir, ht += C * nn, xt += C * sn, st += C * on, C = U[3], xe += C * he, Te += C * rr, Re += C * dr, nt += C * pr, je += C * Qt, pt += C * gr, it += C * lr, et += C * Rr, St += C * mr, Tt += C * yr, At += C * $r, _t += C * Br, ht += C * Ir, xt += C * nn, st += C * sn, bt += C * on, C = U[4], Te += C * he, Re += C * rr, nt += C * dr, je += C * pr, pt += C * Qt, it += C * gr, et += C * lr, St += C * Rr, Tt += C * mr, At += C * yr, _t += C * $r, ht += C * Br, xt += C * Ir, st += C * nn, bt += C * sn, ut += C * on, C = U[5], Re += C * he, nt += C * rr, je += C * dr, pt += C * pr, it += C * Qt, et += C * gr, St += C * lr, Tt += C * Rr, At += C * mr, _t += C * yr, ht += C * $r, xt += C * Br, st += C * Ir, bt += C * nn, ut += C * sn, ot += C * on, C = U[6], nt += C * he, je += C * rr, pt += C * dr, it += C * pr, et += C * Qt, St += C * gr, Tt += C * lr, At += C * Rr, _t += C * mr, ht += C * yr, xt += C * $r, st += C * Br, bt += C * Ir, ut += C * nn, ot += C * sn, Se += C * on, C = U[7], je += C * he, pt += C * rr, it += C * dr, et += C * pr, St += C * Qt, Tt += C * gr, At += C * lr, _t += C * Rr, ht += C * mr, xt += C * yr, st += C * $r, bt += C * Br, ut += C * Ir, ot += C * nn, Se += C * sn, Ae += C * on, C = U[8], pt += C * he, it += C * rr, et += C * dr, St += C * pr, Tt += C * Qt, At += C * gr, _t += C * lr, ht += C * Rr, xt += C * mr, st += C * yr, bt += C * $r, ut += C * Br, ot += C * Ir, Se += C * nn, Ae += C * sn, Ve += C * on, C = U[9], it += C * he, et += C * rr, St += C * dr, Tt += C * pr, At += C * Qt, _t += C * gr, ht += C * lr, xt += C * Rr, st += C * mr, bt += C * yr, ut += C * $r, ot += C * Br, Se += C * Ir, Ae += C * nn, Ve += C * sn, Fe += C * on, C = U[10], et += C * he, St += C * rr, Tt += C * dr, At += C * pr, _t += C * Qt, ht += C * gr, xt += C * lr, st += C * Rr, bt += C * mr, ut += C * yr, ot += C * $r, Se += C * Br, Ae += C * Ir, Ve += C * nn, Fe += C * sn, Ue += C * on, C = U[11], St += C * he, Tt += C * rr, At += C * dr, _t += C * pr, ht += C * Qt, xt += C * gr, st += C * lr, bt += C * Rr, ut += C * mr, ot += C * yr, Se += C * $r, Ae += C * Br, Ve += C * Ir, Fe += C * nn, Ue += C * sn, Je += C * on, C = U[12], Tt += C * he, At += C * rr, _t += C * dr, ht += C * pr, xt += C * Qt, st += C * gr, bt += C * lr, ut += C * Rr, ot += C * mr, Se += C * yr, Ae += C * $r, Ve += C * Br, Fe += C * Ir, Ue += C * nn, Je += C * sn, Lt += C * on, C = U[13], At += C * he, _t += C * rr, ht += C * dr, xt += C * pr, st += C * Qt, bt += C * gr, ut += C * lr, ot += C * Rr, Se += C * mr, Ae += C * yr, Ve += C * $r, Fe += C * Br, Ue += C * Ir, Je += C * nn, Lt += C * sn, zt += C * on, C = U[14], _t += C * he, ht += C * rr, xt += C * dr, st += C * pr, bt += C * Qt, ut += C * gr, ot += C * lr, Se += C * Rr, Ae += C * mr, Ve += C * yr, Fe += C * $r, Ue += C * Br, Je += C * Ir, Lt += C * nn, zt += C * sn, Zt += C * on, C = U[15], ht += C * he, xt += C * rr, st += C * dr, bt += C * pr, ut += C * Qt, ot += C * gr, Se += C * lr, Ae += C * Rr, Ve += C * mr, Fe += C * yr, Ue += C * $r, Je += C * Br, Lt += C * Ir, zt += C * nn, Zt += C * sn, Wt += C * on, j += 38 * xt, se += 38 * st, de += 38 * bt, xe += 38 * ut, Te += 38 * ot, Re += 38 * Se, nt += 38 * Ae, je += 38 * Ve, pt += 38 * Fe, it += 38 * Ue, et += 38 * Je, St += 38 * Lt, Tt += 38 * zt, At += 38 * Zt, _t += 38 * Wt, G = 1, C = j + G + 65535, G = Math.floor(C / 65536), j = C - G * 65536, C = se + G + 65535, G = Math.floor(C / 65536), se = C - G * 65536, C = de + G + 65535, G = Math.floor(C / 65536), de = C - G * 65536, C = xe + G + 65535, G = Math.floor(C / 65536), xe = C - G * 65536, C = Te + G + 65535, G = Math.floor(C / 65536), Te = C - G * 65536, C = Re + G + 65535, G = Math.floor(C / 65536), Re = C - G * 65536, C = nt + G + 65535, G = Math.floor(C / 65536), nt = C - G * 65536, C = je + G + 65535, G = Math.floor(C / 65536), je = C - G * 65536, C = pt + G + 65535, G = Math.floor(C / 65536), pt = C - G * 65536, C = it + G + 65535, G = Math.floor(C / 65536), it = C - G * 65536, C = et + G + 65535, G = Math.floor(C / 65536), et = C - G * 65536, C = St + G + 65535, G = Math.floor(C / 65536), St = C - G * 65536, C = Tt + G + 65535, G = Math.floor(C / 65536), Tt = C - G * 65536, C = At + G + 65535, G = Math.floor(C / 65536), At = C - G * 65536, C = _t + G + 65535, G = Math.floor(C / 65536), _t = C - G * 65536, C = ht + G + 65535, G = Math.floor(C / 65536), ht = C - G * 65536, j += G - 1 + 37 * (G - 1), G = 1, C = j + G + 65535, G = Math.floor(C / 65536), j = C - G * 65536, C = se + G + 65535, G = Math.floor(C / 65536), se = C - G * 65536, C = de + G + 65535, G = Math.floor(C / 65536), de = C - G * 65536, C = xe + G + 65535, G = Math.floor(C / 65536), xe = C - G * 65536, C = Te + G + 65535, G = Math.floor(C / 65536), Te = C - G * 65536, C = Re + G + 65535, G = Math.floor(C / 65536), Re = C - G * 65536, C = nt + G + 65535, G = Math.floor(C / 65536), nt = C - G * 65536, C = je + G + 65535, G = Math.floor(C / 65536), je = C - G * 65536, C = pt + G + 65535, G = Math.floor(C / 65536), pt = C - G * 65536, C = it + G + 65535, G = Math.floor(C / 65536), it = C - G * 65536, C = et + G + 65535, G = Math.floor(C / 65536), et = C - G * 65536, C = St + G + 65535, G = Math.floor(C / 65536), St = C - G * 65536, C = Tt + G + 65535, G = Math.floor(C / 65536), Tt = C - G * 65536, C = At + G + 65535, G = Math.floor(C / 65536), At = C - G * 65536, C = _t + G + 65535, G = Math.floor(C / 65536), _t = C - G * 65536, C = ht + G + 65535, G = Math.floor(C / 65536), ht = C - G * 65536, j += G - 1 + 37 * (G - 1), k[0] = j, k[1] = se, k[2] = de, k[3] = xe, k[4] = Te, k[5] = Re, k[6] = nt, k[7] = je, k[8] = pt, k[9] = it, k[10] = et, k[11] = St, k[12] = Tt, k[13] = At, k[14] = _t, k[15] = ht;
    }
    function oe(k, U) {
      D(k, U, U);
    }
    function Z(k, U) {
      var z = r(), C;
      for (C = 0; C < 16; C++) z[C] = U[C];
      for (C = 253; C >= 0; C--)
        oe(z, z), C !== 2 && C !== 4 && D(z, z, U);
      for (C = 0; C < 16; C++) k[C] = z[C];
    }
    function J(k, U) {
      var z = r(), C;
      for (C = 0; C < 16; C++) z[C] = U[C];
      for (C = 250; C >= 0; C--)
        oe(z, z), C !== 1 && D(z, z, U);
      for (C = 0; C < 16; C++) k[C] = z[C];
    }
    function Q(k, U, z) {
      var C = new Uint8Array(32), G = new Float64Array(80), j, se, de = r(), xe = r(), Te = r(), Re = r(), nt = r(), je = r();
      for (se = 0; se < 31; se++) C[se] = U[se];
      for (C[31] = U[31] & 127 | 64, C[0] &= 248, I(G, z), se = 0; se < 16; se++)
        xe[se] = G[se], Re[se] = de[se] = Te[se] = 0;
      for (de[0] = Re[0] = 1, se = 254; se >= 0; --se)
        j = C[se >>> 3] >>> (se & 7) & 1, _(de, xe, j), _(Te, Re, j), F(nt, de, Te), ce(de, de, Te), F(Te, xe, Re), ce(xe, xe, Re), oe(Re, nt), oe(je, de), D(de, Te, de), D(Te, xe, nt), F(nt, de, Te), ce(de, de, Te), oe(xe, de), ce(Te, Re, je), D(de, Te, u), F(de, de, Re), D(Te, Te, de), D(de, Re, je), D(Re, xe, G), oe(xe, nt), _(de, xe, j), _(Te, Re, j);
      for (se = 0; se < 16; se++)
        G[se + 16] = de[se], G[se + 32] = Te[se], G[se + 48] = xe[se], G[se + 64] = Re[se];
      var pt = G.subarray(32), it = G.subarray(16);
      return Z(pt, pt), D(it, it, pt), E(k, it), 0;
    }
    function T(k, U) {
      return Q(k, U, s);
    }
    function X(k, U) {
      return n(U, 32), T(k, U);
    }
    function re(k, U, z) {
      var C = new Uint8Array(32);
      return Q(C, z, U), V(k, i, C, te);
    }
    var pe = f, ie = g;
    function ue(k, U, z, C, G, j) {
      var se = new Uint8Array(32);
      return re(se, G, j), pe(k, U, z, C, se);
    }
    function ve(k, U, z, C, G, j) {
      var se = new Uint8Array(32);
      return re(se, G, j), ie(k, U, z, C, se);
    }
    var Pe = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function De(k, U, z, C) {
      for (var G = new Int32Array(16), j = new Int32Array(16), se, de, xe, Te, Re, nt, je, pt, it, et, St, Tt, At, _t, ht, xt, st, bt, ut, ot, Se, Ae, Ve, Fe, Ue, Je, Lt = k[0], zt = k[1], Zt = k[2], Wt = k[3], he = k[4], rr = k[5], dr = k[6], pr = k[7], Qt = U[0], gr = U[1], lr = U[2], Rr = U[3], mr = U[4], yr = U[5], $r = U[6], Br = U[7], Ir = 0; C >= 128; ) {
        for (ut = 0; ut < 16; ut++)
          ot = 8 * ut + Ir, G[ut] = z[ot + 0] << 24 | z[ot + 1] << 16 | z[ot + 2] << 8 | z[ot + 3], j[ut] = z[ot + 4] << 24 | z[ot + 5] << 16 | z[ot + 6] << 8 | z[ot + 7];
        for (ut = 0; ut < 80; ut++)
          if (se = Lt, de = zt, xe = Zt, Te = Wt, Re = he, nt = rr, je = dr, pt = pr, it = Qt, et = gr, St = lr, Tt = Rr, At = mr, _t = yr, ht = $r, xt = Br, Se = pr, Ae = Br, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = (he >>> 14 | mr << 18) ^ (he >>> 18 | mr << 14) ^ (mr >>> 9 | he << 23), Ae = (mr >>> 14 | he << 18) ^ (mr >>> 18 | he << 14) ^ (he >>> 9 | mr << 23), Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Se = he & rr ^ ~he & dr, Ae = mr & yr ^ ~mr & $r, Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Se = Pe[ut * 2], Ae = Pe[ut * 2 + 1], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Se = G[ut % 16], Ae = j[ut % 16], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, st = Ue & 65535 | Je << 16, bt = Ve & 65535 | Fe << 16, Se = st, Ae = bt, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = (Lt >>> 28 | Qt << 4) ^ (Qt >>> 2 | Lt << 30) ^ (Qt >>> 7 | Lt << 25), Ae = (Qt >>> 28 | Lt << 4) ^ (Lt >>> 2 | Qt << 30) ^ (Lt >>> 7 | Qt << 25), Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Se = Lt & zt ^ Lt & Zt ^ zt & Zt, Ae = Qt & gr ^ Qt & lr ^ gr & lr, Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, pt = Ue & 65535 | Je << 16, xt = Ve & 65535 | Fe << 16, Se = Te, Ae = Tt, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = st, Ae = bt, Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, Te = Ue & 65535 | Je << 16, Tt = Ve & 65535 | Fe << 16, zt = se, Zt = de, Wt = xe, he = Te, rr = Re, dr = nt, pr = je, Lt = pt, gr = it, lr = et, Rr = St, mr = Tt, yr = At, $r = _t, Br = ht, Qt = xt, ut % 16 === 15)
            for (ot = 0; ot < 16; ot++)
              Se = G[ot], Ae = j[ot], Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = G[(ot + 9) % 16], Ae = j[(ot + 9) % 16], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, st = G[(ot + 1) % 16], bt = j[(ot + 1) % 16], Se = (st >>> 1 | bt << 31) ^ (st >>> 8 | bt << 24) ^ st >>> 7, Ae = (bt >>> 1 | st << 31) ^ (bt >>> 8 | st << 24) ^ (bt >>> 7 | st << 25), Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, st = G[(ot + 14) % 16], bt = j[(ot + 14) % 16], Se = (st >>> 19 | bt << 13) ^ (bt >>> 29 | st << 3) ^ st >>> 6, Ae = (bt >>> 19 | st << 13) ^ (st >>> 29 | bt << 3) ^ (bt >>> 6 | st << 26), Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, G[ot] = Ue & 65535 | Je << 16, j[ot] = Ve & 65535 | Fe << 16;
        Se = Lt, Ae = Qt, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = k[0], Ae = U[0], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, k[0] = Lt = Ue & 65535 | Je << 16, U[0] = Qt = Ve & 65535 | Fe << 16, Se = zt, Ae = gr, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = k[1], Ae = U[1], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, k[1] = zt = Ue & 65535 | Je << 16, U[1] = gr = Ve & 65535 | Fe << 16, Se = Zt, Ae = lr, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = k[2], Ae = U[2], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, k[2] = Zt = Ue & 65535 | Je << 16, U[2] = lr = Ve & 65535 | Fe << 16, Se = Wt, Ae = Rr, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = k[3], Ae = U[3], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, k[3] = Wt = Ue & 65535 | Je << 16, U[3] = Rr = Ve & 65535 | Fe << 16, Se = he, Ae = mr, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = k[4], Ae = U[4], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, k[4] = he = Ue & 65535 | Je << 16, U[4] = mr = Ve & 65535 | Fe << 16, Se = rr, Ae = yr, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = k[5], Ae = U[5], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, k[5] = rr = Ue & 65535 | Je << 16, U[5] = yr = Ve & 65535 | Fe << 16, Se = dr, Ae = $r, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = k[6], Ae = U[6], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, k[6] = dr = Ue & 65535 | Je << 16, U[6] = $r = Ve & 65535 | Fe << 16, Se = pr, Ae = Br, Ve = Ae & 65535, Fe = Ae >>> 16, Ue = Se & 65535, Je = Se >>> 16, Se = k[7], Ae = U[7], Ve += Ae & 65535, Fe += Ae >>> 16, Ue += Se & 65535, Je += Se >>> 16, Fe += Ve >>> 16, Ue += Fe >>> 16, Je += Ue >>> 16, k[7] = pr = Ue & 65535 | Je << 16, U[7] = Br = Ve & 65535 | Fe << 16, Ir += 128, C -= 128;
      }
      return C;
    }
    function Ce(k, U, z) {
      var C = new Int32Array(8), G = new Int32Array(8), j = new Uint8Array(256), se, de = z;
      for (C[0] = 1779033703, C[1] = 3144134277, C[2] = 1013904242, C[3] = 2773480762, C[4] = 1359893119, C[5] = 2600822924, C[6] = 528734635, C[7] = 1541459225, G[0] = 4089235720, G[1] = 2227873595, G[2] = 4271175723, G[3] = 1595750129, G[4] = 2917565137, G[5] = 725511199, G[6] = 4215389547, G[7] = 327033209, De(C, G, U, z), z %= 128, se = 0; se < z; se++) j[se] = U[de - z + se];
      for (j[z] = 128, z = 256 - 128 * (z < 112 ? 1 : 0), j[z - 9] = 0, P(j, z - 8, de / 536870912 | 0, de << 3), De(C, G, j, z), se = 0; se < 8; se++) P(k, 8 * se, C[se], G[se]);
      return 0;
    }
    function $e(k, U) {
      var z = r(), C = r(), G = r(), j = r(), se = r(), de = r(), xe = r(), Te = r(), Re = r();
      ce(z, k[1], k[0]), ce(Re, U[1], U[0]), D(z, z, Re), F(C, k[0], k[1]), F(Re, U[0], U[1]), D(C, C, Re), D(G, k[3], U[3]), D(G, G, d), D(j, k[2], U[2]), F(j, j, j), ce(se, C, z), ce(de, j, G), F(xe, j, G), F(Te, C, z), D(k[0], se, de), D(k[1], Te, xe), D(k[2], xe, de), D(k[3], se, Te);
    }
    function Me(k, U, z) {
      var C;
      for (C = 0; C < 4; C++)
        _(k[C], U[C], z);
    }
    function Ne(k, U) {
      var z = r(), C = r(), G = r();
      Z(G, U[2]), D(z, U[0], G), D(C, U[1], G), E(k, C), k[31] ^= M(z) << 7;
    }
    function Ke(k, U, z) {
      var C, G;
      for (b(k[0], o), b(k[1], a), b(k[2], a), b(k[3], o), G = 255; G >= 0; --G)
        C = z[G / 8 | 0] >> (G & 7) & 1, Me(k, U, C), $e(U, k), $e(k, k), Me(k, U, C);
    }
    function Le(k, U) {
      var z = [r(), r(), r(), r()];
      b(z[0], p), b(z[1], w), b(z[2], a), D(z[3], p, w), Ke(k, z, U);
    }
    function qe(k, U, z) {
      var C = new Uint8Array(64), G = [r(), r(), r(), r()], j;
      for (z || n(U, 32), Ce(C, U, 32), C[0] &= 248, C[31] &= 127, C[31] |= 64, Le(G, C), Ne(k, G), j = 0; j < 32; j++) U[j + 32] = k[j];
      return 0;
    }
    var ze = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function _e(k, U) {
      var z, C, G, j;
      for (C = 63; C >= 32; --C) {
        for (z = 0, G = C - 32, j = C - 12; G < j; ++G)
          U[G] += z - 16 * U[C] * ze[G - (C - 32)], z = Math.floor((U[G] + 128) / 256), U[G] -= z * 256;
        U[G] += z, U[C] = 0;
      }
      for (z = 0, G = 0; G < 32; G++)
        U[G] += z - (U[31] >> 4) * ze[G], z = U[G] >> 8, U[G] &= 255;
      for (G = 0; G < 32; G++) U[G] -= z * ze[G];
      for (C = 0; C < 32; C++)
        U[C + 1] += U[C] >> 8, k[C] = U[C] & 255;
    }
    function Ze(k) {
      var U = new Float64Array(64), z;
      for (z = 0; z < 64; z++) U[z] = k[z];
      for (z = 0; z < 64; z++) k[z] = 0;
      _e(k, U);
    }
    function at(k, U, z, C) {
      var G = new Uint8Array(64), j = new Uint8Array(64), se = new Uint8Array(64), de, xe, Te = new Float64Array(64), Re = [r(), r(), r(), r()];
      Ce(G, C, 32), G[0] &= 248, G[31] &= 127, G[31] |= 64;
      var nt = z + 64;
      for (de = 0; de < z; de++) k[64 + de] = U[de];
      for (de = 0; de < 32; de++) k[32 + de] = G[32 + de];
      for (Ce(se, k.subarray(32), z + 32), Ze(se), Le(Re, se), Ne(k, Re), de = 32; de < 64; de++) k[de] = C[de];
      for (Ce(j, k, z + 64), Ze(j), de = 0; de < 64; de++) Te[de] = 0;
      for (de = 0; de < 32; de++) Te[de] = se[de];
      for (de = 0; de < 32; de++)
        for (xe = 0; xe < 32; xe++)
          Te[de + xe] += j[de] * G[xe];
      return _e(k.subarray(32), Te), nt;
    }
    function ke(k, U) {
      var z = r(), C = r(), G = r(), j = r(), se = r(), de = r(), xe = r();
      return b(k[2], a), I(k[1], U), oe(G, k[1]), D(j, G, l), ce(G, G, k[2]), F(j, k[2], j), oe(se, j), oe(de, se), D(xe, de, se), D(z, xe, G), D(z, z, j), J(z, z), D(z, z, G), D(z, z, j), D(z, z, j), D(k[0], z, j), oe(C, k[0]), D(C, C, j), v(C, G) && D(k[0], k[0], A), oe(C, k[0]), D(C, C, j), v(C, G) ? -1 : (M(k[0]) === U[31] >> 7 && ce(k[0], o, k[0]), D(k[3], k[0], k[1]), 0);
    }
    function Qe(k, U, z, C) {
      var G, j = new Uint8Array(32), se = new Uint8Array(64), de = [r(), r(), r(), r()], xe = [r(), r(), r(), r()];
      if (z < 64 || ke(xe, C)) return -1;
      for (G = 0; G < z; G++) k[G] = U[G];
      for (G = 0; G < 32; G++) k[G + 32] = C[G];
      if (Ce(se, k, z), Ze(se), Ke(de, xe, se), Le(xe, U.subarray(32)), $e(de, xe), Ne(j, de), z -= 64, $(U, 0, j, 0)) {
        for (G = 0; G < z; G++) k[G] = 0;
        return -1;
      }
      for (G = 0; G < z; G++) k[G] = U[G + 64];
      return z;
    }
    var tt = 32, Ye = 24, dt = 32, lt = 16, ct = 32, qt = 32, Jt = 32, Et = 32, er = 32, Xt = Ye, Dt = dt, kt = lt, Ct = 64, gt = 32, Rt = 64, Nt = 32, vt = 64;
    e.lowlevel = {
      crypto_core_hsalsa20: V,
      crypto_stream_xor: Ee,
      crypto_stream: ge,
      crypto_stream_salsa20_xor: R,
      crypto_stream_salsa20: K,
      crypto_onetimeauth: S,
      crypto_onetimeauth_verify: m,
      crypto_verify_16: L,
      crypto_verify_32: $,
      crypto_secretbox: f,
      crypto_secretbox_open: g,
      crypto_scalarmult: Q,
      crypto_scalarmult_base: T,
      crypto_box_beforenm: re,
      crypto_box_afternm: pe,
      crypto_box: ue,
      crypto_box_open: ve,
      crypto_box_keypair: X,
      crypto_hash: Ce,
      crypto_sign: at,
      crypto_sign_keypair: qe,
      crypto_sign_open: Qe,
      crypto_secretbox_KEYBYTES: tt,
      crypto_secretbox_NONCEBYTES: Ye,
      crypto_secretbox_ZEROBYTES: dt,
      crypto_secretbox_BOXZEROBYTES: lt,
      crypto_scalarmult_BYTES: ct,
      crypto_scalarmult_SCALARBYTES: qt,
      crypto_box_PUBLICKEYBYTES: Jt,
      crypto_box_SECRETKEYBYTES: Et,
      crypto_box_BEFORENMBYTES: er,
      crypto_box_NONCEBYTES: Xt,
      crypto_box_ZEROBYTES: Dt,
      crypto_box_BOXZEROBYTES: kt,
      crypto_sign_BYTES: Ct,
      crypto_sign_PUBLICKEYBYTES: gt,
      crypto_sign_SECRETKEYBYTES: Rt,
      crypto_sign_SEEDBYTES: Nt,
      crypto_hash_BYTES: vt,
      gf: r,
      D: l,
      L: ze,
      pack25519: E,
      unpack25519: I,
      M: D,
      A: F,
      S: oe,
      Z: ce,
      pow2523: J,
      add: $e,
      set25519: b,
      modL: _e,
      scalarmult: Ke,
      scalarbase: Le
    };
    function $t(k, U) {
      if (k.length !== tt) throw new Error("bad key size");
      if (U.length !== Ye) throw new Error("bad nonce size");
    }
    function Ft(k, U) {
      if (k.length !== Jt) throw new Error("bad public key size");
      if (U.length !== Et) throw new Error("bad secret key size");
    }
    function rt() {
      for (var k = 0; k < arguments.length; k++)
        if (!(arguments[k] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function Bt(k) {
      for (var U = 0; U < k.length; U++) k[U] = 0;
    }
    e.randomBytes = function(k) {
      var U = new Uint8Array(k);
      return n(U, k), U;
    }, e.secretbox = function(k, U, z) {
      rt(k, U, z), $t(z, U);
      for (var C = new Uint8Array(dt + k.length), G = new Uint8Array(C.length), j = 0; j < k.length; j++) C[j + dt] = k[j];
      return f(G, C, C.length, U, z), G.subarray(lt);
    }, e.secretbox.open = function(k, U, z) {
      rt(k, U, z), $t(z, U);
      for (var C = new Uint8Array(lt + k.length), G = new Uint8Array(C.length), j = 0; j < k.length; j++) C[j + lt] = k[j];
      return C.length < 32 || g(G, C, C.length, U, z) !== 0 ? null : G.subarray(dt);
    }, e.secretbox.keyLength = tt, e.secretbox.nonceLength = Ye, e.secretbox.overheadLength = lt, e.scalarMult = function(k, U) {
      if (rt(k, U), k.length !== qt) throw new Error("bad n size");
      if (U.length !== ct) throw new Error("bad p size");
      var z = new Uint8Array(ct);
      return Q(z, k, U), z;
    }, e.scalarMult.base = function(k) {
      if (rt(k), k.length !== qt) throw new Error("bad n size");
      var U = new Uint8Array(ct);
      return T(U, k), U;
    }, e.scalarMult.scalarLength = qt, e.scalarMult.groupElementLength = ct, e.box = function(k, U, z, C) {
      var G = e.box.before(z, C);
      return e.secretbox(k, U, G);
    }, e.box.before = function(k, U) {
      rt(k, U), Ft(k, U);
      var z = new Uint8Array(er);
      return re(z, k, U), z;
    }, e.box.after = e.secretbox, e.box.open = function(k, U, z, C) {
      var G = e.box.before(z, C);
      return e.secretbox.open(k, U, G);
    }, e.box.open.after = e.secretbox.open, e.box.keyPair = function() {
      var k = new Uint8Array(Jt), U = new Uint8Array(Et);
      return X(k, U), { publicKey: k, secretKey: U };
    }, e.box.keyPair.fromSecretKey = function(k) {
      if (rt(k), k.length !== Et)
        throw new Error("bad secret key size");
      var U = new Uint8Array(Jt);
      return T(U, k), { publicKey: U, secretKey: new Uint8Array(k) };
    }, e.box.publicKeyLength = Jt, e.box.secretKeyLength = Et, e.box.sharedKeyLength = er, e.box.nonceLength = Xt, e.box.overheadLength = e.secretbox.overheadLength, e.sign = function(k, U) {
      if (rt(k, U), U.length !== Rt)
        throw new Error("bad secret key size");
      var z = new Uint8Array(Ct + k.length);
      return at(z, k, k.length, U), z;
    }, e.sign.open = function(k, U) {
      if (rt(k, U), U.length !== gt)
        throw new Error("bad public key size");
      var z = new Uint8Array(k.length), C = Qe(z, k, k.length, U);
      if (C < 0) return null;
      for (var G = new Uint8Array(C), j = 0; j < G.length; j++) G[j] = z[j];
      return G;
    }, e.sign.detached = function(k, U) {
      for (var z = e.sign(k, U), C = new Uint8Array(Ct), G = 0; G < C.length; G++) C[G] = z[G];
      return C;
    }, e.sign.detached.verify = function(k, U, z) {
      if (rt(k, U, z), U.length !== Ct)
        throw new Error("bad signature size");
      if (z.length !== gt)
        throw new Error("bad public key size");
      var C = new Uint8Array(Ct + k.length), G = new Uint8Array(Ct + k.length), j;
      for (j = 0; j < Ct; j++) C[j] = U[j];
      for (j = 0; j < k.length; j++) C[j + Ct] = k[j];
      return Qe(G, C, C.length, z) >= 0;
    }, e.sign.keyPair = function() {
      var k = new Uint8Array(gt), U = new Uint8Array(Rt);
      return qe(k, U), { publicKey: k, secretKey: U };
    }, e.sign.keyPair.fromSecretKey = function(k) {
      if (rt(k), k.length !== Rt)
        throw new Error("bad secret key size");
      for (var U = new Uint8Array(gt), z = 0; z < U.length; z++) U[z] = k[32 + z];
      return { publicKey: U, secretKey: new Uint8Array(k) };
    }, e.sign.keyPair.fromSeed = function(k) {
      if (rt(k), k.length !== Nt)
        throw new Error("bad seed size");
      for (var U = new Uint8Array(gt), z = new Uint8Array(Rt), C = 0; C < 32; C++) z[C] = k[C];
      return qe(U, z, !0), { publicKey: U, secretKey: z };
    }, e.sign.publicKeyLength = gt, e.sign.secretKeyLength = Rt, e.sign.seedLength = Nt, e.sign.signatureLength = Ct, e.hash = function(k) {
      rt(k);
      var U = new Uint8Array(vt);
      return Ce(U, k, k.length), U;
    }, e.hash.hashLength = vt, e.verify = function(k, U) {
      return rt(k, U), k.length === 0 || U.length === 0 || k.length !== U.length ? !1 : N(k, 0, U, 0, k.length) === 0;
    }, e.setPRNG = function(k) {
      n = k;
    }, function() {
      var k = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (k && k.getRandomValues) {
        var U = 65536;
        e.setPRNG(function(z, C) {
          var G, j = new Uint8Array(C);
          for (G = 0; G < C; G += U)
            k.getRandomValues(j.subarray(G, G + Math.min(C - G, U)));
          for (G = 0; G < C; G++) z[G] = j[G];
          Bt(j);
        });
      } else typeof M4 < "u" && (k = Wl, k && k.randomBytes && e.setPRNG(function(z, C) {
        var G, j = k.randomBytes(C);
        for (G = 0; G < C; G++) z[G] = j[G];
        Bt(j);
      }));
    }();
  })(t.exports ? t.exports : self.nacl = self.nacl || {});
})(K9);
var fie = K9.exports;
const yd = /* @__PURE__ */ rs(fie);
var ha;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR", t[t.MANIFEST_NOT_FOUND_ERROR = 2] = "MANIFEST_NOT_FOUND_ERROR", t[t.MANIFEST_CONTENT_ERROR = 3] = "MANIFEST_CONTENT_ERROR", t[t.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR", t[t.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(ha || (ha = {}));
var d5;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(d5 || (d5 = {}));
var su;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR", t[t.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR", t[t.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(su || (su = {}));
var p5;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR", t[t.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR", t[t.USER_REJECTS_ERROR = 300] = "USER_REJECTS_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(p5 || (p5 = {}));
var g5;
(function(t) {
  t[t.UNKNOWN_ERROR = 0] = "UNKNOWN_ERROR", t[t.BAD_REQUEST_ERROR = 1] = "BAD_REQUEST_ERROR", t[t.UNKNOWN_APP_ERROR = 100] = "UNKNOWN_APP_ERROR", t[t.METHOD_NOT_SUPPORTED = 400] = "METHOD_NOT_SUPPORTED";
})(g5 || (g5 = {}));
var m5;
(function(t) {
  t.MAINNET = "-239", t.TESTNET = "-3";
})(m5 || (m5 = {}));
function lie(t, e) {
  const r = Dl.encodeBase64(t);
  return e ? encodeURIComponent(r) : r;
}
function hie(t, e) {
  return e && (t = decodeURIComponent(t)), Dl.decodeBase64(t);
}
function die(t, e = !1) {
  let r;
  return t instanceof Uint8Array ? r = t : (typeof t != "string" && (t = JSON.stringify(t)), r = Dl.decodeUTF8(t)), lie(r, e);
}
function pie(t, e = !1) {
  const r = hie(t, e);
  return {
    toString() {
      return Dl.encodeUTF8(r);
    },
    toObject() {
      try {
        return JSON.parse(Dl.encodeUTF8(r));
      } catch {
        return null;
      }
    },
    toUint8Array() {
      return r;
    }
  };
}
const V9 = {
  encode: die,
  decode: pie
};
function gie(t, e) {
  const r = new Uint8Array(t.length + e.length);
  return r.set(t), r.set(e, t.length), r;
}
function mie(t, e) {
  if (e >= t.length)
    throw new Error("Index is out of buffer");
  const r = t.slice(0, e), n = t.slice(e);
  return [r, n];
}
function Km(t) {
  let e = "";
  return t.forEach((r) => {
    e += ("0" + (r & 255).toString(16)).slice(-2);
  }), e;
}
function A0(t) {
  if (t.length % 2 !== 0)
    throw new Error(`Cannot convert ${t} to bytesArray`);
  const e = new Uint8Array(t.length / 2);
  for (let r = 0; r < t.length; r += 2)
    e[r / 2] = parseInt(t.slice(r, r + 2), 16);
  return e;
}
class hv {
  constructor(e) {
    this.nonceLength = 24, this.keyPair = e ? this.createKeypairFromString(e) : this.createKeypair(), this.sessionId = Km(this.keyPair.publicKey);
  }
  createKeypair() {
    return yd.box.keyPair();
  }
  createKeypairFromString(e) {
    return {
      publicKey: A0(e.publicKey),
      secretKey: A0(e.secretKey)
    };
  }
  createNonce() {
    return yd.randomBytes(this.nonceLength);
  }
  encrypt(e, r) {
    const n = new TextEncoder().encode(e), i = this.createNonce(), s = yd.box(n, i, r, this.keyPair.secretKey);
    return gie(i, s);
  }
  decrypt(e, r) {
    const [n, i] = mie(e, this.nonceLength), s = yd.box.open(i, n, r, this.keyPair.secretKey);
    if (!s)
      throw new Error(`Decryption error: 
 message: ${e.toString()} 
 sender pubkey: ${r.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`);
    return new TextDecoder().decode(s);
  }
  stringifyKeypair() {
    return {
      publicKey: Km(this.keyPair.publicKey),
      secretKey: Km(this.keyPair.secretKey)
    };
  }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function vie(t, e) {
  var r = {};
  for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(t); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]]);
  return r;
}
function Mt(t, e, r, n) {
  function i(s) {
    return s instanceof r ? s : new r(function(o) {
      o(s);
    });
  }
  return new (r || (r = Promise))(function(s, o) {
    function a(d) {
      try {
        l(n.next(d));
      } catch (p) {
        o(p);
      }
    }
    function u(d) {
      try {
        l(n.throw(d));
      } catch (p) {
        o(p);
      }
    }
    function l(d) {
      d.done ? s(d.value) : i(d.value).then(a, u);
    }
    l((n = n.apply(t, [])).next());
  });
}
class jt extends Error {
  constructor(e, r) {
    super(e, r), this.message = `${jt.prefix} ${this.constructor.name}${this.info ? ": " + this.info : ""}${e ? `
` + e : ""}`, Object.setPrototypeOf(this, jt.prototype);
  }
  get info() {
    return "";
  }
}
jt.prefix = "[TON_CONNECT_SDK_ERROR]";
class ly extends jt {
  get info() {
    return "Passed DappMetadata is in incorrect format.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, ly.prototype);
  }
}
class Ap extends jt {
  get info() {
    return "Passed `tonconnect-manifest.json` contains errors. Check format of your manifest. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Ap.prototype);
  }
}
class Pp extends jt {
  get info() {
    return "Manifest not found. Make sure you added `tonconnect-manifest.json` to the root of your app or passed correct manifestUrl. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Pp.prototype);
  }
}
class hy extends jt {
  get info() {
    return "Wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, hy.prototype);
  }
}
class P0 extends jt {
  get info() {
    return "Send transaction or other protocol methods called while wallet is not connected.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, P0.prototype);
  }
}
function bie(t) {
  return "jsBridgeKey" in t;
}
class Mp extends jt {
  get info() {
    return "User rejects the action in the wallet.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Mp.prototype);
  }
}
class Ip extends jt {
  get info() {
    return "Request to the wallet contains errors.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Ip.prototype);
  }
}
class Cp extends jt {
  get info() {
    return "App tries to send rpc request to the injected wallet while not connected.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Cp.prototype);
  }
}
class dy extends jt {
  get info() {
    return "There is an attempt to connect to the injected wallet while it is not exists in the webpage.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, dy.prototype);
  }
}
class py extends jt {
  get info() {
    return "An error occurred while fetching the wallets list.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, py.prototype);
  }
}
class Pa extends jt {
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, Pa.prototype);
  }
}
const v5 = {
  [ha.UNKNOWN_ERROR]: Pa,
  [ha.USER_REJECTS_ERROR]: Mp,
  [ha.BAD_REQUEST_ERROR]: Ip,
  [ha.UNKNOWN_APP_ERROR]: Cp,
  [ha.MANIFEST_NOT_FOUND_ERROR]: Pp,
  [ha.MANIFEST_CONTENT_ERROR]: Ap
};
class yie {
  parseError(e) {
    let r = Pa;
    return e.code in v5 && (r = v5[e.code] || Pa), new r(e.message);
  }
}
const wie = new yie();
class xie {
  isError(e) {
    return "error" in e;
  }
}
const b5 = {
  [su.UNKNOWN_ERROR]: Pa,
  [su.USER_REJECTS_ERROR]: Mp,
  [su.BAD_REQUEST_ERROR]: Ip,
  [su.UNKNOWN_APP_ERROR]: Cp
};
class _ie extends xie {
  convertToRpcRequest(e) {
    return {
      method: "sendTransaction",
      params: [JSON.stringify(e)]
    };
  }
  parseAndThrowError(e) {
    let r = Pa;
    throw e.error.code in b5 && (r = b5[e.error.code] || Pa), new r(e.error.message);
  }
  convertFromRpcResponse(e) {
    return {
      boc: e.result
    };
  }
}
const wd = new _ie();
class Eie {
  constructor(e, r) {
    this.storage = e, this.storeKey = "ton-connect-storage_http-bridge-gateway::" + r;
  }
  storeLastEventId(e) {
    return Mt(this, void 0, void 0, function* () {
      return this.storage.setItem(this.storeKey, e);
    });
  }
  removeLastEventId() {
    return Mt(this, void 0, void 0, function* () {
      return this.storage.removeItem(this.storeKey);
    });
  }
  getLastEventId() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.storage.getItem(this.storeKey);
      return e || null;
    });
  }
}
function Sie(t) {
  return t.slice(-1) === "/" ? t.slice(0, -1) : t;
}
function G9(t, e) {
  return Sie(t) + "/" + e;
}
function Aie(t) {
  if (!t)
    return !1;
  const e = new URL(t);
  return e.protocol === "tg:" || e.hostname === "t.me";
}
function Pie(t) {
  return t.replaceAll(".", "%2E").replaceAll("-", "%2D").replaceAll("_", "%5F").replaceAll("&", "-").replaceAll("=", "__").replaceAll("%", "--");
}
function Y9(t, e) {
  return Mt(this, void 0, void 0, function* () {
    return new Promise((r, n) => {
      var i, s;
      if (!((i = void 0) === null || i === void 0) && i.aborted) {
        n(new jt("Delay aborted"));
        return;
      }
      const o = setTimeout(() => r(), t);
      (s = void 0) === null || s === void 0 || s.addEventListener("abort", () => {
        clearTimeout(o), n(new jt("Delay aborted"));
      });
    });
  });
}
function _s(t) {
  const e = new AbortController();
  return t != null && t.aborted ? e.abort() : t == null || t.addEventListener("abort", () => e.abort(), { once: !0 }), e;
}
function Zf(t, e) {
  var r, n;
  return Mt(this, void 0, void 0, function* () {
    const i = (r = e == null ? void 0 : e.attempts) !== null && r !== void 0 ? r : 10, s = (n = e == null ? void 0 : e.delayMs) !== null && n !== void 0 ? n : 200, o = _s(e == null ? void 0 : e.signal);
    if (typeof t != "function")
      throw new jt(`Expected a function, got ${typeof t}`);
    let a = 0, u;
    for (; a < i; ) {
      if (o.signal.aborted)
        throw new jt(`Aborted after attempts ${a}`);
      try {
        return yield t({ signal: o.signal });
      } catch (l) {
        u = l, a++, a < i && (yield Y9(s));
      }
    }
    throw u;
  });
}
function Sn(...t) {
  try {
    console.debug("[TON_CONNECT_SDK]", ...t);
  } catch {
  }
}
function Lo(...t) {
  try {
    console.error("[TON_CONNECT_SDK]", ...t);
  } catch {
  }
}
function Mie(...t) {
  try {
    console.warn("[TON_CONNECT_SDK]", ...t);
  } catch {
  }
}
function Iie(t, e) {
  let r = null, n = null, i = null, s = null, o = null;
  const a = (p, ...w) => Mt(this, void 0, void 0, function* () {
    if (s = p ?? null, o == null || o.abort(), o = _s(p), o.signal.aborted)
      throw new jt("Resource creation was aborted");
    n = w ?? null;
    const A = t(o.signal, ...w);
    i = A;
    const P = yield A;
    if (i !== A && P !== r)
      throw yield e(P), new jt("Resource creation was aborted by a new resource creation");
    return r = P, r;
  });
  return {
    create: a,
    current: () => r ?? null,
    dispose: () => Mt(this, void 0, void 0, function* () {
      try {
        const p = r;
        r = null;
        const w = i;
        i = null;
        try {
          o == null || o.abort();
        } catch {
        }
        yield Promise.allSettled([
          p ? e(p) : Promise.resolve(),
          w ? e(yield w) : Promise.resolve()
        ]);
      } catch {
      }
    }),
    recreate: (p) => Mt(this, void 0, void 0, function* () {
      const w = r, A = i, P = n, N = s;
      if (yield Y9(p), w === r && A === i && P === n && N === s)
        return yield a(s, ...P ?? []);
      throw new jt("Resource recreation was aborted by a new resource creation");
    })
  };
}
function Cie(t, e) {
  const r = e == null ? void 0 : e.timeout, n = e == null ? void 0 : e.signal, i = _s(n);
  return new Promise((s, o) => Mt(this, void 0, void 0, function* () {
    if (i.signal.aborted) {
      o(new jt("Operation aborted"));
      return;
    }
    let a;
    typeof r < "u" && (a = setTimeout(() => {
      i.abort(), o(new jt(`Timeout after ${r}ms`));
    }, r)), i.signal.addEventListener("abort", () => {
      clearTimeout(a), o(new jt("Operation aborted"));
    }, { once: !0 });
    const u = { timeout: r, abort: i.signal };
    yield t((...l) => {
      clearTimeout(a), s(...l);
    }, () => {
      clearTimeout(a), o();
    }, u);
  }));
}
class Vm {
  constructor(e, r, n, i, s) {
    this.bridgeUrl = r, this.sessionId = n, this.listener = i, this.errorsListener = s, this.ssePath = "events", this.postPath = "message", this.heartbeatMessage = "heartbeat", this.defaultTtl = 300, this.defaultReconnectDelay = 2e3, this.defaultResendDelay = 5e3, this.eventSource = Iie((o, a) => Mt(this, void 0, void 0, function* () {
      const u = {
        bridgeUrl: this.bridgeUrl,
        ssePath: this.ssePath,
        sessionId: this.sessionId,
        bridgeGatewayStorage: this.bridgeGatewayStorage,
        errorHandler: this.errorsHandler.bind(this),
        messageHandler: this.messagesHandler.bind(this),
        signal: o,
        openingDeadlineMS: a
      };
      return yield Tie(u);
    }), (o) => Mt(this, void 0, void 0, function* () {
      o.close();
    })), this.bridgeGatewayStorage = new Eie(e, r);
  }
  get isReady() {
    const e = this.eventSource.current();
    return (e == null ? void 0 : e.readyState) === EventSource.OPEN;
  }
  get isClosed() {
    const e = this.eventSource.current();
    return (e == null ? void 0 : e.readyState) !== EventSource.OPEN;
  }
  get isConnecting() {
    const e = this.eventSource.current();
    return (e == null ? void 0 : e.readyState) === EventSource.CONNECTING;
  }
  registerSession(e) {
    return Mt(this, void 0, void 0, function* () {
      yield this.eventSource.create(e == null ? void 0 : e.signal, e == null ? void 0 : e.openingDeadlineMS);
    });
  }
  send(e, r, n, i) {
    var s;
    return Mt(this, void 0, void 0, function* () {
      const o = {};
      typeof i == "number" ? o.ttl = i : (o.ttl = i == null ? void 0 : i.ttl, o.signal = i == null ? void 0 : i.signal, o.attempts = i == null ? void 0 : i.attempts);
      const a = new URL(G9(this.bridgeUrl, this.postPath));
      a.searchParams.append("client_id", this.sessionId), a.searchParams.append("to", r), a.searchParams.append("ttl", ((o == null ? void 0 : o.ttl) || this.defaultTtl).toString()), a.searchParams.append("topic", n);
      const u = V9.encode(e);
      yield Zf((l) => Mt(this, void 0, void 0, function* () {
        const d = yield this.post(a, u, l.signal);
        if (!d.ok)
          throw new jt(`Bridge send failed, status ${d.status}`);
      }), {
        attempts: (s = o == null ? void 0 : o.attempts) !== null && s !== void 0 ? s : Number.MAX_SAFE_INTEGER,
        delayMs: this.defaultResendDelay,
        signal: o == null ? void 0 : o.signal
      });
    });
  }
  pause() {
    this.eventSource.dispose().catch((e) => Lo(`Bridge pause failed, ${e}`));
  }
  unPause() {
    return Mt(this, void 0, void 0, function* () {
      yield this.eventSource.recreate(0);
    });
  }
  close() {
    return Mt(this, void 0, void 0, function* () {
      yield this.eventSource.dispose().catch((e) => Lo(`Bridge close failed, ${e}`));
    });
  }
  setListener(e) {
    this.listener = e;
  }
  setErrorsListener(e) {
    this.errorsListener = e;
  }
  post(e, r, n) {
    return Mt(this, void 0, void 0, function* () {
      const i = yield fetch(e, {
        method: "post",
        body: r,
        signal: n
      });
      if (!i.ok)
        throw new jt(`Bridge send failed, status ${i.status}`);
      return i;
    });
  }
  errorsHandler(e, r) {
    return Mt(this, void 0, void 0, function* () {
      if (this.isConnecting)
        throw e.close(), new jt("Bridge error, failed to connect");
      if (this.isReady) {
        try {
          this.errorsListener(r);
        } catch {
        }
        return;
      }
      if (this.isClosed)
        return e.close(), Sn(`Bridge reconnecting, ${this.defaultReconnectDelay}ms delay`), yield this.eventSource.recreate(this.defaultReconnectDelay);
      throw new jt("Bridge error, unknown state");
    });
  }
  messagesHandler(e) {
    return Mt(this, void 0, void 0, function* () {
      if (e.data === this.heartbeatMessage || (yield this.bridgeGatewayStorage.storeLastEventId(e.lastEventId), this.isClosed))
        return;
      let r;
      try {
        r = JSON.parse(e.data);
      } catch (n) {
        throw new jt(`Bridge message parse failed, message ${n.data}`);
      }
      this.listener(r);
    });
  }
}
function Tie(t) {
  return Mt(this, void 0, void 0, function* () {
    return yield Cie((e, r, n) => Mt(this, void 0, void 0, function* () {
      var i;
      const o = _s(n.signal).signal;
      if (o.aborted) {
        r(new jt("Bridge connection aborted"));
        return;
      }
      const a = new URL(G9(t.bridgeUrl, t.ssePath));
      a.searchParams.append("client_id", t.sessionId);
      const u = yield t.bridgeGatewayStorage.getLastEventId();
      if (u && a.searchParams.append("last_event_id", u), o.aborted) {
        r(new jt("Bridge connection aborted"));
        return;
      }
      const l = new EventSource(a.toString());
      l.onerror = (d) => Mt(this, void 0, void 0, function* () {
        if (o.aborted) {
          l.close(), r(new jt("Bridge connection aborted"));
          return;
        }
        try {
          const p = yield t.errorHandler(l, d);
          p !== l && l.close(), p && p !== l && e(p);
        } catch (p) {
          l.close(), r(p);
        }
      }), l.onopen = () => {
        if (o.aborted) {
          l.close(), r(new jt("Bridge connection aborted"));
          return;
        }
        e(l);
      }, l.onmessage = (d) => {
        if (o.aborted) {
          l.close(), r(new jt("Bridge connection aborted"));
          return;
        }
        t.messageHandler(d);
      }, (i = t.signal) === null || i === void 0 || i.addEventListener("abort", () => {
        l.close(), r(new jt("Bridge connection aborted"));
      });
    }), { timeout: t.openingDeadlineMS, signal: t.signal });
  });
}
function Qf(t) {
  return !("connectEvent" in t);
}
class Ol {
  constructor(e) {
    this.storage = e, this.storeKey = "ton-connect-storage_bridge-connection";
  }
  storeConnection(e) {
    return Mt(this, void 0, void 0, function* () {
      if (e.type === "injected")
        return this.storage.setItem(this.storeKey, JSON.stringify(e));
      if (!Qf(e)) {
        const n = {
          sessionKeyPair: e.session.sessionCrypto.stringifyKeypair(),
          walletPublicKey: e.session.walletPublicKey,
          bridgeUrl: e.session.bridgeUrl
        }, i = {
          type: "http",
          connectEvent: e.connectEvent,
          session: n,
          lastWalletEventId: e.lastWalletEventId,
          nextRpcRequestId: e.nextRpcRequestId
        };
        return this.storage.setItem(this.storeKey, JSON.stringify(i));
      }
      const r = {
        type: "http",
        connectionSource: e.connectionSource,
        sessionCrypto: e.sessionCrypto.stringifyKeypair()
      };
      return this.storage.setItem(this.storeKey, JSON.stringify(r));
    });
  }
  removeConnection() {
    return Mt(this, void 0, void 0, function* () {
      return this.storage.removeItem(this.storeKey);
    });
  }
  getConnection() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.storage.getItem(this.storeKey);
      if (!e)
        return null;
      const r = JSON.parse(e);
      if (r.type === "injected")
        return r;
      if ("connectEvent" in r) {
        const n = new hv(r.session.sessionKeyPair);
        return {
          type: "http",
          connectEvent: r.connectEvent,
          lastWalletEventId: r.lastWalletEventId,
          nextRpcRequestId: r.nextRpcRequestId,
          session: {
            sessionCrypto: n,
            bridgeUrl: r.session.bridgeUrl,
            walletPublicKey: r.session.walletPublicKey
          }
        };
      }
      return {
        type: "http",
        sessionCrypto: new hv(r.sessionCrypto),
        connectionSource: r.connectionSource
      };
    });
  }
  getHttpConnection() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (!e)
        throw new jt("Trying to read HTTP connection source while nothing is stored");
      if (e.type === "injected")
        throw new jt("Trying to read HTTP connection source while injected connection is stored");
      return e;
    });
  }
  getHttpPendingConnection() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (!e)
        throw new jt("Trying to read HTTP connection source while nothing is stored");
      if (e.type === "injected")
        throw new jt("Trying to read HTTP connection source while injected connection is stored");
      if (!Qf(e))
        throw new jt("Trying to read HTTP-pending connection while http connection is stored");
      return e;
    });
  }
  getInjectedConnection() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (!e)
        throw new jt("Trying to read Injected bridge connection source while nothing is stored");
      if ((e == null ? void 0 : e.type) === "http")
        throw new jt("Trying to read Injected bridge connection source while HTTP connection is stored");
      return e;
    });
  }
  storedConnectionType() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.storage.getItem(this.storeKey);
      return e ? JSON.parse(e).type : null;
    });
  }
  storeLastWalletEventId(e) {
    return Mt(this, void 0, void 0, function* () {
      const r = yield this.getConnection();
      if (r && r.type === "http" && !Qf(r))
        return r.lastWalletEventId = e, this.storeConnection(r);
    });
  }
  getLastWalletEventId() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (e && "lastWalletEventId" in e)
        return e.lastWalletEventId;
    });
  }
  increaseNextRpcRequestId() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      if (e && "nextRpcRequestId" in e) {
        const r = e.nextRpcRequestId || 0;
        return e.nextRpcRequestId = r + 1, this.storeConnection(e);
      }
    });
  }
  getNextRpcRequestId() {
    return Mt(this, void 0, void 0, function* () {
      const e = yield this.getConnection();
      return e && "nextRpcRequestId" in e && e.nextRpcRequestId || 0;
    });
  }
}
const J9 = 2;
class Nl {
  constructor(e, r) {
    this.storage = e, this.walletConnectionSource = r, this.type = "http", this.standardUniversalLink = "tc://", this.pendingRequests = /* @__PURE__ */ new Map(), this.session = null, this.gateway = null, this.pendingGateways = [], this.listeners = [], this.defaultOpeningDeadlineMS = 12e3, this.defaultRetryTimeoutMS = 2e3, this.connectionStorage = new Ol(e);
  }
  static fromStorage(e) {
    return Mt(this, void 0, void 0, function* () {
      const n = yield new Ol(e).getHttpConnection();
      return Qf(n) ? new Nl(e, n.connectionSource) : new Nl(e, { bridgeUrl: n.session.bridgeUrl });
    });
  }
  connect(e, r) {
    var n;
    const i = _s(r == null ? void 0 : r.signal);
    (n = this.abortController) === null || n === void 0 || n.abort(), this.abortController = i, this.closeGateways();
    const s = new hv();
    this.session = {
      sessionCrypto: s,
      bridgeUrl: "bridgeUrl" in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
    }, this.connectionStorage.storeConnection({
      type: "http",
      connectionSource: this.walletConnectionSource,
      sessionCrypto: s
    }).then(() => Mt(this, void 0, void 0, function* () {
      i.signal.aborted || (yield Zf((a) => {
        var u;
        return this.openGateways(s, {
          openingDeadlineMS: (u = r == null ? void 0 : r.openingDeadlineMS) !== null && u !== void 0 ? u : this.defaultOpeningDeadlineMS,
          signal: a == null ? void 0 : a.signal
        });
      }, {
        attempts: Number.MAX_SAFE_INTEGER,
        delayMs: this.defaultRetryTimeoutMS,
        signal: i.signal
      }));
    }));
    const o = "universalLink" in this.walletConnectionSource && this.walletConnectionSource.universalLink ? this.walletConnectionSource.universalLink : this.standardUniversalLink;
    return this.generateUniversalLink(o, e);
  }
  restoreConnection(e) {
    var r, n;
    return Mt(this, void 0, void 0, function* () {
      const i = _s(e == null ? void 0 : e.signal);
      if ((r = this.abortController) === null || r === void 0 || r.abort(), this.abortController = i, i.signal.aborted)
        return;
      this.closeGateways();
      const s = yield this.connectionStorage.getHttpConnection();
      if (!s || i.signal.aborted)
        return;
      const o = (n = e == null ? void 0 : e.openingDeadlineMS) !== null && n !== void 0 ? n : this.defaultOpeningDeadlineMS;
      if (Qf(s))
        return this.session = {
          sessionCrypto: s.sessionCrypto,
          bridgeUrl: "bridgeUrl" in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ""
        }, yield this.openGateways(s.sessionCrypto, {
          openingDeadlineMS: o,
          signal: i == null ? void 0 : i.signal
        });
      if (Array.isArray(this.walletConnectionSource))
        throw new jt("Internal error. Connection source is array while WalletConnectionSourceHTTP was expected.");
      if (this.session = s.session, this.gateway && (Sn("Gateway is already opened, closing previous gateway"), yield this.gateway.close()), this.gateway = new Vm(this.storage, this.walletConnectionSource.bridgeUrl, s.session.sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this)), !i.signal.aborted) {
        this.listeners.forEach((a) => a(s.connectEvent));
        try {
          yield Zf((a) => this.gateway.registerSession({
            openingDeadlineMS: o,
            signal: a.signal
          }), {
            attempts: Number.MAX_SAFE_INTEGER,
            delayMs: this.defaultRetryTimeoutMS,
            signal: i.signal
          });
        } catch {
          yield this.disconnect({ signal: i.signal });
          return;
        }
      }
    });
  }
  sendRequest(e, r) {
    const n = {};
    return typeof r == "function" ? n.onRequestSent = r : (n.onRequestSent = r == null ? void 0 : r.onRequestSent, n.signal = r == null ? void 0 : r.signal, n.attempts = r == null ? void 0 : r.attempts), new Promise((i, s) => Mt(this, void 0, void 0, function* () {
      var o;
      if (!this.gateway || !this.session || !("walletPublicKey" in this.session))
        throw new jt("Trying to send bridge request without session");
      const a = (yield this.connectionStorage.getNextRpcRequestId()).toString();
      yield this.connectionStorage.increaseNextRpcRequestId(), Sn("Send http-bridge request:", Object.assign(Object.assign({}, e), { id: a }));
      const u = this.session.sessionCrypto.encrypt(JSON.stringify(Object.assign(Object.assign({}, e), { id: a })), A0(this.session.walletPublicKey));
      try {
        yield this.gateway.send(u, this.session.walletPublicKey, e.method, { attempts: n == null ? void 0 : n.attempts, signal: n == null ? void 0 : n.signal }), (o = n == null ? void 0 : n.onRequestSent) === null || o === void 0 || o.call(n), this.pendingRequests.set(a.toString(), i);
      } catch (l) {
        s(l);
      }
    }));
  }
  closeConnection() {
    this.closeGateways(), this.listeners = [], this.session = null, this.gateway = null;
  }
  disconnect(e) {
    return Mt(this, void 0, void 0, function* () {
      return new Promise((r) => Mt(this, void 0, void 0, function* () {
        let n = !1, i = null;
        const s = () => {
          n || (n = !0, this.removeBridgeAndSession().then(r));
        };
        try {
          this.closeGateways();
          const o = _s(e == null ? void 0 : e.signal);
          i = setTimeout(() => {
            o.abort();
          }, this.defaultOpeningDeadlineMS), yield this.sendRequest({ method: "disconnect", params: [] }, {
            onRequestSent: s,
            signal: o.signal,
            attempts: 1
          });
        } catch (o) {
          Sn("Disconnect error:", o), n || this.removeBridgeAndSession().then(r);
        } finally {
          i && clearTimeout(i), s();
        }
      }));
    });
  }
  listen(e) {
    return this.listeners.push(e), () => this.listeners = this.listeners.filter((r) => r !== e);
  }
  pause() {
    var e;
    (e = this.gateway) === null || e === void 0 || e.pause(), this.pendingGateways.forEach((r) => r.pause());
  }
  unPause() {
    return Mt(this, void 0, void 0, function* () {
      const e = this.pendingGateways.map((r) => r.unPause());
      this.gateway && e.push(this.gateway.unPause()), yield Promise.all(e);
    });
  }
  pendingGatewaysListener(e, r, n) {
    return Mt(this, void 0, void 0, function* () {
      if (!this.pendingGateways.includes(e)) {
        yield e.close();
        return;
      }
      return this.closeGateways({ except: e }), this.gateway && (Sn("Gateway is already opened, closing previous gateway"), yield this.gateway.close()), this.session.bridgeUrl = r, this.gateway = e, this.gateway.setErrorsListener(this.gatewayErrorsListener.bind(this)), this.gateway.setListener(this.gatewayListener.bind(this)), this.gatewayListener(n);
    });
  }
  gatewayListener(e) {
    return Mt(this, void 0, void 0, function* () {
      const r = JSON.parse(this.session.sessionCrypto.decrypt(V9.decode(e.message).toUint8Array(), A0(e.from)));
      if (Sn("Wallet message received:", r), !("event" in r)) {
        const i = r.id.toString(), s = this.pendingRequests.get(i);
        if (!s) {
          Sn(`Response id ${i} doesn't match any request's id`);
          return;
        }
        s(r), this.pendingRequests.delete(i);
        return;
      }
      if (r.id !== void 0) {
        const i = yield this.connectionStorage.getLastWalletEventId();
        if (i !== void 0 && r.id <= i) {
          Lo(`Received event id (=${r.id}) must be greater than stored last wallet event id (=${i}) `);
          return;
        }
        r.event !== "connect" && (yield this.connectionStorage.storeLastWalletEventId(r.id));
      }
      const n = this.listeners;
      r.event === "connect" && (yield this.updateSession(r, e.from)), r.event === "disconnect" && (Sn("Removing bridge and session: received disconnect event"), yield this.removeBridgeAndSession()), n.forEach((i) => i(r));
    });
  }
  gatewayErrorsListener(e) {
    return Mt(this, void 0, void 0, function* () {
      throw new jt(`Bridge error ${JSON.stringify(e)}`);
    });
  }
  updateSession(e, r) {
    return Mt(this, void 0, void 0, function* () {
      this.session = Object.assign(Object.assign({}, this.session), { walletPublicKey: r });
      const n = e.payload.items.find((s) => s.name === "ton_addr"), i = Object.assign(Object.assign({}, e), { payload: Object.assign(Object.assign({}, e.payload), { items: [n] }) });
      yield this.connectionStorage.storeConnection({
        type: "http",
        session: this.session,
        lastWalletEventId: e.id,
        connectEvent: i,
        nextRpcRequestId: 0
      });
    });
  }
  removeBridgeAndSession() {
    return Mt(this, void 0, void 0, function* () {
      this.closeConnection(), yield this.connectionStorage.removeConnection();
    });
  }
  generateUniversalLink(e, r) {
    return Aie(e) ? this.generateTGUniversalLink(e, r) : this.generateRegularUniversalLink(e, r);
  }
  generateRegularUniversalLink(e, r) {
    const n = new URL(e);
    return n.searchParams.append("v", J9.toString()), n.searchParams.append("id", this.session.sessionCrypto.sessionId), n.searchParams.append("r", JSON.stringify(r)), n.toString();
  }
  generateTGUniversalLink(e, r) {
    const i = this.generateRegularUniversalLink("about:blank", r).split("?")[1], s = "tonconnect-" + Pie(i), o = this.convertToDirectLink(e), a = new URL(o);
    return a.searchParams.append("startapp", s), a.toString();
  }
  // TODO: Remove this method after all dApps and the wallets-list.json have been updated
  convertToDirectLink(e) {
    const r = new URL(e);
    return r.searchParams.has("attach") && (r.searchParams.delete("attach"), r.pathname += "/start"), r.toString();
  }
  openGateways(e, r) {
    return Mt(this, void 0, void 0, function* () {
      if (Array.isArray(this.walletConnectionSource)) {
        this.pendingGateways.map((n) => n.close().catch()), this.pendingGateways = this.walletConnectionSource.map((n) => {
          const i = new Vm(this.storage, n.bridgeUrl, e.sessionId, () => {
          }, () => {
          });
          return i.setListener((s) => this.pendingGatewaysListener(i, n.bridgeUrl, s)), i;
        }), yield Promise.allSettled(this.pendingGateways.map((n) => Zf((i) => {
          var s;
          return this.pendingGateways.some((o) => o === n) ? n.registerSession({
            openingDeadlineMS: (s = r == null ? void 0 : r.openingDeadlineMS) !== null && s !== void 0 ? s : this.defaultOpeningDeadlineMS,
            signal: i.signal
          }) : n.close();
        }, {
          attempts: Number.MAX_SAFE_INTEGER,
          delayMs: this.defaultRetryTimeoutMS,
          signal: r == null ? void 0 : r.signal
        })));
        return;
      } else
        return this.gateway && (Sn("Gateway is already opened, closing previous gateway"), yield this.gateway.close()), this.gateway = new Vm(this.storage, this.walletConnectionSource.bridgeUrl, e.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this)), yield this.gateway.registerSession({
          openingDeadlineMS: r == null ? void 0 : r.openingDeadlineMS,
          signal: r == null ? void 0 : r.signal
        });
    });
  }
  closeGateways(e) {
    var r;
    (r = this.gateway) === null || r === void 0 || r.close(), this.pendingGateways.filter((n) => n !== (e == null ? void 0 : e.except)).forEach((n) => n.close()), this.pendingGateways = [];
  }
}
function y5(t, e) {
  return X9(t, [e]);
}
function X9(t, e) {
  return !t || typeof t != "object" ? !1 : e.every((r) => r in t);
}
function Rie(t) {
  try {
    return !y5(t, "tonconnect") || !y5(t.tonconnect, "walletInfo") ? !1 : X9(t.tonconnect.walletInfo, [
      "name",
      "app_name",
      "image",
      "about_url",
      "platforms"
    ]);
  } catch {
    return !1;
  }
}
class ou {
  constructor() {
    this.storage = {};
  }
  static getInstance() {
    return ou.instance || (ou.instance = new ou()), ou.instance;
  }
  get length() {
    return Object.keys(this.storage).length;
  }
  clear() {
    this.storage = {};
  }
  getItem(e) {
    var r;
    return (r = this.storage[e]) !== null && r !== void 0 ? r : null;
  }
  key(e) {
    var r;
    const n = Object.keys(this.storage);
    return e < 0 || e >= n.length ? null : (r = n[e]) !== null && r !== void 0 ? r : null;
  }
  removeItem(e) {
    delete this.storage[e];
  }
  setItem(e, r) {
    this.storage[e] = r;
  }
}
function Tp() {
  if (!(typeof window > "u"))
    return window;
}
function Die() {
  const t = Tp();
  if (!t)
    return [];
  try {
    return Object.keys(t);
  } catch {
    return [];
  }
}
function Oie() {
  if (!(typeof document > "u"))
    return document;
}
function Nie() {
  var t;
  const e = (t = Tp()) === null || t === void 0 ? void 0 : t.location.origin;
  return e ? e + "/tonconnect-manifest.json" : "";
}
function Lie() {
  if (kie())
    return localStorage;
  if ($ie())
    throw new jt("`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector");
  return ou.getInstance();
}
function kie() {
  try {
    return typeof localStorage < "u";
  } catch {
    return !1;
  }
}
function $ie() {
  return typeof process < "u" && process.versions != null && process.versions.node != null;
}
class vi {
  constructor(e, r) {
    this.injectedWalletKey = r, this.type = "injected", this.unsubscribeCallback = null, this.listenSubscriptions = !1, this.listeners = [];
    const n = vi.window;
    if (!vi.isWindowContainsWallet(n, r))
      throw new dy();
    this.connectionStorage = new Ol(e), this.injectedWallet = n[r].tonconnect;
  }
  static fromStorage(e) {
    return Mt(this, void 0, void 0, function* () {
      const n = yield new Ol(e).getInjectedConnection();
      return new vi(e, n.jsBridgeKey);
    });
  }
  static isWalletInjected(e) {
    return vi.isWindowContainsWallet(this.window, e);
  }
  static isInsideWalletBrowser(e) {
    return vi.isWindowContainsWallet(this.window, e) ? this.window[e].tonconnect.isWalletBrowser : !1;
  }
  static getCurrentlyInjectedWallets() {
    return this.window ? Die().filter(([n, i]) => Rie(i)).map(([n, i]) => ({
      name: i.tonconnect.walletInfo.name,
      appName: i.tonconnect.walletInfo.app_name,
      aboutUrl: i.tonconnect.walletInfo.about_url,
      imageUrl: i.tonconnect.walletInfo.image,
      tondns: i.tonconnect.walletInfo.tondns,
      jsBridgeKey: n,
      injected: !0,
      embedded: i.tonconnect.isWalletBrowser,
      platforms: i.tonconnect.walletInfo.platforms
    })) : [];
  }
  static isWindowContainsWallet(e, r) {
    return !!e && r in e && typeof e[r] == "object" && "tonconnect" in e[r];
  }
  connect(e) {
    this._connect(J9, e);
  }
  restoreConnection() {
    return Mt(this, void 0, void 0, function* () {
      try {
        Sn("Injected Provider restoring connection...");
        const e = yield this.injectedWallet.restoreConnection();
        Sn("Injected Provider restoring connection response", e), e.event === "connect" ? (this.makeSubscriptions(), this.listeners.forEach((r) => r(e))) : yield this.connectionStorage.removeConnection();
      } catch (e) {
        yield this.connectionStorage.removeConnection(), console.error(e);
      }
    });
  }
  closeConnection() {
    this.listenSubscriptions && this.injectedWallet.disconnect(), this.closeAllListeners();
  }
  disconnect() {
    return Mt(this, void 0, void 0, function* () {
      return new Promise((e) => {
        const r = () => {
          this.closeAllListeners(), this.connectionStorage.removeConnection().then(e);
        };
        try {
          this.injectedWallet.disconnect(), r();
        } catch (n) {
          Sn(n), this.sendRequest({
            method: "disconnect",
            params: []
          }, r);
        }
      });
    });
  }
  closeAllListeners() {
    var e;
    this.listenSubscriptions = !1, this.listeners = [], (e = this.unsubscribeCallback) === null || e === void 0 || e.call(this);
  }
  listen(e) {
    return this.listeners.push(e), () => this.listeners = this.listeners.filter((r) => r !== e);
  }
  sendRequest(e, r) {
    var n;
    return Mt(this, void 0, void 0, function* () {
      const i = {};
      typeof r == "function" ? i.onRequestSent = r : (i.onRequestSent = r == null ? void 0 : r.onRequestSent, i.signal = r == null ? void 0 : r.signal);
      const s = (yield this.connectionStorage.getNextRpcRequestId()).toString();
      yield this.connectionStorage.increaseNextRpcRequestId(), Sn("Send injected-bridge request:", Object.assign(Object.assign({}, e), { id: s }));
      const o = this.injectedWallet.send(Object.assign(Object.assign({}, e), { id: s }));
      return o.then((a) => Sn("Wallet message received:", a)), (n = i == null ? void 0 : i.onRequestSent) === null || n === void 0 || n.call(i), o;
    });
  }
  _connect(e, r) {
    return Mt(this, void 0, void 0, function* () {
      try {
        Sn(`Injected Provider connect request: protocolVersion: ${e}, message:`, r);
        const n = yield this.injectedWallet.connect(e, r);
        Sn("Injected Provider connect response:", n), n.event === "connect" && (yield this.updateSession(), this.makeSubscriptions()), this.listeners.forEach((i) => i(n));
      } catch (n) {
        Sn("Injected Provider connect error:", n);
        const i = {
          event: "connect_error",
          payload: {
            code: 0,
            message: n == null ? void 0 : n.toString()
          }
        };
        this.listeners.forEach((s) => s(i));
      }
    });
  }
  makeSubscriptions() {
    this.listenSubscriptions = !0, this.unsubscribeCallback = this.injectedWallet.listen((e) => {
      Sn("Wallet message received:", e), this.listenSubscriptions && this.listeners.forEach((r) => r(e)), e.event === "disconnect" && this.disconnect();
    });
  }
  updateSession() {
    return this.connectionStorage.storeConnection({
      type: "injected",
      jsBridgeKey: this.injectedWalletKey,
      nextRpcRequestId: 0
    });
  }
}
vi.window = Tp();
class Bie {
  constructor() {
    this.localStorage = Lie();
  }
  getItem(e) {
    return Mt(this, void 0, void 0, function* () {
      return this.localStorage.getItem(e);
    });
  }
  removeItem(e) {
    return Mt(this, void 0, void 0, function* () {
      this.localStorage.removeItem(e);
    });
  }
  setItem(e, r) {
    return Mt(this, void 0, void 0, function* () {
      this.localStorage.setItem(e, r);
    });
  }
}
function Z9(t) {
  return jie(t) && t.injected;
}
function Fie(t) {
  return Z9(t) && t.embedded;
}
function jie(t) {
  return "jsBridgeKey" in t;
}
const Uie = [
  {
    app_name: "telegram-wallet",
    name: "Wallet",
    image: "https://wallet.tg/images/logo-288.png",
    about_url: "https://wallet.tg/",
    universal_url: "https://t.me/wallet?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://bridge.ton.space/bridge"
      }
    ],
    platforms: ["ios", "android", "macos", "windows", "linux"]
  },
  {
    app_name: "tonkeeper",
    name: "Tonkeeper",
    image: "https://tonkeeper.com/assets/tonconnect-icon.png",
    tondns: "tonkeeper.ton",
    about_url: "https://tonkeeper.com",
    universal_url: "https://app.tonkeeper.com/ton-connect",
    deepLink: "tonkeeper-tc://",
    bridge: [
      {
        type: "sse",
        url: "https://bridge.tonapi.io/bridge"
      },
      {
        type: "js",
        key: "tonkeeper"
      }
    ],
    platforms: ["ios", "android", "chrome", "firefox", "macos"]
  },
  {
    app_name: "mytonwallet",
    name: "MyTonWallet",
    image: "https://static.mytonwallet.io/icon-256.png",
    about_url: "https://mytonwallet.io",
    universal_url: "https://connect.mytonwallet.org",
    bridge: [
      {
        type: "js",
        key: "mytonwallet"
      },
      {
        type: "sse",
        url: "https://tonconnectbridge.mytonwallet.org/bridge/"
      }
    ],
    platforms: ["chrome", "windows", "macos", "linux", "ios", "android", "firefox"]
  },
  {
    app_name: "openmask",
    name: "OpenMask",
    image: "https://raw.githubusercontent.com/OpenProduct/openmask-extension/main/public/openmask-logo-288.png",
    about_url: "https://www.openmask.app/",
    bridge: [
      {
        type: "js",
        key: "openmask"
      }
    ],
    platforms: ["chrome"]
  },
  {
    app_name: "tonhub",
    name: "Tonhub",
    image: "https://tonhub.com/tonconnect_logo.png",
    about_url: "https://tonhub.com",
    universal_url: "https://tonhub.com/ton-connect",
    bridge: [
      {
        type: "js",
        key: "tonhub"
      },
      {
        type: "sse",
        url: "https://connect.tonhubapi.com/tonconnect"
      }
    ],
    platforms: ["ios", "android"]
  },
  {
    app_name: "dewallet",
    name: "DeWallet",
    image: "https://raw.githubusercontent.com/delab-team/manifests-images/main/WalletAvatar.png",
    about_url: "https://delabwallet.com",
    universal_url: "https://t.me/dewallet?attach=wallet",
    bridge: [
      {
        type: "sse",
        url: "https://sse-bridge.delab.team/bridge"
      }
    ],
    platforms: ["ios", "android"]
  },
  {
    app_name: "xtonwallet",
    name: "XTONWallet",
    image: "https://xtonwallet.com/assets/img/icon-256-back.png",
    about_url: "https://xtonwallet.com",
    bridge: [
      {
        type: "js",
        key: "xtonwallet"
      }
    ],
    platforms: ["chrome", "firefox"]
  },
  {
    app_name: "tonwallet",
    name: "TON Wallet",
    image: "https://wallet.ton.org/assets/ui/qr-logo.png",
    about_url: "https://chrome.google.com/webstore/detail/ton-wallet/nphplpgoakhhjchkkhmiggakijnkhfnd",
    bridge: [
      {
        type: "js",
        key: "tonwallet"
      }
    ],
    platforms: ["chrome"]
  },
  {
    app_name: "bitgetTonWallet",
    name: "Bitget Wallet",
    image: "https://raw.githubusercontent.com/bitkeepwallet/download/main/logo/png/bitget_wallet_logo_0_gas_fee.png",
    about_url: "https://web3.bitget.com",
    deepLink: "bitkeep://",
    bridge: [
      {
        type: "js",
        key: "bitgetTonWallet"
      },
      {
        type: "sse",
        url: "https://bridge.tonapi.io/bridge"
      }
    ],
    platforms: ["ios", "android", "chrome"],
    universal_url: "https://bkcode.vip/ton-connect"
  },
  {
    app_name: "safepalwallet",
    name: "SafePal",
    image: "https://s.pvcliping.com/web/public_image/SafePal_x288.png",
    tondns: "",
    about_url: "https://www.safepal.com",
    universal_url: "https://link.safepal.io/ton-connect",
    deepLink: "safepal-tc://",
    bridge: [
      {
        type: "sse",
        url: "https://ton-bridge.safepal.com/tonbridge/v1/bridge"
      },
      {
        type: "js",
        key: "safepalwallet"
      }
    ],
    platforms: ["ios", "android", "chrome", "firefox"]
  },
  {
    app_name: "okxTonWallet",
    name: "OKX Wallet",
    image: "https://static.okx.com/cdn/assets/imgs/247/58E63FEA47A2B7D7.png",
    about_url: "https://www.okx.com/web3",
    universal_url: "https://www.okx.com/download?appendQuery=true&deeplink=okx://web3/wallet/tonconnect",
    bridge: [
      {
        type: "js",
        key: "okxTonWallet"
      },
      {
        type: "sse",
        url: "https://www.okx.com/tonbridge/discover/rpc/bridge"
      }
    ],
    platforms: ["chrome", "safari", "firefox", "ios", "android"]
  },
  {
    app_name: "okxTonWalletTr",
    name: "OKX TR Wallet",
    image: "https://static.okx.com/cdn/assets/imgs/247/587A8296F0BB640F.png",
    about_url: "https://tr.okx.com/web3",
    universal_url: "https://tr.okx.com/download?appendQuery=true&deeplink=okxtr://web3/wallet/tonconnect",
    bridge: [
      {
        type: "js",
        key: "okxTonWallet"
      },
      {
        type: "sse",
        url: "https://www.okx.com/tonbridge/discover/rpc/bridge"
      }
    ],
    platforms: ["chrome", "safari", "firefox", "ios", "android"]
  }
];
class dv {
  constructor(e) {
    this.walletsListCache = null, this.walletsListCacheCreationTimestamp = null, this.walletsListSource = "https://raw.githubusercontent.com/ton-blockchain/wallets-list/main/wallets-v2.json", e != null && e.walletsListSource && (this.walletsListSource = e.walletsListSource), e != null && e.cacheTTLMs && (this.cacheTTLMs = e.cacheTTLMs);
  }
  getWallets() {
    return Mt(this, void 0, void 0, function* () {
      return this.cacheTTLMs && this.walletsListCacheCreationTimestamp && Date.now() > this.walletsListCacheCreationTimestamp + this.cacheTTLMs && (this.walletsListCache = null), this.walletsListCache || (this.walletsListCache = this.fetchWalletsList(), this.walletsListCache.then(() => {
        this.walletsListCacheCreationTimestamp = Date.now();
      }).catch(() => {
        this.walletsListCache = null, this.walletsListCacheCreationTimestamp = null;
      })), this.walletsListCache;
    });
  }
  getEmbeddedWallet() {
    return Mt(this, void 0, void 0, function* () {
      const r = (yield this.getWallets()).filter(Fie);
      return r.length !== 1 ? null : r[0];
    });
  }
  fetchWalletsList() {
    return Mt(this, void 0, void 0, function* () {
      let e = [];
      try {
        if (e = yield (yield fetch(this.walletsListSource)).json(), !Array.isArray(e))
          throw new py("Wrong wallets list format, wallets list must be an array.");
        const i = e.filter((s) => !this.isCorrectWalletConfigDTO(s));
        i.length && (Lo(`Wallet(s) ${i.map((s) => s.name).join(", ")} config format is wrong. They were removed from the wallets list.`), e = e.filter((s) => this.isCorrectWalletConfigDTO(s)));
      } catch (n) {
        Lo(n), e = Uie;
      }
      let r = [];
      try {
        r = vi.getCurrentlyInjectedWallets();
      } catch (n) {
        Lo(n);
      }
      return this.mergeWalletsLists(this.walletConfigDTOListToWalletConfigList(e), r);
    });
  }
  walletConfigDTOListToWalletConfigList(e) {
    return e.map((r) => {
      const i = {
        name: r.name,
        appName: r.app_name,
        imageUrl: r.image,
        aboutUrl: r.about_url,
        tondns: r.tondns,
        platforms: r.platforms
      };
      return r.bridge.forEach((s) => {
        if (s.type === "sse" && (i.bridgeUrl = s.url, i.universalLink = r.universal_url, i.deepLink = r.deepLink), s.type === "js") {
          const o = s.key;
          i.jsBridgeKey = o, i.injected = vi.isWalletInjected(o), i.embedded = vi.isInsideWalletBrowser(o);
        }
      }), i;
    });
  }
  mergeWalletsLists(e, r) {
    return [...new Set(e.concat(r).map((i) => i.name)).values()].map((i) => {
      const s = e.find((a) => a.name === i), o = r.find((a) => a.name === i);
      return Object.assign(Object.assign({}, s && Object.assign({}, s)), o && Object.assign({}, o));
    });
  }
  // eslint-disable-next-line complexity
  isCorrectWalletConfigDTO(e) {
    if (!e || typeof e != "object")
      return !1;
    const r = "name" in e, n = "app_name" in e, i = "image" in e, s = "about_url" in e, o = "platforms" in e;
    if (!r || !i || !s || !o || !n || !e.platforms || !Array.isArray(e.platforms) || !e.platforms.length || !("bridge" in e) || !Array.isArray(e.bridge) || !e.bridge.length)
      return !1;
    const a = e.bridge;
    if (a.some((d) => !d || typeof d != "object" || !("type" in d)))
      return !1;
    const u = a.find((d) => d.type === "sse");
    if (u && (!("url" in u) || !u.url || !e.universal_url))
      return !1;
    const l = a.find((d) => d.type === "js");
    return !(l && (!("key" in l) || !l.key));
  }
}
class M0 extends jt {
  get info() {
    return "Wallet doesn't support requested feature method.";
  }
  constructor(...e) {
    super(...e), Object.setPrototypeOf(this, M0.prototype);
  }
}
function qie(t, e) {
  const r = t.includes("SendTransaction"), n = t.find((i) => i && typeof i == "object" && i.name === "SendTransaction");
  if (!r && !n)
    throw new M0("Wallet doesn't support SendTransaction feature.");
  if (n && n.maxMessages !== void 0) {
    if (n.maxMessages < e.requiredMessagesNumber)
      throw new M0(`Wallet is not able to handle such SendTransaction request. Max support messages number is ${n.maxMessages}, but ${e.requiredMessagesNumber} is required.`);
    return;
  }
  Mie("Connected wallet didn't provide information about max allowed messages in the SendTransaction request. Request may be rejected by the wallet.");
}
function zie() {
  return {
    type: "request-version"
  };
}
function Wie(t) {
  return {
    type: "response-version",
    version: t
  };
}
function Yu(t) {
  return {
    ton_connect_sdk_lib: t.ton_connect_sdk_lib,
    ton_connect_ui_lib: t.ton_connect_ui_lib
  };
}
function Ju(t, e) {
  var r, n, i, s, o, a, u, l;
  const p = ((r = e == null ? void 0 : e.connectItems) === null || r === void 0 ? void 0 : r.tonProof) && "proof" in e.connectItems.tonProof ? "ton_proof" : "ton_addr";
  return {
    wallet_address: (i = (n = e == null ? void 0 : e.account) === null || n === void 0 ? void 0 : n.address) !== null && i !== void 0 ? i : null,
    wallet_type: (s = e == null ? void 0 : e.device.appName) !== null && s !== void 0 ? s : null,
    wallet_version: (o = e == null ? void 0 : e.device.appVersion) !== null && o !== void 0 ? o : null,
    auth_type: p,
    custom_data: Object.assign({ chain_id: (u = (a = e == null ? void 0 : e.account) === null || a === void 0 ? void 0 : a.chain) !== null && u !== void 0 ? u : null, provider: (l = e == null ? void 0 : e.provider) !== null && l !== void 0 ? l : null }, Yu(t))
  };
}
function Hie(t) {
  return {
    type: "connection-started",
    custom_data: Yu(t)
  };
}
function Kie(t, e) {
  return Object.assign({ type: "connection-completed", is_success: !0 }, Ju(t, e));
}
function Vie(t, e, r) {
  return {
    type: "connection-error",
    is_success: !1,
    error_message: e,
    error_code: r ?? null,
    custom_data: Yu(t)
  };
}
function Gie(t) {
  return {
    type: "connection-restoring-started",
    custom_data: Yu(t)
  };
}
function Yie(t, e) {
  return Object.assign({ type: "connection-restoring-completed", is_success: !0 }, Ju(t, e));
}
function Jie(t, e) {
  return {
    type: "connection-restoring-error",
    is_success: !1,
    error_message: e,
    custom_data: Yu(t)
  };
}
function gy(t, e) {
  var r, n, i, s;
  return {
    valid_until: (r = String(e.validUntil)) !== null && r !== void 0 ? r : null,
    from: (s = (n = e.from) !== null && n !== void 0 ? n : (i = t == null ? void 0 : t.account) === null || i === void 0 ? void 0 : i.address) !== null && s !== void 0 ? s : null,
    messages: e.messages.map((o) => {
      var a, u;
      return {
        address: (a = o.address) !== null && a !== void 0 ? a : null,
        amount: (u = o.amount) !== null && u !== void 0 ? u : null
      };
    })
  };
}
function Xie(t, e, r) {
  return Object.assign(Object.assign({ type: "transaction-sent-for-signature" }, Ju(t, e)), gy(e, r));
}
function Zie(t, e, r, n) {
  return Object.assign(Object.assign({ type: "transaction-signed", is_success: !0, signed_transaction: n.boc }, Ju(t, e)), gy(e, r));
}
function Qie(t, e, r, n, i) {
  return Object.assign(Object.assign({ type: "transaction-signing-failed", is_success: !1, error_message: n, error_code: i ?? null }, Ju(t, e)), gy(e, r));
}
function ese(t, e, r) {
  return Object.assign({ type: "disconnection", scope: r }, Ju(t, e));
}
class tse {
  constructor() {
    this.window = Tp();
  }
  /**
   * Dispatches an event with the given name and details to the browser window.
   * @param eventName - The name of the event to dispatch.
   * @param eventDetails - The details of the event to dispatch.
   * @returns A promise that resolves when the event has been dispatched.
   */
  dispatchEvent(e, r) {
    var n;
    return Mt(this, void 0, void 0, function* () {
      const i = new CustomEvent(e, { detail: r });
      (n = this.window) === null || n === void 0 || n.dispatchEvent(i);
    });
  }
  /**
   * Adds an event listener to the browser window.
   * @param eventName - The name of the event to listen for.
   * @param listener - The listener to add.
   * @param options - The options for the listener.
   * @returns A function that removes the listener.
   */
  addEventListener(e, r, n) {
    var i;
    return Mt(this, void 0, void 0, function* () {
      return (i = this.window) === null || i === void 0 || i.addEventListener(e, r, n), () => {
        var s;
        return (s = this.window) === null || s === void 0 ? void 0 : s.removeEventListener(e, r);
      };
    });
  }
}
class rse {
  constructor(e) {
    var r;
    this.eventPrefix = "ton-connect-", this.tonConnectUiVersion = null, this.eventDispatcher = (r = e == null ? void 0 : e.eventDispatcher) !== null && r !== void 0 ? r : new tse(), this.tonConnectSdkVersion = e.tonConnectSdkVersion, this.init().catch();
  }
  /**
   * Version of the library.
   */
  get version() {
    return Yu({
      ton_connect_sdk_lib: this.tonConnectSdkVersion,
      ton_connect_ui_lib: this.tonConnectUiVersion
    });
  }
  /**
   * Called once when the tracker is created and request version other libraries.
   */
  init() {
    return Mt(this, void 0, void 0, function* () {
      try {
        yield this.setRequestVersionHandler(), this.tonConnectUiVersion = yield this.requestTonConnectUiVersion();
      } catch {
      }
    });
  }
  /**
   * Set request version handler.
   * @private
   */
  setRequestVersionHandler() {
    return Mt(this, void 0, void 0, function* () {
      yield this.eventDispatcher.addEventListener("ton-connect-request-version", () => Mt(this, void 0, void 0, function* () {
        yield this.eventDispatcher.dispatchEvent("ton-connect-response-version", Wie(this.tonConnectSdkVersion));
      }));
    });
  }
  /**
   * Request TonConnect UI version.
   * @private
   */
  requestTonConnectUiVersion() {
    return Mt(this, void 0, void 0, function* () {
      return new Promise((e, r) => Mt(this, void 0, void 0, function* () {
        try {
          yield this.eventDispatcher.addEventListener("ton-connect-ui-response-version", (n) => {
            e(n.detail.version);
          }, { once: !0 }), yield this.eventDispatcher.dispatchEvent("ton-connect-ui-request-version", zie());
        } catch (n) {
          r(n);
        }
      }));
    });
  }
  /**
   * Emit user action event to the window.
   * @param eventDetails
   * @private
   */
  dispatchUserActionEvent(e) {
    try {
      this.eventDispatcher.dispatchEvent(`${this.eventPrefix}${e.type}`, e).catch();
    } catch {
    }
  }
  /**
   * Track connection init event.
   * @param args
   */
  trackConnectionStarted(...e) {
    try {
      const r = Hie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection success event.
   * @param args
   */
  trackConnectionCompleted(...e) {
    try {
      const r = Kie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection error event.
   * @param args
   */
  trackConnectionError(...e) {
    try {
      const r = Vie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection restoring init event.
   * @param args
   */
  trackConnectionRestoringStarted(...e) {
    try {
      const r = Gie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection restoring success event.
   * @param args
   */
  trackConnectionRestoringCompleted(...e) {
    try {
      const r = Yie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track connection restoring error event.
   * @param args
   */
  trackConnectionRestoringError(...e) {
    try {
      const r = Jie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track disconnect event.
   * @param args
   */
  trackDisconnection(...e) {
    try {
      const r = ese(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track transaction init event.
   * @param args
   */
  trackTransactionSentForSignature(...e) {
    try {
      const r = Xie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track transaction signed event.
   * @param args
   */
  trackTransactionSigned(...e) {
    try {
      const r = Zie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
  /**
   * Track transaction error event.
   * @param args
   */
  trackTransactionSigningFailed(...e) {
    try {
      const r = Qie(this.version, ...e);
      this.dispatchUserActionEvent(r);
    } catch {
    }
  }
}
const nse = "3.0.5";
class fh {
  constructor(e) {
    if (this.walletsList = new dv(), this._wallet = null, this.provider = null, this.statusChangeSubscriptions = [], this.statusChangeErrorSubscriptions = [], this.dappSettings = {
      manifestUrl: (e == null ? void 0 : e.manifestUrl) || Nie(),
      storage: (e == null ? void 0 : e.storage) || new Bie()
    }, this.walletsList = new dv({
      walletsListSource: e == null ? void 0 : e.walletsListSource,
      cacheTTLMs: e == null ? void 0 : e.walletsListCacheTTLMs
    }), this.tracker = new rse({
      eventDispatcher: e == null ? void 0 : e.eventDispatcher,
      tonConnectSdkVersion: nse
    }), !this.dappSettings.manifestUrl)
      throw new ly("Dapp tonconnect-manifest.json must be specified if window.location.origin is undefined. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest");
    this.bridgeConnectionStorage = new Ol(this.dappSettings.storage), e != null && e.disableAutoPauseConnection || this.addWindowFocusAndBlurSubscriptions();
  }
  /**
   * Returns available wallets list.
   */
  static getWallets() {
    return this.walletsList.getWallets();
  }
  /**
   * Shows if the wallet is connected right now.
   */
  get connected() {
    return this._wallet !== null;
  }
  /**
   * Current connected account or null if no account is connected.
   */
  get account() {
    var e;
    return ((e = this._wallet) === null || e === void 0 ? void 0 : e.account) || null;
  }
  /**
   * Current connected wallet or null if no account is connected.
   */
  get wallet() {
    return this._wallet;
  }
  set wallet(e) {
    this._wallet = e, this.statusChangeSubscriptions.forEach((r) => r(this._wallet));
  }
  /**
   * Returns available wallets list.
   */
  getWallets() {
    return this.walletsList.getWallets();
  }
  /**
   * Allows to subscribe to connection status changes and handle connection errors.
   * @param callback will be called after connections status changes with actual wallet or null.
   * @param errorsHandler (optional) will be called with some instance of TonConnectError when connect error is received.
   * @returns unsubscribe callback.
   */
  onStatusChange(e, r) {
    return this.statusChangeSubscriptions.push(e), r && this.statusChangeErrorSubscriptions.push(r), () => {
      this.statusChangeSubscriptions = this.statusChangeSubscriptions.filter((n) => n !== e), r && (this.statusChangeErrorSubscriptions = this.statusChangeErrorSubscriptions.filter((n) => n !== r));
    };
  }
  connect(e, r) {
    var n, i;
    const s = {};
    if (typeof r == "object" && "tonProof" in r && (s.request = r), typeof r == "object" && ("openingDeadlineMS" in r || "signal" in r || "request" in r) && (s.request = r == null ? void 0 : r.request, s.openingDeadlineMS = r == null ? void 0 : r.openingDeadlineMS, s.signal = r == null ? void 0 : r.signal), this.connected)
      throw new hy();
    const o = _s(s == null ? void 0 : s.signal);
    if ((n = this.abortController) === null || n === void 0 || n.abort(), this.abortController = o, o.signal.aborted)
      throw new jt("Connection was aborted");
    return (i = this.provider) === null || i === void 0 || i.closeConnection(), this.provider = this.createProvider(e), o.signal.addEventListener("abort", () => {
      var a;
      (a = this.provider) === null || a === void 0 || a.closeConnection(), this.provider = null;
    }), this.tracker.trackConnectionStarted(), this.provider.connect(this.createConnectRequest(s == null ? void 0 : s.request), {
      openingDeadlineMS: s == null ? void 0 : s.openingDeadlineMS,
      signal: o.signal
    });
  }
  /**
   * Try to restore existing session and reconnect to the corresponding wallet. Call it immediately when your app is loaded.
   */
  restoreConnection(e) {
    var r, n;
    return Mt(this, void 0, void 0, function* () {
      this.tracker.trackConnectionRestoringStarted();
      const i = _s(e == null ? void 0 : e.signal);
      if ((r = this.abortController) === null || r === void 0 || r.abort(), this.abortController = i, i.signal.aborted) {
        this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
        return;
      }
      const [s, o] = yield Promise.all([
        this.bridgeConnectionStorage.storedConnectionType(),
        this.walletsList.getEmbeddedWallet()
      ]);
      if (i.signal.aborted) {
        this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
        return;
      }
      let a = null;
      try {
        switch (s) {
          case "http":
            a = yield Nl.fromStorage(this.dappSettings.storage);
            break;
          case "injected":
            a = yield vi.fromStorage(this.dappSettings.storage);
            break;
          default:
            if (o)
              a = this.createProvider(o);
            else
              return;
        }
      } catch {
        this.tracker.trackConnectionRestoringError("Provider is not restored"), yield this.bridgeConnectionStorage.removeConnection(), a == null || a.closeConnection(), a = null;
        return;
      }
      if (i.signal.aborted) {
        a == null || a.closeConnection(), this.tracker.trackConnectionRestoringError("Connection restoring was aborted");
        return;
      }
      if (!a) {
        Lo("Provider is not restored"), this.tracker.trackConnectionRestoringError("Provider is not restored");
        return;
      }
      (n = this.provider) === null || n === void 0 || n.closeConnection(), this.provider = a, a.listen(this.walletEventsListener.bind(this));
      const u = () => {
        this.tracker.trackConnectionRestoringError("Connection restoring was aborted"), a == null || a.closeConnection(), a = null;
      };
      i.signal.addEventListener("abort", u);
      const l = Zf((p) => Mt(this, void 0, void 0, function* () {
        yield a == null ? void 0 : a.restoreConnection({
          openingDeadlineMS: e == null ? void 0 : e.openingDeadlineMS,
          signal: p.signal
        }), i.signal.removeEventListener("abort", u), this.connected ? this.tracker.trackConnectionRestoringCompleted(this.wallet) : this.tracker.trackConnectionRestoringError("Connection restoring failed");
      }), {
        attempts: Number.MAX_SAFE_INTEGER,
        delayMs: 2e3,
        signal: e == null ? void 0 : e.signal
      }), d = new Promise(
        (p) => setTimeout(() => p(), 12e3)
        // connection deadline
      );
      return Promise.race([l, d]);
    });
  }
  sendTransaction(e, r) {
    return Mt(this, void 0, void 0, function* () {
      const n = {};
      typeof r == "function" ? n.onRequestSent = r : (n.onRequestSent = r == null ? void 0 : r.onRequestSent, n.signal = r == null ? void 0 : r.signal);
      const i = _s(n == null ? void 0 : n.signal);
      if (i.signal.aborted)
        throw new jt("Transaction sending was aborted");
      this.checkConnection(), qie(this.wallet.device.features, {
        requiredMessagesNumber: e.messages.length
      }), this.tracker.trackTransactionSentForSignature(this.wallet, e);
      const { validUntil: s } = e, o = vie(e, ["validUntil"]), a = e.from || this.account.address, u = e.network || this.account.chain, l = yield this.provider.sendRequest(wd.convertToRpcRequest(Object.assign(Object.assign({}, o), {
        valid_until: s,
        from: a,
        network: u
      })), { onRequestSent: n.onRequestSent, signal: i.signal });
      if (wd.isError(l))
        return this.tracker.trackTransactionSigningFailed(this.wallet, e, l.error.message, l.error.code), wd.parseAndThrowError(l);
      const d = wd.convertFromRpcResponse(l);
      return this.tracker.trackTransactionSigned(this.wallet, e, d), d;
    });
  }
  /**
   * Disconnect form thw connected wallet and drop current session.
   */
  disconnect(e) {
    var r;
    return Mt(this, void 0, void 0, function* () {
      if (!this.connected)
        throw new P0();
      const n = _s(e == null ? void 0 : e.signal), i = this.abortController;
      if (this.abortController = n, n.signal.aborted)
        throw new jt("Disconnect was aborted");
      this.onWalletDisconnected("dapp"), yield (r = this.provider) === null || r === void 0 ? void 0 : r.disconnect({
        signal: n.signal
      }), i == null || i.abort();
    });
  }
  /**
   * Pause bridge HTTP connection. Might be helpful, if you want to pause connections while browser tab is unfocused,
   * or if you use SDK with NodeJS and want to save server resources.
   */
  pauseConnection() {
    var e;
    ((e = this.provider) === null || e === void 0 ? void 0 : e.type) === "http" && this.provider.pause();
  }
  /**
   * Unpause bridge HTTP connection if it is paused.
   */
  unPauseConnection() {
    var e;
    return ((e = this.provider) === null || e === void 0 ? void 0 : e.type) !== "http" ? Promise.resolve() : this.provider.unPause();
  }
  addWindowFocusAndBlurSubscriptions() {
    const e = Oie();
    if (e)
      try {
        e.addEventListener("visibilitychange", () => {
          e.hidden ? this.pauseConnection() : this.unPauseConnection().catch();
        });
      } catch (r) {
        Lo("Cannot subscribe to the document.visibilitychange: ", r);
      }
  }
  createProvider(e) {
    let r;
    return !Array.isArray(e) && bie(e) ? r = new vi(this.dappSettings.storage, e.jsBridgeKey) : r = new Nl(this.dappSettings.storage, e), r.listen(this.walletEventsListener.bind(this)), r;
  }
  walletEventsListener(e) {
    switch (e.event) {
      case "connect":
        this.onWalletConnected(e.payload);
        break;
      case "connect_error":
        this.onWalletConnectError(e.payload);
        break;
      case "disconnect":
        this.onWalletDisconnected("wallet");
    }
  }
  onWalletConnected(e) {
    const r = e.items.find((s) => s.name === "ton_addr"), n = e.items.find((s) => s.name === "ton_proof");
    if (!r)
      throw new jt("ton_addr connection item was not found");
    const i = {
      device: e.device,
      provider: this.provider.type,
      account: {
        address: r.address,
        chain: r.network,
        walletStateInit: r.walletStateInit,
        publicKey: r.publicKey
      }
    };
    n && (i.connectItems = {
      tonProof: n
    }), this.wallet = i, this.tracker.trackConnectionCompleted(i);
  }
  onWalletConnectError(e) {
    const r = wie.parseError(e);
    if (this.statusChangeErrorSubscriptions.forEach((n) => n(r)), Sn(r), this.tracker.trackConnectionError(e.message, e.code), r instanceof Pp || r instanceof Ap)
      throw Lo(r), r;
  }
  onWalletDisconnected(e) {
    this.tracker.trackDisconnection(this.wallet, e), this.wallet = null;
  }
  checkConnection() {
    if (!this.connected)
      throw new P0();
  }
  createConnectRequest(e) {
    const r = [
      {
        name: "ton_addr"
      }
    ];
    return e != null && e.tonProof && r.push({
      name: "ton_proof",
      payload: e.tonProof
    }), {
      manifestUrl: this.dappSettings.manifestUrl,
      items: r
    };
  }
}
fh.walletsList = new dv();
fh.isWalletInjected = (t) => vi.isWalletInjected(t);
fh.isInsideWalletBrowser = (t) => vi.isInsideWalletBrowser(t);
for (let t = 0; t <= 255; t++) {
  let e = t.toString(16);
  e.length < 2 && (e = "0" + e);
}
function Gm(t) {
  const { children: e, onClick: r } = t;
  return /* @__PURE__ */ fe.jsx("button", { onClick: r, className: "xc-border xc-px-4 xc-py-2 xc-rounded-full xc-text-sm xc-flex xc-gap-2 xc-items-center", children: e });
}
function Q9(t) {
  const { wallet: e, connector: r, loading: n } = t, i = oi(null), s = oi(), [o, a] = Gt(), [u, l] = Gt(), [d, p] = Gt("connect"), [w, A] = Gt(!1), [P, N] = Gt();
  function L(K) {
    var ge;
    (ge = s.current) == null || ge.update({
      data: K
    });
  }
  async function $() {
    A(!0);
    try {
      a("");
      const K = await qo.getNonce({ account_type: "block_chain" });
      if ("universalLink" in e && e.universalLink) {
        const ge = r.connect({
          universalLink: e.universalLink,
          bridgeUrl: e.bridgeUrl
        }, {
          request: { tonProof: K }
        });
        if (!ge) return;
        N(ge), L(ge), l(K);
      }
    } catch (K) {
      a(K.message);
    }
    A(!1);
  }
  function B() {
    s.current = new B9({
      width: 264,
      height: 264,
      margin: 0,
      type: "svg",
      qrOptions: {
        errorCorrectionLevel: "M"
      },
      dotsOptions: {
        color: "black",
        type: "rounded"
      },
      backgroundOptions: {
        color: "transparent"
      }
    }), s.current.append(i.current);
  }
  function H() {
    r.connect(e, {
      request: { tonProof: u }
    });
  }
  function W() {
    if ("deepLink" in e) {
      if (!e.deepLink || !P) return;
      const K = new URL(P), ge = `${e.deepLink}${K.search}`;
      window.open(ge);
    }
  }
  function V() {
    "universalLink" in e && e.universalLink && /t.me/.test(e.universalLink) && window.open(P);
  }
  const te = Ni(() => !!("deepLink" in e && e.deepLink), [e]), R = Ni(() => !!("universalLink" in e && e.universalLink && /t.me/.test(e.universalLink)), [e]);
  return Dn(() => {
    B(), $();
  }, []), /* @__PURE__ */ fe.jsxs(so, { children: [
    /* @__PURE__ */ fe.jsx("div", { className: "xc-mb-6", children: /* @__PURE__ */ fe.jsx(Pc, { title: "Connect wallet", onBack: t.onBack }) }),
    /* @__PURE__ */ fe.jsxs("div", { className: "xc-text-center xc-mb-6", children: [
      /* @__PURE__ */ fe.jsxs("div", { className: "xc-relative xc-mx-auto xc-mb-6 xc-block xc-max-h-[272px] xc-max-w-[272px] xc-rounded-xl xc-bg-white xc-p-1", children: [
        /* @__PURE__ */ fe.jsx("div", { className: "xc-aspect-[1/1] xc-flex xc-h-full xc-w-full xc-justify-center", ref: i }),
        /* @__PURE__ */ fe.jsx("div", { className: "xc-absolute xc-left-0 xc-top-0 xc-flex xc-h-full xc-w-full xc-items-center xc-justify-center", children: w ? /* @__PURE__ */ fe.jsx(_a, { className: "xc-h-6 xc-w-6 xc-animate-spin xc-text-black", size: 20 }) : /* @__PURE__ */ fe.jsx("img", { className: "xc-h-10 xc-w-10 xc-rounded-md", src: e.imageUrl }) })
      ] }),
      /* @__PURE__ */ fe.jsx("p", { className: "xc-text-center", children: "Scan the QR code below with your phone's camera. " })
    ] }),
    /* @__PURE__ */ fe.jsxs("div", { className: "xc-flex xc-justify-center xc-gap-2", children: [
      n && /* @__PURE__ */ fe.jsx(_a, { className: "xc-animate-spin" }),
      !w && !n && /* @__PURE__ */ fe.jsxs(fe.Fragment, { children: [
        Z9(e) && /* @__PURE__ */ fe.jsxs(Gm, { onClick: H, children: [
          /* @__PURE__ */ fe.jsx(pZ, { className: "xc-opacity-80" }),
          "Extension"
        ] }),
        te && /* @__PURE__ */ fe.jsxs(Gm, { onClick: W, children: [
          /* @__PURE__ */ fe.jsx(KS, { className: "xc-opacity-80" }),
          "Desktop"
        ] }),
        R && /* @__PURE__ */ fe.jsx(Gm, { onClick: V, children: "Telegram Mini App" })
      ] })
    ] })
  ] });
}
function ise(t) {
  const [e, r] = Gt(""), [n, i] = Gt(), [s, o] = Gt(), a = fy(), [u, l] = Gt(!1);
  async function d(w) {
    var P, N;
    if (!w || !((P = w.connectItems) != null && P.tonProof)) return;
    l(!0);
    const A = await qo.tonLogin({
      account_type: "block_chain",
      connector: "codatta_ton",
      account_enum: "C",
      wallet_name: w == null ? void 0 : w.device.appName,
      inviter_code: a.inviterCode,
      address: w.account.address,
      chain: w.account.chain,
      connect_info: [
        { name: "ton_addr", network: w.account.chain, ...w.account },
        (N = w.connectItems) == null ? void 0 : N.tonProof
      ],
      source: {
        device: a.device,
        channel: a.channel,
        app: a.app
      }
    });
    await t.onLogin(A.data), l(!1);
  }
  Dn(() => {
    const w = new fh({
      manifestUrl: "https://static.codatta.io/static/tonconnect-manifest.json?v=2"
    }), A = w.onStatusChange(d);
    return o(w), r("select"), A;
  }, []);
  function p(w) {
    r("connect"), i(w);
  }
  return /* @__PURE__ */ fe.jsxs(so, { children: [
    e === "select" && /* @__PURE__ */ fe.jsx(
      W9,
      {
        connector: s,
        onSelect: p,
        onBack: t.onBack
      }
    ),
    e === "connect" && /* @__PURE__ */ fe.jsx(
      Q9,
      {
        connector: s,
        wallet: n,
        onBack: t.onBack,
        loading: u
      }
    )
  ] });
}
function eA(t) {
  const { children: e, className: r } = t, n = oi(null), [i, s] = pv.useState(0);
  function o() {
    var a;
    try {
      const u = ((a = n.current) == null ? void 0 : a.children) || [];
      let l = 0;
      for (let d = 0; d < u.length; d++)
        l += u[d].offsetHeight;
      s(l);
    } catch (u) {
      console.error(u);
    }
  }
  return Dn(() => {
    const a = new MutationObserver(o);
    return a.observe(n.current, { childList: !0, subtree: !0 }), () => a.disconnect();
  }, []), Dn(() => {
    console.log("maxHeight", i);
  }, [i]), /* @__PURE__ */ fe.jsx(
    "div",
    {
      ref: n,
      className: r,
      style: {
        transition: "all 0.2s ease-in-out",
        overflow: "hidden",
        height: i
      },
      children: e
    }
  );
}
function sse() {
  return /* @__PURE__ */ fe.jsxs("svg", { width: "121", height: "120", viewBox: "0 0 121 120", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ fe.jsx("rect", { x: "0.5", width: "120", height: "120", rx: "60", fill: "#404049" }),
    /* @__PURE__ */ fe.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M52.8709 61.106C52.8208 61.4482 52.7948 61.7979 52.7948 62.1535C52.7948 66.2529 56.2445 69.5761 60.5 69.5761C64.7554 69.5761 68.2052 66.2529 68.2052 62.1535C68.2052 61.7979 68.1792 61.4482 68.129 61.106H86.826V77.6174C86.826 78.6422 85.9636 79.473 84.8997 79.473H36.1002C35.0364 79.473 34.174 78.6422 34.174 77.6174V61.106H52.8709Z", fill: "#252532" }),
    /* @__PURE__ */ fe.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M69.061 60.9416C69.061 65.6697 65.2281 69.5026 60.5 69.5026C55.7719 69.5026 51.939 65.6697 51.939 60.9416C51.939 60.7884 51.943 60.6362 51.951 60.485H33.5L39.7959 41.8696C40.0673 41.0671 40.8202 40.527 41.6674 40.527H79.3326C80.1798 40.527 80.9327 41.0671 81.2041 41.8696L87.5 60.485H69.049C69.057 60.6362 69.061 60.7884 69.061 60.9416Z", fill: "#252532" }),
    /* @__PURE__ */ fe.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M67.8081 61.5708C67.8081 65.2243 64.5361 68.8446 60.4999 68.8446C56.4637 68.8446 53.1918 65.2243 53.1918 61.5708C53.1918 61.4524 53.1952 60.6762 53.202 60.5594H39.4268L44.8013 47.4919C45.033 46.8717 45.6757 46.4543 46.3989 46.4543H74.601C75.3242 46.4543 75.9669 46.8717 76.1986 47.4919L81.5731 60.5594H67.7979C67.8046 60.6762 67.8081 61.4524 67.8081 61.5708Z", fill: "#404049" }),
    /* @__PURE__ */ fe.jsx("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M34.3232 60.6199V78.063C34.3232 78.6995 34.8392 79.2155 35.4757 79.2155H85.5245C86.1609 79.2155 86.6769 78.6995 86.6769 78.063V60.6199L80.4244 42.1328C80.2661 41.6647 79.8269 41.3496 79.3327 41.3496H41.6674C41.1733 41.3496 40.7341 41.6647 40.5758 42.1328L34.3232 60.6199Z", stroke: "#77777D", "stroke-width": "2" }),
    /* @__PURE__ */ fe.jsx("path", { d: "M34.817 60.2823C37.4094 60.2823 48.1095 60.2823 51.1124 60.2823C52.348 60.2823 52.348 61.1507 52.348 61.5994C52.348 65.9638 55.9675 69.5019 60.4323 69.5019C64.8971 69.5019 68.5165 65.9638 68.5165 61.5994C68.5165 61.1507 68.5165 60.2823 69.7521 60.2823H86.1829", stroke: "#77777D", "stroke-width": "2", "stroke-linecap": "round", "stroke-linejoin": "round" })
  ] });
}
function tA(t) {
  const { wallets: e } = mp(), [r, n] = Gt(), i = Ni(() => r ? e.filter((a) => a.key.toLowerCase().includes(r.toLowerCase())) : e, [r]);
  function s(a) {
    t.onSelectWallet(a);
  }
  function o(a) {
    n(a.target.value);
  }
  return /* @__PURE__ */ fe.jsxs(so, { children: [
    /* @__PURE__ */ fe.jsx("div", { className: "xc-mb-6", children: /* @__PURE__ */ fe.jsx(Pc, { title: "Select wallet", onBack: t.onBack }) }),
    /* @__PURE__ */ fe.jsxs("div", { className: "xc-mb-6 xc-flex xc-gap-3 xc-px-4 xc-py-2 xc-border xc-rounded-xl xc-w-full xc-overflow-hidden xc-items-center xc-border-opacity-15 xc-border-white focus-within:xc-border-opacity-40", children: [
      /* @__PURE__ */ fe.jsx(GS, { className: "xc-shrink-0 xc-opacity-50" }),
      /* @__PURE__ */ fe.jsx("input", { type: "text", className: "xc-flex-1 xc-bg-transparent xc-appearance-none xc-outline-none", placeholder: "Search wallet", onInput: o })
    ] }),
    /* @__PURE__ */ fe.jsx("div", { className: "xc-mb-4 xc-flex xc-h-[309px] xc-flex-col xc-gap-4 xc-overflow-scroll no-scrollbar", children: i.length ? i.map((a) => /* @__PURE__ */ fe.jsx(
      x9,
      {
        wallet: a,
        onClick: s
      },
      `feature-${a.key}`
    )) : /* @__PURE__ */ fe.jsx(sse, {}) })
  ] });
}
function voe(t) {
  const { onLogin: e, header: r, showEmailSignIn: n = !0, showMoreWallets: i = !0, showTonConnect: s = !0, showFeaturedWallets: o = !0 } = t, [a, u] = Gt(""), [l, d] = Gt(null), [p, w] = Gt("");
  function A($) {
    d($), u("evm-wallet");
  }
  function P($) {
    u("email"), w($);
  }
  async function N($) {
    await e($);
  }
  function L() {
    u("ton-wallet");
  }
  return Dn(() => {
    u("index");
  }, []), /* @__PURE__ */ fe.jsx(Fne, { config: t.config, children: /* @__PURE__ */ fe.jsxs(eA, { className: "xc-rounded-2xl xc-transition-height xc-box-content xc-w-full xc-min-w-[277px] xc-max-w-[420px] xc-p-6 xc-bg-[rgb(28,28,38)] xc-text-white", children: [
    a === "evm-wallet" && /* @__PURE__ */ fe.jsx(
      aie,
      {
        onBack: () => u("index"),
        onLogin: N,
        wallet: l
      }
    ),
    a === "ton-wallet" && /* @__PURE__ */ fe.jsx(
      ise,
      {
        onBack: () => u("index"),
        onLogin: N
      }
    ),
    a === "email" && /* @__PURE__ */ fe.jsx(jne, { email: p, onBack: () => u("index"), onLogin: N }),
    a === "index" && /* @__PURE__ */ fe.jsx(
      C9,
      {
        header: r,
        onEmailConfirm: P,
        onSelectWallet: A,
        onSelectMoreWallets: () => {
          u("all-wallet");
        },
        onSelectTonConnect: L,
        config: {
          showEmailSignIn: n,
          showFeaturedWallets: o,
          showMoreWallets: i,
          showTonConnect: s
        }
      }
    ),
    a === "all-wallet" && /* @__PURE__ */ fe.jsx(
      tA,
      {
        onBack: () => u("index"),
        onSelectWallet: A
      }
    )
  ] }) });
}
function ose(t) {
  const { wallet: e, onConnect: r } = t, [n, i] = Gt(e.installed ? "connect" : "qr");
  async function s(o, a) {
    r(o, a);
  }
  return /* @__PURE__ */ fe.jsxs(so, { children: [
    /* @__PURE__ */ fe.jsx("div", { className: "mb-6", children: /* @__PURE__ */ fe.jsx(Pc, { title: "Connect wallet", onBack: t.onBack }) }),
    n === "qr" && /* @__PURE__ */ fe.jsx(
      U9,
      {
        wallet: e,
        onGetExtension: () => i("get-extension"),
        onSignFinish: s
      }
    ),
    n === "connect" && /* @__PURE__ */ fe.jsx(
      q9,
      {
        onShowQrCode: () => i("qr"),
        wallet: e,
        onSignFinish: s
      }
    ),
    n === "get-extension" && /* @__PURE__ */ fe.jsx(z9, { wallet: e })
  ] });
}
function ase(t) {
  const { email: e } = t, [r, n] = Gt(0), [i, s] = Gt(!1), [o, a] = Gt(!1), [u, l] = Gt(""), [d, p] = Gt("");
  async function w() {
    n(60);
    const N = setInterval(() => {
      n((L) => L === 0 ? (clearInterval(N), 0) : L - 1);
    }, 1e3);
  }
  async function A(N) {
    a(!0);
    try {
      l(""), await qo.getEmailCode({ account_type: "email", email: N }), w();
    } catch (L) {
      l(L.message);
    }
    a(!1);
  }
  Dn(() => {
    e && A(e);
  }, [e]);
  async function P(N) {
    if (p(""), !(N.length < 6)) {
      s(!0);
      try {
        await t.onInputCode(e, N);
      } catch (L) {
        p(L.message);
      }
      s(!1);
    }
  }
  return /* @__PURE__ */ fe.jsxs(so, { children: [
    /* @__PURE__ */ fe.jsxs("div", { className: "xc-flex xc-flex-col xc-items-center xc-justify-center xc-mb-12", children: [
      /* @__PURE__ */ fe.jsx(VS, { className: "xc-mb-4", size: 60 }),
      /* @__PURE__ */ fe.jsx("div", { className: "xc-flex xc-flex-col xc-items-center xc-justify-center xc-mb-8 xc-h-16", children: u ? /* @__PURE__ */ fe.jsx("div", { className: "xc-text-[#ff0000] xc-text-center", children: /* @__PURE__ */ fe.jsx("p", { className: "xc-px-8", children: u }) }) : o ? /* @__PURE__ */ fe.jsx(_a, { className: "xc-animate-spin" }) : /* @__PURE__ */ fe.jsxs(fe.Fragment, { children: [
        /* @__PURE__ */ fe.jsx("p", { className: "xc-text-lg xc-mb-1", children: "Weve sent a verification code to" }),
        /* @__PURE__ */ fe.jsx("p", { className: "xc-font-bold xc-text-center", children: e })
      ] }) }),
      /* @__PURE__ */ fe.jsx("div", { className: "xc-mb-2 xc-h-12", children: /* @__PURE__ */ fe.jsx(L9, { spinning: i, className: "xc-rounded-xl", children: /* @__PURE__ */ fe.jsx(cy, { maxLength: 6, onChange: P, disabled: i, className: "disabled:xc-opacity-20", children: /* @__PURE__ */ fe.jsx(uy, { children: /* @__PURE__ */ fe.jsxs("div", { className: Js("xc-flex xc-gap-2", i ? "xc-opacity-20" : ""), children: [
        /* @__PURE__ */ fe.jsx(Ri, { index: 0 }),
        /* @__PURE__ */ fe.jsx(Ri, { index: 1 }),
        /* @__PURE__ */ fe.jsx(Ri, { index: 2 }),
        /* @__PURE__ */ fe.jsx(Ri, { index: 3 }),
        /* @__PURE__ */ fe.jsx(Ri, { index: 4 }),
        /* @__PURE__ */ fe.jsx(Ri, { index: 5 })
      ] }) }) }) }) }),
      d && /* @__PURE__ */ fe.jsx("div", { className: "xc-text-[#ff0000] xc-text-center", children: /* @__PURE__ */ fe.jsx("p", { children: d }) })
    ] }),
    /* @__PURE__ */ fe.jsxs("div", { className: "xc-text-center xc-text-sm xc-text-gray-400", children: [
      "Not get it? ",
      r ? `Recend in ${r}s` : /* @__PURE__ */ fe.jsx("button", { onClick: () => A(e), children: "Send again" })
    ] })
  ] });
}
function cse(t) {
  const { email: e } = t;
  return /* @__PURE__ */ fe.jsxs(so, { children: [
    /* @__PURE__ */ fe.jsx("div", { className: "xc-mb-12", children: /* @__PURE__ */ fe.jsx(Pc, { title: "Sign in with email", onBack: t.onBack }) }),
    /* @__PURE__ */ fe.jsx(ase, { email: e, onInputCode: t.onInputCode })
  ] });
}
function boe(t) {
  const { onEvmWalletConnect: e, onTonWalletConnect: r, onEmailConnect: n, config: i = {
    showEmailSignIn: !1,
    showFeaturedWallets: !0,
    showMoreWallets: !0,
    showTonConnect: !0
  } } = t, [s, o] = Gt(""), [a, u] = Gt(), [l, d] = Gt(), p = oi(), [w, A] = Gt("");
  function P(H) {
    u(H), o("evm-wallet-connect");
  }
  function N(H) {
    A(H), o("email-connect");
  }
  async function L(H, W) {
    await e({
      chain_type: "eip155",
      client: H.client,
      connect_info: W
    }), o("index");
  }
  function $(H) {
    d(H), o("ton-wallet-connect");
  }
  async function B(H) {
    H && await r({
      chain_type: "ton",
      client: p.current,
      connect_info: H
    });
  }
  return Dn(() => {
    p.current = new fh({
      manifestUrl: "https://static.codatta.io/static/tonconnect-manifest.json?v=2"
    });
    const H = p.current.onStatusChange(B);
    return o("index"), H;
  }, []), /* @__PURE__ */ fe.jsxs(eA, { className: "xc-rounded-2xl xc-transition-height xc-box-content xc-w-full xc-min-w-[277px] xc-max-w-[420px] xc-p-6 xc-bg-[rgb(28,28,38)] xc-text-white", children: [
    s === "evm-wallet-select" && /* @__PURE__ */ fe.jsx(
      tA,
      {
        onBack: () => o("index"),
        onSelectWallet: P
      }
    ),
    s === "evm-wallet-connect" && /* @__PURE__ */ fe.jsx(
      ose,
      {
        onBack: () => o("index"),
        onConnect: L,
        wallet: a
      }
    ),
    s === "ton-wallet-select" && /* @__PURE__ */ fe.jsx(
      W9,
      {
        connector: p.current,
        onSelect: $,
        onBack: () => o("index")
      }
    ),
    s === "ton-wallet-connect" && /* @__PURE__ */ fe.jsx(
      Q9,
      {
        connector: p.current,
        wallet: l,
        onBack: () => o("index")
      }
    ),
    s === "email-connect" && /* @__PURE__ */ fe.jsx(cse, { email: w, onBack: () => o("index"), onInputCode: n }),
    s === "index" && /* @__PURE__ */ fe.jsx(
      C9,
      {
        onEmailConfirm: N,
        onSelectWallet: P,
        onSelectMoreWallets: () => o("evm-wallet-select"),
        onSelectTonConnect: () => o("ton-wallet-select"),
        config: i
      }
    )
  ] });
}
export {
  goe as C,
  T5 as H,
  oZ as a,
  Ll as b,
  dse as c,
  voe as d,
  Hd as e,
  boe as f,
  hse as h,
  pse as r,
  i4 as s,
  C0 as t,
  mp as u
};
